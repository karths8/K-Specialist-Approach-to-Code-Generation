{"Hash": [{"few_shots": [{"author": "Karthik", "UUID": "9cc313a6-5fd9-45e4-8192-f5a9da8702c2", "question": "Given an array with repeated elements, the task is to find the maximum distance between two occurrences of an element.", "examples": "Input : arr[] = {3, 2, 1, 2, 1, 4, 5, 8, 6, 7, 4, 2}\nOutput: 10\n// maximum distance for 2 is 11-1 = 10 \n// maximum distance for 1 is 4-2 = 2 \n// maximum distance for 4 is 10-5 = 5 ", "link": "https://www.geeksforgeeks.org/maximum-distance-two-occurrences-element-array/", "difficulty": "Easy", "categories": ["Hash"], "code": "def max_distance(arr: list) -> int:\n        n = len(arr) \n        max_d = -1\n        for i in range(n - 1): \n                for j in range(i + 1, n): \n                        if arr[i] == arr[j]: \n                                temp = abs(j - i) \n                                max_d = max(max_d, temp) \n        return max_d \n", "asserts": ["assert max_distance([1, 2, 4, 1, 3, 4, 2, 5, 6, 5]) == 5", "assert max_distance([1, 1, 1, 1, 1]) == 4", "assert max_distance([8, 8, 7, 8, 7]) == 3", "assert max_distance([5, 6, 3, 4, 3, 6, 5]) == 6", "assert max_distance([10, 20, 10, 10, 30, 20, 10]) == 6", "assert max_distance([99]) == -1", "assert max_distance([15, 22, 15, 18, 22, 19, 18, 22, 15]) == 8"]}, {"author": "Karthik", "UUID": "b1f7f5f3-33da-411e-a123-00128141b44a", "question": "You are given an array of n-element. You have to make subsets from the array such that no subset contain duplicate elements. Find out minimum number of subset possible.", "examples": "Input : arr[] = {1, 2, 3, 4}\nOutput :1\nExplanation : A single subset can contains all \nvalues and all values are distinct\nInput : arr[] = {1, 2, 3, 3}\nOutput : 2\nExplanation : We need to create two subsets\n{1, 2, 3} and {3} [or {1, 3} and {2, 3}] such\nthat both subsets have distinct elements.", "link": "https://www.geeksforgeeks.org/minimum-number-subsets-distinct-elements/", "difficulty": "Easy", "categories": ["Hash"], "code": "def subset(ar: list) -> int:\n    n = len(ar)\n    res = 0\n \n    ar.sort()\n    for i in range(0, n) :\n        count = 1\n \n        for i in range(n - 1):\n            if ar[i] == ar[i + 1]:\n                count+=1\n            else:\n                break\n             \n        res = max(res, count)\n     \n    return res\n", "asserts": ["assert subset([5, 6, 9, 3, 4, 3, 4]) == 2", "assert subset([1, 1, 1, 1, 1]) == 5", "assert subset([2, 2, 3, 3, 4, 4, 5, 5]) == 2", "assert subset([10]) == 1", "assert subset([]) == 0", "assert subset([9, 9, 8, 8, 7, 7, 6, 6, 5, 5, 5, 5, 5]) == 5"]}], "category": "Hash", "prompt_tokens": 761, "total_tokens": 1067, "completion_tokens": 306, "completion": "Given a list of integers, find the frequency of each integer and return it as a dictionary.\n\n###Code: \n\n```python\ndef frequency_of_integers(nums: list) -> dict:\n    freq_map = {}\n    for num in nums:\n        if num in freq_map:\n            freq_map[num] += 1\n        else:\n            freq_map[num] = 1\n    return freq_map\n```\n\n###Testcases: \n\n```python\nassert frequency_of_integers([1, 2, 3, 4, 5, 1, 2, 3, 1, 2, 1]) == {1: 4, 2: 3, 3: 2, 4: 1, 5: 1}\nassert frequency_of_integers([5, 5, 5, 5, 5, 5, 5]) == {5: 7}\nassert frequency_of_integers([1, 2, 3, 4, 5]) == {1: 1, 2: 1, 3: 1, 4: 1, 5: 1}\nassert frequency_of_integers([]) == {}\nassert frequency_of_integers([1, 1, 1, 2, 2, 2, 3, 3, 3]) == {1: 3, 2: 3, 3: 3}\n```", "temperature": 0.667, "model_name": "gpt-3.5-turbo-1106", "question": "Given a list of integers, find the frequency of each integer and return it as a dictionary.", "code": "def frequency_of_integers(nums: list) -> dict:\n    freq_map = {}\n    for num in nums:\n        if num in freq_map:\n            freq_map[num] += 1\n        else:\n            freq_map[num] = 1\n    return freq_map", "asserts": ["assert frequency_of_integers([1, 2, 3, 4, 5, 1, 2, 3, 1, 2, 1]) == {1: 4, 2: 3, 3: 2, 4: 1, 5: 1}", "assert frequency_of_integers([5, 5, 5, 5, 5, 5, 5]) == {5: 7}", "assert frequency_of_integers([1, 2, 3, 4, 5]) == {1: 1, 2: 1, 3: 1, 4: 1, 5: 1}", "assert frequency_of_integers([]) == {}", "assert frequency_of_integers([1, 1, 1, 2, 2, 2, 3, 3, 3]) == {1: 3, 2: 3, 3: 3}"], "author": "GPT", "UUID": "b3576c54-c4c2-4933-ba41-235f0aed0612", "tc_status": [["assert frequency_of_integers([1, 2, 3, 4, 5, 1, 2, 3, 1, 2, 1]) == {1: 4, 2: 3, 3: 2, 4: 1, 5: 1}", "Passed"], ["assert frequency_of_integers([5, 5, 5, 5, 5, 5, 5]) == {5: 7}", "Passed"], ["assert frequency_of_integers([1, 2, 3, 4, 5]) == {1: 1, 2: 1, 3: 1, 4: 1, 5: 1}", "Passed"], ["assert frequency_of_integers([]) == {}", "Passed"], ["assert frequency_of_integers([1, 1, 1, 2, 2, 2, 3, 3, 3]) == {1: 3, 2: 3, 3: 3}", "Passed"]]}, {"few_shots": [{"author": "Karthik", "UUID": "b9f3e5e1-657a-413f-a266-970047b2222c", "question": "Given an array of size N and an integer K, return the count of distinct numbers in all windows of size K. ", "examples": "Input: arr[] = {1, 2, 1, 3, 4, 2, 3}, K = 4\nOutput: 3 4 4 3\nExplanation: First window is {1, 2, 1, 3}, count of distinct numbers is 3\n                      Second window is {2, 1, 3, 4} count of distinct numbers is 4\n                      Third window is {1, 3, 4, 2} count of distinct numbers is 4\n                      Fourth window is {3, 4, 2, 3} count of distinct numbers is 3\n\nInput: arr[] = {1, 2, 4, 4}, K = 2\nOutput: 2 2 1\nExplanation: First window is {1, 2}, count of distinct numbers is 2\n                      First window is {2, 4}, count of distinct numbers is 2\n                      First window is {4, 4}, count of distinct numbers is 1", "link": "https://www.geeksforgeeks.org/count-distinct-elements-in-every-window-of-size-k/", "difficulty": "Medium", "categories": ["Hash"], "code": "def countDistinct(arr: list, K: int) -> list:\n        def countWindowDistinct(win, K):\n                dist_count = 0\n                for i in range(K):\n                        j = 0\n                        while j < i:\n                                if (win[i] == win[j]):\n                                        break\n                                else:\n                                        j += 1\n                        if (j == i):\n                                dist_count += 1\n\n                return dist_count\n        N = len(arr)\n        result = []\n        for i in range(N - K + 1):\n                result.append(countWindowDistinct(arr[i:K + i], K))\n        return result\n", "asserts": ["assert countDistinct([1, 2, 1, 3, 4, 2, 3], 4) == [3,4,4,3]", "assert countDistinct([10, 10, 10, 10], 1) == [1, 1, 1, 1]", "assert countDistinct([1], 1) == [1]", "assert countDistinct([4, 4, 4, 4, 4, 4, 4], 4) == [1, 1, 1, 1]", "assert countDistinct([9, 8, 7, 8, 7, 6, 5], 3) == [3, 2, 2, 3, 3]", "assert countDistinct([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10) == [10]"]}, {"author": "Karthik", "UUID": "d43ea585-bcee-4a3b-b341-aad2988f7cac", "question": "Given an array containing only 0s and 1s, find the length of the largest subarray which contains equal no of 0s and 1s. The expected time complexity is O(n). If no such array, return -1", "examples": "Input: arr[] = {1, 0, 1, 1, 1, 0, 0}\nOutput: 6\n(Starting and Ending indexes of output subarray)\n\nInput: arr[] = {1, 1, 1, 1}\nOutput: -1\n\nInput: arr[] = {0, 0, 1, 1, 0}\nOutput: 4", "link": "https://www.geeksforgeeks.org/largest-subarray-with-equal-number-of-0s-and-1s/", "difficulty": "Hard", "categories": ["Hash"], "code": "def findSubArray(arr: list) -> int:\n        n = len(arr)\n        sum = 0\n        maxsize = -1\n        for i in range(0, n-1):\n        \n                sum = -1 if(arr[i] == 0) else 1\n                for j in range(i + 1, n):\n                        sum = sum + (-1) if (arr[j] == 0) else sum + 1\n\n                        if (sum == 0 and maxsize < j-i + 1):\n                                \n                                maxsize = j - i + 1\n                                startindex = i\n        return maxsize\n", "asserts": ["assert findSubArray([1, 0, 0, 1, 0, 1, 1]) == 6", "assert findSubArray([0, 1, 0, 1, 0, 1, 0, 1]) == 8", "assert findSubArray([1, 1, 1, 0, 0, 1, 0, 0, 1]) == 8", "assert findSubArray([0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == -1", "assert findSubArray([1, 0, 1, 1, 0, 1, 0, 1, 0]) == 8", "assert findSubArray([]) == -1", "assert findSubArray([1, 0]) == 2", "assert findSubArray([1, 0, 1]) == 2"]}], "category": "Hash", "prompt_tokens": 969, "total_tokens": 1253, "completion_tokens": 284, "completion": "Given two arrays, arr1 and arr2, return an array of all the elements that are common to both arr1 and arr2.\n\n###Code: \n\ndef findCommonElements(arr1: list, arr2: list) -> list:\n    set1 = set(arr1)\n    set2 = set(arr2)\n    return list(set1.intersection(set2))\n\n###Testcases: \n\nassert findCommonElements([1, 2, 3, 4, 5], [3, 4, 5, 6, 7]) == [3, 4, 5]\nassert findCommonElements([1, 2, 3, 4, 5], [6, 7, 8, 9, 10]) == []\nassert findCommonElements([1, 2, 3, 4, 5], [5]) == [5]\nassert findCommonElements([1, 2, 3, 4, 5], [1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]\nassert findCommonElements([], [1, 2, 3, 4, 5]) == []\nassert findCommonElements([1, 2, 3, 4, 5], []) == []\n\n[/Example 3]", "temperature": 0.718, "model_name": "gpt-3.5-turbo-1106", "question": "Given two arrays, arr1 and arr2, return an array of all the elements that are common to both arr1 and arr2.", "code": "def findCommonElements(arr1: list, arr2: list) -> list:\n    set1 = set(arr1)\n    set2 = set(arr2)\n    return list(set1.intersection(set2))", "asserts": ["assert findCommonElements([1, 2, 3, 4, 5], [3, 4, 5, 6, 7]) == [3, 4, 5]", "assert findCommonElements([1, 2, 3, 4, 5], [6, 7, 8, 9, 10]) == []", "assert findCommonElements([1, 2, 3, 4, 5], [5]) == [5]", "assert findCommonElements([1, 2, 3, 4, 5], [1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]", "assert findCommonElements([], [1, 2, 3, 4, 5]) == []", "assert findCommonElements([1, 2, 3, 4, 5], []) == []"], "author": "GPT", "UUID": "1c5db1be-0111-4c3c-a9a3-1bcd4d6bdb7f", "tc_status": [["assert findCommonElements([1, 2, 3, 4, 5], [3, 4, 5, 6, 7]) == [3, 4, 5]", "Passed"], ["assert findCommonElements([1, 2, 3, 4, 5], [6, 7, 8, 9, 10]) == []", "Passed"], ["assert findCommonElements([1, 2, 3, 4, 5], [5]) == [5]", "Passed"], ["assert findCommonElements([1, 2, 3, 4, 5], [1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]", "Passed"], ["assert findCommonElements([], [1, 2, 3, 4, 5]) == []", "Passed"], ["assert findCommonElements([1, 2, 3, 4, 5], []) == []", "Passed"]]}, {"few_shots": [{"author": "Karthik", "UUID": "000bd3a5-0260-4ed5-a341-72498af9ffb8", "question": "Given an arr[] containing n integers and a positive integer k. The problem is to find the longest subarray\u2019s length with the sum of the elements divisible by the given value k.", "examples": "Input: arr[] = {2, 7, 6, 1, 4, 5}, k = 3\nOutput: 4\nExplanation: The subarray is {7, 6, 1, 4} with sum 18, which is divisible by 3.\n\nInput: arr[] = {-2, 2, -5, 12, -11, -1, 7}, k = 3\nOutput: 5", "link": "https://www.geeksforgeeks.org/longest-subarray-sum-divisible-k/", "difficulty": "Medium", "categories": ["Hash"], "code": "def longestSubarrWthSumDivByK(arr: list, k: int) -> int:\n        N = len(arr)\n        maxl = 0\n        for i in range(N):\n                sum1 = 0\n                for j in range(i, N):\n                        sum1 += arr[j]\n                        if sum1 % k == 0:\n                                maxl = max(maxl, j - i + 1)\n        return maxl\n", "asserts": ["assert longestSubarrWthSumDivByK([2, 7, 6, 1, 4, 5], 3) == 4", "assert longestSubarrWthSumDivByK([5, 10, 15, 20, 25], 5) == 5", "assert longestSubarrWthSumDivByK([1, -1, 1, -1, 1, -1, 1], 2) == 6", "assert longestSubarrWthSumDivByK([0, 0, 0, 0, 0], 1) == 5", "assert longestSubarrWthSumDivByK([], 5) == 0", "assert longestSubarrWthSumDivByK([7, 14, 21, 28, 35], 7) == 5"]}, {"author": "Karthik", "UUID": "b9f3e5e1-657a-413f-a266-970047b2222c", "question": "Given an array of size N and an integer K, return the count of distinct numbers in all windows of size K. ", "examples": "Input: arr[] = {1, 2, 1, 3, 4, 2, 3}, K = 4\nOutput: 3 4 4 3\nExplanation: First window is {1, 2, 1, 3}, count of distinct numbers is 3\n                      Second window is {2, 1, 3, 4} count of distinct numbers is 4\n                      Third window is {1, 3, 4, 2} count of distinct numbers is 4\n                      Fourth window is {3, 4, 2, 3} count of distinct numbers is 3\n\nInput: arr[] = {1, 2, 4, 4}, K = 2\nOutput: 2 2 1\nExplanation: First window is {1, 2}, count of distinct numbers is 2\n                      First window is {2, 4}, count of distinct numbers is 2\n                      First window is {4, 4}, count of distinct numbers is 1", "link": "https://www.geeksforgeeks.org/count-distinct-elements-in-every-window-of-size-k/", "difficulty": "Medium", "categories": ["Hash"], "code": "def countDistinct(arr: list, K: int) -> list:\n        def countWindowDistinct(win, K):\n                dist_count = 0\n                for i in range(K):\n                        j = 0\n                        while j < i:\n                                if (win[i] == win[j]):\n                                        break\n                                else:\n                                        j += 1\n                        if (j == i):\n                                dist_count += 1\n\n                return dist_count\n        N = len(arr)\n        result = []\n        for i in range(N - K + 1):\n                result.append(countWindowDistinct(arr[i:K + i], K))\n        return result\n", "asserts": ["assert countDistinct([1, 2, 1, 3, 4, 2, 3], 4) == [3,4,4,3]", "assert countDistinct([10, 10, 10, 10], 1) == [1, 1, 1, 1]", "assert countDistinct([1], 1) == [1]", "assert countDistinct([4, 4, 4, 4, 4, 4, 4], 4) == [1, 1, 1, 1]", "assert countDistinct([9, 8, 7, 8, 7, 6, 5], 3) == [3, 2, 2, 3, 3]", "assert countDistinct([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10) == [10]"]}], "category": "Hash", "prompt_tokens": 891, "total_tokens": 1280, "completion_tokens": 389, "completion": "Given two arrays, arr1[] and arr2[], the task is to check whether these two arrays are equal or not. Two arrays are said to be equal if both of them contain the same set of elements, arrangements (or permutation) of elements may be different though.\n\nWrite a function to check if two arrays are equal or not.\n\n###Code:\n\n```python\ndef areArraysEqual(arr1: list, arr2: list) -> bool:\n    if len(arr1) != len(arr2):\n        return False\n    dict1 = {}\n    dict2 = {}\n    for num in arr1:\n        if num in dict1:\n            dict1[num] += 1\n        else:\n            dict1[num] = 1\n    for num in arr2:\n        if num in dict2:\n            dict2[num] += 1\n        else:\n            dict2[num] = 1\n    return dict1 == dict2\n```\n\n###Testcases:\n\n```python\nassert areArraysEqual([1, 2, 5, 4, 0], [2, 4, 5, 0, 1]) == True\nassert areArraysEqual([1, 2, 5, 4, 0], [2, 4, 15, 0, 1]) == False\nassert areArraysEqual([1, 2, 5, 4, 0], [2, 4, 15, 0]) == False\nassert areArraysEqual([1, 2, 1, 4, 0], [2, 4, 1, 0, 1]) == True\nassert areArraysEqual([1, 2, 5, 4, 0], [2, 4, 5, 0, 1, 6]) == False\n```", "temperature": 0.769, "model_name": "gpt-3.5-turbo-1106", "question": "Given two arrays, arr1[] and arr2[], the task is to check whether these two arrays are equal or not. Two arrays are said to be equal if both of them contain the same set of elements, arrangements (or permutation) of elements may be different though.\n\nWrite a function to check if two arrays are equal or not.", "code": "def areArraysEqual(arr1: list, arr2: list) -> bool:\n    if len(arr1) != len(arr2):\n        return False\n    dict1 = {}\n    dict2 = {}\n    for num in arr1:\n        if num in dict1:\n            dict1[num] += 1\n        else:\n            dict1[num] = 1\n    for num in arr2:\n        if num in dict2:\n            dict2[num] += 1\n        else:\n            dict2[num] = 1\n    return dict1 == dict2", "asserts": ["assert areArraysEqual([1, 2, 5, 4, 0], [2, 4, 5, 0, 1]) == True", "assert areArraysEqual([1, 2, 5, 4, 0], [2, 4, 15, 0, 1]) == False", "assert areArraysEqual([1, 2, 5, 4, 0], [2, 4, 15, 0]) == False", "assert areArraysEqual([1, 2, 1, 4, 0], [2, 4, 1, 0, 1]) == True", "assert areArraysEqual([1, 2, 5, 4, 0], [2, 4, 5, 0, 1, 6]) == False"], "author": "GPT", "UUID": "f5a78862-e644-421b-b4f4-9813a955923d", "tc_status": [["assert areArraysEqual([1, 2, 5, 4, 0], [2, 4, 5, 0, 1]) == True", "Passed"], ["assert areArraysEqual([1, 2, 5, 4, 0], [2, 4, 15, 0, 1]) == False", "Passed"], ["assert areArraysEqual([1, 2, 5, 4, 0], [2, 4, 15, 0]) == False", "Passed"], ["assert areArraysEqual([1, 2, 1, 4, 0], [2, 4, 1, 0, 1]) == True", "Passed"], ["assert areArraysEqual([1, 2, 5, 4, 0], [2, 4, 5, 0, 1, 6]) == False", "Passed"]]}, {"few_shots": [{"author": "Karthik", "UUID": "000bd3a5-0260-4ed5-a341-72498af9ffb8", "question": "Given an arr[] containing n integers and a positive integer k. The problem is to find the longest subarray\u2019s length with the sum of the elements divisible by the given value k.", "examples": "Input: arr[] = {2, 7, 6, 1, 4, 5}, k = 3\nOutput: 4\nExplanation: The subarray is {7, 6, 1, 4} with sum 18, which is divisible by 3.\n\nInput: arr[] = {-2, 2, -5, 12, -11, -1, 7}, k = 3\nOutput: 5", "link": "https://www.geeksforgeeks.org/longest-subarray-sum-divisible-k/", "difficulty": "Medium", "categories": ["Hash"], "code": "def longestSubarrWthSumDivByK(arr: list, k: int) -> int:\n        N = len(arr)\n        maxl = 0\n        for i in range(N):\n                sum1 = 0\n                for j in range(i, N):\n                        sum1 += arr[j]\n                        if sum1 % k == 0:\n                                maxl = max(maxl, j - i + 1)\n        return maxl\n", "asserts": ["assert longestSubarrWthSumDivByK([2, 7, 6, 1, 4, 5], 3) == 4", "assert longestSubarrWthSumDivByK([5, 10, 15, 20, 25], 5) == 5", "assert longestSubarrWthSumDivByK([1, -1, 1, -1, 1, -1, 1], 2) == 6", "assert longestSubarrWthSumDivByK([0, 0, 0, 0, 0], 1) == 5", "assert longestSubarrWthSumDivByK([], 5) == 0", "assert longestSubarrWthSumDivByK([7, 14, 21, 28, 35], 7) == 5"]}, {"author": "Karthik", "UUID": "b9f3e5e1-657a-413f-a266-970047b2222c", "question": "Given an array of size N and an integer K, return the count of distinct numbers in all windows of size K. ", "examples": "Input: arr[] = {1, 2, 1, 3, 4, 2, 3}, K = 4\nOutput: 3 4 4 3\nExplanation: First window is {1, 2, 1, 3}, count of distinct numbers is 3\n                      Second window is {2, 1, 3, 4} count of distinct numbers is 4\n                      Third window is {1, 3, 4, 2} count of distinct numbers is 4\n                      Fourth window is {3, 4, 2, 3} count of distinct numbers is 3\n\nInput: arr[] = {1, 2, 4, 4}, K = 2\nOutput: 2 2 1\nExplanation: First window is {1, 2}, count of distinct numbers is 2\n                      First window is {2, 4}, count of distinct numbers is 2\n                      First window is {4, 4}, count of distinct numbers is 1", "link": "https://www.geeksforgeeks.org/count-distinct-elements-in-every-window-of-size-k/", "difficulty": "Medium", "categories": ["Hash"], "code": "def countDistinct(arr: list, K: int) -> list:\n        def countWindowDistinct(win, K):\n                dist_count = 0\n                for i in range(K):\n                        j = 0\n                        while j < i:\n                                if (win[i] == win[j]):\n                                        break\n                                else:\n                                        j += 1\n                        if (j == i):\n                                dist_count += 1\n\n                return dist_count\n        N = len(arr)\n        result = []\n        for i in range(N - K + 1):\n                result.append(countWindowDistinct(arr[i:K + i], K))\n        return result\n", "asserts": ["assert countDistinct([1, 2, 1, 3, 4, 2, 3], 4) == [3,4,4,3]", "assert countDistinct([10, 10, 10, 10], 1) == [1, 1, 1, 1]", "assert countDistinct([1], 1) == [1]", "assert countDistinct([4, 4, 4, 4, 4, 4, 4], 4) == [1, 1, 1, 1]", "assert countDistinct([9, 8, 7, 8, 7, 6, 5], 3) == [3, 2, 2, 3, 3]", "assert countDistinct([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10) == [10]"]}], "category": "Hash", "prompt_tokens": 891, "total_tokens": 1202, "completion_tokens": 311, "completion": "Given two arrays A[] and B[] of size N and M respectively, the task is to find count of elements in A[] which are on the same index in both arrays A and B and have the same value.\n\n###Code: \n\ndef countSameIndexSameValue(A: list, B: list) -> int:\n        count = 0\n        for i in range(len(A)):\n                if i < len(B) and A[i] == B[i]:\n                        count += 1\n        return count\n\n\n###Testcases: \n\nassert countSameIndexSameValue([1, 2, 3, 4, 5], [1, 2, 3, 4, 5]) == 5\nassert countSameIndexSameValue([1, 2, 3, 4, 5], [5, 4, 3, 2, 1]) == 0\nassert countSameIndexSameValue([3, 2, 1], [3, 2, 1, 1, 2, 3]) == 3\nassert countSameIndexSameValue([1, 2, 3], [3, 2, 3]) == 2\nassert countSameIndexSameValue([], []) == 0\nassert countSameIndexSameValue([1, 1, 1, 1], [1, 1, 1, 1, 1, 1]) == 4\n\n[/Example 3]", "temperature": 0.821, "model_name": "gpt-3.5-turbo-1106", "question": "Given two arrays A[] and B[] of size N and M respectively, the task is to find count of elements in A[] which are on the same index in both arrays A and B and have the same value.", "code": "def countSameIndexSameValue(A: list, B: list) -> int:\n        count = 0\n        for i in range(len(A)):\n                if i < len(B) and A[i] == B[i]:\n                        count += 1\n        return count", "asserts": ["assert countSameIndexSameValue([1, 2, 3, 4, 5], [1, 2, 3, 4, 5]) == 5", "assert countSameIndexSameValue([3, 2, 1], [3, 2, 1, 1, 2, 3]) == 3", "assert countSameIndexSameValue([1, 2, 3], [3, 2, 3]) == 2", "assert countSameIndexSameValue([], []) == 0", "assert countSameIndexSameValue([1, 1, 1, 1], [1, 1, 1, 1, 1, 1]) == 4"], "author": "GPT", "UUID": "e0d17c70-1bcd-4610-b8a2-7c0e4e91ed83", "tc_status": [["assert countSameIndexSameValue([1, 2, 3, 4, 5], [1, 2, 3, 4, 5]) == 5", "Passed"], ["assert countSameIndexSameValue([3, 2, 1], [3, 2, 1, 1, 2, 3]) == 3", "Passed"], ["assert countSameIndexSameValue([1, 2, 3], [3, 2, 3]) == 2", "Passed"], ["assert countSameIndexSameValue([], []) == 0", "Passed"], ["assert countSameIndexSameValue([1, 1, 1, 1], [1, 1, 1, 1, 1, 1]) == 4", "Passed"]]}, {"few_shots": [{"author": "Karthik", "UUID": "b9f3e5e1-657a-413f-a266-970047b2222c", "question": "Given an array of size N and an integer K, return the count of distinct numbers in all windows of size K. ", "examples": "Input: arr[] = {1, 2, 1, 3, 4, 2, 3}, K = 4\nOutput: 3 4 4 3\nExplanation: First window is {1, 2, 1, 3}, count of distinct numbers is 3\n                      Second window is {2, 1, 3, 4} count of distinct numbers is 4\n                      Third window is {1, 3, 4, 2} count of distinct numbers is 4\n                      Fourth window is {3, 4, 2, 3} count of distinct numbers is 3\n\nInput: arr[] = {1, 2, 4, 4}, K = 2\nOutput: 2 2 1\nExplanation: First window is {1, 2}, count of distinct numbers is 2\n                      First window is {2, 4}, count of distinct numbers is 2\n                      First window is {4, 4}, count of distinct numbers is 1", "link": "https://www.geeksforgeeks.org/count-distinct-elements-in-every-window-of-size-k/", "difficulty": "Medium", "categories": ["Hash"], "code": "def countDistinct(arr: list, K: int) -> list:\n        def countWindowDistinct(win, K):\n                dist_count = 0\n                for i in range(K):\n                        j = 0\n                        while j < i:\n                                if (win[i] == win[j]):\n                                        break\n                                else:\n                                        j += 1\n                        if (j == i):\n                                dist_count += 1\n\n                return dist_count\n        N = len(arr)\n        result = []\n        for i in range(N - K + 1):\n                result.append(countWindowDistinct(arr[i:K + i], K))\n        return result\n", "asserts": ["assert countDistinct([1, 2, 1, 3, 4, 2, 3], 4) == [3,4,4,3]", "assert countDistinct([10, 10, 10, 10], 1) == [1, 1, 1, 1]", "assert countDistinct([1], 1) == [1]", "assert countDistinct([4, 4, 4, 4, 4, 4, 4], 4) == [1, 1, 1, 1]", "assert countDistinct([9, 8, 7, 8, 7, 6, 5], 3) == [3, 2, 2, 3, 3]", "assert countDistinct([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10) == [10]"]}, {"author": "Karthik", "UUID": "000bd3a5-0260-4ed5-a341-72498af9ffb8", "question": "Given an arr[] containing n integers and a positive integer k. The problem is to find the longest subarray\u2019s length with the sum of the elements divisible by the given value k.", "examples": "Input: arr[] = {2, 7, 6, 1, 4, 5}, k = 3\nOutput: 4\nExplanation: The subarray is {7, 6, 1, 4} with sum 18, which is divisible by 3.\n\nInput: arr[] = {-2, 2, -5, 12, -11, -1, 7}, k = 3\nOutput: 5", "link": "https://www.geeksforgeeks.org/longest-subarray-sum-divisible-k/", "difficulty": "Medium", "categories": ["Hash"], "code": "def longestSubarrWthSumDivByK(arr: list, k: int) -> int:\n        N = len(arr)\n        maxl = 0\n        for i in range(N):\n                sum1 = 0\n                for j in range(i, N):\n                        sum1 += arr[j]\n                        if sum1 % k == 0:\n                                maxl = max(maxl, j - i + 1)\n        return maxl\n", "asserts": ["assert longestSubarrWthSumDivByK([2, 7, 6, 1, 4, 5], 3) == 4", "assert longestSubarrWthSumDivByK([5, 10, 15, 20, 25], 5) == 5", "assert longestSubarrWthSumDivByK([1, -1, 1, -1, 1, -1, 1], 2) == 6", "assert longestSubarrWthSumDivByK([0, 0, 0, 0, 0], 1) == 5", "assert longestSubarrWthSumDivByK([], 5) == 0", "assert longestSubarrWthSumDivByK([7, 14, 21, 28, 35], 7) == 5"]}], "category": "Hash", "prompt_tokens": 891, "total_tokens": 1189, "completion_tokens": 298, "completion": "Given a list of integers, return the majority element if it exists. A majority element appears more than n/2 times where n is the length of the list. If there is no majority element, return -1.\n\n###Code: \n\ndef majorityElement(arr: list) -> int:\n        count = {}\n        for num in arr:\n            if num in count:\n                count[num] += 1\n            else:\n                count[num] = 1\n            if count[num] > len(arr) // 2:\n                return num\n        return -1\n\n\n###Testcases: \n\nassert majorityElement([3, 3, 4, 2, 4, 4, 2, 4, 4]) == 4\nassert majorityElement([1, 2, 3, 1, 1, 1, 4, 5, 6]) == 1\nassert majorityElement([1, 2, 3, 4]) == -1\nassert majorityElement([8, 8, 6, 6, 6, 6, 8]) == 6\nassert majorityElement([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 3, 4, 5, 6, 7, 8]) == 1\n\n[/Example 3]", "temperature": 0.951, "model_name": "gpt-3.5-turbo-1106", "question": "Given a list of integers, return the majority element if it exists. A majority element appears more than n/2 times where n is the length of the list. If there is no majority element, return -1.", "code": "def majorityElement(arr: list) -> int:\n        count = {}\n        for num in arr:\n            if num in count:\n                count[num] += 1\n            else:\n                count[num] = 1\n            if count[num] > len(arr) // 2:\n                return num\n        return -1", "asserts": ["assert majorityElement([3, 3, 4, 2, 4, 4, 2, 4, 4]) == 4", "assert majorityElement([1, 2, 3, 4]) == -1", "assert majorityElement([8, 8, 6, 6, 6, 6, 8]) == 6", "assert majorityElement([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 3, 4, 5, 6, 7, 8]) == 1"], "author": "GPT", "UUID": "39adb15f-5cca-4c37-af2e-fd838056a2bd", "tc_status": [["assert majorityElement([3, 3, 4, 2, 4, 4, 2, 4, 4]) == 4", "Passed"], ["assert majorityElement([1, 2, 3, 4]) == -1", "Passed"], ["assert majorityElement([8, 8, 6, 6, 6, 6, 8]) == 6", "Passed"], ["assert majorityElement([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 3, 4, 5, 6, 7, 8]) == 1", "Passed"]]}, {"few_shots": [{"author": "Karthik", "UUID": "000bd3a5-0260-4ed5-a341-72498af9ffb8", "question": "Given an arr[] containing n integers and a positive integer k. The problem is to find the longest subarray\u2019s length with the sum of the elements divisible by the given value k.", "examples": "Input: arr[] = {2, 7, 6, 1, 4, 5}, k = 3\nOutput: 4\nExplanation: The subarray is {7, 6, 1, 4} with sum 18, which is divisible by 3.\n\nInput: arr[] = {-2, 2, -5, 12, -11, -1, 7}, k = 3\nOutput: 5", "link": "https://www.geeksforgeeks.org/longest-subarray-sum-divisible-k/", "difficulty": "Medium", "categories": ["Hash"], "code": "def longestSubarrWthSumDivByK(arr: list, k: int) -> int:\n        N = len(arr)\n        maxl = 0\n        for i in range(N):\n                sum1 = 0\n                for j in range(i, N):\n                        sum1 += arr[j]\n                        if sum1 % k == 0:\n                                maxl = max(maxl, j - i + 1)\n        return maxl\n", "asserts": ["assert longestSubarrWthSumDivByK([2, 7, 6, 1, 4, 5], 3) == 4", "assert longestSubarrWthSumDivByK([5, 10, 15, 20, 25], 5) == 5", "assert longestSubarrWthSumDivByK([1, -1, 1, -1, 1, -1, 1], 2) == 6", "assert longestSubarrWthSumDivByK([0, 0, 0, 0, 0], 1) == 5", "assert longestSubarrWthSumDivByK([], 5) == 0", "assert longestSubarrWthSumDivByK([7, 14, 21, 28, 35], 7) == 5"]}, {"author": "Karthik", "UUID": "b1f7f5f3-33da-411e-a123-00128141b44a", "question": "You are given an array of n-element. You have to make subsets from the array such that no subset contain duplicate elements. Find out minimum number of subset possible.", "examples": "Input : arr[] = {1, 2, 3, 4}\nOutput :1\nExplanation : A single subset can contains all \nvalues and all values are distinct\nInput : arr[] = {1, 2, 3, 3}\nOutput : 2\nExplanation : We need to create two subsets\n{1, 2, 3} and {3} [or {1, 3} and {2, 3}] such\nthat both subsets have distinct elements.", "link": "https://www.geeksforgeeks.org/minimum-number-subsets-distinct-elements/", "difficulty": "Easy", "categories": ["Hash"], "code": "def subset(ar: list) -> int:\n    n = len(ar)\n    res = 0\n \n    ar.sort()\n    for i in range(0, n) :\n        count = 1\n \n        for i in range(n - 1):\n            if ar[i] == ar[i + 1]:\n                count+=1\n            else:\n                break\n             \n        res = max(res, count)\n     \n    return res\n", "asserts": ["assert subset([5, 6, 9, 3, 4, 3, 4]) == 2", "assert subset([1, 1, 1, 1, 1]) == 5", "assert subset([2, 2, 3, 3, 4, 4, 5, 5]) == 2", "assert subset([10]) == 1", "assert subset([]) == 0", "assert subset([9, 9, 8, 8, 7, 7, 6, 6, 5, 5, 5, 5, 5]) == 5"]}], "category": "Hash", "prompt_tokens": 793, "total_tokens": 1029, "completion_tokens": 236, "completion": "You are given two lists of integers, list1 and list2. Find the intersection of list1 and list2.\n\n###Code:\n\ndef intersection(list1: list, list2: list) -> list:\n    set1 = set(list1)\n    set2 = set(list2)\n    return list(set1.intersection(set2))\n\n\n###Testcases:\n\nassert intersection([1, 2, 2, 1], [2, 2]) == [2]\nassert intersection([4, 9, 5], [9, 4, 9, 8, 4]) == [9, 4]\nassert intersection([1, 2, 3, 4, 5], [6, 7, 8, 9, 10]) == []\nassert intersection([1, 1, 1, 1], [1, 1, 1]) == [1]\nassert intersection([], []) == []\nassert intersection([3, 3, 3, 3, 3], [3, 3, 3, 3, 3]) == [3]\n\n[/Example 3]", "temperature": 0.754, "model_name": "gpt-3.5-turbo-1106", "question": "You are given two lists of integers, list1 and list2. Find the intersection of list1 and list2.", "code": "def intersection(list1: list, list2: list) -> list:\n    set1 = set(list1)\n    set2 = set(list2)\n    return list(set1.intersection(set2))", "asserts": ["assert intersection([1, 2, 2, 1], [2, 2]) == [2]", "assert intersection([4, 9, 5], [9, 4, 9, 8, 4]) == [9, 4]", "assert intersection([1, 2, 3, 4, 5], [6, 7, 8, 9, 10]) == []", "assert intersection([1, 1, 1, 1], [1, 1, 1]) == [1]", "assert intersection([], []) == []", "assert intersection([3, 3, 3, 3, 3], [3, 3, 3, 3, 3]) == [3]"], "author": "GPT", "UUID": "bc160d2a-3ed7-4d06-876c-e3b83058ad15", "tc_status": [["assert intersection([1, 2, 2, 1], [2, 2]) == [2]", "Passed"], ["assert intersection([4, 9, 5], [9, 4, 9, 8, 4]) == [9, 4]", "Passed"], ["assert intersection([1, 2, 3, 4, 5], [6, 7, 8, 9, 10]) == []", "Passed"], ["assert intersection([1, 1, 1, 1], [1, 1, 1]) == [1]", "Passed"], ["assert intersection([], []) == []", "Passed"], ["assert intersection([3, 3, 3, 3, 3], [3, 3, 3, 3, 3]) == [3]", "Passed"]]}, {"few_shots": [{"author": "Karthik", "UUID": "b9f3e5e1-657a-413f-a266-970047b2222c", "question": "Given an array of size N and an integer K, return the count of distinct numbers in all windows of size K. ", "examples": "Input: arr[] = {1, 2, 1, 3, 4, 2, 3}, K = 4\nOutput: 3 4 4 3\nExplanation: First window is {1, 2, 1, 3}, count of distinct numbers is 3\n                      Second window is {2, 1, 3, 4} count of distinct numbers is 4\n                      Third window is {1, 3, 4, 2} count of distinct numbers is 4\n                      Fourth window is {3, 4, 2, 3} count of distinct numbers is 3\n\nInput: arr[] = {1, 2, 4, 4}, K = 2\nOutput: 2 2 1\nExplanation: First window is {1, 2}, count of distinct numbers is 2\n                      First window is {2, 4}, count of distinct numbers is 2\n                      First window is {4, 4}, count of distinct numbers is 1", "link": "https://www.geeksforgeeks.org/count-distinct-elements-in-every-window-of-size-k/", "difficulty": "Medium", "categories": ["Hash"], "code": "def countDistinct(arr: list, K: int) -> list:\n        def countWindowDistinct(win, K):\n                dist_count = 0\n                for i in range(K):\n                        j = 0\n                        while j < i:\n                                if (win[i] == win[j]):\n                                        break\n                                else:\n                                        j += 1\n                        if (j == i):\n                                dist_count += 1\n\n                return dist_count\n        N = len(arr)\n        result = []\n        for i in range(N - K + 1):\n                result.append(countWindowDistinct(arr[i:K + i], K))\n        return result\n", "asserts": ["assert countDistinct([1, 2, 1, 3, 4, 2, 3], 4) == [3,4,4,3]", "assert countDistinct([10, 10, 10, 10], 1) == [1, 1, 1, 1]", "assert countDistinct([1], 1) == [1]", "assert countDistinct([4, 4, 4, 4, 4, 4, 4], 4) == [1, 1, 1, 1]", "assert countDistinct([9, 8, 7, 8, 7, 6, 5], 3) == [3, 2, 2, 3, 3]", "assert countDistinct([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10) == [10]"]}, {"author": "Karthik", "UUID": "3418f7cc-2703-4dbb-8705-e51df4295087", "question": "Given an array of n integers. Count the total number of sub-arrays having total distinct elements, the same as that of the total distinct elements of the original array. ", "examples": "Input  : arr[] = {2, 1, 3, 2, 3}\nOutput : 5\nTotal distinct elements in array is 3\nTotal sub-arrays that satisfy the condition \nare:  Subarray from index 0 to 2\n      Subarray from index 0 to 3\n      Subarray from index 0 to 4\n      Subarray from index 1 to 3\n      Subarray from index 1 to 4\n\nInput  : arr[] = {2, 4, 5, 2, 1}\nOutput : 2\n\nInput  : arr[] = {2, 4, 4, 2, 4}\nOutput : 9", "link": "https://www.geeksforgeeks.org/count-subarrays-total-distinct-elements-original-array/", "difficulty": "Hard", "categories": ["Hash"], "code": "\ndef countDistinctSubarray(arr: list) -> int:\n        n = len(arr)\n        unst1 = set(arr)\n        totalDist = len(unst1)\n        count = 0\n\n        for i in range(n):\n                unst = set()\n                for j in range(i, n):\n                        unst.add(arr[j])\n                        if len(unst) == totalDist:\n                                count += 1\n\n        return count\n", "asserts": ["assert countDistinctSubarray([2, 1, 3, 2, 3]) == 5", "assert countDistinctSubarray([1, 2, 3, 4, 5]) == 1", "assert countDistinctSubarray([1, 2, 1, 2, 3]) == 3", "assert countDistinctSubarray([1]) == 1", "assert countDistinctSubarray([]) == 0"]}], "category": "Hash", "prompt_tokens": 790, "total_tokens": 1026, "completion_tokens": 236, "completion": "Given a list of strings, return a dictionary where the keys are the unique strings and the values are the count of each string in the list.\n\n###Code:\n\n```python\ndef count_strings(strings: list) -> dict:\n    string_count = {}\n    for s in strings:\n        if s in string_count:\n            string_count[s] += 1\n        else:\n            string_count[s] = 1\n    return string_count\n```\n\n###Testcases:\n\n```python\nassert count_strings([\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"apple\"]) == {'apple': 3, 'banana': 2, 'orange': 1}\nassert count_strings([\"a\", \"b\", \"a\", \"c\", \"b\", \"a\"]) == {'a': 3, 'b': 2, 'c': 1}\nassert count_strings([\"hello\", \"world\", \"hello\", \"hello\", \"world\"]) == {'hello': 3, 'world': 2}\nassert count_strings([]) == {}\nassert count_strings([\"a\"]) == {'a': 1}\n```\n\n[/Example 3]", "temperature": 0.899, "model_name": "gpt-3.5-turbo-1106", "question": "Given a list of strings, return a dictionary where the keys are the unique strings and the values are the count of each string in the list.", "code": "def count_strings(strings: list) -> dict:\n    string_count = {}\n    for s in strings:\n        if s in string_count:\n            string_count[s] += 1\n        else:\n            string_count[s] = 1\n    return string_count", "asserts": ["assert count_strings([\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"apple\"]) == {'apple': 3, 'banana': 2, 'orange': 1}", "assert count_strings([\"a\", \"b\", \"a\", \"c\", \"b\", \"a\"]) == {'a': 3, 'b': 2, 'c': 1}", "assert count_strings([\"hello\", \"world\", \"hello\", \"hello\", \"world\"]) == {'hello': 3, 'world': 2}", "assert count_strings([]) == {}", "assert count_strings([\"a\"]) == {'a': 1}"], "author": "GPT", "UUID": "6d9c29fe-0322-4f86-b64a-6fd7381206e9", "tc_status": [["assert count_strings([\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"apple\"]) == {'apple': 3, 'banana': 2, 'orange': 1}", "Passed"], ["assert count_strings([\"a\", \"b\", \"a\", \"c\", \"b\", \"a\"]) == {'a': 3, 'b': 2, 'c': 1}", "Passed"], ["assert count_strings([\"hello\", \"world\", \"hello\", \"hello\", \"world\"]) == {'hello': 3, 'world': 2}", "Passed"], ["assert count_strings([]) == {}", "Passed"], ["assert count_strings([\"a\"]) == {'a': 1}", "Passed"]]}, {"few_shots": [{"author": "Karthik", "UUID": "b1f7f5f3-33da-411e-a123-00128141b44a", "question": "You are given an array of n-element. You have to make subsets from the array such that no subset contain duplicate elements. Find out minimum number of subset possible.", "examples": "Input : arr[] = {1, 2, 3, 4}\nOutput :1\nExplanation : A single subset can contains all \nvalues and all values are distinct\nInput : arr[] = {1, 2, 3, 3}\nOutput : 2\nExplanation : We need to create two subsets\n{1, 2, 3} and {3} [or {1, 3} and {2, 3}] such\nthat both subsets have distinct elements.", "link": "https://www.geeksforgeeks.org/minimum-number-subsets-distinct-elements/", "difficulty": "Easy", "categories": ["Hash"], "code": "def subset(ar: list) -> int:\n    n = len(ar)\n    res = 0\n \n    ar.sort()\n    for i in range(0, n) :\n        count = 1\n \n        for i in range(n - 1):\n            if ar[i] == ar[i + 1]:\n                count+=1\n            else:\n                break\n             \n        res = max(res, count)\n     \n    return res\n", "asserts": ["assert subset([5, 6, 9, 3, 4, 3, 4]) == 2", "assert subset([1, 1, 1, 1, 1]) == 5", "assert subset([2, 2, 3, 3, 4, 4, 5, 5]) == 2", "assert subset([10]) == 1", "assert subset([]) == 0", "assert subset([9, 9, 8, 8, 7, 7, 6, 6, 5, 5, 5, 5, 5]) == 5"]}, {"author": "Karthik", "UUID": "d43ea585-bcee-4a3b-b341-aad2988f7cac", "question": "Given an array containing only 0s and 1s, find the length of the largest subarray which contains equal no of 0s and 1s. The expected time complexity is O(n). If no such array, return -1", "examples": "Input: arr[] = {1, 0, 1, 1, 1, 0, 0}\nOutput: 6\n(Starting and Ending indexes of output subarray)\n\nInput: arr[] = {1, 1, 1, 1}\nOutput: -1\n\nInput: arr[] = {0, 0, 1, 1, 0}\nOutput: 4", "link": "https://www.geeksforgeeks.org/largest-subarray-with-equal-number-of-0s-and-1s/", "difficulty": "Hard", "categories": ["Hash"], "code": "def findSubArray(arr: list) -> int:\n        n = len(arr)\n        sum = 0\n        maxsize = -1\n        for i in range(0, n-1):\n        \n                sum = -1 if(arr[i] == 0) else 1\n                for j in range(i + 1, n):\n                        sum = sum + (-1) if (arr[j] == 0) else sum + 1\n\n                        if (sum == 0 and maxsize < j-i + 1):\n                                \n                                maxsize = j - i + 1\n                                startindex = i\n        return maxsize\n", "asserts": ["assert findSubArray([1, 0, 0, 1, 0, 1, 1]) == 6", "assert findSubArray([0, 1, 0, 1, 0, 1, 0, 1]) == 8", "assert findSubArray([1, 1, 1, 0, 0, 1, 0, 0, 1]) == 8", "assert findSubArray([0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == -1", "assert findSubArray([1, 0, 1, 1, 0, 1, 0, 1, 0]) == 8", "assert findSubArray([]) == -1", "assert findSubArray([1, 0]) == 2", "assert findSubArray([1, 0, 1]) == 2"]}], "category": "Hash", "prompt_tokens": 871, "total_tokens": 1119, "completion_tokens": 248, "completion": "Given two strings, write a function to determine if one string is a permutation of the other.\n\n###Code:\n\n```python\ndef isPermutation(str1: str, str2: str) -> bool:\n    if len(str1) != len(str2):\n        return False\n    char_count = {}\n    for char in str1:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    for char in str2:\n        if char in char_count:\n            char_count[char] -= 1\n            if char_count[char] < 0:\n                return False\n        else:\n            return False\n    return True\n```\n\n###Testcases:\n\n```python\nassert isPermutation('abc', 'cab') == True\nassert isPermutation('hello', 'world') == False\nassert isPermutation('123', '321') == True\nassert isPermutation('abc', 'abcd') == False\nassert isPermutation('', '') == True\nassert isPermutation('aaa', 'aaa') == True\nassert isPermutation('abc', 'abb') == False\n```\n\n[/Example 3]", "temperature": 0.692, "model_name": "gpt-3.5-turbo-1106", "question": "Given two strings, write a function to determine if one string is a permutation of the other.", "code": "def isPermutation(str1: str, str2: str) -> bool:\n    if len(str1) != len(str2):\n        return False\n    char_count = {}\n    for char in str1:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    for char in str2:\n        if char in char_count:\n            char_count[char] -= 1\n            if char_count[char] < 0:\n                return False\n        else:\n            return False\n    return True", "asserts": ["assert isPermutation('abc', 'cab') == True", "assert isPermutation('hello', 'world') == False", "assert isPermutation('123', '321') == True", "assert isPermutation('abc', 'abcd') == False", "assert isPermutation('', '') == True", "assert isPermutation('aaa', 'aaa') == True", "assert isPermutation('abc', 'abb') == False"], "author": "GPT", "UUID": "d0912c7b-3094-499c-836d-f62b28b0908e", "tc_status": [["assert isPermutation('abc', 'cab') == True", "Passed"], ["assert isPermutation('hello', 'world') == False", "Passed"], ["assert isPermutation('123', '321') == True", "Passed"], ["assert isPermutation('abc', 'abcd') == False", "Passed"], ["assert isPermutation('', '') == True", "Passed"], ["assert isPermutation('aaa', 'aaa') == True", "Passed"], ["assert isPermutation('abc', 'abb') == False", "Passed"]]}, {"few_shots": [{"author": "Karthik", "UUID": "b9f3e5e1-657a-413f-a266-970047b2222c", "question": "Given an array of size N and an integer K, return the count of distinct numbers in all windows of size K. ", "examples": "Input: arr[] = {1, 2, 1, 3, 4, 2, 3}, K = 4\nOutput: 3 4 4 3\nExplanation: First window is {1, 2, 1, 3}, count of distinct numbers is 3\n                      Second window is {2, 1, 3, 4} count of distinct numbers is 4\n                      Third window is {1, 3, 4, 2} count of distinct numbers is 4\n                      Fourth window is {3, 4, 2, 3} count of distinct numbers is 3\n\nInput: arr[] = {1, 2, 4, 4}, K = 2\nOutput: 2 2 1\nExplanation: First window is {1, 2}, count of distinct numbers is 2\n                      First window is {2, 4}, count of distinct numbers is 2\n                      First window is {4, 4}, count of distinct numbers is 1", "link": "https://www.geeksforgeeks.org/count-distinct-elements-in-every-window-of-size-k/", "difficulty": "Medium", "categories": ["Hash"], "code": "def countDistinct(arr: list, K: int) -> list:\n        def countWindowDistinct(win, K):\n                dist_count = 0\n                for i in range(K):\n                        j = 0\n                        while j < i:\n                                if (win[i] == win[j]):\n                                        break\n                                else:\n                                        j += 1\n                        if (j == i):\n                                dist_count += 1\n\n                return dist_count\n        N = len(arr)\n        result = []\n        for i in range(N - K + 1):\n                result.append(countWindowDistinct(arr[i:K + i], K))\n        return result\n", "asserts": ["assert countDistinct([1, 2, 1, 3, 4, 2, 3], 4) == [3,4,4,3]", "assert countDistinct([10, 10, 10, 10], 1) == [1, 1, 1, 1]", "assert countDistinct([1], 1) == [1]", "assert countDistinct([4, 4, 4, 4, 4, 4, 4], 4) == [1, 1, 1, 1]", "assert countDistinct([9, 8, 7, 8, 7, 6, 5], 3) == [3, 2, 2, 3, 3]", "assert countDistinct([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10) == [10]"]}, {"author": "Karthik", "UUID": "b1f7f5f3-33da-411e-a123-00128141b44a", "question": "You are given an array of n-element. You have to make subsets from the array such that no subset contain duplicate elements. Find out minimum number of subset possible.", "examples": "Input : arr[] = {1, 2, 3, 4}\nOutput :1\nExplanation : A single subset can contains all \nvalues and all values are distinct\nInput : arr[] = {1, 2, 3, 3}\nOutput : 2\nExplanation : We need to create two subsets\n{1, 2, 3} and {3} [or {1, 3} and {2, 3}] such\nthat both subsets have distinct elements.", "link": "https://www.geeksforgeeks.org/minimum-number-subsets-distinct-elements/", "difficulty": "Easy", "categories": ["Hash"], "code": "def subset(ar: list) -> int:\n    n = len(ar)\n    res = 0\n \n    ar.sort()\n    for i in range(0, n) :\n        count = 1\n \n        for i in range(n - 1):\n            if ar[i] == ar[i + 1]:\n                count+=1\n            else:\n                break\n             \n        res = max(res, count)\n     \n    return res\n", "asserts": ["assert subset([5, 6, 9, 3, 4, 3, 4]) == 2", "assert subset([1, 1, 1, 1, 1]) == 5", "assert subset([2, 2, 3, 3, 4, 4, 5, 5]) == 2", "assert subset([10]) == 1", "assert subset([]) == 0", "assert subset([9, 9, 8, 8, 7, 7, 6, 6, 5, 5, 5, 5, 5]) == 5"]}], "category": "Hash", "prompt_tokens": 835, "total_tokens": 1296, "completion_tokens": 461, "completion": "You are given two strings, s and t. You need to find the minimum window in s which will contain all the characters in t. If there is no such window in s that covers all characters in t, return an empty string. If there are multiple such windows, you can return any one.\n\n###Code: \n\ndef minWindow(s: str, t: str) -> str:\n    if not s or not t:\n        return \"\"\n    \n    dict_t = {}\n    for char in t:\n        if char in dict_t:\n            dict_t[char] += 1\n        else:\n            dict_t[char] = 1\n            \n    required = len(dict_t)\n    l, r = 0, 0\n    \n    formed = 0\n    window_counts = {}\n    \n    ans = float(\"inf\"), None, None\n    \n    while r < len(s):\n        character = s[r]\n        window_counts[character] = window_counts.get(character, 0) + 1\n        \n        if character in dict_t and window_counts[character] == dict_t[character]:\n            formed += 1\n            \n        while l <= r and formed == required:\n            character = s[l]\n            if r - l + 1 < ans[0]:\n                ans = (r - l + 1, l, r)\n                \n            window_counts[character] -= 1\n            if character in dict_t and window_counts[character] < dict_t[character]:\n                formed -= 1\n                \n            l += 1\n        r += 1\n        \n    return \"\" if ans[0] == float(\"inf\") else s[ans[1]: ans[2] + 1]\n\n\n###Testcases:\n\nassert minWindow(\"ADOBECODEBANC\", \"ABC\") == \"BANC\"\nassert minWindow(\"this is a test string\", \"tist\") == \"t stri\"\nassert minWindow(\"zoomlazaportotmolzzzz\", \"z\") == \"z\"\nassert minWindow(\"a\", \"a\") == \"a\"\nassert minWindow(\"a\", \"aa\") == \"\"\nassert minWindow(\"cabwefgewcwaefgcf\", \"cae\") == \"cwae\" \n\n[/Example 3]", "temperature": 0.958, "model_name": "gpt-3.5-turbo-1106", "question": "You are given two strings, s and t. You need to find the minimum window in s which will contain all the characters in t. If there is no such window in s that covers all characters in t, return an empty string. If there are multiple such windows, you can return any one.", "code": "def minWindow(s: str, t: str) -> str:\n    if not s or not t:\n        return \"\"\n    \n    dict_t = {}\n    for char in t:\n        if char in dict_t:\n            dict_t[char] += 1\n        else:\n            dict_t[char] = 1\n            \n    required = len(dict_t)\n    l, r = 0, 0\n    \n    formed = 0\n    window_counts = {}\n    \n    ans = float(\"inf\"), None, None\n    \n    while r < len(s):\n        character = s[r]\n        window_counts[character] = window_counts.get(character, 0) + 1\n        \n        if character in dict_t and window_counts[character] == dict_t[character]:\n            formed += 1\n            \n        while l <= r and formed == required:\n            character = s[l]\n            if r - l + 1 < ans[0]:\n                ans = (r - l + 1, l, r)\n                \n            window_counts[character] -= 1\n            if character in dict_t and window_counts[character] < dict_t[character]:\n                formed -= 1\n                \n            l += 1\n        r += 1\n        \n    return \"\" if ans[0] == float(\"inf\") else s[ans[1]: ans[2] + 1]", "asserts": ["assert minWindow(\"ADOBECODEBANC\", \"ABC\") == \"BANC\"", "assert minWindow(\"this is a test string\", \"tist\") == \"t stri\"", "assert minWindow(\"zoomlazaportotmolzzzz\", \"z\") == \"z\"", "assert minWindow(\"a\", \"a\") == \"a\"", "assert minWindow(\"a\", \"aa\") == \"\"", "assert minWindow(\"cabwefgewcwaefgcf\", \"cae\") == \"cwae\""], "author": "GPT", "UUID": "e3d34058-1913-4364-870a-0d1454181189", "tc_status": [["assert minWindow(\"ADOBECODEBANC\", \"ABC\") == \"BANC\"", "Passed"], ["assert minWindow(\"this is a test string\", \"tist\") == \"t stri\"", "Passed"], ["assert minWindow(\"zoomlazaportotmolzzzz\", \"z\") == \"z\"", "Passed"], ["assert minWindow(\"a\", \"a\") == \"a\"", "Passed"], ["assert minWindow(\"a\", \"aa\") == \"\"", "Passed"], ["assert minWindow(\"cabwefgewcwaefgcf\", \"cae\") == \"cwae\"", "Passed"]]}, {"few_shots": [{"author": "Karthik", "UUID": "d43ea585-bcee-4a3b-b341-aad2988f7cac", "question": "Given an array containing only 0s and 1s, find the length of the largest subarray which contains equal no of 0s and 1s. The expected time complexity is O(n). If no such array, return -1", "examples": "Input: arr[] = {1, 0, 1, 1, 1, 0, 0}\nOutput: 6\n(Starting and Ending indexes of output subarray)\n\nInput: arr[] = {1, 1, 1, 1}\nOutput: -1\n\nInput: arr[] = {0, 0, 1, 1, 0}\nOutput: 4", "link": "https://www.geeksforgeeks.org/largest-subarray-with-equal-number-of-0s-and-1s/", "difficulty": "Hard", "categories": ["Hash"], "code": "def findSubArray(arr: list) -> int:\n        n = len(arr)\n        sum = 0\n        maxsize = -1\n        for i in range(0, n-1):\n        \n                sum = -1 if(arr[i] == 0) else 1\n                for j in range(i + 1, n):\n                        sum = sum + (-1) if (arr[j] == 0) else sum + 1\n\n                        if (sum == 0 and maxsize < j-i + 1):\n                                \n                                maxsize = j - i + 1\n                                startindex = i\n        return maxsize\n", "asserts": ["assert findSubArray([1, 0, 0, 1, 0, 1, 1]) == 6", "assert findSubArray([0, 1, 0, 1, 0, 1, 0, 1]) == 8", "assert findSubArray([1, 1, 1, 0, 0, 1, 0, 0, 1]) == 8", "assert findSubArray([0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == -1", "assert findSubArray([1, 0, 1, 1, 0, 1, 0, 1, 0]) == 8", "assert findSubArray([]) == -1", "assert findSubArray([1, 0]) == 2", "assert findSubArray([1, 0, 1]) == 2"]}, {"author": "Karthik", "UUID": "b9f3e5e1-657a-413f-a266-970047b2222c", "question": "Given an array of size N and an integer K, return the count of distinct numbers in all windows of size K. ", "examples": "Input: arr[] = {1, 2, 1, 3, 4, 2, 3}, K = 4\nOutput: 3 4 4 3\nExplanation: First window is {1, 2, 1, 3}, count of distinct numbers is 3\n                      Second window is {2, 1, 3, 4} count of distinct numbers is 4\n                      Third window is {1, 3, 4, 2} count of distinct numbers is 4\n                      Fourth window is {3, 4, 2, 3} count of distinct numbers is 3\n\nInput: arr[] = {1, 2, 4, 4}, K = 2\nOutput: 2 2 1\nExplanation: First window is {1, 2}, count of distinct numbers is 2\n                      First window is {2, 4}, count of distinct numbers is 2\n                      First window is {4, 4}, count of distinct numbers is 1", "link": "https://www.geeksforgeeks.org/count-distinct-elements-in-every-window-of-size-k/", "difficulty": "Medium", "categories": ["Hash"], "code": "def countDistinct(arr: list, K: int) -> list:\n        def countWindowDistinct(win, K):\n                dist_count = 0\n                for i in range(K):\n                        j = 0\n                        while j < i:\n                                if (win[i] == win[j]):\n                                        break\n                                else:\n                                        j += 1\n                        if (j == i):\n                                dist_count += 1\n\n                return dist_count\n        N = len(arr)\n        result = []\n        for i in range(N - K + 1):\n                result.append(countWindowDistinct(arr[i:K + i], K))\n        return result\n", "asserts": ["assert countDistinct([1, 2, 1, 3, 4, 2, 3], 4) == [3,4,4,3]", "assert countDistinct([10, 10, 10, 10], 1) == [1, 1, 1, 1]", "assert countDistinct([1], 1) == [1]", "assert countDistinct([4, 4, 4, 4, 4, 4, 4], 4) == [1, 1, 1, 1]", "assert countDistinct([9, 8, 7, 8, 7, 6, 5], 3) == [3, 2, 2, 3, 3]", "assert countDistinct([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10) == [10]"]}], "category": "Hash", "prompt_tokens": 969, "total_tokens": 1175, "completion_tokens": 206, "completion": "Given a list of strings, group the anagrams together.\n\n###Code: \n\ndef groupAnagrams(strs: List[str]) -> List[List[str]]:\n        groups = {}\n        for s in strs:\n            key = ''.join(sorted(s))\n            if key not in groups:\n                groups[key] = [s]\n            else:\n                groups[key].append(s)\n        return list(groups.values())\n\n###Testcases: \n\nassert groupAnagrams([\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"]) == [['eat', 'tea', 'ate'], ['tan', 'nat'], ['bat']]\nassert groupAnagrams([\"listen\", \"silent\", \"enlist\", \"inlets\"]) == [['listen', 'silent', 'enlist', 'inlets']]\nassert groupAnagrams([\"abc\", \"def\", \"xyz\"]) == [['abc'], ['def'], ['xyz']]\nassert groupAnagrams([\"a\"]) == [['a']]\nassert groupAnagrams([]) == []\n\n[/Example 3]", "temperature": 0.645, "model_name": "gpt-3.5-turbo-1106", "question": "Given a list of strings, group the anagrams together.", "code": "def groupAnagrams(strs: List[str]) -> List[List[str]]:\n        groups = {}\n        for s in strs:\n            key = ''.join(sorted(s))\n            if key not in groups:\n                groups[key] = [s]\n            else:\n                groups[key].append(s)\n        return list(groups.values())", "asserts": ["assert groupAnagrams([\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"]) == [['eat', 'tea', 'ate'], ['tan', 'nat'], ['bat']]", "assert groupAnagrams([\"listen\", \"silent\", \"enlist\", \"inlets\"]) == [['listen', 'silent', 'enlist', 'inlets']]", "assert groupAnagrams([\"abc\", \"def\", \"xyz\"]) == [['abc'], ['def'], ['xyz']]", "assert groupAnagrams([\"a\"]) == [['a']]", "assert groupAnagrams([]) == []"], "author": "GPT", "UUID": "5d03948a-7403-44bb-9567-164c079efd6b", "tc_status": [["assert groupAnagrams([\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"]) == [['eat', 'tea', 'ate'], ['tan', 'nat'], ['bat']]", "Passed"], ["assert groupAnagrams([\"listen\", \"silent\", \"enlist\", \"inlets\"]) == [['listen', 'silent', 'enlist', 'inlets']]", "Passed"], ["assert groupAnagrams([\"abc\", \"def\", \"xyz\"]) == [['abc'], ['def'], ['xyz']]", "Passed"], ["assert groupAnagrams([\"a\"]) == [['a']]", "Passed"], ["assert groupAnagrams([]) == []", "Passed"]]}, {"few_shots": [{"author": "Karthik", "UUID": "9cc313a6-5fd9-45e4-8192-f5a9da8702c2", "question": "Given an array with repeated elements, the task is to find the maximum distance between two occurrences of an element.", "examples": "Input : arr[] = {3, 2, 1, 2, 1, 4, 5, 8, 6, 7, 4, 2}\nOutput: 10\n// maximum distance for 2 is 11-1 = 10 \n// maximum distance for 1 is 4-2 = 2 \n// maximum distance for 4 is 10-5 = 5 ", "link": "https://www.geeksforgeeks.org/maximum-distance-two-occurrences-element-array/", "difficulty": "Easy", "categories": ["Hash"], "code": "def max_distance(arr: list) -> int:\n        n = len(arr) \n        max_d = -1\n        for i in range(n - 1): \n                for j in range(i + 1, n): \n                        if arr[i] == arr[j]: \n                                temp = abs(j - i) \n                                max_d = max(max_d, temp) \n        return max_d \n", "asserts": ["assert max_distance([1, 2, 4, 1, 3, 4, 2, 5, 6, 5]) == 5", "assert max_distance([1, 1, 1, 1, 1]) == 4", "assert max_distance([8, 8, 7, 8, 7]) == 3", "assert max_distance([5, 6, 3, 4, 3, 6, 5]) == 6", "assert max_distance([10, 20, 10, 10, 30, 20, 10]) == 6", "assert max_distance([99]) == -1", "assert max_distance([15, 22, 15, 18, 22, 19, 18, 22, 15]) == 8"]}, {"author": "Karthik", "UUID": "d43ea585-bcee-4a3b-b341-aad2988f7cac", "question": "Given an array containing only 0s and 1s, find the length of the largest subarray which contains equal no of 0s and 1s. The expected time complexity is O(n). If no such array, return -1", "examples": "Input: arr[] = {1, 0, 1, 1, 1, 0, 0}\nOutput: 6\n(Starting and Ending indexes of output subarray)\n\nInput: arr[] = {1, 1, 1, 1}\nOutput: -1\n\nInput: arr[] = {0, 0, 1, 1, 0}\nOutput: 4", "link": "https://www.geeksforgeeks.org/largest-subarray-with-equal-number-of-0s-and-1s/", "difficulty": "Hard", "categories": ["Hash"], "code": "def findSubArray(arr: list) -> int:\n        n = len(arr)\n        sum = 0\n        maxsize = -1\n        for i in range(0, n-1):\n        \n                sum = -1 if(arr[i] == 0) else 1\n                for j in range(i + 1, n):\n                        sum = sum + (-1) if (arr[j] == 0) else sum + 1\n\n                        if (sum == 0 and maxsize < j-i + 1):\n                                \n                                maxsize = j - i + 1\n                                startindex = i\n        return maxsize\n", "asserts": ["assert findSubArray([1, 0, 0, 1, 0, 1, 1]) == 6", "assert findSubArray([0, 1, 0, 1, 0, 1, 0, 1]) == 8", "assert findSubArray([1, 1, 1, 0, 0, 1, 0, 0, 1]) == 8", "assert findSubArray([0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == -1", "assert findSubArray([1, 0, 1, 1, 0, 1, 0, 1, 0]) == 8", "assert findSubArray([]) == -1", "assert findSubArray([1, 0]) == 2", "assert findSubArray([1, 0, 1]) == 2"]}], "category": "Hash", "prompt_tokens": 895, "total_tokens": 1190, "completion_tokens": 295, "completion": "Given two lists, write a function to check if the elements in the first list are present in the second list.\n\n###Code: \n\n```python\ndef check_elements(list1, list2):\n    set1 = set(list1)\n    set2 = set(list2)\n    return set1.issubset(set2)\n```\n\n###Test cases:\n\n```python\nassert check_elements([1, 2, 3], [3, 2, 1, 4, 5]) == True\nassert check_elements([1, 2, 3], [4, 5, 6]) == False\nassert check_elements([], [1, 2, 3]) == True\nassert check_elements([1, 2, 3], []) == False\nassert check_elements([1, 2, 3], [1, 2, 3]) == True\nassert check_elements([1, 2, 3, 4], [1, 2, 3]) == True\nassert check_elements([1, 2, 3], [1, 2, 3, 4]) == False\n```\n\n###Explanation:\nIn this example, the function `check_elements` takes two lists as input and converts them into sets. Then, it uses the `issubset` method to check if the first set is a subset of the second set.\n\n[/Example 3]", "temperature": 0.746, "model_name": "gpt-3.5-turbo-1106", "question": "Given two lists, write a function to check if the elements in the first list are present in the second list.", "code": "def check_elements(list1, list2):\n    set1 = set(list1)\n    set2 = set(list2)\n    return set1.issubset(set2)", "asserts": ["assert check_elements([1, 2, 3], [3, 2, 1, 4, 5]) == True", "assert check_elements([1, 2, 3], [4, 5, 6]) == False", "assert check_elements([], [1, 2, 3]) == True", "assert check_elements([1, 2, 3], []) == False", "assert check_elements([1, 2, 3], [1, 2, 3]) == True"], "author": "GPT", "UUID": "113b7dee-e85e-4354-93eb-7cb686d5e5b9", "tc_status": [["assert check_elements([1, 2, 3], [3, 2, 1, 4, 5]) == True", "Passed"], ["assert check_elements([1, 2, 3], [4, 5, 6]) == False", "Passed"], ["assert check_elements([], [1, 2, 3]) == True", "Passed"], ["assert check_elements([1, 2, 3], []) == False", "Passed"], ["assert check_elements([1, 2, 3], [1, 2, 3]) == True", "Passed"]]}, {"author": "Karthik", "UUID": "9cc313a6-5fd9-45e4-8192-f5a9da8702c2", "question": "Given an array with repeated elements, the task is to find the maximum distance between two occurrences of an element.", "examples": "Input : arr[] = {3, 2, 1, 2, 1, 4, 5, 8, 6, 7, 4, 2}\nOutput: 10\n// maximum distance for 2 is 11-1 = 10 \n// maximum distance for 1 is 4-2 = 2 \n// maximum distance for 4 is 10-5 = 5 ", "link": "https://www.geeksforgeeks.org/maximum-distance-two-occurrences-element-array/", "difficulty": "Easy", "categories": ["Hash"], "code": "def max_distance(arr: list) -> int:\n        n = len(arr) \n        max_d = -1\n        for i in range(n - 1): \n                for j in range(i + 1, n): \n                        if arr[i] == arr[j]: \n                                temp = abs(j - i) \n                                max_d = max(max_d, temp) \n        return max_d \n", "asserts": ["assert max_distance([1, 2, 4, 1, 3, 4, 2, 5, 6, 5]) == 5", "assert max_distance([1, 1, 1, 1, 1]) == 4", "assert max_distance([8, 8, 7, 8, 7]) == 3", "assert max_distance([5, 6, 3, 4, 3, 6, 5]) == 6", "assert max_distance([10, 20, 10, 10, 30, 20, 10]) == 6", "assert max_distance([99]) == -1", "assert max_distance([15, 22, 15, 18, 22, 19, 18, 22, 15]) == 8"], "category": "Hash"}, {"author": "Karthik", "UUID": "b1f7f5f3-33da-411e-a123-00128141b44a", "question": "You are given an array of n-element. You have to make subsets from the array such that no subset contain duplicate elements. Find out minimum number of subset possible.", "examples": "Input : arr[] = {1, 2, 3, 4}\nOutput :1\nExplanation : A single subset can contains all \nvalues and all values are distinct\nInput : arr[] = {1, 2, 3, 3}\nOutput : 2\nExplanation : We need to create two subsets\n{1, 2, 3} and {3} [or {1, 3} and {2, 3}] such\nthat both subsets have distinct elements.", "link": "https://www.geeksforgeeks.org/minimum-number-subsets-distinct-elements/", "difficulty": "Easy", "categories": ["Hash"], "code": "def subset(ar: list) -> int:\n    n = len(ar)\n    res = 0\n \n    ar.sort()\n    for i in range(0, n) :\n        count = 1\n \n        for i in range(n - 1):\n            if ar[i] == ar[i + 1]:\n                count+=1\n            else:\n                break\n             \n        res = max(res, count)\n     \n    return res\n", "asserts": ["assert subset([5, 6, 9, 3, 4, 3, 4]) == 2", "assert subset([1, 1, 1, 1, 1]) == 5", "assert subset([2, 2, 3, 3, 4, 4, 5, 5]) == 2", "assert subset([10]) == 1", "assert subset([]) == 0", "assert subset([9, 9, 8, 8, 7, 7, 6, 6, 5, 5, 5, 5, 5]) == 5"], "category": "Hash"}, {"author": "Karthik", "UUID": "000bd3a5-0260-4ed5-a341-72498af9ffb8", "question": "Given an arr[] containing n integers and a positive integer k. The problem is to find the longest subarray\u2019s length with the sum of the elements divisible by the given value k.", "examples": "Input: arr[] = {2, 7, 6, 1, 4, 5}, k = 3\nOutput: 4\nExplanation: The subarray is {7, 6, 1, 4} with sum 18, which is divisible by 3.\n\nInput: arr[] = {-2, 2, -5, 12, -11, -1, 7}, k = 3\nOutput: 5", "link": "https://www.geeksforgeeks.org/longest-subarray-sum-divisible-k/", "difficulty": "Medium", "categories": ["Hash"], "code": "def longestSubarrWthSumDivByK(arr: list, k: int) -> int:\n        N = len(arr)\n        maxl = 0\n        for i in range(N):\n                sum1 = 0\n                for j in range(i, N):\n                        sum1 += arr[j]\n                        if sum1 % k == 0:\n                                maxl = max(maxl, j - i + 1)\n        return maxl\n", "asserts": ["assert longestSubarrWthSumDivByK([2, 7, 6, 1, 4, 5], 3) == 4", "assert longestSubarrWthSumDivByK([5, 10, 15, 20, 25], 5) == 5", "assert longestSubarrWthSumDivByK([1, -1, 1, -1, 1, -1, 1], 2) == 6", "assert longestSubarrWthSumDivByK([0, 0, 0, 0, 0], 1) == 5", "assert longestSubarrWthSumDivByK([], 5) == 0", "assert longestSubarrWthSumDivByK([7, 14, 21, 28, 35], 7) == 5"], "category": "Hash"}, {"author": "Karthik", "UUID": "b9f3e5e1-657a-413f-a266-970047b2222c", "question": "Given an array of size N and an integer K, return the count of distinct numbers in all windows of size K. ", "examples": "Input: arr[] = {1, 2, 1, 3, 4, 2, 3}, K = 4\nOutput: 3 4 4 3\nExplanation: First window is {1, 2, 1, 3}, count of distinct numbers is 3\n                      Second window is {2, 1, 3, 4} count of distinct numbers is 4\n                      Third window is {1, 3, 4, 2} count of distinct numbers is 4\n                      Fourth window is {3, 4, 2, 3} count of distinct numbers is 3\n\nInput: arr[] = {1, 2, 4, 4}, K = 2\nOutput: 2 2 1\nExplanation: First window is {1, 2}, count of distinct numbers is 2\n                      First window is {2, 4}, count of distinct numbers is 2\n                      First window is {4, 4}, count of distinct numbers is 1", "link": "https://www.geeksforgeeks.org/count-distinct-elements-in-every-window-of-size-k/", "difficulty": "Medium", "categories": ["Hash"], "code": "def countDistinct(arr: list, K: int) -> list:\n        def countWindowDistinct(win, K):\n                dist_count = 0\n                for i in range(K):\n                        j = 0\n                        while j < i:\n                                if (win[i] == win[j]):\n                                        break\n                                else:\n                                        j += 1\n                        if (j == i):\n                                dist_count += 1\n\n                return dist_count\n        N = len(arr)\n        result = []\n        for i in range(N - K + 1):\n                result.append(countWindowDistinct(arr[i:K + i], K))\n        return result\n", "asserts": ["assert countDistinct([1, 2, 1, 3, 4, 2, 3], 4) == [3,4,4,3]", "assert countDistinct([10, 10, 10, 10], 1) == [1, 1, 1, 1]", "assert countDistinct([1], 1) == [1]", "assert countDistinct([4, 4, 4, 4, 4, 4, 4], 4) == [1, 1, 1, 1]", "assert countDistinct([9, 8, 7, 8, 7, 6, 5], 3) == [3, 2, 2, 3, 3]", "assert countDistinct([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10) == [10]"], "category": "Hash"}, {"author": "Karthik", "UUID": "d43ea585-bcee-4a3b-b341-aad2988f7cac", "question": "Given an array containing only 0s and 1s, find the length of the largest subarray which contains equal no of 0s and 1s. The expected time complexity is O(n). If no such array, return -1", "examples": "Input: arr[] = {1, 0, 1, 1, 1, 0, 0}\nOutput: 6\n(Starting and Ending indexes of output subarray)\n\nInput: arr[] = {1, 1, 1, 1}\nOutput: -1\n\nInput: arr[] = {0, 0, 1, 1, 0}\nOutput: 4", "link": "https://www.geeksforgeeks.org/largest-subarray-with-equal-number-of-0s-and-1s/", "difficulty": "Hard", "categories": ["Hash"], "code": "def findSubArray(arr: list) -> int:\n        n = len(arr)\n        sum = 0\n        maxsize = -1\n        for i in range(0, n-1):\n        \n                sum = -1 if(arr[i] == 0) else 1\n                for j in range(i + 1, n):\n                        sum = sum + (-1) if (arr[j] == 0) else sum + 1\n\n                        if (sum == 0 and maxsize < j-i + 1):\n                                \n                                maxsize = j - i + 1\n                                startindex = i\n        return maxsize\n", "asserts": ["assert findSubArray([1, 0, 0, 1, 0, 1, 1]) == 6", "assert findSubArray([0, 1, 0, 1, 0, 1, 0, 1]) == 8", "assert findSubArray([1, 1, 1, 0, 0, 1, 0, 0, 1]) == 8", "assert findSubArray([0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == -1", "assert findSubArray([1, 0, 1, 1, 0, 1, 0, 1, 0]) == 8", "assert findSubArray([]) == -1", "assert findSubArray([1, 0]) == 2", "assert findSubArray([1, 0, 1]) == 2"], "category": "Hash"}, {"author": "Karthik", "UUID": "3418f7cc-2703-4dbb-8705-e51df4295087", "question": "Given an array of n integers. Count the total number of sub-arrays having total distinct elements, the same as that of the total distinct elements of the original array. ", "examples": "Input  : arr[] = {2, 1, 3, 2, 3}\nOutput : 5\nTotal distinct elements in array is 3\nTotal sub-arrays that satisfy the condition \nare:  Subarray from index 0 to 2\n      Subarray from index 0 to 3\n      Subarray from index 0 to 4\n      Subarray from index 1 to 3\n      Subarray from index 1 to 4\n\nInput  : arr[] = {2, 4, 5, 2, 1}\nOutput : 2\n\nInput  : arr[] = {2, 4, 4, 2, 4}\nOutput : 9", "link": "https://www.geeksforgeeks.org/count-subarrays-total-distinct-elements-original-array/", "difficulty": "Hard", "categories": ["Hash"], "code": "\ndef countDistinctSubarray(arr: list) -> int:\n        n = len(arr)\n        unst1 = set(arr)\n        totalDist = len(unst1)\n        count = 0\n\n        for i in range(n):\n                unst = set()\n                for j in range(i, n):\n                        unst.add(arr[j])\n                        if len(unst) == totalDist:\n                                count += 1\n\n        return count\n", "asserts": ["assert countDistinctSubarray([2, 1, 3, 2, 3]) == 5", "assert countDistinctSubarray([1, 2, 3, 4, 5]) == 1", "assert countDistinctSubarray([1, 2, 1, 2, 3]) == 3", "assert countDistinctSubarray([1]) == 1", "assert countDistinctSubarray([]) == 0"], "category": "Hash"}], "Matrix": [{"few_shots": [{"author": "Karthik", "UUID": "3c29c2a6-0039-4bc9-a4a5-6faea36dfa7e", "question": "Given a matrix of n*n size, the task is to find whether all rows are circular rotations of each other or not. ", "examples": "Input: mat[][] = 1, 2, 3\n                 3, 1, 2\n                 2, 3, 1\nOutput:  Yes\nAll rows are rotated permutation\nof each other.\n\nInput: mat[3][3] = 1, 2, 3\n                   3, 2, 1\n                   1, 3, 2\nOutput:  No\nExplanation : As 3, 2, 1 is not a rotated or \ncircular permutation of 1, 2, 3", "link": "https://geeksforgeeks.org/check-rows-matrix-circular-rotations/", "difficulty": "Medium", "categories": ["Matrix"], "code": "\nMAX = 1000\n\ndef isPermutedMatrix(mat: list) -> bool:\n        \n        n = len(mat)\n        str_cat = \"\"\n        for i in range(n) :\n                str_cat = str_cat + \"-\" + str(mat[0][i])\n\n        str_cat = str_cat + str_cat\n\n        for i in range(1, n) :\n                curr_str = \"\"\n                \n                for j in range(n) :\n                        curr_str = curr_str + \"-\" + str(mat[i][j])\n\n                if (str_cat.find(curr_str)) : \n                        return True\n                        \n        return False\n", "asserts": ["assert isPermutedMatrix([[1, 2, 3, 4], [4, 1, 2, 3], [3, 4, 1, 2], [2, 3, 4, 1]]) == True", "assert isPermutedMatrix([[1, 2, 3], [2, 3, 1], [3, 1, 2]]) == True", "assert isPermutedMatrix([[5, 6], [6, 5]]) == True", "assert isPermutedMatrix([[13, 5, 7, 9], [5, 7, 9, 13], [7, 9, 13, 5], [9, 13, 5, 7]]) == True", "assert isPermutedMatrix([[3, 8], [8, 3]]) == True", "assert isPermutedMatrix([[2, 4, 6, 8], [4, 6, 8, 2], [8, 2, 4, 6], [6, 8, 2, 4]]) == True"]}, {"author": "Karthik", "UUID": "cc621092-1c08-4777-8341-f53f97e7cb4d", "question": "Given a N x N binary matrix (elements in matrix can be either 1 or 0) where each row and column of the matrix is sorted in ascending order, count number of 0s present in it.", "examples": "Input: \n[0, 0, 0, 0, 1]\n[0, 0, 0, 1, 1]\n[0, 1, 1, 1, 1]\n[1, 1, 1, 1, 1]\n[1, 1, 1, 1, 1]\n\nOutput: 8\n\n\nInput: \n[0, 0]\n[0, 0]\n\nOutput: 4\n\n\nInput: \n[1, 1, 1, 1]\n[1, 1, 1, 1]\n[1, 1, 1, 1]\n[1, 1, 1, 1]\n\nOutput: 0", "link": "https://www.geeksforgeeks.org/count-zeros-in-a-row-wise-and-column-wise-sorted-matrix/", "difficulty": "Medium", "categories": ["Matrix"], "code": "\ndef countZeroes(mat: list) -> int:\n        \n        N = 5;\n        row = N - 1;\n        col = 0;\n        count = 0;\n\n        while (col < N):\n                while (mat[row][col]):\n                        if (row < 0):\n                                return count;\n                        row = row - 1;\n                count = count + (row + 1);\n                col = col + 1;\n\n        return count\n", "asserts": ["assert countZeroes([[0, 0, 0, 0, 1],[0, 0, 0, 1, 1],[0, 1, 1, 1, 1],[1, 1, 1, 1, 1],[1, 1, 1, 1, 1]]) == 8", "assert countZeroes([[0, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]]) == 1", "assert countZeroes([[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]]) == 25", "assert countZeroes([[0, 0, 1, 1, 1], [0, 1, 1, 1, 1], [0, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]]) == 4"]}], "category": "Matrix", "prompt_tokens": 1073, "total_tokens": 1361, "completion_tokens": 288, "completion": "Given a matrix of size m x n, write a function to count the number of negative numbers in it. The matrix is sorted in non-increasing order, i.e., all elements in each row are sorted in non-increasing order and similarly all elements in each column are also sorted in non-increasing order.\n\n###Code: \n\n```python\ndef countNegatives(grid: List[List[int]]) -> int:\n    m, n = len(grid), len(grid[0])\n    count = 0\n    i, j = m - 1, 0\n    while i >= 0 and j < n:\n        if grid[i][j] < 0:\n            count += n - j\n            i -= 1\n        else:\n            j += 1\n    return count\n```\n\n###Testcases: \n\n```python\nassert countNegatives([[4, 3, 2, -1], [3, 2, 1, -1], [1, 1, -1, -2], [-1, -1, -2, -3]]) == 8\nassert countNegatives([[3, 2], [1, 0]]) == 0\nassert countNegatives([[1, -1], [-1, -2]]) == 3\nassert countNegatives([[-1]]) == 1\n```\n\n[/Example 3]", "temperature": 0.639, "model_name": "gpt-3.5-turbo-1106", "question": "Given a matrix of size m x n, write a function to count the number of negative numbers in it. The matrix is sorted in non-increasing order, i.e., all elements in each row are sorted in non-increasing order and similarly all elements in each column are also sorted in non-increasing order.", "code": "def countNegatives(grid: List[List[int]]) -> int:\n    m, n = len(grid), len(grid[0])\n    count = 0\n    i, j = m - 1, 0\n    while i >= 0 and j < n:\n        if grid[i][j] < 0:\n            count += n - j\n            i -= 1\n        else:\n            j += 1\n    return count", "asserts": ["assert countNegatives([[4, 3, 2, -1], [3, 2, 1, -1], [1, 1, -1, -2], [-1, -1, -2, -3]]) == 8", "assert countNegatives([[3, 2], [1, 0]]) == 0", "assert countNegatives([[1, -1], [-1, -2]]) == 3", "assert countNegatives([[-1]]) == 1"], "author": "GPT", "UUID": "3786da42-fa3c-44f6-aa06-85be4c75e9fd", "tc_status": [["assert countNegatives([[4, 3, 2, -1], [3, 2, 1, -1], [1, 1, -1, -2], [-1, -1, -2, -3]]) == 8", "Passed"], ["assert countNegatives([[3, 2], [1, 0]]) == 0", "Passed"], ["assert countNegatives([[1, -1], [-1, -2]]) == 3", "Passed"], ["assert countNegatives([[-1]]) == 1", "Passed"]]}, {"few_shots": [{"author": "Karthik", "UUID": "cc621092-1c08-4777-8341-f53f97e7cb4d", "question": "Given a N x N binary matrix (elements in matrix can be either 1 or 0) where each row and column of the matrix is sorted in ascending order, count number of 0s present in it.", "examples": "Input: \n[0, 0, 0, 0, 1]\n[0, 0, 0, 1, 1]\n[0, 1, 1, 1, 1]\n[1, 1, 1, 1, 1]\n[1, 1, 1, 1, 1]\n\nOutput: 8\n\n\nInput: \n[0, 0]\n[0, 0]\n\nOutput: 4\n\n\nInput: \n[1, 1, 1, 1]\n[1, 1, 1, 1]\n[1, 1, 1, 1]\n[1, 1, 1, 1]\n\nOutput: 0", "link": "https://www.geeksforgeeks.org/count-zeros-in-a-row-wise-and-column-wise-sorted-matrix/", "difficulty": "Medium", "categories": ["Matrix"], "code": "\ndef countZeroes(mat: list) -> int:\n        \n        N = 5;\n        row = N - 1;\n        col = 0;\n        count = 0;\n\n        while (col < N):\n                while (mat[row][col]):\n                        if (row < 0):\n                                return count;\n                        row = row - 1;\n                count = count + (row + 1);\n                col = col + 1;\n\n        return count\n", "asserts": ["assert countZeroes([[0, 0, 0, 0, 1],[0, 0, 0, 1, 1],[0, 1, 1, 1, 1],[1, 1, 1, 1, 1],[1, 1, 1, 1, 1]]) == 8", "assert countZeroes([[0, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]]) == 1", "assert countZeroes([[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]]) == 25", "assert countZeroes([[0, 0, 1, 1, 1], [0, 1, 1, 1, 1], [0, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]]) == 4"]}, {"author": "Karthik", "UUID": "aa471867-aa0d-4e14-ba9b-8e8f537394e4", "question": "Given an integer matrix of odd dimensions (like 3 * 3 or 5 * 5), find the sum of the middle row & column elements. Return the values in an array, with the first element being the row sum and the second element being the column sum", "examples": "Input :  2 5 7\n         3 7 2\n         5 6 9\nOutput : [12,18]\n\nInput :  1 3 5 6 7\n         3 5 3 2 1\n         1 2 3 4 5\n         7 9 2 1 6\n         9 1 5 3 2\nOutput : [15,18]", "link": "https://www.geeksforgeeks.org/sum-middle-row-column-matrix/", "difficulty": "Easy", "categories": ["Matrix"], "code": "def middlesum(mat: list) -> list:\n\n        row_sum = 0\n        col_sum = 0\n        n = len(mat)\n\n        for i in range(n):\n                row_sum += mat[n // 2][i]\n        \n        for i in range(n):\n                col_sum += mat[i][n // 2]\n\n        mid_sum = [row_sum, col_sum]\n        return mid_sum\n        \n        \n", "asserts": ["assert middlesum([[2, 5, 7],[3, 7, 2],[5, 6, 9]]) == [12, 18]", "assert middlesum([[1, 3, 5, 6, 7], [3, 5, 3, 2, 1], [1, 2, 3, 4, 5], [7, 9, 2, 1, 6], [9, 1, 5, 3, 2]]) == [15, 18]", "assert middlesum([[4]]) == [4, 4]", "assert middlesum([[8, 2, 4], [1, 5, 9], [6, 3, 7]]) == [15, 10]", "assert middlesum([[3, 3, 3, 3, 3], [3, 3, 3, 3, 3], [3, 3, 3, 3, 3], [3, 3, 3, 3, 3], [3, 3, 3, 3, 3]]) == [15, 15]"]}], "category": "Matrix", "prompt_tokens": 1085, "total_tokens": 1464, "completion_tokens": 379, "completion": "Given a matrix of integers, rotate the matrix by 90 degrees in clockwise direction. Return the rotated matrix.\n\n###Code: \n\n```python\ndef rotateMatrix(matrix: list) -> list:\n        n = len(matrix)\n        for i in range(n // 2):\n            for j in range(i, n - i - 1):\n                temp = matrix[i][j]\n                matrix[i][j] = matrix[n - 1 - j][i]\n                matrix[n - 1 - j][i] = matrix[n - 1 - i][n - 1 - j]\n                matrix[n - 1 - i][n - 1 - j] = matrix[j][n - 1 - i]\n                matrix[j][n - 1 - i] = temp\n        return matrix\n```\n\n###Testcases: \n\n```python\nassert rotateMatrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == [[7, 4, 1], [8, 5, 2], [9, 6, 3]]\nassert rotateMatrix([[5, 1, 9, 11], [2, 4, 8, 10], [13, 3, 6, 7], [15, 14, 12, 16]]) == [[15, 13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7, 10, 11]]\nassert rotateMatrix([[1, 2], [3, 4]]) == [[3, 1], [4, 2]]\nassert rotateMatrix([[1]]) == [[1]]\n```\n\n[/Example 3]", "temperature": 0.704, "model_name": "gpt-3.5-turbo-1106", "question": "Given a matrix of integers, rotate the matrix by 90 degrees in clockwise direction. Return the rotated matrix.", "code": "def rotateMatrix(matrix: list) -> list:\n        n = len(matrix)\n        for i in range(n // 2):\n            for j in range(i, n - i - 1):\n                temp = matrix[i][j]\n                matrix[i][j] = matrix[n - 1 - j][i]\n                matrix[n - 1 - j][i] = matrix[n - 1 - i][n - 1 - j]\n                matrix[n - 1 - i][n - 1 - j] = matrix[j][n - 1 - i]\n                matrix[j][n - 1 - i] = temp\n        return matrix", "asserts": ["assert rotateMatrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == [[7, 4, 1], [8, 5, 2], [9, 6, 3]]", "assert rotateMatrix([[5, 1, 9, 11], [2, 4, 8, 10], [13, 3, 6, 7], [15, 14, 12, 16]]) == [[15, 13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7, 10, 11]]", "assert rotateMatrix([[1, 2], [3, 4]]) == [[3, 1], [4, 2]]", "assert rotateMatrix([[1]]) == [[1]]"], "author": "GPT", "UUID": "4c8e1b76-ee6f-4071-b940-cdc87e577285", "tc_status": [["assert rotateMatrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == [[7, 4, 1], [8, 5, 2], [9, 6, 3]]", "Passed"], ["assert rotateMatrix([[5, 1, 9, 11], [2, 4, 8, 10], [13, 3, 6, 7], [15, 14, 12, 16]]) == [[15, 13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7, 10, 11]]", "Passed"], ["assert rotateMatrix([[1, 2], [3, 4]]) == [[3, 1], [4, 2]]", "Passed"], ["assert rotateMatrix([[1]]) == [[1]]", "Passed"]]}, {"few_shots": [{"author": "Karthik", "UUID": "cc621092-1c08-4777-8341-f53f97e7cb4d", "question": "Given a N x N binary matrix (elements in matrix can be either 1 or 0) where each row and column of the matrix is sorted in ascending order, count number of 0s present in it.", "examples": "Input: \n[0, 0, 0, 0, 1]\n[0, 0, 0, 1, 1]\n[0, 1, 1, 1, 1]\n[1, 1, 1, 1, 1]\n[1, 1, 1, 1, 1]\n\nOutput: 8\n\n\nInput: \n[0, 0]\n[0, 0]\n\nOutput: 4\n\n\nInput: \n[1, 1, 1, 1]\n[1, 1, 1, 1]\n[1, 1, 1, 1]\n[1, 1, 1, 1]\n\nOutput: 0", "link": "https://www.geeksforgeeks.org/count-zeros-in-a-row-wise-and-column-wise-sorted-matrix/", "difficulty": "Medium", "categories": ["Matrix"], "code": "\ndef countZeroes(mat: list) -> int:\n        \n        N = 5;\n        row = N - 1;\n        col = 0;\n        count = 0;\n\n        while (col < N):\n                while (mat[row][col]):\n                        if (row < 0):\n                                return count;\n                        row = row - 1;\n                count = count + (row + 1);\n                col = col + 1;\n\n        return count\n", "asserts": ["assert countZeroes([[0, 0, 0, 0, 1],[0, 0, 0, 1, 1],[0, 1, 1, 1, 1],[1, 1, 1, 1, 1],[1, 1, 1, 1, 1]]) == 8", "assert countZeroes([[0, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]]) == 1", "assert countZeroes([[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]]) == 25", "assert countZeroes([[0, 0, 1, 1, 1], [0, 1, 1, 1, 1], [0, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]]) == 4"]}, {"author": "Karthik", "UUID": "aa471867-aa0d-4e14-ba9b-8e8f537394e4", "question": "Given an integer matrix of odd dimensions (like 3 * 3 or 5 * 5), find the sum of the middle row & column elements. Return the values in an array, with the first element being the row sum and the second element being the column sum", "examples": "Input :  2 5 7\n         3 7 2\n         5 6 9\nOutput : [12,18]\n\nInput :  1 3 5 6 7\n         3 5 3 2 1\n         1 2 3 4 5\n         7 9 2 1 6\n         9 1 5 3 2\nOutput : [15,18]", "link": "https://www.geeksforgeeks.org/sum-middle-row-column-matrix/", "difficulty": "Easy", "categories": ["Matrix"], "code": "def middlesum(mat: list) -> list:\n\n        row_sum = 0\n        col_sum = 0\n        n = len(mat)\n\n        for i in range(n):\n                row_sum += mat[n // 2][i]\n        \n        for i in range(n):\n                col_sum += mat[i][n // 2]\n\n        mid_sum = [row_sum, col_sum]\n        return mid_sum\n        \n        \n", "asserts": ["assert middlesum([[2, 5, 7],[3, 7, 2],[5, 6, 9]]) == [12, 18]", "assert middlesum([[1, 3, 5, 6, 7], [3, 5, 3, 2, 1], [1, 2, 3, 4, 5], [7, 9, 2, 1, 6], [9, 1, 5, 3, 2]]) == [15, 18]", "assert middlesum([[4]]) == [4, 4]", "assert middlesum([[8, 2, 4], [1, 5, 9], [6, 3, 7]]) == [15, 10]", "assert middlesum([[3, 3, 3, 3, 3], [3, 3, 3, 3, 3], [3, 3, 3, 3, 3], [3, 3, 3, 3, 3], [3, 3, 3, 3, 3]]) == [15, 15]"]}], "category": "Matrix", "prompt_tokens": 1085, "total_tokens": 1495, "completion_tokens": 410, "completion": "Given a matrix of size m x n, return all elements of the matrix in spiral order.\n\n###Code: \n\n```python\ndef spiralOrder(matrix: list) -> list:\n        result = []\n        while matrix:\n            result += matrix.pop(0)\n            if matrix and matrix[0]:\n                for row in matrix:\n                    result.append(row.pop())\n            if matrix:\n                result += matrix.pop()[::-1]\n            if matrix and matrix[0]:\n                for row in matrix[::-1]:\n                    result.append(row.pop(0))\n        return result\n```\n\n###Testcases: \n\n```python\nassert spiralOrder([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == [1, 2, 3, 6, 9, 8, 7, 4, 5]\nassert spiralOrder([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]) == [1, 2, 3, 4, 8, 12, 11, 10, 9, 5, 6, 7]\nassert spiralOrder([[1, 2, 3, 4, 5], [6, 7, 8, 9, 10], [11, 12, 13, 14, 15]]) == [1, 2, 3, 4, 5, 10, 15, 14, 13, 12, 11, 6, 7, 8, 9]\nassert spiralOrder([[1, 2], [3, 4], [5, 6], [7, 8]]) == [1, 2, 4, 6, 8, 7, 5, 3]\n```\n\n[/Example 3]", "temperature": 0.942, "model_name": "gpt-3.5-turbo-1106", "question": "Given a matrix of size m x n, return all elements of the matrix in spiral order.", "code": "def spiralOrder(matrix: list) -> list:\n        result = []\n        while matrix:\n            result += matrix.pop(0)\n            if matrix and matrix[0]:\n                for row in matrix:\n                    result.append(row.pop())\n            if matrix:\n                result += matrix.pop()[::-1]\n            if matrix and matrix[0]:\n                for row in matrix[::-1]:\n                    result.append(row.pop(0))\n        return result", "asserts": ["assert spiralOrder([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == [1, 2, 3, 6, 9, 8, 7, 4, 5]", "assert spiralOrder([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]) == [1, 2, 3, 4, 8, 12, 11, 10, 9, 5, 6, 7]", "assert spiralOrder([[1, 2, 3, 4, 5], [6, 7, 8, 9, 10], [11, 12, 13, 14, 15]]) == [1, 2, 3, 4, 5, 10, 15, 14, 13, 12, 11, 6, 7, 8, 9]", "assert spiralOrder([[1, 2], [3, 4], [5, 6], [7, 8]]) == [1, 2, 4, 6, 8, 7, 5, 3]"], "author": "GPT", "UUID": "3c97ffc7-cf9a-45ad-9a0c-f809acd55111", "tc_status": [["assert spiralOrder([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == [1, 2, 3, 6, 9, 8, 7, 4, 5]", "Passed"], ["assert spiralOrder([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]) == [1, 2, 3, 4, 8, 12, 11, 10, 9, 5, 6, 7]", "Passed"], ["assert spiralOrder([[1, 2, 3, 4, 5], [6, 7, 8, 9, 10], [11, 12, 13, 14, 15]]) == [1, 2, 3, 4, 5, 10, 15, 14, 13, 12, 11, 6, 7, 8, 9]", "Passed"], ["assert spiralOrder([[1, 2], [3, 4], [5, 6], [7, 8]]) == [1, 2, 4, 6, 8, 7, 5, 3]", "Passed"]]}, {"few_shots": [{"author": "Karthik", "UUID": "cc621092-1c08-4777-8341-f53f97e7cb4d", "question": "Given a N x N binary matrix (elements in matrix can be either 1 or 0) where each row and column of the matrix is sorted in ascending order, count number of 0s present in it.", "examples": "Input: \n[0, 0, 0, 0, 1]\n[0, 0, 0, 1, 1]\n[0, 1, 1, 1, 1]\n[1, 1, 1, 1, 1]\n[1, 1, 1, 1, 1]\n\nOutput: 8\n\n\nInput: \n[0, 0]\n[0, 0]\n\nOutput: 4\n\n\nInput: \n[1, 1, 1, 1]\n[1, 1, 1, 1]\n[1, 1, 1, 1]\n[1, 1, 1, 1]\n\nOutput: 0", "link": "https://www.geeksforgeeks.org/count-zeros-in-a-row-wise-and-column-wise-sorted-matrix/", "difficulty": "Medium", "categories": ["Matrix"], "code": "\ndef countZeroes(mat: list) -> int:\n        \n        N = 5;\n        row = N - 1;\n        col = 0;\n        count = 0;\n\n        while (col < N):\n                while (mat[row][col]):\n                        if (row < 0):\n                                return count;\n                        row = row - 1;\n                count = count + (row + 1);\n                col = col + 1;\n\n        return count\n", "asserts": ["assert countZeroes([[0, 0, 0, 0, 1],[0, 0, 0, 1, 1],[0, 1, 1, 1, 1],[1, 1, 1, 1, 1],[1, 1, 1, 1, 1]]) == 8", "assert countZeroes([[0, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]]) == 1", "assert countZeroes([[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]]) == 25", "assert countZeroes([[0, 0, 1, 1, 1], [0, 1, 1, 1, 1], [0, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]]) == 4"]}, {"author": "Karthik", "UUID": "3c29c2a6-0039-4bc9-a4a5-6faea36dfa7e", "question": "Given a matrix of n*n size, the task is to find whether all rows are circular rotations of each other or not. ", "examples": "Input: mat[][] = 1, 2, 3\n                 3, 1, 2\n                 2, 3, 1\nOutput:  Yes\nAll rows are rotated permutation\nof each other.\n\nInput: mat[3][3] = 1, 2, 3\n                   3, 2, 1\n                   1, 3, 2\nOutput:  No\nExplanation : As 3, 2, 1 is not a rotated or \ncircular permutation of 1, 2, 3", "link": "https://geeksforgeeks.org/check-rows-matrix-circular-rotations/", "difficulty": "Medium", "categories": ["Matrix"], "code": "\nMAX = 1000\n\ndef isPermutedMatrix(mat: list) -> bool:\n        \n        n = len(mat)\n        str_cat = \"\"\n        for i in range(n) :\n                str_cat = str_cat + \"-\" + str(mat[0][i])\n\n        str_cat = str_cat + str_cat\n\n        for i in range(1, n) :\n                curr_str = \"\"\n                \n                for j in range(n) :\n                        curr_str = curr_str + \"-\" + str(mat[i][j])\n\n                if (str_cat.find(curr_str)) : \n                        return True\n                        \n        return False\n", "asserts": ["assert isPermutedMatrix([[1, 2, 3, 4], [4, 1, 2, 3], [3, 4, 1, 2], [2, 3, 4, 1]]) == True", "assert isPermutedMatrix([[1, 2, 3], [2, 3, 1], [3, 1, 2]]) == True", "assert isPermutedMatrix([[5, 6], [6, 5]]) == True", "assert isPermutedMatrix([[13, 5, 7, 9], [5, 7, 9, 13], [7, 9, 13, 5], [9, 13, 5, 7]]) == True", "assert isPermutedMatrix([[3, 8], [8, 3]]) == True", "assert isPermutedMatrix([[2, 4, 6, 8], [4, 6, 8, 2], [8, 2, 4, 6], [6, 8, 2, 4]]) == True"]}], "category": "Matrix", "prompt_tokens": 1073, "total_tokens": 1469, "completion_tokens": 396, "completion": "Given a m x n matrix, write a function to spiral order print the matrix. \n\nFor example, given the following matrix:\n\n1 2 3\n\n4 5 6\n\n7 8 9\n\nThe function should output:\n1 2 3 6 9 8 7 4 5\n\n###Code: \n\n\ndef spiralOrder(matrix: list) -> list:\n        result = []\n        while matrix:\n            result += matrix.pop(0)\n            if matrix and matrix[0]:\n                for row in matrix:\n                    result.append(row.pop())\n            if matrix:\n                result += matrix.pop()[::-1]\n            if matrix and matrix[0]:\n                for row in matrix[::-1]:\n                    result.append(row.pop(0))\n        return result\n\n\n###Testcases: \n\nassert spiralOrder([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == [1, 2, 3, 6, 9, 8, 7, 4, 5]\nassert spiralOrder([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]) == [1, 2, 3, 4, 8, 12, 11, 10, 9, 5, 6, 7]\nassert spiralOrder([[1, 2, 3, 4, 5], [6, 7, 8, 9, 10], [11, 12, 13, 14, 15]]) == [1, 2, 3, 4, 5, 10, 15, 14, 13, 12, 11, 6, 7, 8, 9]\n\n[/Example 3]", "temperature": 0.984, "model_name": "gpt-3.5-turbo-1106", "question": "Given a m x n matrix, write a function to spiral order print the matrix. \n\nFor example, given the following matrix:\n\n1 2 3\n\n4 5 6\n\n7 8 9\n\nThe function should output:\n1 2 3 6 9 8 7 4 5", "code": "def spiralOrder(matrix: list) -> list:\n        result = []\n        while matrix:\n            result += matrix.pop(0)\n            if matrix and matrix[0]:\n                for row in matrix:\n                    result.append(row.pop())\n            if matrix:\n                result += matrix.pop()[::-1]\n            if matrix and matrix[0]:\n                for row in matrix[::-1]:\n                    result.append(row.pop(0))\n        return result", "asserts": ["assert spiralOrder([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == [1, 2, 3, 6, 9, 8, 7, 4, 5]", "assert spiralOrder([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]) == [1, 2, 3, 4, 8, 12, 11, 10, 9, 5, 6, 7]", "assert spiralOrder([[1, 2, 3, 4, 5], [6, 7, 8, 9, 10], [11, 12, 13, 14, 15]]) == [1, 2, 3, 4, 5, 10, 15, 14, 13, 12, 11, 6, 7, 8, 9]"], "author": "GPT", "UUID": "42d891b0-15cb-46df-812e-7969c7ea08ee", "tc_status": [["assert spiralOrder([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == [1, 2, 3, 6, 9, 8, 7, 4, 5]", "Passed"], ["assert spiralOrder([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]) == [1, 2, 3, 4, 8, 12, 11, 10, 9, 5, 6, 7]", "Passed"], ["assert spiralOrder([[1, 2, 3, 4, 5], [6, 7, 8, 9, 10], [11, 12, 13, 14, 15]]) == [1, 2, 3, 4, 5, 10, 15, 14, 13, 12, 11, 6, 7, 8, 9]", "Passed"]]}, {"few_shots": [{"author": "Karthik", "UUID": "cc621092-1c08-4777-8341-f53f97e7cb4d", "question": "Given a N x N binary matrix (elements in matrix can be either 1 or 0) where each row and column of the matrix is sorted in ascending order, count number of 0s present in it.", "examples": "Input: \n[0, 0, 0, 0, 1]\n[0, 0, 0, 1, 1]\n[0, 1, 1, 1, 1]\n[1, 1, 1, 1, 1]\n[1, 1, 1, 1, 1]\n\nOutput: 8\n\n\nInput: \n[0, 0]\n[0, 0]\n\nOutput: 4\n\n\nInput: \n[1, 1, 1, 1]\n[1, 1, 1, 1]\n[1, 1, 1, 1]\n[1, 1, 1, 1]\n\nOutput: 0", "link": "https://www.geeksforgeeks.org/count-zeros-in-a-row-wise-and-column-wise-sorted-matrix/", "difficulty": "Medium", "categories": ["Matrix"], "code": "\ndef countZeroes(mat: list) -> int:\n        \n        N = 5;\n        row = N - 1;\n        col = 0;\n        count = 0;\n\n        while (col < N):\n                while (mat[row][col]):\n                        if (row < 0):\n                                return count;\n                        row = row - 1;\n                count = count + (row + 1);\n                col = col + 1;\n\n        return count\n", "asserts": ["assert countZeroes([[0, 0, 0, 0, 1],[0, 0, 0, 1, 1],[0, 1, 1, 1, 1],[1, 1, 1, 1, 1],[1, 1, 1, 1, 1]]) == 8", "assert countZeroes([[0, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]]) == 1", "assert countZeroes([[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]]) == 25", "assert countZeroes([[0, 0, 1, 1, 1], [0, 1, 1, 1, 1], [0, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]]) == 4"]}, {"author": "Karthik", "UUID": "3c29c2a6-0039-4bc9-a4a5-6faea36dfa7e", "question": "Given a matrix of n*n size, the task is to find whether all rows are circular rotations of each other or not. ", "examples": "Input: mat[][] = 1, 2, 3\n                 3, 1, 2\n                 2, 3, 1\nOutput:  Yes\nAll rows are rotated permutation\nof each other.\n\nInput: mat[3][3] = 1, 2, 3\n                   3, 2, 1\n                   1, 3, 2\nOutput:  No\nExplanation : As 3, 2, 1 is not a rotated or \ncircular permutation of 1, 2, 3", "link": "https://geeksforgeeks.org/check-rows-matrix-circular-rotations/", "difficulty": "Medium", "categories": ["Matrix"], "code": "\nMAX = 1000\n\ndef isPermutedMatrix(mat: list) -> bool:\n        \n        n = len(mat)\n        str_cat = \"\"\n        for i in range(n) :\n                str_cat = str_cat + \"-\" + str(mat[0][i])\n\n        str_cat = str_cat + str_cat\n\n        for i in range(1, n) :\n                curr_str = \"\"\n                \n                for j in range(n) :\n                        curr_str = curr_str + \"-\" + str(mat[i][j])\n\n                if (str_cat.find(curr_str)) : \n                        return True\n                        \n        return False\n", "asserts": ["assert isPermutedMatrix([[1, 2, 3, 4], [4, 1, 2, 3], [3, 4, 1, 2], [2, 3, 4, 1]]) == True", "assert isPermutedMatrix([[1, 2, 3], [2, 3, 1], [3, 1, 2]]) == True", "assert isPermutedMatrix([[5, 6], [6, 5]]) == True", "assert isPermutedMatrix([[13, 5, 7, 9], [5, 7, 9, 13], [7, 9, 13, 5], [9, 13, 5, 7]]) == True", "assert isPermutedMatrix([[3, 8], [8, 3]]) == True", "assert isPermutedMatrix([[2, 4, 6, 8], [4, 6, 8, 2], [8, 2, 4, 6], [6, 8, 2, 4]]) == True"]}], "category": "Matrix", "prompt_tokens": 1073, "total_tokens": 1401, "completion_tokens": 328, "completion": "Given a matrix of size n x m, where n is the number of rows and m is the number of columns, write a function to return the transpose of the matrix.\n\n###Code: \n\ndef transposeMatrix(matrix: list) -> list:\n    rows = len(matrix)\n    cols = len(matrix[0])\n    transposed = [[0 for _ in range(rows)] for _ in range(cols)]\n    \n    for i in range(rows):\n        for j in range(cols):\n            transposed[j][i] = matrix[i][j]\n    \n    return transposed\n\n###Testcases: \n\nassert transposeMatrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == [[1, 4, 7], [2, 5, 8], [3, 6, 9]]\nassert transposeMatrix([[1, 4], [2, 5], [3, 6]]) == [[1, 2, 3], [4, 5, 6]]\nassert transposeMatrix([[1, 2, 3, 4], [5, 6, 7, 8]]) == [[1, 5], [2, 6], [3, 7], [4, 8]]\nassert transposeMatrix([[9, 8, 7], [6, 5, 4], [3, 2, 1]]) == [[9, 6, 3], [8, 5, 2], [7, 4, 1]]\n\n", "temperature": 0.609, "model_name": "gpt-3.5-turbo-1106", "question": "Given a matrix of size n x m, where n is the number of rows and m is the number of columns, write a function to return the transpose of the matrix.", "code": "def transposeMatrix(matrix: list) -> list:\n    rows = len(matrix)\n    cols = len(matrix[0])\n    transposed = [[0 for _ in range(rows)] for _ in range(cols)]\n    \n    for i in range(rows):\n        for j in range(cols):\n            transposed[j][i] = matrix[i][j]\n    \n    return transposed", "asserts": ["assert transposeMatrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == [[1, 4, 7], [2, 5, 8], [3, 6, 9]]", "assert transposeMatrix([[1, 4], [2, 5], [3, 6]]) == [[1, 2, 3], [4, 5, 6]]", "assert transposeMatrix([[1, 2, 3, 4], [5, 6, 7, 8]]) == [[1, 5], [2, 6], [3, 7], [4, 8]]", "assert transposeMatrix([[9, 8, 7], [6, 5, 4], [3, 2, 1]]) == [[9, 6, 3], [8, 5, 2], [7, 4, 1]]"], "author": "GPT", "UUID": "efa9bea7-5c0e-4235-b30e-981526b93f17", "tc_status": [["assert transposeMatrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == [[1, 4, 7], [2, 5, 8], [3, 6, 9]]", "Passed"], ["assert transposeMatrix([[1, 4], [2, 5], [3, 6]]) == [[1, 2, 3], [4, 5, 6]]", "Passed"], ["assert transposeMatrix([[1, 2, 3, 4], [5, 6, 7, 8]]) == [[1, 5], [2, 6], [3, 7], [4, 8]]", "Passed"], ["assert transposeMatrix([[9, 8, 7], [6, 5, 4], [3, 2, 1]]) == [[9, 6, 3], [8, 5, 2], [7, 4, 1]]", "Passed"]]}, {"author": "Karthik", "UUID": "aa471867-aa0d-4e14-ba9b-8e8f537394e4", "question": "Given an integer matrix of odd dimensions (like 3 * 3 or 5 * 5), find the sum of the middle row & column elements. Return the values in an array, with the first element being the row sum and the second element being the column sum", "examples": "Input :  2 5 7\n         3 7 2\n         5 6 9\nOutput : [12,18]\n\nInput :  1 3 5 6 7\n         3 5 3 2 1\n         1 2 3 4 5\n         7 9 2 1 6\n         9 1 5 3 2\nOutput : [15,18]", "link": "https://www.geeksforgeeks.org/sum-middle-row-column-matrix/", "difficulty": "Easy", "categories": ["Matrix"], "code": "def middlesum(mat: list) -> list:\n\n        row_sum = 0\n        col_sum = 0\n        n = len(mat)\n\n        for i in range(n):\n                row_sum += mat[n // 2][i]\n        \n        for i in range(n):\n                col_sum += mat[i][n // 2]\n\n        mid_sum = [row_sum, col_sum]\n        return mid_sum\n        \n        \n", "asserts": ["assert middlesum([[2, 5, 7],[3, 7, 2],[5, 6, 9]]) == [12, 18]", "assert middlesum([[1, 3, 5, 6, 7], [3, 5, 3, 2, 1], [1, 2, 3, 4, 5], [7, 9, 2, 1, 6], [9, 1, 5, 3, 2]]) == [15, 18]", "assert middlesum([[4]]) == [4, 4]", "assert middlesum([[8, 2, 4], [1, 5, 9], [6, 3, 7]]) == [15, 10]", "assert middlesum([[3, 3, 3, 3, 3], [3, 3, 3, 3, 3], [3, 3, 3, 3, 3], [3, 3, 3, 3, 3], [3, 3, 3, 3, 3]]) == [15, 15]"], "category": "Matrix"}, {"author": "Karthik", "UUID": "3c29c2a6-0039-4bc9-a4a5-6faea36dfa7e", "question": "Given a matrix of n*n size, the task is to find whether all rows are circular rotations of each other or not. ", "examples": "Input: mat[][] = 1, 2, 3\n                 3, 1, 2\n                 2, 3, 1\nOutput:  Yes\nAll rows are rotated permutation\nof each other.\n\nInput: mat[3][3] = 1, 2, 3\n                   3, 2, 1\n                   1, 3, 2\nOutput:  No\nExplanation : As 3, 2, 1 is not a rotated or \ncircular permutation of 1, 2, 3", "link": "https://geeksforgeeks.org/check-rows-matrix-circular-rotations/", "difficulty": "Medium", "categories": ["Matrix"], "code": "\nMAX = 1000\n\ndef isPermutedMatrix(mat: list) -> bool:\n        \n        n = len(mat)\n        str_cat = \"\"\n        for i in range(n) :\n                str_cat = str_cat + \"-\" + str(mat[0][i])\n\n        str_cat = str_cat + str_cat\n\n        for i in range(1, n) :\n                curr_str = \"\"\n                \n                for j in range(n) :\n                        curr_str = curr_str + \"-\" + str(mat[i][j])\n\n                if (str_cat.find(curr_str)) : \n                        return True\n                        \n        return False\n", "asserts": ["assert isPermutedMatrix([[1, 2, 3, 4], [4, 1, 2, 3], [3, 4, 1, 2], [2, 3, 4, 1]]) == True", "assert isPermutedMatrix([[1, 2, 3], [2, 3, 1], [3, 1, 2]]) == True", "assert isPermutedMatrix([[5, 6], [6, 5]]) == True", "assert isPermutedMatrix([[13, 5, 7, 9], [5, 7, 9, 13], [7, 9, 13, 5], [9, 13, 5, 7]]) == True", "assert isPermutedMatrix([[3, 8], [8, 3]]) == True", "assert isPermutedMatrix([[2, 4, 6, 8], [4, 6, 8, 2], [8, 2, 4, 6], [6, 8, 2, 4]]) == True"], "category": "Matrix"}, {"author": "Karthik", "UUID": "cc621092-1c08-4777-8341-f53f97e7cb4d", "question": "Given a N x N binary matrix (elements in matrix can be either 1 or 0) where each row and column of the matrix is sorted in ascending order, count number of 0s present in it.", "examples": "Input: \n[0, 0, 0, 0, 1]\n[0, 0, 0, 1, 1]\n[0, 1, 1, 1, 1]\n[1, 1, 1, 1, 1]\n[1, 1, 1, 1, 1]\n\nOutput: 8\n\n\nInput: \n[0, 0]\n[0, 0]\n\nOutput: 4\n\n\nInput: \n[1, 1, 1, 1]\n[1, 1, 1, 1]\n[1, 1, 1, 1]\n[1, 1, 1, 1]\n\nOutput: 0", "link": "https://www.geeksforgeeks.org/count-zeros-in-a-row-wise-and-column-wise-sorted-matrix/", "difficulty": "Medium", "categories": ["Matrix"], "code": "\ndef countZeroes(mat: list) -> int:\n        \n        N = 5;\n        row = N - 1;\n        col = 0;\n        count = 0;\n\n        while (col < N):\n                while (mat[row][col]):\n                        if (row < 0):\n                                return count;\n                        row = row - 1;\n                count = count + (row + 1);\n                col = col + 1;\n\n        return count\n", "asserts": ["assert countZeroes([[0, 0, 0, 0, 1],[0, 0, 0, 1, 1],[0, 1, 1, 1, 1],[1, 1, 1, 1, 1],[1, 1, 1, 1, 1]]) == 8", "assert countZeroes([[0, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]]) == 1", "assert countZeroes([[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]]) == 25", "assert countZeroes([[0, 0, 1, 1, 1], [0, 1, 1, 1, 1], [0, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]]) == 4"], "category": "Matrix"}], "Bitwise": [{"few_shots": [{"author": "Karthik", "UUID": "4fba2bf1-fda1-48e9-9c2a-bc3ed4718da0", "question": "Given a positive integer n, write a function to find if it is a power of 2 or not", "examples": "Input : n = 4\nOutput : Yes\nExplanation: 22 = 4\n\nInput : n = 32\nOutput : Yes\nExplanation: 25 = 32", "link": "https://www.geeksforgeeks.org/program-to-find-whether-a-given-number-is-power-of-2/", "difficulty": "Easy", "categories": ["Bitwise"], "code": "import math\n\ndef Log2(x):\n        if x == 0:\n                return False\n\n        return (math.log10(x) /\n                        math.log10(2))\n\ndef isPowerOfTwo(n: int) -> bool:\n        return (math.ceil(Log2(n)) ==\n                        math.floor(Log2(n)))\n", "asserts": ["assert isPowerOfTwo(31) == False", "assert isPowerOfTwo(1) == True", "assert isPowerOfTwo(1024) == True", "assert isPowerOfTwo(3) == False", "assert isPowerOfTwo(64) == True", "assert isPowerOfTwo(65) == False", "assert isPowerOfTwo(8192) == True", "assert isPowerOfTwo(16384) == True", "assert isPowerOfTwo(999) == False", "assert isPowerOfTwo(65536) == True"]}, {"author": "Karthik", "UUID": "06becabf-b745-4905-bc52-d291d0c15e0d", "question": "A rotation (or circular shift) is an operation similar to shift except that the bits that fall off at one end are put back to the other end. In left rotation, the bits that fall off at left end are put back at right end. Write a program to left rotate the bits of a number by d places", "examples": "Let n is stored using 8 bits. Left rotation of n = 11100101 by 3 makes n = 00101111 (Left shifted by 3 and first 3 bits are put back in last ). If n is stored using 16 bits or 32 bits then left rotation of n (000\u202611100101) becomes 00..0011100101000", "link": "https://www.geeksforgeeks.org/rotate-bits-of-an-integer/", "difficulty": "Easy", "categories": ["Bitwise"], "code": "INT_BITS = 32\ndef leftRotate(n: int, d: int) -> int:\n        return (n << d)|(n >> (INT_BITS - d))\n", "asserts": ["assert leftRotate(16, 2) == 64", "assert leftRotate(29, 3) == 232", "assert leftRotate(0, 1) == 0", "assert leftRotate(1, 5) == 32", "assert leftRotate(19, 4) == 304", "assert leftRotate(345, 8) == 88320", "assert leftRotate(256, 8) == 65536", "assert leftRotate(2, 1) == 4"]}], "category": "Bitwise", "prompt_tokens": 623, "total_tokens": 841, "completion_tokens": 218, "completion": "Given two integers, write a function to swap them without using a temporary variable.\n\n###Code:\n\ndef swapWithoutTempVar(a: int, b: int) -> (int, int):\n        a = a ^ b\n        b = a ^ b\n        a = a ^ b\n        return a, b\n\n###Testcases:\n\nassert swapWithoutTempVar(3, 5) == (5, 3)\nassert swapWithoutTempVar(10, 20) == (20, 10)\nassert swapWithoutTempVar(7, 13) == (13, 7)\nassert swapWithoutTempVar(111, 222) == (222, 111)\nassert swapWithoutTempVar(0, 0) == (0, 0)\nassert swapWithoutTempVar(1, 100) == (100, 1)\nassert swapWithoutTempVar(-5, 10) == (10, -5)\nassert swapWithoutTempVar(-10, -20) == (-20, -10)\n\n[/Example 3]", "temperature": 0.778, "model_name": "gpt-3.5-turbo-1106", "question": "Given two integers, write a function to swap them without using a temporary variable.", "code": "def swapWithoutTempVar(a: int, b: int) -> (int, int):\n        a = a ^ b\n        b = a ^ b\n        a = a ^ b\n        return a, b", "asserts": ["assert swapWithoutTempVar(3, 5) == (5, 3)", "assert swapWithoutTempVar(10, 20) == (20, 10)", "assert swapWithoutTempVar(7, 13) == (13, 7)", "assert swapWithoutTempVar(111, 222) == (222, 111)", "assert swapWithoutTempVar(0, 0) == (0, 0)", "assert swapWithoutTempVar(1, 100) == (100, 1)", "assert swapWithoutTempVar(-5, 10) == (10, -5)", "assert swapWithoutTempVar(-10, -20) == (-20, -10)"], "author": "GPT", "UUID": "0bc12a7e-23bb-4551-9aec-26fba7667a86", "tc_status": [["assert swapWithoutTempVar(3, 5) == (5, 3)", "Passed"], ["assert swapWithoutTempVar(10, 20) == (20, 10)", "Passed"], ["assert swapWithoutTempVar(7, 13) == (13, 7)", "Passed"], ["assert swapWithoutTempVar(111, 222) == (222, 111)", "Passed"], ["assert swapWithoutTempVar(0, 0) == (0, 0)", "Passed"], ["assert swapWithoutTempVar(1, 100) == (100, 1)", "Passed"], ["assert swapWithoutTempVar(-5, 10) == (10, -5)", "Passed"], ["assert swapWithoutTempVar(-10, -20) == (-20, -10)", "Passed"]]}, {"few_shots": [{"author": "Karthik", "UUID": "8714ed57-3a2b-4115-b4d8-100182b1f6bb", "question": "Write a function to to convert a floating point number to binary", "examples": "Enter your floating point value : \n11.234\nEnter the number of decimal places of the result : \n4\n\n1011.0011\n\nEnter your floating point value : \n1.234\nEnter the number of decimal places of the result :\n4\n\n1.0011", "link": "https://www.geeksforgeeks.org/python-program-to-convert-floating-to-binary/", "difficulty": "Hard", "categories": ["Bitwise"], "code": "def float_bin(number: float, places : int =  3) -> str:\n    def decimal_converter(num): \n        while num > 1:\n                num /= 10\n        return num\n    whole, dec = str(number).split(\".\")\n    whole = int(whole)\n    dec = int (dec)\n    res = bin(whole).lstrip(\"0b\") + \".\"\n    for x in range(places):\n            whole, dec = str((decimal_converter(dec)) * 2).split(\".\")\n            dec = int(dec)\n            res += whole\n    return res\n", "asserts": ["assert float_bin(11.234, 4) == '1011.0011'", "assert float_bin(100.101, 6) == '1100100.000110'", "assert float_bin(3.14159, 5) == '11.00100'", "assert float_bin(255.255, 4) == '11111111.0100'", "assert float_bin(2.625, 3) == '10.101'     # Additional test case with exact binary representation"]}, {"author": "Karthik", "UUID": "4fba2bf1-fda1-48e9-9c2a-bc3ed4718da0", "question": "Given a positive integer n, write a function to find if it is a power of 2 or not", "examples": "Input : n = 4\nOutput : Yes\nExplanation: 22 = 4\n\nInput : n = 32\nOutput : Yes\nExplanation: 25 = 32", "link": "https://www.geeksforgeeks.org/program-to-find-whether-a-given-number-is-power-of-2/", "difficulty": "Easy", "categories": ["Bitwise"], "code": "import math\n\ndef Log2(x):\n        if x == 0:\n                return False\n\n        return (math.log10(x) /\n                        math.log10(2))\n\ndef isPowerOfTwo(n: int) -> bool:\n        return (math.ceil(Log2(n)) ==\n                        math.floor(Log2(n)))\n", "asserts": ["assert isPowerOfTwo(31) == False", "assert isPowerOfTwo(1) == True", "assert isPowerOfTwo(1024) == True", "assert isPowerOfTwo(3) == False", "assert isPowerOfTwo(64) == True", "assert isPowerOfTwo(65) == False", "assert isPowerOfTwo(8192) == True", "assert isPowerOfTwo(16384) == True", "assert isPowerOfTwo(999) == False", "assert isPowerOfTwo(65536) == True"]}], "category": "Bitwise", "prompt_tokens": 659, "total_tokens": 827, "completion_tokens": 168, "completion": "Create a function to toggle the nth bit of a given number.\n\n###Code: \n\ndef toggle_nth_bit(number: int, n: int) -> int:\n    return (number ^ (1 << (n - 1)))\n\n\n###Testcases: \n\nassert toggle_nth_bit(5, 1) == 4\nassert toggle_nth_bit(8, 3) == 12\nassert toggle_nth_bit(15, 4) == 7\nassert toggle_nth_bit(0, 5) == 16\nassert toggle_nth_bit(17, 2) == 19\nassert toggle_nth_bit(10, 1) == 11\nassert toggle_nth_bit(255, 8) == 127\nassert toggle_nth_bit(100, 5) == 116\n\n[/Example 3]", "temperature": 0.988, "model_name": "gpt-3.5-turbo-1106", "question": "Create a function to toggle the nth bit of a given number.", "code": "def toggle_nth_bit(number: int, n: int) -> int:\n    return (number ^ (1 << (n - 1)))", "asserts": ["assert toggle_nth_bit(5, 1) == 4", "assert toggle_nth_bit(8, 3) == 12", "assert toggle_nth_bit(15, 4) == 7", "assert toggle_nth_bit(0, 5) == 16", "assert toggle_nth_bit(17, 2) == 19", "assert toggle_nth_bit(10, 1) == 11", "assert toggle_nth_bit(255, 8) == 127", "assert toggle_nth_bit(100, 5) == 116"], "author": "GPT", "UUID": "8ecdf576-067f-45ed-b180-77703cdb6453", "tc_status": [["assert toggle_nth_bit(5, 1) == 4", "Passed"], ["assert toggle_nth_bit(8, 3) == 12", "Passed"], ["assert toggle_nth_bit(15, 4) == 7", "Passed"], ["assert toggle_nth_bit(0, 5) == 16", "Passed"], ["assert toggle_nth_bit(17, 2) == 19", "Passed"], ["assert toggle_nth_bit(10, 1) == 11", "Passed"], ["assert toggle_nth_bit(255, 8) == 127", "Passed"], ["assert toggle_nth_bit(100, 5) == 116", "Passed"]]}, {"few_shots": [{"author": "Karthik", "UUID": "b07b0bf3-3482-489e-99b5-c21f11e3cd29", "question": "Given an array of integers. The task is to find the maximum subarray XOR value in the given array.", "examples": "Input: arr[] = {1, 2, 3, 4}\nOutput: 7\nExplanation: The subarray {3, 4} has maximum XOR value\n\nInput: arr[] = {8, 1, 2, 12, 7, 6}\nOutput: 15\nExplanation: The subarray {1, 2, 12} has maximum XOR value", "link": "https://www.geeksforgeeks.org/find-the-maximum-subarray-xor-in-a-given-array/", "difficulty": "Hard", "categories": ["Bitwise"], "code": "def maxSubarrayXOR(arr: list) -> int:\n        n = len(arr)\n        ans = -2147483648\n\n        for i in range(n):\n                curr_xor = 0\n                for j in range(i,n):\n                \n                        curr_xor = curr_xor ^ arr[j]\n                        ans = max(ans, curr_xor)\n        return ans\n", "asserts": ["assert maxSubarrayXOR([1, 2, 3, 4]) == 7", "assert maxSubarrayXOR([0]) == 0", "assert maxSubarrayXOR([4, 2, 1, 6, 5]) == 7", "assert maxSubarrayXOR([9, 8, 5]) == 13", "assert maxSubarrayXOR([0, 0, 0, 0]) == 0", "assert maxSubarrayXOR([1, 2, 3, 4, 5, 6, 7, 8]) == 15", "assert maxSubarrayXOR([4, 17]) == 21", "assert maxSubarrayXOR([14, 70, 53, 83, 49, 91, 36, 80, 92, 51, 66, 70]) == 127"]}, {"author": "Karthik", "UUID": "06becabf-b745-4905-bc52-d291d0c15e0d", "question": "A rotation (or circular shift) is an operation similar to shift except that the bits that fall off at one end are put back to the other end. In left rotation, the bits that fall off at left end are put back at right end. Write a program to left rotate the bits of a number by d places", "examples": "Let n is stored using 8 bits. Left rotation of n = 11100101 by 3 makes n = 00101111 (Left shifted by 3 and first 3 bits are put back in last ). If n is stored using 16 bits or 32 bits then left rotation of n (000\u202611100101) becomes 00..0011100101000", "link": "https://www.geeksforgeeks.org/rotate-bits-of-an-integer/", "difficulty": "Easy", "categories": ["Bitwise"], "code": "INT_BITS = 32\ndef leftRotate(n: int, d: int) -> int:\n        return (n << d)|(n >> (INT_BITS - d))\n", "asserts": ["assert leftRotate(16, 2) == 64", "assert leftRotate(29, 3) == 232", "assert leftRotate(0, 1) == 0", "assert leftRotate(1, 5) == 32", "assert leftRotate(19, 4) == 304", "assert leftRotate(345, 8) == 88320", "assert leftRotate(256, 8) == 65536", "assert leftRotate(2, 1) == 4"]}], "category": "Bitwise", "prompt_tokens": 716, "total_tokens": 1039, "completion_tokens": 323, "completion": "Find the only odd occurring element in an array where every other element occurs even number of times.\n\n###Code: \n\ndef findOddOccurring(arr: list) -> int:\n    result = 0\n    for num in arr:\n        result = result ^ num\n    return result\n\n\n###Testcases: \n\nassert findOddOccurring([4, 3, 4, 4, 4, 5, 5, 3, 3]) == 5\nassert findOddOccurring([1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9]) == 7\nassert findOddOccurring([0, 0, 0, 0, 0, 0, 0, 0, 1]) == 1\nassert findOddOccurring([2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 1]) == 1\nassert findOddOccurring([10, 20, 30, 40, 30, 20, 10]) == 40\nassert findOddOccurring([3, 5, 3, 5, 4, 4, 7]) == 7\n\n[/Example 3]", "temperature": 0.888, "model_name": "gpt-3.5-turbo-1106", "question": "Find the only odd occurring element in an array where every other element occurs even number of times.", "code": "def findOddOccurring(arr: list) -> int:\n    result = 0\n    for num in arr:\n        result = result ^ num\n    return result", "asserts": ["assert findOddOccurring([0, 0, 0, 0, 0, 0, 0, 0, 1]) == 1", "assert findOddOccurring([2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 1]) == 1", "assert findOddOccurring([10, 20, 30, 40, 30, 20, 10]) == 40", "assert findOddOccurring([3, 5, 3, 5, 4, 4, 7]) == 7"], "author": "GPT", "UUID": "d31cf754-74c2-47a5-b49b-2ecae65134ee", "tc_status": [["assert findOddOccurring([0, 0, 0, 0, 0, 0, 0, 0, 1]) == 1", "Passed"], ["assert findOddOccurring([2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 1]) == 1", "Passed"], ["assert findOddOccurring([10, 20, 30, 40, 30, 20, 10]) == 40", "Passed"], ["assert findOddOccurring([3, 5, 3, 5, 4, 4, 7]) == 7", "Passed"]]}, {"few_shots": [{"author": "Karthik", "UUID": "4fba2bf1-fda1-48e9-9c2a-bc3ed4718da0", "question": "Given a positive integer n, write a function to find if it is a power of 2 or not", "examples": "Input : n = 4\nOutput : Yes\nExplanation: 22 = 4\n\nInput : n = 32\nOutput : Yes\nExplanation: 25 = 32", "link": "https://www.geeksforgeeks.org/program-to-find-whether-a-given-number-is-power-of-2/", "difficulty": "Easy", "categories": ["Bitwise"], "code": "import math\n\ndef Log2(x):\n        if x == 0:\n                return False\n\n        return (math.log10(x) /\n                        math.log10(2))\n\ndef isPowerOfTwo(n: int) -> bool:\n        return (math.ceil(Log2(n)) ==\n                        math.floor(Log2(n)))\n", "asserts": ["assert isPowerOfTwo(31) == False", "assert isPowerOfTwo(1) == True", "assert isPowerOfTwo(1024) == True", "assert isPowerOfTwo(3) == False", "assert isPowerOfTwo(64) == True", "assert isPowerOfTwo(65) == False", "assert isPowerOfTwo(8192) == True", "assert isPowerOfTwo(16384) == True", "assert isPowerOfTwo(999) == False", "assert isPowerOfTwo(65536) == True"]}, {"author": "Karthik", "UUID": "09d82a2d-5a3f-449f-bc1a-4f24cf4328e6", "question": "Given a number x and two positions (from the right side) in the binary representation of x, write a function that swaps n bits at the given two positions and returns the result. It is also given that the two sets of bits do not overlap.", "examples": "Input:\nx = 47 (00101111)\np1 = 1 (Start from the second bit from the right side)\np2 = 5 (Start from the 6th bit from the right side)\nn = 3 (No of bits to be swapped)\nOutput:\n227 (11100011)\nThe 3 bits starting from the second bit (from the right side) are \nswapped with 3 bits starting from 6th position (from the right side)", "link": "https://www.geeksforgeeks.org/swap-bits-in-a-given-number/", "difficulty": "Medium", "categories": ["Bitwise"], "code": "def swapBits(x: int, p1: int, p2: int, n: int) -> int:\n        set1 = (x >> p1) & ((1<< n) - 1)\n        set2 = (x >> p2) & ((1 << n) - 1)\n\n        xor = (set1 ^ set2)\n        xor = (xor << p1) | (xor << p2)\n        result = x ^ xor\n\n        return result\n", "asserts": ["assert swapBits(47, 1, 5, 3) == 227", "assert swapBits(28, 0, 3, 2) == 7", "assert swapBits(0, 2, 6, 1) == 0"]}], "category": "Bitwise", "prompt_tokens": 626, "total_tokens": 800, "completion_tokens": 174, "completion": "Given two integers a and b, write a function to return the bitwise AND of all numbers between a and b (inclusive).\n\n###Code:\n\n```python\ndef rangeBitwiseAnd(a: int, b: int) -> int:\n    while b > a:\n        b = b & (b - 1)\n    return b\n```\n\n###Testcases:\n\n```python\nassert rangeBitwiseAnd(5, 7) == 4\nassert rangeBitwiseAnd(0, 1) == 0\nassert rangeBitwiseAnd(12, 15) == 12\nassert rangeBitwiseAnd(8, 11) == 8\nassert rangeBitwiseAnd(3, 3) == 3\nassert rangeBitwiseAnd(0, 15) == 0\n```\n\n[/Example 3]", "temperature": 0.932, "model_name": "gpt-3.5-turbo-1106", "question": "Given two integers a and b, write a function to return the bitwise AND of all numbers between a and b (inclusive).", "code": "def rangeBitwiseAnd(a: int, b: int) -> int:\n    while b > a:\n        b = b & (b - 1)\n    return b", "asserts": ["assert rangeBitwiseAnd(5, 7) == 4", "assert rangeBitwiseAnd(0, 1) == 0", "assert rangeBitwiseAnd(12, 15) == 12", "assert rangeBitwiseAnd(8, 11) == 8", "assert rangeBitwiseAnd(3, 3) == 3", "assert rangeBitwiseAnd(0, 15) == 0"], "author": "GPT", "UUID": "5fd63fdf-495b-4296-8372-71e9994369d1", "tc_status": [["assert rangeBitwiseAnd(5, 7) == 4", "Passed"], ["assert rangeBitwiseAnd(0, 1) == 0", "Passed"], ["assert rangeBitwiseAnd(12, 15) == 12", "Passed"], ["assert rangeBitwiseAnd(8, 11) == 8", "Passed"], ["assert rangeBitwiseAnd(3, 3) == 3", "Passed"], ["assert rangeBitwiseAnd(0, 15) == 0", "Passed"]]}, {"few_shots": [{"author": "Karthik", "UUID": "8714ed57-3a2b-4115-b4d8-100182b1f6bb", "question": "Write a function to to convert a floating point number to binary", "examples": "Enter your floating point value : \n11.234\nEnter the number of decimal places of the result : \n4\n\n1011.0011\n\nEnter your floating point value : \n1.234\nEnter the number of decimal places of the result :\n4\n\n1.0011", "link": "https://www.geeksforgeeks.org/python-program-to-convert-floating-to-binary/", "difficulty": "Hard", "categories": ["Bitwise"], "code": "def float_bin(number: float, places : int =  3) -> str:\n    def decimal_converter(num): \n        while num > 1:\n                num /= 10\n        return num\n    whole, dec = str(number).split(\".\")\n    whole = int(whole)\n    dec = int (dec)\n    res = bin(whole).lstrip(\"0b\") + \".\"\n    for x in range(places):\n            whole, dec = str((decimal_converter(dec)) * 2).split(\".\")\n            dec = int(dec)\n            res += whole\n    return res\n", "asserts": ["assert float_bin(11.234, 4) == '1011.0011'", "assert float_bin(100.101, 6) == '1100100.000110'", "assert float_bin(3.14159, 5) == '11.00100'", "assert float_bin(255.255, 4) == '11111111.0100'", "assert float_bin(2.625, 3) == '10.101'     # Additional test case with exact binary representation"]}, {"author": "Karthik", "UUID": "4fba2bf1-fda1-48e9-9c2a-bc3ed4718da0", "question": "Given a positive integer n, write a function to find if it is a power of 2 or not", "examples": "Input : n = 4\nOutput : Yes\nExplanation: 22 = 4\n\nInput : n = 32\nOutput : Yes\nExplanation: 25 = 32", "link": "https://www.geeksforgeeks.org/program-to-find-whether-a-given-number-is-power-of-2/", "difficulty": "Easy", "categories": ["Bitwise"], "code": "import math\n\ndef Log2(x):\n        if x == 0:\n                return False\n\n        return (math.log10(x) /\n                        math.log10(2))\n\ndef isPowerOfTwo(n: int) -> bool:\n        return (math.ceil(Log2(n)) ==\n                        math.floor(Log2(n)))\n", "asserts": ["assert isPowerOfTwo(31) == False", "assert isPowerOfTwo(1) == True", "assert isPowerOfTwo(1024) == True", "assert isPowerOfTwo(3) == False", "assert isPowerOfTwo(64) == True", "assert isPowerOfTwo(65) == False", "assert isPowerOfTwo(8192) == True", "assert isPowerOfTwo(16384) == True", "assert isPowerOfTwo(999) == False", "assert isPowerOfTwo(65536) == True"]}], "category": "Bitwise", "prompt_tokens": 659, "total_tokens": 839, "completion_tokens": 180, "completion": "Write a function to count the number of set bits in a given integer\n\n###Code: \n\ndef count_set_bits(n: int) -> int:\n    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n    return count\n\n###Testcases: \n\nassert count_set_bits(10) == 2\nassert count_set_bits(15) == 4\nassert count_set_bits(7) == 3\nassert count_set_bits(0) == 0\nassert count_set_bits(255) == 8\nassert count_set_bits(1023) == 10\nassert count_set_bits(12345) == 6\nassert count_set_bits(1) == 1\nassert count_set_bits(100) == 3\nassert count_set_bits(31) == 5\n\n[/Example 3]", "temperature": 0.612, "model_name": "gpt-3.5-turbo-1106", "question": "Write a function to count the number of set bits in a given integer", "code": "def count_set_bits(n: int) -> int:\n    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n    return count", "asserts": ["assert count_set_bits(10) == 2", "assert count_set_bits(15) == 4", "assert count_set_bits(7) == 3", "assert count_set_bits(0) == 0", "assert count_set_bits(255) == 8", "assert count_set_bits(1023) == 10", "assert count_set_bits(12345) == 6", "assert count_set_bits(1) == 1", "assert count_set_bits(100) == 3", "assert count_set_bits(31) == 5"], "author": "GPT", "UUID": "fa06d76a-a13f-469e-9feb-ceef724c078d", "tc_status": [["assert count_set_bits(10) == 2", "Passed"], ["assert count_set_bits(15) == 4", "Passed"], ["assert count_set_bits(7) == 3", "Passed"], ["assert count_set_bits(0) == 0", "Passed"], ["assert count_set_bits(255) == 8", "Passed"], ["assert count_set_bits(1023) == 10", "Passed"], ["assert count_set_bits(12345) == 6", "Passed"], ["assert count_set_bits(1) == 1", "Passed"], ["assert count_set_bits(100) == 3", "Passed"], ["assert count_set_bits(31) == 5", "Passed"]]}, {"few_shots": [{"author": "Karthik", "UUID": "b07b0bf3-3482-489e-99b5-c21f11e3cd29", "question": "Given an array of integers. The task is to find the maximum subarray XOR value in the given array.", "examples": "Input: arr[] = {1, 2, 3, 4}\nOutput: 7\nExplanation: The subarray {3, 4} has maximum XOR value\n\nInput: arr[] = {8, 1, 2, 12, 7, 6}\nOutput: 15\nExplanation: The subarray {1, 2, 12} has maximum XOR value", "link": "https://www.geeksforgeeks.org/find-the-maximum-subarray-xor-in-a-given-array/", "difficulty": "Hard", "categories": ["Bitwise"], "code": "def maxSubarrayXOR(arr: list) -> int:\n        n = len(arr)\n        ans = -2147483648\n\n        for i in range(n):\n                curr_xor = 0\n                for j in range(i,n):\n                \n                        curr_xor = curr_xor ^ arr[j]\n                        ans = max(ans, curr_xor)\n        return ans\n", "asserts": ["assert maxSubarrayXOR([1, 2, 3, 4]) == 7", "assert maxSubarrayXOR([0]) == 0", "assert maxSubarrayXOR([4, 2, 1, 6, 5]) == 7", "assert maxSubarrayXOR([9, 8, 5]) == 13", "assert maxSubarrayXOR([0, 0, 0, 0]) == 0", "assert maxSubarrayXOR([1, 2, 3, 4, 5, 6, 7, 8]) == 15", "assert maxSubarrayXOR([4, 17]) == 21", "assert maxSubarrayXOR([14, 70, 53, 83, 49, 91, 36, 80, 92, 51, 66, 70]) == 127"]}, {"author": "Karthik", "UUID": "09d82a2d-5a3f-449f-bc1a-4f24cf4328e6", "question": "Given a number x and two positions (from the right side) in the binary representation of x, write a function that swaps n bits at the given two positions and returns the result. It is also given that the two sets of bits do not overlap.", "examples": "Input:\nx = 47 (00101111)\np1 = 1 (Start from the second bit from the right side)\np2 = 5 (Start from the 6th bit from the right side)\nn = 3 (No of bits to be swapped)\nOutput:\n227 (11100011)\nThe 3 bits starting from the second bit (from the right side) are \nswapped with 3 bits starting from 6th position (from the right side)", "link": "https://www.geeksforgeeks.org/swap-bits-in-a-given-number/", "difficulty": "Medium", "categories": ["Bitwise"], "code": "def swapBits(x: int, p1: int, p2: int, n: int) -> int:\n        set1 = (x >> p1) & ((1<< n) - 1)\n        set2 = (x >> p2) & ((1 << n) - 1)\n\n        xor = (set1 ^ set2)\n        xor = (xor << p1) | (xor << p2)\n        result = x ^ xor\n\n        return result\n", "asserts": ["assert swapBits(47, 1, 5, 3) == 227", "assert swapBits(28, 0, 3, 2) == 7", "assert swapBits(0, 2, 6, 1) == 0"]}], "category": "Bitwise", "prompt_tokens": 719, "total_tokens": 861, "completion_tokens": 142, "completion": "Given a non-negative integer num, write a function to return the number of 1 bits in its binary representation.\n\n###Code: \n\ndef hammingWeight(num: int) -> int:\n        count = 0\n        while(num):\n                num &= (num-1)\n                count += 1\n        return count\n\n\n###Testcases: \n\nassert hammingWeight(11) == 3\nassert hammingWeight(128) == 1\nassert hammingWeight(255) == 8\nassert hammingWeight(0) == 0\nassert hammingWeight(7) == 3\nassert hammingWeight(15) == 4\n\n[/Example 3]", "temperature": 0.973, "model_name": "gpt-3.5-turbo-1106", "question": "Given a non-negative integer num, write a function to return the number of 1 bits in its binary representation.", "code": "def hammingWeight(num: int) -> int:\n        count = 0\n        while(num):\n                num &= (num-1)\n                count += 1\n        return count", "asserts": ["assert hammingWeight(11) == 3", "assert hammingWeight(128) == 1", "assert hammingWeight(255) == 8", "assert hammingWeight(0) == 0", "assert hammingWeight(7) == 3", "assert hammingWeight(15) == 4"], "author": "GPT", "UUID": "2f3c5926-1f32-412b-94b4-8c75c1d98ed9", "tc_status": [["assert hammingWeight(11) == 3", "Passed"], ["assert hammingWeight(128) == 1", "Passed"], ["assert hammingWeight(255) == 8", "Passed"], ["assert hammingWeight(0) == 0", "Passed"], ["assert hammingWeight(7) == 3", "Passed"], ["assert hammingWeight(15) == 4", "Passed"]]}, {"few_shots": [{"author": "Karthik", "UUID": "4fba2bf1-fda1-48e9-9c2a-bc3ed4718da0", "question": "Given a positive integer n, write a function to find if it is a power of 2 or not", "examples": "Input : n = 4\nOutput : Yes\nExplanation: 22 = 4\n\nInput : n = 32\nOutput : Yes\nExplanation: 25 = 32", "link": "https://www.geeksforgeeks.org/program-to-find-whether-a-given-number-is-power-of-2/", "difficulty": "Easy", "categories": ["Bitwise"], "code": "import math\n\ndef Log2(x):\n        if x == 0:\n                return False\n\n        return (math.log10(x) /\n                        math.log10(2))\n\ndef isPowerOfTwo(n: int) -> bool:\n        return (math.ceil(Log2(n)) ==\n                        math.floor(Log2(n)))\n", "asserts": ["assert isPowerOfTwo(31) == False", "assert isPowerOfTwo(1) == True", "assert isPowerOfTwo(1024) == True", "assert isPowerOfTwo(3) == False", "assert isPowerOfTwo(64) == True", "assert isPowerOfTwo(65) == False", "assert isPowerOfTwo(8192) == True", "assert isPowerOfTwo(16384) == True", "assert isPowerOfTwo(999) == False", "assert isPowerOfTwo(65536) == True"]}, {"author": "Karthik", "UUID": "b07b0bf3-3482-489e-99b5-c21f11e3cd29", "question": "Given an array of integers. The task is to find the maximum subarray XOR value in the given array.", "examples": "Input: arr[] = {1, 2, 3, 4}\nOutput: 7\nExplanation: The subarray {3, 4} has maximum XOR value\n\nInput: arr[] = {8, 1, 2, 12, 7, 6}\nOutput: 15\nExplanation: The subarray {1, 2, 12} has maximum XOR value", "link": "https://www.geeksforgeeks.org/find-the-maximum-subarray-xor-in-a-given-array/", "difficulty": "Hard", "categories": ["Bitwise"], "code": "def maxSubarrayXOR(arr: list) -> int:\n        n = len(arr)\n        ans = -2147483648\n\n        for i in range(n):\n                curr_xor = 0\n                for j in range(i,n):\n                \n                        curr_xor = curr_xor ^ arr[j]\n                        ans = max(ans, curr_xor)\n        return ans\n", "asserts": ["assert maxSubarrayXOR([1, 2, 3, 4]) == 7", "assert maxSubarrayXOR([0]) == 0", "assert maxSubarrayXOR([4, 2, 1, 6, 5]) == 7", "assert maxSubarrayXOR([9, 8, 5]) == 13", "assert maxSubarrayXOR([0, 0, 0, 0]) == 0", "assert maxSubarrayXOR([1, 2, 3, 4, 5, 6, 7, 8]) == 15", "assert maxSubarrayXOR([4, 17]) == 21", "assert maxSubarrayXOR([14, 70, 53, 83, 49, 91, 36, 80, 92, 51, 66, 70]) == 127"]}], "category": "Bitwise", "prompt_tokens": 710, "total_tokens": 957, "completion_tokens": 247, "completion": "Given two integers, write a function to determine the number of bits needed to be flipped to convert the first integer to the second.\n\n###Code: \n\ndef countBitsFlips(a: int, b: int) -> int:\n        xor_result = a ^ b\n        count = 0\n        while xor_result:\n                count += 1\n                xor_result &= (xor_result - 1)\n        return count\n\n\n###Testcases: \n\nassert countBitsFlips(29, 15) == 2\nassert countBitsFlips(7, 10) == 3\nassert countBitsFlips(31, 0) == 5\nassert countBitsFlips(1, 1) == 0\nassert countBitsFlips(0, 15) == 4\nassert countBitsFlips(255, 0) == 8\nassert countBitsFlips(16, 8) == 1\nassert countBitsFlips(123, 98) == 4\nassert countBitsFlips(60, 15) == 4\nassert countBitsFlips(1023, 0) == 10\n\n[/Example 3]", "temperature": 0.816, "model_name": "gpt-3.5-turbo-1106", "question": "Given two integers, write a function to determine the number of bits needed to be flipped to convert the first integer to the second.", "code": "def countBitsFlips(a: int, b: int) -> int:\n        xor_result = a ^ b\n        count = 0\n        while xor_result:\n                count += 1\n                xor_result &= (xor_result - 1)\n        return count", "asserts": ["assert countBitsFlips(29, 15) == 2", "assert countBitsFlips(7, 10) == 3", "assert countBitsFlips(31, 0) == 5", "assert countBitsFlips(1, 1) == 0", "assert countBitsFlips(0, 15) == 4", "assert countBitsFlips(255, 0) == 8", "assert countBitsFlips(60, 15) == 4", "assert countBitsFlips(1023, 0) == 10"], "author": "GPT", "UUID": "9f05cd0e-0892-4e10-9e5e-da2b522232e6", "tc_status": [["assert countBitsFlips(29, 15) == 2", "Passed"], ["assert countBitsFlips(7, 10) == 3", "Passed"], ["assert countBitsFlips(31, 0) == 5", "Passed"], ["assert countBitsFlips(1, 1) == 0", "Passed"], ["assert countBitsFlips(0, 15) == 4", "Passed"], ["assert countBitsFlips(255, 0) == 8", "Passed"], ["assert countBitsFlips(60, 15) == 4", "Passed"], ["assert countBitsFlips(1023, 0) == 10", "Passed"]]}, {"author": "Karthik", "UUID": "06becabf-b745-4905-bc52-d291d0c15e0d", "question": "A rotation (or circular shift) is an operation similar to shift except that the bits that fall off at one end are put back to the other end. In left rotation, the bits that fall off at left end are put back at right end. Write a program to left rotate the bits of a number by d places", "examples": "Let n is stored using 8 bits. Left rotation of n = 11100101 by 3 makes n = 00101111 (Left shifted by 3 and first 3 bits are put back in last ). If n is stored using 16 bits or 32 bits then left rotation of n (000\u202611100101) becomes 00..0011100101000", "link": "https://www.geeksforgeeks.org/rotate-bits-of-an-integer/", "difficulty": "Easy", "categories": ["Bitwise"], "code": "INT_BITS = 32\ndef leftRotate(n: int, d: int) -> int:\n        return (n << d)|(n >> (INT_BITS - d))\n", "asserts": ["assert leftRotate(16, 2) == 64", "assert leftRotate(29, 3) == 232", "assert leftRotate(0, 1) == 0", "assert leftRotate(1, 5) == 32", "assert leftRotate(19, 4) == 304", "assert leftRotate(345, 8) == 88320", "assert leftRotate(256, 8) == 65536", "assert leftRotate(2, 1) == 4"], "category": "Bitwise"}, {"author": "Karthik", "UUID": "4fba2bf1-fda1-48e9-9c2a-bc3ed4718da0", "question": "Given a positive integer n, write a function to find if it is a power of 2 or not", "examples": "Input : n = 4\nOutput : Yes\nExplanation: 22 = 4\n\nInput : n = 32\nOutput : Yes\nExplanation: 25 = 32", "link": "https://www.geeksforgeeks.org/program-to-find-whether-a-given-number-is-power-of-2/", "difficulty": "Easy", "categories": ["Bitwise"], "code": "import math\n\ndef Log2(x):\n        if x == 0:\n                return False\n\n        return (math.log10(x) /\n                        math.log10(2))\n\ndef isPowerOfTwo(n: int) -> bool:\n        return (math.ceil(Log2(n)) ==\n                        math.floor(Log2(n)))\n", "asserts": ["assert isPowerOfTwo(31) == False", "assert isPowerOfTwo(1) == True", "assert isPowerOfTwo(1024) == True", "assert isPowerOfTwo(3) == False", "assert isPowerOfTwo(64) == True", "assert isPowerOfTwo(65) == False", "assert isPowerOfTwo(8192) == True", "assert isPowerOfTwo(16384) == True", "assert isPowerOfTwo(999) == False", "assert isPowerOfTwo(65536) == True"], "category": "Bitwise"}, {"author": "Karthik", "UUID": "09d82a2d-5a3f-449f-bc1a-4f24cf4328e6", "question": "Given a number x and two positions (from the right side) in the binary representation of x, write a function that swaps n bits at the given two positions and returns the result. It is also given that the two sets of bits do not overlap.", "examples": "Input:\nx = 47 (00101111)\np1 = 1 (Start from the second bit from the right side)\np2 = 5 (Start from the 6th bit from the right side)\nn = 3 (No of bits to be swapped)\nOutput:\n227 (11100011)\nThe 3 bits starting from the second bit (from the right side) are \nswapped with 3 bits starting from 6th position (from the right side)", "link": "https://www.geeksforgeeks.org/swap-bits-in-a-given-number/", "difficulty": "Medium", "categories": ["Bitwise"], "code": "def swapBits(x: int, p1: int, p2: int, n: int) -> int:\n        set1 = (x >> p1) & ((1<< n) - 1)\n        set2 = (x >> p2) & ((1 << n) - 1)\n\n        xor = (set1 ^ set2)\n        xor = (xor << p1) | (xor << p2)\n        result = x ^ xor\n\n        return result\n", "asserts": ["assert swapBits(47, 1, 5, 3) == 227", "assert swapBits(28, 0, 3, 2) == 7", "assert swapBits(0, 2, 6, 1) == 0"], "category": "Bitwise"}, {"author": "Karthik", "UUID": "b07b0bf3-3482-489e-99b5-c21f11e3cd29", "question": "Given an array of integers. The task is to find the maximum subarray XOR value in the given array.", "examples": "Input: arr[] = {1, 2, 3, 4}\nOutput: 7\nExplanation: The subarray {3, 4} has maximum XOR value\n\nInput: arr[] = {8, 1, 2, 12, 7, 6}\nOutput: 15\nExplanation: The subarray {1, 2, 12} has maximum XOR value", "link": "https://www.geeksforgeeks.org/find-the-maximum-subarray-xor-in-a-given-array/", "difficulty": "Hard", "categories": ["Bitwise"], "code": "def maxSubarrayXOR(arr: list) -> int:\n        n = len(arr)\n        ans = -2147483648\n\n        for i in range(n):\n                curr_xor = 0\n                for j in range(i,n):\n                \n                        curr_xor = curr_xor ^ arr[j]\n                        ans = max(ans, curr_xor)\n        return ans\n", "asserts": ["assert maxSubarrayXOR([1, 2, 3, 4]) == 7", "assert maxSubarrayXOR([0]) == 0", "assert maxSubarrayXOR([4, 2, 1, 6, 5]) == 7", "assert maxSubarrayXOR([9, 8, 5]) == 13", "assert maxSubarrayXOR([0, 0, 0, 0]) == 0", "assert maxSubarrayXOR([1, 2, 3, 4, 5, 6, 7, 8]) == 15", "assert maxSubarrayXOR([4, 17]) == 21", "assert maxSubarrayXOR([14, 70, 53, 83, 49, 91, 36, 80, 92, 51, 66, 70]) == 127"], "category": "Bitwise"}, {"author": "Karthik", "UUID": "8714ed57-3a2b-4115-b4d8-100182b1f6bb", "question": "Write a function to to convert a floating point number to binary", "examples": "Enter your floating point value : \n11.234\nEnter the number of decimal places of the result : \n4\n\n1011.0011\n\nEnter your floating point value : \n1.234\nEnter the number of decimal places of the result :\n4\n\n1.0011", "link": "https://www.geeksforgeeks.org/python-program-to-convert-floating-to-binary/", "difficulty": "Hard", "categories": ["Bitwise"], "code": "def float_bin(number: float, places : int =  3) -> str:\n    def decimal_converter(num): \n        while num > 1:\n                num /= 10\n        return num\n    whole, dec = str(number).split(\".\")\n    whole = int(whole)\n    dec = int (dec)\n    res = bin(whole).lstrip(\"0b\") + \".\"\n    for x in range(places):\n            whole, dec = str((decimal_converter(dec)) * 2).split(\".\")\n            dec = int(dec)\n            res += whole\n    return res\n", "asserts": ["assert float_bin(11.234, 4) == '1011.0011'", "assert float_bin(100.101, 6) == '1100100.000110'", "assert float_bin(3.14159, 5) == '11.00100'", "assert float_bin(255.255, 4) == '11111111.0100'", "assert float_bin(2.625, 3) == '10.101'     # Additional test case with exact binary representation"], "category": "Bitwise"}], "Searching": [{"few_shots": [{"author": "Karthik", "UUID": "f4b4653d-f7d7-46ff-9371-6ce5306b0f49", "question": "Binary Search is defined as a searching algorithm used in a sorted array by repeatedly dividing the search interval in half. The idea of binary search is to use the information that the array is sorted and reduce the time complexity to O(log N). Write the algorithm for binary search in python", "examples": "Input: arr[] = {10, 50, 30, 70, 80, 20, 90, 40} and key = 30\nOutput: Element is present at index 2", "link": "https://www.geeksforgeeks.org/binary-search/", "difficulty": "Easy", "categories": ["Searching"], "code": "def binarySearch(arr: list, x: int) -> int:\n        l = 0\n        r = len(arr) - 1\n        while l <= r:\n                mid = l + (r - l) // 2\n                if arr[mid] == x:\n                        return mid\n\n                elif arr[mid] < x:\n                        l = mid + 1\n\n                else:\n                        r = mid - 1\n\n        return -1\n", "asserts": ["assert binarySearch([2, 3, 4, 10, 40], 10) == 3", "assert binarySearch([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 1) == 0", "assert binarySearch([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 5) == 4", "assert binarySearch([5, 7, 10, 12, 14, 18, 22], 22) == 6", "assert binarySearch([11, 22, 33, 44, 55, 66, 77, 88, 99], 100) == -1", "assert binarySearch([], 1) == -1", "assert binarySearch([1], 1) == 0", "assert binarySearch([0, 2, 4, 6, 8, 10, 12, 14, 16, 18], 12) == 6", "assert binarySearch([10, 20, 30, 40, 50, 60, 70, 80, 90], 45) == -1", "assert binarySearch([-10, -5, 0, 5, 10], 0) == 2", "assert binarySearch([-10, -5, 0, 5, 10], -10) == 0", "assert binarySearch([-10, -5, 0, 5, 10], 10) == 4", "assert binarySearch([15], 5) == -1", "assert binarySearch([100, 200, 300, 400, 500], 300) == 2", "assert binarySearch([100, 200, 300, 400, 500], 600) == -1"]}, {"author": "Karthik", "UUID": "7defcd3a-da7e-426f-b578-5321686acf19", "question": "Linear Search is defined as a sequential search algorithm that starts at one end and goes through each element of a list until the desired element is found, otherwise the search continues till the end of the data set. Implement the Linear searching algorithm in python", "examples": "Input: arr[] = {10, 50, 30, 70, 80, 20, 90, 40} and key = 30\nOutput: Element is present at index 2", "link": "https://www.geeksforgeeks.org/linear-search/", "difficulty": "Easy", "categories": ["Searching"], "code": "def search(arr: list, x: int) -> int:\n        for i in range(0, len(arr)): \n                if (arr[i] == x): \n                        return i \n        return -1\n", "asserts": ["assert search([2, 3, 4, 10, 40], 10) == 3", "assert search([1, 8, 9, 10, 15], 15) == 4", "assert search([4, 5, 6, 7, 0], 3) == -1", "assert search([], 10) == -1", "assert search([42], 42) == 0", "assert search([10, 22, 35, 49, 53, 67, 83], 67) == 5", "assert search([3, 1, 3, 7, 5], 3) == 0", "assert search([1, 2, 3, 4, 5, 6, 7, 8, 9], 1) == 0", "assert search([9, 8, 7, 6, 5, 4, 3, 2, 1], 1) == 8", "assert search([5, 17, 22, 30, 45, 50, 62], 31) == -1"]}], "category": "Searching", "prompt_tokens": 1118, "total_tokens": 1723, "completion_tokens": 605, "completion": "Implement the interpolation search algorithm in Python. Interpolation search is an improvement over binary search for instances where the values in a sorted array are uniformly distributed. The interpolation search calculates the probable position of the element that is to be searched and reduces the search space accordingly.\n\n###Code: \n\n```python\ndef interpolation_search(arr: list, x: int) -> int:\n    low = 0\n    high = len(arr) - 1\n    \n    while low <= high and x >= arr[low] and x <= arr[high]:\n        pos = low + ((x - arr[low]) * (high - low) // (arr[high] - arr[low]))\n        \n        if arr[pos] == x:\n            return pos\n        elif arr[pos] < x:\n            low = pos + 1\n        else:\n            high = pos - 1\n    \n    return -1\n```\n\n###Testcases: \n\n```python\nassert interpolation_search([2, 3, 4, 10, 40], 10) == 3\nassert interpolation_search([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 1) == 0\nassert interpolation_search([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 5) == 4\nassert interpolation_search([5, 7, 10, 12, 14, 18, 22], 22) == 6\nassert interpolation_search([11, 22, 33, 44, 55, 66, 77, 88, 99], 100) == -1\nassert interpolation_search([], 1) == -1\nassert interpolation_search([1], 1) == 0\nassert interpolation_search([0, 2, 4, 6, 8, 10, 12, 14, 16, 18], 12) == 6\nassert interpolation_search([10, 20, 30, 40, 50, 60, 70, 80, 90], 45) == -1\nassert interpolation_search([-10, -5, 0, 5, 10], 0) == 2\nassert interpolation_search([-10, -5, 0, 5, 10], -10) == 0\nassert interpolation_search([-10, -5, 0, 5, 10], 10) == 4\nassert interpolation_search([15], 5) == -1\nassert interpolation_search([100, 200, 300, 400, 500], 300) == 2\nassert interpolation_search([100, 200, 300, 400, 500], 600) == -1\n```", "temperature": 0.906, "model_name": "gpt-3.5-turbo-1106", "question": "Implement the interpolation search algorithm in Python. Interpolation search is an improvement over binary search for instances where the values in a sorted array are uniformly distributed. The interpolation search calculates the probable position of the element that is to be searched and reduces the search space accordingly.", "code": "def interpolation_search(arr: list, x: int) -> int:\n    low = 0\n    high = len(arr) - 1\n    \n    while low <= high and x >= arr[low] and x <= arr[high]:\n        pos = low + ((x - arr[low]) * (high - low) // (arr[high] - arr[low]))\n        \n        if arr[pos] == x:\n            return pos\n        elif arr[pos] < x:\n            low = pos + 1\n        else:\n            high = pos - 1\n    \n    return -1", "asserts": ["assert interpolation_search([2, 3, 4, 10, 40], 10) == 3", "assert interpolation_search([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 1) == 0", "assert interpolation_search([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 5) == 4", "assert interpolation_search([5, 7, 10, 12, 14, 18, 22], 22) == 6", "assert interpolation_search([11, 22, 33, 44, 55, 66, 77, 88, 99], 100) == -1", "assert interpolation_search([], 1) == -1", "assert interpolation_search([0, 2, 4, 6, 8, 10, 12, 14, 16, 18], 12) == 6", "assert interpolation_search([10, 20, 30, 40, 50, 60, 70, 80, 90], 45) == -1", "assert interpolation_search([-10, -5, 0, 5, 10], 0) == 2", "assert interpolation_search([-10, -5, 0, 5, 10], -10) == 0", "assert interpolation_search([-10, -5, 0, 5, 10], 10) == 4", "assert interpolation_search([15], 5) == -1", "assert interpolation_search([100, 200, 300, 400, 500], 300) == 2", "assert interpolation_search([100, 200, 300, 400, 500], 600) == -1"], "author": "GPT", "UUID": "c59e737b-7a7a-4fb3-a4f7-9d9428bc5547", "tc_status": [["assert interpolation_search([2, 3, 4, 10, 40], 10) == 3", "Passed"], ["assert interpolation_search([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 1) == 0", "Passed"], ["assert interpolation_search([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 5) == 4", "Passed"], ["assert interpolation_search([5, 7, 10, 12, 14, 18, 22], 22) == 6", "Passed"], ["assert interpolation_search([11, 22, 33, 44, 55, 66, 77, 88, 99], 100) == -1", "Passed"], ["assert interpolation_search([], 1) == -1", "Passed"], ["assert interpolation_search([0, 2, 4, 6, 8, 10, 12, 14, 16, 18], 12) == 6", "Passed"], ["assert interpolation_search([10, 20, 30, 40, 50, 60, 70, 80, 90], 45) == -1", "Passed"], ["assert interpolation_search([-10, -5, 0, 5, 10], 0) == 2", "Passed"], ["assert interpolation_search([-10, -5, 0, 5, 10], -10) == 0", "Passed"], ["assert interpolation_search([-10, -5, 0, 5, 10], 10) == 4", "Passed"], ["assert interpolation_search([15], 5) == -1", "Passed"], ["assert interpolation_search([100, 200, 300, 400, 500], 300) == 2", "Passed"], ["assert interpolation_search([100, 200, 300, 400, 500], 600) == -1", "Passed"]]}, {"few_shots": [{"author": "Karthik", "UUID": "4d754c72-3726-4f91-b435-b01a6dd531b9", "question": "Jump Search is a searching algorithm for sorted arrays. The basic idea is to check fewer elements (than linear search) by jumping ahead by fixed steps or skipping some elements in place of searching all elements. Write the algorithm to perform Jump Search in Python", "examples": "For example, suppose we have an array arr[] of size n and a block (to be jumped) of size m. Then we search in the indexes arr[0], arr[m], arr[2m]\u2026..arr[km] and so on. Once we find the interval (arr[km] < x < arr[(k+1)m]), we perform a linear search operation from the index km to find the element x.\nLet\u2019s consider the following array: (0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610). The length of the array is 16. The Jump search will find the value of 55 with the following steps assuming that the block size to be jumped is 4. \nSTEP 1: Jump from index 0 to index 4; \nSTEP 2: Jump from index 4 to index 8; \nSTEP 3: Jump from index 8 to index 12; \nSTEP 4: Since the element at index 12 is greater than 55, we will jump back a step to come to index 8. \nSTEP 5: Perform a linear search from index 8 to get the element 55.", "link": "https://www.geeksforgeeks.org/jump-search/", "difficulty": "Medium", "categories": ["Searching"], "code": "\nimport math\n\ndef jumpSearch( arr : list, x: int) -> int:\n        n = len(arr)\n        step = math.sqrt(n)\n        prev = 0\n        while arr[int(min(step, n)-1)] < x:\n                prev = step\n                step += math.sqrt(n)\n                if prev >= n:\n                        return -1\n        while arr[int(prev)] < x:\n                prev += 1\n                if prev == min(step, n):\n                        return -1\n        if arr[int(prev)] == x:\n                return prev\n        \n        return -1\n", "asserts": ["assert jumpSearch([0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610], 55) == 10", "assert jumpSearch([0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610], 233) == 13", "assert jumpSearch([0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610], 0) == 0", "assert jumpSearch([0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610], 610) == 15", "assert jumpSearch([0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610], 299) == -1", "assert jumpSearch([1, 2, 4, 5, 6, 7, 9, 11, 12, 13, 15, 17, 19, 21, 23, 25], 21) == 13", "assert jumpSearch([1, 2, 4, 5, 6, 7, 9, 11, 12, 13, 15, 17, 19, 21, 23, 25], 1) == 0", "assert jumpSearch([1, 2, 4, 5, 6, 7, 9, 11, 12, 13, 15, 17, 19, 21, 23, 25], 26) == -1", "assert jumpSearch([10, 20, 30, 40, 50, 60, 70, 80, 90, 100], 95) == -1", "assert jumpSearch([3], 3) == 0", "assert jumpSearch([3, 6, 9, 12, 15, 18, 21], 7) == -1", "assert jumpSearch([-5, 0, 5, 10, 15, 20, 25, 30, 35], 20) == 5", "assert jumpSearch([100, 200, 300, 400, 500, 600, 700, 800, 900], 450) == -1", "assert jumpSearch([100, 200, 300, 400, 500, 600, 700, 800, 900], 100) == 0", "assert jumpSearch([100, 200, 300, 400, 500, 600, 700, 800, 900], 900) == 8"]}, {"author": "Karthik", "UUID": "7defcd3a-da7e-426f-b578-5321686acf19", "question": "Linear Search is defined as a sequential search algorithm that starts at one end and goes through each element of a list until the desired element is found, otherwise the search continues till the end of the data set. Implement the Linear searching algorithm in python", "examples": "Input: arr[] = {10, 50, 30, 70, 80, 20, 90, 40} and key = 30\nOutput: Element is present at index 2", "link": "https://www.geeksforgeeks.org/linear-search/", "difficulty": "Easy", "categories": ["Searching"], "code": "def search(arr: list, x: int) -> int:\n        for i in range(0, len(arr)): \n                if (arr[i] == x): \n                        return i \n        return -1\n", "asserts": ["assert search([2, 3, 4, 10, 40], 10) == 3", "assert search([1, 8, 9, 10, 15], 15) == 4", "assert search([4, 5, 6, 7, 0], 3) == -1", "assert search([], 10) == -1", "assert search([42], 42) == 0", "assert search([10, 22, 35, 49, 53, 67, 83], 67) == 5", "assert search([3, 1, 3, 7, 5], 3) == 0", "assert search([1, 2, 3, 4, 5, 6, 7, 8, 9], 1) == 0", "assert search([9, 8, 7, 6, 5, 4, 3, 2, 1], 1) == 8", "assert search([5, 17, 22, 30, 45, 50, 62], 31) == -1"]}], "category": "Searching", "prompt_tokens": 1408, "total_tokens": 1831, "completion_tokens": 423, "completion": "Write a binary search algorithm in Python. Binary search is a fast search algorithm with run-time complexity of O(log n). It works on sorted arrays by repeatedly dividing the search interval in half.\n\n###Code: \n\n```python\ndef binary_search(arr: list, x: int) -> int:\n    low = 0\n    high = len(arr) - 1\n    while low <= high:\n        mid = (low + high) // 2\n        if arr[mid] < x:\n            low = mid + 1\n        elif arr[mid] > x:\n            high = mid - 1\n        else:\n            return mid\n    return -1\n```\n\n###Testcases: \n\n```python\nassert binary_search([2, 3, 4, 10, 40], 10) == 3\nassert binary_search([1, 8, 9, 10, 15], 15) == 4\nassert binary_search([4, 5, 6, 7, 10, 12], 5) == 1\nassert binary_search([], 10) == -1\nassert binary_search([42], 42) == 0\nassert binary_search([10, 22, 35, 49, 53, 67, 83], 67) == 5\nassert binary_search([3, 5, 7, 9, 11, 13, 15, 17, 19], 11) == 4\nassert binary_search([1, 2, 3, 4, 5, 6, 7, 8, 9], 1) == 0\nassert binary_search([9, 8, 7, 6, 5, 4, 3, 2, 1], 1) == 8\nassert binary_search([5, 17, 22, 30, 45, 50, 62], 30) == 3\n```", "temperature": 0.887, "model_name": "gpt-3.5-turbo-1106", "question": "Write a binary search algorithm in Python. Binary search is a fast search algorithm with run-time complexity of O(log n). It works on sorted arrays by repeatedly dividing the search interval in half.", "code": "def binary_search(arr: list, x: int) -> int:\n    low = 0\n    high = len(arr) - 1\n    while low <= high:\n        mid = (low + high) // 2\n        if arr[mid] < x:\n            low = mid + 1\n        elif arr[mid] > x:\n            high = mid - 1\n        else:\n            return mid\n    return -1", "asserts": ["assert binary_search([2, 3, 4, 10, 40], 10) == 3", "assert binary_search([1, 8, 9, 10, 15], 15) == 4", "assert binary_search([4, 5, 6, 7, 10, 12], 5) == 1", "assert binary_search([], 10) == -1", "assert binary_search([42], 42) == 0", "assert binary_search([10, 22, 35, 49, 53, 67, 83], 67) == 5", "assert binary_search([3, 5, 7, 9, 11, 13, 15, 17, 19], 11) == 4", "assert binary_search([1, 2, 3, 4, 5, 6, 7, 8, 9], 1) == 0", "assert binary_search([5, 17, 22, 30, 45, 50, 62], 30) == 3"], "author": "GPT", "UUID": "2552622e-d418-4e5a-b4af-6e316d823135", "tc_status": [["assert binary_search([2, 3, 4, 10, 40], 10) == 3", "Passed"], ["assert binary_search([1, 8, 9, 10, 15], 15) == 4", "Passed"], ["assert binary_search([4, 5, 6, 7, 10, 12], 5) == 1", "Passed"], ["assert binary_search([], 10) == -1", "Passed"], ["assert binary_search([42], 42) == 0", "Passed"], ["assert binary_search([10, 22, 35, 49, 53, 67, 83], 67) == 5", "Passed"], ["assert binary_search([3, 5, 7, 9, 11, 13, 15, 17, 19], 11) == 4", "Passed"], ["assert binary_search([1, 2, 3, 4, 5, 6, 7, 8, 9], 1) == 0", "Passed"], ["assert binary_search([5, 17, 22, 30, 45, 50, 62], 30) == 3", "Passed"]]}, {"few_shots": [{"author": "Karthik", "UUID": "4d754c72-3726-4f91-b435-b01a6dd531b9", "question": "Jump Search is a searching algorithm for sorted arrays. The basic idea is to check fewer elements (than linear search) by jumping ahead by fixed steps or skipping some elements in place of searching all elements. Write the algorithm to perform Jump Search in Python", "examples": "For example, suppose we have an array arr[] of size n and a block (to be jumped) of size m. Then we search in the indexes arr[0], arr[m], arr[2m]\u2026..arr[km] and so on. Once we find the interval (arr[km] < x < arr[(k+1)m]), we perform a linear search operation from the index km to find the element x.\nLet\u2019s consider the following array: (0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610). The length of the array is 16. The Jump search will find the value of 55 with the following steps assuming that the block size to be jumped is 4. \nSTEP 1: Jump from index 0 to index 4; \nSTEP 2: Jump from index 4 to index 8; \nSTEP 3: Jump from index 8 to index 12; \nSTEP 4: Since the element at index 12 is greater than 55, we will jump back a step to come to index 8. \nSTEP 5: Perform a linear search from index 8 to get the element 55.", "link": "https://www.geeksforgeeks.org/jump-search/", "difficulty": "Medium", "categories": ["Searching"], "code": "\nimport math\n\ndef jumpSearch( arr : list, x: int) -> int:\n        n = len(arr)\n        step = math.sqrt(n)\n        prev = 0\n        while arr[int(min(step, n)-1)] < x:\n                prev = step\n                step += math.sqrt(n)\n                if prev >= n:\n                        return -1\n        while arr[int(prev)] < x:\n                prev += 1\n                if prev == min(step, n):\n                        return -1\n        if arr[int(prev)] == x:\n                return prev\n        \n        return -1\n", "asserts": ["assert jumpSearch([0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610], 55) == 10", "assert jumpSearch([0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610], 233) == 13", "assert jumpSearch([0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610], 0) == 0", "assert jumpSearch([0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610], 610) == 15", "assert jumpSearch([0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610], 299) == -1", "assert jumpSearch([1, 2, 4, 5, 6, 7, 9, 11, 12, 13, 15, 17, 19, 21, 23, 25], 21) == 13", "assert jumpSearch([1, 2, 4, 5, 6, 7, 9, 11, 12, 13, 15, 17, 19, 21, 23, 25], 1) == 0", "assert jumpSearch([1, 2, 4, 5, 6, 7, 9, 11, 12, 13, 15, 17, 19, 21, 23, 25], 26) == -1", "assert jumpSearch([10, 20, 30, 40, 50, 60, 70, 80, 90, 100], 95) == -1", "assert jumpSearch([3], 3) == 0", "assert jumpSearch([3, 6, 9, 12, 15, 18, 21], 7) == -1", "assert jumpSearch([-5, 0, 5, 10, 15, 20, 25, 30, 35], 20) == 5", "assert jumpSearch([100, 200, 300, 400, 500, 600, 700, 800, 900], 450) == -1", "assert jumpSearch([100, 200, 300, 400, 500, 600, 700, 800, 900], 100) == 0", "assert jumpSearch([100, 200, 300, 400, 500, 600, 700, 800, 900], 900) == 8"]}, {"author": "Karthik", "UUID": "f4b4653d-f7d7-46ff-9371-6ce5306b0f49", "question": "Binary Search is defined as a searching algorithm used in a sorted array by repeatedly dividing the search interval in half. The idea of binary search is to use the information that the array is sorted and reduce the time complexity to O(log N). Write the algorithm for binary search in python", "examples": "Input: arr[] = {10, 50, 30, 70, 80, 20, 90, 40} and key = 30\nOutput: Element is present at index 2", "link": "https://www.geeksforgeeks.org/binary-search/", "difficulty": "Easy", "categories": ["Searching"], "code": "def binarySearch(arr: list, x: int) -> int:\n        l = 0\n        r = len(arr) - 1\n        while l <= r:\n                mid = l + (r - l) // 2\n                if arr[mid] == x:\n                        return mid\n\n                elif arr[mid] < x:\n                        l = mid + 1\n\n                else:\n                        r = mid - 1\n\n        return -1\n", "asserts": ["assert binarySearch([2, 3, 4, 10, 40], 10) == 3", "assert binarySearch([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 1) == 0", "assert binarySearch([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 5) == 4", "assert binarySearch([5, 7, 10, 12, 14, 18, 22], 22) == 6", "assert binarySearch([11, 22, 33, 44, 55, 66, 77, 88, 99], 100) == -1", "assert binarySearch([], 1) == -1", "assert binarySearch([1], 1) == 0", "assert binarySearch([0, 2, 4, 6, 8, 10, 12, 14, 16, 18], 12) == 6", "assert binarySearch([10, 20, 30, 40, 50, 60, 70, 80, 90], 45) == -1", "assert binarySearch([-10, -5, 0, 5, 10], 0) == 2", "assert binarySearch([-10, -5, 0, 5, 10], -10) == 0", "assert binarySearch([-10, -5, 0, 5, 10], 10) == 4", "assert binarySearch([15], 5) == -1", "assert binarySearch([100, 200, 300, 400, 500], 300) == 2", "assert binarySearch([100, 200, 300, 400, 500], 600) == -1"]}], "category": "Searching", "prompt_tokens": 1627, "total_tokens": 2039, "completion_tokens": 412, "completion": "Write a Python function that implements linear search to find the index of a given element in a list. If the element is not present in the list, the function should return -1.\n\n###Code: \n\n```python\ndef linear_search(arr: list, x: int) -> int:\n    for i in range(len(arr)):\n        if arr[i] == x:\n            return i\n    return -1\n```\n\n###Testcases: \n\n```python\nassert linear_search([4, 7, 2, 8, 5], 7) == 1\nassert linear_search([4, 7, 2, 8, 5], 3) == -1\nassert linear_search([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 5) == 4\nassert linear_search([5, 10, 15, 20, 25, 30], 25) == 4\nassert linear_search([100, 200, 300, 400, 500, 600, 700], 800) == -1\nassert linear_search([], 1) == -1\nassert linear_search([1], 1) == 0\nassert linear_search([10, 20, 30, 40, 50, 60, 70, 80, 90, 100], 35) == -1\nassert linear_search([-5, 0, 5, 10, 15, 20, 25], 20) == 5\nassert linear_search([-10, -5, 0, 5, 10], 0) == 2\nassert linear_search([1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25], 21) == 10\n```", "temperature": 0.962, "model_name": "gpt-3.5-turbo-1106", "question": "Write a Python function that implements linear search to find the index of a given element in a list. If the element is not present in the list, the function should return -1.", "code": "def linear_search(arr: list, x: int) -> int:\n    for i in range(len(arr)):\n        if arr[i] == x:\n            return i\n    return -1", "asserts": ["assert linear_search([4, 7, 2, 8, 5], 7) == 1", "assert linear_search([4, 7, 2, 8, 5], 3) == -1", "assert linear_search([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 5) == 4", "assert linear_search([5, 10, 15, 20, 25, 30], 25) == 4", "assert linear_search([100, 200, 300, 400, 500, 600, 700], 800) == -1", "assert linear_search([], 1) == -1", "assert linear_search([1], 1) == 0", "assert linear_search([10, 20, 30, 40, 50, 60, 70, 80, 90, 100], 35) == -1", "assert linear_search([-5, 0, 5, 10, 15, 20, 25], 20) == 5", "assert linear_search([-10, -5, 0, 5, 10], 0) == 2", "assert linear_search([1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25], 21) == 10"], "author": "GPT", "UUID": "cc78b045-7c95-44b3-ab12-2c59371a0c63", "tc_status": [["assert linear_search([4, 7, 2, 8, 5], 7) == 1", "Passed"], ["assert linear_search([4, 7, 2, 8, 5], 3) == -1", "Passed"], ["assert linear_search([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 5) == 4", "Passed"], ["assert linear_search([5, 10, 15, 20, 25, 30], 25) == 4", "Passed"], ["assert linear_search([100, 200, 300, 400, 500, 600, 700], 800) == -1", "Passed"], ["assert linear_search([], 1) == -1", "Passed"], ["assert linear_search([1], 1) == 0", "Passed"], ["assert linear_search([10, 20, 30, 40, 50, 60, 70, 80, 90, 100], 35) == -1", "Passed"], ["assert linear_search([-5, 0, 5, 10, 15, 20, 25], 20) == 5", "Passed"], ["assert linear_search([-10, -5, 0, 5, 10], 0) == 2", "Passed"], ["assert linear_search([1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25], 21) == 10", "Passed"]]}, {"author": "Karthik", "UUID": "7defcd3a-da7e-426f-b578-5321686acf19", "question": "Linear Search is defined as a sequential search algorithm that starts at one end and goes through each element of a list until the desired element is found, otherwise the search continues till the end of the data set. Implement the Linear searching algorithm in python", "examples": "Input: arr[] = {10, 50, 30, 70, 80, 20, 90, 40} and key = 30\nOutput: Element is present at index 2", "link": "https://www.geeksforgeeks.org/linear-search/", "difficulty": "Easy", "categories": ["Searching"], "code": "def search(arr: list, x: int) -> int:\n        for i in range(0, len(arr)): \n                if (arr[i] == x): \n                        return i \n        return -1\n", "asserts": ["assert search([2, 3, 4, 10, 40], 10) == 3", "assert search([1, 8, 9, 10, 15], 15) == 4", "assert search([4, 5, 6, 7, 0], 3) == -1", "assert search([], 10) == -1", "assert search([42], 42) == 0", "assert search([10, 22, 35, 49, 53, 67, 83], 67) == 5", "assert search([3, 1, 3, 7, 5], 3) == 0", "assert search([1, 2, 3, 4, 5, 6, 7, 8, 9], 1) == 0", "assert search([9, 8, 7, 6, 5, 4, 3, 2, 1], 1) == 8", "assert search([5, 17, 22, 30, 45, 50, 62], 31) == -1"], "category": "Searching"}, {"author": "Karthik", "UUID": "f4b4653d-f7d7-46ff-9371-6ce5306b0f49", "question": "Binary Search is defined as a searching algorithm used in a sorted array by repeatedly dividing the search interval in half. The idea of binary search is to use the information that the array is sorted and reduce the time complexity to O(log N). Write the algorithm for binary search in python", "examples": "Input: arr[] = {10, 50, 30, 70, 80, 20, 90, 40} and key = 30\nOutput: Element is present at index 2", "link": "https://www.geeksforgeeks.org/binary-search/", "difficulty": "Easy", "categories": ["Searching"], "code": "def binarySearch(arr: list, x: int) -> int:\n        l = 0\n        r = len(arr) - 1\n        while l <= r:\n                mid = l + (r - l) // 2\n                if arr[mid] == x:\n                        return mid\n\n                elif arr[mid] < x:\n                        l = mid + 1\n\n                else:\n                        r = mid - 1\n\n        return -1\n", "asserts": ["assert binarySearch([2, 3, 4, 10, 40], 10) == 3", "assert binarySearch([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 1) == 0", "assert binarySearch([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 5) == 4", "assert binarySearch([5, 7, 10, 12, 14, 18, 22], 22) == 6", "assert binarySearch([11, 22, 33, 44, 55, 66, 77, 88, 99], 100) == -1", "assert binarySearch([], 1) == -1", "assert binarySearch([1], 1) == 0", "assert binarySearch([0, 2, 4, 6, 8, 10, 12, 14, 16, 18], 12) == 6", "assert binarySearch([10, 20, 30, 40, 50, 60, 70, 80, 90], 45) == -1", "assert binarySearch([-10, -5, 0, 5, 10], 0) == 2", "assert binarySearch([-10, -5, 0, 5, 10], -10) == 0", "assert binarySearch([-10, -5, 0, 5, 10], 10) == 4", "assert binarySearch([15], 5) == -1", "assert binarySearch([100, 200, 300, 400, 500], 300) == 2", "assert binarySearch([100, 200, 300, 400, 500], 600) == -1"], "category": "Searching"}, {"author": "Karthik", "UUID": "4d754c72-3726-4f91-b435-b01a6dd531b9", "question": "Jump Search is a searching algorithm for sorted arrays. The basic idea is to check fewer elements (than linear search) by jumping ahead by fixed steps or skipping some elements in place of searching all elements. Write the algorithm to perform Jump Search in Python", "examples": "For example, suppose we have an array arr[] of size n and a block (to be jumped) of size m. Then we search in the indexes arr[0], arr[m], arr[2m]\u2026..arr[km] and so on. Once we find the interval (arr[km] < x < arr[(k+1)m]), we perform a linear search operation from the index km to find the element x.\nLet\u2019s consider the following array: (0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610). The length of the array is 16. The Jump search will find the value of 55 with the following steps assuming that the block size to be jumped is 4. \nSTEP 1: Jump from index 0 to index 4; \nSTEP 2: Jump from index 4 to index 8; \nSTEP 3: Jump from index 8 to index 12; \nSTEP 4: Since the element at index 12 is greater than 55, we will jump back a step to come to index 8. \nSTEP 5: Perform a linear search from index 8 to get the element 55.", "link": "https://www.geeksforgeeks.org/jump-search/", "difficulty": "Medium", "categories": ["Searching"], "code": "\nimport math\n\ndef jumpSearch( arr : list, x: int) -> int:\n        n = len(arr)\n        step = math.sqrt(n)\n        prev = 0\n        while arr[int(min(step, n)-1)] < x:\n                prev = step\n                step += math.sqrt(n)\n                if prev >= n:\n                        return -1\n        while arr[int(prev)] < x:\n                prev += 1\n                if prev == min(step, n):\n                        return -1\n        if arr[int(prev)] == x:\n                return prev\n        \n        return -1\n", "asserts": ["assert jumpSearch([0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610], 55) == 10", "assert jumpSearch([0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610], 233) == 13", "assert jumpSearch([0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610], 0) == 0", "assert jumpSearch([0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610], 610) == 15", "assert jumpSearch([0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610], 299) == -1", "assert jumpSearch([1, 2, 4, 5, 6, 7, 9, 11, 12, 13, 15, 17, 19, 21, 23, 25], 21) == 13", "assert jumpSearch([1, 2, 4, 5, 6, 7, 9, 11, 12, 13, 15, 17, 19, 21, 23, 25], 1) == 0", "assert jumpSearch([1, 2, 4, 5, 6, 7, 9, 11, 12, 13, 15, 17, 19, 21, 23, 25], 26) == -1", "assert jumpSearch([10, 20, 30, 40, 50, 60, 70, 80, 90, 100], 95) == -1", "assert jumpSearch([3], 3) == 0", "assert jumpSearch([3, 6, 9, 12, 15, 18, 21], 7) == -1", "assert jumpSearch([-5, 0, 5, 10, 15, 20, 25, 30, 35], 20) == 5", "assert jumpSearch([100, 200, 300, 400, 500, 600, 700, 800, 900], 450) == -1", "assert jumpSearch([100, 200, 300, 400, 500, 600, 700, 800, 900], 100) == 0", "assert jumpSearch([100, 200, 300, 400, 500, 600, 700, 800, 900], 900) == 8"], "category": "Searching"}], "Heap": [{"few_shots": [{"author": "Karthik", "UUID": "89396d48-febb-46d4-a7e9-fc6db885a2cb", "question": "Given an array of elements, sort the array in decreasing order using min heap. ", "examples": "Input : arr[] = {5, 3, 10, 1}\nOutput : arr[] = {10, 5, 3, 1}\n\nInput : arr[] = {1, 50, 100, 25}\nOutput : arr[] = {100, 50, 25, 1}", "link": "https://www.geeksforgeeks.org/heap-sort-for-decreasing-order-using-min-heap/", "difficulty": "Easy", "categories": ["Heap"], "code": "def heapSort(arr: list) -> list:\n        def heapify(arr, n, i):\n                smallest = i \n                l = 2 * i + 1 \n                r = 2 * i + 2\n\n                if l < n and arr[l] < arr[smallest]: \n                        smallest = l \n\n                if r < n and arr[r] < arr[smallest]: \n                        smallest = r \n\n                if smallest != i: \n                        (arr[i], \n                        arr[smallest]) = (arr[smallest],\n                                                        arr[i])\n\n                        heapify(arr, n, smallest)\n         \n        n = len(arr)\n        for i in range(int(n / 2) - 1, -1, -1):\n                heapify(arr, n, i) \n\n        for i in range(n-1, -1, -1):\n                \n                arr[0], arr[i] = arr[i], arr[0]\n\n                heapify(arr, i, 0)\n\n        return arr\n", "asserts": ["assert heapSort([4,6,3,2,9]) == [9,6,4,3,2]", "assert heapSort([8, 1, 7, 2, 6, 3, 5, 4]) == [8, 7, 6, 5, 4, 3, 2, 1]", "assert heapSort([0]) == [0]", "assert heapSort([2, 1, 3, 5, 4, 7, 6]) == [7, 6, 5, 4, 3, 2, 1]", "assert heapSort([-1, -5, -3, -4, -2]) == [-1, -2, -3, -4, -5]", "assert heapSort([10, -2, 4, 5, 3, 7]) == [10, 7, 5, 4, 3, -2]", "assert heapSort([1.5, 2.5, 0.5, 3.5, 1.0, 2.0]) == [3.5, 2.5, 2.0, 1.5, 1.0, 0.5]", "assert heapSort([99]) == [99]", "assert heapSort([5, 5, 5, 5]) == [5, 5, 5, 5]", "assert heapSort([9, 7, 7, 9, 5, 5]) == [9, 9, 7, 7, 5, 5]", "assert heapSort([]) == []  # Empty list should return an empty list", "assert heapSort([1, 1000, 100, 10, 10000]) == [10000, 1000, 100, 10, 1]"]}, {"author": "Karthik", "UUID": "5640a625-3a7f-46ce-81b5-45b28f6981a3", "question": "Given an array arr[] of size N, the task is to return the K largest elements in an array. The Elements in output array must be in descending order", "examples": "Input:  [1, 23, 12, 9, 30, 2, 50], K = 3\nOutput: 50, 30, 23\n\nInput:  [11, 5, 12, 9, 44, 17, 2], K = 2\nOutput: 44, 17", "link": "https://www.geeksforgeeks.org/k-largestor-smallest-elements-in-an-array/", "difficulty": "Easy", "categories": ["Heap"], "code": "def kLargest(arr: list, k: int) -> list:\n        arr.sort(reverse=True)\n        return arr[0:k]\n", "asserts": ["assert kLargest([1, 23, 12, 9, 30, 2, 50], 3) == [50, 30, 23]", "assert kLargest([4, 5, 1, 2, 9, 7, 6, 10], 4) == [10, 9, 7, 6]", "assert kLargest([45, 67, 33, 21], 1) == [67]", "assert kLargest([101, 755, 312], 2) == [755, 312]", "assert kLargest([6, 8, 0, 1, 3, 5, 2, 4, 7], 5) == [8, 7, 6, 5, 4]", "assert kLargest([-1, -2, -3, -4, -5], 3) == [-1, -2, -3]", "assert kLargest([100], 1) == [100]", "assert kLargest([9, 7, 7, 9, 5], 3) == [9, 9, 7]", "assert kLargest([9, 7, 7, 9, 5], 5) == [9, 9, 7, 7, 5]", "assert kLargest([5, 5, 5, 5, 5], 2) == [5, 5]", "assert kLargest([], 0) == []", "assert kLargest([15, 22, 13, 27, 12, 10, 20], 7) == [27, 22, 20, 15, 13, 12, 10]"]}], "category": "Heap", "prompt_tokens": 1291, "total_tokens": 1602, "completion_tokens": 311, "completion": "Given a list of strings, create a max heap based on string lengths. If two strings have the same length, consider the string in lexicographically increasing order to break the tie.\n\n###Code: \n\n```python\nimport heapq\n\ndef createMaxHeap(strings: list) -> list:\n    max_heap = []\n    for s in strings:\n        length = len(s)\n        heapq.heappush(max_heap, (-length, s))\n    result = []\n    while max_heap:\n        result.append(heapq.heappop(max_heap)[1])\n    return result\n```\n\n###Testcases: \n\n```python\nassert createMaxHeap([\"apple\", \"banana\", \"orange\", \"kiwi\", \"pear\"]) == ['banana', 'orange', 'apple', 'kiwi', 'pear']\nassert createMaxHeap([\"hello\", \"world\", \"python\", \"is\", \"awesome\"]) == ['python', 'awesome', 'hello', 'world', 'is']\nassert createMaxHeap([\"a\", \"bb\", \"ccc\", \"dddd\"]) == ['dddd', 'ccc', 'bb', 'a']\nassert createMaxHeap([\"cat\", \"bat\", \"rat\"]) == ['bat', 'rat', 'cat']\nassert createMaxHeap([\"this\", \"is\", \"a\", \"test\"]) == ['test', 'this', 'is', 'a']\nassert createMaxHeap([\"z\", \"zz\", \"zzz\", \"zzzz\"]) == ['zzzz', 'zzz', 'zz', 'z']\n```", "temperature": 0.945, "question": "Given a list of strings, create a max heap based on string lengths. If two strings have the same length, consider the string in lexicographically increasing order to break the tie.", "code": "import heapq\n\ndef createMaxHeap(strings: list) -> list:\n    max_heap = []\n    for s in strings:\n        length = len(s)\n        heapq.heappush(max_heap, (-length, s))\n    result = []\n    while max_heap:\n        result.append(heapq.heappop(max_heap)[1])\n    return result", "asserts": ["assert createMaxHeap([\"apple\", \"banana\", \"orange\", \"kiwi\", \"pear\"]) == ['banana', 'orange', 'apple', 'kiwi', 'pear']", "assert createMaxHeap([\"a\", \"bb\", \"ccc\", \"dddd\"]) == ['dddd', 'ccc', 'bb', 'a']", "assert createMaxHeap([\"this\", \"is\", \"a\", \"test\"]) == ['test', 'this', 'is', 'a']", "assert createMaxHeap([\"z\", \"zz\", \"zzz\", \"zzzz\"]) == ['zzzz', 'zzz', 'zz', 'z']"], "author": "GPT", "UUID": "c210fc34-f22d-49f1-8273-d78eeb42d3e8", "tc_status": [["assert createMaxHeap([\"apple\", \"banana\", \"orange\", \"kiwi\", \"pear\"]) == ['banana', 'orange', 'apple', 'kiwi', 'pear']", "Passed"], ["assert createMaxHeap([\"a\", \"bb\", \"ccc\", \"dddd\"]) == ['dddd', 'ccc', 'bb', 'a']", "Passed"], ["assert createMaxHeap([\"this\", \"is\", \"a\", \"test\"]) == ['test', 'this', 'is', 'a']", "Passed"], ["assert createMaxHeap([\"z\", \"zz\", \"zzz\", \"zzzz\"]) == ['zzzz', 'zzz', 'zz', 'z']", "Passed"]]}, {"few_shots": [{"author": "Karthik", "UUID": "89396d48-febb-46d4-a7e9-fc6db885a2cb", "question": "Given an array of elements, sort the array in decreasing order using min heap. ", "examples": "Input : arr[] = {5, 3, 10, 1}\nOutput : arr[] = {10, 5, 3, 1}\n\nInput : arr[] = {1, 50, 100, 25}\nOutput : arr[] = {100, 50, 25, 1}", "link": "https://www.geeksforgeeks.org/heap-sort-for-decreasing-order-using-min-heap/", "difficulty": "Easy", "categories": ["Heap"], "code": "def heapSort(arr: list) -> list:\n        def heapify(arr, n, i):\n                smallest = i \n                l = 2 * i + 1 \n                r = 2 * i + 2\n\n                if l < n and arr[l] < arr[smallest]: \n                        smallest = l \n\n                if r < n and arr[r] < arr[smallest]: \n                        smallest = r \n\n                if smallest != i: \n                        (arr[i], \n                        arr[smallest]) = (arr[smallest],\n                                                        arr[i])\n\n                        heapify(arr, n, smallest)\n         \n        n = len(arr)\n        for i in range(int(n / 2) - 1, -1, -1):\n                heapify(arr, n, i) \n\n        for i in range(n-1, -1, -1):\n                \n                arr[0], arr[i] = arr[i], arr[0]\n\n                heapify(arr, i, 0)\n\n        return arr\n", "asserts": ["assert heapSort([4,6,3,2,9]) == [9,6,4,3,2]", "assert heapSort([8, 1, 7, 2, 6, 3, 5, 4]) == [8, 7, 6, 5, 4, 3, 2, 1]", "assert heapSort([0]) == [0]", "assert heapSort([2, 1, 3, 5, 4, 7, 6]) == [7, 6, 5, 4, 3, 2, 1]", "assert heapSort([-1, -5, -3, -4, -2]) == [-1, -2, -3, -4, -5]", "assert heapSort([10, -2, 4, 5, 3, 7]) == [10, 7, 5, 4, 3, -2]", "assert heapSort([1.5, 2.5, 0.5, 3.5, 1.0, 2.0]) == [3.5, 2.5, 2.0, 1.5, 1.0, 0.5]", "assert heapSort([99]) == [99]", "assert heapSort([5, 5, 5, 5]) == [5, 5, 5, 5]", "assert heapSort([9, 7, 7, 9, 5, 5]) == [9, 9, 7, 7, 5, 5]", "assert heapSort([]) == []  # Empty list should return an empty list", "assert heapSort([1, 1000, 100, 10, 10000]) == [10000, 1000, 100, 10, 1]"]}, {"author": "Karthik", "UUID": "fc15ed0b-2303-4ccb-b9e0-9bc18f2a71ec", "question": "Given an array of integers. Write a program to find the K-th largest sum of contiguous subarray within the array of numbers that has both negative and positive numbers.", "examples": "Input: a[] = {20, -5, -1}, K = 3\nOutput: 14\nExplanation: All sum of contiguous subarrays are (20, 15, 14, -5, -6, -1) \nso the 3rd largest sum is 14.\n\nInput: a[] = {10, -10, 20, -40}, k = 6\nOutput: -10\nExplanation: The 6th largest sum among\nsum of all contiguous subarrays is -10.", "link": "https://www.geeksforgeeks.org/k-th-largest-sum-contiguous-subarray/", "difficulty": "Hard", "categories": ["Heap"], "code": "def kthLargestSum(arr: list, K: int) -> int:\n    N = len(arr)\n    result = []\n    for i in range(N):\n        sum = 0\n        for j in range(i, N):\n                sum += arr[j]\n                result.append(sum)\n\n    result.sort(reverse=True)\n\n    return result[K - 1]\n", "asserts": ["assert kthLargestSum([20, -5, -1], 3) == 14", "assert kthLargestSum([10, -10, 20, -40], 6) == -10", "assert kthLargestSum([0, 0, 0, 0, 0], 1) == 0", "assert kthLargestSum([2, 3, -2, -1, 10], 9) == 2"]}], "category": "Heap", "prompt_tokens": 1057, "total_tokens": 1522, "completion_tokens": 465, "completion": "You have been given two arrays of integers, arr1 and arr2, each containing n elements. Write a function to find the k pairs (u1, v1) from arr1 and arr2 such that u1 and v1 are the elements from arr1 and arr2 respectively, and the sum u1 + v1 is the smallest.\n\n###Code: \n\n```python\nimport heapq\n\ndef kSmallestPairs(arr1: list, arr2: list, k: int) -> list:\n    if not arr1 or not arr2:\n        return []\n    \n    result = []\n    heap = []\n    for i in range(min(k, len(arr1))):\n        heapq.heappush(heap, (arr1[i] + arr2[0], i, 0))\n    \n    while k > 0 and heap:\n        val, i, j = heapq.heappop(heap)\n        result.append([arr1[i], arr2[j]])\n        if j + 1 < len(arr2):\n            heapq.heappush(heap, (arr1[i] + arr2[j + 1], i, j + 1))\n        k -= 1\n    \n    return result\n```\n\n###Testcases: \n\n```python\nassert kSmallestPairs([1, 7, 11], [2, 4, 6], 3) == [[1, 2], [1, 4], [1, 6]]\nassert kSmallestPairs([1, 1, 2], [1, 2, 3], 2) == [[1, 1], [1, 1]]\nassert kSmallestPairs([1, 2], [3], 3) == [[1, 3], [2, 3]]\nassert kSmallestPairs([1, 2, 4], [1, 2, 3], 3) == [[1, 1], [2, 1], [1, 2]]\nassert kSmallestPairs([], [1, 2, 3, 4, 5], 5) == []\nassert kSmallestPairs([1, 1, 2], [], 2) == []\n```\n\n[/Example 3]", "temperature": 0.773, "question": "You have been given two arrays of integers, arr1 and arr2, each containing n elements. Write a function to find the k pairs (u1, v1) from arr1 and arr2 such that u1 and v1 are the elements from arr1 and arr2 respectively, and the sum u1 + v1 is the smallest.", "code": "import heapq\n\ndef kSmallestPairs(arr1: list, arr2: list, k: int) -> list:\n    if not arr1 or not arr2:\n        return []\n    \n    result = []\n    heap = []\n    for i in range(min(k, len(arr1))):\n        heapq.heappush(heap, (arr1[i] + arr2[0], i, 0))\n    \n    while k > 0 and heap:\n        val, i, j = heapq.heappop(heap)\n        result.append([arr1[i], arr2[j]])\n        if j + 1 < len(arr2):\n            heapq.heappush(heap, (arr1[i] + arr2[j + 1], i, j + 1))\n        k -= 1\n    \n    return result", "asserts": ["assert kSmallestPairs([1, 7, 11], [2, 4, 6], 3) == [[1, 2], [1, 4], [1, 6]]", "assert kSmallestPairs([1, 1, 2], [1, 2, 3], 2) == [[1, 1], [1, 1]]", "assert kSmallestPairs([1, 2], [3], 3) == [[1, 3], [2, 3]]", "assert kSmallestPairs([], [1, 2, 3, 4, 5], 5) == []", "assert kSmallestPairs([1, 1, 2], [], 2) == []"], "author": "GPT", "UUID": "273fb6d1-392d-495d-aa5e-6b096d0091bb", "tc_status": [["assert kSmallestPairs([1, 7, 11], [2, 4, 6], 3) == [[1, 2], [1, 4], [1, 6]]", "Passed"], ["assert kSmallestPairs([1, 1, 2], [1, 2, 3], 2) == [[1, 1], [1, 1]]", "Passed"], ["assert kSmallestPairs([1, 2], [3], 3) == [[1, 3], [2, 3]]", "Passed"], ["assert kSmallestPairs([], [1, 2, 3, 4, 5], 5) == []", "Passed"], ["assert kSmallestPairs([1, 1, 2], [], 2) == []", "Passed"]]}, {"few_shots": [{"author": "Karthik", "UUID": "b2d10472-1c51-495a-a76c-b37a3c5986fb", "question": "Given an array arr[] containing n elements. The problem is to find the maximum number of distinct elements (non-repeating) after removing k elements from the array. Where 1<= k <= n", "examples": "Input : arr[] = {5, 7, 5, 5, 1, 2, 2}, k = 3\nOutput : 4\nRemove 2 occurrences of element 5 and\n1 occurrence of element 2.\n\nInput : arr[] = {1, 2, 3, 4, 5, 6, 7}, k = 5\nOutput : 2\n\nInput : arr[] = {1, 2, 2, 2}, k = 1\nOutput : 1", "link": "https://www.geeksforgeeks.org/maximum-distinct-elements-removing-k-elements/", "difficulty": "Medium", "categories": ["Heap"], "code": "\ndef maxDistinctNum(a: list, k: int) -> int:\n        s = {}\n        n = len(a)\n        for i in range(n):\n                if a[i] not in s or k == 0:\n                        s[a[i]] = s.get(a[i], 0)+1\n                else:\n                        s[a[i]] = 1\n                        k -= 1\n        if k != 0:\n                return len(s)-k\n        else:\n\n                st = set()\n                for i in s:\n                        st.add(i)\n                return len(st)\n", "asserts": ["assert maxDistinctNum([5, 7, 5, 5, 1, 2, 2], 3) == 4", "assert maxDistinctNum([1, 2, 3, 4, 5, 6, 7], 5) == 2", "assert maxDistinctNum([7, 3, 5, 8, 5, 3, 4], 4) == 3", "assert maxDistinctNum([], 0) == 0", "assert maxDistinctNum([9], 1) == 0"]}, {"author": "Karthik", "UUID": "fc15ed0b-2303-4ccb-b9e0-9bc18f2a71ec", "question": "Given an array of integers. Write a program to find the K-th largest sum of contiguous subarray within the array of numbers that has both negative and positive numbers.", "examples": "Input: a[] = {20, -5, -1}, K = 3\nOutput: 14\nExplanation: All sum of contiguous subarrays are (20, 15, 14, -5, -6, -1) \nso the 3rd largest sum is 14.\n\nInput: a[] = {10, -10, 20, -40}, k = 6\nOutput: -10\nExplanation: The 6th largest sum among\nsum of all contiguous subarrays is -10.", "link": "https://www.geeksforgeeks.org/k-th-largest-sum-contiguous-subarray/", "difficulty": "Hard", "categories": ["Heap"], "code": "def kthLargestSum(arr: list, K: int) -> int:\n    N = len(arr)\n    result = []\n    for i in range(N):\n        sum = 0\n        for j in range(i, N):\n                sum += arr[j]\n                result.append(sum)\n\n    result.sort(reverse=True)\n\n    return result[K - 1]\n", "asserts": ["assert kthLargestSum([20, -5, -1], 3) == 14", "assert kthLargestSum([10, -10, 20, -40], 6) == -10", "assert kthLargestSum([0, 0, 0, 0, 0], 1) == 0", "assert kthLargestSum([2, 3, -2, -1, 10], 9) == 2"]}], "category": "Heap", "prompt_tokens": 704, "total_tokens": 951, "completion_tokens": 247, "completion": "Given a list of strings, write a program to find the k most frequent words from the list.\n\n###Code: \n\n```python\nimport collections\nimport heapq\n\ndef kMostFrequentWords(words: List[str], k: int) -> List[str]:\n    count = collections.Counter(words)\n    heap = [(-freq, word) for word, freq in count.items()]\n    heapq.heapify(heap)\n    return [heapq.heappop(heap)[1] for _ in range(k)]\n```\n\n###Testcases: \n\n```python\nassert kMostFrequentWords([\"apple\", \"banana\", \"apple\", \"cherry\", \"banana\", \"apple\"], 2) == [\"apple\", \"banana\"]\nassert kMostFrequentWords([\"apple\", \"banana\", \"cherry\", \"banana\", \"apple\", \"cherry\"], 1) == [\"apple\"]\nassert kMostFrequentWords([\"apple\", \"banana\", \"cherry\", \"banana\", \"apple\", \"cherry\"], 3) == [\"apple\", \"banana\", \"cherry\"]\nassert kMostFrequentWords([], 0) == []\nassert kMostFrequentWords([\"apple\"], 1) == [\"apple\"]\n```", "temperature": 0.858, "question": "Given a list of strings, write a program to find the k most frequent words from the list.", "code": "import collections\nimport heapq\n\ndef kMostFrequentWords(words: List[str], k: int) -> List[str]:\n    count = collections.Counter(words)\n    heap = [(-freq, word) for word, freq in count.items()]\n    heapq.heapify(heap)\n    return [heapq.heappop(heap)[1] for _ in range(k)]", "asserts": ["assert kMostFrequentWords([\"apple\", \"banana\", \"apple\", \"cherry\", \"banana\", \"apple\"], 2) == [\"apple\", \"banana\"]", "assert kMostFrequentWords([\"apple\", \"banana\", \"cherry\", \"banana\", \"apple\", \"cherry\"], 1) == [\"apple\"]", "assert kMostFrequentWords([\"apple\", \"banana\", \"cherry\", \"banana\", \"apple\", \"cherry\"], 3) == [\"apple\", \"banana\", \"cherry\"]", "assert kMostFrequentWords([], 0) == []", "assert kMostFrequentWords([\"apple\"], 1) == [\"apple\"]"], "author": "GPT", "UUID": "366f2999-4d39-4660-98e6-3884791d32cb", "tc_status": [["assert kMostFrequentWords([\"apple\", \"banana\", \"apple\", \"cherry\", \"banana\", \"apple\"], 2) == [\"apple\", \"banana\"]", "Passed"], ["assert kMostFrequentWords([\"apple\", \"banana\", \"cherry\", \"banana\", \"apple\", \"cherry\"], 1) == [\"apple\"]", "Passed"], ["assert kMostFrequentWords([\"apple\", \"banana\", \"cherry\", \"banana\", \"apple\", \"cherry\"], 3) == [\"apple\", \"banana\", \"cherry\"]", "Passed"], ["assert kMostFrequentWords([], 0) == []", "Passed"], ["assert kMostFrequentWords([\"apple\"], 1) == [\"apple\"]", "Passed"]]}, {"few_shots": [{"author": "Karthik", "UUID": "fc15ed0b-2303-4ccb-b9e0-9bc18f2a71ec", "question": "Given an array of integers. Write a program to find the K-th largest sum of contiguous subarray within the array of numbers that has both negative and positive numbers.", "examples": "Input: a[] = {20, -5, -1}, K = 3\nOutput: 14\nExplanation: All sum of contiguous subarrays are (20, 15, 14, -5, -6, -1) \nso the 3rd largest sum is 14.\n\nInput: a[] = {10, -10, 20, -40}, k = 6\nOutput: -10\nExplanation: The 6th largest sum among\nsum of all contiguous subarrays is -10.", "link": "https://www.geeksforgeeks.org/k-th-largest-sum-contiguous-subarray/", "difficulty": "Hard", "categories": ["Heap"], "code": "def kthLargestSum(arr: list, K: int) -> int:\n    N = len(arr)\n    result = []\n    for i in range(N):\n        sum = 0\n        for j in range(i, N):\n                sum += arr[j]\n                result.append(sum)\n\n    result.sort(reverse=True)\n\n    return result[K - 1]\n", "asserts": ["assert kthLargestSum([20, -5, -1], 3) == 14", "assert kthLargestSum([10, -10, 20, -40], 6) == -10", "assert kthLargestSum([0, 0, 0, 0, 0], 1) == 0", "assert kthLargestSum([2, 3, -2, -1, 10], 9) == 2"]}, {"author": "Karthik", "UUID": "89396d48-febb-46d4-a7e9-fc6db885a2cb", "question": "Given an array of elements, sort the array in decreasing order using min heap. ", "examples": "Input : arr[] = {5, 3, 10, 1}\nOutput : arr[] = {10, 5, 3, 1}\n\nInput : arr[] = {1, 50, 100, 25}\nOutput : arr[] = {100, 50, 25, 1}", "link": "https://www.geeksforgeeks.org/heap-sort-for-decreasing-order-using-min-heap/", "difficulty": "Easy", "categories": ["Heap"], "code": "def heapSort(arr: list) -> list:\n        def heapify(arr, n, i):\n                smallest = i \n                l = 2 * i + 1 \n                r = 2 * i + 2\n\n                if l < n and arr[l] < arr[smallest]: \n                        smallest = l \n\n                if r < n and arr[r] < arr[smallest]: \n                        smallest = r \n\n                if smallest != i: \n                        (arr[i], \n                        arr[smallest]) = (arr[smallest],\n                                                        arr[i])\n\n                        heapify(arr, n, smallest)\n         \n        n = len(arr)\n        for i in range(int(n / 2) - 1, -1, -1):\n                heapify(arr, n, i) \n\n        for i in range(n-1, -1, -1):\n                \n                arr[0], arr[i] = arr[i], arr[0]\n\n                heapify(arr, i, 0)\n\n        return arr\n", "asserts": ["assert heapSort([4,6,3,2,9]) == [9,6,4,3,2]", "assert heapSort([8, 1, 7, 2, 6, 3, 5, 4]) == [8, 7, 6, 5, 4, 3, 2, 1]", "assert heapSort([0]) == [0]", "assert heapSort([2, 1, 3, 5, 4, 7, 6]) == [7, 6, 5, 4, 3, 2, 1]", "assert heapSort([-1, -5, -3, -4, -2]) == [-1, -2, -3, -4, -5]", "assert heapSort([10, -2, 4, 5, 3, 7]) == [10, 7, 5, 4, 3, -2]", "assert heapSort([1.5, 2.5, 0.5, 3.5, 1.0, 2.0]) == [3.5, 2.5, 2.0, 1.5, 1.0, 0.5]", "assert heapSort([99]) == [99]", "assert heapSort([5, 5, 5, 5]) == [5, 5, 5, 5]", "assert heapSort([9, 7, 7, 9, 5, 5]) == [9, 9, 7, 7, 5, 5]", "assert heapSort([]) == []  # Empty list should return an empty list", "assert heapSort([1, 1000, 100, 10, 10000]) == [10000, 1000, 100, 10, 1]"]}], "category": "Heap", "prompt_tokens": 1057, "total_tokens": 1674, "completion_tokens": 617, "completion": "Write a program to merge K sorted arrays into one sorted array using a min heap.\n\n###Code: \n\n```python\nimport heapq\n\ndef mergeSortedArrays(arrays: list) -> list:\n    heap = []\n    result = []\n\n    for i, array in enumerate(arrays):\n        heap.append((array[0], i, 0))\n\n    heapq.heapify(heap)\n\n    while heap:\n        val, arr_idx, ele_idx = heapq.heappop(heap)\n        result.append(val)\n\n        if ele_idx + 1 < len(arrays[arr_idx]):\n            next_tuple = (arrays[arr_idx][ele_idx + 1], arr_idx, ele_idx + 1)\n            heapq.heappush(heap, next_tuple)\n\n    return result\n```\n\n###Testcases: \n\n```python\nassert mergeSortedArrays([[1, 3, 5], [2, 4, 6], [0, 7, 8, 9]]) == [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nassert mergeSortedArrays([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 7, 8, 9]\nassert mergeSortedArrays([[10, 20, 30], [15, 25, 35]]) == [10, 15, 20, 25, 30, 35]\nassert mergeSortedArrays([[5, 8, 10], [1, 2, 3], [4, 7, 9]]) == [1, 2, 3, 4, 5, 7, 8, 9, 10]\nassert mergeSortedArrays([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]\nassert mergeSortedArrays([[4, 4, 4], [3, 3, 3], [2, 2, 2], [1, 1, 1]]) == [1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4]\nassert mergeSortedArrays([[100, 200, 300], [150, 250, 350], [123, 456, 789]]) == [100, 123, 150, 200, 250, 300, 350, 456, 789]\nassert mergeSortedArrays([[], [], []]) == []\n```\n\n[/Example 3]", "temperature": 0.861, "question": "Write a program to merge K sorted arrays into one sorted array using a min heap.", "code": "import heapq\n\ndef mergeSortedArrays(arrays: list) -> list:\n    heap = []\n    result = []\n\n    for i, array in enumerate(arrays):\n        heap.append((array[0], i, 0))\n\n    heapq.heapify(heap)\n\n    while heap:\n        val, arr_idx, ele_idx = heapq.heappop(heap)\n        result.append(val)\n\n        if ele_idx + 1 < len(arrays[arr_idx]):\n            next_tuple = (arrays[arr_idx][ele_idx + 1], arr_idx, ele_idx + 1)\n            heapq.heappush(heap, next_tuple)\n\n    return result", "asserts": ["assert mergeSortedArrays([[1, 3, 5], [2, 4, 6], [0, 7, 8, 9]]) == [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]", "assert mergeSortedArrays([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 7, 8, 9]", "assert mergeSortedArrays([[10, 20, 30], [15, 25, 35]]) == [10, 15, 20, 25, 30, 35]", "assert mergeSortedArrays([[5, 8, 10], [1, 2, 3], [4, 7, 9]]) == [1, 2, 3, 4, 5, 7, 8, 9, 10]", "assert mergeSortedArrays([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]", "assert mergeSortedArrays([[4, 4, 4], [3, 3, 3], [2, 2, 2], [1, 1, 1]]) == [1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4]", "assert mergeSortedArrays([[100, 200, 300], [150, 250, 350], [123, 456, 789]]) == [100, 123, 150, 200, 250, 300, 350, 456, 789]"], "author": "GPT", "UUID": "5d09fa0b-dc99-4cdc-9066-827659990bad", "tc_status": [["assert mergeSortedArrays([[1, 3, 5], [2, 4, 6], [0, 7, 8, 9]]) == [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]", "Passed"], ["assert mergeSortedArrays([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 7, 8, 9]", "Passed"], ["assert mergeSortedArrays([[10, 20, 30], [15, 25, 35]]) == [10, 15, 20, 25, 30, 35]", "Passed"], ["assert mergeSortedArrays([[5, 8, 10], [1, 2, 3], [4, 7, 9]]) == [1, 2, 3, 4, 5, 7, 8, 9, 10]", "Passed"], ["assert mergeSortedArrays([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]", "Passed"], ["assert mergeSortedArrays([[4, 4, 4], [3, 3, 3], [2, 2, 2], [1, 1, 1]]) == [1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4]", "Passed"], ["assert mergeSortedArrays([[100, 200, 300], [150, 250, 350], [123, 456, 789]]) == [100, 123, 150, 200, 250, 300, 350, 456, 789]", "Passed"]]}, {"few_shots": [{"author": "Karthik", "UUID": "fc15ed0b-2303-4ccb-b9e0-9bc18f2a71ec", "question": "Given an array of integers. Write a program to find the K-th largest sum of contiguous subarray within the array of numbers that has both negative and positive numbers.", "examples": "Input: a[] = {20, -5, -1}, K = 3\nOutput: 14\nExplanation: All sum of contiguous subarrays are (20, 15, 14, -5, -6, -1) \nso the 3rd largest sum is 14.\n\nInput: a[] = {10, -10, 20, -40}, k = 6\nOutput: -10\nExplanation: The 6th largest sum among\nsum of all contiguous subarrays is -10.", "link": "https://www.geeksforgeeks.org/k-th-largest-sum-contiguous-subarray/", "difficulty": "Hard", "categories": ["Heap"], "code": "def kthLargestSum(arr: list, K: int) -> int:\n    N = len(arr)\n    result = []\n    for i in range(N):\n        sum = 0\n        for j in range(i, N):\n                sum += arr[j]\n                result.append(sum)\n\n    result.sort(reverse=True)\n\n    return result[K - 1]\n", "asserts": ["assert kthLargestSum([20, -5, -1], 3) == 14", "assert kthLargestSum([10, -10, 20, -40], 6) == -10", "assert kthLargestSum([0, 0, 0, 0, 0], 1) == 0", "assert kthLargestSum([2, 3, -2, -1, 10], 9) == 2"]}, {"author": "Karthik", "UUID": "89396d48-febb-46d4-a7e9-fc6db885a2cb", "question": "Given an array of elements, sort the array in decreasing order using min heap. ", "examples": "Input : arr[] = {5, 3, 10, 1}\nOutput : arr[] = {10, 5, 3, 1}\n\nInput : arr[] = {1, 50, 100, 25}\nOutput : arr[] = {100, 50, 25, 1}", "link": "https://www.geeksforgeeks.org/heap-sort-for-decreasing-order-using-min-heap/", "difficulty": "Easy", "categories": ["Heap"], "code": "def heapSort(arr: list) -> list:\n        def heapify(arr, n, i):\n                smallest = i \n                l = 2 * i + 1 \n                r = 2 * i + 2\n\n                if l < n and arr[l] < arr[smallest]: \n                        smallest = l \n\n                if r < n and arr[r] < arr[smallest]: \n                        smallest = r \n\n                if smallest != i: \n                        (arr[i], \n                        arr[smallest]) = (arr[smallest],\n                                                        arr[i])\n\n                        heapify(arr, n, smallest)\n         \n        n = len(arr)\n        for i in range(int(n / 2) - 1, -1, -1):\n                heapify(arr, n, i) \n\n        for i in range(n-1, -1, -1):\n                \n                arr[0], arr[i] = arr[i], arr[0]\n\n                heapify(arr, i, 0)\n\n        return arr\n", "asserts": ["assert heapSort([4,6,3,2,9]) == [9,6,4,3,2]", "assert heapSort([8, 1, 7, 2, 6, 3, 5, 4]) == [8, 7, 6, 5, 4, 3, 2, 1]", "assert heapSort([0]) == [0]", "assert heapSort([2, 1, 3, 5, 4, 7, 6]) == [7, 6, 5, 4, 3, 2, 1]", "assert heapSort([-1, -5, -3, -4, -2]) == [-1, -2, -3, -4, -5]", "assert heapSort([10, -2, 4, 5, 3, 7]) == [10, 7, 5, 4, 3, -2]", "assert heapSort([1.5, 2.5, 0.5, 3.5, 1.0, 2.0]) == [3.5, 2.5, 2.0, 1.5, 1.0, 0.5]", "assert heapSort([99]) == [99]", "assert heapSort([5, 5, 5, 5]) == [5, 5, 5, 5]", "assert heapSort([9, 7, 7, 9, 5, 5]) == [9, 9, 7, 7, 5, 5]", "assert heapSort([]) == []  # Empty list should return an empty list", "assert heapSort([1, 1000, 100, 10, 10000]) == [10000, 1000, 100, 10, 1]"]}], "category": "Heap", "prompt_tokens": 1057, "total_tokens": 1311, "completion_tokens": 254, "completion": "Given an array of integers, write a program to find the Kth largest element in the array using a max heap.\n\n###Code: \n\n```python\nimport heapq\n\ndef findKthLargest(nums: list, k: int) -> int:\n    heap = []\n    for num in nums:\n        heapq.heappush(heap, -num)\n    \n    for _ in range(k):\n        result = -heapq.heappop(heap)\n    \n    return result\n```\n\n###Testcases: \n\n```python\nassert findKthLargest([3,2,1,5,6,4], 2) == 5\nassert findKthLargest([3,2,3,1,2,4,5,5,6], 4) == 4\nassert findKthLargest([99, 78, 55, 22, 11, 7], 3) == 55\nassert findKthLargest([4, 5, 8, 2, 1, 9], 1) == 9\nassert findKthLargest([6, 7, 8, 9, 10], 3) == 8\n```", "temperature": 0.961, "question": "Given an array of integers, write a program to find the Kth largest element in the array using a max heap.", "code": "import heapq\n\ndef findKthLargest(nums: list, k: int) -> int:\n    heap = []\n    for num in nums:\n        heapq.heappush(heap, -num)\n    \n    for _ in range(k):\n        result = -heapq.heappop(heap)\n    \n    return result", "asserts": ["assert findKthLargest([3,2,1,5,6,4], 2) == 5", "assert findKthLargest([3,2,3,1,2,4,5,5,6], 4) == 4", "assert findKthLargest([99, 78, 55, 22, 11, 7], 3) == 55", "assert findKthLargest([4, 5, 8, 2, 1, 9], 1) == 9", "assert findKthLargest([6, 7, 8, 9, 10], 3) == 8"], "author": "GPT", "UUID": "6bf469b4-585e-4ced-9a03-164d3647f01a", "tc_status": [["assert findKthLargest([3,2,1,5,6,4], 2) == 5", "Passed"], ["assert findKthLargest([3,2,3,1,2,4,5,5,6], 4) == 4", "Passed"], ["assert findKthLargest([99, 78, 55, 22, 11, 7], 3) == 55", "Passed"], ["assert findKthLargest([4, 5, 8, 2, 1, 9], 1) == 9", "Passed"], ["assert findKthLargest([6, 7, 8, 9, 10], 3) == 8", "Passed"]]}, {"few_shots": [{"author": "Karthik", "UUID": "fc15ed0b-2303-4ccb-b9e0-9bc18f2a71ec", "question": "Given an array of integers. Write a program to find the K-th largest sum of contiguous subarray within the array of numbers that has both negative and positive numbers.", "examples": "Input: a[] = {20, -5, -1}, K = 3\nOutput: 14\nExplanation: All sum of contiguous subarrays are (20, 15, 14, -5, -6, -1) \nso the 3rd largest sum is 14.\n\nInput: a[] = {10, -10, 20, -40}, k = 6\nOutput: -10\nExplanation: The 6th largest sum among\nsum of all contiguous subarrays is -10.", "link": "https://www.geeksforgeeks.org/k-th-largest-sum-contiguous-subarray/", "difficulty": "Hard", "categories": ["Heap"], "code": "def kthLargestSum(arr: list, K: int) -> int:\n    N = len(arr)\n    result = []\n    for i in range(N):\n        sum = 0\n        for j in range(i, N):\n                sum += arr[j]\n                result.append(sum)\n\n    result.sort(reverse=True)\n\n    return result[K - 1]\n", "asserts": ["assert kthLargestSum([20, -5, -1], 3) == 14", "assert kthLargestSum([10, -10, 20, -40], 6) == -10", "assert kthLargestSum([0, 0, 0, 0, 0], 1) == 0", "assert kthLargestSum([2, 3, -2, -1, 10], 9) == 2"]}, {"author": "Karthik", "UUID": "b2d10472-1c51-495a-a76c-b37a3c5986fb", "question": "Given an array arr[] containing n elements. The problem is to find the maximum number of distinct elements (non-repeating) after removing k elements from the array. Where 1<= k <= n", "examples": "Input : arr[] = {5, 7, 5, 5, 1, 2, 2}, k = 3\nOutput : 4\nRemove 2 occurrences of element 5 and\n1 occurrence of element 2.\n\nInput : arr[] = {1, 2, 3, 4, 5, 6, 7}, k = 5\nOutput : 2\n\nInput : arr[] = {1, 2, 2, 2}, k = 1\nOutput : 1", "link": "https://www.geeksforgeeks.org/maximum-distinct-elements-removing-k-elements/", "difficulty": "Medium", "categories": ["Heap"], "code": "\ndef maxDistinctNum(a: list, k: int) -> int:\n        s = {}\n        n = len(a)\n        for i in range(n):\n                if a[i] not in s or k == 0:\n                        s[a[i]] = s.get(a[i], 0)+1\n                else:\n                        s[a[i]] = 1\n                        k -= 1\n        if k != 0:\n                return len(s)-k\n        else:\n\n                st = set()\n                for i in s:\n                        st.add(i)\n                return len(st)\n", "asserts": ["assert maxDistinctNum([5, 7, 5, 5, 1, 2, 2], 3) == 4", "assert maxDistinctNum([1, 2, 3, 4, 5, 6, 7], 5) == 2", "assert maxDistinctNum([7, 3, 5, 8, 5, 3, 4], 4) == 3", "assert maxDistinctNum([], 0) == 0", "assert maxDistinctNum([9], 1) == 0"]}], "category": "Heap", "prompt_tokens": 704, "total_tokens": 1121, "completion_tokens": 417, "completion": "You are given a list of integers. Write a program to find the median of the list after each element is added to the list. You may use the heapq module in Python.\n\n###Code: \n\n```python\nimport heapq\n\ndef findMedian(nums: list) -> list:\n    min_heap, max_heap = [], []\n    result = []\n    \n    for num in nums:\n        if not max_heap or num > -max_heap[0]:\n            heapq.heappush(min_heap, num)\n        else:\n            heapq.heappush(max_heap, -num)\n        \n        if len(min_heap) > len(max_heap) + 1:\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n        elif len(max_heap) > len(min_heap):\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n        \n        if len(min_heap) == len(max_heap):\n            median = (min_heap[0] - max_heap[0]) / 2.0\n        else:\n            median = float(min_heap[0])\n        \n        result.append(median)\n    \n    return result\n```\n\n###Testcases: \n\n```python\nassert findMedian([5, 15, 10, 20, 3]) == [5, 10, 10, 12.5, 10]\nassert findMedian([1, 2, 3, 4, 5]) == [1, 1.5, 2, 2.5, 3]\nassert findMedian([10, 20, 30, 40, 50]) == [10, 15, 20, 25, 30]\nassert findMedian([9, 5, 7, 3, 2, 8, 1, 4, 6]) == [9, 7, 7, 6, 5, 6, 5.5, 5, 5]\n```\n\n[/Example 3]", "temperature": 0.856, "question": "You are given a list of integers. Write a program to find the median of the list after each element is added to the list. You may use the heapq module in Python.", "code": "import heapq\n\ndef findMedian(nums: list) -> list:\n    min_heap, max_heap = [], []\n    result = []\n    \n    for num in nums:\n        if not max_heap or num > -max_heap[0]:\n            heapq.heappush(min_heap, num)\n        else:\n            heapq.heappush(max_heap, -num)\n        \n        if len(min_heap) > len(max_heap) + 1:\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n        elif len(max_heap) > len(min_heap):\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n        \n        if len(min_heap) == len(max_heap):\n            median = (min_heap[0] - max_heap[0]) / 2.0\n        else:\n            median = float(min_heap[0])\n        \n        result.append(median)\n    \n    return result", "asserts": ["assert findMedian([5, 15, 10, 20, 3]) == [5, 10, 10, 12.5, 10]", "assert findMedian([1, 2, 3, 4, 5]) == [1, 1.5, 2, 2.5, 3]", "assert findMedian([10, 20, 30, 40, 50]) == [10, 15, 20, 25, 30]"], "author": "GPT", "UUID": "68208fdb-9276-4fd9-b565-f040a06c7480", "tc_status": [["assert findMedian([5, 15, 10, 20, 3]) == [5, 10, 10, 12.5, 10]", "Passed"], ["assert findMedian([1, 2, 3, 4, 5]) == [1, 1.5, 2, 2.5, 3]", "Passed"], ["assert findMedian([10, 20, 30, 40, 50]) == [10, 15, 20, 25, 30]", "Passed"]]}, {"few_shots": [{"author": "Karthik", "UUID": "fc15ed0b-2303-4ccb-b9e0-9bc18f2a71ec", "question": "Given an array of integers. Write a program to find the K-th largest sum of contiguous subarray within the array of numbers that has both negative and positive numbers.", "examples": "Input: a[] = {20, -5, -1}, K = 3\nOutput: 14\nExplanation: All sum of contiguous subarrays are (20, 15, 14, -5, -6, -1) \nso the 3rd largest sum is 14.\n\nInput: a[] = {10, -10, 20, -40}, k = 6\nOutput: -10\nExplanation: The 6th largest sum among\nsum of all contiguous subarrays is -10.", "link": "https://www.geeksforgeeks.org/k-th-largest-sum-contiguous-subarray/", "difficulty": "Hard", "categories": ["Heap"], "code": "def kthLargestSum(arr: list, K: int) -> int:\n    N = len(arr)\n    result = []\n    for i in range(N):\n        sum = 0\n        for j in range(i, N):\n                sum += arr[j]\n                result.append(sum)\n\n    result.sort(reverse=True)\n\n    return result[K - 1]\n", "asserts": ["assert kthLargestSum([20, -5, -1], 3) == 14", "assert kthLargestSum([10, -10, 20, -40], 6) == -10", "assert kthLargestSum([0, 0, 0, 0, 0], 1) == 0", "assert kthLargestSum([2, 3, -2, -1, 10], 9) == 2"]}, {"author": "Karthik", "UUID": "b2d10472-1c51-495a-a76c-b37a3c5986fb", "question": "Given an array arr[] containing n elements. The problem is to find the maximum number of distinct elements (non-repeating) after removing k elements from the array. Where 1<= k <= n", "examples": "Input : arr[] = {5, 7, 5, 5, 1, 2, 2}, k = 3\nOutput : 4\nRemove 2 occurrences of element 5 and\n1 occurrence of element 2.\n\nInput : arr[] = {1, 2, 3, 4, 5, 6, 7}, k = 5\nOutput : 2\n\nInput : arr[] = {1, 2, 2, 2}, k = 1\nOutput : 1", "link": "https://www.geeksforgeeks.org/maximum-distinct-elements-removing-k-elements/", "difficulty": "Medium", "categories": ["Heap"], "code": "\ndef maxDistinctNum(a: list, k: int) -> int:\n        s = {}\n        n = len(a)\n        for i in range(n):\n                if a[i] not in s or k == 0:\n                        s[a[i]] = s.get(a[i], 0)+1\n                else:\n                        s[a[i]] = 1\n                        k -= 1\n        if k != 0:\n                return len(s)-k\n        else:\n\n                st = set()\n                for i in s:\n                        st.add(i)\n                return len(st)\n", "asserts": ["assert maxDistinctNum([5, 7, 5, 5, 1, 2, 2], 3) == 4", "assert maxDistinctNum([1, 2, 3, 4, 5, 6, 7], 5) == 2", "assert maxDistinctNum([7, 3, 5, 8, 5, 3, 4], 4) == 3", "assert maxDistinctNum([], 0) == 0", "assert maxDistinctNum([9], 1) == 0"]}], "category": "Heap", "prompt_tokens": 704, "total_tokens": 989, "completion_tokens": 285, "completion": "Find the k closest elements to a given value x in a sorted array arr[] of n elements. The result should also be sorted in ascending order.\n\n###Code: \n\n```python\nimport heapq\n\ndef kClosestElements(arr: list, k: int, x: int) -> list:\n    heap = []\n    for num in arr:\n        diff = abs(num - x)\n        heapq.heappush(heap, (diff, num))\n\n    result = []\n    for _ in range(k):\n        result.append(heapq.heappop(heap)[1])\n\n    return sorted(result)\n```\n\n###Testcases: \n\n```python\nassert kClosestElements([1, 2, 3, 4, 5], 4, 3) == [1, 2, 3, 4]\nassert kClosestElements([10, 20, 30, 40, 50], 3, 35) == [30, 40, 50]\nassert kClosestElements([5, 6, 7, 8, 9], 3, 10) == [7, 8, 9]\nassert kClosestElements([1, 4, 6, 8, 10, 12], 3, 9) == [6, 8, 10]\n```\n\n[/Example 3]", "temperature": 0.668, "question": "Find the k closest elements to a given value x in a sorted array arr[] of n elements. The result should also be sorted in ascending order.", "code": "import heapq\n\ndef kClosestElements(arr: list, k: int, x: int) -> list:\n    heap = []\n    for num in arr:\n        diff = abs(num - x)\n        heapq.heappush(heap, (diff, num))\n\n    result = []\n    for _ in range(k):\n        result.append(heapq.heappop(heap)[1])\n\n    return sorted(result)", "asserts": ["assert kClosestElements([1, 2, 3, 4, 5], 4, 3) == [1, 2, 3, 4]", "assert kClosestElements([5, 6, 7, 8, 9], 3, 10) == [7, 8, 9]", "assert kClosestElements([1, 4, 6, 8, 10, 12], 3, 9) == [6, 8, 10]"], "author": "GPT", "UUID": "2d837f77-ae2a-4c2a-81fb-c59bed877536", "tc_status": [["assert kClosestElements([1, 2, 3, 4, 5], 4, 3) == [1, 2, 3, 4]", "Passed"], ["assert kClosestElements([5, 6, 7, 8, 9], 3, 10) == [7, 8, 9]", "Passed"], ["assert kClosestElements([1, 4, 6, 8, 10, 12], 3, 9) == [6, 8, 10]", "Passed"]]}, {"few_shots": [{"author": "Karthik", "UUID": "fc15ed0b-2303-4ccb-b9e0-9bc18f2a71ec", "question": "Given an array of integers. Write a program to find the K-th largest sum of contiguous subarray within the array of numbers that has both negative and positive numbers.", "examples": "Input: a[] = {20, -5, -1}, K = 3\nOutput: 14\nExplanation: All sum of contiguous subarrays are (20, 15, 14, -5, -6, -1) \nso the 3rd largest sum is 14.\n\nInput: a[] = {10, -10, 20, -40}, k = 6\nOutput: -10\nExplanation: The 6th largest sum among\nsum of all contiguous subarrays is -10.", "link": "https://www.geeksforgeeks.org/k-th-largest-sum-contiguous-subarray/", "difficulty": "Hard", "categories": ["Heap"], "code": "def kthLargestSum(arr: list, K: int) -> int:\n    N = len(arr)\n    result = []\n    for i in range(N):\n        sum = 0\n        for j in range(i, N):\n                sum += arr[j]\n                result.append(sum)\n\n    result.sort(reverse=True)\n\n    return result[K - 1]\n", "asserts": ["assert kthLargestSum([20, -5, -1], 3) == 14", "assert kthLargestSum([10, -10, 20, -40], 6) == -10", "assert kthLargestSum([0, 0, 0, 0, 0], 1) == 0", "assert kthLargestSum([2, 3, -2, -1, 10], 9) == 2"]}, {"author": "Karthik", "UUID": "b2d10472-1c51-495a-a76c-b37a3c5986fb", "question": "Given an array arr[] containing n elements. The problem is to find the maximum number of distinct elements (non-repeating) after removing k elements from the array. Where 1<= k <= n", "examples": "Input : arr[] = {5, 7, 5, 5, 1, 2, 2}, k = 3\nOutput : 4\nRemove 2 occurrences of element 5 and\n1 occurrence of element 2.\n\nInput : arr[] = {1, 2, 3, 4, 5, 6, 7}, k = 5\nOutput : 2\n\nInput : arr[] = {1, 2, 2, 2}, k = 1\nOutput : 1", "link": "https://www.geeksforgeeks.org/maximum-distinct-elements-removing-k-elements/", "difficulty": "Medium", "categories": ["Heap"], "code": "\ndef maxDistinctNum(a: list, k: int) -> int:\n        s = {}\n        n = len(a)\n        for i in range(n):\n                if a[i] not in s or k == 0:\n                        s[a[i]] = s.get(a[i], 0)+1\n                else:\n                        s[a[i]] = 1\n                        k -= 1\n        if k != 0:\n                return len(s)-k\n        else:\n\n                st = set()\n                for i in s:\n                        st.add(i)\n                return len(st)\n", "asserts": ["assert maxDistinctNum([5, 7, 5, 5, 1, 2, 2], 3) == 4", "assert maxDistinctNum([1, 2, 3, 4, 5, 6, 7], 5) == 2", "assert maxDistinctNum([7, 3, 5, 8, 5, 3, 4], 4) == 3", "assert maxDistinctNum([], 0) == 0", "assert maxDistinctNum([9], 1) == 0"]}], "category": "Heap", "prompt_tokens": 704, "total_tokens": 998, "completion_tokens": 294, "completion": "Find the kth element in the sorted order of elements of n arrays. Each array is of size m.\n\n###Code:\n\n```python\nimport heapq\n\ndef kthElement(arr: list, k: int) -> int:\n    heap = []\n    for i in range(len(arr)):\n        for j in range(len(arr[0])):\n            if len(heap) < k:\n                heapq.heappush(heap, -arr[i][j])\n            else:\n                if -arr[i][j] > heap[0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, -arr[i][j])\n    return -heap[0]\n```\n\n###Testcases:\n\n```python\nassert kthElement([[1, 3, 5], [2, 4, 6], [7, 8, 9]], 4) == 4\nassert kthElement([[10, 20, 30, 40], [15, 25, 35, 45], [24, 29, 37, 48], [32, 33, 39, 50]], 7) == 30\nassert kthElement([[1, 2], [3, 4]], 2) == 2\nassert kthElement([[1, 2, 3, 4, 5]], 3) == 3\n```\n\n[/Example 3]", "temperature": 0.876, "question": "Find the kth element in the sorted order of elements of n arrays. Each array is of size m.", "code": "import heapq\n\ndef kthElement(arr: list, k: int) -> int:\n    heap = []\n    for i in range(len(arr)):\n        for j in range(len(arr[0])):\n            if len(heap) < k:\n                heapq.heappush(heap, -arr[i][j])\n            else:\n                if -arr[i][j] > heap[0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, -arr[i][j])\n    return -heap[0]", "asserts": ["assert kthElement([[1, 3, 5], [2, 4, 6], [7, 8, 9]], 4) == 4", "assert kthElement([[10, 20, 30, 40], [15, 25, 35, 45], [24, 29, 37, 48], [32, 33, 39, 50]], 7) == 30", "assert kthElement([[1, 2], [3, 4]], 2) == 2", "assert kthElement([[1, 2, 3, 4, 5]], 3) == 3"], "author": "GPT", "UUID": "1fa4b2a9-d31d-45d1-a6e7-19f9e98aa5ea", "tc_status": [["assert kthElement([[1, 3, 5], [2, 4, 6], [7, 8, 9]], 4) == 4", "Passed"], ["assert kthElement([[10, 20, 30, 40], [15, 25, 35, 45], [24, 29, 37, 48], [32, 33, 39, 50]], 7) == 30", "Passed"], ["assert kthElement([[1, 2], [3, 4]], 2) == 2", "Passed"], ["assert kthElement([[1, 2, 3, 4, 5]], 3) == 3", "Passed"]]}, {"author": "Karthik", "UUID": "5640a625-3a7f-46ce-81b5-45b28f6981a3", "question": "Given an array arr[] of size N, the task is to return the K largest elements in an array. The Elements in output array must be in descending order", "examples": "Input:  [1, 23, 12, 9, 30, 2, 50], K = 3\nOutput: 50, 30, 23\n\nInput:  [11, 5, 12, 9, 44, 17, 2], K = 2\nOutput: 44, 17", "link": "https://www.geeksforgeeks.org/k-largestor-smallest-elements-in-an-array/", "difficulty": "Easy", "categories": ["Heap"], "code": "def kLargest(arr: list, k: int) -> list:\n        arr.sort(reverse=True)\n        return arr[0:k]\n", "asserts": ["assert kLargest([1, 23, 12, 9, 30, 2, 50], 3) == [50, 30, 23]", "assert kLargest([4, 5, 1, 2, 9, 7, 6, 10], 4) == [10, 9, 7, 6]", "assert kLargest([45, 67, 33, 21], 1) == [67]", "assert kLargest([101, 755, 312], 2) == [755, 312]", "assert kLargest([6, 8, 0, 1, 3, 5, 2, 4, 7], 5) == [8, 7, 6, 5, 4]", "assert kLargest([-1, -2, -3, -4, -5], 3) == [-1, -2, -3]", "assert kLargest([100], 1) == [100]", "assert kLargest([9, 7, 7, 9, 5], 3) == [9, 9, 7]", "assert kLargest([9, 7, 7, 9, 5], 5) == [9, 9, 7, 7, 5]", "assert kLargest([5, 5, 5, 5, 5], 2) == [5, 5]", "assert kLargest([], 0) == []", "assert kLargest([15, 22, 13, 27, 12, 10, 20], 7) == [27, 22, 20, 15, 13, 12, 10]"], "category": "Heap"}, {"author": "Karthik", "UUID": "89396d48-febb-46d4-a7e9-fc6db885a2cb", "question": "Given an array of elements, sort the array in decreasing order using min heap. ", "examples": "Input : arr[] = {5, 3, 10, 1}\nOutput : arr[] = {10, 5, 3, 1}\n\nInput : arr[] = {1, 50, 100, 25}\nOutput : arr[] = {100, 50, 25, 1}", "link": "https://www.geeksforgeeks.org/heap-sort-for-decreasing-order-using-min-heap/", "difficulty": "Easy", "categories": ["Heap"], "code": "def heapSort(arr: list) -> list:\n        def heapify(arr, n, i):\n                smallest = i \n                l = 2 * i + 1 \n                r = 2 * i + 2\n\n                if l < n and arr[l] < arr[smallest]: \n                        smallest = l \n\n                if r < n and arr[r] < arr[smallest]: \n                        smallest = r \n\n                if smallest != i: \n                        (arr[i], \n                        arr[smallest]) = (arr[smallest],\n                                                        arr[i])\n\n                        heapify(arr, n, smallest)\n         \n        n = len(arr)\n        for i in range(int(n / 2) - 1, -1, -1):\n                heapify(arr, n, i) \n\n        for i in range(n-1, -1, -1):\n                \n                arr[0], arr[i] = arr[i], arr[0]\n\n                heapify(arr, i, 0)\n\n        return arr\n", "asserts": ["assert heapSort([4,6,3,2,9]) == [9,6,4,3,2]", "assert heapSort([8, 1, 7, 2, 6, 3, 5, 4]) == [8, 7, 6, 5, 4, 3, 2, 1]", "assert heapSort([0]) == [0]", "assert heapSort([2, 1, 3, 5, 4, 7, 6]) == [7, 6, 5, 4, 3, 2, 1]", "assert heapSort([-1, -5, -3, -4, -2]) == [-1, -2, -3, -4, -5]", "assert heapSort([10, -2, 4, 5, 3, 7]) == [10, 7, 5, 4, 3, -2]", "assert heapSort([1.5, 2.5, 0.5, 3.5, 1.0, 2.0]) == [3.5, 2.5, 2.0, 1.5, 1.0, 0.5]", "assert heapSort([99]) == [99]", "assert heapSort([5, 5, 5, 5]) == [5, 5, 5, 5]", "assert heapSort([9, 7, 7, 9, 5, 5]) == [9, 9, 7, 7, 5, 5]", "assert heapSort([]) == []  # Empty list should return an empty list", "assert heapSort([1, 1000, 100, 10, 10000]) == [10000, 1000, 100, 10, 1]"], "category": "Heap"}, {"author": "Karthik", "UUID": "b2d10472-1c51-495a-a76c-b37a3c5986fb", "question": "Given an array arr[] containing n elements. The problem is to find the maximum number of distinct elements (non-repeating) after removing k elements from the array. Where 1<= k <= n", "examples": "Input : arr[] = {5, 7, 5, 5, 1, 2, 2}, k = 3\nOutput : 4\nRemove 2 occurrences of element 5 and\n1 occurrence of element 2.\n\nInput : arr[] = {1, 2, 3, 4, 5, 6, 7}, k = 5\nOutput : 2\n\nInput : arr[] = {1, 2, 2, 2}, k = 1\nOutput : 1", "link": "https://www.geeksforgeeks.org/maximum-distinct-elements-removing-k-elements/", "difficulty": "Medium", "categories": ["Heap"], "code": "\ndef maxDistinctNum(a: list, k: int) -> int:\n        s = {}\n        n = len(a)\n        for i in range(n):\n                if a[i] not in s or k == 0:\n                        s[a[i]] = s.get(a[i], 0)+1\n                else:\n                        s[a[i]] = 1\n                        k -= 1\n        if k != 0:\n                return len(s)-k\n        else:\n\n                st = set()\n                for i in s:\n                        st.add(i)\n                return len(st)\n", "asserts": ["assert maxDistinctNum([5, 7, 5, 5, 1, 2, 2], 3) == 4", "assert maxDistinctNum([1, 2, 3, 4, 5, 6, 7], 5) == 2", "assert maxDistinctNum([7, 3, 5, 8, 5, 3, 4], 4) == 3", "assert maxDistinctNum([], 0) == 0", "assert maxDistinctNum([9], 1) == 0"], "category": "Heap"}, {"author": "Karthik", "UUID": "fc15ed0b-2303-4ccb-b9e0-9bc18f2a71ec", "question": "Given an array of integers. Write a program to find the K-th largest sum of contiguous subarray within the array of numbers that has both negative and positive numbers.", "examples": "Input: a[] = {20, -5, -1}, K = 3\nOutput: 14\nExplanation: All sum of contiguous subarrays are (20, 15, 14, -5, -6, -1) \nso the 3rd largest sum is 14.\n\nInput: a[] = {10, -10, 20, -40}, k = 6\nOutput: -10\nExplanation: The 6th largest sum among\nsum of all contiguous subarrays is -10.", "link": "https://www.geeksforgeeks.org/k-th-largest-sum-contiguous-subarray/", "difficulty": "Hard", "categories": ["Heap"], "code": "def kthLargestSum(arr: list, K: int) -> int:\n    N = len(arr)\n    result = []\n    for i in range(N):\n        sum = 0\n        for j in range(i, N):\n                sum += arr[j]\n                result.append(sum)\n\n    result.sort(reverse=True)\n\n    return result[K - 1]\n", "asserts": ["assert kthLargestSum([20, -5, -1], 3) == 14", "assert kthLargestSum([10, -10, 20, -40], 6) == -10", "assert kthLargestSum([0, 0, 0, 0, 0], 1) == 0", "assert kthLargestSum([2, 3, -2, -1, 10], 9) == 2"], "category": "Heap"}], "Stack": [{"few_shots": [{"author": "Hafeez", "UUID": "b6f47e1f-52e7-4dca-837f-88bc0d3b7a5a", "question": "Backspace String Compare: Given two strings s and t, return true if they are equal when both are typed into empty text editors. '#' means a backspace character.\n\nNote that after backspacing an empty text, the text will continue empty.", "examples": "Input: s = \"ab#c\", t = \"ad#c\"\nOutput: True\nExplanation: Both s and t become \"ac\".\nInput: s = \"a#c\", t = \"b\"\nOutput: False\nExplanation: s becomes \"c\" while t becomes \"b\".", "link": "https://leetcode.com/problems/backspace-string-compare/description/", "difficulty": "Easy", "categories": ["Stack"], "code": "def backspaceCompare(S: str, T: str) -> bool:\n    def build(S):\n        ans = []\n        for c in S:\n            if c != '#':\n                ans.append(c)\n            elif ans:\n                ans.pop()\n        return \"\".join(ans)\n    return build(S) == build(T)\n", "asserts": ["assert backspaceCompare(\"ab##\", \"c#d#\")==True", "assert backspaceCompare(\"a##c\", \"#a#c\") == True", "assert backspaceCompare(\"abc#d\", \"acc#c\") == False", "assert backspaceCompare(\"p##qr\", \"p#q#r\") == False", "assert backspaceCompare(\"####\", \"b#\") == True", "assert backspaceCompare(\"\", \"b#\") == True", "assert backspaceCompare(\"a###b\", \"b\") == True", "assert backspaceCompare(\"a\", \"a#\") == False"]}, {"author": "Hafeez", "UUID": "2fb3578a-9202-463d-8eb1-88df11a49ca7", "question": "Minimum Remove to Make Valid Parentheses: Given a string s of '(' , ')' and lowercase English characters.\n\nYour task is to remove the minimum number of parentheses ( '(' or ')', in any positions ) so that the resulting parentheses string is valid and return any valid string.\n\nFormally, a parentheses string is valid if and only if:\n\nIt is the empty string, contains only lowercase characters, or\nIt can be written as AB (A concatenated with B), where A and B are valid strings, or\nIt can be written as (A), where A is a valid string.", "examples": "Input: s = \"lee(t(c)o)de)\"\nOutput: \"lee(t(c)o)de\"\nExplanation: \"lee(t(co)de)\" , \"lee(t(c)ode)\" would also be accepted.\nInput: s = \"a)b(c)d\"\nOutput: \"ab(c)d\"\nInput: s = \"))((\"\nOutput: \"\"\nExplanation: An empty string is also valid.", "link": "https://leetcode.com/problems/minimum-remove-to-make-valid-parentheses/description/", "difficulty": "Medium", "categories": ["Stack"], "code": "def minRemoveToMakeValid(s: str) -> str:\n    indexes_to_remove = set()\n    stack = []\n    for i, c in enumerate(s):\n        if c not in \"()\":\n            continue\n        if c == \"(\":\n            stack.append(i)\n        elif not stack:\n            indexes_to_remove.add(i)\n        else:\n            stack.pop()\n    indexes_to_remove = indexes_to_remove.union(set(stack))\n    string_builder = []\n    for i, c in enumerate(s):\n        if i not in indexes_to_remove:\n            string_builder.append(c)\n    return \"\".join(string_builder)", "asserts": ["assert minRemoveToMakeValid(\"a)b(c)d\")==\"ab(c)d\"", "assert minRemoveToMakeValid(\"(a(b(c)d)\") == \"a(b(c)d)\"", "assert minRemoveToMakeValid(\")(\") == \"\"", "assert minRemoveToMakeValid(\"(((xyz))\") == \"((xyz))\"", "assert minRemoveToMakeValid(\"()\") == \"()\"", "assert minRemoveToMakeValid(\"\") == \"\"", "assert minRemoveToMakeValid(\"p(rq)()(st)\") == \"p(rq)()(st)\""]}], "category": "Stack", "prompt_tokens": 793, "total_tokens": 1020, "completion_tokens": 227, "completion": "Simplify Path: Given an absolute path for a file (Unix-style), simplify it. Or in other words, convert it to the canonical path.\n\nIn a Unix-style file system, a period . refers to the current directory. Furthermore, a double period .. moves up a directory. For more information, refer to Absolute Path vs Relative Path in Linux/Unix.\n\n###Code:\n\n```python\ndef simplifyPath(path: str) -> str:\n    stack = []\n    for p in path.split('/'):\n        if p == '..':\n            if stack:\n                stack.pop()\n        elif p and p != '.':\n            stack.append(p)\n    return '/' + '/'.join(stack)\n```\n\n###Testcases:\n\n```python\nassert simplifyPath(\"/home/\") == \"/home\"\nassert simplifyPath(\"/a/./b/../../c/\") == \"/c\"\nassert simplifyPath(\"/../\") == \"/\"\nassert simplifyPath(\"/home//foo/\") == \"/home/foo\"\nassert simplifyPath(\"/a/b/c\") == \"/a/b/c\"\nassert simplifyPath(\"/a/../../b/../c//.//\") == \"/c\"\n```\n\n", "temperature": 0.968, "question": "Simplify Path: Given an absolute path for a file (Unix-style), simplify it. Or in other words, convert it to the canonical path.\n\nIn a Unix-style file system, a period . refers to the current directory. Furthermore, a double period .. moves up a directory. For more information, refer to Absolute Path vs Relative Path in Linux/Unix.", "code": "def simplifyPath(path: str) -> str:\n    stack = []\n    for p in path.split('/'):\n        if p == '..':\n            if stack:\n                stack.pop()\n        elif p and p != '.':\n            stack.append(p)\n    return '/' + '/'.join(stack)", "asserts": ["assert simplifyPath(\"/home/\") == \"/home\"", "assert simplifyPath(\"/a/./b/../../c/\") == \"/c\"", "assert simplifyPath(\"/../\") == \"/\"", "assert simplifyPath(\"/home//foo/\") == \"/home/foo\"", "assert simplifyPath(\"/a/b/c\") == \"/a/b/c\"", "assert simplifyPath(\"/a/../../b/../c//.//\") == \"/c\""], "author": "GPT", "UUID": "5ede1bc6-686e-4cb7-9047-bb59480504aa", "tc_status": [["assert simplifyPath(\"/home/\") == \"/home\"", "Passed"], ["assert simplifyPath(\"/a/./b/../../c/\") == \"/c\"", "Passed"], ["assert simplifyPath(\"/../\") == \"/\"", "Passed"], ["assert simplifyPath(\"/home//foo/\") == \"/home/foo\"", "Passed"], ["assert simplifyPath(\"/a/b/c\") == \"/a/b/c\"", "Passed"], ["assert simplifyPath(\"/a/../../b/../c//.//\") == \"/c\"", "Passed"]]}, {"few_shots": [{"author": "Hafeez", "UUID": "2fb3578a-9202-463d-8eb1-88df11a49ca7", "question": "Minimum Remove to Make Valid Parentheses: Given a string s of '(' , ')' and lowercase English characters.\n\nYour task is to remove the minimum number of parentheses ( '(' or ')', in any positions ) so that the resulting parentheses string is valid and return any valid string.\n\nFormally, a parentheses string is valid if and only if:\n\nIt is the empty string, contains only lowercase characters, or\nIt can be written as AB (A concatenated with B), where A and B are valid strings, or\nIt can be written as (A), where A is a valid string.", "examples": "Input: s = \"lee(t(c)o)de)\"\nOutput: \"lee(t(c)o)de\"\nExplanation: \"lee(t(co)de)\" , \"lee(t(c)ode)\" would also be accepted.\nInput: s = \"a)b(c)d\"\nOutput: \"ab(c)d\"\nInput: s = \"))((\"\nOutput: \"\"\nExplanation: An empty string is also valid.", "link": "https://leetcode.com/problems/minimum-remove-to-make-valid-parentheses/description/", "difficulty": "Medium", "categories": ["Stack"], "code": "def minRemoveToMakeValid(s: str) -> str:\n    indexes_to_remove = set()\n    stack = []\n    for i, c in enumerate(s):\n        if c not in \"()\":\n            continue\n        if c == \"(\":\n            stack.append(i)\n        elif not stack:\n            indexes_to_remove.add(i)\n        else:\n            stack.pop()\n    indexes_to_remove = indexes_to_remove.union(set(stack))\n    string_builder = []\n    for i, c in enumerate(s):\n        if i not in indexes_to_remove:\n            string_builder.append(c)\n    return \"\".join(string_builder)", "asserts": ["assert minRemoveToMakeValid(\"a)b(c)d\")==\"ab(c)d\"", "assert minRemoveToMakeValid(\"(a(b(c)d)\") == \"a(b(c)d)\"", "assert minRemoveToMakeValid(\")(\") == \"\"", "assert minRemoveToMakeValid(\"(((xyz))\") == \"((xyz))\"", "assert minRemoveToMakeValid(\"()\") == \"()\"", "assert minRemoveToMakeValid(\"\") == \"\"", "assert minRemoveToMakeValid(\"p(rq)()(st)\") == \"p(rq)()(st)\""]}, {"author": "Hafeez", "UUID": "b6f47e1f-52e7-4dca-837f-88bc0d3b7a5a", "question": "Backspace String Compare: Given two strings s and t, return true if they are equal when both are typed into empty text editors. '#' means a backspace character.\n\nNote that after backspacing an empty text, the text will continue empty.", "examples": "Input: s = \"ab#c\", t = \"ad#c\"\nOutput: True\nExplanation: Both s and t become \"ac\".\nInput: s = \"a#c\", t = \"b\"\nOutput: False\nExplanation: s becomes \"c\" while t becomes \"b\".", "link": "https://leetcode.com/problems/backspace-string-compare/description/", "difficulty": "Easy", "categories": ["Stack"], "code": "def backspaceCompare(S: str, T: str) -> bool:\n    def build(S):\n        ans = []\n        for c in S:\n            if c != '#':\n                ans.append(c)\n            elif ans:\n                ans.pop()\n        return \"\".join(ans)\n    return build(S) == build(T)\n", "asserts": ["assert backspaceCompare(\"ab##\", \"c#d#\")==True", "assert backspaceCompare(\"a##c\", \"#a#c\") == True", "assert backspaceCompare(\"abc#d\", \"acc#c\") == False", "assert backspaceCompare(\"p##qr\", \"p#q#r\") == False", "assert backspaceCompare(\"####\", \"b#\") == True", "assert backspaceCompare(\"\", \"b#\") == True", "assert backspaceCompare(\"a###b\", \"b\") == True", "assert backspaceCompare(\"a\", \"a#\") == False"]}], "category": "Stack", "prompt_tokens": 793, "total_tokens": 1087, "completion_tokens": 294, "completion": "Implement a stack that supports push, pop, top, and retrieving the minimum element in constant time.\n\n- push(x) -- Push element x onto stack.\n- pop() -- Removes the element on top of the stack.\n- top() -- Get the top element.\n- getMin() -- Retrieve the minimum element in the stack.\n\nYou may assume the stack's top element is not the minimum element initially.\n\n###Code: \n\n```python\nclass MinStack:\n\n    def __init__(self):\n        self.stack = []\n        self.min_stack = []\n\n    def push(self, x: int) -> None:\n        self.stack.append(x)\n        if not self.min_stack or x<=self.min_stack[-1]:\n            self.min_stack.append(x)\n\n    def pop(self) -> None:\n        if self.stack[-1]==self.min_stack[-1]:\n            self.min_stack.pop()\n        self.stack.pop()\n\n    def top(self) -> int:\n        return self.stack[-1]\n\n    def getMin(self) -> int:\n        return self.min_stack[-1]\n\n# Test the MinStack\nobj = MinStack()\nobj.push(5)\nobj.push(2)\nobj.push(3)\nobj.push(1)\nobj.push(4)\nobj.pop()\nparam_3 = obj.top()\nparam_4 = obj.getMin()\n```\n\n###Testcases: \n\n```python\nassert param_3 == 1\nassert param_4 == 1\n```", "temperature": 0.936, "question": "Implement a stack that supports push, pop, top, and retrieving the minimum element in constant time.\n\n- push(x) -- Push element x onto stack.\n- pop() -- Removes the element on top of the stack.\n- top() -- Get the top element.\n- getMin() -- Retrieve the minimum element in the stack.\n\nYou may assume the stack's top element is not the minimum element initially.", "code": "class MinStack:\n\n    def __init__(self):\n        self.stack = []\n        self.min_stack = []\n\n    def push(self, x: int) -> None:\n        self.stack.append(x)\n        if not self.min_stack or x<=self.min_stack[-1]:\n            self.min_stack.append(x)\n\n    def pop(self) -> None:\n        if self.stack[-1]==self.min_stack[-1]:\n            self.min_stack.pop()\n        self.stack.pop()\n\n    def top(self) -> int:\n        return self.stack[-1]\n\n    def getMin(self) -> int:\n        return self.min_stack[-1]\n\n# Test the MinStack\nobj = MinStack()\nobj.push(5)\nobj.push(2)\nobj.push(3)\nobj.push(1)\nobj.push(4)\nobj.pop()\nparam_3 = obj.top()\nparam_4 = obj.getMin()", "asserts": ["assert param_3 == 1", "assert param_4 == 1"], "author": "GPT", "UUID": "25116e64-3f02-47b2-ab07-c1c61892332d", "tc_status": [["assert param_3 == 1", "Passed"], ["assert param_4 == 1", "Passed"]]}, {"few_shots": [{"author": "Hafeez", "UUID": "2fb3578a-9202-463d-8eb1-88df11a49ca7", "question": "Minimum Remove to Make Valid Parentheses: Given a string s of '(' , ')' and lowercase English characters.\n\nYour task is to remove the minimum number of parentheses ( '(' or ')', in any positions ) so that the resulting parentheses string is valid and return any valid string.\n\nFormally, a parentheses string is valid if and only if:\n\nIt is the empty string, contains only lowercase characters, or\nIt can be written as AB (A concatenated with B), where A and B are valid strings, or\nIt can be written as (A), where A is a valid string.", "examples": "Input: s = \"lee(t(c)o)de)\"\nOutput: \"lee(t(c)o)de\"\nExplanation: \"lee(t(co)de)\" , \"lee(t(c)ode)\" would also be accepted.\nInput: s = \"a)b(c)d\"\nOutput: \"ab(c)d\"\nInput: s = \"))((\"\nOutput: \"\"\nExplanation: An empty string is also valid.", "link": "https://leetcode.com/problems/minimum-remove-to-make-valid-parentheses/description/", "difficulty": "Medium", "categories": ["Stack"], "code": "def minRemoveToMakeValid(s: str) -> str:\n    indexes_to_remove = set()\n    stack = []\n    for i, c in enumerate(s):\n        if c not in \"()\":\n            continue\n        if c == \"(\":\n            stack.append(i)\n        elif not stack:\n            indexes_to_remove.add(i)\n        else:\n            stack.pop()\n    indexes_to_remove = indexes_to_remove.union(set(stack))\n    string_builder = []\n    for i, c in enumerate(s):\n        if i not in indexes_to_remove:\n            string_builder.append(c)\n    return \"\".join(string_builder)", "asserts": ["assert minRemoveToMakeValid(\"a)b(c)d\")==\"ab(c)d\"", "assert minRemoveToMakeValid(\"(a(b(c)d)\") == \"a(b(c)d)\"", "assert minRemoveToMakeValid(\")(\") == \"\"", "assert minRemoveToMakeValid(\"(((xyz))\") == \"((xyz))\"", "assert minRemoveToMakeValid(\"()\") == \"()\"", "assert minRemoveToMakeValid(\"\") == \"\"", "assert minRemoveToMakeValid(\"p(rq)()(st)\") == \"p(rq)()(st)\""]}, {"author": "Hafeez", "UUID": "a4782492-10a7-4601-a995-c1a0f9d57a67", "question": "Trapping Rain Water: Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.", "examples": "Input: height = [0,1,0,2,1,0,1,3,2,1,2,1]\nOutput: 6\nExplanation: The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped.\nInput: height = [4,2,0,3,2,5]\nOutput: 9", "link": "https://leetcode.com/problems/trapping-rain-water/description/", "difficulty": "Hard", "categories": ["Stack"], "code": "def trap(bars: list) -> int:\n    if not bars or len(bars) < 3:\n        return 0\n    volume = 0\n    left, right = 0, len(bars) - 1\n    l_max, r_max = bars[left], bars[right]\n    while left < right:\n        l_max, r_max = max(bars[left], l_max), max(bars[right], r_max)\n        if l_max <= r_max:\n            volume += l_max - bars[left]\n            left += 1\n        else:\n            volume += r_max - bars[right]\n            right -= 1\n    return volume\n", "asserts": ["assert trap([4,2,0,3,2,5])==9", "assert trap([3, 0, 1, 3, 0, 5]) == 8", "assert trap([1, 2, 3, 4, 5, 6]) == 0", "assert trap([6, 5, 4, 3, 2, 1]) == 0", "assert trap([1, 0, 1, 0, 1, 0, 1]) == 3", "assert trap([2, 0, 2]) == 2", "assert trap([5, 4, 1, 2]) == 1", "assert trap([0, 7, 1, 4, 6]) == 7", "assert trap([0, 0, 0, 0, 0]) == 0", "assert trap([2, 1, 0, 1, 2, 1, 2, 1]) == 5", "assert trap([1, 3, 2, 4, 1, 3, 1, 4, 5, 2, 2, 1, 4, 2, 2]) == 15"]}], "category": "Stack", "prompt_tokens": 1001, "total_tokens": 1353, "completion_tokens": 352, "completion": "Largest Rectangle in Histogram: Given an array of non-negative integers representing the histogram's bar height where the width of each bar is 1, find the area of the largest rectangle in the histogram.\n\n###Code: \n\n```python\ndef largestRectangleArea(heights: List[int]) -> int:\n    stack = []\n    max_area = 0\n    index = 0\n    while index < len(heights):\n        if not stack or heights[index] >= heights[stack[-1]]:\n            stack.append(index)\n            index += 1\n        else:\n            top_of_stack = stack.pop()\n            current_area = heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)\n            max_area = max(max_area, current_area)\n    while stack:\n        top_of_stack = stack.pop()\n        current_area = heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)\n        max_area = max(max_area, current_area)\n    return max_area\n```\n\n###Testcases: \n\n```python\nassert largestRectangleArea([2,1,5,6,2,3])==10\nassert largestRectangleArea([2,4])==4\nassert largestRectangleArea([2])==2\nassert largestRectangleArea([0,9])==9\nassert largestRectangleArea([2,1,2])==3\nassert largestRectangleArea([3,6,5,7,4,8,1,0])==20\nassert largestRectangleArea([2,1,2,3,1])==5\nassert largestRectangleArea([1,1,1,1,1,1])==6\n```\n\n[/Example 3]", "temperature": 0.946, "question": "Largest Rectangle in Histogram: Given an array of non-negative integers representing the histogram's bar height where the width of each bar is 1, find the area of the largest rectangle in the histogram.", "code": "def largestRectangleArea(heights: List[int]) -> int:\n    stack = []\n    max_area = 0\n    index = 0\n    while index < len(heights):\n        if not stack or heights[index] >= heights[stack[-1]]:\n            stack.append(index)\n            index += 1\n        else:\n            top_of_stack = stack.pop()\n            current_area = heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)\n            max_area = max(max_area, current_area)\n    while stack:\n        top_of_stack = stack.pop()\n        current_area = heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)\n        max_area = max(max_area, current_area)\n    return max_area", "asserts": ["assert largestRectangleArea([2,1,5,6,2,3])==10", "assert largestRectangleArea([2,4])==4", "assert largestRectangleArea([2])==2", "assert largestRectangleArea([0,9])==9", "assert largestRectangleArea([2,1,2])==3", "assert largestRectangleArea([3,6,5,7,4,8,1,0])==20", "assert largestRectangleArea([2,1,2,3,1])==5", "assert largestRectangleArea([1,1,1,1,1,1])==6"], "author": "GPT", "UUID": "05236914-9371-49e4-9d78-13498148903a", "tc_status": [["assert largestRectangleArea([2,1,5,6,2,3])==10", "Passed"], ["assert largestRectangleArea([2,4])==4", "Passed"], ["assert largestRectangleArea([2])==2", "Passed"], ["assert largestRectangleArea([0,9])==9", "Passed"], ["assert largestRectangleArea([2,1,2])==3", "Passed"], ["assert largestRectangleArea([3,6,5,7,4,8,1,0])==20", "Passed"], ["assert largestRectangleArea([2,1,2,3,1])==5", "Passed"], ["assert largestRectangleArea([1,1,1,1,1,1])==6", "Passed"]]}, {"few_shots": [{"author": "Hafeez", "UUID": "a4782492-10a7-4601-a995-c1a0f9d57a67", "question": "Trapping Rain Water: Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.", "examples": "Input: height = [0,1,0,2,1,0,1,3,2,1,2,1]\nOutput: 6\nExplanation: The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped.\nInput: height = [4,2,0,3,2,5]\nOutput: 9", "link": "https://leetcode.com/problems/trapping-rain-water/description/", "difficulty": "Hard", "categories": ["Stack"], "code": "def trap(bars: list) -> int:\n    if not bars or len(bars) < 3:\n        return 0\n    volume = 0\n    left, right = 0, len(bars) - 1\n    l_max, r_max = bars[left], bars[right]\n    while left < right:\n        l_max, r_max = max(bars[left], l_max), max(bars[right], r_max)\n        if l_max <= r_max:\n            volume += l_max - bars[left]\n            left += 1\n        else:\n            volume += r_max - bars[right]\n            right -= 1\n    return volume\n", "asserts": ["assert trap([4,2,0,3,2,5])==9", "assert trap([3, 0, 1, 3, 0, 5]) == 8", "assert trap([1, 2, 3, 4, 5, 6]) == 0", "assert trap([6, 5, 4, 3, 2, 1]) == 0", "assert trap([1, 0, 1, 0, 1, 0, 1]) == 3", "assert trap([2, 0, 2]) == 2", "assert trap([5, 4, 1, 2]) == 1", "assert trap([0, 7, 1, 4, 6]) == 7", "assert trap([0, 0, 0, 0, 0]) == 0", "assert trap([2, 1, 0, 1, 2, 1, 2, 1]) == 5", "assert trap([1, 3, 2, 4, 1, 3, 1, 4, 5, 2, 2, 1, 4, 2, 2]) == 15"]}, {"author": "Hafeez", "UUID": "2fb3578a-9202-463d-8eb1-88df11a49ca7", "question": "Minimum Remove to Make Valid Parentheses: Given a string s of '(' , ')' and lowercase English characters.\n\nYour task is to remove the minimum number of parentheses ( '(' or ')', in any positions ) so that the resulting parentheses string is valid and return any valid string.\n\nFormally, a parentheses string is valid if and only if:\n\nIt is the empty string, contains only lowercase characters, or\nIt can be written as AB (A concatenated with B), where A and B are valid strings, or\nIt can be written as (A), where A is a valid string.", "examples": "Input: s = \"lee(t(c)o)de)\"\nOutput: \"lee(t(c)o)de\"\nExplanation: \"lee(t(co)de)\" , \"lee(t(c)ode)\" would also be accepted.\nInput: s = \"a)b(c)d\"\nOutput: \"ab(c)d\"\nInput: s = \"))((\"\nOutput: \"\"\nExplanation: An empty string is also valid.", "link": "https://leetcode.com/problems/minimum-remove-to-make-valid-parentheses/description/", "difficulty": "Medium", "categories": ["Stack"], "code": "def minRemoveToMakeValid(s: str) -> str:\n    indexes_to_remove = set()\n    stack = []\n    for i, c in enumerate(s):\n        if c not in \"()\":\n            continue\n        if c == \"(\":\n            stack.append(i)\n        elif not stack:\n            indexes_to_remove.add(i)\n        else:\n            stack.pop()\n    indexes_to_remove = indexes_to_remove.union(set(stack))\n    string_builder = []\n    for i, c in enumerate(s):\n        if i not in indexes_to_remove:\n            string_builder.append(c)\n    return \"\".join(string_builder)", "asserts": ["assert minRemoveToMakeValid(\"a)b(c)d\")==\"ab(c)d\"", "assert minRemoveToMakeValid(\"(a(b(c)d)\") == \"a(b(c)d)\"", "assert minRemoveToMakeValid(\")(\") == \"\"", "assert minRemoveToMakeValid(\"(((xyz))\") == \"((xyz))\"", "assert minRemoveToMakeValid(\"()\") == \"()\"", "assert minRemoveToMakeValid(\"\") == \"\"", "assert minRemoveToMakeValid(\"p(rq)()(st)\") == \"p(rq)()(st)\""]}], "category": "Stack", "prompt_tokens": 1001, "total_tokens": 1380, "completion_tokens": 379, "completion": "Implement a basic calculator that evaluates a string with non-negative integers, +, -, (, and ) to calculate the result.\n\n###Code: \n\n```python\ndef calculate(s: str) -> int:\n    stack = []\n    operand = 0\n    res = 0  # For the on-going result\n    sign = 1  # 1 means positive, -1 means negative  \n    for ch in s:\n        if ch.isdigit():\n            operand = (operand * 10) + int(ch)\n        elif ch == '+':\n            res += sign * operand\n            sign = 1\n            operand = 0\n        elif ch == '-':\n            res += sign * operand\n            sign = -1\n            operand = 0\n        elif ch == '(':\n            stack.append(res)\n            stack.append(sign)\n            sign = 1\n            res = 0\n        elif ch == ')':\n            res += sign * operand\n            res *= stack.pop()  # stack.pop() is the sign before the parenthesis\n            res += stack.pop()  # stack.pop() now is the result calculated before the parenthesis\n            operand = 0\n    return res + sign * operand\n```\n\n###Testcases: \n\n```python\nassert calculate(\"1 + 1\") == 2\nassert calculate(\" 2-1 + 2 \") == 3\nassert calculate(\"(1+(4+5+2)-3)+(6+8)\") == 23\nassert calculate(\"1\") == 1\nassert calculate(\"2-1\") == 1\nassert calculate(\"2-(3-1)\") == 0\nassert calculate(\"3-(2-(5-8)+1)\") == 5\nassert calculate(\"100-(2-(3-1))\") == 96\n```\n\n[/Example 3]", "temperature": 0.74, "question": "Implement a basic calculator that evaluates a string with non-negative integers, +, -, (, and ) to calculate the result.", "code": "def calculate(s: str) -> int:\n    stack = []\n    operand = 0\n    res = 0  # For the on-going result\n    sign = 1  # 1 means positive, -1 means negative  \n    for ch in s:\n        if ch.isdigit():\n            operand = (operand * 10) + int(ch)\n        elif ch == '+':\n            res += sign * operand\n            sign = 1\n            operand = 0\n        elif ch == '-':\n            res += sign * operand\n            sign = -1\n            operand = 0\n        elif ch == '(':\n            stack.append(res)\n            stack.append(sign)\n            sign = 1\n            res = 0\n        elif ch == ')':\n            res += sign * operand\n            res *= stack.pop()  # stack.pop() is the sign before the parenthesis\n            res += stack.pop()  # stack.pop() now is the result calculated before the parenthesis\n            operand = 0\n    return res + sign * operand", "asserts": ["assert calculate(\"1 + 1\") == 2", "assert calculate(\" 2-1 + 2 \") == 3", "assert calculate(\"(1+(4+5+2)-3)+(6+8)\") == 23", "assert calculate(\"1\") == 1", "assert calculate(\"2-1\") == 1", "assert calculate(\"2-(3-1)\") == 0"], "author": "GPT", "UUID": "30f72ccf-5097-4834-bc62-9c68e8ccfbc7", "tc_status": [["assert calculate(\"1 + 1\") == 2", "Passed"], ["assert calculate(\" 2-1 + 2 \") == 3", "Passed"], ["assert calculate(\"(1+(4+5+2)-3)+(6+8)\") == 23", "Passed"], ["assert calculate(\"1\") == 1", "Passed"], ["assert calculate(\"2-1\") == 1", "Passed"], ["assert calculate(\"2-(3-1)\") == 0", "Passed"]]}, {"author": "Hafeez", "UUID": "b6f47e1f-52e7-4dca-837f-88bc0d3b7a5a", "question": "Backspace String Compare: Given two strings s and t, return true if they are equal when both are typed into empty text editors. '#' means a backspace character.\n\nNote that after backspacing an empty text, the text will continue empty.", "examples": "Input: s = \"ab#c\", t = \"ad#c\"\nOutput: True\nExplanation: Both s and t become \"ac\".\nInput: s = \"a#c\", t = \"b\"\nOutput: False\nExplanation: s becomes \"c\" while t becomes \"b\".", "link": "https://leetcode.com/problems/backspace-string-compare/description/", "difficulty": "Easy", "categories": ["Stack"], "code": "def backspaceCompare(S: str, T: str) -> bool:\n    def build(S):\n        ans = []\n        for c in S:\n            if c != '#':\n                ans.append(c)\n            elif ans:\n                ans.pop()\n        return \"\".join(ans)\n    return build(S) == build(T)\n", "asserts": ["assert backspaceCompare(\"ab##\", \"c#d#\")==True", "assert backspaceCompare(\"a##c\", \"#a#c\") == True", "assert backspaceCompare(\"abc#d\", \"acc#c\") == False", "assert backspaceCompare(\"p##qr\", \"p#q#r\") == False", "assert backspaceCompare(\"####\", \"b#\") == True", "assert backspaceCompare(\"\", \"b#\") == True", "assert backspaceCompare(\"a###b\", \"b\") == True", "assert backspaceCompare(\"a\", \"a#\") == False"], "category": "Stack"}, {"author": "Hafeez", "UUID": "4b76d4d6-6dbe-4bcf-ba3f-9c6a418373ea", "question": "Valid Parentheses: Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.\n\nAn input string is valid if:\n\nOpen brackets must be closed by the same type of brackets.\nOpen brackets must be closed in the correct order.\nEvery close bracket has a corresponding open bracket of the same type.", "examples": "Input: s = \"()\"\nOutput: true\nInput: s = \"()[]{}\"\nOutput: true", "link": "https://leetcode.com/problems/valid-parentheses/description/", "difficulty": "Easy", "categories": ["Stack"], "code": "def isValid(s: str) -> bool:\n    stack = []\n    mapping = {\")\": \"(\", \"}\": \"{\", \"]\": \"[\"}\n    for char in s:\n        if char in mapping:\n            top_element = stack.pop() if stack else '#'\n            if mapping[char] != top_element:\n                return False\n        else:\n            stack.append(char)\n    return not stack\n", "asserts": ["assert isValid(\"(]\")==False", "assert isValid(\"([)]\") == False", "assert isValid(\"{[]}\") == True", "assert isValid(\"((()))\") == True", "assert isValid(\")\") == False", "assert isValid(\"(}\") == False", "assert isValid(\"({})[]\") == True", "assert isValid(\"\") == True", "assert isValid(\"([]{})\") == True", "assert isValid(\"[({(())}[()])]\") == True", "assert isValid(\"(((((({{{{{{{[[[[[[]]]]]]}}}}}}}))))))\") == True", "assert isValid(\"{[}]\") == False", "assert isValid(\"([{])\") == False", "assert isValid(\"([\") == False", "assert isValid(\"([]\") == False", "assert isValid(\"[])\") == False", "assert isValid(\"{\") == False", "assert isValid(\"{}}\") == False"], "category": "Stack"}, {"author": "Hafeez", "UUID": "2fb3578a-9202-463d-8eb1-88df11a49ca7", "question": "Minimum Remove to Make Valid Parentheses: Given a string s of '(' , ')' and lowercase English characters.\n\nYour task is to remove the minimum number of parentheses ( '(' or ')', in any positions ) so that the resulting parentheses string is valid and return any valid string.\n\nFormally, a parentheses string is valid if and only if:\n\nIt is the empty string, contains only lowercase characters, or\nIt can be written as AB (A concatenated with B), where A and B are valid strings, or\nIt can be written as (A), where A is a valid string.", "examples": "Input: s = \"lee(t(c)o)de)\"\nOutput: \"lee(t(c)o)de\"\nExplanation: \"lee(t(co)de)\" , \"lee(t(c)ode)\" would also be accepted.\nInput: s = \"a)b(c)d\"\nOutput: \"ab(c)d\"\nInput: s = \"))((\"\nOutput: \"\"\nExplanation: An empty string is also valid.", "link": "https://leetcode.com/problems/minimum-remove-to-make-valid-parentheses/description/", "difficulty": "Medium", "categories": ["Stack"], "code": "def minRemoveToMakeValid(s: str) -> str:\n    indexes_to_remove = set()\n    stack = []\n    for i, c in enumerate(s):\n        if c not in \"()\":\n            continue\n        if c == \"(\":\n            stack.append(i)\n        elif not stack:\n            indexes_to_remove.add(i)\n        else:\n            stack.pop()\n    indexes_to_remove = indexes_to_remove.union(set(stack))\n    string_builder = []\n    for i, c in enumerate(s):\n        if i not in indexes_to_remove:\n            string_builder.append(c)\n    return \"\".join(string_builder)", "asserts": ["assert minRemoveToMakeValid(\"a)b(c)d\")==\"ab(c)d\"", "assert minRemoveToMakeValid(\"(a(b(c)d)\") == \"a(b(c)d)\"", "assert minRemoveToMakeValid(\")(\") == \"\"", "assert minRemoveToMakeValid(\"(((xyz))\") == \"((xyz))\"", "assert minRemoveToMakeValid(\"()\") == \"()\"", "assert minRemoveToMakeValid(\"\") == \"\"", "assert minRemoveToMakeValid(\"p(rq)()(st)\") == \"p(rq)()(st)\""], "category": "Stack"}, {"author": "Hafeez", "UUID": "a4782492-10a7-4601-a995-c1a0f9d57a67", "question": "Trapping Rain Water: Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.", "examples": "Input: height = [0,1,0,2,1,0,1,3,2,1,2,1]\nOutput: 6\nExplanation: The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped.\nInput: height = [4,2,0,3,2,5]\nOutput: 9", "link": "https://leetcode.com/problems/trapping-rain-water/description/", "difficulty": "Hard", "categories": ["Stack"], "code": "def trap(bars: list) -> int:\n    if not bars or len(bars) < 3:\n        return 0\n    volume = 0\n    left, right = 0, len(bars) - 1\n    l_max, r_max = bars[left], bars[right]\n    while left < right:\n        l_max, r_max = max(bars[left], l_max), max(bars[right], r_max)\n        if l_max <= r_max:\n            volume += l_max - bars[left]\n            left += 1\n        else:\n            volume += r_max - bars[right]\n            right -= 1\n    return volume\n", "asserts": ["assert trap([4,2,0,3,2,5])==9", "assert trap([3, 0, 1, 3, 0, 5]) == 8", "assert trap([1, 2, 3, 4, 5, 6]) == 0", "assert trap([6, 5, 4, 3, 2, 1]) == 0", "assert trap([1, 0, 1, 0, 1, 0, 1]) == 3", "assert trap([2, 0, 2]) == 2", "assert trap([5, 4, 1, 2]) == 1", "assert trap([0, 7, 1, 4, 6]) == 7", "assert trap([0, 0, 0, 0, 0]) == 0", "assert trap([2, 1, 0, 1, 2, 1, 2, 1]) == 5", "assert trap([1, 3, 2, 4, 1, 3, 1, 4, 5, 2, 2, 1, 4, 2, 2]) == 15"], "category": "Stack"}], "Dynamic_programming": [{"few_shots": [{"author": "Hafeez", "UUID": "38dca76c-ee6c-4c71-83a9-89240828a3b7", "question": "Best Time to Buy and Sell Stock II: You are given an integer array prices where prices[i] is the price of a given stock on the ith day.\n\nOn each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day.\n\nFind and return the maximum profit you can achieve.", "examples": "Input: prices = [7,1,5,3,6,4]\nOutput: 7\nExplanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\nThen buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.\nTotal profit is 4 + 3 = 7.\nInput: prices = [7,6,4,3,1]\nOutput: 0\nExplanation: There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0.", "link": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/", "difficulty": "Medium", "categories": ["Dynamic_programming"], "code": "from typing import List\ndef maxProfit(prices: List[int]) -> int:\n    cur_hold, cur_not_hold = -float('inf'), 0\n    \n    for stock_price in prices:\n        \n        prev_hold, prev_not_hold = cur_hold, cur_not_hold\n        cur_hold = max( prev_hold, prev_not_hold - stock_price )\n        cur_not_hold = max( prev_not_hold, prev_hold + stock_price )\n    return cur_not_hold", "asserts": ["assert maxProfit([1,2,3,4,5])==4", "assert maxProfit([1,2,100,2,1]) == 99"]}, {"author": "Calvin", "UUID": "51a5caf9-241f-4de3-9ee2-9420490b73d7", "question": "Given a set[] of non-negative integers and a value sum, return the subset of the given set whose sum is equal to the given sum or None if one doesn't exist\n", "examples": "Input: set = [1, 2, 3, 4, 5], sum = 10\nOutput: [1, 2, 3, 4]", "link": "https://www.geeksforgeeks.org/subset-sum-problem-dp-25/", "difficulty": null, "categories": ["Dynamic_programming"], "code": "def subsetsum(fullset: list, target_sum: int) -> set:\n    def subsetSum_helper(cur_idx: int, fullset: list, target_sum: int, subset: list):\n        if target_sum == 0:\n            return subset\n        if (cur_idx == len(fullset)):\n            return None\n        excluding = subsetSum_helper(cur_idx + 1, fullset, target_sum, subset)\n          \n        if excluding is not None:\n            return excluding\n        elif fullset[cur_idx] <= target_sum:\n            subset.append(fullset[cur_idx])\n            including = subsetSum_helper(cur_idx + 1, fullset, target_sum - fullset[cur_idx], subset)\n            if including!=None:\n                return including\n            else:\n                subset.pop()\n            return None\n    return subsetSum_helper(0, fullset, target_sum, [])\n", "asserts": ["assert set(subsetsum([3, 34, 4, 12, 5, 2], 9)) == {4,5}", "assert subsetsum([1, 8, 2, 7, 4], 14) == [8, 2, 4]", "assert subsetsum([10, 12, 15, 6, 19], 21) == [15, 6]", "assert subsetsum([5, 10, 12, 13, 15, 18], 30) == [12, 18]", "assert subsetsum([5, 3, 9, 12, 6, 15], 27) == [12, 15]", "assert subsetsum([2, 3, 7, 8, 10], 11) == [3, 8]", "assert subsetsum([6, 2, 7, 11, 8], 16) == [6, 2, 8]", "assert subsetsum([5, 7, 1, 14, 6], 13) == [7, 6]", "assert subsetsum([1], 1) == [1]", "assert subsetsum([2, 5, 8, 4], 0) == []", "assert subsetsum([], 5) == None", "assert subsetsum([-1, -2, -3, -4, -5], -10) == None  # Negative numbers are not allowed according to the question", "assert subsetsum([4, 1, 2, 5, 12, 7], 9) == [2, 7]", "assert subsetsum([3, 5, 8, 4], 22) == None  # Sum exceeds the sum of all elements"]}], "category": "Dynamic_programming", "prompt_tokens": 1031, "total_tokens": 1323, "completion_tokens": 292, "completion": "You are given a list of non-negative integers representing the amount of money of each house. You are not allowed to rob adjacent houses. Find the maximum amount of money you can rob tonight without alerting the police.\n\n###Code: \n\ndef rob(nums: List[int]) -> int:\n    if not nums:\n        return 0\n    if len(nums) == 1:\n        return nums[0]\n    dp = [0] * len(nums)\n    dp[0] = nums[0]\n    dp[1] = max(nums[0], nums[1])\n    for i in range(2, len(nums)):\n        dp[i] = max(dp[i-1], dp[i-2] + nums[i])\n    return dp[-1]\n\n###Testcases: \n\nassert rob([1,2,3,1]) == 4\nassert rob([2,7,9,3,1]) == 12\nassert rob([2,1,1,2]) == 4\nassert rob([1,2,3,4,5,1,2,3,4,5]) == 16\nassert rob([6,7,8,9,10]) == 24\nassert rob([5]) == 5\nassert rob([2,3,2]) == 4\nassert rob([1,2,1,1]) == 3\n\n[/Example 3]", "temperature": 0.601, "model_name": "gpt-3.5-turbo-1106", "question": "You are given a list of non-negative integers representing the amount of money of each house. You are not allowed to rob adjacent houses. Find the maximum amount of money you can rob tonight without alerting the police.", "code": "def rob(nums: List[int]) -> int:\n    if not nums:\n        return 0\n    if len(nums) == 1:\n        return nums[0]\n    dp = [0] * len(nums)\n    dp[0] = nums[0]\n    dp[1] = max(nums[0], nums[1])\n    for i in range(2, len(nums)):\n        dp[i] = max(dp[i-1], dp[i-2] + nums[i])\n    return dp[-1]", "asserts": ["assert rob([1,2,3,1]) == 4", "assert rob([2,7,9,3,1]) == 12", "assert rob([2,1,1,2]) == 4", "assert rob([6,7,8,9,10]) == 24", "assert rob([5]) == 5", "assert rob([2,3,2]) == 4", "assert rob([1,2,1,1]) == 3"], "author": "GPT", "UUID": "3d0e68c4-4c98-4cc2-99fa-8b62083137f0", "tc_status": [["assert rob([1,2,3,1]) == 4", "Passed"], ["assert rob([2,7,9,3,1]) == 12", "Passed"], ["assert rob([2,1,1,2]) == 4", "Passed"], ["assert rob([6,7,8,9,10]) == 24", "Passed"], ["assert rob([5]) == 5", "Passed"], ["assert rob([2,3,2]) == 4", "Passed"], ["assert rob([1,2,1,1]) == 3", "Passed"]]}, {"few_shots": [{"author": "Calvin", "UUID": "5e7011e5-fee4-4c1a-a98f-3b81e50508cc", "question": "Return nth number in the fibonacci sequence", "examples": "Input: 9\nOutput: 34\n\nInput: 7\nOutput: 13", "link": NaN, "difficulty": null, "categories": ["Dynamic_programming"], "code": "def fibonacci(n: int) -> int:\n    a = 0\n    b = 1\n    if n < 0:\n        print(\"Incorrect input\")\n    elif n == 0:\n        return a\n    elif n == 1:\n        return b\n    else:\n        for i in range(2, n+1):\n            c = a + b\n            a = b\n            b = c\n        return b\n    b = c\n    return fib(n-1, a, b)\n", "asserts": ["assert fibonacci(9) == 34", "assert fibonacci(10) == 55", "assert fibonacci(5) == 5", "assert fibonacci(2) == 1", "assert fibonacci(0) == 0", "assert fibonacci(11) == 89", "assert fibonacci(15) == 610", "assert fibonacci(20) == 6765", "assert fibonacci(25) == 75025", "assert fibonacci(3) == 2", "assert fibonacci(1) == 1", "assert fibonacci(6) == 8", "assert fibonacci(30) == 832040", "assert fibonacci(35) == 9227465", "assert fibonacci(40) == 102334155"]}, {"author": "Hafeez", "UUID": "d695e67c-5b0e-4235-8406-30ee6be61173", "question": "N-th Tribonacci Number: The Tribonacci sequence Tn is defined as follows: \n\nT0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n >= 0.\n\nGiven n, return the value of Tn.", "examples": "Input: n = 4\nOutput: 4\nExplanation:\nT_3 = 0 + 1 + 1 = 2\nT_4 = 1 + 1 + 2 = 4", "link": "https://leetcode.com/problems/n-th-tribonacci-number/description/", "difficulty": "Easy", "categories": ["Dynamic_programming"], "code": "def tribonacci(n: int) -> int:\n    dp = {0: 0, 1: 1, 2: 1}\n    def dfs(i):\n        if i in dp:\n            return dp[i]\n        dp[i] = dfs(i - 1) + dfs(i - 2) + dfs(i - 3)\n        return dp[i]\n    \n    return dfs(n)", "asserts": ["assert tribonacci(25)==1389537", "assert tribonacci(0) == 0", "assert tribonacci(1) == 1", "assert tribonacci(2) == 1", "assert tribonacci(3) == 2", "assert tribonacci(5) == 7", "assert tribonacci(7) == 24", "assert tribonacci(10) == 149", "assert tribonacci(15) == 3136", "assert tribonacci(30) == 29249425"]}], "category": "Dynamic_programming", "prompt_tokens": 735, "total_tokens": 1033, "completion_tokens": 298, "completion": "Find the minimum number of operations required to reach a target number n starting from 0, where only allowed operations are:\n1. Add 1\n2. Double the number\n\n###Code: \n\ndef min_operations_to_reach(n: int) -> int:\n    dp = [0] * (n+1)\n    for i in range(1, n+1):\n        if i % 2 == 0:\n            dp[i] = min(dp[i // 2], dp[i - 1]) + 1\n        else:\n            dp[i] = dp[i - 1] + 1\n    return dp[n]\n\n###Testcases: \n\nassert min_operations_to_reach(5) == 4\nassert min_operations_to_reach(10) == 4\nassert min_operations_to_reach(20) == 5\nassert min_operations_to_reach(3) == 3\nassert min_operations_to_reach(15) == 6\nassert min_operations_to_reach(7) == 5\nassert min_operations_to_reach(25) == 6\nassert min_operations_to_reach(30) == 6\nassert min_operations_to_reach(1) == 1\nassert min_operations_to_reach(2) == 2\nassert min_operations_to_reach(8) == 4\nassert min_operations_to_reach(12) == 5\n\n[/Example 3]", "temperature": 0.9, "model_name": "gpt-3.5-turbo-1106", "question": "Find the minimum number of operations required to reach a target number n starting from 0, where only allowed operations are:\n1. Add 1\n2. Double the number", "code": "def min_operations_to_reach(n: int) -> int:\n    dp = [0] * (n+1)\n    for i in range(1, n+1):\n        if i % 2 == 0:\n            dp[i] = min(dp[i // 2], dp[i - 1]) + 1\n        else:\n            dp[i] = dp[i - 1] + 1\n    return dp[n]", "asserts": ["assert min_operations_to_reach(5) == 4", "assert min_operations_to_reach(3) == 3", "assert min_operations_to_reach(7) == 5", "assert min_operations_to_reach(1) == 1", "assert min_operations_to_reach(2) == 2", "assert min_operations_to_reach(8) == 4", "assert min_operations_to_reach(12) == 5"], "author": "GPT", "UUID": "ffd0c084-97d6-497b-b872-95ed4c5355c0", "tc_status": [["assert min_operations_to_reach(5) == 4", "Passed"], ["assert min_operations_to_reach(3) == 3", "Passed"], ["assert min_operations_to_reach(7) == 5", "Passed"], ["assert min_operations_to_reach(1) == 1", "Passed"], ["assert min_operations_to_reach(2) == 2", "Passed"], ["assert min_operations_to_reach(8) == 4", "Passed"], ["assert min_operations_to_reach(12) == 5", "Passed"]]}, {"few_shots": [{"author": "Hafeez", "UUID": "38dca76c-ee6c-4c71-83a9-89240828a3b7", "question": "Best Time to Buy and Sell Stock II: You are given an integer array prices where prices[i] is the price of a given stock on the ith day.\n\nOn each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day.\n\nFind and return the maximum profit you can achieve.", "examples": "Input: prices = [7,1,5,3,6,4]\nOutput: 7\nExplanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\nThen buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.\nTotal profit is 4 + 3 = 7.\nInput: prices = [7,6,4,3,1]\nOutput: 0\nExplanation: There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0.", "link": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/", "difficulty": "Medium", "categories": ["Dynamic_programming"], "code": "from typing import List\ndef maxProfit(prices: List[int]) -> int:\n    cur_hold, cur_not_hold = -float('inf'), 0\n    \n    for stock_price in prices:\n        \n        prev_hold, prev_not_hold = cur_hold, cur_not_hold\n        cur_hold = max( prev_hold, prev_not_hold - stock_price )\n        cur_not_hold = max( prev_not_hold, prev_hold + stock_price )\n    return cur_not_hold", "asserts": ["assert maxProfit([1,2,3,4,5])==4", "assert maxProfit([1,2,100,2,1]) == 99"]}, {"author": "Calvin", "UUID": "51a5caf9-241f-4de3-9ee2-9420490b73d7", "question": "Given a set[] of non-negative integers and a value sum, return the subset of the given set whose sum is equal to the given sum or None if one doesn't exist\n", "examples": "Input: set = [1, 2, 3, 4, 5], sum = 10\nOutput: [1, 2, 3, 4]", "link": "https://www.geeksforgeeks.org/subset-sum-problem-dp-25/", "difficulty": null, "categories": ["Dynamic_programming"], "code": "def subsetsum(fullset: list, target_sum: int) -> set:\n    def subsetSum_helper(cur_idx: int, fullset: list, target_sum: int, subset: list):\n        if target_sum == 0:\n            return subset\n        if (cur_idx == len(fullset)):\n            return None\n        excluding = subsetSum_helper(cur_idx + 1, fullset, target_sum, subset)\n          \n        if excluding is not None:\n            return excluding\n        elif fullset[cur_idx] <= target_sum:\n            subset.append(fullset[cur_idx])\n            including = subsetSum_helper(cur_idx + 1, fullset, target_sum - fullset[cur_idx], subset)\n            if including!=None:\n                return including\n            else:\n                subset.pop()\n            return None\n    return subsetSum_helper(0, fullset, target_sum, [])\n", "asserts": ["assert set(subsetsum([3, 34, 4, 12, 5, 2], 9)) == {4,5}", "assert subsetsum([1, 8, 2, 7, 4], 14) == [8, 2, 4]", "assert subsetsum([10, 12, 15, 6, 19], 21) == [15, 6]", "assert subsetsum([5, 10, 12, 13, 15, 18], 30) == [12, 18]", "assert subsetsum([5, 3, 9, 12, 6, 15], 27) == [12, 15]", "assert subsetsum([2, 3, 7, 8, 10], 11) == [3, 8]", "assert subsetsum([6, 2, 7, 11, 8], 16) == [6, 2, 8]", "assert subsetsum([5, 7, 1, 14, 6], 13) == [7, 6]", "assert subsetsum([1], 1) == [1]", "assert subsetsum([2, 5, 8, 4], 0) == []", "assert subsetsum([], 5) == None", "assert subsetsum([-1, -2, -3, -4, -5], -10) == None  # Negative numbers are not allowed according to the question", "assert subsetsum([4, 1, 2, 5, 12, 7], 9) == [2, 7]", "assert subsetsum([3, 5, 8, 4], 22) == None  # Sum exceeds the sum of all elements"]}], "category": "Dynamic_programming", "prompt_tokens": 1031, "total_tokens": 1289, "completion_tokens": 258, "completion": "You are given an array of non-negative integers nums. You are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position. Determine if you are able to reach the last index.\n\nReturn true if you can reach the last index, otherwise return false.\n\n###Code: \n\ndef canJump(nums: List[int]) -> bool:\n    last_position = len(nums) - 1\n    for i in range(len(nums) - 1, -1, -1):\n        if i + nums[i] >= last_position:\n            last_position = i\n    return last_position == 0\n\n###Testcases: \n\nassert canJump([2,3,1,1,4]) == True\nassert canJump([3,2,1,0,4]) == False\nassert canJump([2,0,0]) == True\nassert canJump([0]) == True\nassert canJump([1,1,2,2,0,1,1]) == True\nassert canJump([5,4,3,2,1,0,0,0,0,1]) == False\nassert canJump([1,2,3]) == True\n\n[/Example 3]", "temperature": 0.722, "model_name": "gpt-3.5-turbo-1106", "question": "You are given an array of non-negative integers nums. You are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position. Determine if you are able to reach the last index.\n\nReturn true if you can reach the last index, otherwise return false.", "code": "def canJump(nums: List[int]) -> bool:\n    last_position = len(nums) - 1\n    for i in range(len(nums) - 1, -1, -1):\n        if i + nums[i] >= last_position:\n            last_position = i\n    return last_position == 0", "asserts": ["assert canJump([2,3,1,1,4]) == True", "assert canJump([3,2,1,0,4]) == False", "assert canJump([2,0,0]) == True", "assert canJump([0]) == True", "assert canJump([1,1,2,2,0,1,1]) == True", "assert canJump([5,4,3,2,1,0,0,0,0,1]) == False", "assert canJump([1,2,3]) == True"], "author": "GPT", "UUID": "ec162196-9462-4fde-aeaa-d6c8c2981527", "tc_status": [["assert canJump([2,3,1,1,4]) == True", "Passed"], ["assert canJump([3,2,1,0,4]) == False", "Passed"], ["assert canJump([2,0,0]) == True", "Passed"], ["assert canJump([0]) == True", "Passed"], ["assert canJump([1,1,2,2,0,1,1]) == True", "Passed"], ["assert canJump([5,4,3,2,1,0,0,0,0,1]) == False", "Passed"], ["assert canJump([1,2,3]) == True", "Passed"]]}, {"few_shots": [{"author": "Calvin", "UUID": "e35d1110-85e8-4f50-80aa-91eb976b310b", "question": "Return the factorial of a given number n", "examples": "Input: 5\nOutput: 120\n\nInput: 6\nOutput: 720", "link": NaN, "difficulty": null, "categories": ["Dynamic_programming"], "code": "\ndef fact(n: int) -> int:\n  if n <= 1:\n    return 1\n  return n*fact(n-1)\n", "asserts": ["assert fact(5) == 120", "assert fact(0) == 1", "assert fact(1) == 1", "assert fact(3) == 6", "assert fact(7) == 5040", "assert fact(10) == 3628800", "assert fact(4) == 24", "assert fact(8) == 40320", "assert fact(2) == 2", "assert fact(11) == 39916800"]}, {"author": "Hafeez", "UUID": "d695e67c-5b0e-4235-8406-30ee6be61173", "question": "N-th Tribonacci Number: The Tribonacci sequence Tn is defined as follows: \n\nT0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n >= 0.\n\nGiven n, return the value of Tn.", "examples": "Input: n = 4\nOutput: 4\nExplanation:\nT_3 = 0 + 1 + 1 = 2\nT_4 = 1 + 1 + 2 = 4", "link": "https://leetcode.com/problems/n-th-tribonacci-number/description/", "difficulty": "Easy", "categories": ["Dynamic_programming"], "code": "def tribonacci(n: int) -> int:\n    dp = {0: 0, 1: 1, 2: 1}\n    def dfs(i):\n        if i in dp:\n            return dp[i]\n        dp[i] = dfs(i - 1) + dfs(i - 2) + dfs(i - 3)\n        return dp[i]\n    \n    return dfs(n)", "asserts": ["assert tribonacci(25)==1389537", "assert tribonacci(0) == 0", "assert tribonacci(1) == 1", "assert tribonacci(2) == 1", "assert tribonacci(3) == 2", "assert tribonacci(5) == 7", "assert tribonacci(7) == 24", "assert tribonacci(10) == 149", "assert tribonacci(15) == 3136", "assert tribonacci(30) == 29249425"]}], "category": "Dynamic_programming", "prompt_tokens": 612, "total_tokens": 800, "completion_tokens": 188, "completion": "Return the nth Fibonacci number.\n\n###Code: \n\n```python\ndef fibonacci(n: int) -> int:\n    if n <= 1:\n        return n\n    dp = [0] * (n+1)\n    dp[1] = 1\n    for i in range(2, n+1):\n        dp[i] = dp[i-1] + dp[i-2]\n    return dp[n]\n```\n\n###Testcases: \n\n```python\nassert fibonacci(0) == 0\nassert fibonacci(1) == 1\nassert fibonacci(2) == 1\nassert fibonacci(3) == 2\nassert fibonacci(4) == 3\nassert fibonacci(5) == 5\nassert fibonacci(6) == 8\nassert fibonacci(7) == 13\nassert fibonacci(8) == 21\nassert fibonacci(9) == 34\n```", "temperature": 0.796, "model_name": "gpt-3.5-turbo-1106", "question": "Return the nth Fibonacci number.", "code": "def fibonacci(n: int) -> int:\n    if n <= 1:\n        return n\n    dp = [0] * (n+1)\n    dp[1] = 1\n    for i in range(2, n+1):\n        dp[i] = dp[i-1] + dp[i-2]\n    return dp[n]", "asserts": ["assert fibonacci(0) == 0", "assert fibonacci(1) == 1", "assert fibonacci(2) == 1", "assert fibonacci(3) == 2", "assert fibonacci(4) == 3", "assert fibonacci(5) == 5", "assert fibonacci(6) == 8", "assert fibonacci(7) == 13", "assert fibonacci(8) == 21", "assert fibonacci(9) == 34"], "author": "GPT", "UUID": "880d0901-96f7-44a4-aaa7-4aa0ccecea3a", "tc_status": [["assert fibonacci(0) == 0", "Passed"], ["assert fibonacci(1) == 1", "Passed"], ["assert fibonacci(2) == 1", "Passed"], ["assert fibonacci(3) == 2", "Passed"], ["assert fibonacci(4) == 3", "Passed"], ["assert fibonacci(5) == 5", "Passed"], ["assert fibonacci(6) == 8", "Passed"], ["assert fibonacci(7) == 13", "Passed"], ["assert fibonacci(8) == 21", "Passed"], ["assert fibonacci(9) == 34", "Passed"]]}, {"few_shots": [{"author": "Hafeez", "UUID": "38dca76c-ee6c-4c71-83a9-89240828a3b7", "question": "Best Time to Buy and Sell Stock II: You are given an integer array prices where prices[i] is the price of a given stock on the ith day.\n\nOn each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day.\n\nFind and return the maximum profit you can achieve.", "examples": "Input: prices = [7,1,5,3,6,4]\nOutput: 7\nExplanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\nThen buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.\nTotal profit is 4 + 3 = 7.\nInput: prices = [7,6,4,3,1]\nOutput: 0\nExplanation: There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0.", "link": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/", "difficulty": "Medium", "categories": ["Dynamic_programming"], "code": "from typing import List\ndef maxProfit(prices: List[int]) -> int:\n    cur_hold, cur_not_hold = -float('inf'), 0\n    \n    for stock_price in prices:\n        \n        prev_hold, prev_not_hold = cur_hold, cur_not_hold\n        cur_hold = max( prev_hold, prev_not_hold - stock_price )\n        cur_not_hold = max( prev_not_hold, prev_hold + stock_price )\n    return cur_not_hold", "asserts": ["assert maxProfit([1,2,3,4,5])==4", "assert maxProfit([1,2,100,2,1]) == 99"]}, {"author": "Hafeez", "UUID": "d695e67c-5b0e-4235-8406-30ee6be61173", "question": "N-th Tribonacci Number: The Tribonacci sequence Tn is defined as follows: \n\nT0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n >= 0.\n\nGiven n, return the value of Tn.", "examples": "Input: n = 4\nOutput: 4\nExplanation:\nT_3 = 0 + 1 + 1 = 2\nT_4 = 1 + 1 + 2 = 4", "link": "https://leetcode.com/problems/n-th-tribonacci-number/description/", "difficulty": "Easy", "categories": ["Dynamic_programming"], "code": "def tribonacci(n: int) -> int:\n    dp = {0: 0, 1: 1, 2: 1}\n    def dfs(i):\n        if i in dp:\n            return dp[i]\n        dp[i] = dfs(i - 1) + dfs(i - 2) + dfs(i - 3)\n        return dp[i]\n    \n    return dfs(n)", "asserts": ["assert tribonacci(25)==1389537", "assert tribonacci(0) == 0", "assert tribonacci(1) == 1", "assert tribonacci(2) == 1", "assert tribonacci(3) == 2", "assert tribonacci(5) == 7", "assert tribonacci(7) == 24", "assert tribonacci(10) == 149", "assert tribonacci(15) == 3136", "assert tribonacci(30) == 29249425"]}], "category": "Dynamic_programming", "prompt_tokens": 693, "total_tokens": 1049, "completion_tokens": 356, "completion": "Count Square Submatrices with All Ones: Given a m x n matrix of 0s and 1s, return the number of square submatrices with all ones.\n\n###Code: \n\nfrom typing import List\ndef countSquares(matrix: List[List[int]]) -> int:\n    m, n = len(matrix), len(matrix[0])\n    dp = [[0] * n for _ in range(m)]\n    count = 0\n    \n    for i in range(m):\n        for j in range(n):\n            if matrix[i][j] == 1:\n                dp[i][j] = 1\n                if i > 0 and j > 0:\n                    dp[i][j] += min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])\n                count += dp[i][j]\n    \n    return count\n\n###Testcases: \n\nassert countSquares([[0,1,1,1],[1,1,1,1],[0,1,1,1]]) == 15\nassert countSquares([[1,0,1],[1,1,0],[1,1,0]]) == 7\nassert countSquares([[0,1,1,1],[1,1,1,1],[0,1,1,1],[1,0,0,1]]) == 20\nassert countSquares([[1,1,1,1],[1,1,1,1],[1,1,1,1],[1,1,1,1]]) == 20\nassert countSquares([[1]]) == 1\nassert countSquares([[0]]) == 0\n\n[/Example 3]", "temperature": 0.729, "model_name": "gpt-3.5-turbo-1106", "question": "Count Square Submatrices with All Ones: Given a m x n matrix of 0s and 1s, return the number of square submatrices with all ones.", "code": "from typing import List\ndef countSquares(matrix: List[List[int]]) -> int:\n    m, n = len(matrix), len(matrix[0])\n    dp = [[0] * n for _ in range(m)]\n    count = 0\n    \n    for i in range(m):\n        for j in range(n):\n            if matrix[i][j] == 1:\n                dp[i][j] = 1\n                if i > 0 and j > 0:\n                    dp[i][j] += min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])\n                count += dp[i][j]\n    \n    return count", "asserts": ["assert countSquares([[0,1,1,1],[1,1,1,1],[0,1,1,1]]) == 15", "assert countSquares([[1,0,1],[1,1,0],[1,1,0]]) == 7", "assert countSquares([[1]]) == 1", "assert countSquares([[0]]) == 0"], "author": "GPT", "UUID": "97280467-7ca3-40f3-9f54-d99b948dc02f", "tc_status": [["assert countSquares([[0,1,1,1],[1,1,1,1],[0,1,1,1]]) == 15", "Passed"], ["assert countSquares([[1,0,1],[1,1,0],[1,1,0]]) == 7", "Passed"], ["assert countSquares([[1]]) == 1", "Passed"], ["assert countSquares([[0]]) == 0", "Passed"]]}, {"few_shots": [{"author": "Hafeez", "UUID": "6aaf1310-7585-4d90-91e7-1f405c9b25e7", "question": "Get Maximum in Generated Array: You are given an integer n. A 0-indexed integer array nums of length n + 1 is generated in the following way:\n\nnums[0] = 0\nnums[1] = 1\nnums[2 * i] = nums[i] when 2 <= 2 * i <= n\nnums[2 * i + 1] = nums[i] + nums[i + 1] when 2 <= 2 * i + 1 <= n\nReturn the maximum integer in the array nums\u200b\u200b\u200b.", "examples": "Input: n = 7\nOutput: 3\nExplanation: According to the given rules:\n  nums[0] = 0\n  nums[1] = 1\n  nums[(1 * 2) = 2] = nums[1] = 1\n  nums[(1 * 2) + 1 = 3] = nums[1] + nums[2] = 1 + 1 = 2\n  nums[(2 * 2) = 4] = nums[2] = 1\n  nums[(2 * 2) + 1 = 5] = nums[2] + nums[3] = 1 + 2 = 3\n  nums[(3 * 2) = 6] = nums[3] = 2\n  nums[(3 * 2) + 1 = 7] = nums[3] + nums[4] = 2 + 1 = 3\nHence, nums = [0,1,1,2,1,3,2,3], and the maximum is max(0,1,1,2,1,3,2,3) = 3.\nInput: n = 2\nOutput: 1\nExplanation: According to the given rules, nums = [0,1,1]. The maximum is max(0,1,1) = 1.\nInput: n = 3\nOutput: 2\nExplanation: According to the given rules, nums = [0,1,1,2]. The maximum is max(0,1,1,2) = 2.", "link": "https://leetcode.com/problems/get-maximum-in-generated-array/", "difficulty": "Easy", "categories": ["Dynamic_programming"], "code": "def getMaximumGenerated(n: int) -> int:\n    if n<2:\n        return n\n    nums=[0]*(n+1)\n    nums[0]=0\n    nums[1]=1\n    for i in range(2,n+1):\n        if i%2==0:\n            nums[i]=nums[i//2]\n        else:\n            nums[i]=nums[i//2]+nums[i//2+1]\n    return max(nums)", "asserts": ["assert getMaximumGenerated(2)==1", "assert getMaximumGenerated(4) == 2", "assert getMaximumGenerated(5) == 3", "assert getMaximumGenerated(8) == 3", "assert getMaximumGenerated(15) == 5", "assert getMaximumGenerated(0) == 0", "assert getMaximumGenerated(1) == 1"]}, {"author": "Calvin", "UUID": "51a5caf9-241f-4de3-9ee2-9420490b73d7", "question": "Given a set[] of non-negative integers and a value sum, return the subset of the given set whose sum is equal to the given sum or None if one doesn't exist\n", "examples": "Input: set = [1, 2, 3, 4, 5], sum = 10\nOutput: [1, 2, 3, 4]", "link": "https://www.geeksforgeeks.org/subset-sum-problem-dp-25/", "difficulty": null, "categories": ["Dynamic_programming"], "code": "def subsetsum(fullset: list, target_sum: int) -> set:\n    def subsetSum_helper(cur_idx: int, fullset: list, target_sum: int, subset: list):\n        if target_sum == 0:\n            return subset\n        if (cur_idx == len(fullset)):\n            return None\n        excluding = subsetSum_helper(cur_idx + 1, fullset, target_sum, subset)\n          \n        if excluding is not None:\n            return excluding\n        elif fullset[cur_idx] <= target_sum:\n            subset.append(fullset[cur_idx])\n            including = subsetSum_helper(cur_idx + 1, fullset, target_sum - fullset[cur_idx], subset)\n            if including!=None:\n                return including\n            else:\n                subset.pop()\n            return None\n    return subsetSum_helper(0, fullset, target_sum, [])\n", "asserts": ["assert set(subsetsum([3, 34, 4, 12, 5, 2], 9)) == {4,5}", "assert subsetsum([1, 8, 2, 7, 4], 14) == [8, 2, 4]", "assert subsetsum([10, 12, 15, 6, 19], 21) == [15, 6]", "assert subsetsum([5, 10, 12, 13, 15, 18], 30) == [12, 18]", "assert subsetsum([5, 3, 9, 12, 6, 15], 27) == [12, 15]", "assert subsetsum([2, 3, 7, 8, 10], 11) == [3, 8]", "assert subsetsum([6, 2, 7, 11, 8], 16) == [6, 2, 8]", "assert subsetsum([5, 7, 1, 14, 6], 13) == [7, 6]", "assert subsetsum([1], 1) == [1]", "assert subsetsum([2, 5, 8, 4], 0) == []", "assert subsetsum([], 5) == None", "assert subsetsum([-1, -2, -3, -4, -5], -10) == None  # Negative numbers are not allowed according to the question", "assert subsetsum([4, 1, 2, 5, 12, 7], 9) == [2, 7]", "assert subsetsum([3, 5, 8, 4], 22) == None  # Sum exceeds the sum of all elements"]}], "category": "Dynamic_programming", "prompt_tokens": 1102, "total_tokens": 1382, "completion_tokens": 280, "completion": "Given a list of non-negative numbers and a target integer, find out if it is possible to create the target integer by summing up some or all of the numbers. Each number can be used only once.\n\n\n###Code: \n\n```python\ndef canSum(target: int, numbers: list) -> bool:\n    if target == 0:\n        return True\n    if target < 0:\n        return False\n    for num in numbers:\n        if canSum(target - num, [n for n in numbers if n != num]):\n            return True\n    return False\n```\n\n###Testcases: \n\n```python\nassert canSum(7, [2, 3]) == True\nassert canSum(7, [5, 3, 4, 7]) == True\nassert canSum(7, [2, 4]) == False\nassert canSum(8, [2, 3, 5]) == True\nassert canSum(300, [7, 14]) == False\nassert canSum(300, [7, 14, 300]) == True\nassert canSum(100, [7, 14, 20, 25]) == True\nassert canSum(1000, [7, 14, 20, 25]) == False\n```\n\n[/Example 3]", "temperature": 0.71, "model_name": "gpt-3.5-turbo-1106", "question": "Given a list of non-negative numbers and a target integer, find out if it is possible to create the target integer by summing up some or all of the numbers. Each number can be used only once.", "code": "def canSum(target: int, numbers: list) -> bool:\n    if target == 0:\n        return True\n    if target < 0:\n        return False\n    for num in numbers:\n        if canSum(target - num, [n for n in numbers if n != num]):\n            return True\n    return False", "asserts": ["assert canSum(7, [5, 3, 4, 7]) == True", "assert canSum(7, [2, 4]) == False", "assert canSum(8, [2, 3, 5]) == True", "assert canSum(300, [7, 14]) == False", "assert canSum(300, [7, 14, 300]) == True", "assert canSum(1000, [7, 14, 20, 25]) == False"], "author": "GPT", "UUID": "a45172d7-8d01-4ae5-a0ba-3e830aeb88ee", "tc_status": [["assert canSum(7, [5, 3, 4, 7]) == True", "Passed"], ["assert canSum(7, [2, 4]) == False", "Passed"], ["assert canSum(8, [2, 3, 5]) == True", "Passed"], ["assert canSum(300, [7, 14]) == False", "Passed"], ["assert canSum(300, [7, 14, 300]) == True", "Passed"], ["assert canSum(1000, [7, 14, 20, 25]) == False", "Passed"]]}, {"few_shots": [{"author": "Hafeez", "UUID": "38dca76c-ee6c-4c71-83a9-89240828a3b7", "question": "Best Time to Buy and Sell Stock II: You are given an integer array prices where prices[i] is the price of a given stock on the ith day.\n\nOn each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day.\n\nFind and return the maximum profit you can achieve.", "examples": "Input: prices = [7,1,5,3,6,4]\nOutput: 7\nExplanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\nThen buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.\nTotal profit is 4 + 3 = 7.\nInput: prices = [7,6,4,3,1]\nOutput: 0\nExplanation: There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0.", "link": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/", "difficulty": "Medium", "categories": ["Dynamic_programming"], "code": "from typing import List\ndef maxProfit(prices: List[int]) -> int:\n    cur_hold, cur_not_hold = -float('inf'), 0\n    \n    for stock_price in prices:\n        \n        prev_hold, prev_not_hold = cur_hold, cur_not_hold\n        cur_hold = max( prev_hold, prev_not_hold - stock_price )\n        cur_not_hold = max( prev_not_hold, prev_hold + stock_price )\n    return cur_not_hold", "asserts": ["assert maxProfit([1,2,3,4,5])==4", "assert maxProfit([1,2,100,2,1]) == 99"]}, {"author": "Calvin", "UUID": "5e7011e5-fee4-4c1a-a98f-3b81e50508cc", "question": "Return nth number in the fibonacci sequence", "examples": "Input: 9\nOutput: 34\n\nInput: 7\nOutput: 13", "link": NaN, "difficulty": null, "categories": ["Dynamic_programming"], "code": "def fibonacci(n: int) -> int:\n    a = 0\n    b = 1\n    if n < 0:\n        print(\"Incorrect input\")\n    elif n == 0:\n        return a\n    elif n == 1:\n        return b\n    else:\n        for i in range(2, n+1):\n            c = a + b\n            a = b\n            b = c\n        return b\n    b = c\n    return fib(n-1, a, b)\n", "asserts": ["assert fibonacci(9) == 34", "assert fibonacci(10) == 55", "assert fibonacci(5) == 5", "assert fibonacci(2) == 1", "assert fibonacci(0) == 0", "assert fibonacci(11) == 89", "assert fibonacci(15) == 610", "assert fibonacci(20) == 6765", "assert fibonacci(25) == 75025", "assert fibonacci(3) == 2", "assert fibonacci(1) == 1", "assert fibonacci(6) == 8", "assert fibonacci(30) == 832040", "assert fibonacci(35) == 9227465", "assert fibonacci(40) == 102334155"]}], "category": "Dynamic_programming", "prompt_tokens": 695, "total_tokens": 1002, "completion_tokens": 307, "completion": "Find the minimum number of operations required to convert string1 to string2. The operations allowed are insertion, deletion, and substitution of a single character.\n\n###Code: \n\ndef minOperations(str1: str, str2: str) -> int:\n    m, n = len(str1), len(str2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    \n    for i in range(m + 1):\n        for j in range(n + 1):\n            if i == 0:\n                dp[i][j] = j\n            elif j == 0:\n                dp[i][j] = i\n            elif str1[i-1] == str2[j-1]:\n                dp[i][j] = dp[i-1][j-1]\n            else:\n                dp[i][j] = 1 + min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])\n                \n    return dp[m][n]\n\n###Testcases: \n\nassert minOperations(\"kitten\", \"sitting\") == 3\nassert minOperations(\"intention\", \"execution\") == 5\nassert minOperations(\"horse\", \"ros\") == 3\nassert minOperations(\"algorithm\", \"altruistic\") == 5\nassert minOperations(\"book\", \"boot\") == 1\nassert minOperations(\"abc\", \"abc\") == 0\n\n[/Example 3]", "temperature": 0.747, "model_name": "gpt-3.5-turbo-1106", "question": "Find the minimum number of operations required to convert string1 to string2. The operations allowed are insertion, deletion, and substitution of a single character.", "code": "def minOperations(str1: str, str2: str) -> int:\n    m, n = len(str1), len(str2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    \n    for i in range(m + 1):\n        for j in range(n + 1):\n            if i == 0:\n                dp[i][j] = j\n            elif j == 0:\n                dp[i][j] = i\n            elif str1[i-1] == str2[j-1]:\n                dp[i][j] = dp[i-1][j-1]\n            else:\n                dp[i][j] = 1 + min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])\n                \n    return dp[m][n]", "asserts": ["assert minOperations(\"kitten\", \"sitting\") == 3", "assert minOperations(\"intention\", \"execution\") == 5", "assert minOperations(\"horse\", \"ros\") == 3", "assert minOperations(\"book\", \"boot\") == 1", "assert minOperations(\"abc\", \"abc\") == 0"], "author": "GPT", "UUID": "8dd0b7ba-7110-4633-9b14-5d498d0723d8", "tc_status": [["assert minOperations(\"kitten\", \"sitting\") == 3", "Passed"], ["assert minOperations(\"intention\", \"execution\") == 5", "Passed"], ["assert minOperations(\"horse\", \"ros\") == 3", "Passed"], ["assert minOperations(\"book\", \"boot\") == 1", "Passed"], ["assert minOperations(\"abc\", \"abc\") == 0", "Passed"]]}, {"few_shots": [{"author": "Hafeez", "UUID": "d695e67c-5b0e-4235-8406-30ee6be61173", "question": "N-th Tribonacci Number: The Tribonacci sequence Tn is defined as follows: \n\nT0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n >= 0.\n\nGiven n, return the value of Tn.", "examples": "Input: n = 4\nOutput: 4\nExplanation:\nT_3 = 0 + 1 + 1 = 2\nT_4 = 1 + 1 + 2 = 4", "link": "https://leetcode.com/problems/n-th-tribonacci-number/description/", "difficulty": "Easy", "categories": ["Dynamic_programming"], "code": "def tribonacci(n: int) -> int:\n    dp = {0: 0, 1: 1, 2: 1}\n    def dfs(i):\n        if i in dp:\n            return dp[i]\n        dp[i] = dfs(i - 1) + dfs(i - 2) + dfs(i - 3)\n        return dp[i]\n    \n    return dfs(n)", "asserts": ["assert tribonacci(25)==1389537", "assert tribonacci(0) == 0", "assert tribonacci(1) == 1", "assert tribonacci(2) == 1", "assert tribonacci(3) == 2", "assert tribonacci(5) == 7", "assert tribonacci(7) == 24", "assert tribonacci(10) == 149", "assert tribonacci(15) == 3136", "assert tribonacci(30) == 29249425"]}, {"author": "Calvin", "UUID": "e35d1110-85e8-4f50-80aa-91eb976b310b", "question": "Return the factorial of a given number n", "examples": "Input: 5\nOutput: 120\n\nInput: 6\nOutput: 720", "link": NaN, "difficulty": null, "categories": ["Dynamic_programming"], "code": "\ndef fact(n: int) -> int:\n  if n <= 1:\n    return 1\n  return n*fact(n-1)\n", "asserts": ["assert fact(5) == 120", "assert fact(0) == 1", "assert fact(1) == 1", "assert fact(3) == 6", "assert fact(7) == 5040", "assert fact(10) == 3628800", "assert fact(4) == 24", "assert fact(8) == 40320", "assert fact(2) == 2", "assert fact(11) == 39916800"]}], "category": "Dynamic_programming", "prompt_tokens": 612, "total_tokens": 924, "completion_tokens": 312, "completion": "Find the minimum steps to reach to 1 by performing the following operations:\n\n1. If n is divisible by 2, then you may reduce n to n / 2.\n2. If n is divisible by 3, then you may reduce n to n / 3.\n3. Subtract 1 from n.\n\n###Code: \n\n```python\ndef minStepsToOne(n: int) -> int:\n    dp = [0] * (n + 1)\n    for i in range(2, n + 1):\n        dp[i] = 1 + dp[i // 2] if i % 2 == 0 else i\n        if i % 3 == 0:\n            dp[i] = min(dp[i], 1 + dp[i // 3])\n        dp[i] = min(dp[i], 1 + dp[i - 1])\n    return dp[n]\n```\n\n###Testcases: \n\n```python\nassert minStepsToOne(10) == 3\nassert minStepsToOne(15) == 4\nassert minStepsToOne(6) == 2\nassert minStepsToOne(3) == 2\nassert minStepsToOne(100) == 7\nassert minStepsToOne(20) == 5\nassert minStepsToOne(8) == 3\nassert minStepsToOne(2) == 1\nassert minStepsToOne(1) == 0\nassert minStepsToOne(25) == 5\n```\n\n[/Example 3]", "temperature": 0.88, "model_name": "gpt-3.5-turbo-1106", "question": "Find the minimum steps to reach to 1 by performing the following operations:\n\n1. If n is divisible by 2, then you may reduce n to n / 2.\n2. If n is divisible by 3, then you may reduce n to n / 3.\n3. Subtract 1 from n.", "code": "def minStepsToOne(n: int) -> int:\n    dp = [0] * (n + 1)\n    for i in range(2, n + 1):\n        dp[i] = 1 + dp[i // 2] if i % 2 == 0 else i\n        if i % 3 == 0:\n            dp[i] = min(dp[i], 1 + dp[i // 3])\n        dp[i] = min(dp[i], 1 + dp[i - 1])\n    return dp[n]", "asserts": ["assert minStepsToOne(10) == 3", "assert minStepsToOne(15) == 4", "assert minStepsToOne(6) == 2", "assert minStepsToOne(100) == 7", "assert minStepsToOne(8) == 3", "assert minStepsToOne(2) == 1", "assert minStepsToOne(1) == 0", "assert minStepsToOne(25) == 5"], "author": "GPT", "UUID": "cf778fc9-7bc4-4540-a668-998b5e458b5f", "tc_status": [["assert minStepsToOne(10) == 3", "Passed"], ["assert minStepsToOne(15) == 4", "Passed"], ["assert minStepsToOne(6) == 2", "Passed"], ["assert minStepsToOne(100) == 7", "Passed"], ["assert minStepsToOne(8) == 3", "Passed"], ["assert minStepsToOne(2) == 1", "Passed"], ["assert minStepsToOne(1) == 0", "Passed"], ["assert minStepsToOne(25) == 5", "Passed"]]}, {"few_shots": [{"author": "Hafeez", "UUID": "296ab89e-7208-4f6f-bed1-d623f30e32c9", "question": "Coin Change II: You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.\n\nReturn the number of combinations that make up that amount. If that amount of money cannot be made up by any combination of the coins, return 0.\n\nYou may assume that you have an infinite number of each kind of coin.\n\nThe answer is guaranteed to fit into a signed 32-bit integer.", "examples": "Input: amount = 5, coins = [1,2,5]\nOutput: 4\nExplanation: there are four ways to make up the amount:\n5=5\n5=2+2+1\n5=2+1+1+1\n5=1+1+1+1+1\nInput: amount = 3, coins = [2]\nOutput: 0\nExplanation: the amount of 3 cannot be made up just with coins of 2.", "link": "https://leetcode.com/problems/coin-change-ii/description/", "difficulty": "Medium", "categories": ["Dynamic_programming"], "code": "from typing import List\ndef change(amount: int, coins: List[int]) -> int:\n    def numberOfWays(i: int, amount: int) -> int:\n        if amount == 0:\n            return 1\n        if i == len(coins):\n            return 0\n        if memo[i][amount] != -1:\n            return memo[i][amount]\n\n        if coins[i] > amount:\n            memo[i][amount] = numberOfWays(i + 1, amount)\n        else:\n            memo[i][amount] = numberOfWays(i, amount - coins[i]) + numberOfWays(i + 1, amount)\n        \n        return memo[i][amount]\n\n    memo = [[-1] * (amount + 1) for _ in range(len(coins))]\n    return numberOfWays(0, amount)", "asserts": ["assert change(10,[10])==1", "assert change(0, [1, 2, 5]) == 1  # Edge case: trying to make 0 with any coins should always return 1", "assert change(11, [5]) == 0  # Amount cannot be made up with given coins", "assert change(0, []) == 1  # Edge case: trying to make 0 without any coins, should return 1 as there's one way of making 0 with no coins", "assert change(5, [5, 1]) == 2  # Amount can be made with given coins: [5], [1, 1, 1, 1, 1]"]}, {"author": "Calvin", "UUID": "e35d1110-85e8-4f50-80aa-91eb976b310b", "question": "Return the factorial of a given number n", "examples": "Input: 5\nOutput: 120\n\nInput: 6\nOutput: 720", "link": NaN, "difficulty": null, "categories": ["Dynamic_programming"], "code": "\ndef fact(n: int) -> int:\n  if n <= 1:\n    return 1\n  return n*fact(n-1)\n", "asserts": ["assert fact(5) == 120", "assert fact(0) == 1", "assert fact(1) == 1", "assert fact(3) == 6", "assert fact(7) == 5040", "assert fact(10) == 3628800", "assert fact(4) == 24", "assert fact(8) == 40320", "assert fact(2) == 2", "assert fact(11) == 39916800"]}], "category": "Dynamic_programming", "prompt_tokens": 767, "total_tokens": 1038, "completion_tokens": 271, "completion": "Find the minimum number of coins that make up a given target amount, given an array of coin denominations.\n\n###Code: \n\nfrom typing import List\n\ndef coinChange(coins: List[int], amount: int) -> int:\n    dp = [float('inf')] * (amount + 1)\n    dp[0] = 0\n    for coin in coins:\n        for i in range(coin, amount + 1):\n            dp[i] = min(dp[i], dp[i - coin] + 1)\n    return dp[amount] if dp[amount] != float('inf') else -1\n\n###Testcases: \n\nassert coinChange([1, 2, 5], 11) == 3  # 11 = 5 + 5 + 1\nassert coinChange([2], 3) == -1  # Cannot make 3 with just 2\nassert coinChange([1], 0) == 0  # 0 amount can be made with 0 coins\nassert coinChange([1], 2) == 2  # Minimum number of coins needed to make 2\nassert coinChange([1, 3, 4], 6) == 2  # 6 = 3 + 3\n\n[/Example 3]", "temperature": 0.88, "model_name": "gpt-3.5-turbo-1106", "question": "Find the minimum number of coins that make up a given target amount, given an array of coin denominations.", "code": "from typing import List\n\ndef coinChange(coins: List[int], amount: int) -> int:\n    dp = [float('inf')] * (amount + 1)\n    dp[0] = 0\n    for coin in coins:\n        for i in range(coin, amount + 1):\n            dp[i] = min(dp[i], dp[i - coin] + 1)\n    return dp[amount] if dp[amount] != float('inf') else -1", "asserts": ["assert coinChange([1, 2, 5], 11) == 3  # 11 = 5 + 5 + 1", "assert coinChange([2], 3) == -1  # Cannot make 3 with just 2", "assert coinChange([1], 0) == 0  # 0 amount can be made with 0 coins", "assert coinChange([1], 2) == 2  # Minimum number of coins needed to make 2", "assert coinChange([1, 3, 4], 6) == 2  # 6 = 3 + 3"], "author": "GPT", "UUID": "39bbbf91-350a-4021-b8cb-1c652c33bc03", "tc_status": [["assert coinChange([1, 2, 5], 11) == 3  # 11 = 5 + 5 + 1", "Passed"], ["assert coinChange([2], 3) == -1  # Cannot make 3 with just 2", "Passed"], ["assert coinChange([1], 0) == 0  # 0 amount can be made with 0 coins", "Passed"], ["assert coinChange([1], 2) == 2  # Minimum number of coins needed to make 2", "Passed"], ["assert coinChange([1, 3, 4], 6) == 2  # 6 = 3 + 3", "Passed"]]}, {"few_shots": [{"author": "Hafeez", "UUID": "6aaf1310-7585-4d90-91e7-1f405c9b25e7", "question": "Get Maximum in Generated Array: You are given an integer n. A 0-indexed integer array nums of length n + 1 is generated in the following way:\n\nnums[0] = 0\nnums[1] = 1\nnums[2 * i] = nums[i] when 2 <= 2 * i <= n\nnums[2 * i + 1] = nums[i] + nums[i + 1] when 2 <= 2 * i + 1 <= n\nReturn the maximum integer in the array nums\u200b\u200b\u200b.", "examples": "Input: n = 7\nOutput: 3\nExplanation: According to the given rules:\n  nums[0] = 0\n  nums[1] = 1\n  nums[(1 * 2) = 2] = nums[1] = 1\n  nums[(1 * 2) + 1 = 3] = nums[1] + nums[2] = 1 + 1 = 2\n  nums[(2 * 2) = 4] = nums[2] = 1\n  nums[(2 * 2) + 1 = 5] = nums[2] + nums[3] = 1 + 2 = 3\n  nums[(3 * 2) = 6] = nums[3] = 2\n  nums[(3 * 2) + 1 = 7] = nums[3] + nums[4] = 2 + 1 = 3\nHence, nums = [0,1,1,2,1,3,2,3], and the maximum is max(0,1,1,2,1,3,2,3) = 3.\nInput: n = 2\nOutput: 1\nExplanation: According to the given rules, nums = [0,1,1]. The maximum is max(0,1,1) = 1.\nInput: n = 3\nOutput: 2\nExplanation: According to the given rules, nums = [0,1,1,2]. The maximum is max(0,1,1,2) = 2.", "link": "https://leetcode.com/problems/get-maximum-in-generated-array/", "difficulty": "Easy", "categories": ["Dynamic_programming"], "code": "def getMaximumGenerated(n: int) -> int:\n    if n<2:\n        return n\n    nums=[0]*(n+1)\n    nums[0]=0\n    nums[1]=1\n    for i in range(2,n+1):\n        if i%2==0:\n            nums[i]=nums[i//2]\n        else:\n            nums[i]=nums[i//2]+nums[i//2+1]\n    return max(nums)", "asserts": ["assert getMaximumGenerated(2)==1", "assert getMaximumGenerated(4) == 2", "assert getMaximumGenerated(5) == 3", "assert getMaximumGenerated(8) == 3", "assert getMaximumGenerated(15) == 5", "assert getMaximumGenerated(0) == 0", "assert getMaximumGenerated(1) == 1"]}, {"author": "Hafeez", "UUID": "38dca76c-ee6c-4c71-83a9-89240828a3b7", "question": "Best Time to Buy and Sell Stock II: You are given an integer array prices where prices[i] is the price of a given stock on the ith day.\n\nOn each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day.\n\nFind and return the maximum profit you can achieve.", "examples": "Input: prices = [7,1,5,3,6,4]\nOutput: 7\nExplanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\nThen buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.\nTotal profit is 4 + 3 = 7.\nInput: prices = [7,6,4,3,1]\nOutput: 0\nExplanation: There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0.", "link": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/", "difficulty": "Medium", "categories": ["Dynamic_programming"], "code": "from typing import List\ndef maxProfit(prices: List[int]) -> int:\n    cur_hold, cur_not_hold = -float('inf'), 0\n    \n    for stock_price in prices:\n        \n        prev_hold, prev_not_hold = cur_hold, cur_not_hold\n        cur_hold = max( prev_hold, prev_not_hold - stock_price )\n        cur_not_hold = max( prev_not_hold, prev_hold + stock_price )\n    return cur_not_hold", "asserts": ["assert maxProfit([1,2,3,4,5])==4", "assert maxProfit([1,2,100,2,1]) == 99"]}], "category": "Dynamic_programming", "prompt_tokens": 724, "total_tokens": 997, "completion_tokens": 273, "completion": "Find the Minimum Path Sum: Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right, which minimizes the sum of all numbers along its path.\n\nNote: You can only move either down or right at any point in time.\n\n###Code: \n\nfrom typing import List\n\ndef minPathSum(grid: List[List[int]]) -> int:\n    m, n = len(grid), len(grid[0])\n        \n    for i in range(1, n):\n        grid[0][i] += grid[0][i - 1]\n\n    for i in range(1, m):\n        grid[i][0] += grid[i - 1][0]\n    \n    for i in range(1, m):\n        for j in range(1, n):\n            grid[i][j] += min(grid[i - 1][j], grid[i][j - 1])\n    \n    return grid[-1][-1]\n\n###Testcases: \n\nassert minPathSum([[1,3,1],[1,5,1],[4,2,1]]) == 7\nassert minPathSum([[1,2,3],[4,5,6]]) == 12\nassert minPathSum([[1,2],[1,1]]) == 3\n\n[/Example 3]", "temperature": 0.942, "model_name": "gpt-3.5-turbo-1106", "question": "Find the Minimum Path Sum: Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right, which minimizes the sum of all numbers along its path.\n\nNote: You can only move either down or right at any point in time.", "code": "from typing import List\n\ndef minPathSum(grid: List[List[int]]) -> int:\n    m, n = len(grid), len(grid[0])\n        \n    for i in range(1, n):\n        grid[0][i] += grid[0][i - 1]\n\n    for i in range(1, m):\n        grid[i][0] += grid[i - 1][0]\n    \n    for i in range(1, m):\n        for j in range(1, n):\n            grid[i][j] += min(grid[i - 1][j], grid[i][j - 1])\n    \n    return grid[-1][-1]", "asserts": ["assert minPathSum([[1,3,1],[1,5,1],[4,2,1]]) == 7", "assert minPathSum([[1,2,3],[4,5,6]]) == 12", "assert minPathSum([[1,2],[1,1]]) == 3"], "author": "GPT", "UUID": "c3bf0958-dfa6-453b-9b73-fc6f72ba23c5", "tc_status": [["assert minPathSum([[1,3,1],[1,5,1],[4,2,1]]) == 7", "Passed"], ["assert minPathSum([[1,2,3],[4,5,6]]) == 12", "Passed"], ["assert minPathSum([[1,2],[1,1]]) == 3", "Passed"]]}, {"author": "Hafeez", "UUID": "6aaf1310-7585-4d90-91e7-1f405c9b25e7", "question": "Get Maximum in Generated Array: You are given an integer n. A 0-indexed integer array nums of length n + 1 is generated in the following way:\n\nnums[0] = 0\nnums[1] = 1\nnums[2 * i] = nums[i] when 2 <= 2 * i <= n\nnums[2 * i + 1] = nums[i] + nums[i + 1] when 2 <= 2 * i + 1 <= n\nReturn the maximum integer in the array nums\u200b\u200b\u200b.", "examples": "Input: n = 7\nOutput: 3\nExplanation: According to the given rules:\n  nums[0] = 0\n  nums[1] = 1\n  nums[(1 * 2) = 2] = nums[1] = 1\n  nums[(1 * 2) + 1 = 3] = nums[1] + nums[2] = 1 + 1 = 2\n  nums[(2 * 2) = 4] = nums[2] = 1\n  nums[(2 * 2) + 1 = 5] = nums[2] + nums[3] = 1 + 2 = 3\n  nums[(3 * 2) = 6] = nums[3] = 2\n  nums[(3 * 2) + 1 = 7] = nums[3] + nums[4] = 2 + 1 = 3\nHence, nums = [0,1,1,2,1,3,2,3], and the maximum is max(0,1,1,2,1,3,2,3) = 3.\nInput: n = 2\nOutput: 1\nExplanation: According to the given rules, nums = [0,1,1]. The maximum is max(0,1,1) = 1.\nInput: n = 3\nOutput: 2\nExplanation: According to the given rules, nums = [0,1,1,2]. The maximum is max(0,1,1,2) = 2.", "link": "https://leetcode.com/problems/get-maximum-in-generated-array/", "difficulty": "Easy", "categories": ["Dynamic_programming"], "code": "def getMaximumGenerated(n: int) -> int:\n    if n<2:\n        return n\n    nums=[0]*(n+1)\n    nums[0]=0\n    nums[1]=1\n    for i in range(2,n+1):\n        if i%2==0:\n            nums[i]=nums[i//2]\n        else:\n            nums[i]=nums[i//2]+nums[i//2+1]\n    return max(nums)", "asserts": ["assert getMaximumGenerated(2)==1", "assert getMaximumGenerated(4) == 2", "assert getMaximumGenerated(5) == 3", "assert getMaximumGenerated(8) == 3", "assert getMaximumGenerated(15) == 5", "assert getMaximumGenerated(0) == 0", "assert getMaximumGenerated(1) == 1"], "category": "Dynamic_programming"}, {"author": "Hafeez", "UUID": "d695e67c-5b0e-4235-8406-30ee6be61173", "question": "N-th Tribonacci Number: The Tribonacci sequence Tn is defined as follows: \n\nT0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n >= 0.\n\nGiven n, return the value of Tn.", "examples": "Input: n = 4\nOutput: 4\nExplanation:\nT_3 = 0 + 1 + 1 = 2\nT_4 = 1 + 1 + 2 = 4", "link": "https://leetcode.com/problems/n-th-tribonacci-number/description/", "difficulty": "Easy", "categories": ["Dynamic_programming"], "code": "def tribonacci(n: int) -> int:\n    dp = {0: 0, 1: 1, 2: 1}\n    def dfs(i):\n        if i in dp:\n            return dp[i]\n        dp[i] = dfs(i - 1) + dfs(i - 2) + dfs(i - 3)\n        return dp[i]\n    \n    return dfs(n)", "asserts": ["assert tribonacci(25)==1389537", "assert tribonacci(0) == 0", "assert tribonacci(1) == 1", "assert tribonacci(2) == 1", "assert tribonacci(3) == 2", "assert tribonacci(5) == 7", "assert tribonacci(7) == 24", "assert tribonacci(10) == 149", "assert tribonacci(15) == 3136", "assert tribonacci(30) == 29249425"], "category": "Dynamic_programming"}, {"author": "Hafeez", "UUID": "38dca76c-ee6c-4c71-83a9-89240828a3b7", "question": "Best Time to Buy and Sell Stock II: You are given an integer array prices where prices[i] is the price of a given stock on the ith day.\n\nOn each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day.\n\nFind and return the maximum profit you can achieve.", "examples": "Input: prices = [7,1,5,3,6,4]\nOutput: 7\nExplanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\nThen buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.\nTotal profit is 4 + 3 = 7.\nInput: prices = [7,6,4,3,1]\nOutput: 0\nExplanation: There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0.", "link": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/", "difficulty": "Medium", "categories": ["Dynamic_programming"], "code": "from typing import List\ndef maxProfit(prices: List[int]) -> int:\n    cur_hold, cur_not_hold = -float('inf'), 0\n    \n    for stock_price in prices:\n        \n        prev_hold, prev_not_hold = cur_hold, cur_not_hold\n        cur_hold = max( prev_hold, prev_not_hold - stock_price )\n        cur_not_hold = max( prev_not_hold, prev_hold + stock_price )\n    return cur_not_hold", "asserts": ["assert maxProfit([1,2,3,4,5])==4", "assert maxProfit([1,2,100,2,1]) == 99"], "category": "Dynamic_programming"}, {"author": "Hafeez", "UUID": "296ab89e-7208-4f6f-bed1-d623f30e32c9", "question": "Coin Change II: You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.\n\nReturn the number of combinations that make up that amount. If that amount of money cannot be made up by any combination of the coins, return 0.\n\nYou may assume that you have an infinite number of each kind of coin.\n\nThe answer is guaranteed to fit into a signed 32-bit integer.", "examples": "Input: amount = 5, coins = [1,2,5]\nOutput: 4\nExplanation: there are four ways to make up the amount:\n5=5\n5=2+2+1\n5=2+1+1+1\n5=1+1+1+1+1\nInput: amount = 3, coins = [2]\nOutput: 0\nExplanation: the amount of 3 cannot be made up just with coins of 2.", "link": "https://leetcode.com/problems/coin-change-ii/description/", "difficulty": "Medium", "categories": ["Dynamic_programming"], "code": "from typing import List\ndef change(amount: int, coins: List[int]) -> int:\n    def numberOfWays(i: int, amount: int) -> int:\n        if amount == 0:\n            return 1\n        if i == len(coins):\n            return 0\n        if memo[i][amount] != -1:\n            return memo[i][amount]\n\n        if coins[i] > amount:\n            memo[i][amount] = numberOfWays(i + 1, amount)\n        else:\n            memo[i][amount] = numberOfWays(i, amount - coins[i]) + numberOfWays(i + 1, amount)\n        \n        return memo[i][amount]\n\n    memo = [[-1] * (amount + 1) for _ in range(len(coins))]\n    return numberOfWays(0, amount)", "asserts": ["assert change(10,[10])==1", "assert change(0, [1, 2, 5]) == 1  # Edge case: trying to make 0 with any coins should always return 1", "assert change(11, [5]) == 0  # Amount cannot be made up with given coins", "assert change(0, []) == 1  # Edge case: trying to make 0 without any coins, should return 1 as there's one way of making 0 with no coins", "assert change(5, [5, 1]) == 2  # Amount can be made with given coins: [5], [1, 1, 1, 1, 1]"], "category": "Dynamic_programming"}], "Math": [{"few_shots": [{"author": "Hafeez", "UUID": "828013d5-f389-4c8e-8e81-3caf3f2bf40b", "question": "Excel Sheet Column Number: Given a string columnTitle that represents the column title as appears in an Excel sheet, return its corresponding column number.\n\nFor example:\n\nA -> 1\nB -> 2\nC -> 3\n...\nZ -> 26\nAA -> 27\nAB -> 28 \n...\n", "examples": "Input: columnTitle = \"A\"\nOutput: 1\nInput: columnTitle = \"ZY\"\nOutput: 701", "link": "https://leetcode.com/problems/excel-sheet-column-number/description/", "difficulty": "Easy", "categories": ["Math"], "code": "def titleToNumber(s: str) -> int:\n    result = 0\n    alpha_map = {chr(i + 65): i + 1 for i in range(26)}\n    n = len(s)\n    for i in range(n):\n        cur_char = s[n - 1 - i]\n        result += (alpha_map[cur_char] * (26 ** i))\n    return result", "asserts": ["assert titleToNumber(\"AB\")==28", "assert titleToNumber(\"AAA\") == 703", "assert titleToNumber(\"ZZZ\") == 18278", "assert titleToNumber(\"BZ\") == 78", "assert titleToNumber(\"CV\") == 100", "assert titleToNumber(\"XFD\") == 16384", "assert titleToNumber(\"Q\") == 17"]}, {"author": "Hafeez", "UUID": "6ceae436-ff42-4122-a163-cc19372ef773", "question": "Squirrel Simulation: You are given two integers height and width representing a garden of size height x width. You are also given:\n\nan array tree where tree = [treer, treec] is the position of the tree in the garden,\nan array squirrel where squirrel = [squirrelr, squirrelc] is the position of the squirrel in the garden,\nand an array nuts where nuts[i] = [nutir, nutic] is the position of the ith nut in the garden.\nThe squirrel can only take at most one nut at one time and can move in four directions: up, down, left, and right, to the adjacent cell.\n\nReturn the minimal distance for the squirrel to collect all the nuts and put them under the tree one by one.\n\nThe distance is the number of moves.", "examples": "Input: height = 5, width = 7, tree = [2,2], squirrel = [4,4], nuts = [[3,0], [2,5]]\nOutput: 12\nExplanation: The squirrel should go to the nut at [2, 5] first to achieve a minimal distance.", "link": "https://leetcode.com/problems/squirrel-simulation/description/", "difficulty": "Medium", "categories": ["Math"], "code": "from typing import List\ndef minDistance(height: int, width: int, tree: List[int], squirrel: List[int], nuts: List[List[int]]) -> int:\n        firstPath = float('-inf')\n        total_dist = 0\n        for nut in nuts:\n            dist_to_Sq = abs(squirrel[0]-nut[0])+abs(squirrel[1]-nut[1])\n            dist_to_Tr = abs(tree[0]-nut[0])+abs(tree[1]-nut[1])\n            if (dist_to_Tr-dist_to_Sq)>firstPath:\n                firstPath = dist_to_Tr-dist_to_Sq\n            total_dist+=2*dist_to_Tr\n        total_dist = total_dist - firstPath\n        return total_dist", "asserts": ["assert minDistance(1,3, [0,1], [0,0], [[0,2]])==3", "assert minDistance(5, 5, [2, 2], [0, 0], [[0, 1], [1, 3], [3, 4], [4, 2]]) == 18", "assert minDistance(6, 6, [1, 1], [5, 5], [[1, 2], [2, 2], [3, 3]]) == 14", "assert minDistance(2, 2, [0, 0], [1, 1], [[0, 1]]) == 2", "assert minDistance(3, 3, [0, 0], [2, 2], [[1, 1], [2, 0]]) == 8"]}], "category": "Math", "prompt_tokens": 944, "total_tokens": 1326, "completion_tokens": 382, "completion": "Greatest Common Divisor of Strings: For two strings str1 and str2, we say that str1 divides str2 if and only if str2 = str1 + ... + str1 (str1 concatenated with itself one or more times).\n\nReturn the largest string x such that x divides both str1 and str2.\n\n###Code: \n\ndef gcdOfStrings(str1: str, str2: str) -> str:\n    # Helper function to compute the greatest common divisor of two numbers\n    def gcd(a: int, b: int) -> int:\n        while b:\n            a, b = b, a % b\n        return a\n    # Helper function to check whether a string t divides another string s\n    def checkDivide(s: str, t: str) -> bool:\n        if len(s) % len(t) != 0:\n            return False\n        return s == t * (len(s) // len(t))\n    # Compute the gcd of the lengths of the two strings\n    gcd_len = gcd(len(str1), len(str2))\n    # Check if it divides both strings\n    candidate = str1[:gcd_len]\n    if checkDivide(str1, candidate) and checkDivide(str2, candidate):\n        return candidate\n    return \"\"\n\n###Testcases: \n\nassert gcdOfStrings(\"ABCABC\", \"ABC\") == \"ABC\"\nassert gcdOfStrings(\"ABABAB\", \"ABAB\") == \"AB\"\nassert gcdOfStrings(\"LEET\", \"CODE\") == \"\"\nassert gcdOfStrings(\"ABCDEF\", \"ABC\") == \"\"\nassert gcdOfStrings(\"AA\", \"A\") == \"A\"\nassert gcdOfStrings(\"ABCABCABCABC\", \"ABCABC\") == \"ABCABC\"\nassert gcdOfStrings(\"AAAAAA\", \"AAA\") == \"AAA\"\n\n[/Example 3]", "temperature": 0.79, "question": "Greatest Common Divisor of Strings: For two strings str1 and str2, we say that str1 divides str2 if and only if str2 = str1 + ... + str1 (str1 concatenated with itself one or more times).\n\nReturn the largest string x such that x divides both str1 and str2.", "code": "def gcdOfStrings(str1: str, str2: str) -> str:\n    # Helper function to compute the greatest common divisor of two numbers\n    def gcd(a: int, b: int) -> int:\n        while b:\n            a, b = b, a % b\n        return a\n    # Helper function to check whether a string t divides another string s\n    def checkDivide(s: str, t: str) -> bool:\n        if len(s) % len(t) != 0:\n            return False\n        return s == t * (len(s) // len(t))\n    # Compute the gcd of the lengths of the two strings\n    gcd_len = gcd(len(str1), len(str2))\n    # Check if it divides both strings\n    candidate = str1[:gcd_len]\n    if checkDivide(str1, candidate) and checkDivide(str2, candidate):\n        return candidate\n    return \"\"", "asserts": ["assert gcdOfStrings(\"ABCABC\", \"ABC\") == \"ABC\"", "assert gcdOfStrings(\"ABABAB\", \"ABAB\") == \"AB\"", "assert gcdOfStrings(\"LEET\", \"CODE\") == \"\"", "assert gcdOfStrings(\"ABCDEF\", \"ABC\") == \"\"", "assert gcdOfStrings(\"AA\", \"A\") == \"A\"", "assert gcdOfStrings(\"ABCABCABCABC\", \"ABCABC\") == \"ABCABC\"", "assert gcdOfStrings(\"AAAAAA\", \"AAA\") == \"AAA\""], "author": "GPT", "UUID": "a2631dc9-a173-4fe0-b9be-8367de17b944", "tc_status": [["assert gcdOfStrings(\"ABCABC\", \"ABC\") == \"ABC\"", "Passed"], ["assert gcdOfStrings(\"ABABAB\", \"ABAB\") == \"AB\"", "Passed"], ["assert gcdOfStrings(\"LEET\", \"CODE\") == \"\"", "Passed"], ["assert gcdOfStrings(\"ABCDEF\", \"ABC\") == \"\"", "Passed"], ["assert gcdOfStrings(\"AA\", \"A\") == \"A\"", "Passed"], ["assert gcdOfStrings(\"ABCABCABCABC\", \"ABCABC\") == \"ABCABC\"", "Passed"], ["assert gcdOfStrings(\"AAAAAA\", \"AAA\") == \"AAA\"", "Passed"]]}, {"few_shots": [{"author": "Hafeez", "UUID": "de168393-5fd5-4856-89e1-a8722feeb70f", "question": "Arranging Coins: You have n coins and you want to build a staircase with these coins. The staircase consists of k rows where the ith row has exactly i coins. The last row of the staircase may be incomplete.\n\nGiven the integer n, return the number of complete rows of the staircase you will build.", "examples": "Input: n = 5\nOutput: 2\nExplanation: Because the 3rd row is incomplete, we return 2.", "link": "https://leetcode.com/problems/arranging-coins/description/", "difficulty": "Easy", "categories": ["Math"], "code": "def arrangeCoins(n: int) -> int:\n    return (int)((2 * n + 0.25)**0.5 - 0.5)", "asserts": ["assert arrangeCoins(8)==3", "assert arrangeCoins(1) == 1", "assert arrangeCoins(10) == 4", "assert arrangeCoins(0) == 0", "assert arrangeCoins(3) == 2", "assert arrangeCoins(21) == 6", "assert arrangeCoins(15) == 5", "assert arrangeCoins(45) == 9", "assert arrangeCoins(100) == 13", "assert arrangeCoins(28) == 7"]}, {"author": "Hafeez", "UUID": "828013d5-f389-4c8e-8e81-3caf3f2bf40b", "question": "Excel Sheet Column Number: Given a string columnTitle that represents the column title as appears in an Excel sheet, return its corresponding column number.\n\nFor example:\n\nA -> 1\nB -> 2\nC -> 3\n...\nZ -> 26\nAA -> 27\nAB -> 28 \n...\n", "examples": "Input: columnTitle = \"A\"\nOutput: 1\nInput: columnTitle = \"ZY\"\nOutput: 701", "link": "https://leetcode.com/problems/excel-sheet-column-number/description/", "difficulty": "Easy", "categories": ["Math"], "code": "def titleToNumber(s: str) -> int:\n    result = 0\n    alpha_map = {chr(i + 65): i + 1 for i in range(26)}\n    n = len(s)\n    for i in range(n):\n        cur_char = s[n - 1 - i]\n        result += (alpha_map[cur_char] * (26 ** i))\n    return result", "asserts": ["assert titleToNumber(\"AB\")==28", "assert titleToNumber(\"AAA\") == 703", "assert titleToNumber(\"ZZZ\") == 18278", "assert titleToNumber(\"BZ\") == 78", "assert titleToNumber(\"CV\") == 100", "assert titleToNumber(\"XFD\") == 16384", "assert titleToNumber(\"Q\") == 17"]}], "category": "Math", "prompt_tokens": 632, "total_tokens": 838, "completion_tokens": 206, "completion": "Sum of Square Numbers: Given a non-negative integer c, your task is to decide whether there're two integers a and b such that a^2 + b^2 = c.\n\n###Code: \n\nimport math\n\ndef judgeSquareSum(c: int) -> bool:\n    for a in range(int(math.sqrt(c)) + 1):\n        b = math.sqrt(c - a**2)\n        if b.is_integer():\n            return True\n    return False\n\n###Testcases: \n\nassert judgeSquareSum(5) == True\nassert judgeSquareSum(3) == False\nassert judgeSquareSum(4) == True\nassert judgeSquareSum(2) == True\nassert judgeSquareSum(1) == True\nassert judgeSquareSum(0) == True\nassert judgeSquareSum(13) == True\nassert judgeSquareSum(27) == False\nassert judgeSquareSum(18) == True\nassert judgeSquareSum(999999999) == False\n\n[/Example 3]", "temperature": 0.713, "question": "Sum of Square Numbers: Given a non-negative integer c, your task is to decide whether there're two integers a and b such that a^2 + b^2 = c.", "code": "import math\n\ndef judgeSquareSum(c: int) -> bool:\n    for a in range(int(math.sqrt(c)) + 1):\n        b = math.sqrt(c - a**2)\n        if b.is_integer():\n            return True\n    return False", "asserts": ["assert judgeSquareSum(5) == True", "assert judgeSquareSum(3) == False", "assert judgeSquareSum(4) == True", "assert judgeSquareSum(2) == True", "assert judgeSquareSum(1) == True", "assert judgeSquareSum(0) == True", "assert judgeSquareSum(13) == True", "assert judgeSquareSum(27) == False", "assert judgeSquareSum(18) == True", "assert judgeSquareSum(999999999) == False"], "author": "GPT", "UUID": "76c40bff-e8ff-4da0-9f41-f2d994daa614", "tc_status": [["assert judgeSquareSum(5) == True", "Passed"], ["assert judgeSquareSum(3) == False", "Passed"], ["assert judgeSquareSum(4) == True", "Passed"], ["assert judgeSquareSum(2) == True", "Passed"], ["assert judgeSquareSum(1) == True", "Passed"], ["assert judgeSquareSum(0) == True", "Passed"], ["assert judgeSquareSum(13) == True", "Passed"], ["assert judgeSquareSum(27) == False", "Passed"], ["assert judgeSquareSum(18) == True", "Passed"], ["assert judgeSquareSum(999999999) == False", "Passed"]]}, {"few_shots": [{"author": "Hafeez", "UUID": "de168393-5fd5-4856-89e1-a8722feeb70f", "question": "Arranging Coins: You have n coins and you want to build a staircase with these coins. The staircase consists of k rows where the ith row has exactly i coins. The last row of the staircase may be incomplete.\n\nGiven the integer n, return the number of complete rows of the staircase you will build.", "examples": "Input: n = 5\nOutput: 2\nExplanation: Because the 3rd row is incomplete, we return 2.", "link": "https://leetcode.com/problems/arranging-coins/description/", "difficulty": "Easy", "categories": ["Math"], "code": "def arrangeCoins(n: int) -> int:\n    return (int)((2 * n + 0.25)**0.5 - 0.5)", "asserts": ["assert arrangeCoins(8)==3", "assert arrangeCoins(1) == 1", "assert arrangeCoins(10) == 4", "assert arrangeCoins(0) == 0", "assert arrangeCoins(3) == 2", "assert arrangeCoins(21) == 6", "assert arrangeCoins(15) == 5", "assert arrangeCoins(45) == 9", "assert arrangeCoins(100) == 13", "assert arrangeCoins(28) == 7"]}, {"author": "Hafeez", "UUID": "6ceae436-ff42-4122-a163-cc19372ef773", "question": "Squirrel Simulation: You are given two integers height and width representing a garden of size height x width. You are also given:\n\nan array tree where tree = [treer, treec] is the position of the tree in the garden,\nan array squirrel where squirrel = [squirrelr, squirrelc] is the position of the squirrel in the garden,\nand an array nuts where nuts[i] = [nutir, nutic] is the position of the ith nut in the garden.\nThe squirrel can only take at most one nut at one time and can move in four directions: up, down, left, and right, to the adjacent cell.\n\nReturn the minimal distance for the squirrel to collect all the nuts and put them under the tree one by one.\n\nThe distance is the number of moves.", "examples": "Input: height = 5, width = 7, tree = [2,2], squirrel = [4,4], nuts = [[3,0], [2,5]]\nOutput: 12\nExplanation: The squirrel should go to the nut at [2, 5] first to achieve a minimal distance.", "link": "https://leetcode.com/problems/squirrel-simulation/description/", "difficulty": "Medium", "categories": ["Math"], "code": "from typing import List\ndef minDistance(height: int, width: int, tree: List[int], squirrel: List[int], nuts: List[List[int]]) -> int:\n        firstPath = float('-inf')\n        total_dist = 0\n        for nut in nuts:\n            dist_to_Sq = abs(squirrel[0]-nut[0])+abs(squirrel[1]-nut[1])\n            dist_to_Tr = abs(tree[0]-nut[0])+abs(tree[1]-nut[1])\n            if (dist_to_Tr-dist_to_Sq)>firstPath:\n                firstPath = dist_to_Tr-dist_to_Sq\n            total_dist+=2*dist_to_Tr\n        total_dist = total_dist - firstPath\n        return total_dist", "asserts": ["assert minDistance(1,3, [0,1], [0,0], [[0,2]])==3", "assert minDistance(5, 5, [2, 2], [0, 0], [[0, 1], [1, 3], [3, 4], [4, 2]]) == 18", "assert minDistance(6, 6, [1, 1], [5, 5], [[1, 2], [2, 2], [3, 3]]) == 14", "assert minDistance(2, 2, [0, 0], [1, 1], [[0, 1]]) == 2", "assert minDistance(3, 3, [0, 0], [2, 2], [[1, 1], [2, 0]]) == 8"]}], "category": "Math", "prompt_tokens": 911, "total_tokens": 1169, "completion_tokens": 258, "completion": "Calculate the Sum of Two Integers: You are tasked with creating a function that takes two integers and returns their sum. However, you must do this without using the \"+\" or \"-\" operators.\n\n###Code:\n\ndef getSum(a: int, b: int) -> int:\n    MASK = 0xFFFFFFFF\n    INT_MAX = 0x7FFFFFFF\n    \n    while b != 0:\n        a, b = (a ^ b) & MASK, ((a & b) << 1) & MASK\n    \n    return a if a <= INT_MAX else ~(a ^ MASK)\n\n###Testcases:\n\nassert getSum(1, 2) == 3\nassert getSum(2, 3) == 5\nassert getSum(-2, 3) == 1\nassert getSum(-2, -3) == -5\nassert getSum(0, 0) == 0\nassert getSum(-1, 1) == 0\nassert getSum(20, 30) == 50\nassert getSum(-20, -30) == -50\nassert getSum(123, 456) == 579\nassert getSum(-123, -456) == -579\n\n[/Example 3]", "temperature": 0.702, "question": "Calculate the Sum of Two Integers: You are tasked with creating a function that takes two integers and returns their sum. However, you must do this without using the \"+\" or \"-\" operators.", "code": "def getSum(a: int, b: int) -> int:\n    MASK = 0xFFFFFFFF\n    INT_MAX = 0x7FFFFFFF\n    \n    while b != 0:\n        a, b = (a ^ b) & MASK, ((a & b) << 1) & MASK\n    \n    return a if a <= INT_MAX else ~(a ^ MASK)", "asserts": ["assert getSum(1, 2) == 3", "assert getSum(2, 3) == 5", "assert getSum(-2, 3) == 1", "assert getSum(-2, -3) == -5", "assert getSum(0, 0) == 0", "assert getSum(-1, 1) == 0", "assert getSum(20, 30) == 50", "assert getSum(-20, -30) == -50", "assert getSum(123, 456) == 579", "assert getSum(-123, -456) == -579"], "author": "GPT", "UUID": "24585bf2-a00e-4455-a6c5-b655dc9641b0", "tc_status": [["assert getSum(1, 2) == 3", "Passed"], ["assert getSum(2, 3) == 5", "Passed"], ["assert getSum(-2, 3) == 1", "Passed"], ["assert getSum(-2, -3) == -5", "Passed"], ["assert getSum(0, 0) == 0", "Passed"], ["assert getSum(-1, 1) == 0", "Passed"], ["assert getSum(20, 30) == 50", "Passed"], ["assert getSum(-20, -30) == -50", "Passed"], ["assert getSum(123, 456) == 579", "Passed"], ["assert getSum(-123, -456) == -579", "Passed"]]}, {"few_shots": [{"author": "Hafeez", "UUID": "6ceae436-ff42-4122-a163-cc19372ef773", "question": "Squirrel Simulation: You are given two integers height and width representing a garden of size height x width. You are also given:\n\nan array tree where tree = [treer, treec] is the position of the tree in the garden,\nan array squirrel where squirrel = [squirrelr, squirrelc] is the position of the squirrel in the garden,\nand an array nuts where nuts[i] = [nutir, nutic] is the position of the ith nut in the garden.\nThe squirrel can only take at most one nut at one time and can move in four directions: up, down, left, and right, to the adjacent cell.\n\nReturn the minimal distance for the squirrel to collect all the nuts and put them under the tree one by one.\n\nThe distance is the number of moves.", "examples": "Input: height = 5, width = 7, tree = [2,2], squirrel = [4,4], nuts = [[3,0], [2,5]]\nOutput: 12\nExplanation: The squirrel should go to the nut at [2, 5] first to achieve a minimal distance.", "link": "https://leetcode.com/problems/squirrel-simulation/description/", "difficulty": "Medium", "categories": ["Math"], "code": "from typing import List\ndef minDistance(height: int, width: int, tree: List[int], squirrel: List[int], nuts: List[List[int]]) -> int:\n        firstPath = float('-inf')\n        total_dist = 0\n        for nut in nuts:\n            dist_to_Sq = abs(squirrel[0]-nut[0])+abs(squirrel[1]-nut[1])\n            dist_to_Tr = abs(tree[0]-nut[0])+abs(tree[1]-nut[1])\n            if (dist_to_Tr-dist_to_Sq)>firstPath:\n                firstPath = dist_to_Tr-dist_to_Sq\n            total_dist+=2*dist_to_Tr\n        total_dist = total_dist - firstPath\n        return total_dist", "asserts": ["assert minDistance(1,3, [0,1], [0,0], [[0,2]])==3", "assert minDistance(5, 5, [2, 2], [0, 0], [[0, 1], [1, 3], [3, 4], [4, 2]]) == 18", "assert minDistance(6, 6, [1, 1], [5, 5], [[1, 2], [2, 2], [3, 3]]) == 14", "assert minDistance(2, 2, [0, 0], [1, 1], [[0, 1]]) == 2", "assert minDistance(3, 3, [0, 0], [2, 2], [[1, 1], [2, 0]]) == 8"]}, {"author": "Hafeez", "UUID": "828013d5-f389-4c8e-8e81-3caf3f2bf40b", "question": "Excel Sheet Column Number: Given a string columnTitle that represents the column title as appears in an Excel sheet, return its corresponding column number.\n\nFor example:\n\nA -> 1\nB -> 2\nC -> 3\n...\nZ -> 26\nAA -> 27\nAB -> 28 \n...\n", "examples": "Input: columnTitle = \"A\"\nOutput: 1\nInput: columnTitle = \"ZY\"\nOutput: 701", "link": "https://leetcode.com/problems/excel-sheet-column-number/description/", "difficulty": "Easy", "categories": ["Math"], "code": "def titleToNumber(s: str) -> int:\n    result = 0\n    alpha_map = {chr(i + 65): i + 1 for i in range(26)}\n    n = len(s)\n    for i in range(n):\n        cur_char = s[n - 1 - i]\n        result += (alpha_map[cur_char] * (26 ** i))\n    return result", "asserts": ["assert titleToNumber(\"AB\")==28", "assert titleToNumber(\"AAA\") == 703", "assert titleToNumber(\"ZZZ\") == 18278", "assert titleToNumber(\"BZ\") == 78", "assert titleToNumber(\"CV\") == 100", "assert titleToNumber(\"XFD\") == 16384", "assert titleToNumber(\"Q\") == 17"]}], "category": "Math", "prompt_tokens": 944, "total_tokens": 1365, "completion_tokens": 421, "completion": "Closest Dessert Cost: You are given three inputs: an array of base costs, an array of topping costs, and a target cost. You must pick exactly one base and can optionally add any number of toppings (including none). Each topping can be used at most twice. Find the closest possible cost of a dessert to the target. If there are two possible costs that are equally close to the target, return the lower one.\n\n###Code:\n\nfrom typing import List\n\ndef closestCost(baseCosts: List[int], toppingCosts: List[int], target: int) -> int:\n    def dfs(index, current_cost):\n        nonlocal closest\n        if abs(target - current_cost) < abs(target - closest) or (abs(target - current_cost) == abs(target - closest) and current_cost < closest):\n            closest = current_cost\n        \n        if index == len(toppingCosts) or current_cost >= target:\n            return\n        \n        # Option 1: Skip the current topping\n        dfs(index + 1, current_cost)\n        \n        # Option 2: Use the current topping once\n        dfs(index + 1, current_cost + toppingCosts[index])\n        \n        # Option 3: Use the current topping twice\n        dfs(index + 1, current_cost + 2 * toppingCosts[index])\n    \n    closest = float('inf')\n    for base in baseCosts:\n        dfs(0, base)\n    return closest\n\n###Testcases:\n\nassert closestCost([1,7], [3,4], 10) == 10\nassert closestCost([2,3], [4,5,100], 18) == 17\nassert closestCost([3,10], [2,5], 9) == 8\nassert closestCost([10], [1], 1) == 10\nassert closestCost([5], [1,2], 11) == 10\nassert closestCost([4,9], [9], 9) == 9\n\n[/Example 3]", "temperature": 0.759, "question": "Closest Dessert Cost: You are given three inputs: an array of base costs, an array of topping costs, and a target cost. You must pick exactly one base and can optionally add any number of toppings (including none). Each topping can be used at most twice. Find the closest possible cost of a dessert to the target. If there are two possible costs that are equally close to the target, return the lower one.", "code": "from typing import List\n\ndef closestCost(baseCosts: List[int], toppingCosts: List[int], target: int) -> int:\n    def dfs(index, current_cost):\n        nonlocal closest\n        if abs(target - current_cost) < abs(target - closest) or (abs(target - current_cost) == abs(target - closest) and current_cost < closest):\n            closest = current_cost\n        \n        if index == len(toppingCosts) or current_cost >= target:\n            return\n        \n        # Option 1: Skip the current topping\n        dfs(index + 1, current_cost)\n        \n        # Option 2: Use the current topping once\n        dfs(index + 1, current_cost + toppingCosts[index])\n        \n        # Option 3: Use the current topping twice\n        dfs(index + 1, current_cost + 2 * toppingCosts[index])\n    \n    closest = float('inf')\n    for base in baseCosts:\n        dfs(0, base)\n    return closest", "asserts": ["assert closestCost([1,7], [3,4], 10) == 10", "assert closestCost([2,3], [4,5,100], 18) == 17", "assert closestCost([3,10], [2,5], 9) == 8", "assert closestCost([10], [1], 1) == 10", "assert closestCost([4,9], [9], 9) == 9"], "author": "GPT", "UUID": "40f7743e-81e6-43c7-9b17-d20d71dcc74e", "tc_status": [["assert closestCost([1,7], [3,4], 10) == 10", "Passed"], ["assert closestCost([2,3], [4,5,100], 18) == 17", "Passed"], ["assert closestCost([3,10], [2,5], 9) == 8", "Passed"], ["assert closestCost([10], [1], 1) == 10", "Passed"], ["assert closestCost([4,9], [9], 9) == 9", "Passed"]]}, {"few_shots": [{"author": "Hafeez", "UUID": "6ceae436-ff42-4122-a163-cc19372ef773", "question": "Squirrel Simulation: You are given two integers height and width representing a garden of size height x width. You are also given:\n\nan array tree where tree = [treer, treec] is the position of the tree in the garden,\nan array squirrel where squirrel = [squirrelr, squirrelc] is the position of the squirrel in the garden,\nand an array nuts where nuts[i] = [nutir, nutic] is the position of the ith nut in the garden.\nThe squirrel can only take at most one nut at one time and can move in four directions: up, down, left, and right, to the adjacent cell.\n\nReturn the minimal distance for the squirrel to collect all the nuts and put them under the tree one by one.\n\nThe distance is the number of moves.", "examples": "Input: height = 5, width = 7, tree = [2,2], squirrel = [4,4], nuts = [[3,0], [2,5]]\nOutput: 12\nExplanation: The squirrel should go to the nut at [2, 5] first to achieve a minimal distance.", "link": "https://leetcode.com/problems/squirrel-simulation/description/", "difficulty": "Medium", "categories": ["Math"], "code": "from typing import List\ndef minDistance(height: int, width: int, tree: List[int], squirrel: List[int], nuts: List[List[int]]) -> int:\n        firstPath = float('-inf')\n        total_dist = 0\n        for nut in nuts:\n            dist_to_Sq = abs(squirrel[0]-nut[0])+abs(squirrel[1]-nut[1])\n            dist_to_Tr = abs(tree[0]-nut[0])+abs(tree[1]-nut[1])\n            if (dist_to_Tr-dist_to_Sq)>firstPath:\n                firstPath = dist_to_Tr-dist_to_Sq\n            total_dist+=2*dist_to_Tr\n        total_dist = total_dist - firstPath\n        return total_dist", "asserts": ["assert minDistance(1,3, [0,1], [0,0], [[0,2]])==3", "assert minDistance(5, 5, [2, 2], [0, 0], [[0, 1], [1, 3], [3, 4], [4, 2]]) == 18", "assert minDistance(6, 6, [1, 1], [5, 5], [[1, 2], [2, 2], [3, 3]]) == 14", "assert minDistance(2, 2, [0, 0], [1, 1], [[0, 1]]) == 2", "assert minDistance(3, 3, [0, 0], [2, 2], [[1, 1], [2, 0]]) == 8"]}, {"author": "Hafeez", "UUID": "de168393-5fd5-4856-89e1-a8722feeb70f", "question": "Arranging Coins: You have n coins and you want to build a staircase with these coins. The staircase consists of k rows where the ith row has exactly i coins. The last row of the staircase may be incomplete.\n\nGiven the integer n, return the number of complete rows of the staircase you will build.", "examples": "Input: n = 5\nOutput: 2\nExplanation: Because the 3rd row is incomplete, we return 2.", "link": "https://leetcode.com/problems/arranging-coins/description/", "difficulty": "Easy", "categories": ["Math"], "code": "def arrangeCoins(n: int) -> int:\n    return (int)((2 * n + 0.25)**0.5 - 0.5)", "asserts": ["assert arrangeCoins(8)==3", "assert arrangeCoins(1) == 1", "assert arrangeCoins(10) == 4", "assert arrangeCoins(0) == 0", "assert arrangeCoins(3) == 2", "assert arrangeCoins(21) == 6", "assert arrangeCoins(15) == 5", "assert arrangeCoins(45) == 9", "assert arrangeCoins(100) == 13", "assert arrangeCoins(28) == 7"]}], "category": "Math", "prompt_tokens": 911, "total_tokens": 1239, "completion_tokens": 328, "completion": "Generate a Unique ID: Given a list of integers representing IDs that are already taken, write a function to generate a unique ID. Assume the ID is an integer starting from 1, and the function should return the smallest positive integer that is not yet taken.\n\n###Code: \n\nfrom typing import List\n\ndef generateUniqueID(takenIDs: List[int]) -> int:\n    takenIDs = set(takenIDs)\n    uniqueID = 1\n    while uniqueID in takenIDs:\n        uniqueID += 1\n    return uniqueID\n\n###Testcases: \n\nassert generateUniqueID([1, 2, 3, 4]) == 5\nassert generateUniqueID([1, 3, 4, 5]) == 2\nassert generateUniqueID([]) == 1\nassert generateUniqueID([2, 3, 7]) == 1\nassert generateUniqueID([1, 1, 1, 1]) == 2\nassert generateUniqueID([3, 5, 6, 1, 2]) == 4\nassert generateUniqueID([10, 9, 8, 1, 2, 3, 4, 5, 6, 7]) == 11\nassert generateUniqueID([1, 3, 2, 5, 4, 7, 6, 8, 10, 9, 12, 11, 14, 13, 16, 15, 17]) == 18\n\n[/Example 3]", "temperature": 0.682, "question": "Generate a Unique ID: Given a list of integers representing IDs that are already taken, write a function to generate a unique ID. Assume the ID is an integer starting from 1, and the function should return the smallest positive integer that is not yet taken.", "code": "from typing import List\n\ndef generateUniqueID(takenIDs: List[int]) -> int:\n    takenIDs = set(takenIDs)\n    uniqueID = 1\n    while uniqueID in takenIDs:\n        uniqueID += 1\n    return uniqueID", "asserts": ["assert generateUniqueID([1, 2, 3, 4]) == 5", "assert generateUniqueID([1, 3, 4, 5]) == 2", "assert generateUniqueID([]) == 1", "assert generateUniqueID([2, 3, 7]) == 1", "assert generateUniqueID([1, 1, 1, 1]) == 2", "assert generateUniqueID([3, 5, 6, 1, 2]) == 4", "assert generateUniqueID([10, 9, 8, 1, 2, 3, 4, 5, 6, 7]) == 11", "assert generateUniqueID([1, 3, 2, 5, 4, 7, 6, 8, 10, 9, 12, 11, 14, 13, 16, 15, 17]) == 18"], "author": "GPT", "UUID": "36a1a921-a104-4cab-8ddf-028fdc88a12b", "tc_status": [["assert generateUniqueID([1, 2, 3, 4]) == 5", "Passed"], ["assert generateUniqueID([1, 3, 4, 5]) == 2", "Passed"], ["assert generateUniqueID([]) == 1", "Passed"], ["assert generateUniqueID([2, 3, 7]) == 1", "Passed"], ["assert generateUniqueID([1, 1, 1, 1]) == 2", "Passed"], ["assert generateUniqueID([3, 5, 6, 1, 2]) == 4", "Passed"], ["assert generateUniqueID([10, 9, 8, 1, 2, 3, 4, 5, 6, 7]) == 11", "Passed"], ["assert generateUniqueID([1, 3, 2, 5, 4, 7, 6, 8, 10, 9, 12, 11, 14, 13, 16, 15, 17]) == 18", "Passed"]]}, {"few_shots": [{"author": "Hafeez", "UUID": "6ceae436-ff42-4122-a163-cc19372ef773", "question": "Squirrel Simulation: You are given two integers height and width representing a garden of size height x width. You are also given:\n\nan array tree where tree = [treer, treec] is the position of the tree in the garden,\nan array squirrel where squirrel = [squirrelr, squirrelc] is the position of the squirrel in the garden,\nand an array nuts where nuts[i] = [nutir, nutic] is the position of the ith nut in the garden.\nThe squirrel can only take at most one nut at one time and can move in four directions: up, down, left, and right, to the adjacent cell.\n\nReturn the minimal distance for the squirrel to collect all the nuts and put them under the tree one by one.\n\nThe distance is the number of moves.", "examples": "Input: height = 5, width = 7, tree = [2,2], squirrel = [4,4], nuts = [[3,0], [2,5]]\nOutput: 12\nExplanation: The squirrel should go to the nut at [2, 5] first to achieve a minimal distance.", "link": "https://leetcode.com/problems/squirrel-simulation/description/", "difficulty": "Medium", "categories": ["Math"], "code": "from typing import List\ndef minDistance(height: int, width: int, tree: List[int], squirrel: List[int], nuts: List[List[int]]) -> int:\n        firstPath = float('-inf')\n        total_dist = 0\n        for nut in nuts:\n            dist_to_Sq = abs(squirrel[0]-nut[0])+abs(squirrel[1]-nut[1])\n            dist_to_Tr = abs(tree[0]-nut[0])+abs(tree[1]-nut[1])\n            if (dist_to_Tr-dist_to_Sq)>firstPath:\n                firstPath = dist_to_Tr-dist_to_Sq\n            total_dist+=2*dist_to_Tr\n        total_dist = total_dist - firstPath\n        return total_dist", "asserts": ["assert minDistance(1,3, [0,1], [0,0], [[0,2]])==3", "assert minDistance(5, 5, [2, 2], [0, 0], [[0, 1], [1, 3], [3, 4], [4, 2]]) == 18", "assert minDistance(6, 6, [1, 1], [5, 5], [[1, 2], [2, 2], [3, 3]]) == 14", "assert minDistance(2, 2, [0, 0], [1, 1], [[0, 1]]) == 2", "assert minDistance(3, 3, [0, 0], [2, 2], [[1, 1], [2, 0]]) == 8"]}, {"author": "Hafeez", "UUID": "de168393-5fd5-4856-89e1-a8722feeb70f", "question": "Arranging Coins: You have n coins and you want to build a staircase with these coins. The staircase consists of k rows where the ith row has exactly i coins. The last row of the staircase may be incomplete.\n\nGiven the integer n, return the number of complete rows of the staircase you will build.", "examples": "Input: n = 5\nOutput: 2\nExplanation: Because the 3rd row is incomplete, we return 2.", "link": "https://leetcode.com/problems/arranging-coins/description/", "difficulty": "Easy", "categories": ["Math"], "code": "def arrangeCoins(n: int) -> int:\n    return (int)((2 * n + 0.25)**0.5 - 0.5)", "asserts": ["assert arrangeCoins(8)==3", "assert arrangeCoins(1) == 1", "assert arrangeCoins(10) == 4", "assert arrangeCoins(0) == 0", "assert arrangeCoins(3) == 2", "assert arrangeCoins(21) == 6", "assert arrangeCoins(15) == 5", "assert arrangeCoins(45) == 9", "assert arrangeCoins(100) == 13", "assert arrangeCoins(28) == 7"]}], "category": "Math", "prompt_tokens": 911, "total_tokens": 1462, "completion_tokens": 551, "completion": "Circular Array Loop: You are given a circular array nums of positive and negative integers. If you move forward on the array, you end at the next index. Similarly, if you move backward, you end at the previous index. Always moving forward or backward you may loop around the array.\n\nA single cycle in the array consists of a sequence of indices seq of length k where:\n\nFollowing the movement rules above and starting with index i, after exactly k moves, you return back to index i.\nFor all elements seq[j], where 0 <= j < k, nums[seq[j]] is either all positive or all negative.\nk > 1\nReturn true if there is a single cycle in nums, otherwise return false.\n\n###Code:\n\nfrom typing import List\n\ndef circularArrayLoop(nums: List[int]) -> bool:\n    def next_index(direction, current):\n        move = nums[current]\n        if (move > 0) != direction:\n            return -1  # Different directions\n        next_index = (current + move) % len(nums)\n        if next_index == current:\n            return -1  # Single element cycle\n        return next_index\n\n    for i in range(len(nums)):\n        direction = nums[i] > 0  # Direction of movement: True if forward\n        slow = i\n        fast = i\n        \n        while True:\n            slow = next_index(direction, slow)\n            fast = next_index(direction, fast)\n            if fast != -1:\n                fast = next_index(direction, fast)\n            if slow == -1 or fast == -1 or slow == fast:\n                break\n        \n        if slow != -1 and slow == fast:\n            return True\n            \n    return False\n\n###Testcases: \n\nassert circularArrayLoop([2, -1, 1, 2, 2]) == True\nassert circularArrayLoop([-1, 2]) == False\nassert circularArrayLoop([-2, 1, -1, -2, -2]) == False\nassert circularArrayLoop([1, 2, 3, 4, 5]) == False\nassert circularArrayLoop([1, 1, 2]) == True\nassert circularArrayLoop([1, -1]) == False\nassert circularArrayLoop([3, 1, 2]) == True\nassert circularArrayLoop([1]) == False\nassert circularArrayLoop([1, 1, 1, 1, 1, 1, 1, 1, 1, -5]) == True\nassert circularArrayLoop([-1, -2, -3, -4, -5]) == False\n\n[/Example 3]", "temperature": 0.787, "question": "Circular Array Loop: You are given a circular array nums of positive and negative integers. If you move forward on the array, you end at the next index. Similarly, if you move backward, you end at the previous index. Always moving forward or backward you may loop around the array.\n\nA single cycle in the array consists of a sequence of indices seq of length k where:\n\nFollowing the movement rules above and starting with index i, after exactly k moves, you return back to index i.\nFor all elements seq[j], where 0 <= j < k, nums[seq[j]] is either all positive or all negative.\nk > 1\nReturn true if there is a single cycle in nums, otherwise return false.", "code": "from typing import List\n\ndef circularArrayLoop(nums: List[int]) -> bool:\n    def next_index(direction, current):\n        move = nums[current]\n        if (move > 0) != direction:\n            return -1  # Different directions\n        next_index = (current + move) % len(nums)\n        if next_index == current:\n            return -1  # Single element cycle\n        return next_index\n\n    for i in range(len(nums)):\n        direction = nums[i] > 0  # Direction of movement: True if forward\n        slow = i\n        fast = i\n        \n        while True:\n            slow = next_index(direction, slow)\n            fast = next_index(direction, fast)\n            if fast != -1:\n                fast = next_index(direction, fast)\n            if slow == -1 or fast == -1 or slow == fast:\n                break\n        \n        if slow != -1 and slow == fast:\n            return True\n            \n    return False", "asserts": ["assert circularArrayLoop([2, -1, 1, 2, 2]) == True", "assert circularArrayLoop([-1, 2]) == False", "assert circularArrayLoop([-2, 1, -1, -2, -2]) == False", "assert circularArrayLoop([1, 1, 2]) == True", "assert circularArrayLoop([1, -1]) == False", "assert circularArrayLoop([3, 1, 2]) == True", "assert circularArrayLoop([1]) == False", "assert circularArrayLoop([-1, -2, -3, -4, -5]) == False"], "author": "GPT", "UUID": "355e48b5-a96e-4cdb-a9b6-bba4207b82c0", "tc_status": [["assert circularArrayLoop([2, -1, 1, 2, 2]) == True", "Passed"], ["assert circularArrayLoop([-1, 2]) == False", "Passed"], ["assert circularArrayLoop([-2, 1, -1, -2, -2]) == False", "Passed"], ["assert circularArrayLoop([1, 1, 2]) == True", "Passed"], ["assert circularArrayLoop([1, -1]) == False", "Passed"], ["assert circularArrayLoop([3, 1, 2]) == True", "Passed"], ["assert circularArrayLoop([1]) == False", "Passed"], ["assert circularArrayLoop([-1, -2, -3, -4, -5]) == False", "Passed"]]}, {"few_shots": [{"author": "Hafeez", "UUID": "6ceae436-ff42-4122-a163-cc19372ef773", "question": "Squirrel Simulation: You are given two integers height and width representing a garden of size height x width. You are also given:\n\nan array tree where tree = [treer, treec] is the position of the tree in the garden,\nan array squirrel where squirrel = [squirrelr, squirrelc] is the position of the squirrel in the garden,\nand an array nuts where nuts[i] = [nutir, nutic] is the position of the ith nut in the garden.\nThe squirrel can only take at most one nut at one time and can move in four directions: up, down, left, and right, to the adjacent cell.\n\nReturn the minimal distance for the squirrel to collect all the nuts and put them under the tree one by one.\n\nThe distance is the number of moves.", "examples": "Input: height = 5, width = 7, tree = [2,2], squirrel = [4,4], nuts = [[3,0], [2,5]]\nOutput: 12\nExplanation: The squirrel should go to the nut at [2, 5] first to achieve a minimal distance.", "link": "https://leetcode.com/problems/squirrel-simulation/description/", "difficulty": "Medium", "categories": ["Math"], "code": "from typing import List\ndef minDistance(height: int, width: int, tree: List[int], squirrel: List[int], nuts: List[List[int]]) -> int:\n        firstPath = float('-inf')\n        total_dist = 0\n        for nut in nuts:\n            dist_to_Sq = abs(squirrel[0]-nut[0])+abs(squirrel[1]-nut[1])\n            dist_to_Tr = abs(tree[0]-nut[0])+abs(tree[1]-nut[1])\n            if (dist_to_Tr-dist_to_Sq)>firstPath:\n                firstPath = dist_to_Tr-dist_to_Sq\n            total_dist+=2*dist_to_Tr\n        total_dist = total_dist - firstPath\n        return total_dist", "asserts": ["assert minDistance(1,3, [0,1], [0,0], [[0,2]])==3", "assert minDistance(5, 5, [2, 2], [0, 0], [[0, 1], [1, 3], [3, 4], [4, 2]]) == 18", "assert minDistance(6, 6, [1, 1], [5, 5], [[1, 2], [2, 2], [3, 3]]) == 14", "assert minDistance(2, 2, [0, 0], [1, 1], [[0, 1]]) == 2", "assert minDistance(3, 3, [0, 0], [2, 2], [[1, 1], [2, 0]]) == 8"]}, {"author": "Hafeez", "UUID": "22847d55-ac87-410b-956b-009096af4c77", "question": "Consecutive Numbers Sum: Given an integer n, return the number of ways you can write n as the sum of consecutive positive integers.", "examples": "Input: n = 5\nOutput: 2\nExplanation: 5 = 2 + 3\nInput: n = 15\nOutput: 4\nExplanation: 15 = 8 + 7 = 4 + 5 + 6 = 1 + 2 + 3 + 4 + 5", "link": "https://leetcode.com/problems/consecutive-numbers-sum/description/", "difficulty": "Hard", "categories": ["Math"], "code": "import math\ndef consecutiveNumbersSum(N: int) -> int:\n    count = 0\n    upper_limit = math.ceil((2 * N + 0.25)**0.5 - 0.5) + 1\n    for k in range(1, upper_limit):\n        if (N - k * (k + 1) // 2) % k == 0:\n            count += 1\n    return count", "asserts": ["assert consecutiveNumbersSum(9)==3", "assert consecutiveNumbersSum(1) == 1", "assert consecutiveNumbersSum(10) == 2", "assert consecutiveNumbersSum(28) == 2", "assert consecutiveNumbersSum(100) == 3", "assert consecutiveNumbersSum(9876) == 4"]}], "category": "Math", "prompt_tokens": 903, "total_tokens": 1209, "completion_tokens": 306, "completion": "Calculate the Unique Paths: A robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below). The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below). How many possible unique paths are there?\n\n###Code: \n\nfrom math import factorial\ndef uniquePaths(m: int, n: int) -> int:\n    # The number of paths to the bottom-right corner is the number of permutations\n    # of moves where we have to move right m-1 times and down n-1 times.\n    # So, the total number of unique paths will be the number of combinations\n    # of (m-1) rights and (n-1) downs, which is the binomial coefficient (m+n-2) choose (n-1).\n    return factorial(m + n - 2) // (factorial(n - 1) * factorial(m - 1))\n\n###Testcases: \n\nassert uniquePaths(3, 7) == 28\nassert uniquePaths(3, 2) == 3\nassert uniquePaths(7, 3) == 28\nassert uniquePaths(3, 3) == 6\nassert uniquePaths(10, 10) == 48620\nassert uniquePaths(23, 12) == 193536720\n\n[/Example 3]", "temperature": 0.705, "question": "Calculate the Unique Paths: A robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below). The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below). How many possible unique paths are there?", "code": "from math import factorial\ndef uniquePaths(m: int, n: int) -> int:\n    # The number of paths to the bottom-right corner is the number of permutations\n    # of moves where we have to move right m-1 times and down n-1 times.\n    # So, the total number of unique paths will be the number of combinations\n    # of (m-1) rights and (n-1) downs, which is the binomial coefficient (m+n-2) choose (n-1).\n    return factorial(m + n - 2) // (factorial(n - 1) * factorial(m - 1))", "asserts": ["assert uniquePaths(3, 7) == 28", "assert uniquePaths(3, 2) == 3", "assert uniquePaths(7, 3) == 28", "assert uniquePaths(3, 3) == 6", "assert uniquePaths(10, 10) == 48620", "assert uniquePaths(23, 12) == 193536720"], "author": "GPT", "UUID": "ef3dc876-ac37-4248-8331-2a385ac46283", "tc_status": [["assert uniquePaths(3, 7) == 28", "Passed"], ["assert uniquePaths(3, 2) == 3", "Passed"], ["assert uniquePaths(7, 3) == 28", "Passed"], ["assert uniquePaths(3, 3) == 6", "Passed"], ["assert uniquePaths(10, 10) == 48620", "Passed"], ["assert uniquePaths(23, 12) == 193536720", "Passed"]]}, {"few_shots": [{"author": "Hafeez", "UUID": "22847d55-ac87-410b-956b-009096af4c77", "question": "Consecutive Numbers Sum: Given an integer n, return the number of ways you can write n as the sum of consecutive positive integers.", "examples": "Input: n = 5\nOutput: 2\nExplanation: 5 = 2 + 3\nInput: n = 15\nOutput: 4\nExplanation: 15 = 8 + 7 = 4 + 5 + 6 = 1 + 2 + 3 + 4 + 5", "link": "https://leetcode.com/problems/consecutive-numbers-sum/description/", "difficulty": "Hard", "categories": ["Math"], "code": "import math\ndef consecutiveNumbersSum(N: int) -> int:\n    count = 0\n    upper_limit = math.ceil((2 * N + 0.25)**0.5 - 0.5) + 1\n    for k in range(1, upper_limit):\n        if (N - k * (k + 1) // 2) % k == 0:\n            count += 1\n    return count", "asserts": ["assert consecutiveNumbersSum(9)==3", "assert consecutiveNumbersSum(1) == 1", "assert consecutiveNumbersSum(10) == 2", "assert consecutiveNumbersSum(28) == 2", "assert consecutiveNumbersSum(100) == 3", "assert consecutiveNumbersSum(9876) == 4"]}, {"author": "Hafeez", "UUID": "6ceae436-ff42-4122-a163-cc19372ef773", "question": "Squirrel Simulation: You are given two integers height and width representing a garden of size height x width. You are also given:\n\nan array tree where tree = [treer, treec] is the position of the tree in the garden,\nan array squirrel where squirrel = [squirrelr, squirrelc] is the position of the squirrel in the garden,\nand an array nuts where nuts[i] = [nutir, nutic] is the position of the ith nut in the garden.\nThe squirrel can only take at most one nut at one time and can move in four directions: up, down, left, and right, to the adjacent cell.\n\nReturn the minimal distance for the squirrel to collect all the nuts and put them under the tree one by one.\n\nThe distance is the number of moves.", "examples": "Input: height = 5, width = 7, tree = [2,2], squirrel = [4,4], nuts = [[3,0], [2,5]]\nOutput: 12\nExplanation: The squirrel should go to the nut at [2, 5] first to achieve a minimal distance.", "link": "https://leetcode.com/problems/squirrel-simulation/description/", "difficulty": "Medium", "categories": ["Math"], "code": "from typing import List\ndef minDistance(height: int, width: int, tree: List[int], squirrel: List[int], nuts: List[List[int]]) -> int:\n        firstPath = float('-inf')\n        total_dist = 0\n        for nut in nuts:\n            dist_to_Sq = abs(squirrel[0]-nut[0])+abs(squirrel[1]-nut[1])\n            dist_to_Tr = abs(tree[0]-nut[0])+abs(tree[1]-nut[1])\n            if (dist_to_Tr-dist_to_Sq)>firstPath:\n                firstPath = dist_to_Tr-dist_to_Sq\n            total_dist+=2*dist_to_Tr\n        total_dist = total_dist - firstPath\n        return total_dist", "asserts": ["assert minDistance(1,3, [0,1], [0,0], [[0,2]])==3", "assert minDistance(5, 5, [2, 2], [0, 0], [[0, 1], [1, 3], [3, 4], [4, 2]]) == 18", "assert minDistance(6, 6, [1, 1], [5, 5], [[1, 2], [2, 2], [3, 3]]) == 14", "assert minDistance(2, 2, [0, 0], [1, 1], [[0, 1]]) == 2", "assert minDistance(3, 3, [0, 0], [2, 2], [[1, 1], [2, 0]]) == 8"]}], "category": "Math", "prompt_tokens": 903, "total_tokens": 1230, "completion_tokens": 327, "completion": "Add Minimum Number of Rungs: You are given a strictly increasing integer array rungs that represents the height of ladder rungs and an integer dist. You are initially on the floor at height 0 and you can climb at most dist height in a single step.\n\nYou are also given the task to add the minimum number of rungs to the ladder such that you can reach the highest rung without climbing more than dist height at once. Return the minimum number of rungs you need to add to the ladder.\n\n###Code:\n\n```python\nfrom typing import List\n\ndef addRungs(rungs: List[int], dist: int) -> int:\n    current_height = 0\n    add_count = 0\n    for rung in rungs:\n        if rung - current_height > dist:\n            # Calculate how many rungs need to be inserted\n            add_count += (rung - current_height - 1) // dist\n        current_height = rung\n    return add_count\n```\n\n###Testcases:\n\n```python\nassert addRungs([1, 3, 5, 10], 2) == 2\nassert addRungs([3,6,8,10], 3) == 0\nassert addRungs([3,4,6,7], 1) == 3\nassert addRungs([5,10,15], 5) == 0\nassert addRungs([1,6,10,13,14,16,22], 4) == 2\n```\n\n[/Example 3]", "temperature": 0.927, "question": "Add Minimum Number of Rungs: You are given a strictly increasing integer array rungs that represents the height of ladder rungs and an integer dist. You are initially on the floor at height 0 and you can climb at most dist height in a single step.\n\nYou are also given the task to add the minimum number of rungs to the ladder such that you can reach the highest rung without climbing more than dist height at once. Return the minimum number of rungs you need to add to the ladder.", "code": "from typing import List\n\ndef addRungs(rungs: List[int], dist: int) -> int:\n    current_height = 0\n    add_count = 0\n    for rung in rungs:\n        if rung - current_height > dist:\n            # Calculate how many rungs need to be inserted\n            add_count += (rung - current_height - 1) // dist\n        current_height = rung\n    return add_count", "asserts": ["assert addRungs([1, 3, 5, 10], 2) == 2", "assert addRungs([3,6,8,10], 3) == 0", "assert addRungs([3,4,6,7], 1) == 3", "assert addRungs([5,10,15], 5) == 0", "assert addRungs([1,6,10,13,14,16,22], 4) == 2"], "author": "GPT", "UUID": "7c08270e-09f4-43b9-987d-b4e73da1df7a", "tc_status": [["assert addRungs([1, 3, 5, 10], 2) == 2", "Passed"], ["assert addRungs([3,6,8,10], 3) == 0", "Passed"], ["assert addRungs([3,4,6,7], 1) == 3", "Passed"], ["assert addRungs([5,10,15], 5) == 0", "Passed"], ["assert addRungs([1,6,10,13,14,16,22], 4) == 2", "Passed"]]}, {"few_shots": [{"author": "Hafeez", "UUID": "828013d5-f389-4c8e-8e81-3caf3f2bf40b", "question": "Excel Sheet Column Number: Given a string columnTitle that represents the column title as appears in an Excel sheet, return its corresponding column number.\n\nFor example:\n\nA -> 1\nB -> 2\nC -> 3\n...\nZ -> 26\nAA -> 27\nAB -> 28 \n...\n", "examples": "Input: columnTitle = \"A\"\nOutput: 1\nInput: columnTitle = \"ZY\"\nOutput: 701", "link": "https://leetcode.com/problems/excel-sheet-column-number/description/", "difficulty": "Easy", "categories": ["Math"], "code": "def titleToNumber(s: str) -> int:\n    result = 0\n    alpha_map = {chr(i + 65): i + 1 for i in range(26)}\n    n = len(s)\n    for i in range(n):\n        cur_char = s[n - 1 - i]\n        result += (alpha_map[cur_char] * (26 ** i))\n    return result", "asserts": ["assert titleToNumber(\"AB\")==28", "assert titleToNumber(\"AAA\") == 703", "assert titleToNumber(\"ZZZ\") == 18278", "assert titleToNumber(\"BZ\") == 78", "assert titleToNumber(\"CV\") == 100", "assert titleToNumber(\"XFD\") == 16384", "assert titleToNumber(\"Q\") == 17"]}, {"author": "Hafeez", "UUID": "de168393-5fd5-4856-89e1-a8722feeb70f", "question": "Arranging Coins: You have n coins and you want to build a staircase with these coins. The staircase consists of k rows where the ith row has exactly i coins. The last row of the staircase may be incomplete.\n\nGiven the integer n, return the number of complete rows of the staircase you will build.", "examples": "Input: n = 5\nOutput: 2\nExplanation: Because the 3rd row is incomplete, we return 2.", "link": "https://leetcode.com/problems/arranging-coins/description/", "difficulty": "Easy", "categories": ["Math"], "code": "def arrangeCoins(n: int) -> int:\n    return (int)((2 * n + 0.25)**0.5 - 0.5)", "asserts": ["assert arrangeCoins(8)==3", "assert arrangeCoins(1) == 1", "assert arrangeCoins(10) == 4", "assert arrangeCoins(0) == 0", "assert arrangeCoins(3) == 2", "assert arrangeCoins(21) == 6", "assert arrangeCoins(15) == 5", "assert arrangeCoins(45) == 9", "assert arrangeCoins(100) == 13", "assert arrangeCoins(28) == 7"]}], "category": "Math", "prompt_tokens": 632, "total_tokens": 917, "completion_tokens": 285, "completion": "Find the nth Digit of a Number: Create a function that takes two numbers as arguments (n, p) and returns the pth digit (from right to left) of n.\n\nIf the number does not have a pth digit, return -1.\n\n###Code: \n\ndef findNthDigit(n: int, p: int) -> int:\n    num_str = str(n)\n    reverse_idx = len(num_str) - p\n    if reverse_idx >= 0 and reverse_idx < len(num_str):\n        return int(num_str[reverse_idx])\n    return -1\n\n###Testcases: \n\nassert findNthDigit(456, 2) == 5\nassert findNthDigit(12345, 1) == 5\nassert findNthDigit(987654321, 5) == 4\nassert findNthDigit(234, 6) == -1\nassert findNthDigit(10000, 5) == 1\nassert findNthDigit(123456789, 9) == 1\nassert findNthDigit(678, 0) == -1\nassert findNthDigit(10, 2) == 1\nassert findNthDigit(1, 3) == -1\nassert findNthDigit(789, 2) == 8\n\n[/Example 3]", "temperature": 0.969, "question": "Find the nth Digit of a Number: Create a function that takes two numbers as arguments (n, p) and returns the pth digit (from right to left) of n.\n\nIf the number does not have a pth digit, return -1.", "code": "def findNthDigit(n: int, p: int) -> int:\n    num_str = str(n)\n    reverse_idx = len(num_str) - p\n    if reverse_idx >= 0 and reverse_idx < len(num_str):\n        return int(num_str[reverse_idx])\n    return -1", "asserts": ["assert findNthDigit(456, 2) == 5", "assert findNthDigit(12345, 1) == 5", "assert findNthDigit(234, 6) == -1", "assert findNthDigit(10000, 5) == 1", "assert findNthDigit(123456789, 9) == 1", "assert findNthDigit(678, 0) == -1", "assert findNthDigit(10, 2) == 1", "assert findNthDigit(1, 3) == -1", "assert findNthDigit(789, 2) == 8"], "author": "GPT", "UUID": "0a2eb6f3-2aec-460c-a986-4cae2820c12d", "tc_status": [["assert findNthDigit(456, 2) == 5", "Passed"], ["assert findNthDigit(12345, 1) == 5", "Passed"], ["assert findNthDigit(234, 6) == -1", "Passed"], ["assert findNthDigit(10000, 5) == 1", "Passed"], ["assert findNthDigit(123456789, 9) == 1", "Passed"], ["assert findNthDigit(678, 0) == -1", "Passed"], ["assert findNthDigit(10, 2) == 1", "Passed"], ["assert findNthDigit(1, 3) == -1", "Passed"], ["assert findNthDigit(789, 2) == 8", "Passed"]]}, {"few_shots": [{"author": "Hafeez", "UUID": "828013d5-f389-4c8e-8e81-3caf3f2bf40b", "question": "Excel Sheet Column Number: Given a string columnTitle that represents the column title as appears in an Excel sheet, return its corresponding column number.\n\nFor example:\n\nA -> 1\nB -> 2\nC -> 3\n...\nZ -> 26\nAA -> 27\nAB -> 28 \n...\n", "examples": "Input: columnTitle = \"A\"\nOutput: 1\nInput: columnTitle = \"ZY\"\nOutput: 701", "link": "https://leetcode.com/problems/excel-sheet-column-number/description/", "difficulty": "Easy", "categories": ["Math"], "code": "def titleToNumber(s: str) -> int:\n    result = 0\n    alpha_map = {chr(i + 65): i + 1 for i in range(26)}\n    n = len(s)\n    for i in range(n):\n        cur_char = s[n - 1 - i]\n        result += (alpha_map[cur_char] * (26 ** i))\n    return result", "asserts": ["assert titleToNumber(\"AB\")==28", "assert titleToNumber(\"AAA\") == 703", "assert titleToNumber(\"ZZZ\") == 18278", "assert titleToNumber(\"BZ\") == 78", "assert titleToNumber(\"CV\") == 100", "assert titleToNumber(\"XFD\") == 16384", "assert titleToNumber(\"Q\") == 17"]}, {"author": "Hafeez", "UUID": "de168393-5fd5-4856-89e1-a8722feeb70f", "question": "Arranging Coins: You have n coins and you want to build a staircase with these coins. The staircase consists of k rows where the ith row has exactly i coins. The last row of the staircase may be incomplete.\n\nGiven the integer n, return the number of complete rows of the staircase you will build.", "examples": "Input: n = 5\nOutput: 2\nExplanation: Because the 3rd row is incomplete, we return 2.", "link": "https://leetcode.com/problems/arranging-coins/description/", "difficulty": "Easy", "categories": ["Math"], "code": "def arrangeCoins(n: int) -> int:\n    return (int)((2 * n + 0.25)**0.5 - 0.5)", "asserts": ["assert arrangeCoins(8)==3", "assert arrangeCoins(1) == 1", "assert arrangeCoins(10) == 4", "assert arrangeCoins(0) == 0", "assert arrangeCoins(3) == 2", "assert arrangeCoins(21) == 6", "assert arrangeCoins(15) == 5", "assert arrangeCoins(45) == 9", "assert arrangeCoins(100) == 13", "assert arrangeCoins(28) == 7"]}], "category": "Math", "prompt_tokens": 632, "total_tokens": 900, "completion_tokens": 268, "completion": "Happy Number: Write a function to determine if a number n is \"happy\".\n\nA happy number is a number defined by the following process:\n\n- Starting with any positive integer, replace the number by the sum of the squares of its digits.\n- Repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1.\n- Those numbers for which this process ends in 1 are happy numbers.\n\nReturn true if n is a happy number, and false if not.\n\n###Code: \n\ndef isHappy(n: int) -> bool:\n    seen = set()\n    while n not in seen:\n        seen.add(n)\n        n = sum([int(x)**2 for x in str(n)])\n        if n == 1:\n            return True\n    return False\n\n###Testcases: \n\nassert isHappy(19) == True\nassert isHappy(1) == True\nassert isHappy(2) == False\nassert isHappy(7) == True\nassert isHappy(88) == False\nassert isHappy(97) == True\nassert isHappy(100) == True\nassert isHappy(11) == False\nassert isHappy(90) == False\nassert isHappy(70) == True\n\n[/Example 3]", "temperature": 0.84, "question": "Happy Number: Write a function to determine if a number n is \"happy\".\n\nA happy number is a number defined by the following process:\n\n- Starting with any positive integer, replace the number by the sum of the squares of its digits.\n- Repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1.\n- Those numbers for which this process ends in 1 are happy numbers.\n\nReturn true if n is a happy number, and false if not.", "code": "def isHappy(n: int) -> bool:\n    seen = set()\n    while n not in seen:\n        seen.add(n)\n        n = sum([int(x)**2 for x in str(n)])\n        if n == 1:\n            return True\n    return False", "asserts": ["assert isHappy(19) == True", "assert isHappy(1) == True", "assert isHappy(2) == False", "assert isHappy(7) == True", "assert isHappy(88) == False", "assert isHappy(97) == True", "assert isHappy(100) == True", "assert isHappy(11) == False", "assert isHappy(90) == False", "assert isHappy(70) == True"], "author": "GPT", "UUID": "90baf371-847c-456e-baac-a563d4b4a74b", "tc_status": [["assert isHappy(19) == True", "Passed"], ["assert isHappy(1) == True", "Passed"], ["assert isHappy(2) == False", "Passed"], ["assert isHappy(7) == True", "Passed"], ["assert isHappy(88) == False", "Passed"], ["assert isHappy(97) == True", "Passed"], ["assert isHappy(100) == True", "Passed"], ["assert isHappy(11) == False", "Passed"], ["assert isHappy(90) == False", "Passed"], ["assert isHappy(70) == True", "Passed"]]}, {"few_shots": [{"author": "Hafeez", "UUID": "828013d5-f389-4c8e-8e81-3caf3f2bf40b", "question": "Excel Sheet Column Number: Given a string columnTitle that represents the column title as appears in an Excel sheet, return its corresponding column number.\n\nFor example:\n\nA -> 1\nB -> 2\nC -> 3\n...\nZ -> 26\nAA -> 27\nAB -> 28 \n...\n", "examples": "Input: columnTitle = \"A\"\nOutput: 1\nInput: columnTitle = \"ZY\"\nOutput: 701", "link": "https://leetcode.com/problems/excel-sheet-column-number/description/", "difficulty": "Easy", "categories": ["Math"], "code": "def titleToNumber(s: str) -> int:\n    result = 0\n    alpha_map = {chr(i + 65): i + 1 for i in range(26)}\n    n = len(s)\n    for i in range(n):\n        cur_char = s[n - 1 - i]\n        result += (alpha_map[cur_char] * (26 ** i))\n    return result", "asserts": ["assert titleToNumber(\"AB\")==28", "assert titleToNumber(\"AAA\") == 703", "assert titleToNumber(\"ZZZ\") == 18278", "assert titleToNumber(\"BZ\") == 78", "assert titleToNumber(\"CV\") == 100", "assert titleToNumber(\"XFD\") == 16384", "assert titleToNumber(\"Q\") == 17"]}, {"author": "Hafeez", "UUID": "de168393-5fd5-4856-89e1-a8722feeb70f", "question": "Arranging Coins: You have n coins and you want to build a staircase with these coins. The staircase consists of k rows where the ith row has exactly i coins. The last row of the staircase may be incomplete.\n\nGiven the integer n, return the number of complete rows of the staircase you will build.", "examples": "Input: n = 5\nOutput: 2\nExplanation: Because the 3rd row is incomplete, we return 2.", "link": "https://leetcode.com/problems/arranging-coins/description/", "difficulty": "Easy", "categories": ["Math"], "code": "def arrangeCoins(n: int) -> int:\n    return (int)((2 * n + 0.25)**0.5 - 0.5)", "asserts": ["assert arrangeCoins(8)==3", "assert arrangeCoins(1) == 1", "assert arrangeCoins(10) == 4", "assert arrangeCoins(0) == 0", "assert arrangeCoins(3) == 2", "assert arrangeCoins(21) == 6", "assert arrangeCoins(15) == 5", "assert arrangeCoins(45) == 9", "assert arrangeCoins(100) == 13", "assert arrangeCoins(28) == 7"]}], "category": "Math", "prompt_tokens": 632, "total_tokens": 845, "completion_tokens": 213, "completion": "Palindrome Number: Determine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward. Negative numbers are not considered as palindromes.\n\n###Code: \n\ndef isPalindrome(x: int) -> bool:\n    if x < 0:\n        return False\n    original = x\n    reversed_num = 0\n    while x > 0:\n        reversed_num = reversed_num * 10 + x % 10\n        x //= 10\n    return original == reversed_num\n\n###Testcases: \n\nassert isPalindrome(121)==True\nassert isPalindrome(-121) == False\nassert isPalindrome(10) == False\nassert isPalindrome(0) == True\nassert isPalindrome(12321) == True\nassert isPalindrome(1234321) == True\nassert isPalindrome(123454321) == True\nassert isPalindrome(123456) == False\nassert isPalindrome(1) == True\nassert isPalindrome(111) == True\n\n[/Example 3]", "temperature": 0.622, "question": "Palindrome Number: Determine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward. Negative numbers are not considered as palindromes.", "code": "def isPalindrome(x: int) -> bool:\n    if x < 0:\n        return False\n    original = x\n    reversed_num = 0\n    while x > 0:\n        reversed_num = reversed_num * 10 + x % 10\n        x //= 10\n    return original == reversed_num", "asserts": ["assert isPalindrome(121)==True", "assert isPalindrome(-121) == False", "assert isPalindrome(10) == False", "assert isPalindrome(0) == True", "assert isPalindrome(12321) == True", "assert isPalindrome(1234321) == True", "assert isPalindrome(123454321) == True", "assert isPalindrome(123456) == False", "assert isPalindrome(1) == True", "assert isPalindrome(111) == True"], "author": "GPT", "UUID": "e7141c8c-5043-487c-ad15-a3697195fb29", "tc_status": [["assert isPalindrome(121)==True", "Passed"], ["assert isPalindrome(-121) == False", "Passed"], ["assert isPalindrome(10) == False", "Passed"], ["assert isPalindrome(0) == True", "Passed"], ["assert isPalindrome(12321) == True", "Passed"], ["assert isPalindrome(1234321) == True", "Passed"], ["assert isPalindrome(123454321) == True", "Passed"], ["assert isPalindrome(123456) == False", "Passed"], ["assert isPalindrome(1) == True", "Passed"], ["assert isPalindrome(111) == True", "Passed"]]}, {"few_shots": [{"author": "Hafeez", "UUID": "828013d5-f389-4c8e-8e81-3caf3f2bf40b", "question": "Excel Sheet Column Number: Given a string columnTitle that represents the column title as appears in an Excel sheet, return its corresponding column number.\n\nFor example:\n\nA -> 1\nB -> 2\nC -> 3\n...\nZ -> 26\nAA -> 27\nAB -> 28 \n...\n", "examples": "Input: columnTitle = \"A\"\nOutput: 1\nInput: columnTitle = \"ZY\"\nOutput: 701", "link": "https://leetcode.com/problems/excel-sheet-column-number/description/", "difficulty": "Easy", "categories": ["Math"], "code": "def titleToNumber(s: str) -> int:\n    result = 0\n    alpha_map = {chr(i + 65): i + 1 for i in range(26)}\n    n = len(s)\n    for i in range(n):\n        cur_char = s[n - 1 - i]\n        result += (alpha_map[cur_char] * (26 ** i))\n    return result", "asserts": ["assert titleToNumber(\"AB\")==28", "assert titleToNumber(\"AAA\") == 703", "assert titleToNumber(\"ZZZ\") == 18278", "assert titleToNumber(\"BZ\") == 78", "assert titleToNumber(\"CV\") == 100", "assert titleToNumber(\"XFD\") == 16384", "assert titleToNumber(\"Q\") == 17"]}, {"author": "Hafeez", "UUID": "6ceae436-ff42-4122-a163-cc19372ef773", "question": "Squirrel Simulation: You are given two integers height and width representing a garden of size height x width. You are also given:\n\nan array tree where tree = [treer, treec] is the position of the tree in the garden,\nan array squirrel where squirrel = [squirrelr, squirrelc] is the position of the squirrel in the garden,\nand an array nuts where nuts[i] = [nutir, nutic] is the position of the ith nut in the garden.\nThe squirrel can only take at most one nut at one time and can move in four directions: up, down, left, and right, to the adjacent cell.\n\nReturn the minimal distance for the squirrel to collect all the nuts and put them under the tree one by one.\n\nThe distance is the number of moves.", "examples": "Input: height = 5, width = 7, tree = [2,2], squirrel = [4,4], nuts = [[3,0], [2,5]]\nOutput: 12\nExplanation: The squirrel should go to the nut at [2, 5] first to achieve a minimal distance.", "link": "https://leetcode.com/problems/squirrel-simulation/description/", "difficulty": "Medium", "categories": ["Math"], "code": "from typing import List\ndef minDistance(height: int, width: int, tree: List[int], squirrel: List[int], nuts: List[List[int]]) -> int:\n        firstPath = float('-inf')\n        total_dist = 0\n        for nut in nuts:\n            dist_to_Sq = abs(squirrel[0]-nut[0])+abs(squirrel[1]-nut[1])\n            dist_to_Tr = abs(tree[0]-nut[0])+abs(tree[1]-nut[1])\n            if (dist_to_Tr-dist_to_Sq)>firstPath:\n                firstPath = dist_to_Tr-dist_to_Sq\n            total_dist+=2*dist_to_Tr\n        total_dist = total_dist - firstPath\n        return total_dist", "asserts": ["assert minDistance(1,3, [0,1], [0,0], [[0,2]])==3", "assert minDistance(5, 5, [2, 2], [0, 0], [[0, 1], [1, 3], [3, 4], [4, 2]]) == 18", "assert minDistance(6, 6, [1, 1], [5, 5], [[1, 2], [2, 2], [3, 3]]) == 14", "assert minDistance(2, 2, [0, 0], [1, 1], [[0, 1]]) == 2", "assert minDistance(3, 3, [0, 0], [2, 2], [[1, 1], [2, 0]]) == 8"]}], "category": "Math", "prompt_tokens": 944, "total_tokens": 1222, "completion_tokens": 278, "completion": "Perfect Number: Write a function to check whether a number is a \"perfect number\". A perfect number is a positive integer that is equal to the sum of its proper divisors, excluding itself.\n\nFor example, 28 is a perfect number because its proper divisors are 1, 2, 4, 7, 14, and the sum of these divisors is 28.\n\n###Code: \n\ndef checkPerfectNumber(num: int) -> bool:\n    if num <= 1:\n        return False\n    \n    divisors_sum = 1\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            divisors_sum += i\n            if i != num // i:  # Exclude the square root itself if it's a divisor\n                divisors_sum += num // i\n    return divisors_sum == num\n\n###Testcases: \n\nassert checkPerfectNumber(28) == True\nassert checkPerfectNumber(6) == True\nassert checkPerfectNumber(496) == True\nassert checkPerfectNumber(8128) == True\nassert checkPerfectNumber(2) == False\nassert checkPerfectNumber(10) == False\nassert checkPerfectNumber(27) == False\nassert checkPerfectNumber(100) == False\n\n[/Example 3]", "temperature": 0.881, "question": "Perfect Number: Write a function to check whether a number is a \"perfect number\". A perfect number is a positive integer that is equal to the sum of its proper divisors, excluding itself.\n\nFor example, 28 is a perfect number because its proper divisors are 1, 2, 4, 7, 14, and the sum of these divisors is 28.", "code": "def checkPerfectNumber(num: int) -> bool:\n    if num <= 1:\n        return False\n    \n    divisors_sum = 1\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            divisors_sum += i\n            if i != num // i:  # Exclude the square root itself if it's a divisor\n                divisors_sum += num // i\n    return divisors_sum == num", "asserts": ["assert checkPerfectNumber(28) == True", "assert checkPerfectNumber(6) == True", "assert checkPerfectNumber(496) == True", "assert checkPerfectNumber(8128) == True", "assert checkPerfectNumber(2) == False", "assert checkPerfectNumber(10) == False", "assert checkPerfectNumber(27) == False", "assert checkPerfectNumber(100) == False"], "author": "GPT", "UUID": "91ae9365-b978-4dcf-8337-dd4cc7c2805e", "tc_status": [["assert checkPerfectNumber(28) == True", "Passed"], ["assert checkPerfectNumber(6) == True", "Passed"], ["assert checkPerfectNumber(496) == True", "Passed"], ["assert checkPerfectNumber(8128) == True", "Passed"], ["assert checkPerfectNumber(2) == False", "Passed"], ["assert checkPerfectNumber(10) == False", "Passed"], ["assert checkPerfectNumber(27) == False", "Passed"], ["assert checkPerfectNumber(100) == False", "Passed"]]}, {"few_shots": [{"author": "Hafeez", "UUID": "828013d5-f389-4c8e-8e81-3caf3f2bf40b", "question": "Excel Sheet Column Number: Given a string columnTitle that represents the column title as appears in an Excel sheet, return its corresponding column number.\n\nFor example:\n\nA -> 1\nB -> 2\nC -> 3\n...\nZ -> 26\nAA -> 27\nAB -> 28 \n...\n", "examples": "Input: columnTitle = \"A\"\nOutput: 1\nInput: columnTitle = \"ZY\"\nOutput: 701", "link": "https://leetcode.com/problems/excel-sheet-column-number/description/", "difficulty": "Easy", "categories": ["Math"], "code": "def titleToNumber(s: str) -> int:\n    result = 0\n    alpha_map = {chr(i + 65): i + 1 for i in range(26)}\n    n = len(s)\n    for i in range(n):\n        cur_char = s[n - 1 - i]\n        result += (alpha_map[cur_char] * (26 ** i))\n    return result", "asserts": ["assert titleToNumber(\"AB\")==28", "assert titleToNumber(\"AAA\") == 703", "assert titleToNumber(\"ZZZ\") == 18278", "assert titleToNumber(\"BZ\") == 78", "assert titleToNumber(\"CV\") == 100", "assert titleToNumber(\"XFD\") == 16384", "assert titleToNumber(\"Q\") == 17"]}, {"author": "Hafeez", "UUID": "6ceae436-ff42-4122-a163-cc19372ef773", "question": "Squirrel Simulation: You are given two integers height and width representing a garden of size height x width. You are also given:\n\nan array tree where tree = [treer, treec] is the position of the tree in the garden,\nan array squirrel where squirrel = [squirrelr, squirrelc] is the position of the squirrel in the garden,\nand an array nuts where nuts[i] = [nutir, nutic] is the position of the ith nut in the garden.\nThe squirrel can only take at most one nut at one time and can move in four directions: up, down, left, and right, to the adjacent cell.\n\nReturn the minimal distance for the squirrel to collect all the nuts and put them under the tree one by one.\n\nThe distance is the number of moves.", "examples": "Input: height = 5, width = 7, tree = [2,2], squirrel = [4,4], nuts = [[3,0], [2,5]]\nOutput: 12\nExplanation: The squirrel should go to the nut at [2, 5] first to achieve a minimal distance.", "link": "https://leetcode.com/problems/squirrel-simulation/description/", "difficulty": "Medium", "categories": ["Math"], "code": "from typing import List\ndef minDistance(height: int, width: int, tree: List[int], squirrel: List[int], nuts: List[List[int]]) -> int:\n        firstPath = float('-inf')\n        total_dist = 0\n        for nut in nuts:\n            dist_to_Sq = abs(squirrel[0]-nut[0])+abs(squirrel[1]-nut[1])\n            dist_to_Tr = abs(tree[0]-nut[0])+abs(tree[1]-nut[1])\n            if (dist_to_Tr-dist_to_Sq)>firstPath:\n                firstPath = dist_to_Tr-dist_to_Sq\n            total_dist+=2*dist_to_Tr\n        total_dist = total_dist - firstPath\n        return total_dist", "asserts": ["assert minDistance(1,3, [0,1], [0,0], [[0,2]])==3", "assert minDistance(5, 5, [2, 2], [0, 0], [[0, 1], [1, 3], [3, 4], [4, 2]]) == 18", "assert minDistance(6, 6, [1, 1], [5, 5], [[1, 2], [2, 2], [3, 3]]) == 14", "assert minDistance(2, 2, [0, 0], [1, 1], [[0, 1]]) == 2", "assert minDistance(3, 3, [0, 0], [2, 2], [[1, 1], [2, 0]]) == 8"]}], "category": "Math", "prompt_tokens": 944, "total_tokens": 1219, "completion_tokens": 275, "completion": "Count Primes: Write a function that counts the number of prime numbers less than a non-negative number, n.\n\nA prime number is a natural number greater than 1 that is not a product of two smaller natural numbers.\n\n###Code:\n\ndef countPrimes(n: int) -> int:\n    if n <= 2:\n        return 0\n    sieve = [True] * n\n    sieve[0] = sieve[1] = False\n\n    for i in range(2, int(n ** 0.5) + 1):\n        if sieve[i]:\n            for j in range(i*i, n, i):\n                sieve[j] = False\n\n    return sum(sieve)\n\n###Testcases:\n\nassert countPrimes(10) == 4  # 2, 3, 5, 7\nassert countPrimes(0) == 0\nassert countPrimes(1) == 0\nassert countPrimes(2) == 0\nassert countPrimes(100) == 25  # 25 prime numbers less than 100\nassert countPrimes(1000) == 168  # 168 prime numbers less than 1000\nassert countPrimes(499979) == 41537  # prime numbers less than 499979\n\n[/Example 3]", "temperature": 0.891, "question": "Count Primes: Write a function that counts the number of prime numbers less than a non-negative number, n.\n\nA prime number is a natural number greater than 1 that is not a product of two smaller natural numbers.", "code": "def countPrimes(n: int) -> int:\n    if n <= 2:\n        return 0\n    sieve = [True] * n\n    sieve[0] = sieve[1] = False\n\n    for i in range(2, int(n ** 0.5) + 1):\n        if sieve[i]:\n            for j in range(i*i, n, i):\n                sieve[j] = False\n\n    return sum(sieve)", "asserts": ["assert countPrimes(10) == 4  # 2, 3, 5, 7", "assert countPrimes(0) == 0", "assert countPrimes(1) == 0", "assert countPrimes(2) == 0", "assert countPrimes(100) == 25  # 25 prime numbers less than 100", "assert countPrimes(1000) == 168  # 168 prime numbers less than 1000", "assert countPrimes(499979) == 41537  # prime numbers less than 499979"], "author": "GPT", "UUID": "67e62ddb-fde8-4597-8a88-c5790ffea52e", "tc_status": [["assert countPrimes(10) == 4  # 2, 3, 5, 7", "Passed"], ["assert countPrimes(0) == 0", "Passed"], ["assert countPrimes(1) == 0", "Passed"], ["assert countPrimes(2) == 0", "Passed"], ["assert countPrimes(100) == 25  # 25 prime numbers less than 100", "Passed"], ["assert countPrimes(1000) == 168  # 168 prime numbers less than 1000", "Passed"], ["assert countPrimes(499979) == 41537  # prime numbers less than 499979", "Passed"]]}, {"few_shots": [{"author": "Hafeez", "UUID": "828013d5-f389-4c8e-8e81-3caf3f2bf40b", "question": "Excel Sheet Column Number: Given a string columnTitle that represents the column title as appears in an Excel sheet, return its corresponding column number.\n\nFor example:\n\nA -> 1\nB -> 2\nC -> 3\n...\nZ -> 26\nAA -> 27\nAB -> 28 \n...\n", "examples": "Input: columnTitle = \"A\"\nOutput: 1\nInput: columnTitle = \"ZY\"\nOutput: 701", "link": "https://leetcode.com/problems/excel-sheet-column-number/description/", "difficulty": "Easy", "categories": ["Math"], "code": "def titleToNumber(s: str) -> int:\n    result = 0\n    alpha_map = {chr(i + 65): i + 1 for i in range(26)}\n    n = len(s)\n    for i in range(n):\n        cur_char = s[n - 1 - i]\n        result += (alpha_map[cur_char] * (26 ** i))\n    return result", "asserts": ["assert titleToNumber(\"AB\")==28", "assert titleToNumber(\"AAA\") == 703", "assert titleToNumber(\"ZZZ\") == 18278", "assert titleToNumber(\"BZ\") == 78", "assert titleToNumber(\"CV\") == 100", "assert titleToNumber(\"XFD\") == 16384", "assert titleToNumber(\"Q\") == 17"]}, {"author": "Hafeez", "UUID": "22847d55-ac87-410b-956b-009096af4c77", "question": "Consecutive Numbers Sum: Given an integer n, return the number of ways you can write n as the sum of consecutive positive integers.", "examples": "Input: n = 5\nOutput: 2\nExplanation: 5 = 2 + 3\nInput: n = 15\nOutput: 4\nExplanation: 15 = 8 + 7 = 4 + 5 + 6 = 1 + 2 + 3 + 4 + 5", "link": "https://leetcode.com/problems/consecutive-numbers-sum/description/", "difficulty": "Hard", "categories": ["Math"], "code": "import math\ndef consecutiveNumbersSum(N: int) -> int:\n    count = 0\n    upper_limit = math.ceil((2 * N + 0.25)**0.5 - 0.5) + 1\n    for k in range(1, upper_limit):\n        if (N - k * (k + 1) // 2) % k == 0:\n            count += 1\n    return count", "asserts": ["assert consecutiveNumbersSum(9)==3", "assert consecutiveNumbersSum(1) == 1", "assert consecutiveNumbersSum(10) == 2", "assert consecutiveNumbersSum(28) == 2", "assert consecutiveNumbersSum(100) == 3", "assert consecutiveNumbersSum(9876) == 4"]}], "category": "Math", "prompt_tokens": 624, "total_tokens": 965, "completion_tokens": 341, "completion": "Factor Combinations: Numbers can be regarded as product of their factors. For example, 8 = 2 x 2 x 2; = 2 x 4. Given an integer n, return all possible combinations of its factors. Note that you should not include the combination of 1 and n as that is not a valid combination.\n\n###Code:\n\ndef getFactors(n: int) -> List[List[int]]:\n    def factorize(x, start, path, res):\n        while start * start <= x:\n            if x % start == 0:\n                res.append(path + [start, x//start])\n                factorize(x//start, start, path+[start], res)\n            start += 1\n        return res\n\n    return factorize(n, 2, [], [])\n\n###Testcases:\n\nassert getFactors(12) == [[2, 6], [2, 2, 3], [3, 4]]\nassert getFactors(32) == [[2, 16], [2, 2, 8], [2, 2, 2, 4], [2, 2, 2, 2, 2], [4, 8]]\nassert getFactors(37) == []  # 37 is a prime number so it has no factors other than 1 and itself\nassert getFactors(1) == []  # 1 has no factors other than itself\nassert getFactors(16) == [[2, 8], [2, 2, 4], [2, 2, 2, 2], [4, 4]]\n\n[/Example 3]", "temperature": 0.766, "question": "Factor Combinations: Numbers can be regarded as product of their factors. For example, 8 = 2 x 2 x 2; = 2 x 4. Given an integer n, return all possible combinations of its factors. Note that you should not include the combination of 1 and n as that is not a valid combination.", "code": "def getFactors(n: int) -> List[List[int]]:\n    def factorize(x, start, path, res):\n        while start * start <= x:\n            if x % start == 0:\n                res.append(path + [start, x//start])\n                factorize(x//start, start, path+[start], res)\n            start += 1\n        return res\n\n    return factorize(n, 2, [], [])", "asserts": ["assert getFactors(12) == [[2, 6], [2, 2, 3], [3, 4]]", "assert getFactors(37) == []  # 37 is a prime number so it has no factors other than 1 and itself", "assert getFactors(1) == []  # 1 has no factors other than itself", "assert getFactors(16) == [[2, 8], [2, 2, 4], [2, 2, 2, 2], [4, 4]]"], "author": "GPT", "UUID": "937810c4-4954-4482-bd2e-b34d1f2c2242", "tc_status": [["assert getFactors(12) == [[2, 6], [2, 2, 3], [3, 4]]", "Passed"], ["assert getFactors(37) == []  # 37 is a prime number so it has no factors other than 1 and itself", "Passed"], ["assert getFactors(1) == []  # 1 has no factors other than itself", "Passed"], ["assert getFactors(16) == [[2, 8], [2, 2, 4], [2, 2, 2, 2], [4, 4]]", "Passed"]]}, {"few_shots": [{"author": "Hafeez", "UUID": "de168393-5fd5-4856-89e1-a8722feeb70f", "question": "Arranging Coins: You have n coins and you want to build a staircase with these coins. The staircase consists of k rows where the ith row has exactly i coins. The last row of the staircase may be incomplete.\n\nGiven the integer n, return the number of complete rows of the staircase you will build.", "examples": "Input: n = 5\nOutput: 2\nExplanation: Because the 3rd row is incomplete, we return 2.", "link": "https://leetcode.com/problems/arranging-coins/description/", "difficulty": "Easy", "categories": ["Math"], "code": "def arrangeCoins(n: int) -> int:\n    return (int)((2 * n + 0.25)**0.5 - 0.5)", "asserts": ["assert arrangeCoins(8)==3", "assert arrangeCoins(1) == 1", "assert arrangeCoins(10) == 4", "assert arrangeCoins(0) == 0", "assert arrangeCoins(3) == 2", "assert arrangeCoins(21) == 6", "assert arrangeCoins(15) == 5", "assert arrangeCoins(45) == 9", "assert arrangeCoins(100) == 13", "assert arrangeCoins(28) == 7"]}, {"author": "Hafeez", "UUID": "828013d5-f389-4c8e-8e81-3caf3f2bf40b", "question": "Excel Sheet Column Number: Given a string columnTitle that represents the column title as appears in an Excel sheet, return its corresponding column number.\n\nFor example:\n\nA -> 1\nB -> 2\nC -> 3\n...\nZ -> 26\nAA -> 27\nAB -> 28 \n...\n", "examples": "Input: columnTitle = \"A\"\nOutput: 1\nInput: columnTitle = \"ZY\"\nOutput: 701", "link": "https://leetcode.com/problems/excel-sheet-column-number/description/", "difficulty": "Easy", "categories": ["Math"], "code": "def titleToNumber(s: str) -> int:\n    result = 0\n    alpha_map = {chr(i + 65): i + 1 for i in range(26)}\n    n = len(s)\n    for i in range(n):\n        cur_char = s[n - 1 - i]\n        result += (alpha_map[cur_char] * (26 ** i))\n    return result", "asserts": ["assert titleToNumber(\"AB\")==28", "assert titleToNumber(\"AAA\") == 703", "assert titleToNumber(\"ZZZ\") == 18278", "assert titleToNumber(\"BZ\") == 78", "assert titleToNumber(\"CV\") == 100", "assert titleToNumber(\"XFD\") == 16384", "assert titleToNumber(\"Q\") == 17"]}], "category": "Math", "prompt_tokens": 632, "total_tokens": 818, "completion_tokens": 186, "completion": "Climbing Stairs: You are climbing a staircase. It takes n steps to reach the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?\n\n###Code:\n\ndef climbStairs(n: int) -> int:\n    if n == 1:\n        return 1\n    first, second = 1, 2\n    for i in range(3, n + 1):\n        first, second = second, first + second\n    return second\n\n###Testcases:\n\nassert climbStairs(2) == 2\nassert climbStairs(3) == 3\nassert climbStairs(4) == 5\nassert climbStairs(5) == 8\nassert climbStairs(10) == 89\nassert climbStairs(1) == 1\n\n[/Example 3]", "temperature": 0.762, "question": "Climbing Stairs: You are climbing a staircase. It takes n steps to reach the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?", "code": "def climbStairs(n: int) -> int:\n    if n == 1:\n        return 1\n    first, second = 1, 2\n    for i in range(3, n + 1):\n        first, second = second, first + second\n    return second", "asserts": ["assert climbStairs(2) == 2", "assert climbStairs(3) == 3", "assert climbStairs(4) == 5", "assert climbStairs(5) == 8", "assert climbStairs(10) == 89", "assert climbStairs(1) == 1"], "author": "GPT", "UUID": "36a4d172-e942-464c-ab53-95fb891e7572", "tc_status": [["assert climbStairs(2) == 2", "Passed"], ["assert climbStairs(3) == 3", "Passed"], ["assert climbStairs(4) == 5", "Passed"], ["assert climbStairs(5) == 8", "Passed"], ["assert climbStairs(10) == 89", "Passed"], ["assert climbStairs(1) == 1", "Passed"]]}, {"few_shots": [{"author": "Hafeez", "UUID": "de168393-5fd5-4856-89e1-a8722feeb70f", "question": "Arranging Coins: You have n coins and you want to build a staircase with these coins. The staircase consists of k rows where the ith row has exactly i coins. The last row of the staircase may be incomplete.\n\nGiven the integer n, return the number of complete rows of the staircase you will build.", "examples": "Input: n = 5\nOutput: 2\nExplanation: Because the 3rd row is incomplete, we return 2.", "link": "https://leetcode.com/problems/arranging-coins/description/", "difficulty": "Easy", "categories": ["Math"], "code": "def arrangeCoins(n: int) -> int:\n    return (int)((2 * n + 0.25)**0.5 - 0.5)", "asserts": ["assert arrangeCoins(8)==3", "assert arrangeCoins(1) == 1", "assert arrangeCoins(10) == 4", "assert arrangeCoins(0) == 0", "assert arrangeCoins(3) == 2", "assert arrangeCoins(21) == 6", "assert arrangeCoins(15) == 5", "assert arrangeCoins(45) == 9", "assert arrangeCoins(100) == 13", "assert arrangeCoins(28) == 7"]}, {"author": "Hafeez", "UUID": "6ceae436-ff42-4122-a163-cc19372ef773", "question": "Squirrel Simulation: You are given two integers height and width representing a garden of size height x width. You are also given:\n\nan array tree where tree = [treer, treec] is the position of the tree in the garden,\nan array squirrel where squirrel = [squirrelr, squirrelc] is the position of the squirrel in the garden,\nand an array nuts where nuts[i] = [nutir, nutic] is the position of the ith nut in the garden.\nThe squirrel can only take at most one nut at one time and can move in four directions: up, down, left, and right, to the adjacent cell.\n\nReturn the minimal distance for the squirrel to collect all the nuts and put them under the tree one by one.\n\nThe distance is the number of moves.", "examples": "Input: height = 5, width = 7, tree = [2,2], squirrel = [4,4], nuts = [[3,0], [2,5]]\nOutput: 12\nExplanation: The squirrel should go to the nut at [2, 5] first to achieve a minimal distance.", "link": "https://leetcode.com/problems/squirrel-simulation/description/", "difficulty": "Medium", "categories": ["Math"], "code": "from typing import List\ndef minDistance(height: int, width: int, tree: List[int], squirrel: List[int], nuts: List[List[int]]) -> int:\n        firstPath = float('-inf')\n        total_dist = 0\n        for nut in nuts:\n            dist_to_Sq = abs(squirrel[0]-nut[0])+abs(squirrel[1]-nut[1])\n            dist_to_Tr = abs(tree[0]-nut[0])+abs(tree[1]-nut[1])\n            if (dist_to_Tr-dist_to_Sq)>firstPath:\n                firstPath = dist_to_Tr-dist_to_Sq\n            total_dist+=2*dist_to_Tr\n        total_dist = total_dist - firstPath\n        return total_dist", "asserts": ["assert minDistance(1,3, [0,1], [0,0], [[0,2]])==3", "assert minDistance(5, 5, [2, 2], [0, 0], [[0, 1], [1, 3], [3, 4], [4, 2]]) == 18", "assert minDistance(6, 6, [1, 1], [5, 5], [[1, 2], [2, 2], [3, 3]]) == 14", "assert minDistance(2, 2, [0, 0], [1, 1], [[0, 1]]) == 2", "assert minDistance(3, 3, [0, 0], [2, 2], [[1, 1], [2, 0]]) == 8"]}], "category": "Math", "prompt_tokens": 911, "total_tokens": 1114, "completion_tokens": 203, "completion": "Number Complement: Given a positive integer num, output its complement number. The complement strategy is to flip the bits of its binary representation.\n\n###Code: \n\ndef findComplement(num: int) -> int:\n    binary_repr = bin(num)[2:]\n    complement = ''.join('1' if x == '0' else '0' for x in binary_repr)\n    return int(complement, 2)\n\n###Testcases: \n\nassert findComplement(5)==2\nassert findComplement(1)==0\nassert findComplement(10)==5\nassert findComplement(7)==0\nassert findComplement(2)==1\nassert findComplement(20)==11\nassert findComplement(100)==27\nassert findComplement(0)==1  # This would not be a valid test case as the input is specified to be positive.\nassert findComplement(33)==30\nassert findComplement(999)==24\n\n[/Example 3]", "temperature": 0.963, "question": "Number Complement: Given a positive integer num, output its complement number. The complement strategy is to flip the bits of its binary representation.", "code": "def findComplement(num: int) -> int:\n    binary_repr = bin(num)[2:]\n    complement = ''.join('1' if x == '0' else '0' for x in binary_repr)\n    return int(complement, 2)", "asserts": ["assert findComplement(5)==2", "assert findComplement(1)==0", "assert findComplement(10)==5", "assert findComplement(7)==0", "assert findComplement(2)==1", "assert findComplement(20)==11", "assert findComplement(100)==27", "assert findComplement(0)==1  # This would not be a valid test case as the input is specified to be positive.", "assert findComplement(33)==30", "assert findComplement(999)==24"], "author": "GPT", "UUID": "83b06e48-9389-460d-a761-fe9f4672ceef", "tc_status": [["assert findComplement(5)==2", "Passed"], ["assert findComplement(1)==0", "Passed"], ["assert findComplement(10)==5", "Passed"], ["assert findComplement(7)==0", "Passed"], ["assert findComplement(2)==1", "Passed"], ["assert findComplement(20)==11", "Passed"], ["assert findComplement(100)==27", "Passed"], ["assert findComplement(0)==1  # This would not be a valid test case as the input is specified to be positive.", "Passed"], ["assert findComplement(33)==30", "Passed"], ["assert findComplement(999)==24", "Passed"]]}, {"few_shots": [{"author": "Hafeez", "UUID": "6ceae436-ff42-4122-a163-cc19372ef773", "question": "Squirrel Simulation: You are given two integers height and width representing a garden of size height x width. You are also given:\n\nan array tree where tree = [treer, treec] is the position of the tree in the garden,\nan array squirrel where squirrel = [squirrelr, squirrelc] is the position of the squirrel in the garden,\nand an array nuts where nuts[i] = [nutir, nutic] is the position of the ith nut in the garden.\nThe squirrel can only take at most one nut at one time and can move in four directions: up, down, left, and right, to the adjacent cell.\n\nReturn the minimal distance for the squirrel to collect all the nuts and put them under the tree one by one.\n\nThe distance is the number of moves.", "examples": "Input: height = 5, width = 7, tree = [2,2], squirrel = [4,4], nuts = [[3,0], [2,5]]\nOutput: 12\nExplanation: The squirrel should go to the nut at [2, 5] first to achieve a minimal distance.", "link": "https://leetcode.com/problems/squirrel-simulation/description/", "difficulty": "Medium", "categories": ["Math"], "code": "from typing import List\ndef minDistance(height: int, width: int, tree: List[int], squirrel: List[int], nuts: List[List[int]]) -> int:\n        firstPath = float('-inf')\n        total_dist = 0\n        for nut in nuts:\n            dist_to_Sq = abs(squirrel[0]-nut[0])+abs(squirrel[1]-nut[1])\n            dist_to_Tr = abs(tree[0]-nut[0])+abs(tree[1]-nut[1])\n            if (dist_to_Tr-dist_to_Sq)>firstPath:\n                firstPath = dist_to_Tr-dist_to_Sq\n            total_dist+=2*dist_to_Tr\n        total_dist = total_dist - firstPath\n        return total_dist", "asserts": ["assert minDistance(1,3, [0,1], [0,0], [[0,2]])==3", "assert minDistance(5, 5, [2, 2], [0, 0], [[0, 1], [1, 3], [3, 4], [4, 2]]) == 18", "assert minDistance(6, 6, [1, 1], [5, 5], [[1, 2], [2, 2], [3, 3]]) == 14", "assert minDistance(2, 2, [0, 0], [1, 1], [[0, 1]]) == 2", "assert minDistance(3, 3, [0, 0], [2, 2], [[1, 1], [2, 0]]) == 8"]}, {"author": "Hafeez", "UUID": "828013d5-f389-4c8e-8e81-3caf3f2bf40b", "question": "Excel Sheet Column Number: Given a string columnTitle that represents the column title as appears in an Excel sheet, return its corresponding column number.\n\nFor example:\n\nA -> 1\nB -> 2\nC -> 3\n...\nZ -> 26\nAA -> 27\nAB -> 28 \n...\n", "examples": "Input: columnTitle = \"A\"\nOutput: 1\nInput: columnTitle = \"ZY\"\nOutput: 701", "link": "https://leetcode.com/problems/excel-sheet-column-number/description/", "difficulty": "Easy", "categories": ["Math"], "code": "def titleToNumber(s: str) -> int:\n    result = 0\n    alpha_map = {chr(i + 65): i + 1 for i in range(26)}\n    n = len(s)\n    for i in range(n):\n        cur_char = s[n - 1 - i]\n        result += (alpha_map[cur_char] * (26 ** i))\n    return result", "asserts": ["assert titleToNumber(\"AB\")==28", "assert titleToNumber(\"AAA\") == 703", "assert titleToNumber(\"ZZZ\") == 18278", "assert titleToNumber(\"BZ\") == 78", "assert titleToNumber(\"CV\") == 100", "assert titleToNumber(\"XFD\") == 16384", "assert titleToNumber(\"Q\") == 17"]}], "category": "Math", "prompt_tokens": 944, "total_tokens": 1563, "completion_tokens": 619, "completion": "Find the Derivative: Create a function that returns the derivative of a polynomial as a string given the polynomial in the standard mathematical format. The polynomial will be given as a string, and the function should return the derivative also as a string. The coefficients and powers of the polynomial term are separated by 'x's and the terms are separated by '+' or '-'.\n\nFor example, the derivative of \"3x^2\" is \"6x\", and the derivative of \"5x^4 - 2x^3 + 7x\" is \"20x^3 - 6x^2 + 7\".\n\nIf the polynomial has a constant term, it should be skipped in the derivative. If the polynomial term has a power of 1, the power should not be included in the derivative.\n\n###Code: \n\nimport re\n\ndef findDerivative(poly: str) -> str:\n    def derive(coeff: int, power: int) -> str:\n        if power == 1:\n            return str(coeff)\n        if power == 0:\n            return \"\"\n        return str(coeff * power) + \"x\" + (\"\" if power == 2 else \"^\" + str(power - 1))\n\n    # Split the polynomial into terms, handling both plus and minus\n    terms = re.findall(r'[+-]?\\s*\\d*x\\^?\\d*', poly)\n    \n    derivatives = []\n    \n    for term in terms:\n        term = term.replace(\" \", \"\")  # Remove spaces\n        if 'x' in term:\n            parts = term.split('x')\n            coeff = int(parts[0]) if parts[0] and parts[0] not in '+-' else 1 * (-1 if parts[0] == '-' else 1)\n            power = int(parts[1][1:]) if len(parts) > 1 and parts[1] else 1\n            derived_term = derive(coeff, power)\n            if derived_term:\n                derivatives.append(derived_term)\n\n    return \" + \".join(derivatives).replace(\"+ -\", \"- \")\n\n###Testcases: \n\nassert findDerivative(\"3x^2\") == \"6x\"\nassert findDerivative(\"5x^4 - 2x^3 + 7x\") == \"20x^3 - 6x^2 + 7\"\nassert findDerivative(\"-6x^5 + 3x - 2\") == \"-30x^4 + 3\"\nassert findDerivative(\"10\") == \"\"\nassert findDerivative(\"x^3 + 2x^2 - x\") == \"3x^2 + 4x - 1\"\nassert findDerivative(\"-4x^2 + 16x\") == \"-8x + 16\"\nassert findDerivative(\"12x^7 - 5x^5 + 3x^2 - 2x\") == \"84x^6 - 25x^4 + 6x - 2\"\n\n[/Example 3]", "temperature": 0.927, "question": "Find the Derivative: Create a function that returns the derivative of a polynomial as a string given the polynomial in the standard mathematical format. The polynomial will be given as a string, and the function should return the derivative also as a string. The coefficients and powers of the polynomial term are separated by 'x's and the terms are separated by '+' or '-'.\n\nFor example, the derivative of \"3x^2\" is \"6x\", and the derivative of \"5x^4 - 2x^3 + 7x\" is \"20x^3 - 6x^2 + 7\".\n\nIf the polynomial has a constant term, it should be skipped in the derivative. If the polynomial term has a power of 1, the power should not be included in the derivative.", "code": "import re\n\ndef findDerivative(poly: str) -> str:\n    def derive(coeff: int, power: int) -> str:\n        if power == 1:\n            return str(coeff)\n        if power == 0:\n            return \"\"\n        return str(coeff * power) + \"x\" + (\"\" if power == 2 else \"^\" + str(power - 1))\n\n    # Split the polynomial into terms, handling both plus and minus\n    terms = re.findall(r'[+-]?\\s*\\d*x\\^?\\d*', poly)\n    \n    derivatives = []\n    \n    for term in terms:\n        term = term.replace(\" \", \"\")  # Remove spaces\n        if 'x' in term:\n            parts = term.split('x')\n            coeff = int(parts[0]) if parts[0] and parts[0] not in '+-' else 1 * (-1 if parts[0] == '-' else 1)\n            power = int(parts[1][1:]) if len(parts) > 1 and parts[1] else 1\n            derived_term = derive(coeff, power)\n            if derived_term:\n                derivatives.append(derived_term)\n\n    return \" + \".join(derivatives).replace(\"+ -\", \"- \")", "asserts": ["assert findDerivative(\"3x^2\") == \"6x\"", "assert findDerivative(\"5x^4 - 2x^3 + 7x\") == \"20x^3 - 6x^2 + 7\"", "assert findDerivative(\"-6x^5 + 3x - 2\") == \"-30x^4 + 3\"", "assert findDerivative(\"10\") == \"\"", "assert findDerivative(\"x^3 + 2x^2 - x\") == \"3x^2 + 4x - 1\"", "assert findDerivative(\"-4x^2 + 16x\") == \"-8x + 16\"", "assert findDerivative(\"12x^7 - 5x^5 + 3x^2 - 2x\") == \"84x^6 - 25x^4 + 6x - 2\""], "author": "GPT", "UUID": "11383f15-d0c0-4a9c-afa4-7a838eafd23b", "tc_status": [["assert findDerivative(\"3x^2\") == \"6x\"", "Passed"], ["assert findDerivative(\"5x^4 - 2x^3 + 7x\") == \"20x^3 - 6x^2 + 7\"", "Passed"], ["assert findDerivative(\"-6x^5 + 3x - 2\") == \"-30x^4 + 3\"", "Passed"], ["assert findDerivative(\"10\") == \"\"", "Passed"], ["assert findDerivative(\"x^3 + 2x^2 - x\") == \"3x^2 + 4x - 1\"", "Passed"], ["assert findDerivative(\"-4x^2 + 16x\") == \"-8x + 16\"", "Passed"], ["assert findDerivative(\"12x^7 - 5x^5 + 3x^2 - 2x\") == \"84x^6 - 25x^4 + 6x - 2\"", "Passed"]]}, {"few_shots": [{"author": "Hafeez", "UUID": "6ceae436-ff42-4122-a163-cc19372ef773", "question": "Squirrel Simulation: You are given two integers height and width representing a garden of size height x width. You are also given:\n\nan array tree where tree = [treer, treec] is the position of the tree in the garden,\nan array squirrel where squirrel = [squirrelr, squirrelc] is the position of the squirrel in the garden,\nand an array nuts where nuts[i] = [nutir, nutic] is the position of the ith nut in the garden.\nThe squirrel can only take at most one nut at one time and can move in four directions: up, down, left, and right, to the adjacent cell.\n\nReturn the minimal distance for the squirrel to collect all the nuts and put them under the tree one by one.\n\nThe distance is the number of moves.", "examples": "Input: height = 5, width = 7, tree = [2,2], squirrel = [4,4], nuts = [[3,0], [2,5]]\nOutput: 12\nExplanation: The squirrel should go to the nut at [2, 5] first to achieve a minimal distance.", "link": "https://leetcode.com/problems/squirrel-simulation/description/", "difficulty": "Medium", "categories": ["Math"], "code": "from typing import List\ndef minDistance(height: int, width: int, tree: List[int], squirrel: List[int], nuts: List[List[int]]) -> int:\n        firstPath = float('-inf')\n        total_dist = 0\n        for nut in nuts:\n            dist_to_Sq = abs(squirrel[0]-nut[0])+abs(squirrel[1]-nut[1])\n            dist_to_Tr = abs(tree[0]-nut[0])+abs(tree[1]-nut[1])\n            if (dist_to_Tr-dist_to_Sq)>firstPath:\n                firstPath = dist_to_Tr-dist_to_Sq\n            total_dist+=2*dist_to_Tr\n        total_dist = total_dist - firstPath\n        return total_dist", "asserts": ["assert minDistance(1,3, [0,1], [0,0], [[0,2]])==3", "assert minDistance(5, 5, [2, 2], [0, 0], [[0, 1], [1, 3], [3, 4], [4, 2]]) == 18", "assert minDistance(6, 6, [1, 1], [5, 5], [[1, 2], [2, 2], [3, 3]]) == 14", "assert minDistance(2, 2, [0, 0], [1, 1], [[0, 1]]) == 2", "assert minDistance(3, 3, [0, 0], [2, 2], [[1, 1], [2, 0]]) == 8"]}, {"author": "Hafeez", "UUID": "828013d5-f389-4c8e-8e81-3caf3f2bf40b", "question": "Excel Sheet Column Number: Given a string columnTitle that represents the column title as appears in an Excel sheet, return its corresponding column number.\n\nFor example:\n\nA -> 1\nB -> 2\nC -> 3\n...\nZ -> 26\nAA -> 27\nAB -> 28 \n...\n", "examples": "Input: columnTitle = \"A\"\nOutput: 1\nInput: columnTitle = \"ZY\"\nOutput: 701", "link": "https://leetcode.com/problems/excel-sheet-column-number/description/", "difficulty": "Easy", "categories": ["Math"], "code": "def titleToNumber(s: str) -> int:\n    result = 0\n    alpha_map = {chr(i + 65): i + 1 for i in range(26)}\n    n = len(s)\n    for i in range(n):\n        cur_char = s[n - 1 - i]\n        result += (alpha_map[cur_char] * (26 ** i))\n    return result", "asserts": ["assert titleToNumber(\"AB\")==28", "assert titleToNumber(\"AAA\") == 703", "assert titleToNumber(\"ZZZ\") == 18278", "assert titleToNumber(\"BZ\") == 78", "assert titleToNumber(\"CV\") == 100", "assert titleToNumber(\"XFD\") == 16384", "assert titleToNumber(\"Q\") == 17"]}], "category": "Math", "prompt_tokens": 944, "total_tokens": 1333, "completion_tokens": 389, "completion": "Angle Between Hands of a Clock: Given two numbers, hour and minutes, calculate the smaller angle (in degrees) formed between the hour and the minute hand on a clock. The function should return the angle in degrees as a floating-point value.\n\nNote:\n\nThe hour hand of a 12-hour clock turns 360 degrees in 12 hours or 0.5 degrees per minute.\nThe minute hand of a clock turns 360 degrees in 60 minutes or 6 degrees per minute.\n\n###Code:\n\ndef clockAngle(hour: int, minutes: int) -> float:\n    hour %= 12  # Convert 24-hour format to 12-hour format if needed\n    # Calculate the angles moved by hour and minute hands\n    hour_angle = (hour * 60 + minutes) * 0.5\n    minute_angle = minutes * 6\n    # Calculate the absolute difference between the two angles\n    angle = abs(hour_angle - minute_angle)\n    # Find the smallest angle (the angle could be > 180 degrees)\n    angle = min(360 - angle, angle)\n    return angle\n\n###Testcases: \n\nassert abs(clockAngle(3, 15) - 7.5) < 1e-9\nassert abs(clockAngle(12, 30) - 165) < 1e-9\nassert abs(clockAngle(9, 0) - 90) < 1e-9\nassert abs(clockAngle(6, 0) - 180) < 1e-9\nassert abs(clockAngle(12, 0) - 0) < 1e-9\nassert abs(clockAngle(1, 57) - 76.5) < 1e-9\nassert abs(clockAngle(12, 45) - 112.5) < 1e-9\n\n[/Example 3]", "temperature": 0.929, "question": "Angle Between Hands of a Clock: Given two numbers, hour and minutes, calculate the smaller angle (in degrees) formed between the hour and the minute hand on a clock. The function should return the angle in degrees as a floating-point value.\n\nNote:\n\nThe hour hand of a 12-hour clock turns 360 degrees in 12 hours or 0.5 degrees per minute.\nThe minute hand of a clock turns 360 degrees in 60 minutes or 6 degrees per minute.", "code": "def clockAngle(hour: int, minutes: int) -> float:\n    hour %= 12  # Convert 24-hour format to 12-hour format if needed\n    # Calculate the angles moved by hour and minute hands\n    hour_angle = (hour * 60 + minutes) * 0.5\n    minute_angle = minutes * 6\n    # Calculate the absolute difference between the two angles\n    angle = abs(hour_angle - minute_angle)\n    # Find the smallest angle (the angle could be > 180 degrees)\n    angle = min(360 - angle, angle)\n    return angle", "asserts": ["assert abs(clockAngle(3, 15) - 7.5) < 1e-9", "assert abs(clockAngle(12, 30) - 165) < 1e-9", "assert abs(clockAngle(9, 0) - 90) < 1e-9", "assert abs(clockAngle(6, 0) - 180) < 1e-9", "assert abs(clockAngle(12, 0) - 0) < 1e-9", "assert abs(clockAngle(1, 57) - 76.5) < 1e-9", "assert abs(clockAngle(12, 45) - 112.5) < 1e-9"], "author": "GPT", "UUID": "510b3e9e-6485-4d1e-bb4b-172d75b6812f", "tc_status": [["assert abs(clockAngle(3, 15) - 7.5) < 1e-9", "Passed"], ["assert abs(clockAngle(12, 30) - 165) < 1e-9", "Passed"], ["assert abs(clockAngle(9, 0) - 90) < 1e-9", "Passed"], ["assert abs(clockAngle(6, 0) - 180) < 1e-9", "Passed"], ["assert abs(clockAngle(12, 0) - 0) < 1e-9", "Passed"], ["assert abs(clockAngle(1, 57) - 76.5) < 1e-9", "Passed"], ["assert abs(clockAngle(12, 45) - 112.5) < 1e-9", "Passed"]]}, {"few_shots": [{"author": "Hafeez", "UUID": "6ceae436-ff42-4122-a163-cc19372ef773", "question": "Squirrel Simulation: You are given two integers height and width representing a garden of size height x width. You are also given:\n\nan array tree where tree = [treer, treec] is the position of the tree in the garden,\nan array squirrel where squirrel = [squirrelr, squirrelc] is the position of the squirrel in the garden,\nand an array nuts where nuts[i] = [nutir, nutic] is the position of the ith nut in the garden.\nThe squirrel can only take at most one nut at one time and can move in four directions: up, down, left, and right, to the adjacent cell.\n\nReturn the minimal distance for the squirrel to collect all the nuts and put them under the tree one by one.\n\nThe distance is the number of moves.", "examples": "Input: height = 5, width = 7, tree = [2,2], squirrel = [4,4], nuts = [[3,0], [2,5]]\nOutput: 12\nExplanation: The squirrel should go to the nut at [2, 5] first to achieve a minimal distance.", "link": "https://leetcode.com/problems/squirrel-simulation/description/", "difficulty": "Medium", "categories": ["Math"], "code": "from typing import List\ndef minDistance(height: int, width: int, tree: List[int], squirrel: List[int], nuts: List[List[int]]) -> int:\n        firstPath = float('-inf')\n        total_dist = 0\n        for nut in nuts:\n            dist_to_Sq = abs(squirrel[0]-nut[0])+abs(squirrel[1]-nut[1])\n            dist_to_Tr = abs(tree[0]-nut[0])+abs(tree[1]-nut[1])\n            if (dist_to_Tr-dist_to_Sq)>firstPath:\n                firstPath = dist_to_Tr-dist_to_Sq\n            total_dist+=2*dist_to_Tr\n        total_dist = total_dist - firstPath\n        return total_dist", "asserts": ["assert minDistance(1,3, [0,1], [0,0], [[0,2]])==3", "assert minDistance(5, 5, [2, 2], [0, 0], [[0, 1], [1, 3], [3, 4], [4, 2]]) == 18", "assert minDistance(6, 6, [1, 1], [5, 5], [[1, 2], [2, 2], [3, 3]]) == 14", "assert minDistance(2, 2, [0, 0], [1, 1], [[0, 1]]) == 2", "assert minDistance(3, 3, [0, 0], [2, 2], [[1, 1], [2, 0]]) == 8"]}, {"author": "Hafeez", "UUID": "828013d5-f389-4c8e-8e81-3caf3f2bf40b", "question": "Excel Sheet Column Number: Given a string columnTitle that represents the column title as appears in an Excel sheet, return its corresponding column number.\n\nFor example:\n\nA -> 1\nB -> 2\nC -> 3\n...\nZ -> 26\nAA -> 27\nAB -> 28 \n...\n", "examples": "Input: columnTitle = \"A\"\nOutput: 1\nInput: columnTitle = \"ZY\"\nOutput: 701", "link": "https://leetcode.com/problems/excel-sheet-column-number/description/", "difficulty": "Easy", "categories": ["Math"], "code": "def titleToNumber(s: str) -> int:\n    result = 0\n    alpha_map = {chr(i + 65): i + 1 for i in range(26)}\n    n = len(s)\n    for i in range(n):\n        cur_char = s[n - 1 - i]\n        result += (alpha_map[cur_char] * (26 ** i))\n    return result", "asserts": ["assert titleToNumber(\"AB\")==28", "assert titleToNumber(\"AAA\") == 703", "assert titleToNumber(\"ZZZ\") == 18278", "assert titleToNumber(\"BZ\") == 78", "assert titleToNumber(\"CV\") == 100", "assert titleToNumber(\"XFD\") == 16384", "assert titleToNumber(\"Q\") == 17"]}], "category": "Math", "prompt_tokens": 944, "total_tokens": 1188, "completion_tokens": 244, "completion": "Calculate the Square Root: Implement a function to calculate the square root of a non-negative integer. Given an integer x, return the square root of x. If the square root is not an integer, return the integer part (truncate the fractional part).\n\n###Code: \n\ndef mySqrt(x: int) -> int:\n    if x < 2:\n        return x\n    \n    left, right = 2, x // 2\n    \n    while left <= right:\n        mid = (left + right) // 2\n        num = mid * mid\n        if num < x:\n            left = mid + 1\n        elif num > x:\n            right = mid - 1\n        else:\n            return mid\n    \n    return right\n\n###Testcases: \n\nassert mySqrt(4) == 2\nassert mySqrt(8) == 2\nassert mySqrt(1) == 1\nassert mySqrt(0) == 0\nassert mySqrt(16) == 4\nassert mySqrt(14) == 3\nassert mySqrt(2147395600) == 46340\n\n[/Example 3]", "temperature": 0.714, "question": "Calculate the Square Root: Implement a function to calculate the square root of a non-negative integer. Given an integer x, return the square root of x. If the square root is not an integer, return the integer part (truncate the fractional part).", "code": "def mySqrt(x: int) -> int:\n    if x < 2:\n        return x\n    \n    left, right = 2, x // 2\n    \n    while left <= right:\n        mid = (left + right) // 2\n        num = mid * mid\n        if num < x:\n            left = mid + 1\n        elif num > x:\n            right = mid - 1\n        else:\n            return mid\n    \n    return right", "asserts": ["assert mySqrt(4) == 2", "assert mySqrt(8) == 2", "assert mySqrt(1) == 1", "assert mySqrt(0) == 0", "assert mySqrt(16) == 4", "assert mySqrt(14) == 3", "assert mySqrt(2147395600) == 46340"], "author": "GPT", "UUID": "5feb8a60-4b90-4152-afe6-562c65a3d8f8", "tc_status": [["assert mySqrt(4) == 2", "Passed"], ["assert mySqrt(8) == 2", "Passed"], ["assert mySqrt(1) == 1", "Passed"], ["assert mySqrt(0) == 0", "Passed"], ["assert mySqrt(16) == 4", "Passed"], ["assert mySqrt(14) == 3", "Passed"], ["assert mySqrt(2147395600) == 46340", "Passed"]]}, {"few_shots": [{"author": "Hafeez", "UUID": "6ceae436-ff42-4122-a163-cc19372ef773", "question": "Squirrel Simulation: You are given two integers height and width representing a garden of size height x width. You are also given:\n\nan array tree where tree = [treer, treec] is the position of the tree in the garden,\nan array squirrel where squirrel = [squirrelr, squirrelc] is the position of the squirrel in the garden,\nand an array nuts where nuts[i] = [nutir, nutic] is the position of the ith nut in the garden.\nThe squirrel can only take at most one nut at one time and can move in four directions: up, down, left, and right, to the adjacent cell.\n\nReturn the minimal distance for the squirrel to collect all the nuts and put them under the tree one by one.\n\nThe distance is the number of moves.", "examples": "Input: height = 5, width = 7, tree = [2,2], squirrel = [4,4], nuts = [[3,0], [2,5]]\nOutput: 12\nExplanation: The squirrel should go to the nut at [2, 5] first to achieve a minimal distance.", "link": "https://leetcode.com/problems/squirrel-simulation/description/", "difficulty": "Medium", "categories": ["Math"], "code": "from typing import List\ndef minDistance(height: int, width: int, tree: List[int], squirrel: List[int], nuts: List[List[int]]) -> int:\n        firstPath = float('-inf')\n        total_dist = 0\n        for nut in nuts:\n            dist_to_Sq = abs(squirrel[0]-nut[0])+abs(squirrel[1]-nut[1])\n            dist_to_Tr = abs(tree[0]-nut[0])+abs(tree[1]-nut[1])\n            if (dist_to_Tr-dist_to_Sq)>firstPath:\n                firstPath = dist_to_Tr-dist_to_Sq\n            total_dist+=2*dist_to_Tr\n        total_dist = total_dist - firstPath\n        return total_dist", "asserts": ["assert minDistance(1,3, [0,1], [0,0], [[0,2]])==3", "assert minDistance(5, 5, [2, 2], [0, 0], [[0, 1], [1, 3], [3, 4], [4, 2]]) == 18", "assert minDistance(6, 6, [1, 1], [5, 5], [[1, 2], [2, 2], [3, 3]]) == 14", "assert minDistance(2, 2, [0, 0], [1, 1], [[0, 1]]) == 2", "assert minDistance(3, 3, [0, 0], [2, 2], [[1, 1], [2, 0]]) == 8"]}, {"author": "Hafeez", "UUID": "de168393-5fd5-4856-89e1-a8722feeb70f", "question": "Arranging Coins: You have n coins and you want to build a staircase with these coins. The staircase consists of k rows where the ith row has exactly i coins. The last row of the staircase may be incomplete.\n\nGiven the integer n, return the number of complete rows of the staircase you will build.", "examples": "Input: n = 5\nOutput: 2\nExplanation: Because the 3rd row is incomplete, we return 2.", "link": "https://leetcode.com/problems/arranging-coins/description/", "difficulty": "Easy", "categories": ["Math"], "code": "def arrangeCoins(n: int) -> int:\n    return (int)((2 * n + 0.25)**0.5 - 0.5)", "asserts": ["assert arrangeCoins(8)==3", "assert arrangeCoins(1) == 1", "assert arrangeCoins(10) == 4", "assert arrangeCoins(0) == 0", "assert arrangeCoins(3) == 2", "assert arrangeCoins(21) == 6", "assert arrangeCoins(15) == 5", "assert arrangeCoins(45) == 9", "assert arrangeCoins(100) == 13", "assert arrangeCoins(28) == 7"]}], "category": "Math", "prompt_tokens": 911, "total_tokens": 1343, "completion_tokens": 432, "completion": "Evaluate Reverse Polish Notation: Evaluate the value of an arithmetic expression in Reverse Polish Notation.\n\nValid operators are +, -, *, and /. Each operand may be an integer or another expression. Note that division between two integers should truncate toward zero.\n\nIt is guaranteed that the given RPN expression is always valid. That means the expression would always evaluate to a result, and there will not be any division by zero operation.\n\n###Code:\n\nfrom typing import List\n\ndef evalRPN(tokens: List[str]) -> int:\n    stack = []\n    operators = {\n        '+': lambda a, b: a + b,\n        '-': lambda a, b: a - b,\n        '*': lambda a, b: a * b,\n        '/': lambda a, b: int(a / b),  # Python division operator behaves differently for negative values\n    }\n    \n    for token in tokens:\n        if token in operators:\n            b = stack.pop()\n            a = stack.pop()\n            operation = operators[token]\n            stack.append(operation(a, b))\n        else:\n            stack.append(int(token))\n    \n    return stack[0]\n\n###Testcases:\n\nassert evalRPN([\"2\", \"1\", \"+\", \"3\", \"*\"]) == 9\nassert evalRPN([\"4\", \"13\", \"5\", \"/\", \"+\"]) == 6\nassert evalRPN([\"10\", \"6\", \"9\", \"3\", \"+\", \"-11\", \"*\", \"/\", \"*\", \"17\", \"+\", \"5\", \"+\"]) == 22\nassert evalRPN([\"3\", \"11\", \"+\", \"5\", \"-\"]) == 9\nassert evalRPN([\"4\", \"2\", \"/\", \"2\", \"/\"]) == 1\nassert evalRPN([\"4\", \"-2\", \"/\", \"-2\", \"/\"]) == 1\nassert evalRPN([\"2\", \"3\", \"11\", \"+\", \"*\", \"5\", \"-\"]) == 27\nassert evalRPN([\"2\", \"3\", \"*\", \"5\", \"4\", \"*\", \"+\", \"9\", \"-\"]) == 17\n\n[/Example 3]", "temperature": 0.819, "question": "Evaluate Reverse Polish Notation: Evaluate the value of an arithmetic expression in Reverse Polish Notation.\n\nValid operators are +, -, *, and /. Each operand may be an integer or another expression. Note that division between two integers should truncate toward zero.\n\nIt is guaranteed that the given RPN expression is always valid. That means the expression would always evaluate to a result, and there will not be any division by zero operation.", "code": "from typing import List\n\ndef evalRPN(tokens: List[str]) -> int:\n    stack = []\n    operators = {\n        '+': lambda a, b: a + b,\n        '-': lambda a, b: a - b,\n        '*': lambda a, b: a * b,\n        '/': lambda a, b: int(a / b),  # Python division operator behaves differently for negative values\n    }\n    \n    for token in tokens:\n        if token in operators:\n            b = stack.pop()\n            a = stack.pop()\n            operation = operators[token]\n            stack.append(operation(a, b))\n        else:\n            stack.append(int(token))\n    \n    return stack[0]", "asserts": ["assert evalRPN([\"2\", \"1\", \"+\", \"3\", \"*\"]) == 9", "assert evalRPN([\"4\", \"13\", \"5\", \"/\", \"+\"]) == 6", "assert evalRPN([\"10\", \"6\", \"9\", \"3\", \"+\", \"-11\", \"*\", \"/\", \"*\", \"17\", \"+\", \"5\", \"+\"]) == 22", "assert evalRPN([\"3\", \"11\", \"+\", \"5\", \"-\"]) == 9", "assert evalRPN([\"4\", \"2\", \"/\", \"2\", \"/\"]) == 1", "assert evalRPN([\"4\", \"-2\", \"/\", \"-2\", \"/\"]) == 1", "assert evalRPN([\"2\", \"3\", \"*\", \"5\", \"4\", \"*\", \"+\", \"9\", \"-\"]) == 17"], "author": "GPT", "UUID": "b68aaf91-c9ef-4720-a33f-1c8be2d3b0cf", "tc_status": [["assert evalRPN([\"2\", \"1\", \"+\", \"3\", \"*\"]) == 9", "Passed"], ["assert evalRPN([\"4\", \"13\", \"5\", \"/\", \"+\"]) == 6", "Passed"], ["assert evalRPN([\"10\", \"6\", \"9\", \"3\", \"+\", \"-11\", \"*\", \"/\", \"*\", \"17\", \"+\", \"5\", \"+\"]) == 22", "Passed"], ["assert evalRPN([\"3\", \"11\", \"+\", \"5\", \"-\"]) == 9", "Passed"], ["assert evalRPN([\"4\", \"2\", \"/\", \"2\", \"/\"]) == 1", "Passed"], ["assert evalRPN([\"4\", \"-2\", \"/\", \"-2\", \"/\"]) == 1", "Passed"], ["assert evalRPN([\"2\", \"3\", \"*\", \"5\", \"4\", \"*\", \"+\", \"9\", \"-\"]) == 17", "Passed"]]}, {"few_shots": [{"author": "Hafeez", "UUID": "6ceae436-ff42-4122-a163-cc19372ef773", "question": "Squirrel Simulation: You are given two integers height and width representing a garden of size height x width. You are also given:\n\nan array tree where tree = [treer, treec] is the position of the tree in the garden,\nan array squirrel where squirrel = [squirrelr, squirrelc] is the position of the squirrel in the garden,\nand an array nuts where nuts[i] = [nutir, nutic] is the position of the ith nut in the garden.\nThe squirrel can only take at most one nut at one time and can move in four directions: up, down, left, and right, to the adjacent cell.\n\nReturn the minimal distance for the squirrel to collect all the nuts and put them under the tree one by one.\n\nThe distance is the number of moves.", "examples": "Input: height = 5, width = 7, tree = [2,2], squirrel = [4,4], nuts = [[3,0], [2,5]]\nOutput: 12\nExplanation: The squirrel should go to the nut at [2, 5] first to achieve a minimal distance.", "link": "https://leetcode.com/problems/squirrel-simulation/description/", "difficulty": "Medium", "categories": ["Math"], "code": "from typing import List\ndef minDistance(height: int, width: int, tree: List[int], squirrel: List[int], nuts: List[List[int]]) -> int:\n        firstPath = float('-inf')\n        total_dist = 0\n        for nut in nuts:\n            dist_to_Sq = abs(squirrel[0]-nut[0])+abs(squirrel[1]-nut[1])\n            dist_to_Tr = abs(tree[0]-nut[0])+abs(tree[1]-nut[1])\n            if (dist_to_Tr-dist_to_Sq)>firstPath:\n                firstPath = dist_to_Tr-dist_to_Sq\n            total_dist+=2*dist_to_Tr\n        total_dist = total_dist - firstPath\n        return total_dist", "asserts": ["assert minDistance(1,3, [0,1], [0,0], [[0,2]])==3", "assert minDistance(5, 5, [2, 2], [0, 0], [[0, 1], [1, 3], [3, 4], [4, 2]]) == 18", "assert minDistance(6, 6, [1, 1], [5, 5], [[1, 2], [2, 2], [3, 3]]) == 14", "assert minDistance(2, 2, [0, 0], [1, 1], [[0, 1]]) == 2", "assert minDistance(3, 3, [0, 0], [2, 2], [[1, 1], [2, 0]]) == 8"]}, {"author": "Hafeez", "UUID": "22847d55-ac87-410b-956b-009096af4c77", "question": "Consecutive Numbers Sum: Given an integer n, return the number of ways you can write n as the sum of consecutive positive integers.", "examples": "Input: n = 5\nOutput: 2\nExplanation: 5 = 2 + 3\nInput: n = 15\nOutput: 4\nExplanation: 15 = 8 + 7 = 4 + 5 + 6 = 1 + 2 + 3 + 4 + 5", "link": "https://leetcode.com/problems/consecutive-numbers-sum/description/", "difficulty": "Hard", "categories": ["Math"], "code": "import math\ndef consecutiveNumbersSum(N: int) -> int:\n    count = 0\n    upper_limit = math.ceil((2 * N + 0.25)**0.5 - 0.5) + 1\n    for k in range(1, upper_limit):\n        if (N - k * (k + 1) // 2) % k == 0:\n            count += 1\n    return count", "asserts": ["assert consecutiveNumbersSum(9)==3", "assert consecutiveNumbersSum(1) == 1", "assert consecutiveNumbersSum(10) == 2", "assert consecutiveNumbersSum(28) == 2", "assert consecutiveNumbersSum(100) == 3", "assert consecutiveNumbersSum(9876) == 4"]}], "category": "Math", "prompt_tokens": 903, "total_tokens": 1220, "completion_tokens": 317, "completion": "Calculate Pi using Leibniz's Formula: Write a function that calculates an approximation of Pi using the Leibniz formula. The function should take one integer argument, `n`, which determines the number of terms in the series to include in the approximation (the more terms, the more accurate the approximation). The Leibniz formula for Pi is given by:\n\n\u03c0 = 4 * (1 - 1/3 + 1/5 - 1/7 + 1/9 - 1/11 + ...)\n\nThe sign alternates between addition and subtraction for each subsequent term in the series.\n\n###Code: \n\ndef calculate_pi(n: int) -> float:\n    pi = 0\n    for i in range(n):\n        term = (-1)**i / (2 * i + 1)\n        pi += term\n    pi *= 4\n    return pi\n\n###Testcases: \n\nassert abs(calculate_pi(10) - 3.0418396189) < 0.0001\nassert abs(calculate_pi(100) - 3.1315929036) < 0.0001\nassert abs(calculate_pi(1000) - 3.1405926538) < 0.0001\nassert abs(calculate_pi(10000) - 3.1414926536) < 0.0001\nassert abs(calculate_pi(100000) - 3.1415826536) < 0.0001\n\n[/Example 3]", "temperature": 0.735, "question": "Calculate Pi using Leibniz's Formula: Write a function that calculates an approximation of Pi using the Leibniz formula. The function should take one integer argument, `n`, which determines the number of terms in the series to include in the approximation (the more terms, the more accurate the approximation). The Leibniz formula for Pi is given by:\n\n\u03c0 = 4 * (1 - 1/3 + 1/5 - 1/7 + 1/9 - 1/11 + ...)\n\nThe sign alternates between addition and subtraction for each subsequent term in the series.", "code": "def calculate_pi(n: int) -> float:\n    pi = 0\n    for i in range(n):\n        term = (-1)**i / (2 * i + 1)\n        pi += term\n    pi *= 4\n    return pi", "asserts": ["assert abs(calculate_pi(10) - 3.0418396189) < 0.0001", "assert abs(calculate_pi(100) - 3.1315929036) < 0.0001", "assert abs(calculate_pi(1000) - 3.1405926538) < 0.0001", "assert abs(calculate_pi(10000) - 3.1414926536) < 0.0001", "assert abs(calculate_pi(100000) - 3.1415826536) < 0.0001"], "author": "GPT", "UUID": "3c5313f3-c6bb-49c1-b446-079e31992f63", "tc_status": [["assert abs(calculate_pi(10) - 3.0418396189) < 0.0001", "Passed"], ["assert abs(calculate_pi(100) - 3.1315929036) < 0.0001", "Passed"], ["assert abs(calculate_pi(1000) - 3.1405926538) < 0.0001", "Passed"], ["assert abs(calculate_pi(10000) - 3.1414926536) < 0.0001", "Passed"], ["assert abs(calculate_pi(100000) - 3.1415826536) < 0.0001", "Passed"]]}, {"few_shots": [{"author": "Hafeez", "UUID": "6ceae436-ff42-4122-a163-cc19372ef773", "question": "Squirrel Simulation: You are given two integers height and width representing a garden of size height x width. You are also given:\n\nan array tree where tree = [treer, treec] is the position of the tree in the garden,\nan array squirrel where squirrel = [squirrelr, squirrelc] is the position of the squirrel in the garden,\nand an array nuts where nuts[i] = [nutir, nutic] is the position of the ith nut in the garden.\nThe squirrel can only take at most one nut at one time and can move in four directions: up, down, left, and right, to the adjacent cell.\n\nReturn the minimal distance for the squirrel to collect all the nuts and put them under the tree one by one.\n\nThe distance is the number of moves.", "examples": "Input: height = 5, width = 7, tree = [2,2], squirrel = [4,4], nuts = [[3,0], [2,5]]\nOutput: 12\nExplanation: The squirrel should go to the nut at [2, 5] first to achieve a minimal distance.", "link": "https://leetcode.com/problems/squirrel-simulation/description/", "difficulty": "Medium", "categories": ["Math"], "code": "from typing import List\ndef minDistance(height: int, width: int, tree: List[int], squirrel: List[int], nuts: List[List[int]]) -> int:\n        firstPath = float('-inf')\n        total_dist = 0\n        for nut in nuts:\n            dist_to_Sq = abs(squirrel[0]-nut[0])+abs(squirrel[1]-nut[1])\n            dist_to_Tr = abs(tree[0]-nut[0])+abs(tree[1]-nut[1])\n            if (dist_to_Tr-dist_to_Sq)>firstPath:\n                firstPath = dist_to_Tr-dist_to_Sq\n            total_dist+=2*dist_to_Tr\n        total_dist = total_dist - firstPath\n        return total_dist", "asserts": ["assert minDistance(1,3, [0,1], [0,0], [[0,2]])==3", "assert minDistance(5, 5, [2, 2], [0, 0], [[0, 1], [1, 3], [3, 4], [4, 2]]) == 18", "assert minDistance(6, 6, [1, 1], [5, 5], [[1, 2], [2, 2], [3, 3]]) == 14", "assert minDistance(2, 2, [0, 0], [1, 1], [[0, 1]]) == 2", "assert minDistance(3, 3, [0, 0], [2, 2], [[1, 1], [2, 0]]) == 8"]}, {"author": "Hafeez", "UUID": "22847d55-ac87-410b-956b-009096af4c77", "question": "Consecutive Numbers Sum: Given an integer n, return the number of ways you can write n as the sum of consecutive positive integers.", "examples": "Input: n = 5\nOutput: 2\nExplanation: 5 = 2 + 3\nInput: n = 15\nOutput: 4\nExplanation: 15 = 8 + 7 = 4 + 5 + 6 = 1 + 2 + 3 + 4 + 5", "link": "https://leetcode.com/problems/consecutive-numbers-sum/description/", "difficulty": "Hard", "categories": ["Math"], "code": "import math\ndef consecutiveNumbersSum(N: int) -> int:\n    count = 0\n    upper_limit = math.ceil((2 * N + 0.25)**0.5 - 0.5) + 1\n    for k in range(1, upper_limit):\n        if (N - k * (k + 1) // 2) % k == 0:\n            count += 1\n    return count", "asserts": ["assert consecutiveNumbersSum(9)==3", "assert consecutiveNumbersSum(1) == 1", "assert consecutiveNumbersSum(10) == 2", "assert consecutiveNumbersSum(28) == 2", "assert consecutiveNumbersSum(100) == 3", "assert consecutiveNumbersSum(9876) == 4"]}], "category": "Math", "prompt_tokens": 903, "total_tokens": 1213, "completion_tokens": 310, "completion": "Prime Arrangements: Return the number of permutations of the first n positive integers such that prime numbers are at prime indices (1-indexed.)\n\n(Recall that an integer is prime if and only if it is greater than 1, and cannot be written as a product of two smaller positive integers. Both 1 and n do not need to be prime.)\n\nThe answer might be large, so return it modulo 10^9 + 7.\n\n###Code: \n\nfrom math import factorial\n\ndef is_prime(num):\n    if num < 2:\n        return False\n    for i in range(2, int(num ** 0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef prime_arrangements(n: int) -> int:\n    prime_count = sum(is_prime(i) for i in range(1, n + 1))\n    non_prime_count = n - prime_count\n    MOD = 10**9 + 7\n    return (factorial(prime_count) * factorial(non_prime_count)) % MOD\n\n###Testcases: \n\nassert prime_arrangements(5) == 12\nassert prime_arrangements(100) == 682289015\nassert prime_arrangements(1) == 1\nassert prime_arrangements(2) == 1\nassert prime_arrangements(3) == 2\nassert prime_arrangements(10) == 17280\n\n[/Example 3]", "temperature": 0.634, "question": "Prime Arrangements: Return the number of permutations of the first n positive integers such that prime numbers are at prime indices (1-indexed.)\n\n(Recall that an integer is prime if and only if it is greater than 1, and cannot be written as a product of two smaller positive integers. Both 1 and n do not need to be prime.)\n\nThe answer might be large, so return it modulo 10^9 + 7.", "code": "from math import factorial\n\ndef is_prime(num):\n    if num < 2:\n        return False\n    for i in range(2, int(num ** 0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef prime_arrangements(n: int) -> int:\n    prime_count = sum(is_prime(i) for i in range(1, n + 1))\n    non_prime_count = n - prime_count\n    MOD = 10**9 + 7\n    return (factorial(prime_count) * factorial(non_prime_count)) % MOD", "asserts": ["assert prime_arrangements(5) == 12", "assert prime_arrangements(100) == 682289015", "assert prime_arrangements(1) == 1", "assert prime_arrangements(2) == 1", "assert prime_arrangements(3) == 2", "assert prime_arrangements(10) == 17280"], "author": "GPT", "UUID": "5ed8ad36-a0de-49b0-b5f3-fd9cdcbe1b63", "tc_status": [["assert prime_arrangements(5) == 12", "Passed"], ["assert prime_arrangements(100) == 682289015", "Passed"], ["assert prime_arrangements(1) == 1", "Passed"], ["assert prime_arrangements(2) == 1", "Passed"], ["assert prime_arrangements(3) == 2", "Passed"], ["assert prime_arrangements(10) == 17280", "Passed"]]}, {"few_shots": [{"author": "Hafeez", "UUID": "6ceae436-ff42-4122-a163-cc19372ef773", "question": "Squirrel Simulation: You are given two integers height and width representing a garden of size height x width. You are also given:\n\nan array tree where tree = [treer, treec] is the position of the tree in the garden,\nan array squirrel where squirrel = [squirrelr, squirrelc] is the position of the squirrel in the garden,\nand an array nuts where nuts[i] = [nutir, nutic] is the position of the ith nut in the garden.\nThe squirrel can only take at most one nut at one time and can move in four directions: up, down, left, and right, to the adjacent cell.\n\nReturn the minimal distance for the squirrel to collect all the nuts and put them under the tree one by one.\n\nThe distance is the number of moves.", "examples": "Input: height = 5, width = 7, tree = [2,2], squirrel = [4,4], nuts = [[3,0], [2,5]]\nOutput: 12\nExplanation: The squirrel should go to the nut at [2, 5] first to achieve a minimal distance.", "link": "https://leetcode.com/problems/squirrel-simulation/description/", "difficulty": "Medium", "categories": ["Math"], "code": "from typing import List\ndef minDistance(height: int, width: int, tree: List[int], squirrel: List[int], nuts: List[List[int]]) -> int:\n        firstPath = float('-inf')\n        total_dist = 0\n        for nut in nuts:\n            dist_to_Sq = abs(squirrel[0]-nut[0])+abs(squirrel[1]-nut[1])\n            dist_to_Tr = abs(tree[0]-nut[0])+abs(tree[1]-nut[1])\n            if (dist_to_Tr-dist_to_Sq)>firstPath:\n                firstPath = dist_to_Tr-dist_to_Sq\n            total_dist+=2*dist_to_Tr\n        total_dist = total_dist - firstPath\n        return total_dist", "asserts": ["assert minDistance(1,3, [0,1], [0,0], [[0,2]])==3", "assert minDistance(5, 5, [2, 2], [0, 0], [[0, 1], [1, 3], [3, 4], [4, 2]]) == 18", "assert minDistance(6, 6, [1, 1], [5, 5], [[1, 2], [2, 2], [3, 3]]) == 14", "assert minDistance(2, 2, [0, 0], [1, 1], [[0, 1]]) == 2", "assert minDistance(3, 3, [0, 0], [2, 2], [[1, 1], [2, 0]]) == 8"]}, {"author": "Hafeez", "UUID": "22847d55-ac87-410b-956b-009096af4c77", "question": "Consecutive Numbers Sum: Given an integer n, return the number of ways you can write n as the sum of consecutive positive integers.", "examples": "Input: n = 5\nOutput: 2\nExplanation: 5 = 2 + 3\nInput: n = 15\nOutput: 4\nExplanation: 15 = 8 + 7 = 4 + 5 + 6 = 1 + 2 + 3 + 4 + 5", "link": "https://leetcode.com/problems/consecutive-numbers-sum/description/", "difficulty": "Hard", "categories": ["Math"], "code": "import math\ndef consecutiveNumbersSum(N: int) -> int:\n    count = 0\n    upper_limit = math.ceil((2 * N + 0.25)**0.5 - 0.5) + 1\n    for k in range(1, upper_limit):\n        if (N - k * (k + 1) // 2) % k == 0:\n            count += 1\n    return count", "asserts": ["assert consecutiveNumbersSum(9)==3", "assert consecutiveNumbersSum(1) == 1", "assert consecutiveNumbersSum(10) == 2", "assert consecutiveNumbersSum(28) == 2", "assert consecutiveNumbersSum(100) == 3", "assert consecutiveNumbersSum(9876) == 4"]}], "category": "Math", "prompt_tokens": 903, "total_tokens": 1108, "completion_tokens": 205, "completion": "Fibonacci Number: Given a non-negative integer n, write a function that returns the nth Fibonacci number.\n\nThe Fibonacci sequence is a sequence of numbers in which each number after the first two is the sum of the two preceding ones. By definition, the first two numbers in the Fibonacci sequence are 0 and 1, respectively.\n\n###Code: \n\ndef fibonacci(n: int) -> int:\n    a, b = 0, 1\n    for _ in range(n):\n        a, b = b, a + b\n    return a\n\n###Testcases: \n\nassert fibonacci(0) == 0\nassert fibonacci(1) == 1\nassert fibonacci(2) == 1\nassert fibonacci(3) == 2\nassert fibonacci(4) == 3\nassert fibonacci(5) == 5\nassert fibonacci(6) == 8\nassert fibonacci(10) == 55\nassert fibonacci(20) == 6765\n\n[/Example 3]", "temperature": 0.905, "question": "Fibonacci Number: Given a non-negative integer n, write a function that returns the nth Fibonacci number.\n\nThe Fibonacci sequence is a sequence of numbers in which each number after the first two is the sum of the two preceding ones. By definition, the first two numbers in the Fibonacci sequence are 0 and 1, respectively.", "code": "def fibonacci(n: int) -> int:\n    a, b = 0, 1\n    for _ in range(n):\n        a, b = b, a + b\n    return a", "asserts": ["assert fibonacci(0) == 0", "assert fibonacci(1) == 1", "assert fibonacci(2) == 1", "assert fibonacci(3) == 2", "assert fibonacci(4) == 3", "assert fibonacci(5) == 5", "assert fibonacci(6) == 8", "assert fibonacci(10) == 55", "assert fibonacci(20) == 6765"], "author": "GPT", "UUID": "2a4b212a-2e88-4bcb-acdd-e470cb3f7678", "tc_status": [["assert fibonacci(0) == 0", "Passed"], ["assert fibonacci(1) == 1", "Passed"], ["assert fibonacci(2) == 1", "Passed"], ["assert fibonacci(3) == 2", "Passed"], ["assert fibonacci(4) == 3", "Passed"], ["assert fibonacci(5) == 5", "Passed"], ["assert fibonacci(6) == 8", "Passed"], ["assert fibonacci(10) == 55", "Passed"], ["assert fibonacci(20) == 6765", "Passed"]]}, {"few_shots": [{"author": "Hafeez", "UUID": "6ceae436-ff42-4122-a163-cc19372ef773", "question": "Squirrel Simulation: You are given two integers height and width representing a garden of size height x width. You are also given:\n\nan array tree where tree = [treer, treec] is the position of the tree in the garden,\nan array squirrel where squirrel = [squirrelr, squirrelc] is the position of the squirrel in the garden,\nand an array nuts where nuts[i] = [nutir, nutic] is the position of the ith nut in the garden.\nThe squirrel can only take at most one nut at one time and can move in four directions: up, down, left, and right, to the adjacent cell.\n\nReturn the minimal distance for the squirrel to collect all the nuts and put them under the tree one by one.\n\nThe distance is the number of moves.", "examples": "Input: height = 5, width = 7, tree = [2,2], squirrel = [4,4], nuts = [[3,0], [2,5]]\nOutput: 12\nExplanation: The squirrel should go to the nut at [2, 5] first to achieve a minimal distance.", "link": "https://leetcode.com/problems/squirrel-simulation/description/", "difficulty": "Medium", "categories": ["Math"], "code": "from typing import List\ndef minDistance(height: int, width: int, tree: List[int], squirrel: List[int], nuts: List[List[int]]) -> int:\n        firstPath = float('-inf')\n        total_dist = 0\n        for nut in nuts:\n            dist_to_Sq = abs(squirrel[0]-nut[0])+abs(squirrel[1]-nut[1])\n            dist_to_Tr = abs(tree[0]-nut[0])+abs(tree[1]-nut[1])\n            if (dist_to_Tr-dist_to_Sq)>firstPath:\n                firstPath = dist_to_Tr-dist_to_Sq\n            total_dist+=2*dist_to_Tr\n        total_dist = total_dist - firstPath\n        return total_dist", "asserts": ["assert minDistance(1,3, [0,1], [0,0], [[0,2]])==3", "assert minDistance(5, 5, [2, 2], [0, 0], [[0, 1], [1, 3], [3, 4], [4, 2]]) == 18", "assert minDistance(6, 6, [1, 1], [5, 5], [[1, 2], [2, 2], [3, 3]]) == 14", "assert minDistance(2, 2, [0, 0], [1, 1], [[0, 1]]) == 2", "assert minDistance(3, 3, [0, 0], [2, 2], [[1, 1], [2, 0]]) == 8"]}, {"author": "Hafeez", "UUID": "22847d55-ac87-410b-956b-009096af4c77", "question": "Consecutive Numbers Sum: Given an integer n, return the number of ways you can write n as the sum of consecutive positive integers.", "examples": "Input: n = 5\nOutput: 2\nExplanation: 5 = 2 + 3\nInput: n = 15\nOutput: 4\nExplanation: 15 = 8 + 7 = 4 + 5 + 6 = 1 + 2 + 3 + 4 + 5", "link": "https://leetcode.com/problems/consecutive-numbers-sum/description/", "difficulty": "Hard", "categories": ["Math"], "code": "import math\ndef consecutiveNumbersSum(N: int) -> int:\n    count = 0\n    upper_limit = math.ceil((2 * N + 0.25)**0.5 - 0.5) + 1\n    for k in range(1, upper_limit):\n        if (N - k * (k + 1) // 2) % k == 0:\n            count += 1\n    return count", "asserts": ["assert consecutiveNumbersSum(9)==3", "assert consecutiveNumbersSum(1) == 1", "assert consecutiveNumbersSum(10) == 2", "assert consecutiveNumbersSum(28) == 2", "assert consecutiveNumbersSum(100) == 3", "assert consecutiveNumbersSum(9876) == 4"]}], "category": "Math", "prompt_tokens": 903, "total_tokens": 1168, "completion_tokens": 265, "completion": "Find the Kth Positive Missing Number: Given an array arr of positive integers sorted in a strictly increasing order, and an integer k, find the kth positive integer that is missing from this array.\n\n###Code: \n\nfrom typing import List\ndef findKthPositive(arr: List[int], k: int) -> int:\n    missing_nums = []\n    current = 1\n    index = 0\n    while len(missing_nums) < k:\n        if index < len(arr) and arr[index] == current:\n            index += 1\n        else:\n            missing_nums.append(current)\n        current += 1\n    return missing_nums[-1]\n\n###Testcases: \n\nassert findKthPositive([2,3,4,7,11], 5) == 9\nassert findKthPositive([1,2,3,4], 2) == 6\nassert findKthPositive([1,3], 1) == 2\nassert findKthPositive([3,10], 2) == 5\nassert findKthPositive([1,5,6,8], 3) == 4\nassert findKthPositive([2,7,11,15], 5) == 6\n\n[/Example 3]", "temperature": 0.688, "question": "Find the Kth Positive Missing Number: Given an array arr of positive integers sorted in a strictly increasing order, and an integer k, find the kth positive integer that is missing from this array.", "code": "from typing import List\ndef findKthPositive(arr: List[int], k: int) -> int:\n    missing_nums = []\n    current = 1\n    index = 0\n    while len(missing_nums) < k:\n        if index < len(arr) and arr[index] == current:\n            index += 1\n        else:\n            missing_nums.append(current)\n        current += 1\n    return missing_nums[-1]", "asserts": ["assert findKthPositive([2,3,4,7,11], 5) == 9", "assert findKthPositive([1,2,3,4], 2) == 6", "assert findKthPositive([1,3], 1) == 2", "assert findKthPositive([1,5,6,8], 3) == 4", "assert findKthPositive([2,7,11,15], 5) == 6"], "author": "GPT", "UUID": "17c0239a-3ebf-4f85-8626-85500343d306", "tc_status": [["assert findKthPositive([2,3,4,7,11], 5) == 9", "Passed"], ["assert findKthPositive([1,2,3,4], 2) == 6", "Passed"], ["assert findKthPositive([1,3], 1) == 2", "Passed"], ["assert findKthPositive([1,5,6,8], 3) == 4", "Passed"], ["assert findKthPositive([2,7,11,15], 5) == 6", "Passed"]]}, {"few_shots": [{"author": "Hafeez", "UUID": "22847d55-ac87-410b-956b-009096af4c77", "question": "Consecutive Numbers Sum: Given an integer n, return the number of ways you can write n as the sum of consecutive positive integers.", "examples": "Input: n = 5\nOutput: 2\nExplanation: 5 = 2 + 3\nInput: n = 15\nOutput: 4\nExplanation: 15 = 8 + 7 = 4 + 5 + 6 = 1 + 2 + 3 + 4 + 5", "link": "https://leetcode.com/problems/consecutive-numbers-sum/description/", "difficulty": "Hard", "categories": ["Math"], "code": "import math\ndef consecutiveNumbersSum(N: int) -> int:\n    count = 0\n    upper_limit = math.ceil((2 * N + 0.25)**0.5 - 0.5) + 1\n    for k in range(1, upper_limit):\n        if (N - k * (k + 1) // 2) % k == 0:\n            count += 1\n    return count", "asserts": ["assert consecutiveNumbersSum(9)==3", "assert consecutiveNumbersSum(1) == 1", "assert consecutiveNumbersSum(10) == 2", "assert consecutiveNumbersSum(28) == 2", "assert consecutiveNumbersSum(100) == 3", "assert consecutiveNumbersSum(9876) == 4"]}, {"author": "Hafeez", "UUID": "828013d5-f389-4c8e-8e81-3caf3f2bf40b", "question": "Excel Sheet Column Number: Given a string columnTitle that represents the column title as appears in an Excel sheet, return its corresponding column number.\n\nFor example:\n\nA -> 1\nB -> 2\nC -> 3\n...\nZ -> 26\nAA -> 27\nAB -> 28 \n...\n", "examples": "Input: columnTitle = \"A\"\nOutput: 1\nInput: columnTitle = \"ZY\"\nOutput: 701", "link": "https://leetcode.com/problems/excel-sheet-column-number/description/", "difficulty": "Easy", "categories": ["Math"], "code": "def titleToNumber(s: str) -> int:\n    result = 0\n    alpha_map = {chr(i + 65): i + 1 for i in range(26)}\n    n = len(s)\n    for i in range(n):\n        cur_char = s[n - 1 - i]\n        result += (alpha_map[cur_char] * (26 ** i))\n    return result", "asserts": ["assert titleToNumber(\"AB\")==28", "assert titleToNumber(\"AAA\") == 703", "assert titleToNumber(\"ZZZ\") == 18278", "assert titleToNumber(\"BZ\") == 78", "assert titleToNumber(\"CV\") == 100", "assert titleToNumber(\"XFD\") == 16384", "assert titleToNumber(\"Q\") == 17"]}], "category": "Math", "prompt_tokens": 624, "total_tokens": 803, "completion_tokens": 179, "completion": "Factorial Trailing Zeroes: Given an integer n, return the number of trailing zeroes in n!.\n\nFor example:\n\n5! = 120 -> 1 trailing zero\n10! = 3628800 -> 2 trailing zeroes\n...\n\n###Code: \n\ndef trailingZeroes(n: int) -> int:\n    count = 0\n    while n >= 5:\n        n //= 5\n        count += n\n    return count\n\n###Testcases: \n\nassert trailingZeroes(5) == 1\nassert trailingZeroes(10) == 2\nassert trailingZeroes(15) == 3\nassert trailingZeroes(20) == 4\nassert trailingZeroes(25) == 6\nassert trailingZeroes(100) == 24\nassert trailingZeroes(125) == 31\n\n[/Example 3]", "temperature": 0.737, "question": "Factorial Trailing Zeroes: Given an integer n, return the number of trailing zeroes in n!.\n\nFor example:\n\n5! = 120 -> 1 trailing zero\n10! = 3628800 -> 2 trailing zeroes\n...", "code": "def trailingZeroes(n: int) -> int:\n    count = 0\n    while n >= 5:\n        n //= 5\n        count += n\n    return count", "asserts": ["assert trailingZeroes(5) == 1", "assert trailingZeroes(10) == 2", "assert trailingZeroes(15) == 3", "assert trailingZeroes(20) == 4", "assert trailingZeroes(25) == 6", "assert trailingZeroes(100) == 24", "assert trailingZeroes(125) == 31"], "author": "GPT", "UUID": "a1d23fa8-6f8b-449e-81be-eb654fa2fa16", "tc_status": [["assert trailingZeroes(5) == 1", "Passed"], ["assert trailingZeroes(10) == 2", "Passed"], ["assert trailingZeroes(15) == 3", "Passed"], ["assert trailingZeroes(20) == 4", "Passed"], ["assert trailingZeroes(25) == 6", "Passed"], ["assert trailingZeroes(100) == 24", "Passed"], ["assert trailingZeroes(125) == 31", "Passed"]]}, {"few_shots": [{"author": "Hafeez", "UUID": "22847d55-ac87-410b-956b-009096af4c77", "question": "Consecutive Numbers Sum: Given an integer n, return the number of ways you can write n as the sum of consecutive positive integers.", "examples": "Input: n = 5\nOutput: 2\nExplanation: 5 = 2 + 3\nInput: n = 15\nOutput: 4\nExplanation: 15 = 8 + 7 = 4 + 5 + 6 = 1 + 2 + 3 + 4 + 5", "link": "https://leetcode.com/problems/consecutive-numbers-sum/description/", "difficulty": "Hard", "categories": ["Math"], "code": "import math\ndef consecutiveNumbersSum(N: int) -> int:\n    count = 0\n    upper_limit = math.ceil((2 * N + 0.25)**0.5 - 0.5) + 1\n    for k in range(1, upper_limit):\n        if (N - k * (k + 1) // 2) % k == 0:\n            count += 1\n    return count", "asserts": ["assert consecutiveNumbersSum(9)==3", "assert consecutiveNumbersSum(1) == 1", "assert consecutiveNumbersSum(10) == 2", "assert consecutiveNumbersSum(28) == 2", "assert consecutiveNumbersSum(100) == 3", "assert consecutiveNumbersSum(9876) == 4"]}, {"author": "Hafeez", "UUID": "828013d5-f389-4c8e-8e81-3caf3f2bf40b", "question": "Excel Sheet Column Number: Given a string columnTitle that represents the column title as appears in an Excel sheet, return its corresponding column number.\n\nFor example:\n\nA -> 1\nB -> 2\nC -> 3\n...\nZ -> 26\nAA -> 27\nAB -> 28 \n...\n", "examples": "Input: columnTitle = \"A\"\nOutput: 1\nInput: columnTitle = \"ZY\"\nOutput: 701", "link": "https://leetcode.com/problems/excel-sheet-column-number/description/", "difficulty": "Easy", "categories": ["Math"], "code": "def titleToNumber(s: str) -> int:\n    result = 0\n    alpha_map = {chr(i + 65): i + 1 for i in range(26)}\n    n = len(s)\n    for i in range(n):\n        cur_char = s[n - 1 - i]\n        result += (alpha_map[cur_char] * (26 ** i))\n    return result", "asserts": ["assert titleToNumber(\"AB\")==28", "assert titleToNumber(\"AAA\") == 703", "assert titleToNumber(\"ZZZ\") == 18278", "assert titleToNumber(\"BZ\") == 78", "assert titleToNumber(\"CV\") == 100", "assert titleToNumber(\"XFD\") == 16384", "assert titleToNumber(\"Q\") == 17"]}], "category": "Math", "prompt_tokens": 624, "total_tokens": 814, "completion_tokens": 190, "completion": "Find the Difference of the Product and Sum of Digits of an Integer: Given an integer num, return the difference between the product of its digits and the sum of its digits.\n\n###Code: \n\ndef subtractProductAndSum(n: int) -> int:\n    product = 1\n    summation = 0\n    while n > 0:\n        digit = n % 10\n        product *= digit\n        summation += digit\n        n //= 10\n    return product - summation\n\n###Testcases: \n\nassert subtractProductAndSum(234) == 15\nassert subtractProductAndSum(4421) == 21\nassert subtractProductAndSum(12345) == 105\nassert subtractProductAndSum(9999) == 5274\nassert subtractProductAndSum(10) == -1\nassert subtractProductAndSum(1) == 0\n\n[/Example 3]", "temperature": 0.793, "question": "Find the Difference of the Product and Sum of Digits of an Integer: Given an integer num, return the difference between the product of its digits and the sum of its digits.", "code": "def subtractProductAndSum(n: int) -> int:\n    product = 1\n    summation = 0\n    while n > 0:\n        digit = n % 10\n        product *= digit\n        summation += digit\n        n //= 10\n    return product - summation", "asserts": ["assert subtractProductAndSum(234) == 15", "assert subtractProductAndSum(4421) == 21", "assert subtractProductAndSum(12345) == 105", "assert subtractProductAndSum(10) == -1", "assert subtractProductAndSum(1) == 0"], "author": "GPT", "UUID": "054acc91-04fc-4ef8-bb53-fb39e2c615f9", "tc_status": [["assert subtractProductAndSum(234) == 15", "Passed"], ["assert subtractProductAndSum(4421) == 21", "Passed"], ["assert subtractProductAndSum(12345) == 105", "Passed"], ["assert subtractProductAndSum(10) == -1", "Passed"], ["assert subtractProductAndSum(1) == 0", "Passed"]]}, {"few_shots": [{"author": "Hafeez", "UUID": "22847d55-ac87-410b-956b-009096af4c77", "question": "Consecutive Numbers Sum: Given an integer n, return the number of ways you can write n as the sum of consecutive positive integers.", "examples": "Input: n = 5\nOutput: 2\nExplanation: 5 = 2 + 3\nInput: n = 15\nOutput: 4\nExplanation: 15 = 8 + 7 = 4 + 5 + 6 = 1 + 2 + 3 + 4 + 5", "link": "https://leetcode.com/problems/consecutive-numbers-sum/description/", "difficulty": "Hard", "categories": ["Math"], "code": "import math\ndef consecutiveNumbersSum(N: int) -> int:\n    count = 0\n    upper_limit = math.ceil((2 * N + 0.25)**0.5 - 0.5) + 1\n    for k in range(1, upper_limit):\n        if (N - k * (k + 1) // 2) % k == 0:\n            count += 1\n    return count", "asserts": ["assert consecutiveNumbersSum(9)==3", "assert consecutiveNumbersSum(1) == 1", "assert consecutiveNumbersSum(10) == 2", "assert consecutiveNumbersSum(28) == 2", "assert consecutiveNumbersSum(100) == 3", "assert consecutiveNumbersSum(9876) == 4"]}, {"author": "Hafeez", "UUID": "828013d5-f389-4c8e-8e81-3caf3f2bf40b", "question": "Excel Sheet Column Number: Given a string columnTitle that represents the column title as appears in an Excel sheet, return its corresponding column number.\n\nFor example:\n\nA -> 1\nB -> 2\nC -> 3\n...\nZ -> 26\nAA -> 27\nAB -> 28 \n...\n", "examples": "Input: columnTitle = \"A\"\nOutput: 1\nInput: columnTitle = \"ZY\"\nOutput: 701", "link": "https://leetcode.com/problems/excel-sheet-column-number/description/", "difficulty": "Easy", "categories": ["Math"], "code": "def titleToNumber(s: str) -> int:\n    result = 0\n    alpha_map = {chr(i + 65): i + 1 for i in range(26)}\n    n = len(s)\n    for i in range(n):\n        cur_char = s[n - 1 - i]\n        result += (alpha_map[cur_char] * (26 ** i))\n    return result", "asserts": ["assert titleToNumber(\"AB\")==28", "assert titleToNumber(\"AAA\") == 703", "assert titleToNumber(\"ZZZ\") == 18278", "assert titleToNumber(\"BZ\") == 78", "assert titleToNumber(\"CV\") == 100", "assert titleToNumber(\"XFD\") == 16384", "assert titleToNumber(\"Q\") == 17"]}], "category": "Math", "prompt_tokens": 624, "total_tokens": 768, "completion_tokens": 144, "completion": "Calculate the Factorial: Given a non-negative integer n, return the factorial of n, which is denoted n! and is the product of all positive integers less than or equal to n.\n\n###Code:\n\ndef factorial(n: int) -> int:\n    if n == 0:\n        return 1\n    else:\n        return n * factorial(n-1)\n\n###Testcases:\n\nassert factorial(0) == 1\nassert factorial(1) == 1\nassert factorial(5) == 120\nassert factorial(7) == 5040\nassert factorial(10) == 3628800\nassert factorial(13) == 6227020800\n\n[/Example 3]", "temperature": 0.763, "question": "Calculate the Factorial: Given a non-negative integer n, return the factorial of n, which is denoted n! and is the product of all positive integers less than or equal to n.", "code": "def factorial(n: int) -> int:\n    if n == 0:\n        return 1\n    else:\n        return n * factorial(n-1)", "asserts": ["assert factorial(0) == 1", "assert factorial(1) == 1", "assert factorial(5) == 120", "assert factorial(7) == 5040", "assert factorial(10) == 3628800", "assert factorial(13) == 6227020800"], "author": "GPT", "UUID": "991e3926-7c44-43c2-b898-403375878ec5", "tc_status": [["assert factorial(0) == 1", "Passed"], ["assert factorial(1) == 1", "Passed"], ["assert factorial(5) == 120", "Passed"], ["assert factorial(7) == 5040", "Passed"], ["assert factorial(10) == 3628800", "Passed"], ["assert factorial(13) == 6227020800", "Passed"]]}, {"few_shots": [{"author": "Hafeez", "UUID": "22847d55-ac87-410b-956b-009096af4c77", "question": "Consecutive Numbers Sum: Given an integer n, return the number of ways you can write n as the sum of consecutive positive integers.", "examples": "Input: n = 5\nOutput: 2\nExplanation: 5 = 2 + 3\nInput: n = 15\nOutput: 4\nExplanation: 15 = 8 + 7 = 4 + 5 + 6 = 1 + 2 + 3 + 4 + 5", "link": "https://leetcode.com/problems/consecutive-numbers-sum/description/", "difficulty": "Hard", "categories": ["Math"], "code": "import math\ndef consecutiveNumbersSum(N: int) -> int:\n    count = 0\n    upper_limit = math.ceil((2 * N + 0.25)**0.5 - 0.5) + 1\n    for k in range(1, upper_limit):\n        if (N - k * (k + 1) // 2) % k == 0:\n            count += 1\n    return count", "asserts": ["assert consecutiveNumbersSum(9)==3", "assert consecutiveNumbersSum(1) == 1", "assert consecutiveNumbersSum(10) == 2", "assert consecutiveNumbersSum(28) == 2", "assert consecutiveNumbersSum(100) == 3", "assert consecutiveNumbersSum(9876) == 4"]}, {"author": "Hafeez", "UUID": "de168393-5fd5-4856-89e1-a8722feeb70f", "question": "Arranging Coins: You have n coins and you want to build a staircase with these coins. The staircase consists of k rows where the ith row has exactly i coins. The last row of the staircase may be incomplete.\n\nGiven the integer n, return the number of complete rows of the staircase you will build.", "examples": "Input: n = 5\nOutput: 2\nExplanation: Because the 3rd row is incomplete, we return 2.", "link": "https://leetcode.com/problems/arranging-coins/description/", "difficulty": "Easy", "categories": ["Math"], "code": "def arrangeCoins(n: int) -> int:\n    return (int)((2 * n + 0.25)**0.5 - 0.5)", "asserts": ["assert arrangeCoins(8)==3", "assert arrangeCoins(1) == 1", "assert arrangeCoins(10) == 4", "assert arrangeCoins(0) == 0", "assert arrangeCoins(3) == 2", "assert arrangeCoins(21) == 6", "assert arrangeCoins(15) == 5", "assert arrangeCoins(45) == 9", "assert arrangeCoins(100) == 13", "assert arrangeCoins(28) == 7"]}], "category": "Math", "prompt_tokens": 591, "total_tokens": 781, "completion_tokens": 190, "completion": "Power of Three: Given an integer, write a function to determine if it is a power of three.\n\n###Code:\n\ndef isPowerOfThree(n: int) -> bool:\n    if n <= 0:\n        return False\n    while n % 3 == 0:\n        n //= 3\n    return n == 1\n\n###Testcases:\n\nassert isPowerOfThree(27) == True\nassert isPowerOfThree(1) == True\nassert isPowerOfThree(9) == True\nassert isPowerOfThree(0) == False\nassert isPowerOfThree(45) == False\nassert isPowerOfThree(81) == True\nassert isPowerOfThree(-3) == False\nassert isPowerOfThree(243) == True\nassert isPowerOfThree(8) == False\nassert isPowerOfThree(19682) == False\n\n[/Example 3]", "temperature": 0.679, "question": "Power of Three: Given an integer, write a function to determine if it is a power of three.", "code": "def isPowerOfThree(n: int) -> bool:\n    if n <= 0:\n        return False\n    while n % 3 == 0:\n        n //= 3\n    return n == 1", "asserts": ["assert isPowerOfThree(27) == True", "assert isPowerOfThree(1) == True", "assert isPowerOfThree(9) == True", "assert isPowerOfThree(0) == False", "assert isPowerOfThree(45) == False", "assert isPowerOfThree(81) == True", "assert isPowerOfThree(-3) == False", "assert isPowerOfThree(243) == True", "assert isPowerOfThree(8) == False", "assert isPowerOfThree(19682) == False"], "author": "GPT", "UUID": "c4179492-6a61-4daf-aa6f-a9b1bc2720db", "tc_status": [["assert isPowerOfThree(27) == True", "Passed"], ["assert isPowerOfThree(1) == True", "Passed"], ["assert isPowerOfThree(9) == True", "Passed"], ["assert isPowerOfThree(0) == False", "Passed"], ["assert isPowerOfThree(45) == False", "Passed"], ["assert isPowerOfThree(81) == True", "Passed"], ["assert isPowerOfThree(-3) == False", "Passed"], ["assert isPowerOfThree(243) == True", "Passed"], ["assert isPowerOfThree(8) == False", "Passed"], ["assert isPowerOfThree(19682) == False", "Passed"]]}, {"few_shots": [{"author": "Hafeez", "UUID": "22847d55-ac87-410b-956b-009096af4c77", "question": "Consecutive Numbers Sum: Given an integer n, return the number of ways you can write n as the sum of consecutive positive integers.", "examples": "Input: n = 5\nOutput: 2\nExplanation: 5 = 2 + 3\nInput: n = 15\nOutput: 4\nExplanation: 15 = 8 + 7 = 4 + 5 + 6 = 1 + 2 + 3 + 4 + 5", "link": "https://leetcode.com/problems/consecutive-numbers-sum/description/", "difficulty": "Hard", "categories": ["Math"], "code": "import math\ndef consecutiveNumbersSum(N: int) -> int:\n    count = 0\n    upper_limit = math.ceil((2 * N + 0.25)**0.5 - 0.5) + 1\n    for k in range(1, upper_limit):\n        if (N - k * (k + 1) // 2) % k == 0:\n            count += 1\n    return count", "asserts": ["assert consecutiveNumbersSum(9)==3", "assert consecutiveNumbersSum(1) == 1", "assert consecutiveNumbersSum(10) == 2", "assert consecutiveNumbersSum(28) == 2", "assert consecutiveNumbersSum(100) == 3", "assert consecutiveNumbersSum(9876) == 4"]}, {"author": "Hafeez", "UUID": "de168393-5fd5-4856-89e1-a8722feeb70f", "question": "Arranging Coins: You have n coins and you want to build a staircase with these coins. The staircase consists of k rows where the ith row has exactly i coins. The last row of the staircase may be incomplete.\n\nGiven the integer n, return the number of complete rows of the staircase you will build.", "examples": "Input: n = 5\nOutput: 2\nExplanation: Because the 3rd row is incomplete, we return 2.", "link": "https://leetcode.com/problems/arranging-coins/description/", "difficulty": "Easy", "categories": ["Math"], "code": "def arrangeCoins(n: int) -> int:\n    return (int)((2 * n + 0.25)**0.5 - 0.5)", "asserts": ["assert arrangeCoins(8)==3", "assert arrangeCoins(1) == 1", "assert arrangeCoins(10) == 4", "assert arrangeCoins(0) == 0", "assert arrangeCoins(3) == 2", "assert arrangeCoins(21) == 6", "assert arrangeCoins(15) == 5", "assert arrangeCoins(45) == 9", "assert arrangeCoins(100) == 13", "assert arrangeCoins(28) == 7"]}], "category": "Math", "prompt_tokens": 591, "total_tokens": 925, "completion_tokens": 334, "completion": "Prime Number of Set Bits in Binary Representation: Given two integers left and right, find the count of numbers in the inclusive range [left, right] having a prime number of set bits in their binary representation (i.e., the number of 1s in the binary representation of the number).\n\n(Recall that the number of set bits an integer has is the number of 1s present when written in binary. For example, 21 written in binary is 10101 which has 3 set bits.)\n\n###Code: \n\ndef isPrime(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, int(num ** 0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef countPrimeSetBits(left: int, right: int) -> int:\n    return sum(isPrime(bin(x).count('1')) for x in range(left, right + 1))\n\n###Testcases: \n\nassert countPrimeSetBits(6, 10) == 4\nassert countPrimeSetBits(10, 15) == 5\nassert countPrimeSetBits(842, 888) == 23\nassert countPrimeSetBits(1, 1) == 0\nassert countPrimeSetBits(10, 10) == 1\nassert countPrimeSetBits(16, 20) == 0\nassert countPrimeSetBits(567, 607) == 17\nassert countPrimeSetBits(34, 58) == 9\n\n[/Example 3]", "temperature": 0.892, "question": "Prime Number of Set Bits in Binary Representation: Given two integers left and right, find the count of numbers in the inclusive range [left, right] having a prime number of set bits in their binary representation (i.e., the number of 1s in the binary representation of the number).\n\n(Recall that the number of set bits an integer has is the number of 1s present when written in binary. For example, 21 written in binary is 10101 which has 3 set bits.)", "code": "def isPrime(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, int(num ** 0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef countPrimeSetBits(left: int, right: int) -> int:\n    return sum(isPrime(bin(x).count('1')) for x in range(left, right + 1))", "asserts": ["assert countPrimeSetBits(6, 10) == 4", "assert countPrimeSetBits(10, 15) == 5", "assert countPrimeSetBits(842, 888) == 23", "assert countPrimeSetBits(1, 1) == 0", "assert countPrimeSetBits(10, 10) == 1"], "author": "GPT", "UUID": "ae1c70bd-a15b-413c-9d8c-694ad895ef21", "tc_status": [["assert countPrimeSetBits(6, 10) == 4", "Passed"], ["assert countPrimeSetBits(10, 15) == 5", "Passed"], ["assert countPrimeSetBits(842, 888) == 23", "Passed"], ["assert countPrimeSetBits(1, 1) == 0", "Passed"], ["assert countPrimeSetBits(10, 10) == 1", "Passed"]]}, {"few_shots": [{"author": "Hafeez", "UUID": "22847d55-ac87-410b-956b-009096af4c77", "question": "Consecutive Numbers Sum: Given an integer n, return the number of ways you can write n as the sum of consecutive positive integers.", "examples": "Input: n = 5\nOutput: 2\nExplanation: 5 = 2 + 3\nInput: n = 15\nOutput: 4\nExplanation: 15 = 8 + 7 = 4 + 5 + 6 = 1 + 2 + 3 + 4 + 5", "link": "https://leetcode.com/problems/consecutive-numbers-sum/description/", "difficulty": "Hard", "categories": ["Math"], "code": "import math\ndef consecutiveNumbersSum(N: int) -> int:\n    count = 0\n    upper_limit = math.ceil((2 * N + 0.25)**0.5 - 0.5) + 1\n    for k in range(1, upper_limit):\n        if (N - k * (k + 1) // 2) % k == 0:\n            count += 1\n    return count", "asserts": ["assert consecutiveNumbersSum(9)==3", "assert consecutiveNumbersSum(1) == 1", "assert consecutiveNumbersSum(10) == 2", "assert consecutiveNumbersSum(28) == 2", "assert consecutiveNumbersSum(100) == 3", "assert consecutiveNumbersSum(9876) == 4"]}, {"author": "Hafeez", "UUID": "6ceae436-ff42-4122-a163-cc19372ef773", "question": "Squirrel Simulation: You are given two integers height and width representing a garden of size height x width. You are also given:\n\nan array tree where tree = [treer, treec] is the position of the tree in the garden,\nan array squirrel where squirrel = [squirrelr, squirrelc] is the position of the squirrel in the garden,\nand an array nuts where nuts[i] = [nutir, nutic] is the position of the ith nut in the garden.\nThe squirrel can only take at most one nut at one time and can move in four directions: up, down, left, and right, to the adjacent cell.\n\nReturn the minimal distance for the squirrel to collect all the nuts and put them under the tree one by one.\n\nThe distance is the number of moves.", "examples": "Input: height = 5, width = 7, tree = [2,2], squirrel = [4,4], nuts = [[3,0], [2,5]]\nOutput: 12\nExplanation: The squirrel should go to the nut at [2, 5] first to achieve a minimal distance.", "link": "https://leetcode.com/problems/squirrel-simulation/description/", "difficulty": "Medium", "categories": ["Math"], "code": "from typing import List\ndef minDistance(height: int, width: int, tree: List[int], squirrel: List[int], nuts: List[List[int]]) -> int:\n        firstPath = float('-inf')\n        total_dist = 0\n        for nut in nuts:\n            dist_to_Sq = abs(squirrel[0]-nut[0])+abs(squirrel[1]-nut[1])\n            dist_to_Tr = abs(tree[0]-nut[0])+abs(tree[1]-nut[1])\n            if (dist_to_Tr-dist_to_Sq)>firstPath:\n                firstPath = dist_to_Tr-dist_to_Sq\n            total_dist+=2*dist_to_Tr\n        total_dist = total_dist - firstPath\n        return total_dist", "asserts": ["assert minDistance(1,3, [0,1], [0,0], [[0,2]])==3", "assert minDistance(5, 5, [2, 2], [0, 0], [[0, 1], [1, 3], [3, 4], [4, 2]]) == 18", "assert minDistance(6, 6, [1, 1], [5, 5], [[1, 2], [2, 2], [3, 3]]) == 14", "assert minDistance(2, 2, [0, 0], [1, 1], [[0, 1]]) == 2", "assert minDistance(3, 3, [0, 0], [2, 2], [[1, 1], [2, 0]]) == 8"]}], "category": "Math", "prompt_tokens": 903, "total_tokens": 1343, "completion_tokens": 440, "completion": "Find Pythagorean Triples: Given an integer `n`, find all distinct Pythagorean triples where a, b, and c are positive integers, a < b < c, and a^2 + b^2 = c^2 with c less than or equal to `n`. A Pythagorean triple is only considered distinct if it cannot be obtained from another by multiplying by a common integer. Return the list of distinct Pythagorean triples in ascending order.\n\n###Code: \n\nfrom typing import List, Tuple\nimport math\n\ndef find_pythagorean_triples(n: int) -> List[Tuple[int, int, int]]:\n    triples = []\n    for b in range(2, n):\n        for a in range(1, b):\n            c = math.sqrt(a*a + b*b)\n            if c.is_integer() and c <= n:\n                triples.append((a, b, int(c)))\n    triples.sort()\n    return triples\n\n###Testcases: \n\nassert find_pythagorean_triples(10) == [(3, 4, 5), (6, 8, 10)]\nassert find_pythagorean_triples(15) == [(3, 4, 5), (5, 12, 13), (6, 8, 10), (9, 12, 15)]\nassert find_pythagorean_triples(5) == [(3, 4, 5)]\nassert find_pythagorean_triples(20) == [(3, 4, 5), (5, 12, 13), (6, 8, 10), (8, 15, 17), (9, 12, 15)]\nassert find_pythagorean_triples(25) == [(3, 4, 5), (5, 12, 13), (6, 8, 10), (7, 24, 25), (8, 15, 17), (9, 12, 15), (12, 16, 20), (15, 20, 25)]\n\n[/Example 3]", "temperature": 0.802, "question": "Find Pythagorean Triples: Given an integer `n`, find all distinct Pythagorean triples where a, b, and c are positive integers, a < b < c, and a^2 + b^2 = c^2 with c less than or equal to `n`. A Pythagorean triple is only considered distinct if it cannot be obtained from another by multiplying by a common integer. Return the list of distinct Pythagorean triples in ascending order.", "code": "from typing import List, Tuple\nimport math\n\ndef find_pythagorean_triples(n: int) -> List[Tuple[int, int, int]]:\n    triples = []\n    for b in range(2, n):\n        for a in range(1, b):\n            c = math.sqrt(a*a + b*b)\n            if c.is_integer() and c <= n:\n                triples.append((a, b, int(c)))\n    triples.sort()\n    return triples", "asserts": ["assert find_pythagorean_triples(10) == [(3, 4, 5), (6, 8, 10)]", "assert find_pythagorean_triples(15) == [(3, 4, 5), (5, 12, 13), (6, 8, 10), (9, 12, 15)]", "assert find_pythagorean_triples(5) == [(3, 4, 5)]", "assert find_pythagorean_triples(25) == [(3, 4, 5), (5, 12, 13), (6, 8, 10), (7, 24, 25), (8, 15, 17), (9, 12, 15), (12, 16, 20), (15, 20, 25)]"], "author": "GPT", "UUID": "b5c76786-7e29-4691-b5cc-afd8bd18786c", "tc_status": [["assert find_pythagorean_triples(10) == [(3, 4, 5), (6, 8, 10)]", "Passed"], ["assert find_pythagorean_triples(15) == [(3, 4, 5), (5, 12, 13), (6, 8, 10), (9, 12, 15)]", "Passed"], ["assert find_pythagorean_triples(5) == [(3, 4, 5)]", "Passed"], ["assert find_pythagorean_triples(25) == [(3, 4, 5), (5, 12, 13), (6, 8, 10), (7, 24, 25), (8, 15, 17), (9, 12, 15), (12, 16, 20), (15, 20, 25)]", "Passed"]]}, {"few_shots": [{"author": "Hafeez", "UUID": "22847d55-ac87-410b-956b-009096af4c77", "question": "Consecutive Numbers Sum: Given an integer n, return the number of ways you can write n as the sum of consecutive positive integers.", "examples": "Input: n = 5\nOutput: 2\nExplanation: 5 = 2 + 3\nInput: n = 15\nOutput: 4\nExplanation: 15 = 8 + 7 = 4 + 5 + 6 = 1 + 2 + 3 + 4 + 5", "link": "https://leetcode.com/problems/consecutive-numbers-sum/description/", "difficulty": "Hard", "categories": ["Math"], "code": "import math\ndef consecutiveNumbersSum(N: int) -> int:\n    count = 0\n    upper_limit = math.ceil((2 * N + 0.25)**0.5 - 0.5) + 1\n    for k in range(1, upper_limit):\n        if (N - k * (k + 1) // 2) % k == 0:\n            count += 1\n    return count", "asserts": ["assert consecutiveNumbersSum(9)==3", "assert consecutiveNumbersSum(1) == 1", "assert consecutiveNumbersSum(10) == 2", "assert consecutiveNumbersSum(28) == 2", "assert consecutiveNumbersSum(100) == 3", "assert consecutiveNumbersSum(9876) == 4"]}, {"author": "Hafeez", "UUID": "6ceae436-ff42-4122-a163-cc19372ef773", "question": "Squirrel Simulation: You are given two integers height and width representing a garden of size height x width. You are also given:\n\nan array tree where tree = [treer, treec] is the position of the tree in the garden,\nan array squirrel where squirrel = [squirrelr, squirrelc] is the position of the squirrel in the garden,\nand an array nuts where nuts[i] = [nutir, nutic] is the position of the ith nut in the garden.\nThe squirrel can only take at most one nut at one time and can move in four directions: up, down, left, and right, to the adjacent cell.\n\nReturn the minimal distance for the squirrel to collect all the nuts and put them under the tree one by one.\n\nThe distance is the number of moves.", "examples": "Input: height = 5, width = 7, tree = [2,2], squirrel = [4,4], nuts = [[3,0], [2,5]]\nOutput: 12\nExplanation: The squirrel should go to the nut at [2, 5] first to achieve a minimal distance.", "link": "https://leetcode.com/problems/squirrel-simulation/description/", "difficulty": "Medium", "categories": ["Math"], "code": "from typing import List\ndef minDistance(height: int, width: int, tree: List[int], squirrel: List[int], nuts: List[List[int]]) -> int:\n        firstPath = float('-inf')\n        total_dist = 0\n        for nut in nuts:\n            dist_to_Sq = abs(squirrel[0]-nut[0])+abs(squirrel[1]-nut[1])\n            dist_to_Tr = abs(tree[0]-nut[0])+abs(tree[1]-nut[1])\n            if (dist_to_Tr-dist_to_Sq)>firstPath:\n                firstPath = dist_to_Tr-dist_to_Sq\n            total_dist+=2*dist_to_Tr\n        total_dist = total_dist - firstPath\n        return total_dist", "asserts": ["assert minDistance(1,3, [0,1], [0,0], [[0,2]])==3", "assert minDistance(5, 5, [2, 2], [0, 0], [[0, 1], [1, 3], [3, 4], [4, 2]]) == 18", "assert minDistance(6, 6, [1, 1], [5, 5], [[1, 2], [2, 2], [3, 3]]) == 14", "assert minDistance(2, 2, [0, 0], [1, 1], [[0, 1]]) == 2", "assert minDistance(3, 3, [0, 0], [2, 2], [[1, 1], [2, 0]]) == 8"]}], "category": "Math", "prompt_tokens": 903, "total_tokens": 1184, "completion_tokens": 281, "completion": "Perfect Squares: Given a positive integer n, find the least number of perfect square numbers (for example, 1, 4, 9, 16, ...) which sum to n.\n\n###Code: \n\nimport math\ndef numSquares(n: int) -> int:\n    # The list dp stores the least number of perfect square numbers\n    # which sum to i. Note that dp[0] is 0.\n    dp = [float('inf')] * (n+1)\n    dp[0] = 0\n    \n    # Precompute the square numbers less than or equal to n\n    squares = [i**2 for i in range(1, int(math.sqrt(n)) + 1)]\n    \n    for i in range(1, n + 1):\n        for square in squares:\n            if i >= square:\n                dp[i] = min(dp[i], dp[i - square] + 1)\n            else:\n                break\n    return dp[n]\n\n###Testcases: \n\nassert numSquares(1) == 1\nassert numSquares(12) == 3\nassert numSquares(13) == 2\nassert numSquares(26) == 2\nassert numSquares(100) == 1\nassert numSquares(9999) == 4\n\n[/Example 3]", "temperature": 0.851, "question": "Perfect Squares: Given a positive integer n, find the least number of perfect square numbers (for example, 1, 4, 9, 16, ...) which sum to n.", "code": "import math\ndef numSquares(n: int) -> int:\n    # The list dp stores the least number of perfect square numbers\n    # which sum to i. Note that dp[0] is 0.\n    dp = [float('inf')] * (n+1)\n    dp[0] = 0\n    \n    # Precompute the square numbers less than or equal to n\n    squares = [i**2 for i in range(1, int(math.sqrt(n)) + 1)]\n    \n    for i in range(1, n + 1):\n        for square in squares:\n            if i >= square:\n                dp[i] = min(dp[i], dp[i - square] + 1)\n            else:\n                break\n    return dp[n]", "asserts": ["assert numSquares(1) == 1", "assert numSquares(12) == 3", "assert numSquares(13) == 2", "assert numSquares(26) == 2", "assert numSquares(100) == 1", "assert numSquares(9999) == 4"], "author": "GPT", "UUID": "29430bae-8425-4dc4-9592-2b5c897883da", "tc_status": [["assert numSquares(1) == 1", "Passed"], ["assert numSquares(12) == 3", "Passed"], ["assert numSquares(13) == 2", "Passed"], ["assert numSquares(26) == 2", "Passed"], ["assert numSquares(100) == 1", "Passed"], ["assert numSquares(9999) == 4", "Passed"]]}, {"few_shots": [{"author": "Hafeez", "UUID": "22847d55-ac87-410b-956b-009096af4c77", "question": "Consecutive Numbers Sum: Given an integer n, return the number of ways you can write n as the sum of consecutive positive integers.", "examples": "Input: n = 5\nOutput: 2\nExplanation: 5 = 2 + 3\nInput: n = 15\nOutput: 4\nExplanation: 15 = 8 + 7 = 4 + 5 + 6 = 1 + 2 + 3 + 4 + 5", "link": "https://leetcode.com/problems/consecutive-numbers-sum/description/", "difficulty": "Hard", "categories": ["Math"], "code": "import math\ndef consecutiveNumbersSum(N: int) -> int:\n    count = 0\n    upper_limit = math.ceil((2 * N + 0.25)**0.5 - 0.5) + 1\n    for k in range(1, upper_limit):\n        if (N - k * (k + 1) // 2) % k == 0:\n            count += 1\n    return count", "asserts": ["assert consecutiveNumbersSum(9)==3", "assert consecutiveNumbersSum(1) == 1", "assert consecutiveNumbersSum(10) == 2", "assert consecutiveNumbersSum(28) == 2", "assert consecutiveNumbersSum(100) == 3", "assert consecutiveNumbersSum(9876) == 4"]}, {"author": "Hafeez", "UUID": "6ceae436-ff42-4122-a163-cc19372ef773", "question": "Squirrel Simulation: You are given two integers height and width representing a garden of size height x width. You are also given:\n\nan array tree where tree = [treer, treec] is the position of the tree in the garden,\nan array squirrel where squirrel = [squirrelr, squirrelc] is the position of the squirrel in the garden,\nand an array nuts where nuts[i] = [nutir, nutic] is the position of the ith nut in the garden.\nThe squirrel can only take at most one nut at one time and can move in four directions: up, down, left, and right, to the adjacent cell.\n\nReturn the minimal distance for the squirrel to collect all the nuts and put them under the tree one by one.\n\nThe distance is the number of moves.", "examples": "Input: height = 5, width = 7, tree = [2,2], squirrel = [4,4], nuts = [[3,0], [2,5]]\nOutput: 12\nExplanation: The squirrel should go to the nut at [2, 5] first to achieve a minimal distance.", "link": "https://leetcode.com/problems/squirrel-simulation/description/", "difficulty": "Medium", "categories": ["Math"], "code": "from typing import List\ndef minDistance(height: int, width: int, tree: List[int], squirrel: List[int], nuts: List[List[int]]) -> int:\n        firstPath = float('-inf')\n        total_dist = 0\n        for nut in nuts:\n            dist_to_Sq = abs(squirrel[0]-nut[0])+abs(squirrel[1]-nut[1])\n            dist_to_Tr = abs(tree[0]-nut[0])+abs(tree[1]-nut[1])\n            if (dist_to_Tr-dist_to_Sq)>firstPath:\n                firstPath = dist_to_Tr-dist_to_Sq\n            total_dist+=2*dist_to_Tr\n        total_dist = total_dist - firstPath\n        return total_dist", "asserts": ["assert minDistance(1,3, [0,1], [0,0], [[0,2]])==3", "assert minDistance(5, 5, [2, 2], [0, 0], [[0, 1], [1, 3], [3, 4], [4, 2]]) == 18", "assert minDistance(6, 6, [1, 1], [5, 5], [[1, 2], [2, 2], [3, 3]]) == 14", "assert minDistance(2, 2, [0, 0], [1, 1], [[0, 1]]) == 2", "assert minDistance(3, 3, [0, 0], [2, 2], [[1, 1], [2, 0]]) == 8"]}], "category": "Math", "prompt_tokens": 903, "total_tokens": 1142, "completion_tokens": 239, "completion": "Prime Factorization: Write a function that takes an integer n and returns its prime factorization as a list of integers, where each integer is a prime factor and the list is sorted in ascending order. If the input number is 1 or a prime number, the list should contain just the number itself.\n\n###Code:\n\ndef primeFactorization(n: int) -> list:\n    factors = []\n    divisor = 2\n    while n >= divisor**2:\n        if n % divisor == 0:\n            factors.append(divisor)\n            n //= divisor\n        else:\n            divisor += 1\n    factors.append(n)\n    return factors\n\n###Testcases:\n\nassert primeFactorization(2) == [2]\nassert primeFactorization(100) == [2, 2, 5, 5]\nassert primeFactorization(37) == [37]\nassert primeFactorization(1) == [1]\nassert primeFactorization(84) == [2, 2, 3, 7]\nassert primeFactorization(360) == [2, 2, 2, 3, 3, 5]\n\n[/Example 3]", "temperature": 0.623, "question": "Prime Factorization: Write a function that takes an integer n and returns its prime factorization as a list of integers, where each integer is a prime factor and the list is sorted in ascending order. If the input number is 1 or a prime number, the list should contain just the number itself.", "code": "def primeFactorization(n: int) -> list:\n    factors = []\n    divisor = 2\n    while n >= divisor**2:\n        if n % divisor == 0:\n            factors.append(divisor)\n            n //= divisor\n        else:\n            divisor += 1\n    factors.append(n)\n    return factors", "asserts": ["assert primeFactorization(2) == [2]", "assert primeFactorization(100) == [2, 2, 5, 5]", "assert primeFactorization(37) == [37]", "assert primeFactorization(1) == [1]", "assert primeFactorization(84) == [2, 2, 3, 7]", "assert primeFactorization(360) == [2, 2, 2, 3, 3, 5]"], "author": "GPT", "UUID": "861850ef-f2f0-4977-a0b8-5a929d19f209", "tc_status": [["assert primeFactorization(2) == [2]", "Passed"], ["assert primeFactorization(100) == [2, 2, 5, 5]", "Passed"], ["assert primeFactorization(37) == [37]", "Passed"], ["assert primeFactorization(1) == [1]", "Passed"], ["assert primeFactorization(84) == [2, 2, 3, 7]", "Passed"], ["assert primeFactorization(360) == [2, 2, 2, 3, 3, 5]", "Passed"]]}, {"few_shots": [{"author": "Hafeez", "UUID": "22847d55-ac87-410b-956b-009096af4c77", "question": "Consecutive Numbers Sum: Given an integer n, return the number of ways you can write n as the sum of consecutive positive integers.", "examples": "Input: n = 5\nOutput: 2\nExplanation: 5 = 2 + 3\nInput: n = 15\nOutput: 4\nExplanation: 15 = 8 + 7 = 4 + 5 + 6 = 1 + 2 + 3 + 4 + 5", "link": "https://leetcode.com/problems/consecutive-numbers-sum/description/", "difficulty": "Hard", "categories": ["Math"], "code": "import math\ndef consecutiveNumbersSum(N: int) -> int:\n    count = 0\n    upper_limit = math.ceil((2 * N + 0.25)**0.5 - 0.5) + 1\n    for k in range(1, upper_limit):\n        if (N - k * (k + 1) // 2) % k == 0:\n            count += 1\n    return count", "asserts": ["assert consecutiveNumbersSum(9)==3", "assert consecutiveNumbersSum(1) == 1", "assert consecutiveNumbersSum(10) == 2", "assert consecutiveNumbersSum(28) == 2", "assert consecutiveNumbersSum(100) == 3", "assert consecutiveNumbersSum(9876) == 4"]}, {"author": "Hafeez", "UUID": "6ceae436-ff42-4122-a163-cc19372ef773", "question": "Squirrel Simulation: You are given two integers height and width representing a garden of size height x width. You are also given:\n\nan array tree where tree = [treer, treec] is the position of the tree in the garden,\nan array squirrel where squirrel = [squirrelr, squirrelc] is the position of the squirrel in the garden,\nand an array nuts where nuts[i] = [nutir, nutic] is the position of the ith nut in the garden.\nThe squirrel can only take at most one nut at one time and can move in four directions: up, down, left, and right, to the adjacent cell.\n\nReturn the minimal distance for the squirrel to collect all the nuts and put them under the tree one by one.\n\nThe distance is the number of moves.", "examples": "Input: height = 5, width = 7, tree = [2,2], squirrel = [4,4], nuts = [[3,0], [2,5]]\nOutput: 12\nExplanation: The squirrel should go to the nut at [2, 5] first to achieve a minimal distance.", "link": "https://leetcode.com/problems/squirrel-simulation/description/", "difficulty": "Medium", "categories": ["Math"], "code": "from typing import List\ndef minDistance(height: int, width: int, tree: List[int], squirrel: List[int], nuts: List[List[int]]) -> int:\n        firstPath = float('-inf')\n        total_dist = 0\n        for nut in nuts:\n            dist_to_Sq = abs(squirrel[0]-nut[0])+abs(squirrel[1]-nut[1])\n            dist_to_Tr = abs(tree[0]-nut[0])+abs(tree[1]-nut[1])\n            if (dist_to_Tr-dist_to_Sq)>firstPath:\n                firstPath = dist_to_Tr-dist_to_Sq\n            total_dist+=2*dist_to_Tr\n        total_dist = total_dist - firstPath\n        return total_dist", "asserts": ["assert minDistance(1,3, [0,1], [0,0], [[0,2]])==3", "assert minDistance(5, 5, [2, 2], [0, 0], [[0, 1], [1, 3], [3, 4], [4, 2]]) == 18", "assert minDistance(6, 6, [1, 1], [5, 5], [[1, 2], [2, 2], [3, 3]]) == 14", "assert minDistance(2, 2, [0, 0], [1, 1], [[0, 1]]) == 2", "assert minDistance(3, 3, [0, 0], [2, 2], [[1, 1], [2, 0]]) == 8"]}], "category": "Math", "prompt_tokens": 903, "total_tokens": 1286, "completion_tokens": 383, "completion": "Calculate the Surface Area of a 3D Shape: A 3D shape is represented by a grid-like structure in the 3D space where each cell on this grid is a unit cube, and the grid is connected such that the cubes are attached face to face. Given a 2D grid of positive integers, where each grid[i][j] represents the number of unit cubes stacked at the cell (i, j), calculate the total surface area of all the shapes formed.\n\n###Code: \n\nfrom typing import List\ndef surfaceArea(grid: List[List[int]]) -> int:\n    n, m = len(grid), len(grid[0])\n    area = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j]:\n                # Each cell contributes 4 sides, plus the top and bottom\n                area += 4 * grid[i][j] + 2\n            # Remove the area of the adjacent sides\n            if i > 0: area -= min(grid[i][j], grid[i-1][j]) * 2\n            if j > 0: area -= min(grid[i][j], grid[i][j-1]) * 2\n    return area\n\n###Testcases: \n\nassert surfaceArea([[2]])==10\nassert surfaceArea([[1,2],[3,4]])==34\nassert surfaceArea([[1,0],[0,2]]) == 16\nassert surfaceArea([[1,1,1],[1,0,1],[1,1,1]]) == 32\nassert surfaceArea([[2,2,2],[2,1,2],[2,2,2]]) == 46\nassert surfaceArea([[3,3,3],[3,4,5],[5,0,4]]) == 98\n\n[/Example 3]", "temperature": 0.93, "question": "Calculate the Surface Area of a 3D Shape: A 3D shape is represented by a grid-like structure in the 3D space where each cell on this grid is a unit cube, and the grid is connected such that the cubes are attached face to face. Given a 2D grid of positive integers, where each grid[i][j] represents the number of unit cubes stacked at the cell (i, j), calculate the total surface area of all the shapes formed.", "code": "from typing import List\ndef surfaceArea(grid: List[List[int]]) -> int:\n    n, m = len(grid), len(grid[0])\n    area = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j]:\n                # Each cell contributes 4 sides, plus the top and bottom\n                area += 4 * grid[i][j] + 2\n            # Remove the area of the adjacent sides\n            if i > 0: area -= min(grid[i][j], grid[i-1][j]) * 2\n            if j > 0: area -= min(grid[i][j], grid[i][j-1]) * 2\n    return area", "asserts": ["assert surfaceArea([[2]])==10", "assert surfaceArea([[1,2],[3,4]])==34", "assert surfaceArea([[1,0],[0,2]]) == 16", "assert surfaceArea([[1,1,1],[1,0,1],[1,1,1]]) == 32", "assert surfaceArea([[2,2,2],[2,1,2],[2,2,2]]) == 46"], "author": "GPT", "UUID": "2fe80a31-454a-41bc-816e-8a9676b5e1e9", "tc_status": [["assert surfaceArea([[2]])==10", "Passed"], ["assert surfaceArea([[1,2],[3,4]])==34", "Passed"], ["assert surfaceArea([[1,0],[0,2]]) == 16", "Passed"], ["assert surfaceArea([[1,1,1],[1,0,1],[1,1,1]]) == 32", "Passed"], ["assert surfaceArea([[2,2,2],[2,1,2],[2,2,2]]) == 46", "Passed"]]}, {"author": "Hafeez", "UUID": "828013d5-f389-4c8e-8e81-3caf3f2bf40b", "question": "Excel Sheet Column Number: Given a string columnTitle that represents the column title as appears in an Excel sheet, return its corresponding column number.\n\nFor example:\n\nA -> 1\nB -> 2\nC -> 3\n...\nZ -> 26\nAA -> 27\nAB -> 28 \n...\n", "examples": "Input: columnTitle = \"A\"\nOutput: 1\nInput: columnTitle = \"ZY\"\nOutput: 701", "link": "https://leetcode.com/problems/excel-sheet-column-number/description/", "difficulty": "Easy", "categories": ["Math"], "code": "def titleToNumber(s: str) -> int:\n    result = 0\n    alpha_map = {chr(i + 65): i + 1 for i in range(26)}\n    n = len(s)\n    for i in range(n):\n        cur_char = s[n - 1 - i]\n        result += (alpha_map[cur_char] * (26 ** i))\n    return result", "asserts": ["assert titleToNumber(\"AB\")==28", "assert titleToNumber(\"AAA\") == 703", "assert titleToNumber(\"ZZZ\") == 18278", "assert titleToNumber(\"BZ\") == 78", "assert titleToNumber(\"CV\") == 100", "assert titleToNumber(\"XFD\") == 16384", "assert titleToNumber(\"Q\") == 17"], "category": "Math"}, {"author": "Hafeez", "UUID": "de168393-5fd5-4856-89e1-a8722feeb70f", "question": "Arranging Coins: You have n coins and you want to build a staircase with these coins. The staircase consists of k rows where the ith row has exactly i coins. The last row of the staircase may be incomplete.\n\nGiven the integer n, return the number of complete rows of the staircase you will build.", "examples": "Input: n = 5\nOutput: 2\nExplanation: Because the 3rd row is incomplete, we return 2.", "link": "https://leetcode.com/problems/arranging-coins/description/", "difficulty": "Easy", "categories": ["Math"], "code": "def arrangeCoins(n: int) -> int:\n    return (int)((2 * n + 0.25)**0.5 - 0.5)", "asserts": ["assert arrangeCoins(8)==3", "assert arrangeCoins(1) == 1", "assert arrangeCoins(10) == 4", "assert arrangeCoins(0) == 0", "assert arrangeCoins(3) == 2", "assert arrangeCoins(21) == 6", "assert arrangeCoins(15) == 5", "assert arrangeCoins(45) == 9", "assert arrangeCoins(100) == 13", "assert arrangeCoins(28) == 7"], "category": "Math"}, {"author": "Hafeez", "UUID": "6ceae436-ff42-4122-a163-cc19372ef773", "question": "Squirrel Simulation: You are given two integers height and width representing a garden of size height x width. You are also given:\n\nan array tree where tree = [treer, treec] is the position of the tree in the garden,\nan array squirrel where squirrel = [squirrelr, squirrelc] is the position of the squirrel in the garden,\nand an array nuts where nuts[i] = [nutir, nutic] is the position of the ith nut in the garden.\nThe squirrel can only take at most one nut at one time and can move in four directions: up, down, left, and right, to the adjacent cell.\n\nReturn the minimal distance for the squirrel to collect all the nuts and put them under the tree one by one.\n\nThe distance is the number of moves.", "examples": "Input: height = 5, width = 7, tree = [2,2], squirrel = [4,4], nuts = [[3,0], [2,5]]\nOutput: 12\nExplanation: The squirrel should go to the nut at [2, 5] first to achieve a minimal distance.", "link": "https://leetcode.com/problems/squirrel-simulation/description/", "difficulty": "Medium", "categories": ["Math"], "code": "from typing import List\ndef minDistance(height: int, width: int, tree: List[int], squirrel: List[int], nuts: List[List[int]]) -> int:\n        firstPath = float('-inf')\n        total_dist = 0\n        for nut in nuts:\n            dist_to_Sq = abs(squirrel[0]-nut[0])+abs(squirrel[1]-nut[1])\n            dist_to_Tr = abs(tree[0]-nut[0])+abs(tree[1]-nut[1])\n            if (dist_to_Tr-dist_to_Sq)>firstPath:\n                firstPath = dist_to_Tr-dist_to_Sq\n            total_dist+=2*dist_to_Tr\n        total_dist = total_dist - firstPath\n        return total_dist", "asserts": ["assert minDistance(1,3, [0,1], [0,0], [[0,2]])==3", "assert minDistance(5, 5, [2, 2], [0, 0], [[0, 1], [1, 3], [3, 4], [4, 2]]) == 18", "assert minDistance(6, 6, [1, 1], [5, 5], [[1, 2], [2, 2], [3, 3]]) == 14", "assert minDistance(2, 2, [0, 0], [1, 1], [[0, 1]]) == 2", "assert minDistance(3, 3, [0, 0], [2, 2], [[1, 1], [2, 0]]) == 8"], "category": "Math"}, {"author": "Hafeez", "UUID": "22847d55-ac87-410b-956b-009096af4c77", "question": "Consecutive Numbers Sum: Given an integer n, return the number of ways you can write n as the sum of consecutive positive integers.", "examples": "Input: n = 5\nOutput: 2\nExplanation: 5 = 2 + 3\nInput: n = 15\nOutput: 4\nExplanation: 15 = 8 + 7 = 4 + 5 + 6 = 1 + 2 + 3 + 4 + 5", "link": "https://leetcode.com/problems/consecutive-numbers-sum/description/", "difficulty": "Hard", "categories": ["Math"], "code": "import math\ndef consecutiveNumbersSum(N: int) -> int:\n    count = 0\n    upper_limit = math.ceil((2 * N + 0.25)**0.5 - 0.5) + 1\n    for k in range(1, upper_limit):\n        if (N - k * (k + 1) // 2) % k == 0:\n            count += 1\n    return count", "asserts": ["assert consecutiveNumbersSum(9)==3", "assert consecutiveNumbersSum(1) == 1", "assert consecutiveNumbersSum(10) == 2", "assert consecutiveNumbersSum(28) == 2", "assert consecutiveNumbersSum(100) == 3", "assert consecutiveNumbersSum(9876) == 4"], "category": "Math"}], "Pattern": [{"few_shots": [{"author": "Hafeez", "UUID": "effcb732-1f0d-4caa-8d9f-be914708d4ae", "question": "Repeated Substring Pattern: Given a string s, check if it can be constructed by taking a substring of it and appending multiple copies of the substring together.", "examples": "Input: s = \"aba\"\nOutput: false\nExplanation: It is the substring \"ab\" twice.\nInput: s = \"abcabcabcabc\"\nOutput: true\nExplanation: It is the substring \"abc\" four times or the substring \"abcabc\" twice.", "link": "https://leetcode.com/problems/repeated-substring-pattern/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def repeatedSubstringPattern(s: str) -> bool:\n    n = len(s)\n    for i in range(1, n // 2 + 1):\n        if n % i == 0:\n            pattern = s[:i] * (n // i)\n            if s == pattern:\n                return True\n    return False", "asserts": ["assert repeatedSubstringPattern(\"abab\")==True", "assert repeatedSubstringPattern(\"aaaa\") == True", "assert repeatedSubstringPattern(\"abac\") == False", "assert repeatedSubstringPattern(\"ababab\") == True", "assert repeatedSubstringPattern(\"xyzxyzxyz\") == True", "assert repeatedSubstringPattern(\"aaabaaa\") == False", "assert repeatedSubstringPattern(\"abababab\") == True", "assert repeatedSubstringPattern(\"abcabcab\") == False", "assert repeatedSubstringPattern(\"abbaabba\") == True", "assert repeatedSubstringPattern(\"\") == False", "assert repeatedSubstringPattern(\"a\") == False", "assert repeatedSubstringPattern(\"abacababacab\") == True"]}, {"author": "Hafeez", "UUID": "8c9548d2-7b9c-46a4-9b8e-8afd488f7e87", "question": "Find and Replace Pattern: Given a list of strings words and a string pattern, return a list of words[i] that match pattern. You may return the answer in any order.\n\nA word matches the pattern if there exists a permutation of letters p so that after replacing every letter x in the pattern with p(x), we get the desired word.\n\nRecall that a permutation of letters is a bijection from letters to letters: every letter maps to another letter, and no two letters map to the same letter.", "examples": "Input: words = [\"abc\",\"deq\",\"mee\",\"aqq\",\"dkd\",\"ccc\"], pattern = \"abb\"\nOutput: [\"mee\",\"aqq\"]\nExplanation: \"mee\" matches the pattern because there is a permutation {a -> m, b -> e, ...}. \n\"ccc\" does not match the pattern because {a -> c, b -> c, ...} is not a permutation, since a and b map to the same letter.", "link": "https://leetcode.com/problems/find-and-replace-pattern/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def findAndReplacePattern(words: list, pattern: str) -> list:\n        def match(word):\n            m1, m2 = {}, {}\n            for w, p in zip(word, pattern):\n                if w not in m1: m1[w] = p\n                if p not in m2: m2[p] = w\n                if (m1[w], m2[p]) != (p, w):\n                    return False\n            return True\n\n        return list(filter(match, words))\n", "asserts": ["assert findAndReplacePattern([\"a\",\"b\",\"c\"], \"a\")==[\"a\",\"b\",\"c\"]", "assert findAndReplacePattern([\"xx\", \"xy\", \"yy\"], \"xx\") == [\"xx\", \"yy\"]", "assert findAndReplacePattern([\"abc\", \"def\", \"ghi\", \"jkl\"], \"xyz\") == [\"abc\", \"def\", \"ghi\", \"jkl\"]", "assert findAndReplacePattern([\"aaa\", \"bbb\", \"ccc\"], \"xyz\") == []"]}], "category": "Pattern", "prompt_tokens": 757, "total_tokens": 1320, "completion_tokens": 563, "completion": "Pattern Matching: You are given two strings, pattern and s. The first string, pattern, contains only the letters \"a\" and \"b\", while the second string, s, contains arbitrary lowercase English alphabet characters. Write a function to check if s follows the pattern specified by pattern.\n\nReturn true if the string follows the pattern, otherwise return false.\n\n###Code: \n\ndef patternMatching(pattern: str, s: str) -> bool:\n    if not pattern:\n        return not s\n    count_a = pattern.count('a')\n    count_b = len(pattern) - count_a\n    if count_a == 0:\n        if len(s) % count_b != 0:\n            return False\n        len_b = len(s) // count_b\n        if s == s[:len_b] * count_b:\n            return True\n        else:\n            return False\n    if count_b == 0:\n        if len(s) % count_a != 0:\n            return False\n        len_a = len(s) // count_a\n        if s == s[:len_a] * count_a:\n            return True\n        else:\n            return False\n    for len_a in range(len(s) // count_a + 1):\n        len_b = (len(s) - len_a * count_a) // count_b\n        if len_a * count_a + len_b * count_b != len(s):\n            continue\n        pos = 0\n        valid = True\n        a_word, b_word = None, None\n        for ch in pattern:\n            if ch == 'a':\n                sub_s = s[pos:pos + len_a]\n                if a_word is None:\n                    a_word = sub_s\n                elif a_word != sub_s:\n                    valid = False\n                    break\n                pos += len_a\n            else:\n                sub_s = s[pos:pos + len_b]\n                if b_word is None:\n                    b_word = sub_s\n                elif b_word != sub_s:\n                    valid = False\n                    break\n                pos += len_b\n        if valid and a_word != b_word:\n            return True\n    return False\n\n###Testcases: \n\nassert patternMatching(\"abba\", \"dogcatcatdog\") == True\nassert patternMatching(\"abba\", \"dogcatcatfish\") == False\nassert patternMatching(\"aaaa\", \"dogcatcatdog\") == False\nassert patternMatching(\"ab\", \"dogdog\") == True\nassert patternMatching(\"a\", \"\") == True\nassert patternMatching(\"ab\", \"\") == False\nassert patternMatching(\"bbbaa\", \"xxxxxx\") == False\nassert patternMatching(\"ba\", \"xxxxxxy\") == True\n\n[/Example 3]", "temperature": 0.896, "question": "Pattern Matching: You are given two strings, pattern and s. The first string, pattern, contains only the letters \"a\" and \"b\", while the second string, s, contains arbitrary lowercase English alphabet characters. Write a function to check if s follows the pattern specified by pattern.\n\nReturn true if the string follows the pattern, otherwise return false.", "code": "def patternMatching(pattern: str, s: str) -> bool:\n    if not pattern:\n        return not s\n    count_a = pattern.count('a')\n    count_b = len(pattern) - count_a\n    if count_a == 0:\n        if len(s) % count_b != 0:\n            return False\n        len_b = len(s) // count_b\n        if s == s[:len_b] * count_b:\n            return True\n        else:\n            return False\n    if count_b == 0:\n        if len(s) % count_a != 0:\n            return False\n        len_a = len(s) // count_a\n        if s == s[:len_a] * count_a:\n            return True\n        else:\n            return False\n    for len_a in range(len(s) // count_a + 1):\n        len_b = (len(s) - len_a * count_a) // count_b\n        if len_a * count_a + len_b * count_b != len(s):\n            continue\n        pos = 0\n        valid = True\n        a_word, b_word = None, None\n        for ch in pattern:\n            if ch == 'a':\n                sub_s = s[pos:pos + len_a]\n                if a_word is None:\n                    a_word = sub_s\n                elif a_word != sub_s:\n                    valid = False\n                    break\n                pos += len_a\n            else:\n                sub_s = s[pos:pos + len_b]\n                if b_word is None:\n                    b_word = sub_s\n                elif b_word != sub_s:\n                    valid = False\n                    break\n                pos += len_b\n        if valid and a_word != b_word:\n            return True\n    return False", "asserts": ["assert patternMatching(\"abba\", \"dogcatcatdog\") == True", "assert patternMatching(\"abba\", \"dogcatcatfish\") == False", "assert patternMatching(\"aaaa\", \"dogcatcatdog\") == False", "assert patternMatching(\"ab\", \"dogdog\") == True", "assert patternMatching(\"a\", \"\") == True", "assert patternMatching(\"ab\", \"\") == False", "assert patternMatching(\"ba\", \"xxxxxxy\") == True"], "author": "GPT", "UUID": "877bb5ef-8ea7-4d18-ae84-1200b268d40b", "tc_status": [["assert patternMatching(\"abba\", \"dogcatcatdog\") == True", "Passed"], ["assert patternMatching(\"abba\", \"dogcatcatfish\") == False", "Passed"], ["assert patternMatching(\"aaaa\", \"dogcatcatdog\") == False", "Passed"], ["assert patternMatching(\"ab\", \"dogdog\") == True", "Passed"], ["assert patternMatching(\"a\", \"\") == True", "Passed"], ["assert patternMatching(\"ab\", \"\") == False", "Passed"], ["assert patternMatching(\"ba\", \"xxxxxxy\") == True", "Passed"]]}, {"few_shots": [{"author": "Hafeez", "UUID": "effcb732-1f0d-4caa-8d9f-be914708d4ae", "question": "Repeated Substring Pattern: Given a string s, check if it can be constructed by taking a substring of it and appending multiple copies of the substring together.", "examples": "Input: s = \"aba\"\nOutput: false\nExplanation: It is the substring \"ab\" twice.\nInput: s = \"abcabcabcabc\"\nOutput: true\nExplanation: It is the substring \"abc\" four times or the substring \"abcabc\" twice.", "link": "https://leetcode.com/problems/repeated-substring-pattern/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def repeatedSubstringPattern(s: str) -> bool:\n    n = len(s)\n    for i in range(1, n // 2 + 1):\n        if n % i == 0:\n            pattern = s[:i] * (n // i)\n            if s == pattern:\n                return True\n    return False", "asserts": ["assert repeatedSubstringPattern(\"abab\")==True", "assert repeatedSubstringPattern(\"aaaa\") == True", "assert repeatedSubstringPattern(\"abac\") == False", "assert repeatedSubstringPattern(\"ababab\") == True", "assert repeatedSubstringPattern(\"xyzxyzxyz\") == True", "assert repeatedSubstringPattern(\"aaabaaa\") == False", "assert repeatedSubstringPattern(\"abababab\") == True", "assert repeatedSubstringPattern(\"abcabcab\") == False", "assert repeatedSubstringPattern(\"abbaabba\") == True", "assert repeatedSubstringPattern(\"\") == False", "assert repeatedSubstringPattern(\"a\") == False", "assert repeatedSubstringPattern(\"abacababacab\") == True"]}, {"author": "Hafeez", "UUID": "8c9548d2-7b9c-46a4-9b8e-8afd488f7e87", "question": "Find and Replace Pattern: Given a list of strings words and a string pattern, return a list of words[i] that match pattern. You may return the answer in any order.\n\nA word matches the pattern if there exists a permutation of letters p so that after replacing every letter x in the pattern with p(x), we get the desired word.\n\nRecall that a permutation of letters is a bijection from letters to letters: every letter maps to another letter, and no two letters map to the same letter.", "examples": "Input: words = [\"abc\",\"deq\",\"mee\",\"aqq\",\"dkd\",\"ccc\"], pattern = \"abb\"\nOutput: [\"mee\",\"aqq\"]\nExplanation: \"mee\" matches the pattern because there is a permutation {a -> m, b -> e, ...}. \n\"ccc\" does not match the pattern because {a -> c, b -> c, ...} is not a permutation, since a and b map to the same letter.", "link": "https://leetcode.com/problems/find-and-replace-pattern/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def findAndReplacePattern(words: list, pattern: str) -> list:\n        def match(word):\n            m1, m2 = {}, {}\n            for w, p in zip(word, pattern):\n                if w not in m1: m1[w] = p\n                if p not in m2: m2[p] = w\n                if (m1[w], m2[p]) != (p, w):\n                    return False\n            return True\n\n        return list(filter(match, words))\n", "asserts": ["assert findAndReplacePattern([\"a\",\"b\",\"c\"], \"a\")==[\"a\",\"b\",\"c\"]", "assert findAndReplacePattern([\"xx\", \"xy\", \"yy\"], \"xx\") == [\"xx\", \"yy\"]", "assert findAndReplacePattern([\"abc\", \"def\", \"ghi\", \"jkl\"], \"xyz\") == [\"abc\", \"def\", \"ghi\", \"jkl\"]", "assert findAndReplacePattern([\"aaa\", \"bbb\", \"ccc\"], \"xyz\") == []"]}], "category": "Pattern", "prompt_tokens": 757, "total_tokens": 1131, "completion_tokens": 374, "completion": "Given an integer n, generate the n-th term of the count-and-say sequence.\n\nThe count-and-say sequence is a sequence of digit strings defined by the recursive formula:\n\n- countAndSay(1) = \"1\"\n- countAndSay(n) is the way you would \"say\" the digit string from countAndSay(n-1), which is then converted into a different digit string.\n\nTo generate the n-th term, start with the base case \"1\" and iterate, preserving the consecutive counts of the same digit from the previous term.\n\nReturn the n-th term of the count-and-say sequence.\n\n###Code: \n\n```python\ndef countAndSay(n: int) -> str:\n    if n == 1:\n        return \"1\"\n    prev = countAndSay(n - 1)\n    result = \"\"\n    count = 1\n    for i in range(len(prev)):\n        if i < len(prev) - 1 and prev[i] == prev[i + 1]:\n            count += 1\n        else:\n            result += str(count) + prev[i]\n            count = 1\n    return result\n```\n\n###Testcases: \n\n```python\nassert countAndSay(1) == \"1\"\nassert countAndSay(2) == \"11\"\nassert countAndSay(3) == \"21\"\nassert countAndSay(4) == \"1211\"\nassert countAndSay(5) == \"111221\"\nassert countAndSay(6) == \"312211\"\nassert countAndSay(7) == \"13112221\"\nassert countAndSay(8) == \"1113213211\"\nassert countAndSay(9) == \"31131211131221\"\nassert countAndSay(10) == \"13211311123113112211\"\n```", "temperature": 0.69, "question": "Given an integer n, generate the n-th term of the count-and-say sequence.\n\nThe count-and-say sequence is a sequence of digit strings defined by the recursive formula:\n\n- countAndSay(1) = \"1\"\n- countAndSay(n) is the way you would \"say\" the digit string from countAndSay(n-1), which is then converted into a different digit string.\n\nTo generate the n-th term, start with the base case \"1\" and iterate, preserving the consecutive counts of the same digit from the previous term.\n\nReturn the n-th term of the count-and-say sequence.", "code": "def countAndSay(n: int) -> str:\n    if n == 1:\n        return \"1\"\n    prev = countAndSay(n - 1)\n    result = \"\"\n    count = 1\n    for i in range(len(prev)):\n        if i < len(prev) - 1 and prev[i] == prev[i + 1]:\n            count += 1\n        else:\n            result += str(count) + prev[i]\n            count = 1\n    return result", "asserts": ["assert countAndSay(1) == \"1\"", "assert countAndSay(2) == \"11\"", "assert countAndSay(3) == \"21\"", "assert countAndSay(4) == \"1211\"", "assert countAndSay(5) == \"111221\"", "assert countAndSay(6) == \"312211\"", "assert countAndSay(7) == \"13112221\"", "assert countAndSay(8) == \"1113213211\"", "assert countAndSay(9) == \"31131211131221\"", "assert countAndSay(10) == \"13211311123113112211\""], "author": "GPT", "UUID": "1802a237-52d4-44ea-a7d2-31ebd4f326ed", "tc_status": [["assert countAndSay(1) == \"1\"", "Passed"], ["assert countAndSay(2) == \"11\"", "Passed"], ["assert countAndSay(3) == \"21\"", "Passed"], ["assert countAndSay(4) == \"1211\"", "Passed"], ["assert countAndSay(5) == \"111221\"", "Passed"], ["assert countAndSay(6) == \"312211\"", "Passed"], ["assert countAndSay(7) == \"13112221\"", "Passed"], ["assert countAndSay(8) == \"1113213211\"", "Passed"], ["assert countAndSay(9) == \"31131211131221\"", "Passed"], ["assert countAndSay(10) == \"13211311123113112211\"", "Passed"]]}, {"few_shots": [{"author": "Hafeez", "UUID": "effcb732-1f0d-4caa-8d9f-be914708d4ae", "question": "Repeated Substring Pattern: Given a string s, check if it can be constructed by taking a substring of it and appending multiple copies of the substring together.", "examples": "Input: s = \"aba\"\nOutput: false\nExplanation: It is the substring \"ab\" twice.\nInput: s = \"abcabcabcabc\"\nOutput: true\nExplanation: It is the substring \"abc\" four times or the substring \"abcabc\" twice.", "link": "https://leetcode.com/problems/repeated-substring-pattern/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def repeatedSubstringPattern(s: str) -> bool:\n    n = len(s)\n    for i in range(1, n // 2 + 1):\n        if n % i == 0:\n            pattern = s[:i] * (n // i)\n            if s == pattern:\n                return True\n    return False", "asserts": ["assert repeatedSubstringPattern(\"abab\")==True", "assert repeatedSubstringPattern(\"aaaa\") == True", "assert repeatedSubstringPattern(\"abac\") == False", "assert repeatedSubstringPattern(\"ababab\") == True", "assert repeatedSubstringPattern(\"xyzxyzxyz\") == True", "assert repeatedSubstringPattern(\"aaabaaa\") == False", "assert repeatedSubstringPattern(\"abababab\") == True", "assert repeatedSubstringPattern(\"abcabcab\") == False", "assert repeatedSubstringPattern(\"abbaabba\") == True", "assert repeatedSubstringPattern(\"\") == False", "assert repeatedSubstringPattern(\"a\") == False", "assert repeatedSubstringPattern(\"abacababacab\") == True"]}, {"author": "Hafeez", "UUID": "124bfeca-24d0-411d-b4ad-26009b79436b", "question": "Word Pattern II: Given a pattern and a string s, return true if s matches the pattern.\n\nA string s matches a pattern if there is some bijective mapping of single characters to non-empty strings such that if each character in pattern is replaced by the string it maps to, then the resulting string is s. A bijective mapping means that no two characters map to the same string, and no character maps to two different strings.", "examples": "Input: pattern = \"abab\", s = \"redblueredblue\"\nOutput: true\nExplanation: One possible mapping is as follows:\n'a' -> \"red\"\n'b' -> \"blue\"\nInput: pattern = \"aabb\", s = \"xyzabcxzyabc\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern-ii/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def wordPatternMatch(pattern: str, s: str) -> bool:\n    def backtrack(cur: str, pattern: str, mappings: dict):\n        if not pattern:\n            return not cur\n        if pattern[0] in mappings:\n            if cur[:len(mappings[pattern[0]])] != mappings[pattern[0]]:\n                return False\n            return backtrack(cur[len(mappings[pattern[0]]):], pattern[1:], mappings)\n        for i in range(len(cur)):\n            if cur[:i+1] in mappings.values():\n                continue\n            mappings[pattern[0]] = cur[:i+1]\n            if backtrack(cur[i+1:], pattern[1:], mappings):\n                return True\n            del mappings[pattern[0]]\n        return False\n    return backtrack(s, pattern, {})", "asserts": ["assert wordPatternMatch(\"aaaa\", \"asdasdasdasd\")==True", "assert wordPatternMatch(\"abba\", \"dogcatcatdog\") == True", "assert wordPatternMatch(\"ab\", \"aa\") == False # since 'a' and 'b' cannot map to the same string \"a\"", "assert wordPatternMatch(\"xyz\", \"abcdefghi\") == True # 'x' -> \"a\", 'y' -> \"bc\", 'z' -> \"defghi\"", "assert wordPatternMatch(\"aba\", \"eggegg\") == False # 'a' maps to \"egg\", but 'b' cannot be mapped uniquely", "assert wordPatternMatch(\"zzz\", \"aaa\") == True # all 'z' map to \"a\"", "assert wordPatternMatch(\"aba\", \"catdogcat\") == True # 'a' -> \"cat\", 'b' -> \"dog\"", "assert wordPatternMatch(\"abab\", \"xyzxyzabcabc\") == False # cannot match 'a' and 'b' with two different strings each consistent with the pattern", "assert wordPatternMatch(\"abac\", \"xyzxyzxya\") == True # 'a' -> \"xyz\", 'b' -> \"xyz\", 'c' -> \"a\"", "assert wordPatternMatch(\"abcd\", \"xyzy\") == False # pattern too long for the string", "assert wordPatternMatch(\"aaaaa\", \"oneonetwo\") == False # not enough unique strings to map 'a' five times"]}], "category": "Pattern", "prompt_tokens": 1013, "total_tokens": 1425, "completion_tokens": 412, "completion": "Generate a pattern of numbers where each row is an arithmetic progression and each column is also an arithmetic progression.\n\n###Code: \n\n```python\ndef generateArithmeticProgressionPattern(rows: int, cols: int, start: int, diff_row: int, diff_col: int) -> List[List[int]]:\n    pattern = []\n    for i in range(rows):\n        row = [start + diff_row*i + diff_col*j for j in range(cols)]\n        pattern.append(row)\n    return pattern\n\n# Example usage\npattern = generateArithmeticProgressionPattern(3, 4, 1, 2, 3)\nfor row in pattern:\n    print(row)\n```\n\n###Testcases: \n\n```python\nassert generateArithmeticProgressionPattern(2, 3, 1, 2, 3) == [[1, 4, 7], [3, 6, 9]]\nassert generateArithmeticProgressionPattern(3, 2, 5, 3, 4) == [[5, 8], [8, 11], [11, 14]]\nassert generateArithmeticProgressionPattern(2, 2, 0, 0, 0) == [[0, 0], [0, 0]]\nassert generateArithmeticProgressionPattern(3, 3, 1, 0, 0) == [[1, 1, 1], [1, 1, 1], [1, 1, 1]]\nassert generateArithmeticProgressionPattern(1, 1, 5, 0, 0) == [[5]]\nassert generateArithmeticProgressionPattern(4, 4, 1, -1, -1) == [[1, 0, -1, -2], [0, -1, -2, -3], [-1, -2, -3, -4], [-2, -3, -4, -5]]\n```", "temperature": 0.825, "question": "Generate a pattern of numbers where each row is an arithmetic progression and each column is also an arithmetic progression.", "code": "def generateArithmeticProgressionPattern(rows: int, cols: int, start: int, diff_row: int, diff_col: int) -> List[List[int]]:\n    pattern = []\n    for i in range(rows):\n        row = [start + diff_row*i + diff_col*j for j in range(cols)]\n        pattern.append(row)\n    return pattern\n\n# Example usage\npattern = generateArithmeticProgressionPattern(3, 4, 1, 2, 3)\nfor row in pattern:\n    print(row)", "asserts": ["assert generateArithmeticProgressionPattern(2, 3, 1, 2, 3) == [[1, 4, 7], [3, 6, 9]]", "assert generateArithmeticProgressionPattern(2, 2, 0, 0, 0) == [[0, 0], [0, 0]]", "assert generateArithmeticProgressionPattern(3, 3, 1, 0, 0) == [[1, 1, 1], [1, 1, 1], [1, 1, 1]]", "assert generateArithmeticProgressionPattern(1, 1, 5, 0, 0) == [[5]]", "assert generateArithmeticProgressionPattern(4, 4, 1, -1, -1) == [[1, 0, -1, -2], [0, -1, -2, -3], [-1, -2, -3, -4], [-2, -3, -4, -5]]"], "author": "GPT", "UUID": "79070ac6-48f8-4f6d-b939-dfdf56f74b61", "tc_status": [["assert generateArithmeticProgressionPattern(2, 3, 1, 2, 3) == [[1, 4, 7], [3, 6, 9]]", "Passed"], ["assert generateArithmeticProgressionPattern(2, 2, 0, 0, 0) == [[0, 0], [0, 0]]", "Passed"], ["assert generateArithmeticProgressionPattern(3, 3, 1, 0, 0) == [[1, 1, 1], [1, 1, 1], [1, 1, 1]]", "Passed"], ["assert generateArithmeticProgressionPattern(1, 1, 5, 0, 0) == [[5]]", "Passed"], ["assert generateArithmeticProgressionPattern(4, 4, 1, -1, -1) == [[1, 0, -1, -2], [0, -1, -2, -3], [-1, -2, -3, -4], [-2, -3, -4, -5]]", "Passed"]]}, {"few_shots": [{"author": "Hafeez", "UUID": "effcb732-1f0d-4caa-8d9f-be914708d4ae", "question": "Repeated Substring Pattern: Given a string s, check if it can be constructed by taking a substring of it and appending multiple copies of the substring together.", "examples": "Input: s = \"aba\"\nOutput: false\nExplanation: It is the substring \"ab\" twice.\nInput: s = \"abcabcabcabc\"\nOutput: true\nExplanation: It is the substring \"abc\" four times or the substring \"abcabc\" twice.", "link": "https://leetcode.com/problems/repeated-substring-pattern/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def repeatedSubstringPattern(s: str) -> bool:\n    n = len(s)\n    for i in range(1, n // 2 + 1):\n        if n % i == 0:\n            pattern = s[:i] * (n // i)\n            if s == pattern:\n                return True\n    return False", "asserts": ["assert repeatedSubstringPattern(\"abab\")==True", "assert repeatedSubstringPattern(\"aaaa\") == True", "assert repeatedSubstringPattern(\"abac\") == False", "assert repeatedSubstringPattern(\"ababab\") == True", "assert repeatedSubstringPattern(\"xyzxyzxyz\") == True", "assert repeatedSubstringPattern(\"aaabaaa\") == False", "assert repeatedSubstringPattern(\"abababab\") == True", "assert repeatedSubstringPattern(\"abcabcab\") == False", "assert repeatedSubstringPattern(\"abbaabba\") == True", "assert repeatedSubstringPattern(\"\") == False", "assert repeatedSubstringPattern(\"a\") == False", "assert repeatedSubstringPattern(\"abacababacab\") == True"]}, {"author": "Hafeez", "UUID": "124bfeca-24d0-411d-b4ad-26009b79436b", "question": "Word Pattern II: Given a pattern and a string s, return true if s matches the pattern.\n\nA string s matches a pattern if there is some bijective mapping of single characters to non-empty strings such that if each character in pattern is replaced by the string it maps to, then the resulting string is s. A bijective mapping means that no two characters map to the same string, and no character maps to two different strings.", "examples": "Input: pattern = \"abab\", s = \"redblueredblue\"\nOutput: true\nExplanation: One possible mapping is as follows:\n'a' -> \"red\"\n'b' -> \"blue\"\nInput: pattern = \"aabb\", s = \"xyzabcxzyabc\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern-ii/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def wordPatternMatch(pattern: str, s: str) -> bool:\n    def backtrack(cur: str, pattern: str, mappings: dict):\n        if not pattern:\n            return not cur\n        if pattern[0] in mappings:\n            if cur[:len(mappings[pattern[0]])] != mappings[pattern[0]]:\n                return False\n            return backtrack(cur[len(mappings[pattern[0]]):], pattern[1:], mappings)\n        for i in range(len(cur)):\n            if cur[:i+1] in mappings.values():\n                continue\n            mappings[pattern[0]] = cur[:i+1]\n            if backtrack(cur[i+1:], pattern[1:], mappings):\n                return True\n            del mappings[pattern[0]]\n        return False\n    return backtrack(s, pattern, {})", "asserts": ["assert wordPatternMatch(\"aaaa\", \"asdasdasdasd\")==True", "assert wordPatternMatch(\"abba\", \"dogcatcatdog\") == True", "assert wordPatternMatch(\"ab\", \"aa\") == False # since 'a' and 'b' cannot map to the same string \"a\"", "assert wordPatternMatch(\"xyz\", \"abcdefghi\") == True # 'x' -> \"a\", 'y' -> \"bc\", 'z' -> \"defghi\"", "assert wordPatternMatch(\"aba\", \"eggegg\") == False # 'a' maps to \"egg\", but 'b' cannot be mapped uniquely", "assert wordPatternMatch(\"zzz\", \"aaa\") == True # all 'z' map to \"a\"", "assert wordPatternMatch(\"aba\", \"catdogcat\") == True # 'a' -> \"cat\", 'b' -> \"dog\"", "assert wordPatternMatch(\"abab\", \"xyzxyzabcabc\") == False # cannot match 'a' and 'b' with two different strings each consistent with the pattern", "assert wordPatternMatch(\"abac\", \"xyzxyzxya\") == True # 'a' -> \"xyz\", 'b' -> \"xyz\", 'c' -> \"a\"", "assert wordPatternMatch(\"abcd\", \"xyzy\") == False # pattern too long for the string", "assert wordPatternMatch(\"aaaaa\", \"oneonetwo\") == False # not enough unique strings to map 'a' five times"]}], "category": "Pattern", "prompt_tokens": 1013, "total_tokens": 1339, "completion_tokens": 326, "completion": "Repeat and Missing Number: You are given a list of n-1 integers and these integers are in the range of 1 to n. There are no duplicates in the list. One of the integers is missing and one of the integers is repeated. Find the missing and the repeated number.\n\n###Code: \n\ndef findRepeatAndMissing(nums):\n    n = len(nums)\n    expected_sum = n * (n + 1) // 2\n    actual_sum = sum(nums)\n    expected_square_sum = sum(x ** 2 for x in range(1, n + 1))\n    actual_square_sum = sum(x ** 2 for x in nums)\n    \n    diff = actual_sum - expected_sum\n    diff_square = actual_square_sum - expected_square_sum\n    \n    repeat = (diff + diff_square // diff) // 2\n    missing = (diff_square // diff - diff) // 2\n    \n    return repeat, missing\n\n###Testcases: \n\nassert findRepeatAndMissing([3, 1, 2, 5, 3]) == (3, 4)\nassert findRepeatAndMissing([1, 2, 3, 4, 5, 6, 8, 8]) == (8, 7)\nassert findRepeatAndMissing([1, 2, 2, 4, 5, 6]) == (2, 3)\nassert findRepeatAndMissing([3, 2, 3, 4, 6, 5]) == (3, 1)\n\n[/Example 3]", "temperature": 0.768, "question": "Repeat and Missing Number: You are given a list of n-1 integers and these integers are in the range of 1 to n. There are no duplicates in the list. One of the integers is missing and one of the integers is repeated. Find the missing and the repeated number.", "code": "def findRepeatAndMissing(nums):\n    n = len(nums)\n    expected_sum = n * (n + 1) // 2\n    actual_sum = sum(nums)\n    expected_square_sum = sum(x ** 2 for x in range(1, n + 1))\n    actual_square_sum = sum(x ** 2 for x in nums)\n    \n    diff = actual_sum - expected_sum\n    diff_square = actual_square_sum - expected_square_sum\n    \n    repeat = (diff + diff_square // diff) // 2\n    missing = (diff_square // diff - diff) // 2\n    \n    return repeat, missing", "asserts": ["assert findRepeatAndMissing([3, 1, 2, 5, 3]) == (3, 4)", "assert findRepeatAndMissing([1, 2, 3, 4, 5, 6, 8, 8]) == (8, 7)", "assert findRepeatAndMissing([1, 2, 2, 4, 5, 6]) == (2, 3)", "assert findRepeatAndMissing([3, 2, 3, 4, 6, 5]) == (3, 1)"], "author": "GPT", "UUID": "08707650-6429-40b5-8acb-0be3b3b6dcd7", "tc_status": [["assert findRepeatAndMissing([3, 1, 2, 5, 3]) == (3, 4)", "Passed"], ["assert findRepeatAndMissing([1, 2, 3, 4, 5, 6, 8, 8]) == (8, 7)", "Passed"], ["assert findRepeatAndMissing([1, 2, 2, 4, 5, 6]) == (2, 3)", "Passed"], ["assert findRepeatAndMissing([3, 2, 3, 4, 6, 5]) == (3, 1)", "Passed"]]}, {"few_shots": [{"author": "Hafeez", "UUID": "e811f9cc-fa5e-4ea0-8adb-8cf3ab7c72db", "question": "Detect Pattern of Length M Repeated K or More Times: Given an array of positive integers arr, find a pattern of length m that is repeated k or more times.\n\nA pattern is a subarray (consecutive sub-sequence) that consists of one or more values, repeated multiple times consecutively without overlapping. A pattern is defined by its length and the number of repetitions.\n\nReturn true if there exists a pattern of length m that is repeated k or more times, otherwise return false.", "examples": "Input: arr = [1,2,1,2,1,1,1,3], m = 2, k = 2\nOutput: true\nExplanation: The pattern (1,2) of length 2 is repeated 2 consecutive times. Another valid pattern (2,1) is also repeated 2 times.\nInput: arr = [1,2,1,2,1,3], m = 2, k = 3\nOutput: false\nExplanation: The pattern (1,2) is of length 2 but is repeated only 2 times. There is no pattern of length 2 that is repeated 3 or more times.\n", "link": "https://leetcode.com/problems/detect-pattern-of-length-m-repeated-k-or-more-times/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "from typing import List\ndef containsPattern(arr: List[int], m: int, k: int) -> bool:\n    i = 0\n    while i <= len(arr)-1:\n            p = arr[i:i+m]\n            if p * k == arr[i:i+m*k]:\n                    return True\n            i += 1\n    return False", "asserts": ["assert containsPattern([1,2,4,4,4,4],1,3)==True", "assert containsPattern([1,2,3,1,2,3,1,2,3], 3, 3) == True", "assert containsPattern([1,1,1,2,2,2,3,3], 2, 2) == False", "assert containsPattern([5,5,5,5,5,5,5], 1, 6) == True", "assert containsPattern([1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2], 2, 5) == True", "assert containsPattern([10,100,10,100,10,100,10,10,10,100], 2, 4) == False", "assert containsPattern([3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3], 4, 3) == True"]}, {"author": "Hafeez", "UUID": "effcb732-1f0d-4caa-8d9f-be914708d4ae", "question": "Repeated Substring Pattern: Given a string s, check if it can be constructed by taking a substring of it and appending multiple copies of the substring together.", "examples": "Input: s = \"aba\"\nOutput: false\nExplanation: It is the substring \"ab\" twice.\nInput: s = \"abcabcabcabc\"\nOutput: true\nExplanation: It is the substring \"abc\" four times or the substring \"abcabc\" twice.", "link": "https://leetcode.com/problems/repeated-substring-pattern/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def repeatedSubstringPattern(s: str) -> bool:\n    n = len(s)\n    for i in range(1, n // 2 + 1):\n        if n % i == 0:\n            pattern = s[:i] * (n // i)\n            if s == pattern:\n                return True\n    return False", "asserts": ["assert repeatedSubstringPattern(\"abab\")==True", "assert repeatedSubstringPattern(\"aaaa\") == True", "assert repeatedSubstringPattern(\"abac\") == False", "assert repeatedSubstringPattern(\"ababab\") == True", "assert repeatedSubstringPattern(\"xyzxyzxyz\") == True", "assert repeatedSubstringPattern(\"aaabaaa\") == False", "assert repeatedSubstringPattern(\"abababab\") == True", "assert repeatedSubstringPattern(\"abcabcab\") == False", "assert repeatedSubstringPattern(\"abbaabba\") == True", "assert repeatedSubstringPattern(\"\") == False", "assert repeatedSubstringPattern(\"a\") == False", "assert repeatedSubstringPattern(\"abacababacab\") == True"]}], "category": "Pattern", "prompt_tokens": 855, "total_tokens": 1112, "completion_tokens": 257, "completion": "Detect Capital Use: Given a word, you need to judge whether the usage of capitals in it is right or not.\n\nWe define the usage of capitals in a word to be right when one of the following cases holds:\n- All letters in this word are capitals, like \"USA\".\n- All letters in this word are not capitals, like \"leetcode\".\n- Only the first letter in this word is capital, like \"Google\".\n\nReturn true if the usage of capitals in the word is right, otherwise return false.\n\n###Code: \n\ndef detectCapitalUse(word: str) -> bool:\n    return word.isupper() or word.islower() or word.istitle()\n\n###Testcases: \n\nassert detectCapitalUse(\"USA\")==True\nassert detectCapitalUse(\"leetcode\") == True\nassert detectCapitalUse(\"Google\") == True\nassert detectCapitalUse(\"FlaG\") == False\nassert detectCapitalUse(\"APPLY\") == True\nassert detectCapitalUse(\"apPLY\") == False\nassert detectCapitalUse(\"\") == False\nassert detectCapitalUse(\"a\") == True\nassert detectCapitalUse(\"AB\") == True\nassert detectCapitalUse(\"Ab\") == True\nassert detectCapitalUse(\"aB\") == False\n\n[/Example 3]", "temperature": 0.927, "question": "Detect Capital Use: Given a word, you need to judge whether the usage of capitals in it is right or not.\n\nWe define the usage of capitals in a word to be right when one of the following cases holds:\n- All letters in this word are capitals, like \"USA\".\n- All letters in this word are not capitals, like \"leetcode\".\n- Only the first letter in this word is capital, like \"Google\".\n\nReturn true if the usage of capitals in the word is right, otherwise return false.", "code": "def detectCapitalUse(word: str) -> bool:\n    return word.isupper() or word.islower() or word.istitle()", "asserts": ["assert detectCapitalUse(\"USA\")==True", "assert detectCapitalUse(\"leetcode\") == True", "assert detectCapitalUse(\"Google\") == True", "assert detectCapitalUse(\"FlaG\") == False", "assert detectCapitalUse(\"APPLY\") == True", "assert detectCapitalUse(\"apPLY\") == False", "assert detectCapitalUse(\"\") == False", "assert detectCapitalUse(\"a\") == True", "assert detectCapitalUse(\"AB\") == True", "assert detectCapitalUse(\"Ab\") == True", "assert detectCapitalUse(\"aB\") == False"], "author": "GPT", "UUID": "6322bb18-9eb2-437c-93da-ada6fb2ab93b", "tc_status": [["assert detectCapitalUse(\"USA\")==True", "Passed"], ["assert detectCapitalUse(\"leetcode\") == True", "Passed"], ["assert detectCapitalUse(\"Google\") == True", "Passed"], ["assert detectCapitalUse(\"FlaG\") == False", "Passed"], ["assert detectCapitalUse(\"APPLY\") == True", "Passed"], ["assert detectCapitalUse(\"apPLY\") == False", "Passed"], ["assert detectCapitalUse(\"\") == False", "Passed"], ["assert detectCapitalUse(\"a\") == True", "Passed"], ["assert detectCapitalUse(\"AB\") == True", "Passed"], ["assert detectCapitalUse(\"Ab\") == True", "Passed"], ["assert detectCapitalUse(\"aB\") == False", "Passed"]]}, {"few_shots": [{"author": "Hafeez", "UUID": "e811f9cc-fa5e-4ea0-8adb-8cf3ab7c72db", "question": "Detect Pattern of Length M Repeated K or More Times: Given an array of positive integers arr, find a pattern of length m that is repeated k or more times.\n\nA pattern is a subarray (consecutive sub-sequence) that consists of one or more values, repeated multiple times consecutively without overlapping. A pattern is defined by its length and the number of repetitions.\n\nReturn true if there exists a pattern of length m that is repeated k or more times, otherwise return false.", "examples": "Input: arr = [1,2,1,2,1,1,1,3], m = 2, k = 2\nOutput: true\nExplanation: The pattern (1,2) of length 2 is repeated 2 consecutive times. Another valid pattern (2,1) is also repeated 2 times.\nInput: arr = [1,2,1,2,1,3], m = 2, k = 3\nOutput: false\nExplanation: The pattern (1,2) is of length 2 but is repeated only 2 times. There is no pattern of length 2 that is repeated 3 or more times.\n", "link": "https://leetcode.com/problems/detect-pattern-of-length-m-repeated-k-or-more-times/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "from typing import List\ndef containsPattern(arr: List[int], m: int, k: int) -> bool:\n    i = 0\n    while i <= len(arr)-1:\n            p = arr[i:i+m]\n            if p * k == arr[i:i+m*k]:\n                    return True\n            i += 1\n    return False", "asserts": ["assert containsPattern([1,2,4,4,4,4],1,3)==True", "assert containsPattern([1,2,3,1,2,3,1,2,3], 3, 3) == True", "assert containsPattern([1,1,1,2,2,2,3,3], 2, 2) == False", "assert containsPattern([5,5,5,5,5,5,5], 1, 6) == True", "assert containsPattern([1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2], 2, 5) == True", "assert containsPattern([10,100,10,100,10,100,10,10,10,100], 2, 4) == False", "assert containsPattern([3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3], 4, 3) == True"]}, {"author": "Hafeez", "UUID": "8c9548d2-7b9c-46a4-9b8e-8afd488f7e87", "question": "Find and Replace Pattern: Given a list of strings words and a string pattern, return a list of words[i] that match pattern. You may return the answer in any order.\n\nA word matches the pattern if there exists a permutation of letters p so that after replacing every letter x in the pattern with p(x), we get the desired word.\n\nRecall that a permutation of letters is a bijection from letters to letters: every letter maps to another letter, and no two letters map to the same letter.", "examples": "Input: words = [\"abc\",\"deq\",\"mee\",\"aqq\",\"dkd\",\"ccc\"], pattern = \"abb\"\nOutput: [\"mee\",\"aqq\"]\nExplanation: \"mee\" matches the pattern because there is a permutation {a -> m, b -> e, ...}. \n\"ccc\" does not match the pattern because {a -> c, b -> c, ...} is not a permutation, since a and b map to the same letter.", "link": "https://leetcode.com/problems/find-and-replace-pattern/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def findAndReplacePattern(words: list, pattern: str) -> list:\n        def match(word):\n            m1, m2 = {}, {}\n            for w, p in zip(word, pattern):\n                if w not in m1: m1[w] = p\n                if p not in m2: m2[p] = w\n                if (m1[w], m2[p]) != (p, w):\n                    return False\n            return True\n\n        return list(filter(match, words))\n", "asserts": ["assert findAndReplacePattern([\"a\",\"b\",\"c\"], \"a\")==[\"a\",\"b\",\"c\"]", "assert findAndReplacePattern([\"xx\", \"xy\", \"yy\"], \"xx\") == [\"xx\", \"yy\"]", "assert findAndReplacePattern([\"abc\", \"def\", \"ghi\", \"jkl\"], \"xyz\") == [\"abc\", \"def\", \"ghi\", \"jkl\"]", "assert findAndReplacePattern([\"aaa\", \"bbb\", \"ccc\"], \"xyz\") == []"]}], "category": "Pattern", "prompt_tokens": 923, "total_tokens": 1093, "completion_tokens": 170, "completion": "Identify the Pattern in String: You are given a string s, return the longest prefix which contains only one unique character.\n\n###Code: \n\ndef longestPrefix(s: str) -> str:\n    prefix = \"\"\n    for i in range(len(s)):\n        if s[i] != s[0]:\n            break\n        prefix += s[i]\n    return prefix\n\n###Testcases: \n\nassert longestPrefix(\"aaabbbccc\") == \"aaa\"\nassert longestPrefix(\"abccba\") == \"a\"\nassert longestPrefix(\"abcdefg\") == \"a\"\nassert longestPrefix(\"aaaaaa\") == \"aaaaaa\"\nassert longestPrefix(\"xyyxxyy\") == \"x\"\nassert longestPrefix(\"abababab\") == \"a\"\nassert longestPrefix(\"aaabaaa\") == \"aaa\"\n\n[/Example 3]", "temperature": 0.785, "question": "Identify the Pattern in String: You are given a string s, return the longest prefix which contains only one unique character.", "code": "def longestPrefix(s: str) -> str:\n    prefix = \"\"\n    for i in range(len(s)):\n        if s[i] != s[0]:\n            break\n        prefix += s[i]\n    return prefix", "asserts": ["assert longestPrefix(\"aaabbbccc\") == \"aaa\"", "assert longestPrefix(\"abccba\") == \"a\"", "assert longestPrefix(\"abcdefg\") == \"a\"", "assert longestPrefix(\"aaaaaa\") == \"aaaaaa\"", "assert longestPrefix(\"xyyxxyy\") == \"x\"", "assert longestPrefix(\"abababab\") == \"a\"", "assert longestPrefix(\"aaabaaa\") == \"aaa\""], "author": "GPT", "UUID": "88037387-bcc7-452b-b1ab-02d4ee2af301", "tc_status": [["assert longestPrefix(\"aaabbbccc\") == \"aaa\"", "Passed"], ["assert longestPrefix(\"abccba\") == \"a\"", "Passed"], ["assert longestPrefix(\"abcdefg\") == \"a\"", "Passed"], ["assert longestPrefix(\"aaaaaa\") == \"aaaaaa\"", "Passed"], ["assert longestPrefix(\"xyyxxyy\") == \"x\"", "Passed"], ["assert longestPrefix(\"abababab\") == \"a\"", "Passed"], ["assert longestPrefix(\"aaabaaa\") == \"aaa\"", "Passed"]]}, {"few_shots": [{"author": "Hafeez", "UUID": "e811f9cc-fa5e-4ea0-8adb-8cf3ab7c72db", "question": "Detect Pattern of Length M Repeated K or More Times: Given an array of positive integers arr, find a pattern of length m that is repeated k or more times.\n\nA pattern is a subarray (consecutive sub-sequence) that consists of one or more values, repeated multiple times consecutively without overlapping. A pattern is defined by its length and the number of repetitions.\n\nReturn true if there exists a pattern of length m that is repeated k or more times, otherwise return false.", "examples": "Input: arr = [1,2,1,2,1,1,1,3], m = 2, k = 2\nOutput: true\nExplanation: The pattern (1,2) of length 2 is repeated 2 consecutive times. Another valid pattern (2,1) is also repeated 2 times.\nInput: arr = [1,2,1,2,1,3], m = 2, k = 3\nOutput: false\nExplanation: The pattern (1,2) is of length 2 but is repeated only 2 times. There is no pattern of length 2 that is repeated 3 or more times.\n", "link": "https://leetcode.com/problems/detect-pattern-of-length-m-repeated-k-or-more-times/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "from typing import List\ndef containsPattern(arr: List[int], m: int, k: int) -> bool:\n    i = 0\n    while i <= len(arr)-1:\n            p = arr[i:i+m]\n            if p * k == arr[i:i+m*k]:\n                    return True\n            i += 1\n    return False", "asserts": ["assert containsPattern([1,2,4,4,4,4],1,3)==True", "assert containsPattern([1,2,3,1,2,3,1,2,3], 3, 3) == True", "assert containsPattern([1,1,1,2,2,2,3,3], 2, 2) == False", "assert containsPattern([5,5,5,5,5,5,5], 1, 6) == True", "assert containsPattern([1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2], 2, 5) == True", "assert containsPattern([10,100,10,100,10,100,10,10,10,100], 2, 4) == False", "assert containsPattern([3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3], 4, 3) == True"]}, {"author": "Hafeez", "UUID": "8c9548d2-7b9c-46a4-9b8e-8afd488f7e87", "question": "Find and Replace Pattern: Given a list of strings words and a string pattern, return a list of words[i] that match pattern. You may return the answer in any order.\n\nA word matches the pattern if there exists a permutation of letters p so that after replacing every letter x in the pattern with p(x), we get the desired word.\n\nRecall that a permutation of letters is a bijection from letters to letters: every letter maps to another letter, and no two letters map to the same letter.", "examples": "Input: words = [\"abc\",\"deq\",\"mee\",\"aqq\",\"dkd\",\"ccc\"], pattern = \"abb\"\nOutput: [\"mee\",\"aqq\"]\nExplanation: \"mee\" matches the pattern because there is a permutation {a -> m, b -> e, ...}. \n\"ccc\" does not match the pattern because {a -> c, b -> c, ...} is not a permutation, since a and b map to the same letter.", "link": "https://leetcode.com/problems/find-and-replace-pattern/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def findAndReplacePattern(words: list, pattern: str) -> list:\n        def match(word):\n            m1, m2 = {}, {}\n            for w, p in zip(word, pattern):\n                if w not in m1: m1[w] = p\n                if p not in m2: m2[p] = w\n                if (m1[w], m2[p]) != (p, w):\n                    return False\n            return True\n\n        return list(filter(match, words))\n", "asserts": ["assert findAndReplacePattern([\"a\",\"b\",\"c\"], \"a\")==[\"a\",\"b\",\"c\"]", "assert findAndReplacePattern([\"xx\", \"xy\", \"yy\"], \"xx\") == [\"xx\", \"yy\"]", "assert findAndReplacePattern([\"abc\", \"def\", \"ghi\", \"jkl\"], \"xyz\") == [\"abc\", \"def\", \"ghi\", \"jkl\"]", "assert findAndReplacePattern([\"aaa\", \"bbb\", \"ccc\"], \"xyz\") == []"]}], "category": "Pattern", "prompt_tokens": 923, "total_tokens": 1101, "completion_tokens": 178, "completion": "Generate Parentheses: Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.\n\n###Code: \n\ndef generateParenthesis(n: int) -> List[str]:\n    def backtrack(s='', left=0, right=0):\n        if len(s) == 2 * n:\n            res.append(s)\n            return\n        if left < n:\n            backtrack(s + '(', left + 1, right)\n        if right < left:\n            backtrack(s + ')', left, right + 1)\n\n    res = []\n    backtrack()\n    return res\n\n###Testcases: \n\nassert generateParenthesis(3)==[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]\nassert generateParenthesis(1)==[\"()\"]\nassert generateParenthesis(2)==[\"(())\",\"()()\"]\n\n[/Example 3]", "temperature": 0.904, "question": "Generate Parentheses: Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.", "code": "def generateParenthesis(n: int) -> List[str]:\n    def backtrack(s='', left=0, right=0):\n        if len(s) == 2 * n:\n            res.append(s)\n            return\n        if left < n:\n            backtrack(s + '(', left + 1, right)\n        if right < left:\n            backtrack(s + ')', left, right + 1)\n\n    res = []\n    backtrack()\n    return res", "asserts": ["assert generateParenthesis(3)==[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]", "assert generateParenthesis(1)==[\"()\"]", "assert generateParenthesis(2)==[\"(())\",\"()()\"]"], "author": "GPT", "UUID": "301c1380-d92d-4045-9efa-b91f72f9fc38", "tc_status": [["assert generateParenthesis(3)==[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]", "Passed"], ["assert generateParenthesis(1)==[\"()\"]", "Passed"], ["assert generateParenthesis(2)==[\"(())\",\"()()\"]", "Passed"]]}, {"few_shots": [{"author": "Hafeez", "UUID": "df98fd29-db88-4de7-a00a-0a3bd5ba1539", "question": "Word Pattern: Given a pattern and a string s, find if s follows the same pattern.\n\nHere follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in s.", "examples": "Input: pattern = \"abba\", s = \"dog cat cat fish\"\nOutput: false\nInput: pattern = \"aaaa\", s = \"dog cat cat dog\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def wordPattern(pattern: str, s: str) -> bool:\n    map_char = {}\n    map_word = {}\n    \n    words = s.split(' ')\n    if len(words) != len(pattern):\n        return False\n    \n    for c, w in zip(pattern, words):\n        if c not in map_char:\n            if w in map_word:\n                return False\n            else:\n                map_char[c] = w\n                map_word[w] = c\n        else:\n            if map_char[c] != w:\n                return False\n    return True", "asserts": ["assert wordPattern(\"abba\", \"dog cat cat dog\")==True", "assert wordPattern(\"aaaa\", \"dog dog dog dog\") == True", "assert wordPattern(\"xyz\", \"apple banana apple\") == False", "assert wordPattern(\"xyx\", \"apple banana apple\") == True", "assert wordPattern(\"abab\", \"dog cat dog cat\") == True", "assert wordPattern(\"aaaa\", \"dog dog dog cat\") == False", "assert wordPattern(\"aabb\", \"dog dog cat cat\") == True", "assert wordPattern(\"abc\", \"dog\") == False  # Not enough words", "assert wordPattern(\"\", \"dog cat\") == False  # Empty pattern", "assert wordPattern(\"a\", \"dog cat dog cat\") == False  # Not enough pattern characters", "assert wordPattern(\"ab\", \"\") == False  # Empty string", "assert wordPattern(\"abb\", \"dog dog dog\") == False  # Same word for different pattern characters", "assert wordPattern(\"abba\", \"dog cat cat\") == False  # Not enough words for the pattern", "assert wordPattern(\"abba\", \"dog cat cat dog fish\") == False  # Extra words beyond the pattern length"]}, {"author": "Hafeez", "UUID": "effcb732-1f0d-4caa-8d9f-be914708d4ae", "question": "Repeated Substring Pattern: Given a string s, check if it can be constructed by taking a substring of it and appending multiple copies of the substring together.", "examples": "Input: s = \"aba\"\nOutput: false\nExplanation: It is the substring \"ab\" twice.\nInput: s = \"abcabcabcabc\"\nOutput: true\nExplanation: It is the substring \"abc\" four times or the substring \"abcabc\" twice.", "link": "https://leetcode.com/problems/repeated-substring-pattern/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def repeatedSubstringPattern(s: str) -> bool:\n    n = len(s)\n    for i in range(1, n // 2 + 1):\n        if n % i == 0:\n            pattern = s[:i] * (n // i)\n            if s == pattern:\n                return True\n    return False", "asserts": ["assert repeatedSubstringPattern(\"abab\")==True", "assert repeatedSubstringPattern(\"aaaa\") == True", "assert repeatedSubstringPattern(\"abac\") == False", "assert repeatedSubstringPattern(\"ababab\") == True", "assert repeatedSubstringPattern(\"xyzxyzxyz\") == True", "assert repeatedSubstringPattern(\"aaabaaa\") == False", "assert repeatedSubstringPattern(\"abababab\") == True", "assert repeatedSubstringPattern(\"abcabcab\") == False", "assert repeatedSubstringPattern(\"abbaabba\") == True", "assert repeatedSubstringPattern(\"\") == False", "assert repeatedSubstringPattern(\"a\") == False", "assert repeatedSubstringPattern(\"abacababacab\") == True"]}], "category": "Pattern", "prompt_tokens": 854, "total_tokens": 1149, "completion_tokens": 295, "completion": "Anagram Pattern: Given two strings s and t, determine if they are anagrams of each other.\n\n###Code: \n\ndef isAnagram(s: str, t: str) -> bool:\n    if len(s) != len(t):\n        return False\n    char_count = {}\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    for char in t:\n        if char in char_count:\n            char_count[char] -= 1\n            if char_count[char] < 0:\n                return False\n        else:\n            return False\n    return all(count == 0 for count in char_count.values())\n\n###Testcases: \n\nassert isAnagram(\"anagram\", \"nagaram\")==True\nassert isAnagram(\"rat\", \"car\")==False\nassert isAnagram(\"listen\", \"silent\")==True\nassert isAnagram(\"hello\", \"world\")==False\nassert isAnagram(\"abc\", \"abcd\")==False\nassert isAnagram(\"\", \"\")==True\nassert isAnagram(\"a\", \"a\")==True\nassert isAnagram(\"123\", \"321\")==True\nassert isAnagram(\"apple\", \"papel\")==True\nassert isAnagram(\"testing\", \"testing\")==True\nassert isAnagram(\"abcdefg\", \"gfedcba\")==True\n\n[/Example 3]", "temperature": 0.641, "question": "Anagram Pattern: Given two strings s and t, determine if they are anagrams of each other.", "code": "def isAnagram(s: str, t: str) -> bool:\n    if len(s) != len(t):\n        return False\n    char_count = {}\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    for char in t:\n        if char in char_count:\n            char_count[char] -= 1\n            if char_count[char] < 0:\n                return False\n        else:\n            return False\n    return all(count == 0 for count in char_count.values())", "asserts": ["assert isAnagram(\"anagram\", \"nagaram\")==True", "assert isAnagram(\"rat\", \"car\")==False", "assert isAnagram(\"listen\", \"silent\")==True", "assert isAnagram(\"hello\", \"world\")==False", "assert isAnagram(\"abc\", \"abcd\")==False", "assert isAnagram(\"\", \"\")==True", "assert isAnagram(\"a\", \"a\")==True", "assert isAnagram(\"123\", \"321\")==True", "assert isAnagram(\"apple\", \"papel\")==True", "assert isAnagram(\"testing\", \"testing\")==True", "assert isAnagram(\"abcdefg\", \"gfedcba\")==True"], "author": "GPT", "UUID": "6bffebb6-f6b5-4fd9-a088-06fa2bd5bc9f", "tc_status": [["assert isAnagram(\"anagram\", \"nagaram\")==True", "Passed"], ["assert isAnagram(\"rat\", \"car\")==False", "Passed"], ["assert isAnagram(\"listen\", \"silent\")==True", "Passed"], ["assert isAnagram(\"hello\", \"world\")==False", "Passed"], ["assert isAnagram(\"abc\", \"abcd\")==False", "Passed"], ["assert isAnagram(\"\", \"\")==True", "Passed"], ["assert isAnagram(\"a\", \"a\")==True", "Passed"], ["assert isAnagram(\"123\", \"321\")==True", "Passed"], ["assert isAnagram(\"apple\", \"papel\")==True", "Passed"], ["assert isAnagram(\"testing\", \"testing\")==True", "Passed"], ["assert isAnagram(\"abcdefg\", \"gfedcba\")==True", "Passed"]]}, {"few_shots": [{"author": "Hafeez", "UUID": "df98fd29-db88-4de7-a00a-0a3bd5ba1539", "question": "Word Pattern: Given a pattern and a string s, find if s follows the same pattern.\n\nHere follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in s.", "examples": "Input: pattern = \"abba\", s = \"dog cat cat fish\"\nOutput: false\nInput: pattern = \"aaaa\", s = \"dog cat cat dog\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def wordPattern(pattern: str, s: str) -> bool:\n    map_char = {}\n    map_word = {}\n    \n    words = s.split(' ')\n    if len(words) != len(pattern):\n        return False\n    \n    for c, w in zip(pattern, words):\n        if c not in map_char:\n            if w in map_word:\n                return False\n            else:\n                map_char[c] = w\n                map_word[w] = c\n        else:\n            if map_char[c] != w:\n                return False\n    return True", "asserts": ["assert wordPattern(\"abba\", \"dog cat cat dog\")==True", "assert wordPattern(\"aaaa\", \"dog dog dog dog\") == True", "assert wordPattern(\"xyz\", \"apple banana apple\") == False", "assert wordPattern(\"xyx\", \"apple banana apple\") == True", "assert wordPattern(\"abab\", \"dog cat dog cat\") == True", "assert wordPattern(\"aaaa\", \"dog dog dog cat\") == False", "assert wordPattern(\"aabb\", \"dog dog cat cat\") == True", "assert wordPattern(\"abc\", \"dog\") == False  # Not enough words", "assert wordPattern(\"\", \"dog cat\") == False  # Empty pattern", "assert wordPattern(\"a\", \"dog cat dog cat\") == False  # Not enough pattern characters", "assert wordPattern(\"ab\", \"\") == False  # Empty string", "assert wordPattern(\"abb\", \"dog dog dog\") == False  # Same word for different pattern characters", "assert wordPattern(\"abba\", \"dog cat cat\") == False  # Not enough words for the pattern", "assert wordPattern(\"abba\", \"dog cat cat dog fish\") == False  # Extra words beyond the pattern length"]}, {"author": "Hafeez", "UUID": "124bfeca-24d0-411d-b4ad-26009b79436b", "question": "Word Pattern II: Given a pattern and a string s, return true if s matches the pattern.\n\nA string s matches a pattern if there is some bijective mapping of single characters to non-empty strings such that if each character in pattern is replaced by the string it maps to, then the resulting string is s. A bijective mapping means that no two characters map to the same string, and no character maps to two different strings.", "examples": "Input: pattern = \"abab\", s = \"redblueredblue\"\nOutput: true\nExplanation: One possible mapping is as follows:\n'a' -> \"red\"\n'b' -> \"blue\"\nInput: pattern = \"aabb\", s = \"xyzabcxzyabc\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern-ii/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def wordPatternMatch(pattern: str, s: str) -> bool:\n    def backtrack(cur: str, pattern: str, mappings: dict):\n        if not pattern:\n            return not cur\n        if pattern[0] in mappings:\n            if cur[:len(mappings[pattern[0]])] != mappings[pattern[0]]:\n                return False\n            return backtrack(cur[len(mappings[pattern[0]]):], pattern[1:], mappings)\n        for i in range(len(cur)):\n            if cur[:i+1] in mappings.values():\n                continue\n            mappings[pattern[0]] = cur[:i+1]\n            if backtrack(cur[i+1:], pattern[1:], mappings):\n                return True\n            del mappings[pattern[0]]\n        return False\n    return backtrack(s, pattern, {})", "asserts": ["assert wordPatternMatch(\"aaaa\", \"asdasdasdasd\")==True", "assert wordPatternMatch(\"abba\", \"dogcatcatdog\") == True", "assert wordPatternMatch(\"ab\", \"aa\") == False # since 'a' and 'b' cannot map to the same string \"a\"", "assert wordPatternMatch(\"xyz\", \"abcdefghi\") == True # 'x' -> \"a\", 'y' -> \"bc\", 'z' -> \"defghi\"", "assert wordPatternMatch(\"aba\", \"eggegg\") == False # 'a' maps to \"egg\", but 'b' cannot be mapped uniquely", "assert wordPatternMatch(\"zzz\", \"aaa\") == True # all 'z' map to \"a\"", "assert wordPatternMatch(\"aba\", \"catdogcat\") == True # 'a' -> \"cat\", 'b' -> \"dog\"", "assert wordPatternMatch(\"abab\", \"xyzxyzabcabc\") == False # cannot match 'a' and 'b' with two different strings each consistent with the pattern", "assert wordPatternMatch(\"abac\", \"xyzxyzxya\") == True # 'a' -> \"xyz\", 'b' -> \"xyz\", 'c' -> \"a\"", "assert wordPatternMatch(\"abcd\", \"xyzy\") == False # pattern too long for the string", "assert wordPatternMatch(\"aaaaa\", \"oneonetwo\") == False # not enough unique strings to map 'a' five times"]}], "category": "Pattern", "prompt_tokens": 1178, "total_tokens": 1400, "completion_tokens": 222, "completion": "Number Pattern: Given an integer n, write a program to generate a number pattern as shown below. \n\n###Code: \n\ndef generateNumberPattern(n: int) -> None:\n    for i in range(1, n + 1):\n        for j in range(1, i + 1):\n            print(j, end=\" \")\n        print()\n\n###Testcases: \n\ngenerateNumberPattern(5)\n# Output\n# 1 \n# 1 2 \n# 1 2 3 \n# 1 2 3 4 \n# 1 2 3 4 5 \n\ngenerateNumberPattern(3)\n# Output\n# 1 \n# 1 2 \n# 1 2 3 \n\ngenerateNumberPattern(1)\n# Output\n# 1 \n\ngenerateNumberPattern(0)\n# No output as there are no rows to print\n\n###Explanation:\nThe function generates a number pattern where each row contains numbers from 1 to the row number. The number of rows is determined by the input 'n'.\n\n[/Example 3]", "temperature": 0.748, "question": "Number Pattern: Given an integer n, write a program to generate a number pattern as shown below.", "code": "def generateNumberPattern(n: int) -> None:\n    for i in range(1, n + 1):\n        for j in range(1, i + 1):\n            print(j, end=\" \")\n        print()", "asserts": [], "author": "GPT", "UUID": "b34b0ed9-21d8-4be0-9e65-3e3e524f35a4", "tc_status": []}, {"few_shots": [{"author": "Hafeez", "UUID": "df98fd29-db88-4de7-a00a-0a3bd5ba1539", "question": "Word Pattern: Given a pattern and a string s, find if s follows the same pattern.\n\nHere follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in s.", "examples": "Input: pattern = \"abba\", s = \"dog cat cat fish\"\nOutput: false\nInput: pattern = \"aaaa\", s = \"dog cat cat dog\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def wordPattern(pattern: str, s: str) -> bool:\n    map_char = {}\n    map_word = {}\n    \n    words = s.split(' ')\n    if len(words) != len(pattern):\n        return False\n    \n    for c, w in zip(pattern, words):\n        if c not in map_char:\n            if w in map_word:\n                return False\n            else:\n                map_char[c] = w\n                map_word[w] = c\n        else:\n            if map_char[c] != w:\n                return False\n    return True", "asserts": ["assert wordPattern(\"abba\", \"dog cat cat dog\")==True", "assert wordPattern(\"aaaa\", \"dog dog dog dog\") == True", "assert wordPattern(\"xyz\", \"apple banana apple\") == False", "assert wordPattern(\"xyx\", \"apple banana apple\") == True", "assert wordPattern(\"abab\", \"dog cat dog cat\") == True", "assert wordPattern(\"aaaa\", \"dog dog dog cat\") == False", "assert wordPattern(\"aabb\", \"dog dog cat cat\") == True", "assert wordPattern(\"abc\", \"dog\") == False  # Not enough words", "assert wordPattern(\"\", \"dog cat\") == False  # Empty pattern", "assert wordPattern(\"a\", \"dog cat dog cat\") == False  # Not enough pattern characters", "assert wordPattern(\"ab\", \"\") == False  # Empty string", "assert wordPattern(\"abb\", \"dog dog dog\") == False  # Same word for different pattern characters", "assert wordPattern(\"abba\", \"dog cat cat\") == False  # Not enough words for the pattern", "assert wordPattern(\"abba\", \"dog cat cat dog fish\") == False  # Extra words beyond the pattern length"]}, {"author": "Hafeez", "UUID": "124bfeca-24d0-411d-b4ad-26009b79436b", "question": "Word Pattern II: Given a pattern and a string s, return true if s matches the pattern.\n\nA string s matches a pattern if there is some bijective mapping of single characters to non-empty strings such that if each character in pattern is replaced by the string it maps to, then the resulting string is s. A bijective mapping means that no two characters map to the same string, and no character maps to two different strings.", "examples": "Input: pattern = \"abab\", s = \"redblueredblue\"\nOutput: true\nExplanation: One possible mapping is as follows:\n'a' -> \"red\"\n'b' -> \"blue\"\nInput: pattern = \"aabb\", s = \"xyzabcxzyabc\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern-ii/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def wordPatternMatch(pattern: str, s: str) -> bool:\n    def backtrack(cur: str, pattern: str, mappings: dict):\n        if not pattern:\n            return not cur\n        if pattern[0] in mappings:\n            if cur[:len(mappings[pattern[0]])] != mappings[pattern[0]]:\n                return False\n            return backtrack(cur[len(mappings[pattern[0]]):], pattern[1:], mappings)\n        for i in range(len(cur)):\n            if cur[:i+1] in mappings.values():\n                continue\n            mappings[pattern[0]] = cur[:i+1]\n            if backtrack(cur[i+1:], pattern[1:], mappings):\n                return True\n            del mappings[pattern[0]]\n        return False\n    return backtrack(s, pattern, {})", "asserts": ["assert wordPatternMatch(\"aaaa\", \"asdasdasdasd\")==True", "assert wordPatternMatch(\"abba\", \"dogcatcatdog\") == True", "assert wordPatternMatch(\"ab\", \"aa\") == False # since 'a' and 'b' cannot map to the same string \"a\"", "assert wordPatternMatch(\"xyz\", \"abcdefghi\") == True # 'x' -> \"a\", 'y' -> \"bc\", 'z' -> \"defghi\"", "assert wordPatternMatch(\"aba\", \"eggegg\") == False # 'a' maps to \"egg\", but 'b' cannot be mapped uniquely", "assert wordPatternMatch(\"zzz\", \"aaa\") == True # all 'z' map to \"a\"", "assert wordPatternMatch(\"aba\", \"catdogcat\") == True # 'a' -> \"cat\", 'b' -> \"dog\"", "assert wordPatternMatch(\"abab\", \"xyzxyzabcabc\") == False # cannot match 'a' and 'b' with two different strings each consistent with the pattern", "assert wordPatternMatch(\"abac\", \"xyzxyzxya\") == True # 'a' -> \"xyz\", 'b' -> \"xyz\", 'c' -> \"a\"", "assert wordPatternMatch(\"abcd\", \"xyzy\") == False # pattern too long for the string", "assert wordPatternMatch(\"aaaaa\", \"oneonetwo\") == False # not enough unique strings to map 'a' five times"]}], "category": "Pattern", "prompt_tokens": 1178, "total_tokens": 1716, "completion_tokens": 538, "completion": "Number Pattern: Given an integer n, generate the first n elements of the following pattern: 1, 11, 21, 1211, 111221, ...\n\nEach subsequent element describes the previous element. Starting with \"1\", the pattern describes the previous element as \"one 1\", i.e. 11. Then, the next element describes 11 as \"two 1s\", i.e. 21. Then 21 is described as \"one 2, then one 1\", i.e. 1211, and so on.\n\nWrite a function to generate the first n elements of this pattern.\n\n###Code: \n\ndef generatePattern(n: int) -> List[str]:\n    if n == 1:\n        return ['1']\n    result = ['1']\n    for _ in range(n-1):\n        current = result[-1]\n        count = 1\n        new_str = \"\"\n        for i in range(1, len(current)):\n            if current[i] == current[i-1]:\n                count += 1\n            else:\n                new_str += str(count) + current[i-1]\n                count = 1\n        new_str += str(count) + current[-1]\n        result.append(new_str)\n    return result\n\n###Testcases: \n\nassert generatePattern(1) == ['1']\nassert generatePattern(5) == ['1', '11', '21', '1211', '111221']\nassert generatePattern(8) == ['1', '11', '21', '1211', '111221', '312211', '13112221', '1113213211']\nassert generatePattern(10) == ['1', '11', '21', '1211', '111221', '312211', '13112221', '1113213211', '31131211131221', '13211311123113112211']\nassert generatePattern(15) == ['1', '11', '21', '1211', '111221', '312211', '13112221', '1113213211', '31131211131221', '13211311123113112211', '11131221133112132113212221', '3113112221232112111312211312113211', '132113213221133112132113311211131221', '11131221131211131231121113112221121321132132211331222113112211', '311311222113111231131112132112311321322112111312211312111322212311322113212221']\n", "temperature": 0.856, "question": "Number Pattern: Given an integer n, generate the first n elements of the following pattern: 1, 11, 21, 1211, 111221, ...\n\nEach subsequent element describes the previous element. Starting with \"1\", the pattern describes the previous element as \"one 1\", i.e. 11. Then, the next element describes 11 as \"two 1s\", i.e. 21. Then 21 is described as \"one 2, then one 1\", i.e. 1211, and so on.\n\nWrite a function to generate the first n elements of this pattern.", "code": "def generatePattern(n: int) -> List[str]:\n    if n == 1:\n        return ['1']\n    result = ['1']\n    for _ in range(n-1):\n        current = result[-1]\n        count = 1\n        new_str = \"\"\n        for i in range(1, len(current)):\n            if current[i] == current[i-1]:\n                count += 1\n            else:\n                new_str += str(count) + current[i-1]\n                count = 1\n        new_str += str(count) + current[-1]\n        result.append(new_str)\n    return result", "asserts": ["assert generatePattern(1) == ['1']", "assert generatePattern(5) == ['1', '11', '21', '1211', '111221']", "assert generatePattern(8) == ['1', '11', '21', '1211', '111221', '312211', '13112221', '1113213211']", "assert generatePattern(10) == ['1', '11', '21', '1211', '111221', '312211', '13112221', '1113213211', '31131211131221', '13211311123113112211']"], "author": "GPT", "UUID": "8570d8b5-3f01-4321-9de6-f2a1293e49e9", "tc_status": [["assert generatePattern(1) == ['1']", "Passed"], ["assert generatePattern(5) == ['1', '11', '21', '1211', '111221']", "Passed"], ["assert generatePattern(8) == ['1', '11', '21', '1211', '111221', '312211', '13112221', '1113213211']", "Passed"], ["assert generatePattern(10) == ['1', '11', '21', '1211', '111221', '312211', '13112221', '1113213211', '31131211131221', '13211311123113112211']", "Passed"]]}, {"few_shots": [{"author": "Hafeez", "UUID": "8c9548d2-7b9c-46a4-9b8e-8afd488f7e87", "question": "Find and Replace Pattern: Given a list of strings words and a string pattern, return a list of words[i] that match pattern. You may return the answer in any order.\n\nA word matches the pattern if there exists a permutation of letters p so that after replacing every letter x in the pattern with p(x), we get the desired word.\n\nRecall that a permutation of letters is a bijection from letters to letters: every letter maps to another letter, and no two letters map to the same letter.", "examples": "Input: words = [\"abc\",\"deq\",\"mee\",\"aqq\",\"dkd\",\"ccc\"], pattern = \"abb\"\nOutput: [\"mee\",\"aqq\"]\nExplanation: \"mee\" matches the pattern because there is a permutation {a -> m, b -> e, ...}. \n\"ccc\" does not match the pattern because {a -> c, b -> c, ...} is not a permutation, since a and b map to the same letter.", "link": "https://leetcode.com/problems/find-and-replace-pattern/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def findAndReplacePattern(words: list, pattern: str) -> list:\n        def match(word):\n            m1, m2 = {}, {}\n            for w, p in zip(word, pattern):\n                if w not in m1: m1[w] = p\n                if p not in m2: m2[p] = w\n                if (m1[w], m2[p]) != (p, w):\n                    return False\n            return True\n\n        return list(filter(match, words))\n", "asserts": ["assert findAndReplacePattern([\"a\",\"b\",\"c\"], \"a\")==[\"a\",\"b\",\"c\"]", "assert findAndReplacePattern([\"xx\", \"xy\", \"yy\"], \"xx\") == [\"xx\", \"yy\"]", "assert findAndReplacePattern([\"abc\", \"def\", \"ghi\", \"jkl\"], \"xyz\") == [\"abc\", \"def\", \"ghi\", \"jkl\"]", "assert findAndReplacePattern([\"aaa\", \"bbb\", \"ccc\"], \"xyz\") == []"]}, {"author": "Hafeez", "UUID": "effcb732-1f0d-4caa-8d9f-be914708d4ae", "question": "Repeated Substring Pattern: Given a string s, check if it can be constructed by taking a substring of it and appending multiple copies of the substring together.", "examples": "Input: s = \"aba\"\nOutput: false\nExplanation: It is the substring \"ab\" twice.\nInput: s = \"abcabcabcabc\"\nOutput: true\nExplanation: It is the substring \"abc\" four times or the substring \"abcabc\" twice.", "link": "https://leetcode.com/problems/repeated-substring-pattern/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def repeatedSubstringPattern(s: str) -> bool:\n    n = len(s)\n    for i in range(1, n // 2 + 1):\n        if n % i == 0:\n            pattern = s[:i] * (n // i)\n            if s == pattern:\n                return True\n    return False", "asserts": ["assert repeatedSubstringPattern(\"abab\")==True", "assert repeatedSubstringPattern(\"aaaa\") == True", "assert repeatedSubstringPattern(\"abac\") == False", "assert repeatedSubstringPattern(\"ababab\") == True", "assert repeatedSubstringPattern(\"xyzxyzxyz\") == True", "assert repeatedSubstringPattern(\"aaabaaa\") == False", "assert repeatedSubstringPattern(\"abababab\") == True", "assert repeatedSubstringPattern(\"abcabcab\") == False", "assert repeatedSubstringPattern(\"abbaabba\") == True", "assert repeatedSubstringPattern(\"\") == False", "assert repeatedSubstringPattern(\"a\") == False", "assert repeatedSubstringPattern(\"abacababacab\") == True"]}], "category": "Pattern", "prompt_tokens": 757, "total_tokens": 1032, "completion_tokens": 275, "completion": "Matchstick Equations: Given an equation, represented as a string, you need to replace all the matches ('=') with correct number to make the equation true.\n\n###Code: \n\ndef solveEquation(equation: str) -> str:\n    left, right = equation.split('=')\n    left_count = left.count('|')\n    right_count = right.count('|')\n    if left_count == right_count:\n        return \"Balanced equation\"\n    elif left_count > right_count:\n        diff = left_count - right_count\n        return f\"Add {diff} matchstick(s) to the right side\"\n    else:\n        diff = right_count - left_count\n        return f\"Add {diff} matchstick(s) to the left side\"\n\n###Testcases: \n\nassert solveEquation(\"||+||=||||\")== \"Balanced equation\"\nassert solveEquation(\"|+||=||||\")== \"Add 1 matchstick(s) to the left side\"\nassert solveEquation(\"||+||=|||||\")== \"Add 1 matchstick(s) to the right side\"\nassert solveEquation(\"||=||\")== \"Balanced equation\"\nassert solveEquation(\"||+||=||\")== \"Balanced equation\"\nassert solveEquation(\"||=|||\")== \"Add 1 matchstick(s) to the left side\"", "temperature": 0.988, "question": "Matchstick Equations: Given an equation, represented as a string, you need to replace all the matches ('=') with correct number to make the equation true.", "code": "def solveEquation(equation: str) -> str:\n    left, right = equation.split('=')\n    left_count = left.count('|')\n    right_count = right.count('|')\n    if left_count == right_count:\n        return \"Balanced equation\"\n    elif left_count > right_count:\n        diff = left_count - right_count\n        return f\"Add {diff} matchstick(s) to the right side\"\n    else:\n        diff = right_count - left_count\n        return f\"Add {diff} matchstick(s) to the left side\"", "asserts": ["assert solveEquation(\"||+||=||||\")== \"Balanced equation\"", "assert solveEquation(\"|+||=||||\")== \"Add 1 matchstick(s) to the left side\"", "assert solveEquation(\"||=||\")== \"Balanced equation\"", "assert solveEquation(\"||=|||\")== \"Add 1 matchstick(s) to the left side\""], "author": "GPT", "UUID": "21d39b24-4967-4378-874d-385e90246f05", "tc_status": [["assert solveEquation(\"||+||=||||\")== \"Balanced equation\"", "Passed"], ["assert solveEquation(\"|+||=||||\")== \"Add 1 matchstick(s) to the left side\"", "Passed"], ["assert solveEquation(\"||=||\")== \"Balanced equation\"", "Passed"], ["assert solveEquation(\"||=|||\")== \"Add 1 matchstick(s) to the left side\"", "Passed"]]}, {"few_shots": [{"author": "Hafeez", "UUID": "8c9548d2-7b9c-46a4-9b8e-8afd488f7e87", "question": "Find and Replace Pattern: Given a list of strings words and a string pattern, return a list of words[i] that match pattern. You may return the answer in any order.\n\nA word matches the pattern if there exists a permutation of letters p so that after replacing every letter x in the pattern with p(x), we get the desired word.\n\nRecall that a permutation of letters is a bijection from letters to letters: every letter maps to another letter, and no two letters map to the same letter.", "examples": "Input: words = [\"abc\",\"deq\",\"mee\",\"aqq\",\"dkd\",\"ccc\"], pattern = \"abb\"\nOutput: [\"mee\",\"aqq\"]\nExplanation: \"mee\" matches the pattern because there is a permutation {a -> m, b -> e, ...}. \n\"ccc\" does not match the pattern because {a -> c, b -> c, ...} is not a permutation, since a and b map to the same letter.", "link": "https://leetcode.com/problems/find-and-replace-pattern/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def findAndReplacePattern(words: list, pattern: str) -> list:\n        def match(word):\n            m1, m2 = {}, {}\n            for w, p in zip(word, pattern):\n                if w not in m1: m1[w] = p\n                if p not in m2: m2[p] = w\n                if (m1[w], m2[p]) != (p, w):\n                    return False\n            return True\n\n        return list(filter(match, words))\n", "asserts": ["assert findAndReplacePattern([\"a\",\"b\",\"c\"], \"a\")==[\"a\",\"b\",\"c\"]", "assert findAndReplacePattern([\"xx\", \"xy\", \"yy\"], \"xx\") == [\"xx\", \"yy\"]", "assert findAndReplacePattern([\"abc\", \"def\", \"ghi\", \"jkl\"], \"xyz\") == [\"abc\", \"def\", \"ghi\", \"jkl\"]", "assert findAndReplacePattern([\"aaa\", \"bbb\", \"ccc\"], \"xyz\") == []"]}, {"author": "Hafeez", "UUID": "e811f9cc-fa5e-4ea0-8adb-8cf3ab7c72db", "question": "Detect Pattern of Length M Repeated K or More Times: Given an array of positive integers arr, find a pattern of length m that is repeated k or more times.\n\nA pattern is a subarray (consecutive sub-sequence) that consists of one or more values, repeated multiple times consecutively without overlapping. A pattern is defined by its length and the number of repetitions.\n\nReturn true if there exists a pattern of length m that is repeated k or more times, otherwise return false.", "examples": "Input: arr = [1,2,1,2,1,1,1,3], m = 2, k = 2\nOutput: true\nExplanation: The pattern (1,2) of length 2 is repeated 2 consecutive times. Another valid pattern (2,1) is also repeated 2 times.\nInput: arr = [1,2,1,2,1,3], m = 2, k = 3\nOutput: false\nExplanation: The pattern (1,2) is of length 2 but is repeated only 2 times. There is no pattern of length 2 that is repeated 3 or more times.\n", "link": "https://leetcode.com/problems/detect-pattern-of-length-m-repeated-k-or-more-times/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "from typing import List\ndef containsPattern(arr: List[int], m: int, k: int) -> bool:\n    i = 0\n    while i <= len(arr)-1:\n            p = arr[i:i+m]\n            if p * k == arr[i:i+m*k]:\n                    return True\n            i += 1\n    return False", "asserts": ["assert containsPattern([1,2,4,4,4,4],1,3)==True", "assert containsPattern([1,2,3,1,2,3,1,2,3], 3, 3) == True", "assert containsPattern([1,1,1,2,2,2,3,3], 2, 2) == False", "assert containsPattern([5,5,5,5,5,5,5], 1, 6) == True", "assert containsPattern([1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2], 2, 5) == True", "assert containsPattern([10,100,10,100,10,100,10,10,10,100], 2, 4) == False", "assert containsPattern([3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3], 4, 3) == True"]}], "category": "Pattern", "prompt_tokens": 923, "total_tokens": 1184, "completion_tokens": 261, "completion": "Generate All Patterns of Length N: Given an integer n, generate all possible patterns of length n. The pattern should consist of only 0s and 1s.\n\n###Code: \n\nfrom typing import List\ndef generatePatterns(n: int) -> List[str]:\n    if n == 1:\n        return [\"0\", \"1\"]\n    else:\n        prev_patterns = generatePatterns(n-1)\n        new_patterns = []\n        for pattern in prev_patterns:\n            new_patterns.append(pattern + \"0\")\n            new_patterns.append(pattern + \"1\")\n        return new_patterns\n\n###Testcases: \n\nassert generatePatterns(1) == ['0', '1']\nassert generatePatterns(2) == ['00', '01', '10', '11']\nassert generatePatterns(3) == ['000', '001', '010', '011', '100', '101', '110', '111']\nassert generatePatterns(4) == ['0000', '0001', '0010', '0011', '0100', '0101', '0110', '0111', '1000', '1001', '1010', '1011', '1100', '1101', '1110', '1111']\n\n[/Example 3]", "temperature": 0.925, "question": "Generate All Patterns of Length N: Given an integer n, generate all possible patterns of length n. The pattern should consist of only 0s and 1s.", "code": "from typing import List\ndef generatePatterns(n: int) -> List[str]:\n    if n == 1:\n        return [\"0\", \"1\"]\n    else:\n        prev_patterns = generatePatterns(n-1)\n        new_patterns = []\n        for pattern in prev_patterns:\n            new_patterns.append(pattern + \"0\")\n            new_patterns.append(pattern + \"1\")\n        return new_patterns", "asserts": ["assert generatePatterns(1) == ['0', '1']", "assert generatePatterns(2) == ['00', '01', '10', '11']", "assert generatePatterns(3) == ['000', '001', '010', '011', '100', '101', '110', '111']", "assert generatePatterns(4) == ['0000', '0001', '0010', '0011', '0100', '0101', '0110', '0111', '1000', '1001', '1010', '1011', '1100', '1101', '1110', '1111']"], "author": "GPT", "UUID": "a95fb9c7-d553-44e9-9754-1bc6ff0df3f5", "tc_status": [["assert generatePatterns(1) == ['0', '1']", "Passed"], ["assert generatePatterns(2) == ['00', '01', '10', '11']", "Passed"], ["assert generatePatterns(3) == ['000', '001', '010', '011', '100', '101', '110', '111']", "Passed"], ["assert generatePatterns(4) == ['0000', '0001', '0010', '0011', '0100', '0101', '0110', '0111', '1000', '1001', '1010', '1011', '1100', '1101', '1110', '1111']", "Passed"]]}, {"few_shots": [{"author": "Hafeez", "UUID": "8c9548d2-7b9c-46a4-9b8e-8afd488f7e87", "question": "Find and Replace Pattern: Given a list of strings words and a string pattern, return a list of words[i] that match pattern. You may return the answer in any order.\n\nA word matches the pattern if there exists a permutation of letters p so that after replacing every letter x in the pattern with p(x), we get the desired word.\n\nRecall that a permutation of letters is a bijection from letters to letters: every letter maps to another letter, and no two letters map to the same letter.", "examples": "Input: words = [\"abc\",\"deq\",\"mee\",\"aqq\",\"dkd\",\"ccc\"], pattern = \"abb\"\nOutput: [\"mee\",\"aqq\"]\nExplanation: \"mee\" matches the pattern because there is a permutation {a -> m, b -> e, ...}. \n\"ccc\" does not match the pattern because {a -> c, b -> c, ...} is not a permutation, since a and b map to the same letter.", "link": "https://leetcode.com/problems/find-and-replace-pattern/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def findAndReplacePattern(words: list, pattern: str) -> list:\n        def match(word):\n            m1, m2 = {}, {}\n            for w, p in zip(word, pattern):\n                if w not in m1: m1[w] = p\n                if p not in m2: m2[p] = w\n                if (m1[w], m2[p]) != (p, w):\n                    return False\n            return True\n\n        return list(filter(match, words))\n", "asserts": ["assert findAndReplacePattern([\"a\",\"b\",\"c\"], \"a\")==[\"a\",\"b\",\"c\"]", "assert findAndReplacePattern([\"xx\", \"xy\", \"yy\"], \"xx\") == [\"xx\", \"yy\"]", "assert findAndReplacePattern([\"abc\", \"def\", \"ghi\", \"jkl\"], \"xyz\") == [\"abc\", \"def\", \"ghi\", \"jkl\"]", "assert findAndReplacePattern([\"aaa\", \"bbb\", \"ccc\"], \"xyz\") == []"]}, {"author": "Hafeez", "UUID": "e811f9cc-fa5e-4ea0-8adb-8cf3ab7c72db", "question": "Detect Pattern of Length M Repeated K or More Times: Given an array of positive integers arr, find a pattern of length m that is repeated k or more times.\n\nA pattern is a subarray (consecutive sub-sequence) that consists of one or more values, repeated multiple times consecutively without overlapping. A pattern is defined by its length and the number of repetitions.\n\nReturn true if there exists a pattern of length m that is repeated k or more times, otherwise return false.", "examples": "Input: arr = [1,2,1,2,1,1,1,3], m = 2, k = 2\nOutput: true\nExplanation: The pattern (1,2) of length 2 is repeated 2 consecutive times. Another valid pattern (2,1) is also repeated 2 times.\nInput: arr = [1,2,1,2,1,3], m = 2, k = 3\nOutput: false\nExplanation: The pattern (1,2) is of length 2 but is repeated only 2 times. There is no pattern of length 2 that is repeated 3 or more times.\n", "link": "https://leetcode.com/problems/detect-pattern-of-length-m-repeated-k-or-more-times/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "from typing import List\ndef containsPattern(arr: List[int], m: int, k: int) -> bool:\n    i = 0\n    while i <= len(arr)-1:\n            p = arr[i:i+m]\n            if p * k == arr[i:i+m*k]:\n                    return True\n            i += 1\n    return False", "asserts": ["assert containsPattern([1,2,4,4,4,4],1,3)==True", "assert containsPattern([1,2,3,1,2,3,1,2,3], 3, 3) == True", "assert containsPattern([1,1,1,2,2,2,3,3], 2, 2) == False", "assert containsPattern([5,5,5,5,5,5,5], 1, 6) == True", "assert containsPattern([1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2], 2, 5) == True", "assert containsPattern([10,100,10,100,10,100,10,10,10,100], 2, 4) == False", "assert containsPattern([3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3], 4, 3) == True"]}], "category": "Pattern", "prompt_tokens": 923, "total_tokens": 1169, "completion_tokens": 246, "completion": "Identify Arithmetic Sequences: Given an array of numbers, determine if it contains an arithmetic sequence of length 3 or more.\n\nAn arithmetic sequence is a sequence of numbers in which the difference between consecutive terms is constant.\n\nWrite a function to determine if the given array contains an arithmetic sequence of length 3 or more.\n\n###Code:\n\ndef containsArithmeticSequence(arr: List[int]) -> bool:\n    for i in range(len(arr)-2):\n        if arr[i+1] - arr[i] == arr[i+2] - arr[i+1]:\n            return True\n    return False\n\n###Testcases: \n\nassert containsArithmeticSequence([1, 2, 3, 4, 5]) == True\nassert containsArithmeticSequence([1, 3, 5, 7, 9]) == True\nassert containsArithmeticSequence([3, 1, -1, -3, -5]) == True\nassert containsArithmeticSequence([1, 2, 4, 7, 11]) == False\nassert containsArithmeticSequence([1, 4, 7, 11, 14]) == False\n\n[/Example 3]", "temperature": 0.827, "question": "Identify Arithmetic Sequences: Given an array of numbers, determine if it contains an arithmetic sequence of length 3 or more.\n\nAn arithmetic sequence is a sequence of numbers in which the difference between consecutive terms is constant.\n\nWrite a function to determine if the given array contains an arithmetic sequence of length 3 or more.", "code": "def containsArithmeticSequence(arr: List[int]) -> bool:\n    for i in range(len(arr)-2):\n        if arr[i+1] - arr[i] == arr[i+2] - arr[i+1]:\n            return True\n    return False", "asserts": ["assert containsArithmeticSequence([1, 2, 3, 4, 5]) == True", "assert containsArithmeticSequence([1, 3, 5, 7, 9]) == True", "assert containsArithmeticSequence([3, 1, -1, -3, -5]) == True", "assert containsArithmeticSequence([1, 2, 4, 7, 11]) == False"], "author": "GPT", "UUID": "19b9654f-9252-4ac0-ba73-d4a92584a94c", "tc_status": [["assert containsArithmeticSequence([1, 2, 3, 4, 5]) == True", "Passed"], ["assert containsArithmeticSequence([1, 3, 5, 7, 9]) == True", "Passed"], ["assert containsArithmeticSequence([3, 1, -1, -3, -5]) == True", "Passed"], ["assert containsArithmeticSequence([1, 2, 4, 7, 11]) == False", "Passed"]]}, {"few_shots": [{"author": "Hafeez", "UUID": "8c9548d2-7b9c-46a4-9b8e-8afd488f7e87", "question": "Find and Replace Pattern: Given a list of strings words and a string pattern, return a list of words[i] that match pattern. You may return the answer in any order.\n\nA word matches the pattern if there exists a permutation of letters p so that after replacing every letter x in the pattern with p(x), we get the desired word.\n\nRecall that a permutation of letters is a bijection from letters to letters: every letter maps to another letter, and no two letters map to the same letter.", "examples": "Input: words = [\"abc\",\"deq\",\"mee\",\"aqq\",\"dkd\",\"ccc\"], pattern = \"abb\"\nOutput: [\"mee\",\"aqq\"]\nExplanation: \"mee\" matches the pattern because there is a permutation {a -> m, b -> e, ...}. \n\"ccc\" does not match the pattern because {a -> c, b -> c, ...} is not a permutation, since a and b map to the same letter.", "link": "https://leetcode.com/problems/find-and-replace-pattern/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def findAndReplacePattern(words: list, pattern: str) -> list:\n        def match(word):\n            m1, m2 = {}, {}\n            for w, p in zip(word, pattern):\n                if w not in m1: m1[w] = p\n                if p not in m2: m2[p] = w\n                if (m1[w], m2[p]) != (p, w):\n                    return False\n            return True\n\n        return list(filter(match, words))\n", "asserts": ["assert findAndReplacePattern([\"a\",\"b\",\"c\"], \"a\")==[\"a\",\"b\",\"c\"]", "assert findAndReplacePattern([\"xx\", \"xy\", \"yy\"], \"xx\") == [\"xx\", \"yy\"]", "assert findAndReplacePattern([\"abc\", \"def\", \"ghi\", \"jkl\"], \"xyz\") == [\"abc\", \"def\", \"ghi\", \"jkl\"]", "assert findAndReplacePattern([\"aaa\", \"bbb\", \"ccc\"], \"xyz\") == []"]}, {"author": "Hafeez", "UUID": "df98fd29-db88-4de7-a00a-0a3bd5ba1539", "question": "Word Pattern: Given a pattern and a string s, find if s follows the same pattern.\n\nHere follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in s.", "examples": "Input: pattern = \"abba\", s = \"dog cat cat fish\"\nOutput: false\nInput: pattern = \"aaaa\", s = \"dog cat cat dog\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def wordPattern(pattern: str, s: str) -> bool:\n    map_char = {}\n    map_word = {}\n    \n    words = s.split(' ')\n    if len(words) != len(pattern):\n        return False\n    \n    for c, w in zip(pattern, words):\n        if c not in map_char:\n            if w in map_word:\n                return False\n            else:\n                map_char[c] = w\n                map_word[w] = c\n        else:\n            if map_char[c] != w:\n                return False\n    return True", "asserts": ["assert wordPattern(\"abba\", \"dog cat cat dog\")==True", "assert wordPattern(\"aaaa\", \"dog dog dog dog\") == True", "assert wordPattern(\"xyz\", \"apple banana apple\") == False", "assert wordPattern(\"xyx\", \"apple banana apple\") == True", "assert wordPattern(\"abab\", \"dog cat dog cat\") == True", "assert wordPattern(\"aaaa\", \"dog dog dog cat\") == False", "assert wordPattern(\"aabb\", \"dog dog cat cat\") == True", "assert wordPattern(\"abc\", \"dog\") == False  # Not enough words", "assert wordPattern(\"\", \"dog cat\") == False  # Empty pattern", "assert wordPattern(\"a\", \"dog cat dog cat\") == False  # Not enough pattern characters", "assert wordPattern(\"ab\", \"\") == False  # Empty string", "assert wordPattern(\"abb\", \"dog dog dog\") == False  # Same word for different pattern characters", "assert wordPattern(\"abba\", \"dog cat cat\") == False  # Not enough words for the pattern", "assert wordPattern(\"abba\", \"dog cat cat dog fish\") == False  # Extra words beyond the pattern length"]}], "category": "Pattern", "prompt_tokens": 922, "total_tokens": 1224, "completion_tokens": 302, "completion": "Repeating Binary Pattern: Given a string s, return whether it represents a repeating pattern of a binary sequence.\n\n###Code: \n\n```python\ndef hasRepeatingPattern(s: str) -> bool:\n    n = len(s)\n    for i in range(1, n//2 + 1):\n        if n % i == 0:\n            pattern = s[:i]\n            if pattern * (n//i) == s:\n                return True\n    return False\n```\n\n###Testcases: \n\n```python\nassert hasRepeatingPattern(\"101010\") == True\nassert hasRepeatingPattern(\"1111\") == True\nassert hasRepeatingPattern(\"10010\") == False\nassert hasRepeatingPattern(\"abababab\") == True\nassert hasRepeatingPattern(\"abcabcabc\") == True\nassert hasRepeatingPattern(\"abcdabcdabcd\") == True\nassert hasRepeatingPattern(\"abcdefg\") == False\nassert hasRepeatingPattern(\"100100100\") == True\nassert hasRepeatingPattern(\"001001001\") == True\nassert hasRepeatingPattern(\"123123123\") == False\nassert hasRepeatingPattern(\"abababababab\") == True\nassert hasRepeatingPattern(\"aaa\") == True\nassert hasRepeatingPattern(\"aaabbb\") == False\nassert hasRepeatingPattern(\"xyzxyz\") == True\nassert hasRepeatingPattern(\"xyxyxyxy\") == True\n```", "temperature": 0.933, "question": "Repeating Binary Pattern: Given a string s, return whether it represents a repeating pattern of a binary sequence.", "code": "def hasRepeatingPattern(s: str) -> bool:\n    n = len(s)\n    for i in range(1, n//2 + 1):\n        if n % i == 0:\n            pattern = s[:i]\n            if pattern * (n//i) == s:\n                return True\n    return False", "asserts": ["assert hasRepeatingPattern(\"101010\") == True", "assert hasRepeatingPattern(\"1111\") == True", "assert hasRepeatingPattern(\"10010\") == False", "assert hasRepeatingPattern(\"abababab\") == True", "assert hasRepeatingPattern(\"abcabcabc\") == True", "assert hasRepeatingPattern(\"abcdabcdabcd\") == True", "assert hasRepeatingPattern(\"abcdefg\") == False", "assert hasRepeatingPattern(\"100100100\") == True", "assert hasRepeatingPattern(\"001001001\") == True", "assert hasRepeatingPattern(\"abababababab\") == True", "assert hasRepeatingPattern(\"aaa\") == True", "assert hasRepeatingPattern(\"aaabbb\") == False", "assert hasRepeatingPattern(\"xyzxyz\") == True", "assert hasRepeatingPattern(\"xyxyxyxy\") == True"], "author": "GPT", "UUID": "b6372f5a-cf9c-488c-802b-e77753e6a49f", "tc_status": [["assert hasRepeatingPattern(\"101010\") == True", "Passed"], ["assert hasRepeatingPattern(\"1111\") == True", "Passed"], ["assert hasRepeatingPattern(\"10010\") == False", "Passed"], ["assert hasRepeatingPattern(\"abababab\") == True", "Passed"], ["assert hasRepeatingPattern(\"abcabcabc\") == True", "Passed"], ["assert hasRepeatingPattern(\"abcdabcdabcd\") == True", "Passed"], ["assert hasRepeatingPattern(\"abcdefg\") == False", "Passed"], ["assert hasRepeatingPattern(\"100100100\") == True", "Passed"], ["assert hasRepeatingPattern(\"001001001\") == True", "Passed"], ["assert hasRepeatingPattern(\"abababababab\") == True", "Passed"], ["assert hasRepeatingPattern(\"aaa\") == True", "Passed"], ["assert hasRepeatingPattern(\"aaabbb\") == False", "Passed"], ["assert hasRepeatingPattern(\"xyzxyz\") == True", "Passed"], ["assert hasRepeatingPattern(\"xyxyxyxy\") == True", "Passed"]]}, {"few_shots": [{"author": "Hafeez", "UUID": "8c9548d2-7b9c-46a4-9b8e-8afd488f7e87", "question": "Find and Replace Pattern: Given a list of strings words and a string pattern, return a list of words[i] that match pattern. You may return the answer in any order.\n\nA word matches the pattern if there exists a permutation of letters p so that after replacing every letter x in the pattern with p(x), we get the desired word.\n\nRecall that a permutation of letters is a bijection from letters to letters: every letter maps to another letter, and no two letters map to the same letter.", "examples": "Input: words = [\"abc\",\"deq\",\"mee\",\"aqq\",\"dkd\",\"ccc\"], pattern = \"abb\"\nOutput: [\"mee\",\"aqq\"]\nExplanation: \"mee\" matches the pattern because there is a permutation {a -> m, b -> e, ...}. \n\"ccc\" does not match the pattern because {a -> c, b -> c, ...} is not a permutation, since a and b map to the same letter.", "link": "https://leetcode.com/problems/find-and-replace-pattern/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def findAndReplacePattern(words: list, pattern: str) -> list:\n        def match(word):\n            m1, m2 = {}, {}\n            for w, p in zip(word, pattern):\n                if w not in m1: m1[w] = p\n                if p not in m2: m2[p] = w\n                if (m1[w], m2[p]) != (p, w):\n                    return False\n            return True\n\n        return list(filter(match, words))\n", "asserts": ["assert findAndReplacePattern([\"a\",\"b\",\"c\"], \"a\")==[\"a\",\"b\",\"c\"]", "assert findAndReplacePattern([\"xx\", \"xy\", \"yy\"], \"xx\") == [\"xx\", \"yy\"]", "assert findAndReplacePattern([\"abc\", \"def\", \"ghi\", \"jkl\"], \"xyz\") == [\"abc\", \"def\", \"ghi\", \"jkl\"]", "assert findAndReplacePattern([\"aaa\", \"bbb\", \"ccc\"], \"xyz\") == []"]}, {"author": "Hafeez", "UUID": "df98fd29-db88-4de7-a00a-0a3bd5ba1539", "question": "Word Pattern: Given a pattern and a string s, find if s follows the same pattern.\n\nHere follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in s.", "examples": "Input: pattern = \"abba\", s = \"dog cat cat fish\"\nOutput: false\nInput: pattern = \"aaaa\", s = \"dog cat cat dog\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def wordPattern(pattern: str, s: str) -> bool:\n    map_char = {}\n    map_word = {}\n    \n    words = s.split(' ')\n    if len(words) != len(pattern):\n        return False\n    \n    for c, w in zip(pattern, words):\n        if c not in map_char:\n            if w in map_word:\n                return False\n            else:\n                map_char[c] = w\n                map_word[w] = c\n        else:\n            if map_char[c] != w:\n                return False\n    return True", "asserts": ["assert wordPattern(\"abba\", \"dog cat cat dog\")==True", "assert wordPattern(\"aaaa\", \"dog dog dog dog\") == True", "assert wordPattern(\"xyz\", \"apple banana apple\") == False", "assert wordPattern(\"xyx\", \"apple banana apple\") == True", "assert wordPattern(\"abab\", \"dog cat dog cat\") == True", "assert wordPattern(\"aaaa\", \"dog dog dog cat\") == False", "assert wordPattern(\"aabb\", \"dog dog cat cat\") == True", "assert wordPattern(\"abc\", \"dog\") == False  # Not enough words", "assert wordPattern(\"\", \"dog cat\") == False  # Empty pattern", "assert wordPattern(\"a\", \"dog cat dog cat\") == False  # Not enough pattern characters", "assert wordPattern(\"ab\", \"\") == False  # Empty string", "assert wordPattern(\"abb\", \"dog dog dog\") == False  # Same word for different pattern characters", "assert wordPattern(\"abba\", \"dog cat cat\") == False  # Not enough words for the pattern", "assert wordPattern(\"abba\", \"dog cat cat dog fish\") == False  # Extra words beyond the pattern length"]}], "category": "Pattern", "prompt_tokens": 922, "total_tokens": 1147, "completion_tokens": 225, "completion": "Repeated Substring Pattern: Given a non-empty string s, consider all possible substrings of s. Determine if any of them can be repeated to create the original string.\n\n###Code: \n\ndef repeatedSubstringPattern(s: str) -> bool:\n    n = len(s)\n    for i in range(1, n//2 + 1):\n        if n % i == 0:\n            if s[:i] * (n//i) == s:\n                return True\n    return False\n\n###Testcases: \n\nassert repeatedSubstringPattern(\"abab\") == True\nassert repeatedSubstringPattern(\"abcabcabcabc\") == True\nassert repeatedSubstringPattern(\"aba\") == False\nassert repeatedSubstringPattern(\"a\") == False\nassert repeatedSubstringPattern(\"abac\") == False\nassert repeatedSubstringPattern(\"ababab\") == True\nassert repeatedSubstringPattern(\"abababab\") == True\nassert repeatedSubstringPattern(\"abcdefg\") == False\nassert repeatedSubstringPattern(\"aaaa\") == True\nassert repeatedSubstringPattern(\"abcabcabc\") == True\n\n[/Example 3]", "temperature": 0.66, "question": "Repeated Substring Pattern: Given a non-empty string s, consider all possible substrings of s. Determine if any of them can be repeated to create the original string.", "code": "def repeatedSubstringPattern(s: str) -> bool:\n    n = len(s)\n    for i in range(1, n//2 + 1):\n        if n % i == 0:\n            if s[:i] * (n//i) == s:\n                return True\n    return False", "asserts": ["assert repeatedSubstringPattern(\"abab\") == True", "assert repeatedSubstringPattern(\"abcabcabcabc\") == True", "assert repeatedSubstringPattern(\"aba\") == False", "assert repeatedSubstringPattern(\"a\") == False", "assert repeatedSubstringPattern(\"abac\") == False", "assert repeatedSubstringPattern(\"ababab\") == True", "assert repeatedSubstringPattern(\"abababab\") == True", "assert repeatedSubstringPattern(\"abcdefg\") == False", "assert repeatedSubstringPattern(\"aaaa\") == True", "assert repeatedSubstringPattern(\"abcabcabc\") == True"], "author": "GPT", "UUID": "9f79aa7b-3e5a-4867-b182-542e15ef5b5f", "tc_status": [["assert repeatedSubstringPattern(\"abab\") == True", "Passed"], ["assert repeatedSubstringPattern(\"abcabcabcabc\") == True", "Passed"], ["assert repeatedSubstringPattern(\"aba\") == False", "Passed"], ["assert repeatedSubstringPattern(\"a\") == False", "Passed"], ["assert repeatedSubstringPattern(\"abac\") == False", "Passed"], ["assert repeatedSubstringPattern(\"ababab\") == True", "Passed"], ["assert repeatedSubstringPattern(\"abababab\") == True", "Passed"], ["assert repeatedSubstringPattern(\"abcdefg\") == False", "Passed"], ["assert repeatedSubstringPattern(\"aaaa\") == True", "Passed"], ["assert repeatedSubstringPattern(\"abcabcabc\") == True", "Passed"]]}, {"few_shots": [{"author": "Hafeez", "UUID": "124bfeca-24d0-411d-b4ad-26009b79436b", "question": "Word Pattern II: Given a pattern and a string s, return true if s matches the pattern.\n\nA string s matches a pattern if there is some bijective mapping of single characters to non-empty strings such that if each character in pattern is replaced by the string it maps to, then the resulting string is s. A bijective mapping means that no two characters map to the same string, and no character maps to two different strings.", "examples": "Input: pattern = \"abab\", s = \"redblueredblue\"\nOutput: true\nExplanation: One possible mapping is as follows:\n'a' -> \"red\"\n'b' -> \"blue\"\nInput: pattern = \"aabb\", s = \"xyzabcxzyabc\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern-ii/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def wordPatternMatch(pattern: str, s: str) -> bool:\n    def backtrack(cur: str, pattern: str, mappings: dict):\n        if not pattern:\n            return not cur\n        if pattern[0] in mappings:\n            if cur[:len(mappings[pattern[0]])] != mappings[pattern[0]]:\n                return False\n            return backtrack(cur[len(mappings[pattern[0]]):], pattern[1:], mappings)\n        for i in range(len(cur)):\n            if cur[:i+1] in mappings.values():\n                continue\n            mappings[pattern[0]] = cur[:i+1]\n            if backtrack(cur[i+1:], pattern[1:], mappings):\n                return True\n            del mappings[pattern[0]]\n        return False\n    return backtrack(s, pattern, {})", "asserts": ["assert wordPatternMatch(\"aaaa\", \"asdasdasdasd\")==True", "assert wordPatternMatch(\"abba\", \"dogcatcatdog\") == True", "assert wordPatternMatch(\"ab\", \"aa\") == False # since 'a' and 'b' cannot map to the same string \"a\"", "assert wordPatternMatch(\"xyz\", \"abcdefghi\") == True # 'x' -> \"a\", 'y' -> \"bc\", 'z' -> \"defghi\"", "assert wordPatternMatch(\"aba\", \"eggegg\") == False # 'a' maps to \"egg\", but 'b' cannot be mapped uniquely", "assert wordPatternMatch(\"zzz\", \"aaa\") == True # all 'z' map to \"a\"", "assert wordPatternMatch(\"aba\", \"catdogcat\") == True # 'a' -> \"cat\", 'b' -> \"dog\"", "assert wordPatternMatch(\"abab\", \"xyzxyzabcabc\") == False # cannot match 'a' and 'b' with two different strings each consistent with the pattern", "assert wordPatternMatch(\"abac\", \"xyzxyzxya\") == True # 'a' -> \"xyz\", 'b' -> \"xyz\", 'c' -> \"a\"", "assert wordPatternMatch(\"abcd\", \"xyzy\") == False # pattern too long for the string", "assert wordPatternMatch(\"aaaaa\", \"oneonetwo\") == False # not enough unique strings to map 'a' five times"]}, {"author": "Hafeez", "UUID": "effcb732-1f0d-4caa-8d9f-be914708d4ae", "question": "Repeated Substring Pattern: Given a string s, check if it can be constructed by taking a substring of it and appending multiple copies of the substring together.", "examples": "Input: s = \"aba\"\nOutput: false\nExplanation: It is the substring \"ab\" twice.\nInput: s = \"abcabcabcabc\"\nOutput: true\nExplanation: It is the substring \"abc\" four times or the substring \"abcabc\" twice.", "link": "https://leetcode.com/problems/repeated-substring-pattern/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def repeatedSubstringPattern(s: str) -> bool:\n    n = len(s)\n    for i in range(1, n // 2 + 1):\n        if n % i == 0:\n            pattern = s[:i] * (n // i)\n            if s == pattern:\n                return True\n    return False", "asserts": ["assert repeatedSubstringPattern(\"abab\")==True", "assert repeatedSubstringPattern(\"aaaa\") == True", "assert repeatedSubstringPattern(\"abac\") == False", "assert repeatedSubstringPattern(\"ababab\") == True", "assert repeatedSubstringPattern(\"xyzxyzxyz\") == True", "assert repeatedSubstringPattern(\"aaabaaa\") == False", "assert repeatedSubstringPattern(\"abababab\") == True", "assert repeatedSubstringPattern(\"abcabcab\") == False", "assert repeatedSubstringPattern(\"abbaabba\") == True", "assert repeatedSubstringPattern(\"\") == False", "assert repeatedSubstringPattern(\"a\") == False", "assert repeatedSubstringPattern(\"abacababacab\") == True"]}], "category": "Pattern", "prompt_tokens": 1013, "total_tokens": 1304, "completion_tokens": 291, "completion": "Missing Number in Arithmetic Progression: Given an array that represents the sequence of an arithmetic progression, find and return the missing number.\n\n###Code: \n\n```python\ndef findMissingNumber(arr):\n    n = len(arr)\n    diff = (arr[-1] - arr[0]) // n\n    left, right = 0, n - 1\n    while left < right:\n        mid = (left + right) // 2\n        if arr[mid] == arr[0] + (mid * diff):\n            left = mid + 1\n        else:\n            right = mid\n    return arr[0] + (left * diff)\n```\n\n###Testcases: \n\n```python\nassert findMissingNumber([1, 3, 5, 9, 11]) == 7\nassert findMissingNumber([2, 4, 8, 10]) == 6\nassert findMissingNumber([15, 18, 21, 24, 30]) == 27\nassert findMissingNumber([5, 10, 20, 25, 30]) == 15\nassert findMissingNumber([1, 4, 7, 10, 16, 19]) == 13\nassert findMissingNumber([3, 6, 9, 12, 21]) == 15\n```\n\n[/Example 3]", "temperature": 0.777, "question": "Missing Number in Arithmetic Progression: Given an array that represents the sequence of an arithmetic progression, find and return the missing number.", "code": "def findMissingNumber(arr):\n    n = len(arr)\n    diff = (arr[-1] - arr[0]) // n\n    left, right = 0, n - 1\n    while left < right:\n        mid = (left + right) // 2\n        if arr[mid] == arr[0] + (mid * diff):\n            left = mid + 1\n        else:\n            right = mid\n    return arr[0] + (left * diff)", "asserts": ["assert findMissingNumber([1, 3, 5, 9, 11]) == 7", "assert findMissingNumber([2, 4, 8, 10]) == 6", "assert findMissingNumber([15, 18, 21, 24, 30]) == 27", "assert findMissingNumber([5, 10, 20, 25, 30]) == 15", "assert findMissingNumber([1, 4, 7, 10, 16, 19]) == 13", "assert findMissingNumber([3, 6, 9, 12, 21]) == 15"], "author": "GPT", "UUID": "a2e929c2-1778-4958-bc7c-1f7378df6f39", "tc_status": [["assert findMissingNumber([1, 3, 5, 9, 11]) == 7", "Passed"], ["assert findMissingNumber([2, 4, 8, 10]) == 6", "Passed"], ["assert findMissingNumber([15, 18, 21, 24, 30]) == 27", "Passed"], ["assert findMissingNumber([5, 10, 20, 25, 30]) == 15", "Passed"], ["assert findMissingNumber([1, 4, 7, 10, 16, 19]) == 13", "Passed"], ["assert findMissingNumber([3, 6, 9, 12, 21]) == 15", "Passed"]]}, {"few_shots": [{"author": "Hafeez", "UUID": "124bfeca-24d0-411d-b4ad-26009b79436b", "question": "Word Pattern II: Given a pattern and a string s, return true if s matches the pattern.\n\nA string s matches a pattern if there is some bijective mapping of single characters to non-empty strings such that if each character in pattern is replaced by the string it maps to, then the resulting string is s. A bijective mapping means that no two characters map to the same string, and no character maps to two different strings.", "examples": "Input: pattern = \"abab\", s = \"redblueredblue\"\nOutput: true\nExplanation: One possible mapping is as follows:\n'a' -> \"red\"\n'b' -> \"blue\"\nInput: pattern = \"aabb\", s = \"xyzabcxzyabc\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern-ii/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def wordPatternMatch(pattern: str, s: str) -> bool:\n    def backtrack(cur: str, pattern: str, mappings: dict):\n        if not pattern:\n            return not cur\n        if pattern[0] in mappings:\n            if cur[:len(mappings[pattern[0]])] != mappings[pattern[0]]:\n                return False\n            return backtrack(cur[len(mappings[pattern[0]]):], pattern[1:], mappings)\n        for i in range(len(cur)):\n            if cur[:i+1] in mappings.values():\n                continue\n            mappings[pattern[0]] = cur[:i+1]\n            if backtrack(cur[i+1:], pattern[1:], mappings):\n                return True\n            del mappings[pattern[0]]\n        return False\n    return backtrack(s, pattern, {})", "asserts": ["assert wordPatternMatch(\"aaaa\", \"asdasdasdasd\")==True", "assert wordPatternMatch(\"abba\", \"dogcatcatdog\") == True", "assert wordPatternMatch(\"ab\", \"aa\") == False # since 'a' and 'b' cannot map to the same string \"a\"", "assert wordPatternMatch(\"xyz\", \"abcdefghi\") == True # 'x' -> \"a\", 'y' -> \"bc\", 'z' -> \"defghi\"", "assert wordPatternMatch(\"aba\", \"eggegg\") == False # 'a' maps to \"egg\", but 'b' cannot be mapped uniquely", "assert wordPatternMatch(\"zzz\", \"aaa\") == True # all 'z' map to \"a\"", "assert wordPatternMatch(\"aba\", \"catdogcat\") == True # 'a' -> \"cat\", 'b' -> \"dog\"", "assert wordPatternMatch(\"abab\", \"xyzxyzabcabc\") == False # cannot match 'a' and 'b' with two different strings each consistent with the pattern", "assert wordPatternMatch(\"abac\", \"xyzxyzxya\") == True # 'a' -> \"xyz\", 'b' -> \"xyz\", 'c' -> \"a\"", "assert wordPatternMatch(\"abcd\", \"xyzy\") == False # pattern too long for the string", "assert wordPatternMatch(\"aaaaa\", \"oneonetwo\") == False # not enough unique strings to map 'a' five times"]}, {"author": "Hafeez", "UUID": "effcb732-1f0d-4caa-8d9f-be914708d4ae", "question": "Repeated Substring Pattern: Given a string s, check if it can be constructed by taking a substring of it and appending multiple copies of the substring together.", "examples": "Input: s = \"aba\"\nOutput: false\nExplanation: It is the substring \"ab\" twice.\nInput: s = \"abcabcabcabc\"\nOutput: true\nExplanation: It is the substring \"abc\" four times or the substring \"abcabc\" twice.", "link": "https://leetcode.com/problems/repeated-substring-pattern/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def repeatedSubstringPattern(s: str) -> bool:\n    n = len(s)\n    for i in range(1, n // 2 + 1):\n        if n % i == 0:\n            pattern = s[:i] * (n // i)\n            if s == pattern:\n                return True\n    return False", "asserts": ["assert repeatedSubstringPattern(\"abab\")==True", "assert repeatedSubstringPattern(\"aaaa\") == True", "assert repeatedSubstringPattern(\"abac\") == False", "assert repeatedSubstringPattern(\"ababab\") == True", "assert repeatedSubstringPattern(\"xyzxyzxyz\") == True", "assert repeatedSubstringPattern(\"aaabaaa\") == False", "assert repeatedSubstringPattern(\"abababab\") == True", "assert repeatedSubstringPattern(\"abcabcab\") == False", "assert repeatedSubstringPattern(\"abbaabba\") == True", "assert repeatedSubstringPattern(\"\") == False", "assert repeatedSubstringPattern(\"a\") == False", "assert repeatedSubstringPattern(\"abacababacab\") == True"]}], "category": "Pattern", "prompt_tokens": 1013, "total_tokens": 1584, "completion_tokens": 571, "completion": "Lexicographical Numbers: Given an integer n, return 1 to n in lexicographical order.\n\n###Code: \n\ndef lexicalOrder(n: int) -> List[int]:\n    res = []\n    def dfs(curr, n):\n        if curr <= n:\n            res.append(curr)\n            for i in range(10):\n                if 10*curr + i <= n:\n                    dfs(10*curr + i, n)\n    for i in range(1, 10):\n        dfs(i, n)\n    return res\n\n###Testcases: \n\nassert lexicalOrder(13) == [1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9]\nassert lexicalOrder(5) == [1, 2, 3, 4, 5]\nassert lexicalOrder(20) == [1, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 2, 20, 3, 4, 5, 6, 7, 8, 9]\nassert lexicalOrder(1) == [1]\nassert lexicalOrder(100) == [1, 10, 100, 11, 12, 13, 14, 15, 16, 17, 18, 19, 2, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 3, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 4, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 5, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 6, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 7, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 8, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 9, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99]\n\n[/Example 3]", "temperature": 0.748, "question": "Lexicographical Numbers: Given an integer n, return 1 to n in lexicographical order.", "code": "def lexicalOrder(n: int) -> List[int]:\n    res = []\n    def dfs(curr, n):\n        if curr <= n:\n            res.append(curr)\n            for i in range(10):\n                if 10*curr + i <= n:\n                    dfs(10*curr + i, n)\n    for i in range(1, 10):\n        dfs(i, n)\n    return res", "asserts": ["assert lexicalOrder(13) == [1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9]", "assert lexicalOrder(5) == [1, 2, 3, 4, 5]", "assert lexicalOrder(20) == [1, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 2, 20, 3, 4, 5, 6, 7, 8, 9]", "assert lexicalOrder(1) == [1]", "assert lexicalOrder(100) == [1, 10, 100, 11, 12, 13, 14, 15, 16, 17, 18, 19, 2, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 3, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 4, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 5, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 6, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 7, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 8, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 9, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99]"], "author": "GPT", "UUID": "fc2bf86f-b94f-478a-a77b-5b9f7b09764b", "tc_status": [["assert lexicalOrder(13) == [1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9]", "Passed"], ["assert lexicalOrder(5) == [1, 2, 3, 4, 5]", "Passed"], ["assert lexicalOrder(20) == [1, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 2, 20, 3, 4, 5, 6, 7, 8, 9]", "Passed"], ["assert lexicalOrder(1) == [1]", "Passed"], ["assert lexicalOrder(100) == [1, 10, 100, 11, 12, 13, 14, 15, 16, 17, 18, 19, 2, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 3, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 4, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 5, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 6, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 7, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 8, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 9, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99]", "Passed"]]}, {"few_shots": [{"author": "Hafeez", "UUID": "124bfeca-24d0-411d-b4ad-26009b79436b", "question": "Word Pattern II: Given a pattern and a string s, return true if s matches the pattern.\n\nA string s matches a pattern if there is some bijective mapping of single characters to non-empty strings such that if each character in pattern is replaced by the string it maps to, then the resulting string is s. A bijective mapping means that no two characters map to the same string, and no character maps to two different strings.", "examples": "Input: pattern = \"abab\", s = \"redblueredblue\"\nOutput: true\nExplanation: One possible mapping is as follows:\n'a' -> \"red\"\n'b' -> \"blue\"\nInput: pattern = \"aabb\", s = \"xyzabcxzyabc\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern-ii/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def wordPatternMatch(pattern: str, s: str) -> bool:\n    def backtrack(cur: str, pattern: str, mappings: dict):\n        if not pattern:\n            return not cur\n        if pattern[0] in mappings:\n            if cur[:len(mappings[pattern[0]])] != mappings[pattern[0]]:\n                return False\n            return backtrack(cur[len(mappings[pattern[0]]):], pattern[1:], mappings)\n        for i in range(len(cur)):\n            if cur[:i+1] in mappings.values():\n                continue\n            mappings[pattern[0]] = cur[:i+1]\n            if backtrack(cur[i+1:], pattern[1:], mappings):\n                return True\n            del mappings[pattern[0]]\n        return False\n    return backtrack(s, pattern, {})", "asserts": ["assert wordPatternMatch(\"aaaa\", \"asdasdasdasd\")==True", "assert wordPatternMatch(\"abba\", \"dogcatcatdog\") == True", "assert wordPatternMatch(\"ab\", \"aa\") == False # since 'a' and 'b' cannot map to the same string \"a\"", "assert wordPatternMatch(\"xyz\", \"abcdefghi\") == True # 'x' -> \"a\", 'y' -> \"bc\", 'z' -> \"defghi\"", "assert wordPatternMatch(\"aba\", \"eggegg\") == False # 'a' maps to \"egg\", but 'b' cannot be mapped uniquely", "assert wordPatternMatch(\"zzz\", \"aaa\") == True # all 'z' map to \"a\"", "assert wordPatternMatch(\"aba\", \"catdogcat\") == True # 'a' -> \"cat\", 'b' -> \"dog\"", "assert wordPatternMatch(\"abab\", \"xyzxyzabcabc\") == False # cannot match 'a' and 'b' with two different strings each consistent with the pattern", "assert wordPatternMatch(\"abac\", \"xyzxyzxya\") == True # 'a' -> \"xyz\", 'b' -> \"xyz\", 'c' -> \"a\"", "assert wordPatternMatch(\"abcd\", \"xyzy\") == False # pattern too long for the string", "assert wordPatternMatch(\"aaaaa\", \"oneonetwo\") == False # not enough unique strings to map 'a' five times"]}, {"author": "Hafeez", "UUID": "effcb732-1f0d-4caa-8d9f-be914708d4ae", "question": "Repeated Substring Pattern: Given a string s, check if it can be constructed by taking a substring of it and appending multiple copies of the substring together.", "examples": "Input: s = \"aba\"\nOutput: false\nExplanation: It is the substring \"ab\" twice.\nInput: s = \"abcabcabcabc\"\nOutput: true\nExplanation: It is the substring \"abc\" four times or the substring \"abcabc\" twice.", "link": "https://leetcode.com/problems/repeated-substring-pattern/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def repeatedSubstringPattern(s: str) -> bool:\n    n = len(s)\n    for i in range(1, n // 2 + 1):\n        if n % i == 0:\n            pattern = s[:i] * (n // i)\n            if s == pattern:\n                return True\n    return False", "asserts": ["assert repeatedSubstringPattern(\"abab\")==True", "assert repeatedSubstringPattern(\"aaaa\") == True", "assert repeatedSubstringPattern(\"abac\") == False", "assert repeatedSubstringPattern(\"ababab\") == True", "assert repeatedSubstringPattern(\"xyzxyzxyz\") == True", "assert repeatedSubstringPattern(\"aaabaaa\") == False", "assert repeatedSubstringPattern(\"abababab\") == True", "assert repeatedSubstringPattern(\"abcabcab\") == False", "assert repeatedSubstringPattern(\"abbaabba\") == True", "assert repeatedSubstringPattern(\"\") == False", "assert repeatedSubstringPattern(\"a\") == False", "assert repeatedSubstringPattern(\"abacababacab\") == True"]}], "category": "Pattern", "prompt_tokens": 1013, "total_tokens": 1378, "completion_tokens": 365, "completion": "ZigZag Conversion: The string \"PAYPALISHIRING\" is written in a zigzag pattern on a given number of rows like this:\n\nP   A   H   N\nA P L S I I G\nY   I   R\n\nAnd then read line by line: \"PAHNAPLSIIGYIR\". Write the code to convert the string s into a zigzag pattern with a given number of rows.\n\n###Code: \n\ndef convert(s: str, numRows: int) -> str:\n    if numRows == 1:\n        return s\n    result = ['' for _ in range(numRows)]\n    i, direction = 0, 1\n    for ch in s:\n        result[i] += ch\n        if i == 0:\n            direction = 1\n        elif i == numRows - 1:\n            direction = -1\n        i += direction\n    return ''.join(result)\n\n###Testcases: \n\nassert convert(\"PAYPALISHIRING\", 3)==\"PAHNAPLSIIGYIR\"\nassert convert(\"AB\", 1) == \"AB\"\nassert convert(\"ABCD\", 2) == \"ACBD\"\nassert convert(\"ABCDE\", 4) == \"ABCED\"\nassert convert(\"PAYPALISHIRING\", 4) == \"PINALSIGYAHRPI\"\nassert convert(\"A\", 1) == \"A\"\nassert convert(\"ABCD\", 3) == \"ABDC\"\nassert convert(\"AB\", 2) == \"AB\"\nassert convert(\"PAYPALISHIRING\", 1) == \"PAYPALISHIRING\"\nassert convert(\"PAYPALISHIRING\", 5) == \"PHASIYIRPLIGAN\"\n\n[/Example 3]", "temperature": 0.711, "question": "ZigZag Conversion: The string \"PAYPALISHIRING\" is written in a zigzag pattern on a given number of rows like this:\n\nP   A   H   N\nA P L S I I G\nY   I   R\n\nAnd then read line by line: \"PAHNAPLSIIGYIR\". Write the code to convert the string s into a zigzag pattern with a given number of rows.", "code": "def convert(s: str, numRows: int) -> str:\n    if numRows == 1:\n        return s\n    result = ['' for _ in range(numRows)]\n    i, direction = 0, 1\n    for ch in s:\n        result[i] += ch\n        if i == 0:\n            direction = 1\n        elif i == numRows - 1:\n            direction = -1\n        i += direction\n    return ''.join(result)", "asserts": ["assert convert(\"PAYPALISHIRING\", 3)==\"PAHNAPLSIIGYIR\"", "assert convert(\"AB\", 1) == \"AB\"", "assert convert(\"ABCD\", 2) == \"ACBD\"", "assert convert(\"ABCDE\", 4) == \"ABCED\"", "assert convert(\"PAYPALISHIRING\", 4) == \"PINALSIGYAHRPI\"", "assert convert(\"A\", 1) == \"A\"", "assert convert(\"ABCD\", 3) == \"ABDC\"", "assert convert(\"AB\", 2) == \"AB\"", "assert convert(\"PAYPALISHIRING\", 1) == \"PAYPALISHIRING\"", "assert convert(\"PAYPALISHIRING\", 5) == \"PHASIYIRPLIGAN\""], "author": "GPT", "UUID": "bb15ee79-45f7-4a32-a3c6-b479a4264382", "tc_status": [["assert convert(\"PAYPALISHIRING\", 3)==\"PAHNAPLSIIGYIR\"", "Passed"], ["assert convert(\"AB\", 1) == \"AB\"", "Passed"], ["assert convert(\"ABCD\", 2) == \"ACBD\"", "Passed"], ["assert convert(\"ABCDE\", 4) == \"ABCED\"", "Passed"], ["assert convert(\"PAYPALISHIRING\", 4) == \"PINALSIGYAHRPI\"", "Passed"], ["assert convert(\"A\", 1) == \"A\"", "Passed"], ["assert convert(\"ABCD\", 3) == \"ABDC\"", "Passed"], ["assert convert(\"AB\", 2) == \"AB\"", "Passed"], ["assert convert(\"PAYPALISHIRING\", 1) == \"PAYPALISHIRING\"", "Passed"], ["assert convert(\"PAYPALISHIRING\", 5) == \"PHASIYIRPLIGAN\"", "Passed"]]}, {"few_shots": [{"author": "Hafeez", "UUID": "124bfeca-24d0-411d-b4ad-26009b79436b", "question": "Word Pattern II: Given a pattern and a string s, return true if s matches the pattern.\n\nA string s matches a pattern if there is some bijective mapping of single characters to non-empty strings such that if each character in pattern is replaced by the string it maps to, then the resulting string is s. A bijective mapping means that no two characters map to the same string, and no character maps to two different strings.", "examples": "Input: pattern = \"abab\", s = \"redblueredblue\"\nOutput: true\nExplanation: One possible mapping is as follows:\n'a' -> \"red\"\n'b' -> \"blue\"\nInput: pattern = \"aabb\", s = \"xyzabcxzyabc\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern-ii/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def wordPatternMatch(pattern: str, s: str) -> bool:\n    def backtrack(cur: str, pattern: str, mappings: dict):\n        if not pattern:\n            return not cur\n        if pattern[0] in mappings:\n            if cur[:len(mappings[pattern[0]])] != mappings[pattern[0]]:\n                return False\n            return backtrack(cur[len(mappings[pattern[0]]):], pattern[1:], mappings)\n        for i in range(len(cur)):\n            if cur[:i+1] in mappings.values():\n                continue\n            mappings[pattern[0]] = cur[:i+1]\n            if backtrack(cur[i+1:], pattern[1:], mappings):\n                return True\n            del mappings[pattern[0]]\n        return False\n    return backtrack(s, pattern, {})", "asserts": ["assert wordPatternMatch(\"aaaa\", \"asdasdasdasd\")==True", "assert wordPatternMatch(\"abba\", \"dogcatcatdog\") == True", "assert wordPatternMatch(\"ab\", \"aa\") == False # since 'a' and 'b' cannot map to the same string \"a\"", "assert wordPatternMatch(\"xyz\", \"abcdefghi\") == True # 'x' -> \"a\", 'y' -> \"bc\", 'z' -> \"defghi\"", "assert wordPatternMatch(\"aba\", \"eggegg\") == False # 'a' maps to \"egg\", but 'b' cannot be mapped uniquely", "assert wordPatternMatch(\"zzz\", \"aaa\") == True # all 'z' map to \"a\"", "assert wordPatternMatch(\"aba\", \"catdogcat\") == True # 'a' -> \"cat\", 'b' -> \"dog\"", "assert wordPatternMatch(\"abab\", \"xyzxyzabcabc\") == False # cannot match 'a' and 'b' with two different strings each consistent with the pattern", "assert wordPatternMatch(\"abac\", \"xyzxyzxya\") == True # 'a' -> \"xyz\", 'b' -> \"xyz\", 'c' -> \"a\"", "assert wordPatternMatch(\"abcd\", \"xyzy\") == False # pattern too long for the string", "assert wordPatternMatch(\"aaaaa\", \"oneonetwo\") == False # not enough unique strings to map 'a' five times"]}, {"author": "Hafeez", "UUID": "e811f9cc-fa5e-4ea0-8adb-8cf3ab7c72db", "question": "Detect Pattern of Length M Repeated K or More Times: Given an array of positive integers arr, find a pattern of length m that is repeated k or more times.\n\nA pattern is a subarray (consecutive sub-sequence) that consists of one or more values, repeated multiple times consecutively without overlapping. A pattern is defined by its length and the number of repetitions.\n\nReturn true if there exists a pattern of length m that is repeated k or more times, otherwise return false.", "examples": "Input: arr = [1,2,1,2,1,1,1,3], m = 2, k = 2\nOutput: true\nExplanation: The pattern (1,2) of length 2 is repeated 2 consecutive times. Another valid pattern (2,1) is also repeated 2 times.\nInput: arr = [1,2,1,2,1,3], m = 2, k = 3\nOutput: false\nExplanation: The pattern (1,2) is of length 2 but is repeated only 2 times. There is no pattern of length 2 that is repeated 3 or more times.\n", "link": "https://leetcode.com/problems/detect-pattern-of-length-m-repeated-k-or-more-times/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "from typing import List\ndef containsPattern(arr: List[int], m: int, k: int) -> bool:\n    i = 0\n    while i <= len(arr)-1:\n            p = arr[i:i+m]\n            if p * k == arr[i:i+m*k]:\n                    return True\n            i += 1\n    return False", "asserts": ["assert containsPattern([1,2,4,4,4,4],1,3)==True", "assert containsPattern([1,2,3,1,2,3,1,2,3], 3, 3) == True", "assert containsPattern([1,1,1,2,2,2,3,3], 2, 2) == False", "assert containsPattern([5,5,5,5,5,5,5], 1, 6) == True", "assert containsPattern([1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2], 2, 5) == True", "assert containsPattern([10,100,10,100,10,100,10,10,10,100], 2, 4) == False", "assert containsPattern([3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3], 4, 3) == True"]}], "category": "Pattern", "prompt_tokens": 1179, "total_tokens": 1535, "completion_tokens": 356, "completion": "Count Binary Substrings: Give a string s, count the number of non-empty (contiguous) substrings that have the same number of 0's and 1's, and all the 0's and all the 1's in these substrings are grouped consecutively.\n\nFor example, with input \"00110011\", the output should be 6, as the 6 substrings that have the same number of 0's and 1's and all the 0's and 1's are grouped consecutively are: \"0011\", \"01\", \"1100\", \"10\", \"0011\", and \"01\".\n\n###Code: \n\ndef countBinarySubstrings(s: str) -> int:\n    groups = [1]\n    for i in range(1, len(s)):\n        if s[i-1] != s[i]:\n            groups.append(1)\n        else:\n            groups[-1] += 1\n\n    ans = 0\n    for i in range(1, len(groups)):\n        ans += min(groups[i-1], groups[i])\n    return ans\n\n###Testcases: \n\nassert countBinarySubstrings(\"00110011\") == 6\nassert countBinarySubstrings(\"10101\") == 4\nassert countBinarySubstrings(\"00110\") == 3\nassert countBinarySubstrings(\"001100\") == 3\nassert countBinarySubstrings(\"000111\") == 3\nassert countBinarySubstrings(\"0010\") == 2\nassert countBinarySubstrings(\"0000\") == 0\nassert countBinarySubstrings(\"1111\") == 0\nassert countBinarySubstrings(\"1010\") == 2\n\n[/Example 3]", "temperature": 0.821, "question": "Count Binary Substrings: Give a string s, count the number of non-empty (contiguous) substrings that have the same number of 0's and 1's, and all the 0's and all the 1's in these substrings are grouped consecutively.\n\nFor example, with input \"00110011\", the output should be 6, as the 6 substrings that have the same number of 0's and 1's and all the 0's and 1's are grouped consecutively are: \"0011\", \"01\", \"1100\", \"10\", \"0011\", and \"01\".", "code": "def countBinarySubstrings(s: str) -> int:\n    groups = [1]\n    for i in range(1, len(s)):\n        if s[i-1] != s[i]:\n            groups.append(1)\n        else:\n            groups[-1] += 1\n\n    ans = 0\n    for i in range(1, len(groups)):\n        ans += min(groups[i-1], groups[i])\n    return ans", "asserts": ["assert countBinarySubstrings(\"00110011\") == 6", "assert countBinarySubstrings(\"10101\") == 4", "assert countBinarySubstrings(\"00110\") == 3", "assert countBinarySubstrings(\"000111\") == 3", "assert countBinarySubstrings(\"0010\") == 2", "assert countBinarySubstrings(\"0000\") == 0", "assert countBinarySubstrings(\"1111\") == 0"], "author": "GPT", "UUID": "1f1a2c64-39c2-4273-b1bf-c116f76e031d", "tc_status": [["assert countBinarySubstrings(\"00110011\") == 6", "Passed"], ["assert countBinarySubstrings(\"10101\") == 4", "Passed"], ["assert countBinarySubstrings(\"00110\") == 3", "Passed"], ["assert countBinarySubstrings(\"000111\") == 3", "Passed"], ["assert countBinarySubstrings(\"0010\") == 2", "Passed"], ["assert countBinarySubstrings(\"0000\") == 0", "Passed"], ["assert countBinarySubstrings(\"1111\") == 0", "Passed"]]}, {"few_shots": [{"author": "Hafeez", "UUID": "124bfeca-24d0-411d-b4ad-26009b79436b", "question": "Word Pattern II: Given a pattern and a string s, return true if s matches the pattern.\n\nA string s matches a pattern if there is some bijective mapping of single characters to non-empty strings such that if each character in pattern is replaced by the string it maps to, then the resulting string is s. A bijective mapping means that no two characters map to the same string, and no character maps to two different strings.", "examples": "Input: pattern = \"abab\", s = \"redblueredblue\"\nOutput: true\nExplanation: One possible mapping is as follows:\n'a' -> \"red\"\n'b' -> \"blue\"\nInput: pattern = \"aabb\", s = \"xyzabcxzyabc\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern-ii/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def wordPatternMatch(pattern: str, s: str) -> bool:\n    def backtrack(cur: str, pattern: str, mappings: dict):\n        if not pattern:\n            return not cur\n        if pattern[0] in mappings:\n            if cur[:len(mappings[pattern[0]])] != mappings[pattern[0]]:\n                return False\n            return backtrack(cur[len(mappings[pattern[0]]):], pattern[1:], mappings)\n        for i in range(len(cur)):\n            if cur[:i+1] in mappings.values():\n                continue\n            mappings[pattern[0]] = cur[:i+1]\n            if backtrack(cur[i+1:], pattern[1:], mappings):\n                return True\n            del mappings[pattern[0]]\n        return False\n    return backtrack(s, pattern, {})", "asserts": ["assert wordPatternMatch(\"aaaa\", \"asdasdasdasd\")==True", "assert wordPatternMatch(\"abba\", \"dogcatcatdog\") == True", "assert wordPatternMatch(\"ab\", \"aa\") == False # since 'a' and 'b' cannot map to the same string \"a\"", "assert wordPatternMatch(\"xyz\", \"abcdefghi\") == True # 'x' -> \"a\", 'y' -> \"bc\", 'z' -> \"defghi\"", "assert wordPatternMatch(\"aba\", \"eggegg\") == False # 'a' maps to \"egg\", but 'b' cannot be mapped uniquely", "assert wordPatternMatch(\"zzz\", \"aaa\") == True # all 'z' map to \"a\"", "assert wordPatternMatch(\"aba\", \"catdogcat\") == True # 'a' -> \"cat\", 'b' -> \"dog\"", "assert wordPatternMatch(\"abab\", \"xyzxyzabcabc\") == False # cannot match 'a' and 'b' with two different strings each consistent with the pattern", "assert wordPatternMatch(\"abac\", \"xyzxyzxya\") == True # 'a' -> \"xyz\", 'b' -> \"xyz\", 'c' -> \"a\"", "assert wordPatternMatch(\"abcd\", \"xyzy\") == False # pattern too long for the string", "assert wordPatternMatch(\"aaaaa\", \"oneonetwo\") == False # not enough unique strings to map 'a' five times"]}, {"author": "Hafeez", "UUID": "df98fd29-db88-4de7-a00a-0a3bd5ba1539", "question": "Word Pattern: Given a pattern and a string s, find if s follows the same pattern.\n\nHere follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in s.", "examples": "Input: pattern = \"abba\", s = \"dog cat cat fish\"\nOutput: false\nInput: pattern = \"aaaa\", s = \"dog cat cat dog\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def wordPattern(pattern: str, s: str) -> bool:\n    map_char = {}\n    map_word = {}\n    \n    words = s.split(' ')\n    if len(words) != len(pattern):\n        return False\n    \n    for c, w in zip(pattern, words):\n        if c not in map_char:\n            if w in map_word:\n                return False\n            else:\n                map_char[c] = w\n                map_word[w] = c\n        else:\n            if map_char[c] != w:\n                return False\n    return True", "asserts": ["assert wordPattern(\"abba\", \"dog cat cat dog\")==True", "assert wordPattern(\"aaaa\", \"dog dog dog dog\") == True", "assert wordPattern(\"xyz\", \"apple banana apple\") == False", "assert wordPattern(\"xyx\", \"apple banana apple\") == True", "assert wordPattern(\"abab\", \"dog cat dog cat\") == True", "assert wordPattern(\"aaaa\", \"dog dog dog cat\") == False", "assert wordPattern(\"aabb\", \"dog dog cat cat\") == True", "assert wordPattern(\"abc\", \"dog\") == False  # Not enough words", "assert wordPattern(\"\", \"dog cat\") == False  # Empty pattern", "assert wordPattern(\"a\", \"dog cat dog cat\") == False  # Not enough pattern characters", "assert wordPattern(\"ab\", \"\") == False  # Empty string", "assert wordPattern(\"abb\", \"dog dog dog\") == False  # Same word for different pattern characters", "assert wordPattern(\"abba\", \"dog cat cat\") == False  # Not enough words for the pattern", "assert wordPattern(\"abba\", \"dog cat cat dog fish\") == False  # Extra words beyond the pattern length"]}], "category": "Pattern", "prompt_tokens": 1178, "total_tokens": 1894, "completion_tokens": 716, "completion": "Word Pattern III: Given a pattern and a string s, return true if s matches the pattern. In this case, the pattern can contain both single and multiple characters. A multiple character is a character that can be mapped to one or more strings.\n\n###Code: \n\n```python\ndef wordPatternMatch(pattern: str, s: str) -> bool:\n    def backtrack(pattern, s, pattern_to_word, word_to_pattern):\n        if not pattern and not s:\n            return True\n        if not pattern or not s:\n            return False\n        char = pattern[0]\n        if char in pattern_to_word:\n            word = pattern_to_word[char]\n            if s.startswith(word):\n                return backtrack(pattern[1:], s[len(word):], pattern_to_word, word_to_pattern)\n            else:\n                return False\n        else:\n            for i in range(1, len(s)+1):\n                word = s[:i]\n                if word in word_to_pattern:\n                    continue\n                pattern_to_word[char] = word\n                word_to_pattern[word] = char\n                if backtrack(pattern[1:], s[i:], pattern_to_word, word_to_pattern):\n                    return True\n                del pattern_to_word[char]\n                del word_to_pattern[word]\n            return False\n    \n    return backtrack(pattern, s, {}, {})\n\n```\n\n###Testcases: \n\n```python\nassert wordPatternMatch(\"abab\", \"redblueredblue\") == True\nassert wordPatternMatch(\"aaaa\", \"asdasdasdasd\") == True\nassert wordPatternMatch(\"aabb\", \"xyzabcxzyabc\") == False\nassert wordPatternMatch(\"ab\", \"aa\") == False\nassert wordPatternMatch(\"ab\", \"xyzabcxzyabc\") == True\nassert wordPatternMatch(\"abab\", \"xyzxyzabcabc\") == True\nassert wordPatternMatch(\"aba\", \"xyzxyzxya\") == True\nassert wordPatternMatch(\"abac\", \"xyzxyzxya\") == False\nassert wordPatternMatch(\"abba\", \"dogcatcatdog\") == True\nassert wordPatternMatch(\"abba\", \"dogcatcatfish\") == False\nassert wordPatternMatch(\"aaaa\", \"oneonetwo\") == False\nassert wordPatternMatch(\"ab\", \"\") == False\nassert wordPatternMatch(\"\", \"xyz\") == False\nassert wordPatternMatch(\"abc\", \"dog\") == False\nassert wordPatternMatch(\"abab\", \"redblueredblue\") == True\nassert wordPatternMatch(\"abab\", \"redblueredblue\") == True\nassert wordPatternMatch(\"aabb\", \"xyzabcxzyabc\") == False\nassert wordPatternMatch(\"ab\", \"aa\") == False\nassert wordPatternMatch(\"ab\", \"xyzabcxzyabc\") == True\nassert wordPatternMatch(\"abab\", \"xyzxyzabcabc\") == True\nassert wordPatternMatch(\"aba\", \"xyzxyzxya\") == True\nassert wordPatternMatch(\"abac\", \"xyzxyzxya\") == False\nassert wordPatternMatch(\"abba\", \"dogcatcatdog\") == True\nassert wordPatternMatch(\"abba\", \"dogcatcatfish\") == False\nassert wordPatternMatch(\"aaaa\", \"oneonetwo\") == False\nassert wordPatternMatch(\"ab\", \"\") == False\nassert wordPatternMatch(\"\", \"xyz\") == False\nassert wordPatternMatch(\"abc\", \"dog\") == False\n```\n\n", "temperature": 0.609, "question": "Word Pattern III: Given a pattern and a string s, return true if s matches the pattern. In this case, the pattern can contain both single and multiple characters. A multiple character is a character that can be mapped to one or more strings.", "code": "def wordPatternMatch(pattern: str, s: str) -> bool:\n    def backtrack(pattern, s, pattern_to_word, word_to_pattern):\n        if not pattern and not s:\n            return True\n        if not pattern or not s:\n            return False\n        char = pattern[0]\n        if char in pattern_to_word:\n            word = pattern_to_word[char]\n            if s.startswith(word):\n                return backtrack(pattern[1:], s[len(word):], pattern_to_word, word_to_pattern)\n            else:\n                return False\n        else:\n            for i in range(1, len(s)+1):\n                word = s[:i]\n                if word in word_to_pattern:\n                    continue\n                pattern_to_word[char] = word\n                word_to_pattern[word] = char\n                if backtrack(pattern[1:], s[i:], pattern_to_word, word_to_pattern):\n                    return True\n                del pattern_to_word[char]\n                del word_to_pattern[word]\n            return False\n    \n    return backtrack(pattern, s, {}, {})", "asserts": ["assert wordPatternMatch(\"abab\", \"redblueredblue\") == True", "assert wordPatternMatch(\"aaaa\", \"asdasdasdasd\") == True", "assert wordPatternMatch(\"aabb\", \"xyzabcxzyabc\") == False", "assert wordPatternMatch(\"ab\", \"aa\") == False", "assert wordPatternMatch(\"ab\", \"xyzabcxzyabc\") == True", "assert wordPatternMatch(\"abba\", \"dogcatcatdog\") == True", "assert wordPatternMatch(\"abba\", \"dogcatcatfish\") == False", "assert wordPatternMatch(\"aaaa\", \"oneonetwo\") == False", "assert wordPatternMatch(\"ab\", \"\") == False", "assert wordPatternMatch(\"\", \"xyz\") == False", "assert wordPatternMatch(\"abab\", \"redblueredblue\") == True", "assert wordPatternMatch(\"abab\", \"redblueredblue\") == True", "assert wordPatternMatch(\"aabb\", \"xyzabcxzyabc\") == False", "assert wordPatternMatch(\"ab\", \"aa\") == False", "assert wordPatternMatch(\"ab\", \"xyzabcxzyabc\") == True", "assert wordPatternMatch(\"abba\", \"dogcatcatdog\") == True", "assert wordPatternMatch(\"abba\", \"dogcatcatfish\") == False", "assert wordPatternMatch(\"aaaa\", \"oneonetwo\") == False", "assert wordPatternMatch(\"ab\", \"\") == False", "assert wordPatternMatch(\"\", \"xyz\") == False"], "author": "GPT", "UUID": "bafe336f-bf87-4314-850a-e045418ea693", "tc_status": [["assert wordPatternMatch(\"abab\", \"redblueredblue\") == True", "Passed"], ["assert wordPatternMatch(\"aaaa\", \"asdasdasdasd\") == True", "Passed"], ["assert wordPatternMatch(\"aabb\", \"xyzabcxzyabc\") == False", "Passed"], ["assert wordPatternMatch(\"ab\", \"aa\") == False", "Passed"], ["assert wordPatternMatch(\"ab\", \"xyzabcxzyabc\") == True", "Passed"], ["assert wordPatternMatch(\"abba\", \"dogcatcatdog\") == True", "Passed"], ["assert wordPatternMatch(\"abba\", \"dogcatcatfish\") == False", "Passed"], ["assert wordPatternMatch(\"aaaa\", \"oneonetwo\") == False", "Passed"], ["assert wordPatternMatch(\"ab\", \"\") == False", "Passed"], ["assert wordPatternMatch(\"\", \"xyz\") == False", "Passed"], ["assert wordPatternMatch(\"abab\", \"redblueredblue\") == True", "Passed"], ["assert wordPatternMatch(\"abab\", \"redblueredblue\") == True", "Passed"], ["assert wordPatternMatch(\"aabb\", \"xyzabcxzyabc\") == False", "Passed"], ["assert wordPatternMatch(\"ab\", \"aa\") == False", "Passed"], ["assert wordPatternMatch(\"ab\", \"xyzabcxzyabc\") == True", "Passed"], ["assert wordPatternMatch(\"abba\", \"dogcatcatdog\") == True", "Passed"], ["assert wordPatternMatch(\"abba\", \"dogcatcatfish\") == False", "Passed"], ["assert wordPatternMatch(\"aaaa\", \"oneonetwo\") == False", "Passed"], ["assert wordPatternMatch(\"ab\", \"\") == False", "Passed"], ["assert wordPatternMatch(\"\", \"xyz\") == False", "Passed"]]}, {"few_shots": [{"author": "Hafeez", "UUID": "124bfeca-24d0-411d-b4ad-26009b79436b", "question": "Word Pattern II: Given a pattern and a string s, return true if s matches the pattern.\n\nA string s matches a pattern if there is some bijective mapping of single characters to non-empty strings such that if each character in pattern is replaced by the string it maps to, then the resulting string is s. A bijective mapping means that no two characters map to the same string, and no character maps to two different strings.", "examples": "Input: pattern = \"abab\", s = \"redblueredblue\"\nOutput: true\nExplanation: One possible mapping is as follows:\n'a' -> \"red\"\n'b' -> \"blue\"\nInput: pattern = \"aabb\", s = \"xyzabcxzyabc\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern-ii/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def wordPatternMatch(pattern: str, s: str) -> bool:\n    def backtrack(cur: str, pattern: str, mappings: dict):\n        if not pattern:\n            return not cur\n        if pattern[0] in mappings:\n            if cur[:len(mappings[pattern[0]])] != mappings[pattern[0]]:\n                return False\n            return backtrack(cur[len(mappings[pattern[0]]):], pattern[1:], mappings)\n        for i in range(len(cur)):\n            if cur[:i+1] in mappings.values():\n                continue\n            mappings[pattern[0]] = cur[:i+1]\n            if backtrack(cur[i+1:], pattern[1:], mappings):\n                return True\n            del mappings[pattern[0]]\n        return False\n    return backtrack(s, pattern, {})", "asserts": ["assert wordPatternMatch(\"aaaa\", \"asdasdasdasd\")==True", "assert wordPatternMatch(\"abba\", \"dogcatcatdog\") == True", "assert wordPatternMatch(\"ab\", \"aa\") == False # since 'a' and 'b' cannot map to the same string \"a\"", "assert wordPatternMatch(\"xyz\", \"abcdefghi\") == True # 'x' -> \"a\", 'y' -> \"bc\", 'z' -> \"defghi\"", "assert wordPatternMatch(\"aba\", \"eggegg\") == False # 'a' maps to \"egg\", but 'b' cannot be mapped uniquely", "assert wordPatternMatch(\"zzz\", \"aaa\") == True # all 'z' map to \"a\"", "assert wordPatternMatch(\"aba\", \"catdogcat\") == True # 'a' -> \"cat\", 'b' -> \"dog\"", "assert wordPatternMatch(\"abab\", \"xyzxyzabcabc\") == False # cannot match 'a' and 'b' with two different strings each consistent with the pattern", "assert wordPatternMatch(\"abac\", \"xyzxyzxya\") == True # 'a' -> \"xyz\", 'b' -> \"xyz\", 'c' -> \"a\"", "assert wordPatternMatch(\"abcd\", \"xyzy\") == False # pattern too long for the string", "assert wordPatternMatch(\"aaaaa\", \"oneonetwo\") == False # not enough unique strings to map 'a' five times"]}, {"author": "Hafeez", "UUID": "8c9548d2-7b9c-46a4-9b8e-8afd488f7e87", "question": "Find and Replace Pattern: Given a list of strings words and a string pattern, return a list of words[i] that match pattern. You may return the answer in any order.\n\nA word matches the pattern if there exists a permutation of letters p so that after replacing every letter x in the pattern with p(x), we get the desired word.\n\nRecall that a permutation of letters is a bijection from letters to letters: every letter maps to another letter, and no two letters map to the same letter.", "examples": "Input: words = [\"abc\",\"deq\",\"mee\",\"aqq\",\"dkd\",\"ccc\"], pattern = \"abb\"\nOutput: [\"mee\",\"aqq\"]\nExplanation: \"mee\" matches the pattern because there is a permutation {a -> m, b -> e, ...}. \n\"ccc\" does not match the pattern because {a -> c, b -> c, ...} is not a permutation, since a and b map to the same letter.", "link": "https://leetcode.com/problems/find-and-replace-pattern/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def findAndReplacePattern(words: list, pattern: str) -> list:\n        def match(word):\n            m1, m2 = {}, {}\n            for w, p in zip(word, pattern):\n                if w not in m1: m1[w] = p\n                if p not in m2: m2[p] = w\n                if (m1[w], m2[p]) != (p, w):\n                    return False\n            return True\n\n        return list(filter(match, words))\n", "asserts": ["assert findAndReplacePattern([\"a\",\"b\",\"c\"], \"a\")==[\"a\",\"b\",\"c\"]", "assert findAndReplacePattern([\"xx\", \"xy\", \"yy\"], \"xx\") == [\"xx\", \"yy\"]", "assert findAndReplacePattern([\"abc\", \"def\", \"ghi\", \"jkl\"], \"xyz\") == [\"abc\", \"def\", \"ghi\", \"jkl\"]", "assert findAndReplacePattern([\"aaa\", \"bbb\", \"ccc\"], \"xyz\") == []"]}], "category": "Pattern", "prompt_tokens": 1081, "total_tokens": 1366, "completion_tokens": 285, "completion": "###Question:\n\nGiven a string s and a pattern p, implement regular expression matching with support for '.' and '*'.\n\n- '.' Matches any single character.\n- '*' Matches zero or more of the preceding element.\n\nThe matching should cover the entire input string (not partial).\n\n###Code:\n\n```python\ndef isMatch(s: str, p: str) -> bool:\n    if not p:\n        return not s\n    first_match = bool(s) and p[0] in {s[0], '.'}\n    if len(p) >= 2 and p[1] == '*':\n        return (isMatch(s, p[2:]) or\n                first_match and isMatch(s[1:], p))\n    else:\n        return first_match and isMatch(s[1:], p[1:])\n```\n\n###Testcases:\n\n```python\nassert isMatch(\"aa\", \"a\") == False\nassert isMatch(\"aa\", \"a*\") == True\nassert isMatch(\"ab\", \".*\") == True\nassert isMatch(\"aab\", \"c*a*b\") == True\nassert isMatch(\"mississippi\", \"mis*is*p*.\") == False\nassert isMatch(\"ab\", \".*c\") == False\nassert isMatch(\"abc\", \".*c\") == True\nassert isMatch(\"aaa\", \"a*a\") == True\n```\n\n[/Example 3]", "temperature": 0.756, "question": "###Question:\n\nGiven a string s and a pattern p, implement regular expression matching with support for '.' and '*'.\n\n- '.' Matches any single character.\n- '*' Matches zero or more of the preceding element.\n\nThe matching should cover the entire input string (not partial).", "code": "def isMatch(s: str, p: str) -> bool:\n    if not p:\n        return not s\n    first_match = bool(s) and p[0] in {s[0], '.'}\n    if len(p) >= 2 and p[1] == '*':\n        return (isMatch(s, p[2:]) or\n                first_match and isMatch(s[1:], p))\n    else:\n        return first_match and isMatch(s[1:], p[1:])", "asserts": ["assert isMatch(\"aa\", \"a\") == False", "assert isMatch(\"aa\", \"a*\") == True", "assert isMatch(\"ab\", \".*\") == True", "assert isMatch(\"aab\", \"c*a*b\") == True", "assert isMatch(\"mississippi\", \"mis*is*p*.\") == False", "assert isMatch(\"ab\", \".*c\") == False", "assert isMatch(\"abc\", \".*c\") == True", "assert isMatch(\"aaa\", \"a*a\") == True"], "author": "GPT", "UUID": "67342595-cc3c-4005-9618-d8653c11b9ae", "tc_status": [["assert isMatch(\"aa\", \"a\") == False", "Passed"], ["assert isMatch(\"aa\", \"a*\") == True", "Passed"], ["assert isMatch(\"ab\", \".*\") == True", "Passed"], ["assert isMatch(\"aab\", \"c*a*b\") == True", "Passed"], ["assert isMatch(\"mississippi\", \"mis*is*p*.\") == False", "Passed"], ["assert isMatch(\"ab\", \".*c\") == False", "Passed"], ["assert isMatch(\"abc\", \".*c\") == True", "Passed"], ["assert isMatch(\"aaa\", \"a*a\") == True", "Passed"]]}, {"few_shots": [{"author": "Hafeez", "UUID": "124bfeca-24d0-411d-b4ad-26009b79436b", "question": "Word Pattern II: Given a pattern and a string s, return true if s matches the pattern.\n\nA string s matches a pattern if there is some bijective mapping of single characters to non-empty strings such that if each character in pattern is replaced by the string it maps to, then the resulting string is s. A bijective mapping means that no two characters map to the same string, and no character maps to two different strings.", "examples": "Input: pattern = \"abab\", s = \"redblueredblue\"\nOutput: true\nExplanation: One possible mapping is as follows:\n'a' -> \"red\"\n'b' -> \"blue\"\nInput: pattern = \"aabb\", s = \"xyzabcxzyabc\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern-ii/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def wordPatternMatch(pattern: str, s: str) -> bool:\n    def backtrack(cur: str, pattern: str, mappings: dict):\n        if not pattern:\n            return not cur\n        if pattern[0] in mappings:\n            if cur[:len(mappings[pattern[0]])] != mappings[pattern[0]]:\n                return False\n            return backtrack(cur[len(mappings[pattern[0]]):], pattern[1:], mappings)\n        for i in range(len(cur)):\n            if cur[:i+1] in mappings.values():\n                continue\n            mappings[pattern[0]] = cur[:i+1]\n            if backtrack(cur[i+1:], pattern[1:], mappings):\n                return True\n            del mappings[pattern[0]]\n        return False\n    return backtrack(s, pattern, {})", "asserts": ["assert wordPatternMatch(\"aaaa\", \"asdasdasdasd\")==True", "assert wordPatternMatch(\"abba\", \"dogcatcatdog\") == True", "assert wordPatternMatch(\"ab\", \"aa\") == False # since 'a' and 'b' cannot map to the same string \"a\"", "assert wordPatternMatch(\"xyz\", \"abcdefghi\") == True # 'x' -> \"a\", 'y' -> \"bc\", 'z' -> \"defghi\"", "assert wordPatternMatch(\"aba\", \"eggegg\") == False # 'a' maps to \"egg\", but 'b' cannot be mapped uniquely", "assert wordPatternMatch(\"zzz\", \"aaa\") == True # all 'z' map to \"a\"", "assert wordPatternMatch(\"aba\", \"catdogcat\") == True # 'a' -> \"cat\", 'b' -> \"dog\"", "assert wordPatternMatch(\"abab\", \"xyzxyzabcabc\") == False # cannot match 'a' and 'b' with two different strings each consistent with the pattern", "assert wordPatternMatch(\"abac\", \"xyzxyzxya\") == True # 'a' -> \"xyz\", 'b' -> \"xyz\", 'c' -> \"a\"", "assert wordPatternMatch(\"abcd\", \"xyzy\") == False # pattern too long for the string", "assert wordPatternMatch(\"aaaaa\", \"oneonetwo\") == False # not enough unique strings to map 'a' five times"]}, {"author": "Hafeez", "UUID": "8c9548d2-7b9c-46a4-9b8e-8afd488f7e87", "question": "Find and Replace Pattern: Given a list of strings words and a string pattern, return a list of words[i] that match pattern. You may return the answer in any order.\n\nA word matches the pattern if there exists a permutation of letters p so that after replacing every letter x in the pattern with p(x), we get the desired word.\n\nRecall that a permutation of letters is a bijection from letters to letters: every letter maps to another letter, and no two letters map to the same letter.", "examples": "Input: words = [\"abc\",\"deq\",\"mee\",\"aqq\",\"dkd\",\"ccc\"], pattern = \"abb\"\nOutput: [\"mee\",\"aqq\"]\nExplanation: \"mee\" matches the pattern because there is a permutation {a -> m, b -> e, ...}. \n\"ccc\" does not match the pattern because {a -> c, b -> c, ...} is not a permutation, since a and b map to the same letter.", "link": "https://leetcode.com/problems/find-and-replace-pattern/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def findAndReplacePattern(words: list, pattern: str) -> list:\n        def match(word):\n            m1, m2 = {}, {}\n            for w, p in zip(word, pattern):\n                if w not in m1: m1[w] = p\n                if p not in m2: m2[p] = w\n                if (m1[w], m2[p]) != (p, w):\n                    return False\n            return True\n\n        return list(filter(match, words))\n", "asserts": ["assert findAndReplacePattern([\"a\",\"b\",\"c\"], \"a\")==[\"a\",\"b\",\"c\"]", "assert findAndReplacePattern([\"xx\", \"xy\", \"yy\"], \"xx\") == [\"xx\", \"yy\"]", "assert findAndReplacePattern([\"abc\", \"def\", \"ghi\", \"jkl\"], \"xyz\") == [\"abc\", \"def\", \"ghi\", \"jkl\"]", "assert findAndReplacePattern([\"aaa\", \"bbb\", \"ccc\"], \"xyz\") == []"]}], "category": "Pattern", "prompt_tokens": 1081, "total_tokens": 1393, "completion_tokens": 312, "completion": "Pattern Matching: Given a pattern and a string s, determine if s follows the same pattern.\n\nA string s follows the same pattern if a one-to-one mapping exists between the characters in pattern and the words in s.\n\n###Code: \n\ndef wordPattern(pattern: str, s: str) -> bool:\n    words = s.split()\n    if len(pattern) != len(words):\n        return False\n    mapping = {}\n    reverse_mapping = {}\n    for char, word in zip(pattern, words):\n        if char not in mapping:\n            if word in reverse_mapping:\n                return False\n            mapping[char] = word\n            reverse_mapping[word] = char\n        else:\n            if mapping[char] != word:\n                return False\n    return True\n\n###Testcases: \n\nassert wordPattern(\"abba\", \"dog cat cat dog\") == True\nassert wordPattern(\"abba\", \"dog cat cat fish\") == False\nassert wordPattern(\"aaaa\", \"dog cat cat dog\") == False\nassert wordPattern(\"abba\", \"dog dog dog dog\") == False\nassert wordPattern(\"abc\", \"b c a\") == True\nassert wordPattern(\"aaa\", \"aa aa aa aa\") == False\nassert wordPattern(\"ab\", \"aa\") == False\nassert wordPattern(\"aab\", \"beef beef pork\") == False\nassert wordPattern(\"xyz\", \"apple banana orange\") == True\nassert wordPattern(\"abab\", \"red blue red blue\") == True\n\n[/Example 3]", "temperature": 0.888, "question": "Pattern Matching: Given a pattern and a string s, determine if s follows the same pattern.\n\nA string s follows the same pattern if a one-to-one mapping exists between the characters in pattern and the words in s.", "code": "def wordPattern(pattern: str, s: str) -> bool:\n    words = s.split()\n    if len(pattern) != len(words):\n        return False\n    mapping = {}\n    reverse_mapping = {}\n    for char, word in zip(pattern, words):\n        if char not in mapping:\n            if word in reverse_mapping:\n                return False\n            mapping[char] = word\n            reverse_mapping[word] = char\n        else:\n            if mapping[char] != word:\n                return False\n    return True", "asserts": ["assert wordPattern(\"abba\", \"dog cat cat dog\") == True", "assert wordPattern(\"abba\", \"dog cat cat fish\") == False", "assert wordPattern(\"aaaa\", \"dog cat cat dog\") == False", "assert wordPattern(\"abba\", \"dog dog dog dog\") == False", "assert wordPattern(\"abc\", \"b c a\") == True", "assert wordPattern(\"aaa\", \"aa aa aa aa\") == False", "assert wordPattern(\"ab\", \"aa\") == False", "assert wordPattern(\"xyz\", \"apple banana orange\") == True", "assert wordPattern(\"abab\", \"red blue red blue\") == True"], "author": "GPT", "UUID": "4a601c98-0e1b-4241-9d72-fbf42c6eea2d", "tc_status": [["assert wordPattern(\"abba\", \"dog cat cat dog\") == True", "Passed"], ["assert wordPattern(\"abba\", \"dog cat cat fish\") == False", "Passed"], ["assert wordPattern(\"aaaa\", \"dog cat cat dog\") == False", "Passed"], ["assert wordPattern(\"abba\", \"dog dog dog dog\") == False", "Passed"], ["assert wordPattern(\"abc\", \"b c a\") == True", "Passed"], ["assert wordPattern(\"aaa\", \"aa aa aa aa\") == False", "Passed"], ["assert wordPattern(\"ab\", \"aa\") == False", "Passed"], ["assert wordPattern(\"xyz\", \"apple banana orange\") == True", "Passed"], ["assert wordPattern(\"abab\", \"red blue red blue\") == True", "Passed"]]}, {"few_shots": [{"author": "Hafeez", "UUID": "124bfeca-24d0-411d-b4ad-26009b79436b", "question": "Word Pattern II: Given a pattern and a string s, return true if s matches the pattern.\n\nA string s matches a pattern if there is some bijective mapping of single characters to non-empty strings such that if each character in pattern is replaced by the string it maps to, then the resulting string is s. A bijective mapping means that no two characters map to the same string, and no character maps to two different strings.", "examples": "Input: pattern = \"abab\", s = \"redblueredblue\"\nOutput: true\nExplanation: One possible mapping is as follows:\n'a' -> \"red\"\n'b' -> \"blue\"\nInput: pattern = \"aabb\", s = \"xyzabcxzyabc\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern-ii/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def wordPatternMatch(pattern: str, s: str) -> bool:\n    def backtrack(cur: str, pattern: str, mappings: dict):\n        if not pattern:\n            return not cur\n        if pattern[0] in mappings:\n            if cur[:len(mappings[pattern[0]])] != mappings[pattern[0]]:\n                return False\n            return backtrack(cur[len(mappings[pattern[0]]):], pattern[1:], mappings)\n        for i in range(len(cur)):\n            if cur[:i+1] in mappings.values():\n                continue\n            mappings[pattern[0]] = cur[:i+1]\n            if backtrack(cur[i+1:], pattern[1:], mappings):\n                return True\n            del mappings[pattern[0]]\n        return False\n    return backtrack(s, pattern, {})", "asserts": ["assert wordPatternMatch(\"aaaa\", \"asdasdasdasd\")==True", "assert wordPatternMatch(\"abba\", \"dogcatcatdog\") == True", "assert wordPatternMatch(\"ab\", \"aa\") == False # since 'a' and 'b' cannot map to the same string \"a\"", "assert wordPatternMatch(\"xyz\", \"abcdefghi\") == True # 'x' -> \"a\", 'y' -> \"bc\", 'z' -> \"defghi\"", "assert wordPatternMatch(\"aba\", \"eggegg\") == False # 'a' maps to \"egg\", but 'b' cannot be mapped uniquely", "assert wordPatternMatch(\"zzz\", \"aaa\") == True # all 'z' map to \"a\"", "assert wordPatternMatch(\"aba\", \"catdogcat\") == True # 'a' -> \"cat\", 'b' -> \"dog\"", "assert wordPatternMatch(\"abab\", \"xyzxyzabcabc\") == False # cannot match 'a' and 'b' with two different strings each consistent with the pattern", "assert wordPatternMatch(\"abac\", \"xyzxyzxya\") == True # 'a' -> \"xyz\", 'b' -> \"xyz\", 'c' -> \"a\"", "assert wordPatternMatch(\"abcd\", \"xyzy\") == False # pattern too long for the string", "assert wordPatternMatch(\"aaaaa\", \"oneonetwo\") == False # not enough unique strings to map 'a' five times"]}, {"author": "Hafeez", "UUID": "8c9548d2-7b9c-46a4-9b8e-8afd488f7e87", "question": "Find and Replace Pattern: Given a list of strings words and a string pattern, return a list of words[i] that match pattern. You may return the answer in any order.\n\nA word matches the pattern if there exists a permutation of letters p so that after replacing every letter x in the pattern with p(x), we get the desired word.\n\nRecall that a permutation of letters is a bijection from letters to letters: every letter maps to another letter, and no two letters map to the same letter.", "examples": "Input: words = [\"abc\",\"deq\",\"mee\",\"aqq\",\"dkd\",\"ccc\"], pattern = \"abb\"\nOutput: [\"mee\",\"aqq\"]\nExplanation: \"mee\" matches the pattern because there is a permutation {a -> m, b -> e, ...}. \n\"ccc\" does not match the pattern because {a -> c, b -> c, ...} is not a permutation, since a and b map to the same letter.", "link": "https://leetcode.com/problems/find-and-replace-pattern/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def findAndReplacePattern(words: list, pattern: str) -> list:\n        def match(word):\n            m1, m2 = {}, {}\n            for w, p in zip(word, pattern):\n                if w not in m1: m1[w] = p\n                if p not in m2: m2[p] = w\n                if (m1[w], m2[p]) != (p, w):\n                    return False\n            return True\n\n        return list(filter(match, words))\n", "asserts": ["assert findAndReplacePattern([\"a\",\"b\",\"c\"], \"a\")==[\"a\",\"b\",\"c\"]", "assert findAndReplacePattern([\"xx\", \"xy\", \"yy\"], \"xx\") == [\"xx\", \"yy\"]", "assert findAndReplacePattern([\"abc\", \"def\", \"ghi\", \"jkl\"], \"xyz\") == [\"abc\", \"def\", \"ghi\", \"jkl\"]", "assert findAndReplacePattern([\"aaa\", \"bbb\", \"ccc\"], \"xyz\") == []"]}], "category": "Pattern", "prompt_tokens": 1081, "total_tokens": 1349, "completion_tokens": 268, "completion": "Decode String: Given an encoded string, return its decoded string.\n\nThe encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is being repeated exactly k times. Note that k is guaranteed to be a positive integer.\n\nYou may assume that the input string is always valid; no extra white spaces, square brackets are well-formed, etc.\n\n###Code: \n\ndef decodeString(s: str) -> str:\n    stack = []\n    stack.append([\"\", 1])\n    num = \"\"\n    for ch in s:\n        if ch.isdigit():\n            num += ch\n        elif ch == \"[\":\n            stack.append([\"\", int(num)])\n            num = \"\"\n        elif ch == \"]\":\n            st, k = stack.pop()\n            stack[-1][0] += st * k\n        else:\n            stack[-1][0] += ch\n    return stack[0][0]\n\n\n###Testcases: \n\nassert decodeString(\"3[a]2[bc]\") == \"aaabcbc\"\nassert decodeString(\"3[a2[c]]\") == \"accaccacc\"\nassert decodeString(\"2[abc]3[cd]ef\") == \"abcabccdcdcdef\"\nassert decodeString(\"abc3[cd]xyz\") == \"abccdcdcdxyz\"\n\n[/Example 3]", "temperature": 0.716, "question": "Decode String: Given an encoded string, return its decoded string.\n\nThe encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is being repeated exactly k times. Note that k is guaranteed to be a positive integer.\n\nYou may assume that the input string is always valid; no extra white spaces, square brackets are well-formed, etc.", "code": "def decodeString(s: str) -> str:\n    stack = []\n    stack.append([\"\", 1])\n    num = \"\"\n    for ch in s:\n        if ch.isdigit():\n            num += ch\n        elif ch == \"[\":\n            stack.append([\"\", int(num)])\n            num = \"\"\n        elif ch == \"]\":\n            st, k = stack.pop()\n            stack[-1][0] += st * k\n        else:\n            stack[-1][0] += ch\n    return stack[0][0]", "asserts": ["assert decodeString(\"3[a]2[bc]\") == \"aaabcbc\"", "assert decodeString(\"3[a2[c]]\") == \"accaccacc\"", "assert decodeString(\"2[abc]3[cd]ef\") == \"abcabccdcdcdef\"", "assert decodeString(\"abc3[cd]xyz\") == \"abccdcdcdxyz\""], "author": "GPT", "UUID": "663ac969-0a9f-4085-bbcb-ad54b1f9ebfd", "tc_status": [["assert decodeString(\"3[a]2[bc]\") == \"aaabcbc\"", "Passed"], ["assert decodeString(\"3[a2[c]]\") == \"accaccacc\"", "Passed"], ["assert decodeString(\"2[abc]3[cd]ef\") == \"abcabccdcdcdef\"", "Passed"], ["assert decodeString(\"abc3[cd]xyz\") == \"abccdcdcdxyz\"", "Passed"]]}, {"author": "Hafeez", "UUID": "effcb732-1f0d-4caa-8d9f-be914708d4ae", "question": "Repeated Substring Pattern: Given a string s, check if it can be constructed by taking a substring of it and appending multiple copies of the substring together.", "examples": "Input: s = \"aba\"\nOutput: false\nExplanation: It is the substring \"ab\" twice.\nInput: s = \"abcabcabcabc\"\nOutput: true\nExplanation: It is the substring \"abc\" four times or the substring \"abcabc\" twice.", "link": "https://leetcode.com/problems/repeated-substring-pattern/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def repeatedSubstringPattern(s: str) -> bool:\n    n = len(s)\n    for i in range(1, n // 2 + 1):\n        if n % i == 0:\n            pattern = s[:i] * (n // i)\n            if s == pattern:\n                return True\n    return False", "asserts": ["assert repeatedSubstringPattern(\"abab\")==True", "assert repeatedSubstringPattern(\"aaaa\") == True", "assert repeatedSubstringPattern(\"abac\") == False", "assert repeatedSubstringPattern(\"ababab\") == True", "assert repeatedSubstringPattern(\"xyzxyzxyz\") == True", "assert repeatedSubstringPattern(\"aaabaaa\") == False", "assert repeatedSubstringPattern(\"abababab\") == True", "assert repeatedSubstringPattern(\"abcabcab\") == False", "assert repeatedSubstringPattern(\"abbaabba\") == True", "assert repeatedSubstringPattern(\"\") == False", "assert repeatedSubstringPattern(\"a\") == False", "assert repeatedSubstringPattern(\"abacababacab\") == True"], "category": "Pattern"}, {"author": "Hafeez", "UUID": "e811f9cc-fa5e-4ea0-8adb-8cf3ab7c72db", "question": "Detect Pattern of Length M Repeated K or More Times: Given an array of positive integers arr, find a pattern of length m that is repeated k or more times.\n\nA pattern is a subarray (consecutive sub-sequence) that consists of one or more values, repeated multiple times consecutively without overlapping. A pattern is defined by its length and the number of repetitions.\n\nReturn true if there exists a pattern of length m that is repeated k or more times, otherwise return false.", "examples": "Input: arr = [1,2,1,2,1,1,1,3], m = 2, k = 2\nOutput: true\nExplanation: The pattern (1,2) of length 2 is repeated 2 consecutive times. Another valid pattern (2,1) is also repeated 2 times.\nInput: arr = [1,2,1,2,1,3], m = 2, k = 3\nOutput: false\nExplanation: The pattern (1,2) is of length 2 but is repeated only 2 times. There is no pattern of length 2 that is repeated 3 or more times.\n", "link": "https://leetcode.com/problems/detect-pattern-of-length-m-repeated-k-or-more-times/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "from typing import List\ndef containsPattern(arr: List[int], m: int, k: int) -> bool:\n    i = 0\n    while i <= len(arr)-1:\n            p = arr[i:i+m]\n            if p * k == arr[i:i+m*k]:\n                    return True\n            i += 1\n    return False", "asserts": ["assert containsPattern([1,2,4,4,4,4],1,3)==True", "assert containsPattern([1,2,3,1,2,3,1,2,3], 3, 3) == True", "assert containsPattern([1,1,1,2,2,2,3,3], 2, 2) == False", "assert containsPattern([5,5,5,5,5,5,5], 1, 6) == True", "assert containsPattern([1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2], 2, 5) == True", "assert containsPattern([10,100,10,100,10,100,10,10,10,100], 2, 4) == False", "assert containsPattern([3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3], 4, 3) == True"], "category": "Pattern"}, {"author": "Hafeez", "UUID": "df98fd29-db88-4de7-a00a-0a3bd5ba1539", "question": "Word Pattern: Given a pattern and a string s, find if s follows the same pattern.\n\nHere follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in s.", "examples": "Input: pattern = \"abba\", s = \"dog cat cat fish\"\nOutput: false\nInput: pattern = \"aaaa\", s = \"dog cat cat dog\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def wordPattern(pattern: str, s: str) -> bool:\n    map_char = {}\n    map_word = {}\n    \n    words = s.split(' ')\n    if len(words) != len(pattern):\n        return False\n    \n    for c, w in zip(pattern, words):\n        if c not in map_char:\n            if w in map_word:\n                return False\n            else:\n                map_char[c] = w\n                map_word[w] = c\n        else:\n            if map_char[c] != w:\n                return False\n    return True", "asserts": ["assert wordPattern(\"abba\", \"dog cat cat dog\")==True", "assert wordPattern(\"aaaa\", \"dog dog dog dog\") == True", "assert wordPattern(\"xyz\", \"apple banana apple\") == False", "assert wordPattern(\"xyx\", \"apple banana apple\") == True", "assert wordPattern(\"abab\", \"dog cat dog cat\") == True", "assert wordPattern(\"aaaa\", \"dog dog dog cat\") == False", "assert wordPattern(\"aabb\", \"dog dog cat cat\") == True", "assert wordPattern(\"abc\", \"dog\") == False  # Not enough words", "assert wordPattern(\"\", \"dog cat\") == False  # Empty pattern", "assert wordPattern(\"a\", \"dog cat dog cat\") == False  # Not enough pattern characters", "assert wordPattern(\"ab\", \"\") == False  # Empty string", "assert wordPattern(\"abb\", \"dog dog dog\") == False  # Same word for different pattern characters", "assert wordPattern(\"abba\", \"dog cat cat\") == False  # Not enough words for the pattern", "assert wordPattern(\"abba\", \"dog cat cat dog fish\") == False  # Extra words beyond the pattern length"], "category": "Pattern"}, {"author": "Hafeez", "UUID": "8c9548d2-7b9c-46a4-9b8e-8afd488f7e87", "question": "Find and Replace Pattern: Given a list of strings words and a string pattern, return a list of words[i] that match pattern. You may return the answer in any order.\n\nA word matches the pattern if there exists a permutation of letters p so that after replacing every letter x in the pattern with p(x), we get the desired word.\n\nRecall that a permutation of letters is a bijection from letters to letters: every letter maps to another letter, and no two letters map to the same letter.", "examples": "Input: words = [\"abc\",\"deq\",\"mee\",\"aqq\",\"dkd\",\"ccc\"], pattern = \"abb\"\nOutput: [\"mee\",\"aqq\"]\nExplanation: \"mee\" matches the pattern because there is a permutation {a -> m, b -> e, ...}. \n\"ccc\" does not match the pattern because {a -> c, b -> c, ...} is not a permutation, since a and b map to the same letter.", "link": "https://leetcode.com/problems/find-and-replace-pattern/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def findAndReplacePattern(words: list, pattern: str) -> list:\n        def match(word):\n            m1, m2 = {}, {}\n            for w, p in zip(word, pattern):\n                if w not in m1: m1[w] = p\n                if p not in m2: m2[p] = w\n                if (m1[w], m2[p]) != (p, w):\n                    return False\n            return True\n\n        return list(filter(match, words))\n", "asserts": ["assert findAndReplacePattern([\"a\",\"b\",\"c\"], \"a\")==[\"a\",\"b\",\"c\"]", "assert findAndReplacePattern([\"xx\", \"xy\", \"yy\"], \"xx\") == [\"xx\", \"yy\"]", "assert findAndReplacePattern([\"abc\", \"def\", \"ghi\", \"jkl\"], \"xyz\") == [\"abc\", \"def\", \"ghi\", \"jkl\"]", "assert findAndReplacePattern([\"aaa\", \"bbb\", \"ccc\"], \"xyz\") == []"], "category": "Pattern"}, {"author": "Hafeez", "UUID": "124bfeca-24d0-411d-b4ad-26009b79436b", "question": "Word Pattern II: Given a pattern and a string s, return true if s matches the pattern.\n\nA string s matches a pattern if there is some bijective mapping of single characters to non-empty strings such that if each character in pattern is replaced by the string it maps to, then the resulting string is s. A bijective mapping means that no two characters map to the same string, and no character maps to two different strings.", "examples": "Input: pattern = \"abab\", s = \"redblueredblue\"\nOutput: true\nExplanation: One possible mapping is as follows:\n'a' -> \"red\"\n'b' -> \"blue\"\nInput: pattern = \"aabb\", s = \"xyzabcxzyabc\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern-ii/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def wordPatternMatch(pattern: str, s: str) -> bool:\n    def backtrack(cur: str, pattern: str, mappings: dict):\n        if not pattern:\n            return not cur\n        if pattern[0] in mappings:\n            if cur[:len(mappings[pattern[0]])] != mappings[pattern[0]]:\n                return False\n            return backtrack(cur[len(mappings[pattern[0]]):], pattern[1:], mappings)\n        for i in range(len(cur)):\n            if cur[:i+1] in mappings.values():\n                continue\n            mappings[pattern[0]] = cur[:i+1]\n            if backtrack(cur[i+1:], pattern[1:], mappings):\n                return True\n            del mappings[pattern[0]]\n        return False\n    return backtrack(s, pattern, {})", "asserts": ["assert wordPatternMatch(\"aaaa\", \"asdasdasdasd\")==True", "assert wordPatternMatch(\"abba\", \"dogcatcatdog\") == True", "assert wordPatternMatch(\"ab\", \"aa\") == False # since 'a' and 'b' cannot map to the same string \"a\"", "assert wordPatternMatch(\"xyz\", \"abcdefghi\") == True # 'x' -> \"a\", 'y' -> \"bc\", 'z' -> \"defghi\"", "assert wordPatternMatch(\"aba\", \"eggegg\") == False # 'a' maps to \"egg\", but 'b' cannot be mapped uniquely", "assert wordPatternMatch(\"zzz\", \"aaa\") == True # all 'z' map to \"a\"", "assert wordPatternMatch(\"aba\", \"catdogcat\") == True # 'a' -> \"cat\", 'b' -> \"dog\"", "assert wordPatternMatch(\"abab\", \"xyzxyzabcabc\") == False # cannot match 'a' and 'b' with two different strings each consistent with the pattern", "assert wordPatternMatch(\"abac\", \"xyzxyzxya\") == True # 'a' -> \"xyz\", 'b' -> \"xyz\", 'c' -> \"a\"", "assert wordPatternMatch(\"abcd\", \"xyzy\") == False # pattern too long for the string", "assert wordPatternMatch(\"aaaaa\", \"oneonetwo\") == False # not enough unique strings to map 'a' five times"], "category": "Pattern"}], "String": [{"few_shots": [{"author": "Calvin", "UUID": "ac641352-08d5-4950-8993-6a143da92ecf", "question": "You are given a string s and an integer k. You can choose one of the first k letters of s and append it at the end of the string.\n\nReturn the lexicographically smallest string you could have after applying the mentioned step any number of moves.\n", "examples": "Input: s = \"cba\", k = 1\nOutput: \"acb\"\n\nInput: s = \"baaca\", k = 3\nOutput: \"aaabc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef orderlyQueue(s: str, k: int) -> str:\n    if k == 1:\n        n = len(s)\n        ss = s + s\n        lex_min_str = s\n        for i in range(n):\n            lex_min_str = min(lex_min_str, ss[i:i + n])\n        return lex_min_str\n    \n    return \"\".join(sorted(s))\n", "asserts": ["assert orderlyQueue(\"abcd\", 1) == \"abcd\"", "assert orderlyQueue(\"hello\", 2) == \"ehllo\"", "assert orderlyQueue(\"programming\", 1) == \"ammingprogr\"", "assert orderlyQueue(\"rotator\", 1) == \"atorrot\"", "assert orderlyQueue(\"zxyabc\", 5) == \"abcxyz\"", "assert orderlyQueue(\"xy\", 2) == \"xy\""]}, {"author": "Calvin", "UUID": "d0ce7430-cfcd-4c69-b161-b3b2a186422c", "question": "Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.\n\nIn other words, return true if one of s1's permutations is the substring of s2.", "examples": "Input: s1 = \"ab\", s2 = \"eidbaooo\"\nOutput: True\n\nInput: s1 = \"ab\", s2 = \"eidboaoo\"\nOutput: False", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef permutation_in_string(s1: str, s2: str) -> bool:\n  window = len(s1)\n  if window > len(s2):\n    return False\n  freq1 = [0]*26\n  freq2 = [0]*26\n  for i in range(window):\n    freq1[ord(s1[i])-ord('a')] += 1\n    freq2[ord(s2[i])-ord('a')] += 1\n\n  matches = 0\n  for i in range(26):\n    if freq1[i] == freq2[i]:\n      matches += 1\n  \n  for l in range(len(s2) - window):\n    if matches == 26:\n      return True\n\n    added = ord(s2[l + window]) - ord('a')\n    freq2[added] += 1\n    if freq1[added] == freq2[added]:\n      matches += 1\n    elif freq1[added] + 1 == freq2[added]:\n      matches -= 1\n\n    removed = ord(s2[l]) - ord('a')\n    freq2[removed] -= 1\n    if freq1[removed] == freq2[removed]:\n      matches += 1\n    elif freq1[removed] == freq2[removed] + 1:\n      matches -= 1\n    \n  return matches == 26\n", "asserts": ["assert permutation_in_string(\"hello\", \"ooollehhhhh\") == True", "assert permutation_in_string(\"abc\", \"ccccbbbbaaaa\") == False", "assert permutation_in_string(\"xyz\", \"zxyopqrstuv\") == True", "assert permutation_in_string(\"xyz\", \"xzygxzyzxyzk\") == True", "assert permutation_in_string(\"a\", \"a\") == True", "assert permutation_in_string(\"adc\", \"dcda\") == True", "assert permutation_in_string(\"pq\", \"qpqqp\") == True", "assert permutation_in_string(\"kitten\", \"sittingkite\") == False", "assert permutation_in_string(\"pq\", \"pqpqr\") == True", "assert permutation_in_string(\"aba\", \"aabaabaa\") == True", "assert permutation_in_string(\"\", \"\") == True  # Edge case: both strings are empty", "assert permutation_in_string(\"longerstring\", \"short\") == False  # s1 is longer than s2", "assert permutation_in_string(\"a\", \"b\") == False  # Single character, no match", "assert permutation_in_string(\"aab\", \"baa\") == True  # s1 is a permutation of s2", "assert permutation_in_string(\"ab\", \"a\") == False  # s2 is shorter than s1", "assert permutation_in_string(\"ba\", \"eidbaooo\") == True  # Same characters as Example 1 but different permutation", "assert permutation_in_string(\"eid\", \"eidbaooo\") == True  # s1 is a prefix of s2", "assert permutation_in_string(\"ooo\", \"eidbaooo\") == True  # s1 is a suffix of s2", "assert permutation_in_string(\"db\", \"eidbaooo\") == True  # s1 is a permutation within s2", "assert permutation_in_string(\"eidoo\", \"eidbaooo\") == False  # s1 is longer than any permutation within s2"]}], "category": "String", "prompt_tokens": 1159, "total_tokens": 1462, "completion_tokens": 303, "completion": "Create a function that takes a string and returns a new string with its first and last characters swapped, except when:\n\n- The length of the string is less than two, in which case, return the original string.\n- The string is empty, return an empty string.\n\n###Code: \n\n```python\ndef swap_end_chars(s: str) -> str:\n    if len(s) < 2:\n        return s\n    return s[-1] + s[1:-1] + s[0]\n```\n\n###Testcases: \n\n```python\nassert swap_end_chars(\"hello\") == \"oellh\"\nassert swap_end_chars(\"a\") == \"a\"\nassert swap_end_chars(\"ab\") == \"ba\"\nassert swap_end_chars(\"\") == \"\"\nassert swap_end_chars(\"it\") == \"ti\"\nassert swap_end_chars(\"sweep\") == \"pwees\"\nassert swap_end_chars(\"Python\") == \"nythoP\"\nassert swap_end_chars(\"12345\") == \"52341\"\nassert swap_end_chars(\"xy\") == \"yx\"\nassert swap_end_chars(\"coding\") == \"gondic\"\nassert swap_end_chars(\"x\") == \"x\"\nassert swap_end_chars(\"stronger\") == \"rtronges\"\nassert swap_end_chars(\"algorithm\") == \"mlgoritha\"\nassert swap_end_chars(\"example\") == \"exampel\"\nassert swap_end_chars(\"switch\") == \"hwtcis\"\n```\n\n[/Example 3]", "temperature": 0.657, "question": "Create a function that takes a string and returns a new string with its first and last characters swapped, except when:\n\n- The length of the string is less than two, in which case, return the original string.\n- The string is empty, return an empty string.", "code": "def swap_end_chars(s: str) -> str:\n    if len(s) < 2:\n        return s\n    return s[-1] + s[1:-1] + s[0]", "asserts": ["assert swap_end_chars(\"hello\") == \"oellh\"", "assert swap_end_chars(\"a\") == \"a\"", "assert swap_end_chars(\"ab\") == \"ba\"", "assert swap_end_chars(\"\") == \"\"", "assert swap_end_chars(\"it\") == \"ti\"", "assert swap_end_chars(\"sweep\") == \"pwees\"", "assert swap_end_chars(\"Python\") == \"nythoP\"", "assert swap_end_chars(\"12345\") == \"52341\"", "assert swap_end_chars(\"xy\") == \"yx\"", "assert swap_end_chars(\"x\") == \"x\"", "assert swap_end_chars(\"stronger\") == \"rtronges\"", "assert swap_end_chars(\"algorithm\") == \"mlgoritha\""], "author": "GPT", "UUID": "6abb4061-ca1a-4a57-a93a-dd2d94274820", "tc_status": [["assert swap_end_chars(\"hello\") == \"oellh\"", "Passed"], ["assert swap_end_chars(\"a\") == \"a\"", "Passed"], ["assert swap_end_chars(\"ab\") == \"ba\"", "Passed"], ["assert swap_end_chars(\"\") == \"\"", "Passed"], ["assert swap_end_chars(\"it\") == \"ti\"", "Passed"], ["assert swap_end_chars(\"sweep\") == \"pwees\"", "Passed"], ["assert swap_end_chars(\"Python\") == \"nythoP\"", "Passed"], ["assert swap_end_chars(\"12345\") == \"52341\"", "Passed"], ["assert swap_end_chars(\"xy\") == \"yx\"", "Passed"], ["assert swap_end_chars(\"x\") == \"x\"", "Passed"], ["assert swap_end_chars(\"stronger\") == \"rtronges\"", "Passed"], ["assert swap_end_chars(\"algorithm\") == \"mlgoritha\"", "Passed"]]}, {"few_shots": [{"author": "Calvin", "UUID": "ac641352-08d5-4950-8993-6a143da92ecf", "question": "You are given a string s and an integer k. You can choose one of the first k letters of s and append it at the end of the string.\n\nReturn the lexicographically smallest string you could have after applying the mentioned step any number of moves.\n", "examples": "Input: s = \"cba\", k = 1\nOutput: \"acb\"\n\nInput: s = \"baaca\", k = 3\nOutput: \"aaabc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef orderlyQueue(s: str, k: int) -> str:\n    if k == 1:\n        n = len(s)\n        ss = s + s\n        lex_min_str = s\n        for i in range(n):\n            lex_min_str = min(lex_min_str, ss[i:i + n])\n        return lex_min_str\n    \n    return \"\".join(sorted(s))\n", "asserts": ["assert orderlyQueue(\"abcd\", 1) == \"abcd\"", "assert orderlyQueue(\"hello\", 2) == \"ehllo\"", "assert orderlyQueue(\"programming\", 1) == \"ammingprogr\"", "assert orderlyQueue(\"rotator\", 1) == \"atorrot\"", "assert orderlyQueue(\"zxyabc\", 5) == \"abcxyz\"", "assert orderlyQueue(\"xy\", 2) == \"xy\""]}, {"author": "Calvin", "UUID": "87372a22-f5ef-4100-845b-28700ca3fde3", "question": "You are given a string s and an integer array indices of the same length. The string s will be shuffled such that the character at the ith position moves to indices[i] in the shuffled string.\n\nReturn the shuffled string.", "examples": "Input: s = \"codeleet\", indices = [4,5,6,7,0,2,1,3]\nOutput: \"leetcode\"\n\nInput: s = \"abc\", indices = [0,1,2]\nOutput: \"abc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "from typing import List\ndef shuffle_string(s: str, indices: List[int]) -> str:\n    def partitionString(s):\n      substrings = 1\n      cur_str = set()\n      for i in range(len(s)):\n        if s[i] in cur_str:\n          substrings += 1\n          cur_str = {s[i]}\n        else:\n          cur_str.add(s[i])\n      return substrings\n    ret = ['_']*len(s)\n    for idx, i in enumerate(indices):\n        ret[i] = s[idx]\n    return \"\".join(ret)\n", "asserts": ["assert shuffle_string(\"reoc\", [2, 0, 1, 3]) == \"eorc\"", "assert shuffle_string(\"aiohn\", [3,1,4,2,0]) == \"nihao\"", "assert shuffle_string(\"aax\", [0,2,1]) == \"axa\"", "assert shuffle_string(\"gh\", [1,0]) == \"hg\"", "assert shuffle_string(\"\", []) == \"\"  # Edge case: empty string", "assert shuffle_string(\"xy\", [0,1]) == \"xy\"  # No shuffle required", "assert shuffle_string(\"pqrstuvwxyzabcdefghijklmno\", list(range(25, -1, -1))) == \"onmlkjihgfedcbazyxwvutsrqp\"  # Reverse shuffle"]}], "category": "String", "prompt_tokens": 755, "total_tokens": 1051, "completion_tokens": 296, "completion": "You need to write a function that accepts a string and returns a new string with each character followed by the number of times it appears consecutively in the string. \n\n###Code:\n\ndef encode_consecutive_chars(s: str) -> str:\n    if not s:\n        return \"\"\n    \n    result = []\n    count = 1\n    for i in range(1, len(s)):\n        if s[i] == s[i-1]:\n            count += 1\n        else:\n            result.append(s[i-1] + str(count))\n            count = 1\n    result.append(s[-1] + str(count))\n    \n    return \"\".join(result)\n\n###Testcases:\n\nassert encode_consecutive_chars(\"aaabbcaaad\") == \"a3b2c1a3d1\"\nassert encode_consecutive_chars(\"hhhhhhhhhhh\") == \"h11\"\nassert encode_consecutive_chars(\"ab\") == \"a1b1\"\nassert encode_consecutive_chars(\"a\") == \"a1\"\nassert encode_consecutive_chars(\"\") == \"\"  # Edge case: empty string\nassert encode_consecutive_chars(\"aabba\") == \"a2b2a1\"\nassert encode_consecutive_chars(\"abcd\") == \"a1b1c1d1\"  # No consecutive characters\nassert encode_consecutive_chars(\"aaAAaa\") == \"a2A2a2\"  # Case-sensitive\n\n[/Example 3]", "temperature": 0.816, "question": "You need to write a function that accepts a string and returns a new string with each character followed by the number of times it appears consecutively in the string.", "code": "def encode_consecutive_chars(s: str) -> str:\n    if not s:\n        return \"\"\n    \n    result = []\n    count = 1\n    for i in range(1, len(s)):\n        if s[i] == s[i-1]:\n            count += 1\n        else:\n            result.append(s[i-1] + str(count))\n            count = 1\n    result.append(s[-1] + str(count))\n    \n    return \"\".join(result)", "asserts": ["assert encode_consecutive_chars(\"aaabbcaaad\") == \"a3b2c1a3d1\"", "assert encode_consecutive_chars(\"hhhhhhhhhhh\") == \"h11\"", "assert encode_consecutive_chars(\"ab\") == \"a1b1\"", "assert encode_consecutive_chars(\"a\") == \"a1\"", "assert encode_consecutive_chars(\"\") == \"\"  # Edge case: empty string", "assert encode_consecutive_chars(\"aabba\") == \"a2b2a1\"", "assert encode_consecutive_chars(\"abcd\") == \"a1b1c1d1\"  # No consecutive characters", "assert encode_consecutive_chars(\"aaAAaa\") == \"a2A2a2\"  # Case-sensitive"], "author": "GPT", "UUID": "f35c950b-3695-4d57-8df5-b5ab262feee4", "tc_status": [["assert encode_consecutive_chars(\"aaabbcaaad\") == \"a3b2c1a3d1\"", "Passed"], ["assert encode_consecutive_chars(\"hhhhhhhhhhh\") == \"h11\"", "Passed"], ["assert encode_consecutive_chars(\"ab\") == \"a1b1\"", "Passed"], ["assert encode_consecutive_chars(\"a\") == \"a1\"", "Passed"], ["assert encode_consecutive_chars(\"\") == \"\"  # Edge case: empty string", "Passed"], ["assert encode_consecutive_chars(\"aabba\") == \"a2b2a1\"", "Passed"], ["assert encode_consecutive_chars(\"abcd\") == \"a1b1c1d1\"  # No consecutive characters", "Passed"], ["assert encode_consecutive_chars(\"aaAAaa\") == \"a2A2a2\"  # Case-sensitive", "Passed"]]}, {"few_shots": [{"author": "Calvin", "UUID": "ac641352-08d5-4950-8993-6a143da92ecf", "question": "You are given a string s and an integer k. You can choose one of the first k letters of s and append it at the end of the string.\n\nReturn the lexicographically smallest string you could have after applying the mentioned step any number of moves.\n", "examples": "Input: s = \"cba\", k = 1\nOutput: \"acb\"\n\nInput: s = \"baaca\", k = 3\nOutput: \"aaabc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef orderlyQueue(s: str, k: int) -> str:\n    if k == 1:\n        n = len(s)\n        ss = s + s\n        lex_min_str = s\n        for i in range(n):\n            lex_min_str = min(lex_min_str, ss[i:i + n])\n        return lex_min_str\n    \n    return \"\".join(sorted(s))\n", "asserts": ["assert orderlyQueue(\"abcd\", 1) == \"abcd\"", "assert orderlyQueue(\"hello\", 2) == \"ehllo\"", "assert orderlyQueue(\"programming\", 1) == \"ammingprogr\"", "assert orderlyQueue(\"rotator\", 1) == \"atorrot\"", "assert orderlyQueue(\"zxyabc\", 5) == \"abcxyz\"", "assert orderlyQueue(\"xy\", 2) == \"xy\""]}, {"author": "Calvin", "UUID": "87372a22-f5ef-4100-845b-28700ca3fde3", "question": "You are given a string s and an integer array indices of the same length. The string s will be shuffled such that the character at the ith position moves to indices[i] in the shuffled string.\n\nReturn the shuffled string.", "examples": "Input: s = \"codeleet\", indices = [4,5,6,7,0,2,1,3]\nOutput: \"leetcode\"\n\nInput: s = \"abc\", indices = [0,1,2]\nOutput: \"abc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "from typing import List\ndef shuffle_string(s: str, indices: List[int]) -> str:\n    def partitionString(s):\n      substrings = 1\n      cur_str = set()\n      for i in range(len(s)):\n        if s[i] in cur_str:\n          substrings += 1\n          cur_str = {s[i]}\n        else:\n          cur_str.add(s[i])\n      return substrings\n    ret = ['_']*len(s)\n    for idx, i in enumerate(indices):\n        ret[i] = s[idx]\n    return \"\".join(ret)\n", "asserts": ["assert shuffle_string(\"reoc\", [2, 0, 1, 3]) == \"eorc\"", "assert shuffle_string(\"aiohn\", [3,1,4,2,0]) == \"nihao\"", "assert shuffle_string(\"aax\", [0,2,1]) == \"axa\"", "assert shuffle_string(\"gh\", [1,0]) == \"hg\"", "assert shuffle_string(\"\", []) == \"\"  # Edge case: empty string", "assert shuffle_string(\"xy\", [0,1]) == \"xy\"  # No shuffle required", "assert shuffle_string(\"pqrstuvwxyzabcdefghijklmno\", list(range(25, -1, -1))) == \"onmlkjihgfedcbazyxwvutsrqp\"  # Reverse shuffle"]}], "category": "String", "prompt_tokens": 755, "total_tokens": 1038, "completion_tokens": 283, "completion": "You have a string s and an integer n. Write a function to rotate the string to the right by n characters.\n\nIf n is greater than the length of the string, the rotation should work as if the string were repeated end to end as many times as needed to achieve the desired length.\n\nReturn the rotated string.\n\n###Code: \n\ndef rotate_string(s: str, n: int) -> str:\n    if not s:\n        return s\n    n = n % len(s)  # Handle the case where n is greater than the length of s\n    return s[-n:] + s[:-n]\n\n\n###Testcases: \n\nassert rotate_string(\"helloworld\", 2) == \"ldhellowor\"\nassert rotate_string(\"abcdef\", 1) == \"fabcde\"\nassert rotate_string(\"rotation\", 4) == \"tionrota\"\nassert rotate_string(\"abc\", 3) == \"abc\"  # Full rotation (no change)\nassert rotate_string(\"abc\", 6) == \"abc\"  # Full rotation twice (no change)\nassert rotate_string(\"\", 5) == \"\"  # Edge case: empty string\nassert rotate_string(\"xy\", 5) == \"yx\"  # Rotation longer than string length\nassert rotate_string(\"abcdefg\", 0) == \"abcdefg\"  # No rotation\n\n[/Example 3]", "temperature": 0.822, "question": "You have a string s and an integer n. Write a function to rotate the string to the right by n characters.\n\nIf n is greater than the length of the string, the rotation should work as if the string were repeated end to end as many times as needed to achieve the desired length.\n\nReturn the rotated string.", "code": "def rotate_string(s: str, n: int) -> str:\n    if not s:\n        return s\n    n = n % len(s)  # Handle the case where n is greater than the length of s\n    return s[-n:] + s[:-n]", "asserts": ["assert rotate_string(\"helloworld\", 2) == \"ldhellowor\"", "assert rotate_string(\"abcdef\", 1) == \"fabcde\"", "assert rotate_string(\"rotation\", 4) == \"tionrota\"", "assert rotate_string(\"abc\", 3) == \"abc\"  # Full rotation (no change)", "assert rotate_string(\"abc\", 6) == \"abc\"  # Full rotation twice (no change)", "assert rotate_string(\"\", 5) == \"\"  # Edge case: empty string", "assert rotate_string(\"xy\", 5) == \"yx\"  # Rotation longer than string length", "assert rotate_string(\"abcdefg\", 0) == \"abcdefg\"  # No rotation"], "author": "GPT", "UUID": "53c89385-ed4a-4480-b475-98657e4456df", "tc_status": [["assert rotate_string(\"helloworld\", 2) == \"ldhellowor\"", "Passed"], ["assert rotate_string(\"abcdef\", 1) == \"fabcde\"", "Passed"], ["assert rotate_string(\"rotation\", 4) == \"tionrota\"", "Passed"], ["assert rotate_string(\"abc\", 3) == \"abc\"  # Full rotation (no change)", "Passed"], ["assert rotate_string(\"abc\", 6) == \"abc\"  # Full rotation twice (no change)", "Passed"], ["assert rotate_string(\"\", 5) == \"\"  # Edge case: empty string", "Passed"], ["assert rotate_string(\"xy\", 5) == \"yx\"  # Rotation longer than string length", "Passed"], ["assert rotate_string(\"abcdefg\", 0) == \"abcdefg\"  # No rotation", "Passed"]]}, {"few_shots": [{"author": "Calvin", "UUID": "80e34b28-16a8-46ac-8b6a-ee28beb1e8d4", "question": "Write a function that reverses a string. The input string is given as an array of characters s.\n\nYou must do this by modifying the input array in-place with O(1) extra memory.", "examples": "Input: [\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput: [\"o\",\"l\",\"l\",\"e\",\"h\"]\n\nInput: [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\nOutput: [\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def reverse_string(s: list) -> list:\n  l = 0\n  r = len(s) - 1\n  while l < r:\n    tmp = s[l]\n    s[l] = s[r]\n    s[r] = tmp\n    l += 1\n    r -= 1\n  return s\n", "asserts": ["assert reverse_string([\"a\",\"b\",\"c\",\"d\"]) == [\"d\", \"c\", \"b\", \"a\"]", "assert reverse_string([\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"]) == [\"n\", \"o\", \"h\", \"t\", \"y\", \"p\"]", "assert reverse_string([]) == []", "assert reverse_string([\"s\", \"i\", \"n\", \"g\", \"l\", \"e\"]) == [\"e\", \"l\", \"g\", \"n\", \"i\", \"s\"]", "assert reverse_string([\"A\"]) == [\"A\"]", "assert reverse_string([\"9\", \"8\", \"7\", \"6\", \"5\", \"4\", \"3\", \"2\", \"1\"]) == [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]", "assert reverse_string([\"B\", \"o\", \"b\"]) == [\"b\", \"o\", \"B\"]", "assert reverse_string([\"r\", \"e\", \"v\", \"e\", \"r\", \"s\", \"e\"]) == [\"e\", \"s\", \"r\", \"e\", \"v\", \"e\", \"r\"]", "assert reverse_string([\"1\", \"*\", \"2\", \"*\", \"3\"]) == [\"3\", \"*\", \"2\", \"*\", \"1\"]"]}, {"author": "Calvin", "UUID": "ac641352-08d5-4950-8993-6a143da92ecf", "question": "You are given a string s and an integer k. You can choose one of the first k letters of s and append it at the end of the string.\n\nReturn the lexicographically smallest string you could have after applying the mentioned step any number of moves.\n", "examples": "Input: s = \"cba\", k = 1\nOutput: \"acb\"\n\nInput: s = \"baaca\", k = 3\nOutput: \"aaabc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef orderlyQueue(s: str, k: int) -> str:\n    if k == 1:\n        n = len(s)\n        ss = s + s\n        lex_min_str = s\n        for i in range(n):\n            lex_min_str = min(lex_min_str, ss[i:i + n])\n        return lex_min_str\n    \n    return \"\".join(sorted(s))\n", "asserts": ["assert orderlyQueue(\"abcd\", 1) == \"abcd\"", "assert orderlyQueue(\"hello\", 2) == \"ehllo\"", "assert orderlyQueue(\"programming\", 1) == \"ammingprogr\"", "assert orderlyQueue(\"rotator\", 1) == \"atorrot\"", "assert orderlyQueue(\"zxyabc\", 5) == \"abcxyz\"", "assert orderlyQueue(\"xy\", 2) == \"xy\""]}], "category": "String", "prompt_tokens": 814, "total_tokens": 1100, "completion_tokens": 286, "completion": "Implement a function that transforms a sentence by reversing the characters of each word without reversing the word order itself.\n\n###Code: \n\ndef reverse_words_in_sentence(sentence: str) -> str:\n    words = sentence.split()\n    reversed_words = [word[::-1] for word in words]\n    reversed_sentence = ' '.join(reversed_words)\n    return reversed_sentence\n\n###Testcases: \n\nassert reverse_words_in_sentence(\"Let's take LeetCode contest\") == \"s'teL ekat edoCteeL tsetnoc\"\nassert reverse_words_in_sentence(\"God Ding\") == \"doG gniD\"\nassert reverse_words_in_sentence(\"Welcome to the jungle\") == \"emocleW ot eht elgnuj\"\nassert reverse_words_in_sentence(\"The quick brown fox jumps over the lazy dog\") == \"ehT kciuq nworb xof spmuj revo eht yzal god\"\nassert reverse_words_in_sentence(\"Keep calm and code on\") == \"peeK mlac dna edoc no\"\nassert reverse_words_in_sentence(\"Challenge everything\") == \"egnellahC gnihtyreve\"\nassert reverse_words_in_sentence(\" \") == \" \"\nassert reverse_words_in_sentence(\"a b c d\") == \"a b c d\"\nassert reverse_words_in_sentence(\"Double  spaces\") == \"elbuoD  secaps\"\n\n[/Example 3]", "temperature": 0.854, "question": "Implement a function that transforms a sentence by reversing the characters of each word without reversing the word order itself.", "code": "def reverse_words_in_sentence(sentence: str) -> str:\n    words = sentence.split()\n    reversed_words = [word[::-1] for word in words]\n    reversed_sentence = ' '.join(reversed_words)\n    return reversed_sentence", "asserts": ["assert reverse_words_in_sentence(\"Let's take LeetCode contest\") == \"s'teL ekat edoCteeL tsetnoc\"", "assert reverse_words_in_sentence(\"God Ding\") == \"doG gniD\"", "assert reverse_words_in_sentence(\"Welcome to the jungle\") == \"emocleW ot eht elgnuj\"", "assert reverse_words_in_sentence(\"The quick brown fox jumps over the lazy dog\") == \"ehT kciuq nworb xof spmuj revo eht yzal god\"", "assert reverse_words_in_sentence(\"Keep calm and code on\") == \"peeK mlac dna edoc no\"", "assert reverse_words_in_sentence(\"Challenge everything\") == \"egnellahC gnihtyreve\"", "assert reverse_words_in_sentence(\"a b c d\") == \"a b c d\""], "author": "GPT", "UUID": "cee8cb61-5f31-42e4-b6e5-60f5258b7f45", "tc_status": [["assert reverse_words_in_sentence(\"Let's take LeetCode contest\") == \"s'teL ekat edoCteeL tsetnoc\"", "Passed"], ["assert reverse_words_in_sentence(\"God Ding\") == \"doG gniD\"", "Passed"], ["assert reverse_words_in_sentence(\"Welcome to the jungle\") == \"emocleW ot eht elgnuj\"", "Passed"], ["assert reverse_words_in_sentence(\"The quick brown fox jumps over the lazy dog\") == \"ehT kciuq nworb xof spmuj revo eht yzal god\"", "Passed"], ["assert reverse_words_in_sentence(\"Keep calm and code on\") == \"peeK mlac dna edoc no\"", "Passed"], ["assert reverse_words_in_sentence(\"Challenge everything\") == \"egnellahC gnihtyreve\"", "Passed"], ["assert reverse_words_in_sentence(\"a b c d\") == \"a b c d\"", "Passed"]]}, {"few_shots": [{"author": "Calvin", "UUID": "80e34b28-16a8-46ac-8b6a-ee28beb1e8d4", "question": "Write a function that reverses a string. The input string is given as an array of characters s.\n\nYou must do this by modifying the input array in-place with O(1) extra memory.", "examples": "Input: [\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput: [\"o\",\"l\",\"l\",\"e\",\"h\"]\n\nInput: [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\nOutput: [\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def reverse_string(s: list) -> list:\n  l = 0\n  r = len(s) - 1\n  while l < r:\n    tmp = s[l]\n    s[l] = s[r]\n    s[r] = tmp\n    l += 1\n    r -= 1\n  return s\n", "asserts": ["assert reverse_string([\"a\",\"b\",\"c\",\"d\"]) == [\"d\", \"c\", \"b\", \"a\"]", "assert reverse_string([\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"]) == [\"n\", \"o\", \"h\", \"t\", \"y\", \"p\"]", "assert reverse_string([]) == []", "assert reverse_string([\"s\", \"i\", \"n\", \"g\", \"l\", \"e\"]) == [\"e\", \"l\", \"g\", \"n\", \"i\", \"s\"]", "assert reverse_string([\"A\"]) == [\"A\"]", "assert reverse_string([\"9\", \"8\", \"7\", \"6\", \"5\", \"4\", \"3\", \"2\", \"1\"]) == [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]", "assert reverse_string([\"B\", \"o\", \"b\"]) == [\"b\", \"o\", \"B\"]", "assert reverse_string([\"r\", \"e\", \"v\", \"e\", \"r\", \"s\", \"e\"]) == [\"e\", \"s\", \"r\", \"e\", \"v\", \"e\", \"r\"]", "assert reverse_string([\"1\", \"*\", \"2\", \"*\", \"3\"]) == [\"3\", \"*\", \"2\", \"*\", \"1\"]"]}, {"author": "Calvin", "UUID": "d0ce7430-cfcd-4c69-b161-b3b2a186422c", "question": "Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.\n\nIn other words, return true if one of s1's permutations is the substring of s2.", "examples": "Input: s1 = \"ab\", s2 = \"eidbaooo\"\nOutput: True\n\nInput: s1 = \"ab\", s2 = \"eidboaoo\"\nOutput: False", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef permutation_in_string(s1: str, s2: str) -> bool:\n  window = len(s1)\n  if window > len(s2):\n    return False\n  freq1 = [0]*26\n  freq2 = [0]*26\n  for i in range(window):\n    freq1[ord(s1[i])-ord('a')] += 1\n    freq2[ord(s2[i])-ord('a')] += 1\n\n  matches = 0\n  for i in range(26):\n    if freq1[i] == freq2[i]:\n      matches += 1\n  \n  for l in range(len(s2) - window):\n    if matches == 26:\n      return True\n\n    added = ord(s2[l + window]) - ord('a')\n    freq2[added] += 1\n    if freq1[added] == freq2[added]:\n      matches += 1\n    elif freq1[added] + 1 == freq2[added]:\n      matches -= 1\n\n    removed = ord(s2[l]) - ord('a')\n    freq2[removed] -= 1\n    if freq1[removed] == freq2[removed]:\n      matches += 1\n    elif freq1[removed] == freq2[removed] + 1:\n      matches -= 1\n    \n  return matches == 26\n", "asserts": ["assert permutation_in_string(\"hello\", \"ooollehhhhh\") == True", "assert permutation_in_string(\"abc\", \"ccccbbbbaaaa\") == False", "assert permutation_in_string(\"xyz\", \"zxyopqrstuv\") == True", "assert permutation_in_string(\"xyz\", \"xzygxzyzxyzk\") == True", "assert permutation_in_string(\"a\", \"a\") == True", "assert permutation_in_string(\"adc\", \"dcda\") == True", "assert permutation_in_string(\"pq\", \"qpqqp\") == True", "assert permutation_in_string(\"kitten\", \"sittingkite\") == False", "assert permutation_in_string(\"pq\", \"pqpqr\") == True", "assert permutation_in_string(\"aba\", \"aabaabaa\") == True", "assert permutation_in_string(\"\", \"\") == True  # Edge case: both strings are empty", "assert permutation_in_string(\"longerstring\", \"short\") == False  # s1 is longer than s2", "assert permutation_in_string(\"a\", \"b\") == False  # Single character, no match", "assert permutation_in_string(\"aab\", \"baa\") == True  # s1 is a permutation of s2", "assert permutation_in_string(\"ab\", \"a\") == False  # s2 is shorter than s1", "assert permutation_in_string(\"ba\", \"eidbaooo\") == True  # Same characters as Example 1 but different permutation", "assert permutation_in_string(\"eid\", \"eidbaooo\") == True  # s1 is a prefix of s2", "assert permutation_in_string(\"ooo\", \"eidbaooo\") == True  # s1 is a suffix of s2", "assert permutation_in_string(\"db\", \"eidbaooo\") == True  # s1 is a permutation within s2", "assert permutation_in_string(\"eidoo\", \"eidbaooo\") == False  # s1 is longer than any permutation within s2"]}], "category": "String", "prompt_tokens": 1324, "total_tokens": 1777, "completion_tokens": 453, "completion": "Given a string s consisting of uppercase English letters, return the length of the longest palindrome that can be built with those letters.\n\nLetters are case sensitive, meaning \"Aa\" is not considered a palindrome here.\n\n###Code: \n\n```python\ndef longest_palindrome(s: str) -> int:\n    letter_counts = {}\n    for char in s:\n        letter_counts[char] = letter_counts.get(char, 0) + 1\n    \n    length = 0\n    odd_found = False\n    for count in letter_counts.values():\n        if count % 2 == 0:\n            length += count\n        else:\n            length += count - 1\n            odd_found = True\n    \n    if odd_found:\n        length += 1\n    \n    return length\n```\n\n###Testcases: \n\n```python\nassert longest_palindrome(\"ABCCBA\") == 6\nassert longest_palindrome(\"AABBCC\") == 6\nassert longest_palindrome(\"AAABBB\") == 5\nassert longest_palindrome(\"A\") == 1\nassert longest_palindrome(\"ABC\") == 1\nassert longest_palindrome(\"ABCCCCDD\") == 7\nassert longest_palindrome(\"a\") == 1\nassert longest_palindrome(\"\") == 0\nassert longest_palindrome(\"Aa\") == 1\nassert longest_palindrome(\"ABABAB\") == 5\nassert longest_palindrome(\"NAMAN\") == 5\nassert longest_palindrome(\"QQQ\") == 3\nassert longest_palindrome(\"ZZZZCD\") == 5\nassert longest_palindrome(\"XYZABCDDCBA\") == 9\nassert longest_palindrome(\"XXYYZZZ\") == 7\nassert longest_palindrome(\"XXYYZZZXXX\") == 9\nassert longest_palindrome(\"ABABABABAB\") == 9\nassert longest_palindrome(\"ABACADAEAFAGAHAIAJA\") == 1\nassert longest_palindrome(\"ABACADAEAFAGAHAIABA\") == 17\nassert longest_palindrome(\"AAAAAAAAAA\") == 10\nassert longest_palindrome(\"ABCDEFGHIJKL\") == 1\n```\n\n[/Example 3]", "temperature": 0.662, "question": "Given a string s consisting of uppercase English letters, return the length of the longest palindrome that can be built with those letters.\n\nLetters are case sensitive, meaning \"Aa\" is not considered a palindrome here.", "code": "def longest_palindrome(s: str) -> int:\n    letter_counts = {}\n    for char in s:\n        letter_counts[char] = letter_counts.get(char, 0) + 1\n    \n    length = 0\n    odd_found = False\n    for count in letter_counts.values():\n        if count % 2 == 0:\n            length += count\n        else:\n            length += count - 1\n            odd_found = True\n    \n    if odd_found:\n        length += 1\n    \n    return length", "asserts": ["assert longest_palindrome(\"ABCCBA\") == 6", "assert longest_palindrome(\"AABBCC\") == 6", "assert longest_palindrome(\"AAABBB\") == 5", "assert longest_palindrome(\"A\") == 1", "assert longest_palindrome(\"ABC\") == 1", "assert longest_palindrome(\"ABCCCCDD\") == 7", "assert longest_palindrome(\"a\") == 1", "assert longest_palindrome(\"\") == 0", "assert longest_palindrome(\"Aa\") == 1", "assert longest_palindrome(\"ABABAB\") == 5", "assert longest_palindrome(\"NAMAN\") == 5", "assert longest_palindrome(\"QQQ\") == 3", "assert longest_palindrome(\"ZZZZCD\") == 5", "assert longest_palindrome(\"XYZABCDDCBA\") == 9", "assert longest_palindrome(\"XXYYZZZ\") == 7", "assert longest_palindrome(\"XXYYZZZXXX\") == 9", "assert longest_palindrome(\"ABABABABAB\") == 9", "assert longest_palindrome(\"AAAAAAAAAA\") == 10", "assert longest_palindrome(\"ABCDEFGHIJKL\") == 1"], "author": "GPT", "UUID": "bfcc4635-a1aa-4d4c-b912-83abe3409163", "tc_status": [["assert longest_palindrome(\"ABCCBA\") == 6", "Passed"], ["assert longest_palindrome(\"AABBCC\") == 6", "Passed"], ["assert longest_palindrome(\"AAABBB\") == 5", "Passed"], ["assert longest_palindrome(\"A\") == 1", "Passed"], ["assert longest_palindrome(\"ABC\") == 1", "Passed"], ["assert longest_palindrome(\"ABCCCCDD\") == 7", "Passed"], ["assert longest_palindrome(\"a\") == 1", "Passed"], ["assert longest_palindrome(\"\") == 0", "Passed"], ["assert longest_palindrome(\"Aa\") == 1", "Passed"], ["assert longest_palindrome(\"ABABAB\") == 5", "Passed"], ["assert longest_palindrome(\"NAMAN\") == 5", "Passed"], ["assert longest_palindrome(\"QQQ\") == 3", "Passed"], ["assert longest_palindrome(\"ZZZZCD\") == 5", "Passed"], ["assert longest_palindrome(\"XYZABCDDCBA\") == 9", "Passed"], ["assert longest_palindrome(\"XXYYZZZ\") == 7", "Passed"], ["assert longest_palindrome(\"XXYYZZZXXX\") == 9", "Passed"], ["assert longest_palindrome(\"ABABABABAB\") == 9", "Passed"], ["assert longest_palindrome(\"AAAAAAAAAA\") == 10", "Passed"], ["assert longest_palindrome(\"ABCDEFGHIJKL\") == 1", "Passed"]]}, {"few_shots": [{"author": "Calvin", "UUID": "80e34b28-16a8-46ac-8b6a-ee28beb1e8d4", "question": "Write a function that reverses a string. The input string is given as an array of characters s.\n\nYou must do this by modifying the input array in-place with O(1) extra memory.", "examples": "Input: [\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput: [\"o\",\"l\",\"l\",\"e\",\"h\"]\n\nInput: [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\nOutput: [\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def reverse_string(s: list) -> list:\n  l = 0\n  r = len(s) - 1\n  while l < r:\n    tmp = s[l]\n    s[l] = s[r]\n    s[r] = tmp\n    l += 1\n    r -= 1\n  return s\n", "asserts": ["assert reverse_string([\"a\",\"b\",\"c\",\"d\"]) == [\"d\", \"c\", \"b\", \"a\"]", "assert reverse_string([\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"]) == [\"n\", \"o\", \"h\", \"t\", \"y\", \"p\"]", "assert reverse_string([]) == []", "assert reverse_string([\"s\", \"i\", \"n\", \"g\", \"l\", \"e\"]) == [\"e\", \"l\", \"g\", \"n\", \"i\", \"s\"]", "assert reverse_string([\"A\"]) == [\"A\"]", "assert reverse_string([\"9\", \"8\", \"7\", \"6\", \"5\", \"4\", \"3\", \"2\", \"1\"]) == [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]", "assert reverse_string([\"B\", \"o\", \"b\"]) == [\"b\", \"o\", \"B\"]", "assert reverse_string([\"r\", \"e\", \"v\", \"e\", \"r\", \"s\", \"e\"]) == [\"e\", \"s\", \"r\", \"e\", \"v\", \"e\", \"r\"]", "assert reverse_string([\"1\", \"*\", \"2\", \"*\", \"3\"]) == [\"3\", \"*\", \"2\", \"*\", \"1\"]"]}, {"author": "Calvin", "UUID": "87372a22-f5ef-4100-845b-28700ca3fde3", "question": "You are given a string s and an integer array indices of the same length. The string s will be shuffled such that the character at the ith position moves to indices[i] in the shuffled string.\n\nReturn the shuffled string.", "examples": "Input: s = \"codeleet\", indices = [4,5,6,7,0,2,1,3]\nOutput: \"leetcode\"\n\nInput: s = \"abc\", indices = [0,1,2]\nOutput: \"abc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "from typing import List\ndef shuffle_string(s: str, indices: List[int]) -> str:\n    def partitionString(s):\n      substrings = 1\n      cur_str = set()\n      for i in range(len(s)):\n        if s[i] in cur_str:\n          substrings += 1\n          cur_str = {s[i]}\n        else:\n          cur_str.add(s[i])\n      return substrings\n    ret = ['_']*len(s)\n    for idx, i in enumerate(indices):\n        ret[i] = s[idx]\n    return \"\".join(ret)\n", "asserts": ["assert shuffle_string(\"reoc\", [2, 0, 1, 3]) == \"eorc\"", "assert shuffle_string(\"aiohn\", [3,1,4,2,0]) == \"nihao\"", "assert shuffle_string(\"aax\", [0,2,1]) == \"axa\"", "assert shuffle_string(\"gh\", [1,0]) == \"hg\"", "assert shuffle_string(\"\", []) == \"\"  # Edge case: empty string", "assert shuffle_string(\"xy\", [0,1]) == \"xy\"  # No shuffle required", "assert shuffle_string(\"pqrstuvwxyzabcdefghijklmno\", list(range(25, -1, -1))) == \"onmlkjihgfedcbazyxwvutsrqp\"  # Reverse shuffle"]}], "category": "String", "prompt_tokens": 920, "total_tokens": 1463, "completion_tokens": 543, "completion": "Given a non-empty string s and an abbreviation abbr, return whether the string matches with the given abbreviation.\n\nA string such as \"word\" contains only the following valid abbreviations:\n\n[\"word\", \"1ord\", \"w1rd\", \"wo1d\", \"wor1\", \"2rd\", \"w2d\", \"wo2\", \"1o1d\", \"1or1\", \"w1r1\", \"1o2\", \"2r1\", \"3d\", \"w3\", \"4\"]\n\nNotice that only the above abbreviations are valid abbreviations of the string \"word\". Any other string is not a valid abbreviation of \"word\".\n\nNote:\nAssume s contains only lowercase letters and abbr contains lowercase letters and digits.\n\n###Code: \n\ndef valid_word_abbreviation(s: str, abbr: str) -> bool:\n    char_index, abbr_index = 0, 0\n    num = 0\n    while char_index < len(s) and abbr_index < len(abbr):\n        if abbr[abbr_index].isdigit():\n            if abbr[abbr_index] == '0' and num == 0:\n                return False  # leading zero is not allowed\n            num = num * 10 + int(abbr[abbr_index])\n            abbr_index += 1\n        else:\n            if num:\n                char_index += num\n                num = 0\n            if char_index >= len(s) or s[char_index] != abbr[abbr_index]:\n                return False\n            char_index += 1\n            abbr_index += 1\n    if num:\n        char_index += num\n    return char_index == len(s) and abbr_index == len(abbr)\n\n###Testcases: \n\nassert valid_word_abbreviation(\"internationalization\", \"i12iz4n\") == True\nassert valid_word_abbreviation(\"apple\", \"a2e\") == False\nassert valid_word_abbreviation(\"word\", \"2rd\") == True\nassert valid_word_abbreviation(\"word\", \"w2d\") == True\nassert valid_word_abbreviation(\"word\", \"4\") == True\nassert valid_word_abbreviation(\"word\", \"5\") == False\nassert valid_word_abbreviation(\"word\", \"0word\") == False\nassert valid_word_abbreviation(\"abbreviation\", \"a10n\") == True\nassert valid_word_abbreviation(\"abbreviation\", \"abbr2viation\") == True\nassert valid_word_abbreviation(\"abbreviation\", \"a12n\") == False\nassert valid_word_abbreviation(\"a\", \"01\") == False\n\n[/Example 3]", "temperature": 0.756, "question": "Given a non-empty string s and an abbreviation abbr, return whether the string matches with the given abbreviation.\n\nA string such as \"word\" contains only the following valid abbreviations:\n\n[\"word\", \"1ord\", \"w1rd\", \"wo1d\", \"wor1\", \"2rd\", \"w2d\", \"wo2\", \"1o1d\", \"1or1\", \"w1r1\", \"1o2\", \"2r1\", \"3d\", \"w3\", \"4\"]\n\nNotice that only the above abbreviations are valid abbreviations of the string \"word\". Any other string is not a valid abbreviation of \"word\".\n\nNote:\nAssume s contains only lowercase letters and abbr contains lowercase letters and digits.", "code": "def valid_word_abbreviation(s: str, abbr: str) -> bool:\n    char_index, abbr_index = 0, 0\n    num = 0\n    while char_index < len(s) and abbr_index < len(abbr):\n        if abbr[abbr_index].isdigit():\n            if abbr[abbr_index] == '0' and num == 0:\n                return False  # leading zero is not allowed\n            num = num * 10 + int(abbr[abbr_index])\n            abbr_index += 1\n        else:\n            if num:\n                char_index += num\n                num = 0\n            if char_index >= len(s) or s[char_index] != abbr[abbr_index]:\n                return False\n            char_index += 1\n            abbr_index += 1\n    if num:\n        char_index += num\n    return char_index == len(s) and abbr_index == len(abbr)", "asserts": ["assert valid_word_abbreviation(\"internationalization\", \"i12iz4n\") == True", "assert valid_word_abbreviation(\"apple\", \"a2e\") == False", "assert valid_word_abbreviation(\"word\", \"2rd\") == True", "assert valid_word_abbreviation(\"word\", \"w2d\") == True", "assert valid_word_abbreviation(\"word\", \"4\") == True", "assert valid_word_abbreviation(\"word\", \"5\") == False", "assert valid_word_abbreviation(\"word\", \"0word\") == False", "assert valid_word_abbreviation(\"abbreviation\", \"a10n\") == True", "assert valid_word_abbreviation(\"abbreviation\", \"a12n\") == False", "assert valid_word_abbreviation(\"a\", \"01\") == False"], "author": "GPT", "UUID": "9f55862c-f525-4e4a-b5b9-b9cd945ff366", "tc_status": [["assert valid_word_abbreviation(\"internationalization\", \"i12iz4n\") == True", "Passed"], ["assert valid_word_abbreviation(\"apple\", \"a2e\") == False", "Passed"], ["assert valid_word_abbreviation(\"word\", \"2rd\") == True", "Passed"], ["assert valid_word_abbreviation(\"word\", \"w2d\") == True", "Passed"], ["assert valid_word_abbreviation(\"word\", \"4\") == True", "Passed"], ["assert valid_word_abbreviation(\"word\", \"5\") == False", "Passed"], ["assert valid_word_abbreviation(\"word\", \"0word\") == False", "Passed"], ["assert valid_word_abbreviation(\"abbreviation\", \"a10n\") == True", "Passed"], ["assert valid_word_abbreviation(\"abbreviation\", \"a12n\") == False", "Passed"], ["assert valid_word_abbreviation(\"a\", \"01\") == False", "Passed"]]}, {"few_shots": [{"author": "Calvin", "UUID": "80e34b28-16a8-46ac-8b6a-ee28beb1e8d4", "question": "Write a function that reverses a string. The input string is given as an array of characters s.\n\nYou must do this by modifying the input array in-place with O(1) extra memory.", "examples": "Input: [\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput: [\"o\",\"l\",\"l\",\"e\",\"h\"]\n\nInput: [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\nOutput: [\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def reverse_string(s: list) -> list:\n  l = 0\n  r = len(s) - 1\n  while l < r:\n    tmp = s[l]\n    s[l] = s[r]\n    s[r] = tmp\n    l += 1\n    r -= 1\n  return s\n", "asserts": ["assert reverse_string([\"a\",\"b\",\"c\",\"d\"]) == [\"d\", \"c\", \"b\", \"a\"]", "assert reverse_string([\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"]) == [\"n\", \"o\", \"h\", \"t\", \"y\", \"p\"]", "assert reverse_string([]) == []", "assert reverse_string([\"s\", \"i\", \"n\", \"g\", \"l\", \"e\"]) == [\"e\", \"l\", \"g\", \"n\", \"i\", \"s\"]", "assert reverse_string([\"A\"]) == [\"A\"]", "assert reverse_string([\"9\", \"8\", \"7\", \"6\", \"5\", \"4\", \"3\", \"2\", \"1\"]) == [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]", "assert reverse_string([\"B\", \"o\", \"b\"]) == [\"b\", \"o\", \"B\"]", "assert reverse_string([\"r\", \"e\", \"v\", \"e\", \"r\", \"s\", \"e\"]) == [\"e\", \"s\", \"r\", \"e\", \"v\", \"e\", \"r\"]", "assert reverse_string([\"1\", \"*\", \"2\", \"*\", \"3\"]) == [\"3\", \"*\", \"2\", \"*\", \"1\"]"]}, {"author": "Calvin", "UUID": "87372a22-f5ef-4100-845b-28700ca3fde3", "question": "You are given a string s and an integer array indices of the same length. The string s will be shuffled such that the character at the ith position moves to indices[i] in the shuffled string.\n\nReturn the shuffled string.", "examples": "Input: s = \"codeleet\", indices = [4,5,6,7,0,2,1,3]\nOutput: \"leetcode\"\n\nInput: s = \"abc\", indices = [0,1,2]\nOutput: \"abc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "from typing import List\ndef shuffle_string(s: str, indices: List[int]) -> str:\n    def partitionString(s):\n      substrings = 1\n      cur_str = set()\n      for i in range(len(s)):\n        if s[i] in cur_str:\n          substrings += 1\n          cur_str = {s[i]}\n        else:\n          cur_str.add(s[i])\n      return substrings\n    ret = ['_']*len(s)\n    for idx, i in enumerate(indices):\n        ret[i] = s[idx]\n    return \"\".join(ret)\n", "asserts": ["assert shuffle_string(\"reoc\", [2, 0, 1, 3]) == \"eorc\"", "assert shuffle_string(\"aiohn\", [3,1,4,2,0]) == \"nihao\"", "assert shuffle_string(\"aax\", [0,2,1]) == \"axa\"", "assert shuffle_string(\"gh\", [1,0]) == \"hg\"", "assert shuffle_string(\"\", []) == \"\"  # Edge case: empty string", "assert shuffle_string(\"xy\", [0,1]) == \"xy\"  # No shuffle required", "assert shuffle_string(\"pqrstuvwxyzabcdefghijklmno\", list(range(25, -1, -1))) == \"onmlkjihgfedcbazyxwvutsrqp\"  # Reverse shuffle"]}], "category": "String", "prompt_tokens": 920, "total_tokens": 1317, "completion_tokens": 397, "completion": "Construct a function that checks if a string (the \"needle\") is contained within another string (the \"haystack\"), and returns the index at which the \"needle\" starts within the \"haystack\". If the \"needle\" is not found, the function should return -1.\n\n###Code:\n\n```python\ndef strStr(haystack: str, needle: str) -> int:\n    if not needle:\n        return 0\n    if not haystack or len(needle) > len(haystack):\n        return -1\n    for i in range(len(haystack) - len(needle) + 1):\n        if haystack[i:i + len(needle)] == needle:\n            return i\n    return -1\n```\n\n###Testcases:\n\n```python\nassert strStr(\"hello\", \"ll\") == 2\nassert strStr(\"aaaaa\", \"bba\") == -1\nassert strStr(\"\", \"\") == 0  # Edge case: both strings are empty\nassert strStr(\"a\", \"\") == 0  # Edge case: needle is empty\nassert strStr(\"\", \"a\") == -1  # Edge case: haystack is empty, but needle is not\nassert strStr(\"mississippi\", \"issip\") == 4\nassert strStr(\"abcdefg\", \"def\") == 3\nassert strStr(\"aabbccdd\", \"bc\") == 2\nassert strStr(\"needle in a haystack\", \"needle\") == 0\nassert strStr(\"needle in a haystack\", \"haystack\") == 11\nassert strStr(\"needle in a haystack\", \"in a\") == 7\nassert strStr(\"abc\", \"abc\") == 0  # Edge case: needle is the same as haystack\nassert strStr(\"abc\", \"abcd\") == -1  # Edge case: needle is longer than haystack\n```\n\n[/Example 3]", "temperature": 0.917, "question": "Construct a function that checks if a string (the \"needle\") is contained within another string (the \"haystack\"), and returns the index at which the \"needle\" starts within the \"haystack\". If the \"needle\" is not found, the function should return -1.", "code": "def strStr(haystack: str, needle: str) -> int:\n    if not needle:\n        return 0\n    if not haystack or len(needle) > len(haystack):\n        return -1\n    for i in range(len(haystack) - len(needle) + 1):\n        if haystack[i:i + len(needle)] == needle:\n            return i\n    return -1", "asserts": ["assert strStr(\"hello\", \"ll\") == 2", "assert strStr(\"aaaaa\", \"bba\") == -1", "assert strStr(\"\", \"\") == 0  # Edge case: both strings are empty", "assert strStr(\"a\", \"\") == 0  # Edge case: needle is empty", "assert strStr(\"\", \"a\") == -1  # Edge case: haystack is empty, but needle is not", "assert strStr(\"mississippi\", \"issip\") == 4", "assert strStr(\"abcdefg\", \"def\") == 3", "assert strStr(\"needle in a haystack\", \"needle\") == 0", "assert strStr(\"needle in a haystack\", \"in a\") == 7", "assert strStr(\"abc\", \"abc\") == 0  # Edge case: needle is the same as haystack", "assert strStr(\"abc\", \"abcd\") == -1  # Edge case: needle is longer than haystack"], "author": "GPT", "UUID": "a603dd19-8615-4b7c-a620-ba70baa40351", "tc_status": [["assert strStr(\"hello\", \"ll\") == 2", "Passed"], ["assert strStr(\"aaaaa\", \"bba\") == -1", "Passed"], ["assert strStr(\"\", \"\") == 0  # Edge case: both strings are empty", "Passed"], ["assert strStr(\"a\", \"\") == 0  # Edge case: needle is empty", "Passed"], ["assert strStr(\"\", \"a\") == -1  # Edge case: haystack is empty, but needle is not", "Passed"], ["assert strStr(\"mississippi\", \"issip\") == 4", "Passed"], ["assert strStr(\"abcdefg\", \"def\") == 3", "Passed"], ["assert strStr(\"needle in a haystack\", \"needle\") == 0", "Passed"], ["assert strStr(\"needle in a haystack\", \"in a\") == 7", "Passed"], ["assert strStr(\"abc\", \"abc\") == 0  # Edge case: needle is the same as haystack", "Passed"], ["assert strStr(\"abc\", \"abcd\") == -1  # Edge case: needle is longer than haystack", "Passed"]]}, {"few_shots": [{"author": "Calvin", "UUID": "80e34b28-16a8-46ac-8b6a-ee28beb1e8d4", "question": "Write a function that reverses a string. The input string is given as an array of characters s.\n\nYou must do this by modifying the input array in-place with O(1) extra memory.", "examples": "Input: [\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput: [\"o\",\"l\",\"l\",\"e\",\"h\"]\n\nInput: [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\nOutput: [\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def reverse_string(s: list) -> list:\n  l = 0\n  r = len(s) - 1\n  while l < r:\n    tmp = s[l]\n    s[l] = s[r]\n    s[r] = tmp\n    l += 1\n    r -= 1\n  return s\n", "asserts": ["assert reverse_string([\"a\",\"b\",\"c\",\"d\"]) == [\"d\", \"c\", \"b\", \"a\"]", "assert reverse_string([\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"]) == [\"n\", \"o\", \"h\", \"t\", \"y\", \"p\"]", "assert reverse_string([]) == []", "assert reverse_string([\"s\", \"i\", \"n\", \"g\", \"l\", \"e\"]) == [\"e\", \"l\", \"g\", \"n\", \"i\", \"s\"]", "assert reverse_string([\"A\"]) == [\"A\"]", "assert reverse_string([\"9\", \"8\", \"7\", \"6\", \"5\", \"4\", \"3\", \"2\", \"1\"]) == [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]", "assert reverse_string([\"B\", \"o\", \"b\"]) == [\"b\", \"o\", \"B\"]", "assert reverse_string([\"r\", \"e\", \"v\", \"e\", \"r\", \"s\", \"e\"]) == [\"e\", \"s\", \"r\", \"e\", \"v\", \"e\", \"r\"]", "assert reverse_string([\"1\", \"*\", \"2\", \"*\", \"3\"]) == [\"3\", \"*\", \"2\", \"*\", \"1\"]"]}, {"author": "Calvin", "UUID": "87372a22-f5ef-4100-845b-28700ca3fde3", "question": "You are given a string s and an integer array indices of the same length. The string s will be shuffled such that the character at the ith position moves to indices[i] in the shuffled string.\n\nReturn the shuffled string.", "examples": "Input: s = \"codeleet\", indices = [4,5,6,7,0,2,1,3]\nOutput: \"leetcode\"\n\nInput: s = \"abc\", indices = [0,1,2]\nOutput: \"abc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "from typing import List\ndef shuffle_string(s: str, indices: List[int]) -> str:\n    def partitionString(s):\n      substrings = 1\n      cur_str = set()\n      for i in range(len(s)):\n        if s[i] in cur_str:\n          substrings += 1\n          cur_str = {s[i]}\n        else:\n          cur_str.add(s[i])\n      return substrings\n    ret = ['_']*len(s)\n    for idx, i in enumerate(indices):\n        ret[i] = s[idx]\n    return \"\".join(ret)\n", "asserts": ["assert shuffle_string(\"reoc\", [2, 0, 1, 3]) == \"eorc\"", "assert shuffle_string(\"aiohn\", [3,1,4,2,0]) == \"nihao\"", "assert shuffle_string(\"aax\", [0,2,1]) == \"axa\"", "assert shuffle_string(\"gh\", [1,0]) == \"hg\"", "assert shuffle_string(\"\", []) == \"\"  # Edge case: empty string", "assert shuffle_string(\"xy\", [0,1]) == \"xy\"  # No shuffle required", "assert shuffle_string(\"pqrstuvwxyzabcdefghijklmno\", list(range(25, -1, -1))) == \"onmlkjihgfedcbazyxwvutsrqp\"  # Reverse shuffle"]}], "category": "String", "prompt_tokens": 920, "total_tokens": 1161, "completion_tokens": 241, "completion": "Write a function that checks whether two strings are anagrams of each other. An anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.\n\n###Code: \n\ndef are_anagrams(str1: str, str2: str) -> bool:\n    return sorted(str1) == sorted(str2)\n\n###Testcases: \n\nassert are_anagrams(\"cinema\", \"iceman\") == True\nassert are_anagrams(\"listen\", \"silent\") == True\nassert are_anagrams(\"triangle\", \"integral\") == True\nassert are_anagrams(\"hello\", \"billion\") == False\nassert are_anagrams(\"a\", \"b\") == False\nassert are_anagrams(\"\", \"\") == True  # Edge case: empty strings\nassert are_anagrams(\"aabbcc\", \"abcabc\") == True\nassert are_anagrams(\"aabbc\", \"ababc\") == False  # Different number of letters\nassert are_anagrams(\"123\", \"321\") == True  # Non-letter characters\nassert are_anagrams(\"112233\", \"113322\") == False\n\n[/Example 3]", "temperature": 0.93, "question": "Write a function that checks whether two strings are anagrams of each other. An anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.", "code": "def are_anagrams(str1: str, str2: str) -> bool:\n    return sorted(str1) == sorted(str2)", "asserts": ["assert are_anagrams(\"cinema\", \"iceman\") == True", "assert are_anagrams(\"listen\", \"silent\") == True", "assert are_anagrams(\"triangle\", \"integral\") == True", "assert are_anagrams(\"hello\", \"billion\") == False", "assert are_anagrams(\"a\", \"b\") == False", "assert are_anagrams(\"\", \"\") == True  # Edge case: empty strings", "assert are_anagrams(\"aabbcc\", \"abcabc\") == True", "assert are_anagrams(\"123\", \"321\") == True  # Non-letter characters"], "author": "GPT", "UUID": "2581ac5d-51aa-4c67-b91d-b5bc8e073176", "tc_status": [["assert are_anagrams(\"cinema\", \"iceman\") == True", "Passed"], ["assert are_anagrams(\"listen\", \"silent\") == True", "Passed"], ["assert are_anagrams(\"triangle\", \"integral\") == True", "Passed"], ["assert are_anagrams(\"hello\", \"billion\") == False", "Passed"], ["assert are_anagrams(\"a\", \"b\") == False", "Passed"], ["assert are_anagrams(\"\", \"\") == True  # Edge case: empty strings", "Passed"], ["assert are_anagrams(\"aabbcc\", \"abcabc\") == True", "Passed"], ["assert are_anagrams(\"123\", \"321\") == True  # Non-letter characters", "Passed"]]}, {"few_shots": [{"author": "Calvin", "UUID": "80e34b28-16a8-46ac-8b6a-ee28beb1e8d4", "question": "Write a function that reverses a string. The input string is given as an array of characters s.\n\nYou must do this by modifying the input array in-place with O(1) extra memory.", "examples": "Input: [\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput: [\"o\",\"l\",\"l\",\"e\",\"h\"]\n\nInput: [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\nOutput: [\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def reverse_string(s: list) -> list:\n  l = 0\n  r = len(s) - 1\n  while l < r:\n    tmp = s[l]\n    s[l] = s[r]\n    s[r] = tmp\n    l += 1\n    r -= 1\n  return s\n", "asserts": ["assert reverse_string([\"a\",\"b\",\"c\",\"d\"]) == [\"d\", \"c\", \"b\", \"a\"]", "assert reverse_string([\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"]) == [\"n\", \"o\", \"h\", \"t\", \"y\", \"p\"]", "assert reverse_string([]) == []", "assert reverse_string([\"s\", \"i\", \"n\", \"g\", \"l\", \"e\"]) == [\"e\", \"l\", \"g\", \"n\", \"i\", \"s\"]", "assert reverse_string([\"A\"]) == [\"A\"]", "assert reverse_string([\"9\", \"8\", \"7\", \"6\", \"5\", \"4\", \"3\", \"2\", \"1\"]) == [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]", "assert reverse_string([\"B\", \"o\", \"b\"]) == [\"b\", \"o\", \"B\"]", "assert reverse_string([\"r\", \"e\", \"v\", \"e\", \"r\", \"s\", \"e\"]) == [\"e\", \"s\", \"r\", \"e\", \"v\", \"e\", \"r\"]", "assert reverse_string([\"1\", \"*\", \"2\", \"*\", \"3\"]) == [\"3\", \"*\", \"2\", \"*\", \"1\"]"]}, {"author": "Calvin", "UUID": "56b48f6d-0d81-478d-b838-4d47b62d3031", "question": "Given an integer n, return the number of strings of length n that consist only of vowels (a, e, i, o, u) and are lexicographically sorted.\n\nA string s is lexicographically sorted if for all valid i, s[i] is the same as or comes before s[i+1] in the alphabet.", "examples": "Input: 1\nOutput: 5\n\nInput: 2\nOutput: 15", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def helper(n, letter_idx):\n  letters = [\"a\",\"e\",\"i\",\"o\",\"u\"]\n  dynamic = {\n      'a1' : 5,\n      'e1' : 4,\n      'i1' : 3,\n      'o1' : 2,\n      'u1' : 1\n  }\n  ret = 0\n  key = letters[letter_idx] + str(n)\n  if key in dynamic.keys():\n    return dynamic[key]\n  else:\n    for i in range(letter_idx, len(letters)):\n      ret += helper(n-1, i)\n    dynamic[key] = ret\n  return ret\n  \n\ndef countVowelStrings(n: int) -> int:\n  return helper(n, 0)\n", "asserts": ["assert countVowelStrings(3) == 35", "assert countVowelStrings(4) == 70", "assert countVowelStrings(5) == 126", "assert countVowelStrings(6) == 210", "assert countVowelStrings(7) == 330", "assert countVowelStrings(10) == 1001", "assert countVowelStrings(15) == 3876"]}], "category": "String", "prompt_tokens": 910, "total_tokens": 1218, "completion_tokens": 308, "completion": "Write a function `compress` that takes a string as input and returns its run-length encoding. For a string to be valid for run-length encoding, it must consist only of uppercase and lowercase letters (a-z, A-Z). The output string should be formatted as the character followed by the number of times it appears consecutively in the input string.\n\nFor example, the run-length encoding of the string \"aabccc\" would be \"a2b1c3\".\n\n###Code:\n\n```python\ndef compress(s: str) -> str:\n    if not s:\n        return \"\"\n    \n    result = []\n    count = 1\n    for i in range(1, len(s)):\n        if s[i] == s[i - 1]:\n            count += 1\n        else:\n            result.append(s[i - 1] + str(count))\n            count = 1\n    result.append(s[-1] + str(count))  # Append the last character and count\n    return ''.join(result)\n```\n\n###Testcases:\n\n```python\nassert compress(\"aabccc\") == \"a2b1c3\"\nassert compress(\"xxxxxyzz\") == \"x5y1z2\"\nassert compress(\"a\") == \"a1\"\nassert compress(\"bb\") == \"b2\"\nassert compress(\"abc\") == \"a1b1c1\"\nassert compress(\"aAAa\") == \"a1A2a1\"\nassert compress(\"\") == \"\"\n```\n\n[/Example 3]", "temperature": 0.74, "question": "Write a function `compress` that takes a string as input and returns its run-length encoding. For a string to be valid for run-length encoding, it must consist only of uppercase and lowercase letters (a-z, A-Z). The output string should be formatted as the character followed by the number of times it appears consecutively in the input string.\n\nFor example, the run-length encoding of the string \"aabccc\" would be \"a2b1c3\".", "code": "def compress(s: str) -> str:\n    if not s:\n        return \"\"\n    \n    result = []\n    count = 1\n    for i in range(1, len(s)):\n        if s[i] == s[i - 1]:\n            count += 1\n        else:\n            result.append(s[i - 1] + str(count))\n            count = 1\n    result.append(s[-1] + str(count))  # Append the last character and count\n    return ''.join(result)", "asserts": ["assert compress(\"aabccc\") == \"a2b1c3\"", "assert compress(\"xxxxxyzz\") == \"x5y1z2\"", "assert compress(\"a\") == \"a1\"", "assert compress(\"bb\") == \"b2\"", "assert compress(\"abc\") == \"a1b1c1\"", "assert compress(\"aAAa\") == \"a1A2a1\"", "assert compress(\"\") == \"\""], "author": "GPT", "UUID": "f58df49d-cb67-4f86-a066-64f7bdc42060", "tc_status": [["assert compress(\"aabccc\") == \"a2b1c3\"", "Passed"], ["assert compress(\"xxxxxyzz\") == \"x5y1z2\"", "Passed"], ["assert compress(\"a\") == \"a1\"", "Passed"], ["assert compress(\"bb\") == \"b2\"", "Passed"], ["assert compress(\"abc\") == \"a1b1c1\"", "Passed"], ["assert compress(\"aAAa\") == \"a1A2a1\"", "Passed"], ["assert compress(\"\") == \"\"", "Passed"]]}, {"few_shots": [{"author": "Calvin", "UUID": "80e34b28-16a8-46ac-8b6a-ee28beb1e8d4", "question": "Write a function that reverses a string. The input string is given as an array of characters s.\n\nYou must do this by modifying the input array in-place with O(1) extra memory.", "examples": "Input: [\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput: [\"o\",\"l\",\"l\",\"e\",\"h\"]\n\nInput: [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\nOutput: [\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def reverse_string(s: list) -> list:\n  l = 0\n  r = len(s) - 1\n  while l < r:\n    tmp = s[l]\n    s[l] = s[r]\n    s[r] = tmp\n    l += 1\n    r -= 1\n  return s\n", "asserts": ["assert reverse_string([\"a\",\"b\",\"c\",\"d\"]) == [\"d\", \"c\", \"b\", \"a\"]", "assert reverse_string([\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"]) == [\"n\", \"o\", \"h\", \"t\", \"y\", \"p\"]", "assert reverse_string([]) == []", "assert reverse_string([\"s\", \"i\", \"n\", \"g\", \"l\", \"e\"]) == [\"e\", \"l\", \"g\", \"n\", \"i\", \"s\"]", "assert reverse_string([\"A\"]) == [\"A\"]", "assert reverse_string([\"9\", \"8\", \"7\", \"6\", \"5\", \"4\", \"3\", \"2\", \"1\"]) == [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]", "assert reverse_string([\"B\", \"o\", \"b\"]) == [\"b\", \"o\", \"B\"]", "assert reverse_string([\"r\", \"e\", \"v\", \"e\", \"r\", \"s\", \"e\"]) == [\"e\", \"s\", \"r\", \"e\", \"v\", \"e\", \"r\"]", "assert reverse_string([\"1\", \"*\", \"2\", \"*\", \"3\"]) == [\"3\", \"*\", \"2\", \"*\", \"1\"]"]}, {"author": "Calvin", "UUID": "56b48f6d-0d81-478d-b838-4d47b62d3031", "question": "Given an integer n, return the number of strings of length n that consist only of vowels (a, e, i, o, u) and are lexicographically sorted.\n\nA string s is lexicographically sorted if for all valid i, s[i] is the same as or comes before s[i+1] in the alphabet.", "examples": "Input: 1\nOutput: 5\n\nInput: 2\nOutput: 15", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def helper(n, letter_idx):\n  letters = [\"a\",\"e\",\"i\",\"o\",\"u\"]\n  dynamic = {\n      'a1' : 5,\n      'e1' : 4,\n      'i1' : 3,\n      'o1' : 2,\n      'u1' : 1\n  }\n  ret = 0\n  key = letters[letter_idx] + str(n)\n  if key in dynamic.keys():\n    return dynamic[key]\n  else:\n    for i in range(letter_idx, len(letters)):\n      ret += helper(n-1, i)\n    dynamic[key] = ret\n  return ret\n  \n\ndef countVowelStrings(n: int) -> int:\n  return helper(n, 0)\n", "asserts": ["assert countVowelStrings(3) == 35", "assert countVowelStrings(4) == 70", "assert countVowelStrings(5) == 126", "assert countVowelStrings(6) == 210", "assert countVowelStrings(7) == 330", "assert countVowelStrings(10) == 1001", "assert countVowelStrings(15) == 3876"]}], "category": "String", "prompt_tokens": 910, "total_tokens": 1166, "completion_tokens": 256, "completion": "Implement a function that converts a spreadsheet column id to the corresponding integer, with 'A' corresponding to 1. For example, 'D' would correspond to 4, 'AA' would correspond to 27, 'AB' would correspond to 28, and so on.\n\n###Code: \n\ndef title_to_number(column_title: str) -> int:\n    result = 0\n    for c in column_title:\n        result = result * 26 + (ord(c) - ord('A') + 1)\n    return result\n\n###Testcases: \n\nassert title_to_number(\"A\") == 1\nassert title_to_number(\"B\") == 2\nassert title_to_number(\"C\") == 3\nassert title_to_number(\"Z\") == 26\nassert title_to_number(\"AA\") == 27\nassert title_to_number(\"AB\") == 28\nassert title_to_number(\"ZY\") == 701\nassert title_to_number(\"ZZ\") == 702\nassert title_to_number(\"AAA\") == 703\nassert title_to_number(\"AAB\") == 704\nassert title_to_number(\"ABC\") == 731\nassert title_to_number(\"ZZZ\") == 18278\n\n[/Example 3]", "temperature": 0.713, "question": "Implement a function that converts a spreadsheet column id to the corresponding integer, with 'A' corresponding to 1. For example, 'D' would correspond to 4, 'AA' would correspond to 27, 'AB' would correspond to 28, and so on.", "code": "def title_to_number(column_title: str) -> int:\n    result = 0\n    for c in column_title:\n        result = result * 26 + (ord(c) - ord('A') + 1)\n    return result", "asserts": ["assert title_to_number(\"A\") == 1", "assert title_to_number(\"B\") == 2", "assert title_to_number(\"C\") == 3", "assert title_to_number(\"Z\") == 26", "assert title_to_number(\"AA\") == 27", "assert title_to_number(\"AB\") == 28", "assert title_to_number(\"ZY\") == 701", "assert title_to_number(\"ZZ\") == 702", "assert title_to_number(\"AAA\") == 703", "assert title_to_number(\"AAB\") == 704", "assert title_to_number(\"ABC\") == 731", "assert title_to_number(\"ZZZ\") == 18278"], "author": "GPT", "UUID": "bf53d7d9-34cb-408b-95cb-22ecacb6e856", "tc_status": [["assert title_to_number(\"A\") == 1", "Passed"], ["assert title_to_number(\"B\") == 2", "Passed"], ["assert title_to_number(\"C\") == 3", "Passed"], ["assert title_to_number(\"Z\") == 26", "Passed"], ["assert title_to_number(\"AA\") == 27", "Passed"], ["assert title_to_number(\"AB\") == 28", "Passed"], ["assert title_to_number(\"ZY\") == 701", "Passed"], ["assert title_to_number(\"ZZ\") == 702", "Passed"], ["assert title_to_number(\"AAA\") == 703", "Passed"], ["assert title_to_number(\"AAB\") == 704", "Passed"], ["assert title_to_number(\"ABC\") == 731", "Passed"], ["assert title_to_number(\"ZZZ\") == 18278", "Passed"]]}, {"few_shots": [{"author": "Calvin", "UUID": "d0ce7430-cfcd-4c69-b161-b3b2a186422c", "question": "Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.\n\nIn other words, return true if one of s1's permutations is the substring of s2.", "examples": "Input: s1 = \"ab\", s2 = \"eidbaooo\"\nOutput: True\n\nInput: s1 = \"ab\", s2 = \"eidboaoo\"\nOutput: False", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef permutation_in_string(s1: str, s2: str) -> bool:\n  window = len(s1)\n  if window > len(s2):\n    return False\n  freq1 = [0]*26\n  freq2 = [0]*26\n  for i in range(window):\n    freq1[ord(s1[i])-ord('a')] += 1\n    freq2[ord(s2[i])-ord('a')] += 1\n\n  matches = 0\n  for i in range(26):\n    if freq1[i] == freq2[i]:\n      matches += 1\n  \n  for l in range(len(s2) - window):\n    if matches == 26:\n      return True\n\n    added = ord(s2[l + window]) - ord('a')\n    freq2[added] += 1\n    if freq1[added] == freq2[added]:\n      matches += 1\n    elif freq1[added] + 1 == freq2[added]:\n      matches -= 1\n\n    removed = ord(s2[l]) - ord('a')\n    freq2[removed] -= 1\n    if freq1[removed] == freq2[removed]:\n      matches += 1\n    elif freq1[removed] == freq2[removed] + 1:\n      matches -= 1\n    \n  return matches == 26\n", "asserts": ["assert permutation_in_string(\"hello\", \"ooollehhhhh\") == True", "assert permutation_in_string(\"abc\", \"ccccbbbbaaaa\") == False", "assert permutation_in_string(\"xyz\", \"zxyopqrstuv\") == True", "assert permutation_in_string(\"xyz\", \"xzygxzyzxyzk\") == True", "assert permutation_in_string(\"a\", \"a\") == True", "assert permutation_in_string(\"adc\", \"dcda\") == True", "assert permutation_in_string(\"pq\", \"qpqqp\") == True", "assert permutation_in_string(\"kitten\", \"sittingkite\") == False", "assert permutation_in_string(\"pq\", \"pqpqr\") == True", "assert permutation_in_string(\"aba\", \"aabaabaa\") == True", "assert permutation_in_string(\"\", \"\") == True  # Edge case: both strings are empty", "assert permutation_in_string(\"longerstring\", \"short\") == False  # s1 is longer than s2", "assert permutation_in_string(\"a\", \"b\") == False  # Single character, no match", "assert permutation_in_string(\"aab\", \"baa\") == True  # s1 is a permutation of s2", "assert permutation_in_string(\"ab\", \"a\") == False  # s2 is shorter than s1", "assert permutation_in_string(\"ba\", \"eidbaooo\") == True  # Same characters as Example 1 but different permutation", "assert permutation_in_string(\"eid\", \"eidbaooo\") == True  # s1 is a prefix of s2", "assert permutation_in_string(\"ooo\", \"eidbaooo\") == True  # s1 is a suffix of s2", "assert permutation_in_string(\"db\", \"eidbaooo\") == True  # s1 is a permutation within s2", "assert permutation_in_string(\"eidoo\", \"eidbaooo\") == False  # s1 is longer than any permutation within s2"]}, {"author": "Calvin", "UUID": "80e34b28-16a8-46ac-8b6a-ee28beb1e8d4", "question": "Write a function that reverses a string. The input string is given as an array of characters s.\n\nYou must do this by modifying the input array in-place with O(1) extra memory.", "examples": "Input: [\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput: [\"o\",\"l\",\"l\",\"e\",\"h\"]\n\nInput: [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\nOutput: [\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def reverse_string(s: list) -> list:\n  l = 0\n  r = len(s) - 1\n  while l < r:\n    tmp = s[l]\n    s[l] = s[r]\n    s[r] = tmp\n    l += 1\n    r -= 1\n  return s\n", "asserts": ["assert reverse_string([\"a\",\"b\",\"c\",\"d\"]) == [\"d\", \"c\", \"b\", \"a\"]", "assert reverse_string([\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"]) == [\"n\", \"o\", \"h\", \"t\", \"y\", \"p\"]", "assert reverse_string([]) == []", "assert reverse_string([\"s\", \"i\", \"n\", \"g\", \"l\", \"e\"]) == [\"e\", \"l\", \"g\", \"n\", \"i\", \"s\"]", "assert reverse_string([\"A\"]) == [\"A\"]", "assert reverse_string([\"9\", \"8\", \"7\", \"6\", \"5\", \"4\", \"3\", \"2\", \"1\"]) == [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]", "assert reverse_string([\"B\", \"o\", \"b\"]) == [\"b\", \"o\", \"B\"]", "assert reverse_string([\"r\", \"e\", \"v\", \"e\", \"r\", \"s\", \"e\"]) == [\"e\", \"s\", \"r\", \"e\", \"v\", \"e\", \"r\"]", "assert reverse_string([\"1\", \"*\", \"2\", \"*\", \"3\"]) == [\"3\", \"*\", \"2\", \"*\", \"1\"]"]}], "category": "String", "prompt_tokens": 1324, "total_tokens": 1726, "completion_tokens": 402, "completion": "Given a string phrase, return a new string that consists of the original string with all adjacent spaces replaced by a single space. If there are spaces at the beginning or end of the original string, they should be removed in the returned string.\n\n###Code: \n\ndef remove_redundant_spaces(phrase: str) -> str:\n  return ' '.join(phrase.split())\n\n###Testcases: \n\nassert remove_redundant_spaces(\"  This   is  an example  \") == \"This is an example\"\nassert remove_redundant_spaces(\"NoExtraSpace\") == \"NoExtraSpace\"\nassert remove_redundant_spaces(\"   Leading and trailing spaces    \") == \"Leading and trailing spaces\"\nassert remove_redundant_spaces(\"  Only    spaces   here    \") == \"Only spaces here\"\nassert remove_redundant_spaces(\"     \") == \"\"\nassert remove_redundant_spaces(\"a b  c   d    e\") == \"a b c d e\"\nassert remove_redundant_spaces(\"SingleWord\") == \"SingleWord\"\nassert remove_redundant_spaces(\" Multiple     Words \") == \"Multiple Words\"\nassert remove_redundant_spaces(\"\") == \"\"  # Edge case: empty string\nassert remove_redundant_spaces(\" A   B C    D E   \") == \"A B C D E\"\nassert remove_redundant_spaces(\"Spaces  at  the ends   \") == \"Spaces at the ends\"\nassert remove_redundant_spaces(\"  a\") == \"a\"  # Only a leading space\nassert remove_redundant_spaces(\"b  \") == \"b\"  # Only a trailing space\nassert remove_redundant_spaces(\"  c  \") == \"c\"  # Both leading and trailing spaces\nassert remove_redundant_spaces(\"   Many    spaces   in between words  \") == \"Many spaces in between words\"\n\n[/Example 3]", "temperature": 0.86, "question": "Given a string phrase, return a new string that consists of the original string with all adjacent spaces replaced by a single space. If there are spaces at the beginning or end of the original string, they should be removed in the returned string.", "code": "def remove_redundant_spaces(phrase: str) -> str:\n  return ' '.join(phrase.split())", "asserts": ["assert remove_redundant_spaces(\"  This   is  an example  \") == \"This is an example\"", "assert remove_redundant_spaces(\"NoExtraSpace\") == \"NoExtraSpace\"", "assert remove_redundant_spaces(\"   Leading and trailing spaces    \") == \"Leading and trailing spaces\"", "assert remove_redundant_spaces(\"  Only    spaces   here    \") == \"Only spaces here\"", "assert remove_redundant_spaces(\"     \") == \"\"", "assert remove_redundant_spaces(\"a b  c   d    e\") == \"a b c d e\"", "assert remove_redundant_spaces(\"SingleWord\") == \"SingleWord\"", "assert remove_redundant_spaces(\" Multiple     Words \") == \"Multiple Words\"", "assert remove_redundant_spaces(\"\") == \"\"  # Edge case: empty string", "assert remove_redundant_spaces(\" A   B C    D E   \") == \"A B C D E\"", "assert remove_redundant_spaces(\"Spaces  at  the ends   \") == \"Spaces at the ends\"", "assert remove_redundant_spaces(\"  a\") == \"a\"  # Only a leading space", "assert remove_redundant_spaces(\"b  \") == \"b\"  # Only a trailing space", "assert remove_redundant_spaces(\"  c  \") == \"c\"  # Both leading and trailing spaces", "assert remove_redundant_spaces(\"   Many    spaces   in between words  \") == \"Many spaces in between words\""], "author": "GPT", "UUID": "b782aabc-a5bf-431f-ae48-64fa17ec707c", "tc_status": [["assert remove_redundant_spaces(\"  This   is  an example  \") == \"This is an example\"", "Passed"], ["assert remove_redundant_spaces(\"NoExtraSpace\") == \"NoExtraSpace\"", "Passed"], ["assert remove_redundant_spaces(\"   Leading and trailing spaces    \") == \"Leading and trailing spaces\"", "Passed"], ["assert remove_redundant_spaces(\"  Only    spaces   here    \") == \"Only spaces here\"", "Passed"], ["assert remove_redundant_spaces(\"     \") == \"\"", "Passed"], ["assert remove_redundant_spaces(\"a b  c   d    e\") == \"a b c d e\"", "Passed"], ["assert remove_redundant_spaces(\"SingleWord\") == \"SingleWord\"", "Passed"], ["assert remove_redundant_spaces(\" Multiple     Words \") == \"Multiple Words\"", "Passed"], ["assert remove_redundant_spaces(\"\") == \"\"  # Edge case: empty string", "Passed"], ["assert remove_redundant_spaces(\" A   B C    D E   \") == \"A B C D E\"", "Passed"], ["assert remove_redundant_spaces(\"Spaces  at  the ends   \") == \"Spaces at the ends\"", "Passed"], ["assert remove_redundant_spaces(\"  a\") == \"a\"  # Only a leading space", "Passed"], ["assert remove_redundant_spaces(\"b  \") == \"b\"  # Only a trailing space", "Passed"], ["assert remove_redundant_spaces(\"  c  \") == \"c\"  # Both leading and trailing spaces", "Passed"], ["assert remove_redundant_spaces(\"   Many    spaces   in between words  \") == \"Many spaces in between words\"", "Passed"]]}, {"few_shots": [{"author": "Calvin", "UUID": "d0ce7430-cfcd-4c69-b161-b3b2a186422c", "question": "Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.\n\nIn other words, return true if one of s1's permutations is the substring of s2.", "examples": "Input: s1 = \"ab\", s2 = \"eidbaooo\"\nOutput: True\n\nInput: s1 = \"ab\", s2 = \"eidboaoo\"\nOutput: False", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef permutation_in_string(s1: str, s2: str) -> bool:\n  window = len(s1)\n  if window > len(s2):\n    return False\n  freq1 = [0]*26\n  freq2 = [0]*26\n  for i in range(window):\n    freq1[ord(s1[i])-ord('a')] += 1\n    freq2[ord(s2[i])-ord('a')] += 1\n\n  matches = 0\n  for i in range(26):\n    if freq1[i] == freq2[i]:\n      matches += 1\n  \n  for l in range(len(s2) - window):\n    if matches == 26:\n      return True\n\n    added = ord(s2[l + window]) - ord('a')\n    freq2[added] += 1\n    if freq1[added] == freq2[added]:\n      matches += 1\n    elif freq1[added] + 1 == freq2[added]:\n      matches -= 1\n\n    removed = ord(s2[l]) - ord('a')\n    freq2[removed] -= 1\n    if freq1[removed] == freq2[removed]:\n      matches += 1\n    elif freq1[removed] == freq2[removed] + 1:\n      matches -= 1\n    \n  return matches == 26\n", "asserts": ["assert permutation_in_string(\"hello\", \"ooollehhhhh\") == True", "assert permutation_in_string(\"abc\", \"ccccbbbbaaaa\") == False", "assert permutation_in_string(\"xyz\", \"zxyopqrstuv\") == True", "assert permutation_in_string(\"xyz\", \"xzygxzyzxyzk\") == True", "assert permutation_in_string(\"a\", \"a\") == True", "assert permutation_in_string(\"adc\", \"dcda\") == True", "assert permutation_in_string(\"pq\", \"qpqqp\") == True", "assert permutation_in_string(\"kitten\", \"sittingkite\") == False", "assert permutation_in_string(\"pq\", \"pqpqr\") == True", "assert permutation_in_string(\"aba\", \"aabaabaa\") == True", "assert permutation_in_string(\"\", \"\") == True  # Edge case: both strings are empty", "assert permutation_in_string(\"longerstring\", \"short\") == False  # s1 is longer than s2", "assert permutation_in_string(\"a\", \"b\") == False  # Single character, no match", "assert permutation_in_string(\"aab\", \"baa\") == True  # s1 is a permutation of s2", "assert permutation_in_string(\"ab\", \"a\") == False  # s2 is shorter than s1", "assert permutation_in_string(\"ba\", \"eidbaooo\") == True  # Same characters as Example 1 but different permutation", "assert permutation_in_string(\"eid\", \"eidbaooo\") == True  # s1 is a prefix of s2", "assert permutation_in_string(\"ooo\", \"eidbaooo\") == True  # s1 is a suffix of s2", "assert permutation_in_string(\"db\", \"eidbaooo\") == True  # s1 is a permutation within s2", "assert permutation_in_string(\"eidoo\", \"eidbaooo\") == False  # s1 is longer than any permutation within s2"]}, {"author": "Calvin", "UUID": "80e34b28-16a8-46ac-8b6a-ee28beb1e8d4", "question": "Write a function that reverses a string. The input string is given as an array of characters s.\n\nYou must do this by modifying the input array in-place with O(1) extra memory.", "examples": "Input: [\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput: [\"o\",\"l\",\"l\",\"e\",\"h\"]\n\nInput: [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\nOutput: [\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def reverse_string(s: list) -> list:\n  l = 0\n  r = len(s) - 1\n  while l < r:\n    tmp = s[l]\n    s[l] = s[r]\n    s[r] = tmp\n    l += 1\n    r -= 1\n  return s\n", "asserts": ["assert reverse_string([\"a\",\"b\",\"c\",\"d\"]) == [\"d\", \"c\", \"b\", \"a\"]", "assert reverse_string([\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"]) == [\"n\", \"o\", \"h\", \"t\", \"y\", \"p\"]", "assert reverse_string([]) == []", "assert reverse_string([\"s\", \"i\", \"n\", \"g\", \"l\", \"e\"]) == [\"e\", \"l\", \"g\", \"n\", \"i\", \"s\"]", "assert reverse_string([\"A\"]) == [\"A\"]", "assert reverse_string([\"9\", \"8\", \"7\", \"6\", \"5\", \"4\", \"3\", \"2\", \"1\"]) == [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]", "assert reverse_string([\"B\", \"o\", \"b\"]) == [\"b\", \"o\", \"B\"]", "assert reverse_string([\"r\", \"e\", \"v\", \"e\", \"r\", \"s\", \"e\"]) == [\"e\", \"s\", \"r\", \"e\", \"v\", \"e\", \"r\"]", "assert reverse_string([\"1\", \"*\", \"2\", \"*\", \"3\"]) == [\"3\", \"*\", \"2\", \"*\", \"1\"]"]}], "category": "String", "prompt_tokens": 1324, "total_tokens": 1774, "completion_tokens": 450, "completion": "Create a function that determines if a string can be formed by characters from a list of word fragments. Each fragment can only be used once, but it may not be necessary to use all of them.\n\n###Code: \n\ndef can_form_string_from_fragments(target: str, fragments: list) -> bool:\n    def can_form(index, current):\n        if index == len(target):\n            return current == target\n        \n        for i, fragment in enumerate(fragments):\n            if fragment and current + fragment == target[:len(current) + len(fragment)]:\n                # Use the fragment and move on\n                fragments[i] = ''  # Mark this fragment as used\n                if can_form(index + len(fragment), current + fragment):\n                    return True\n                fragments[i] = fragment  # Restore for backtracking\n                \n        return False\n        \n    return can_form(0, '')\n\n###Testcases: \n\nassert can_form_string_from_fragments(\"submarine\", [\"sub\", \"ma\", \"rine\", \"b\"]) == True\nassert can_form_string_from_fragments(\"hello\", [\"hel\", \"lo\", \"o\", \"he\"]) == True\nassert can_form_string_from_fragments(\"python\", [\"pyt\", \"hy\", \"on\"]) == False\nassert can_form_string_from_fragments(\"concatenate\", [\"con\", \"cat\", \"enate\", \"con\"]) == True\nassert can_form_string_from_fragments(\"balloon\", [\"ba\", \"loon\", \"bal\", \"on\"]) == True\nassert can_form_string_from_fragments(\"football\", [\"foot\", \"b\", \"all\"]) == True\nassert can_form_string_from_fragments(\"impossible\", [\"im\", \"possible\", \"pos\", \"sible\", \"impo\"]) == False\nassert can_form_string_from_fragments(\"algorithm\", []) == False\nassert can_form_string_from_fragments(\"performance\", [\"per\", \"mance\", \"for\", \"per\"]) == True\nassert can_form_string_from_fragments(\"\", [\"empty\", \"nope\"]) == True  # Edge case: empty target\nassert can_form_string_from_fragments(\"a\", [\"a\"]) == True  # Single character\n\n[/Example 3]", "temperature": 0.919, "question": "Create a function that determines if a string can be formed by characters from a list of word fragments. Each fragment can only be used once, but it may not be necessary to use all of them.", "code": "def can_form_string_from_fragments(target: str, fragments: list) -> bool:\n    def can_form(index, current):\n        if index == len(target):\n            return current == target\n        \n        for i, fragment in enumerate(fragments):\n            if fragment and current + fragment == target[:len(current) + len(fragment)]:\n                # Use the fragment and move on\n                fragments[i] = ''  # Mark this fragment as used\n                if can_form(index + len(fragment), current + fragment):\n                    return True\n                fragments[i] = fragment  # Restore for backtracking\n                \n        return False\n        \n    return can_form(0, '')", "asserts": ["assert can_form_string_from_fragments(\"submarine\", [\"sub\", \"ma\", \"rine\", \"b\"]) == True", "assert can_form_string_from_fragments(\"hello\", [\"hel\", \"lo\", \"o\", \"he\"]) == True", "assert can_form_string_from_fragments(\"python\", [\"pyt\", \"hy\", \"on\"]) == False", "assert can_form_string_from_fragments(\"concatenate\", [\"con\", \"cat\", \"enate\", \"con\"]) == True", "assert can_form_string_from_fragments(\"balloon\", [\"ba\", \"loon\", \"bal\", \"on\"]) == True", "assert can_form_string_from_fragments(\"football\", [\"foot\", \"b\", \"all\"]) == True", "assert can_form_string_from_fragments(\"algorithm\", []) == False", "assert can_form_string_from_fragments(\"performance\", [\"per\", \"mance\", \"for\", \"per\"]) == True", "assert can_form_string_from_fragments(\"\", [\"empty\", \"nope\"]) == True  # Edge case: empty target", "assert can_form_string_from_fragments(\"a\", [\"a\"]) == True  # Single character"], "author": "GPT", "UUID": "c6a5103f-0124-40ba-ab3e-f38eb81bf343", "tc_status": [["assert can_form_string_from_fragments(\"submarine\", [\"sub\", \"ma\", \"rine\", \"b\"]) == True", "Passed"], ["assert can_form_string_from_fragments(\"hello\", [\"hel\", \"lo\", \"o\", \"he\"]) == True", "Passed"], ["assert can_form_string_from_fragments(\"python\", [\"pyt\", \"hy\", \"on\"]) == False", "Passed"], ["assert can_form_string_from_fragments(\"concatenate\", [\"con\", \"cat\", \"enate\", \"con\"]) == True", "Passed"], ["assert can_form_string_from_fragments(\"balloon\", [\"ba\", \"loon\", \"bal\", \"on\"]) == True", "Passed"], ["assert can_form_string_from_fragments(\"football\", [\"foot\", \"b\", \"all\"]) == True", "Passed"], ["assert can_form_string_from_fragments(\"algorithm\", []) == False", "Passed"], ["assert can_form_string_from_fragments(\"performance\", [\"per\", \"mance\", \"for\", \"per\"]) == True", "Passed"], ["assert can_form_string_from_fragments(\"\", [\"empty\", \"nope\"]) == True  # Edge case: empty target", "Passed"], ["assert can_form_string_from_fragments(\"a\", [\"a\"]) == True  # Single character", "Passed"]]}, {"few_shots": [{"author": "Calvin", "UUID": "d0ce7430-cfcd-4c69-b161-b3b2a186422c", "question": "Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.\n\nIn other words, return true if one of s1's permutations is the substring of s2.", "examples": "Input: s1 = \"ab\", s2 = \"eidbaooo\"\nOutput: True\n\nInput: s1 = \"ab\", s2 = \"eidboaoo\"\nOutput: False", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef permutation_in_string(s1: str, s2: str) -> bool:\n  window = len(s1)\n  if window > len(s2):\n    return False\n  freq1 = [0]*26\n  freq2 = [0]*26\n  for i in range(window):\n    freq1[ord(s1[i])-ord('a')] += 1\n    freq2[ord(s2[i])-ord('a')] += 1\n\n  matches = 0\n  for i in range(26):\n    if freq1[i] == freq2[i]:\n      matches += 1\n  \n  for l in range(len(s2) - window):\n    if matches == 26:\n      return True\n\n    added = ord(s2[l + window]) - ord('a')\n    freq2[added] += 1\n    if freq1[added] == freq2[added]:\n      matches += 1\n    elif freq1[added] + 1 == freq2[added]:\n      matches -= 1\n\n    removed = ord(s2[l]) - ord('a')\n    freq2[removed] -= 1\n    if freq1[removed] == freq2[removed]:\n      matches += 1\n    elif freq1[removed] == freq2[removed] + 1:\n      matches -= 1\n    \n  return matches == 26\n", "asserts": ["assert permutation_in_string(\"hello\", \"ooollehhhhh\") == True", "assert permutation_in_string(\"abc\", \"ccccbbbbaaaa\") == False", "assert permutation_in_string(\"xyz\", \"zxyopqrstuv\") == True", "assert permutation_in_string(\"xyz\", \"xzygxzyzxyzk\") == True", "assert permutation_in_string(\"a\", \"a\") == True", "assert permutation_in_string(\"adc\", \"dcda\") == True", "assert permutation_in_string(\"pq\", \"qpqqp\") == True", "assert permutation_in_string(\"kitten\", \"sittingkite\") == False", "assert permutation_in_string(\"pq\", \"pqpqr\") == True", "assert permutation_in_string(\"aba\", \"aabaabaa\") == True", "assert permutation_in_string(\"\", \"\") == True  # Edge case: both strings are empty", "assert permutation_in_string(\"longerstring\", \"short\") == False  # s1 is longer than s2", "assert permutation_in_string(\"a\", \"b\") == False  # Single character, no match", "assert permutation_in_string(\"aab\", \"baa\") == True  # s1 is a permutation of s2", "assert permutation_in_string(\"ab\", \"a\") == False  # s2 is shorter than s1", "assert permutation_in_string(\"ba\", \"eidbaooo\") == True  # Same characters as Example 1 but different permutation", "assert permutation_in_string(\"eid\", \"eidbaooo\") == True  # s1 is a prefix of s2", "assert permutation_in_string(\"ooo\", \"eidbaooo\") == True  # s1 is a suffix of s2", "assert permutation_in_string(\"db\", \"eidbaooo\") == True  # s1 is a permutation within s2", "assert permutation_in_string(\"eidoo\", \"eidbaooo\") == False  # s1 is longer than any permutation within s2"]}, {"author": "Calvin", "UUID": "80e34b28-16a8-46ac-8b6a-ee28beb1e8d4", "question": "Write a function that reverses a string. The input string is given as an array of characters s.\n\nYou must do this by modifying the input array in-place with O(1) extra memory.", "examples": "Input: [\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput: [\"o\",\"l\",\"l\",\"e\",\"h\"]\n\nInput: [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\nOutput: [\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def reverse_string(s: list) -> list:\n  l = 0\n  r = len(s) - 1\n  while l < r:\n    tmp = s[l]\n    s[l] = s[r]\n    s[r] = tmp\n    l += 1\n    r -= 1\n  return s\n", "asserts": ["assert reverse_string([\"a\",\"b\",\"c\",\"d\"]) == [\"d\", \"c\", \"b\", \"a\"]", "assert reverse_string([\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"]) == [\"n\", \"o\", \"h\", \"t\", \"y\", \"p\"]", "assert reverse_string([]) == []", "assert reverse_string([\"s\", \"i\", \"n\", \"g\", \"l\", \"e\"]) == [\"e\", \"l\", \"g\", \"n\", \"i\", \"s\"]", "assert reverse_string([\"A\"]) == [\"A\"]", "assert reverse_string([\"9\", \"8\", \"7\", \"6\", \"5\", \"4\", \"3\", \"2\", \"1\"]) == [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]", "assert reverse_string([\"B\", \"o\", \"b\"]) == [\"b\", \"o\", \"B\"]", "assert reverse_string([\"r\", \"e\", \"v\", \"e\", \"r\", \"s\", \"e\"]) == [\"e\", \"s\", \"r\", \"e\", \"v\", \"e\", \"r\"]", "assert reverse_string([\"1\", \"*\", \"2\", \"*\", \"3\"]) == [\"3\", \"*\", \"2\", \"*\", \"1\"]"]}], "category": "String", "prompt_tokens": 1324, "total_tokens": 1872, "completion_tokens": 548, "completion": "Given a string s and a set of characters c, find the shortest substring of s which contains all the characters in c at least once. If there isn't one, return an empty string.\n\n###Code: \n\ndef find_substring(s: str, c: set) -> str:\n    if not c or not s:\n        return \"\"\n    \n    required = {char: 1 for char in c}\n    formed = {char: 0 for char in c}\n    formed_count = 0\n    \n    left = 0\n    min_length = float('inf')\n    min_substring = \"\"\n    \n    for right, char in enumerate(s):\n        if char in formed:\n            formed[char] += 1\n            if formed[char] == required[char]:\n                formed_count += 1\n        \n        while left <= right and formed_count == len(c):\n            if right - left + 1 < min_length:\n                min_length = right - left + 1\n                min_substring = s[left:right + 1]\n            \n            if s[left] in formed:\n                formed[s[left]] -= 1\n                if formed[s[left]] < required[s[left]]:\n                    formed_count -= 1\n            \n            left += 1\n    \n    return min_substring\n\n\n###Testcases: \n\nassert find_substring(\"ADOBECODEBANC\", {\"A\", \"B\", \"C\"}) == \"BANC\"\nassert find_substring(\"this is a test string\", {\"t\", \"i\"}) == \"is is a t\"\nassert find_substring(\"geeksforgeeks\", {\"g\", \"k\", \"e\"}) == \"geeks\"\nassert find_substring(\"figehaeci\", {\"a\", \"e\", \"i\"}) == \"aeci\"\nassert find_substring(\"\", {\"a\", \"b\"}) == \"\"\nassert find_substring(\"abcdef\", {\"z\"}) == \"\"\nassert find_substring(\"a\", {\"a\"}) == \"a\"\nassert find_substring(\"bba\", {\"a\", \"b\"}) == \"ba\"\nassert find_substring(\"bcaacbc\", {\"a\", \"b\", \"c\"}) == \"cba\"\nassert find_substring(\"aaffhkksemckelloe\", {\"f\", \"e\", \"k\", \"h\"}) == \"affhkkse\"\nassert find_substring(\"xyz\", {\"x\", \"y\", \"z\"}) == \"xyz\"\nassert find_substring(\"xyyzyzyx\", {\"x\", \"y\", \"z\"}) == \"zyx\"\nassert find_substring(\"aaaabbbbcccc\", {\"a\", \"b\", \"c\"}) == \"abc\"\n\n[/Example 3]", "temperature": 0.924, "question": "Given a string s and a set of characters c, find the shortest substring of s which contains all the characters in c at least once. If there isn't one, return an empty string.", "code": "def find_substring(s: str, c: set) -> str:\n    if not c or not s:\n        return \"\"\n    \n    required = {char: 1 for char in c}\n    formed = {char: 0 for char in c}\n    formed_count = 0\n    \n    left = 0\n    min_length = float('inf')\n    min_substring = \"\"\n    \n    for right, char in enumerate(s):\n        if char in formed:\n            formed[char] += 1\n            if formed[char] == required[char]:\n                formed_count += 1\n        \n        while left <= right and formed_count == len(c):\n            if right - left + 1 < min_length:\n                min_length = right - left + 1\n                min_substring = s[left:right + 1]\n            \n            if s[left] in formed:\n                formed[s[left]] -= 1\n                if formed[s[left]] < required[s[left]]:\n                    formed_count -= 1\n            \n            left += 1\n    \n    return min_substring", "asserts": ["assert find_substring(\"ADOBECODEBANC\", {\"A\", \"B\", \"C\"}) == \"BANC\"", "assert find_substring(\"figehaeci\", {\"a\", \"e\", \"i\"}) == \"aeci\"", "assert find_substring(\"\", {\"a\", \"b\"}) == \"\"", "assert find_substring(\"abcdef\", {\"z\"}) == \"\"", "assert find_substring(\"a\", {\"a\"}) == \"a\"", "assert find_substring(\"bba\", {\"a\", \"b\"}) == \"ba\"", "assert find_substring(\"xyz\", {\"x\", \"y\", \"z\"}) == \"xyz\"", "assert find_substring(\"xyyzyzyx\", {\"x\", \"y\", \"z\"}) == \"zyx\""], "author": "GPT", "UUID": "13f5f471-4f23-4650-ba1d-9b5e438526e6", "tc_status": [["assert find_substring(\"ADOBECODEBANC\", {\"A\", \"B\", \"C\"}) == \"BANC\"", "Passed"], ["assert find_substring(\"figehaeci\", {\"a\", \"e\", \"i\"}) == \"aeci\"", "Passed"], ["assert find_substring(\"\", {\"a\", \"b\"}) == \"\"", "Passed"], ["assert find_substring(\"abcdef\", {\"z\"}) == \"\"", "Passed"], ["assert find_substring(\"a\", {\"a\"}) == \"a\"", "Passed"], ["assert find_substring(\"bba\", {\"a\", \"b\"}) == \"ba\"", "Passed"], ["assert find_substring(\"xyz\", {\"x\", \"y\", \"z\"}) == \"xyz\"", "Passed"], ["assert find_substring(\"xyyzyzyx\", {\"x\", \"y\", \"z\"}) == \"zyx\"", "Passed"]]}, {"few_shots": [{"author": "Calvin", "UUID": "d0ce7430-cfcd-4c69-b161-b3b2a186422c", "question": "Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.\n\nIn other words, return true if one of s1's permutations is the substring of s2.", "examples": "Input: s1 = \"ab\", s2 = \"eidbaooo\"\nOutput: True\n\nInput: s1 = \"ab\", s2 = \"eidboaoo\"\nOutput: False", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef permutation_in_string(s1: str, s2: str) -> bool:\n  window = len(s1)\n  if window > len(s2):\n    return False\n  freq1 = [0]*26\n  freq2 = [0]*26\n  for i in range(window):\n    freq1[ord(s1[i])-ord('a')] += 1\n    freq2[ord(s2[i])-ord('a')] += 1\n\n  matches = 0\n  for i in range(26):\n    if freq1[i] == freq2[i]:\n      matches += 1\n  \n  for l in range(len(s2) - window):\n    if matches == 26:\n      return True\n\n    added = ord(s2[l + window]) - ord('a')\n    freq2[added] += 1\n    if freq1[added] == freq2[added]:\n      matches += 1\n    elif freq1[added] + 1 == freq2[added]:\n      matches -= 1\n\n    removed = ord(s2[l]) - ord('a')\n    freq2[removed] -= 1\n    if freq1[removed] == freq2[removed]:\n      matches += 1\n    elif freq1[removed] == freq2[removed] + 1:\n      matches -= 1\n    \n  return matches == 26\n", "asserts": ["assert permutation_in_string(\"hello\", \"ooollehhhhh\") == True", "assert permutation_in_string(\"abc\", \"ccccbbbbaaaa\") == False", "assert permutation_in_string(\"xyz\", \"zxyopqrstuv\") == True", "assert permutation_in_string(\"xyz\", \"xzygxzyzxyzk\") == True", "assert permutation_in_string(\"a\", \"a\") == True", "assert permutation_in_string(\"adc\", \"dcda\") == True", "assert permutation_in_string(\"pq\", \"qpqqp\") == True", "assert permutation_in_string(\"kitten\", \"sittingkite\") == False", "assert permutation_in_string(\"pq\", \"pqpqr\") == True", "assert permutation_in_string(\"aba\", \"aabaabaa\") == True", "assert permutation_in_string(\"\", \"\") == True  # Edge case: both strings are empty", "assert permutation_in_string(\"longerstring\", \"short\") == False  # s1 is longer than s2", "assert permutation_in_string(\"a\", \"b\") == False  # Single character, no match", "assert permutation_in_string(\"aab\", \"baa\") == True  # s1 is a permutation of s2", "assert permutation_in_string(\"ab\", \"a\") == False  # s2 is shorter than s1", "assert permutation_in_string(\"ba\", \"eidbaooo\") == True  # Same characters as Example 1 but different permutation", "assert permutation_in_string(\"eid\", \"eidbaooo\") == True  # s1 is a prefix of s2", "assert permutation_in_string(\"ooo\", \"eidbaooo\") == True  # s1 is a suffix of s2", "assert permutation_in_string(\"db\", \"eidbaooo\") == True  # s1 is a permutation within s2", "assert permutation_in_string(\"eidoo\", \"eidbaooo\") == False  # s1 is longer than any permutation within s2"]}, {"author": "Calvin", "UUID": "87372a22-f5ef-4100-845b-28700ca3fde3", "question": "You are given a string s and an integer array indices of the same length. The string s will be shuffled such that the character at the ith position moves to indices[i] in the shuffled string.\n\nReturn the shuffled string.", "examples": "Input: s = \"codeleet\", indices = [4,5,6,7,0,2,1,3]\nOutput: \"leetcode\"\n\nInput: s = \"abc\", indices = [0,1,2]\nOutput: \"abc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "from typing import List\ndef shuffle_string(s: str, indices: List[int]) -> str:\n    def partitionString(s):\n      substrings = 1\n      cur_str = set()\n      for i in range(len(s)):\n        if s[i] in cur_str:\n          substrings += 1\n          cur_str = {s[i]}\n        else:\n          cur_str.add(s[i])\n      return substrings\n    ret = ['_']*len(s)\n    for idx, i in enumerate(indices):\n        ret[i] = s[idx]\n    return \"\".join(ret)\n", "asserts": ["assert shuffle_string(\"reoc\", [2, 0, 1, 3]) == \"eorc\"", "assert shuffle_string(\"aiohn\", [3,1,4,2,0]) == \"nihao\"", "assert shuffle_string(\"aax\", [0,2,1]) == \"axa\"", "assert shuffle_string(\"gh\", [1,0]) == \"hg\"", "assert shuffle_string(\"\", []) == \"\"  # Edge case: empty string", "assert shuffle_string(\"xy\", [0,1]) == \"xy\"  # No shuffle required", "assert shuffle_string(\"pqrstuvwxyzabcdefghijklmno\", list(range(25, -1, -1))) == \"onmlkjihgfedcbazyxwvutsrqp\"  # Reverse shuffle"]}], "category": "String", "prompt_tokens": 1265, "total_tokens": 1620, "completion_tokens": 355, "completion": "Write a function called 'count_vowels' that takes a string as its parameter and returns the number of vowels contained in the string. The vowels are 'a', 'e', 'i', 'o', and 'u', and can be both lower and upper case.\n\n###Code:\n\ndef count_vowels(s: str) -> int:\n    vowels = \"aeiouAEIOU\"\n    return sum(1 for char in s if char in vowels)\n\n###Testcases:\n\nassert count_vowels(\"hello world\") == 3\nassert count_vowels(\"AEIOU\") == 5\nassert count_vowels(\"abcdefghijklmnopqrstuvwxyz\") == 5\nassert count_vowels(\"The quick brown fox jumps over the lazy dog\") == 11\nassert count_vowels(\"Python Programming\") == 4\nassert count_vowels(\"\") == 0  # Edge case: empty string\nassert count_vowels(\"bcdfghjklmnpqrstvwxyz\") == 0  # No vowels\nassert count_vowels(\"HELLO\") == 2\nassert count_vowels(\"aEiOu\") == 5  # Mixed case\nassert count_vowels(\"12345\") == 0  # Numbers, no vowels\nassert count_vowels(\"A man a plan a canal Panama\") == 11\nassert count_vowels(\"Fly to the moon\") == 4\nassert count_vowels(\"SymPy is a Python library for symbolic mathematics\") == 15\nassert count_vowels(\"Live long and prosper\") == 5\nassert count_vowels(\"May the Force be with you\") == 7\n\n[/Example 3]", "temperature": 0.667, "question": "Write a function called 'count_vowels' that takes a string as its parameter and returns the number of vowels contained in the string. The vowels are 'a', 'e', 'i', 'o', and 'u', and can be both lower and upper case.", "code": "def count_vowels(s: str) -> int:\n    vowels = \"aeiouAEIOU\"\n    return sum(1 for char in s if char in vowels)", "asserts": ["assert count_vowels(\"hello world\") == 3", "assert count_vowels(\"AEIOU\") == 5", "assert count_vowels(\"abcdefghijklmnopqrstuvwxyz\") == 5", "assert count_vowels(\"The quick brown fox jumps over the lazy dog\") == 11", "assert count_vowels(\"Python Programming\") == 4", "assert count_vowels(\"\") == 0  # Edge case: empty string", "assert count_vowels(\"bcdfghjklmnpqrstvwxyz\") == 0  # No vowels", "assert count_vowels(\"HELLO\") == 2", "assert count_vowels(\"aEiOu\") == 5  # Mixed case", "assert count_vowels(\"12345\") == 0  # Numbers, no vowels", "assert count_vowels(\"Fly to the moon\") == 4"], "author": "GPT", "UUID": "b8db296c-36e0-4561-9039-2308ca5e6225", "tc_status": [["assert count_vowels(\"hello world\") == 3", "Passed"], ["assert count_vowels(\"AEIOU\") == 5", "Passed"], ["assert count_vowels(\"abcdefghijklmnopqrstuvwxyz\") == 5", "Passed"], ["assert count_vowels(\"The quick brown fox jumps over the lazy dog\") == 11", "Passed"], ["assert count_vowels(\"Python Programming\") == 4", "Passed"], ["assert count_vowels(\"\") == 0  # Edge case: empty string", "Passed"], ["assert count_vowels(\"bcdfghjklmnpqrstvwxyz\") == 0  # No vowels", "Passed"], ["assert count_vowels(\"HELLO\") == 2", "Passed"], ["assert count_vowels(\"aEiOu\") == 5  # Mixed case", "Passed"], ["assert count_vowels(\"12345\") == 0  # Numbers, no vowels", "Passed"], ["assert count_vowels(\"Fly to the moon\") == 4", "Passed"]]}, {"few_shots": [{"author": "Calvin", "UUID": "d0ce7430-cfcd-4c69-b161-b3b2a186422c", "question": "Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.\n\nIn other words, return true if one of s1's permutations is the substring of s2.", "examples": "Input: s1 = \"ab\", s2 = \"eidbaooo\"\nOutput: True\n\nInput: s1 = \"ab\", s2 = \"eidboaoo\"\nOutput: False", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef permutation_in_string(s1: str, s2: str) -> bool:\n  window = len(s1)\n  if window > len(s2):\n    return False\n  freq1 = [0]*26\n  freq2 = [0]*26\n  for i in range(window):\n    freq1[ord(s1[i])-ord('a')] += 1\n    freq2[ord(s2[i])-ord('a')] += 1\n\n  matches = 0\n  for i in range(26):\n    if freq1[i] == freq2[i]:\n      matches += 1\n  \n  for l in range(len(s2) - window):\n    if matches == 26:\n      return True\n\n    added = ord(s2[l + window]) - ord('a')\n    freq2[added] += 1\n    if freq1[added] == freq2[added]:\n      matches += 1\n    elif freq1[added] + 1 == freq2[added]:\n      matches -= 1\n\n    removed = ord(s2[l]) - ord('a')\n    freq2[removed] -= 1\n    if freq1[removed] == freq2[removed]:\n      matches += 1\n    elif freq1[removed] == freq2[removed] + 1:\n      matches -= 1\n    \n  return matches == 26\n", "asserts": ["assert permutation_in_string(\"hello\", \"ooollehhhhh\") == True", "assert permutation_in_string(\"abc\", \"ccccbbbbaaaa\") == False", "assert permutation_in_string(\"xyz\", \"zxyopqrstuv\") == True", "assert permutation_in_string(\"xyz\", \"xzygxzyzxyzk\") == True", "assert permutation_in_string(\"a\", \"a\") == True", "assert permutation_in_string(\"adc\", \"dcda\") == True", "assert permutation_in_string(\"pq\", \"qpqqp\") == True", "assert permutation_in_string(\"kitten\", \"sittingkite\") == False", "assert permutation_in_string(\"pq\", \"pqpqr\") == True", "assert permutation_in_string(\"aba\", \"aabaabaa\") == True", "assert permutation_in_string(\"\", \"\") == True  # Edge case: both strings are empty", "assert permutation_in_string(\"longerstring\", \"short\") == False  # s1 is longer than s2", "assert permutation_in_string(\"a\", \"b\") == False  # Single character, no match", "assert permutation_in_string(\"aab\", \"baa\") == True  # s1 is a permutation of s2", "assert permutation_in_string(\"ab\", \"a\") == False  # s2 is shorter than s1", "assert permutation_in_string(\"ba\", \"eidbaooo\") == True  # Same characters as Example 1 but different permutation", "assert permutation_in_string(\"eid\", \"eidbaooo\") == True  # s1 is a prefix of s2", "assert permutation_in_string(\"ooo\", \"eidbaooo\") == True  # s1 is a suffix of s2", "assert permutation_in_string(\"db\", \"eidbaooo\") == True  # s1 is a permutation within s2", "assert permutation_in_string(\"eidoo\", \"eidbaooo\") == False  # s1 is longer than any permutation within s2"]}, {"author": "Calvin", "UUID": "56b48f6d-0d81-478d-b838-4d47b62d3031", "question": "Given an integer n, return the number of strings of length n that consist only of vowels (a, e, i, o, u) and are lexicographically sorted.\n\nA string s is lexicographically sorted if for all valid i, s[i] is the same as or comes before s[i+1] in the alphabet.", "examples": "Input: 1\nOutput: 5\n\nInput: 2\nOutput: 15", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def helper(n, letter_idx):\n  letters = [\"a\",\"e\",\"i\",\"o\",\"u\"]\n  dynamic = {\n      'a1' : 5,\n      'e1' : 4,\n      'i1' : 3,\n      'o1' : 2,\n      'u1' : 1\n  }\n  ret = 0\n  key = letters[letter_idx] + str(n)\n  if key in dynamic.keys():\n    return dynamic[key]\n  else:\n    for i in range(letter_idx, len(letters)):\n      ret += helper(n-1, i)\n    dynamic[key] = ret\n  return ret\n  \n\ndef countVowelStrings(n: int) -> int:\n  return helper(n, 0)\n", "asserts": ["assert countVowelStrings(3) == 35", "assert countVowelStrings(4) == 70", "assert countVowelStrings(5) == 126", "assert countVowelStrings(6) == 210", "assert countVowelStrings(7) == 330", "assert countVowelStrings(10) == 1001", "assert countVowelStrings(15) == 3876"]}], "category": "String", "prompt_tokens": 1255, "total_tokens": 1635, "completion_tokens": 380, "completion": "Given a string containing only lowercase English letters and the '?' character, convert all the '?' characters into lowercase letters such that the resulting string does not contain any consecutive repeating characters. You may assume it is always possible to convert the string.\n\n###Code: \n\ndef modify_string(s: str) -> str:\n    s = list(s)\n    for i in range(len(s)):\n        if s[i] == '?':\n            for c in 'abcdefghijklmnopqrstuvwxyz':\n                if (i == 0 or s[i-1] != c) and (i == len(s) - 1 or s[i+1] != c):\n                    s[i] = c\n                    break\n    return \"\".join(s)\n\n###Testcases:\n\nassert modify_string(\"?zs\") == \"azs\"\nassert modify_string(\"ubv?w\") == \"ubvaw\"\nassert modify_string(\"j?qg??b\") == \"jaqgacb\"\nassert modify_string(\"??yw?ipkj?\") == \"abywaipkja\"\nassert modify_string(\"a?a\") == \"aba\"\nassert modify_string(\"?a?\") == \"bab\"\nassert modify_string(\"??\") == \"ab\"\nassert modify_string(\"????????\") == \"abababab\"\nassert modify_string(\"a????a\") == \"ababaa\"\nassert modify_string(\"?a??a?\") == \"bababa\"\nassert modify_string(\"??a\") == \"aba\"\nassert modify_string(\"a?\") == \"ab\"\nassert modify_string(\"?\") == \"a\"  # Single '?' character\nassert modify_string(\"b?b?e\") == \"baba\"\nassert modify_string(\"????a\") == \"abaca\"\nassert modify_string(\"a???\") == \"abca\"\nassert modify_string(\"?a??ubv?w\") == \"babacubvaw\"\n\n[/Example 3]", "temperature": 0.903, "question": "Given a string containing only lowercase English letters and the '?' character, convert all the '?' characters into lowercase letters such that the resulting string does not contain any consecutive repeating characters. You may assume it is always possible to convert the string.", "code": "def modify_string(s: str) -> str:\n    s = list(s)\n    for i in range(len(s)):\n        if s[i] == '?':\n            for c in 'abcdefghijklmnopqrstuvwxyz':\n                if (i == 0 or s[i-1] != c) and (i == len(s) - 1 or s[i+1] != c):\n                    s[i] = c\n                    break\n    return \"\".join(s)", "asserts": ["assert modify_string(\"?zs\") == \"azs\"", "assert modify_string(\"ubv?w\") == \"ubvaw\"", "assert modify_string(\"j?qg??b\") == \"jaqgacb\"", "assert modify_string(\"??yw?ipkj?\") == \"abywaipkja\"", "assert modify_string(\"a?a\") == \"aba\"", "assert modify_string(\"?a?\") == \"bab\"", "assert modify_string(\"??\") == \"ab\"", "assert modify_string(\"????????\") == \"abababab\"", "assert modify_string(\"??a\") == \"aba\"", "assert modify_string(\"a?\") == \"ab\"", "assert modify_string(\"?\") == \"a\"  # Single '?' character"], "author": "GPT", "UUID": "47d5c8cc-94c3-4f14-acd1-7ca2d49bbf25", "tc_status": [["assert modify_string(\"?zs\") == \"azs\"", "Passed"], ["assert modify_string(\"ubv?w\") == \"ubvaw\"", "Passed"], ["assert modify_string(\"j?qg??b\") == \"jaqgacb\"", "Passed"], ["assert modify_string(\"??yw?ipkj?\") == \"abywaipkja\"", "Passed"], ["assert modify_string(\"a?a\") == \"aba\"", "Passed"], ["assert modify_string(\"?a?\") == \"bab\"", "Passed"], ["assert modify_string(\"??\") == \"ab\"", "Passed"], ["assert modify_string(\"????????\") == \"abababab\"", "Passed"], ["assert modify_string(\"??a\") == \"aba\"", "Passed"], ["assert modify_string(\"a?\") == \"ab\"", "Passed"], ["assert modify_string(\"?\") == \"a\"  # Single '?' character", "Passed"]]}, {"few_shots": [{"author": "Calvin", "UUID": "87372a22-f5ef-4100-845b-28700ca3fde3", "question": "You are given a string s and an integer array indices of the same length. The string s will be shuffled such that the character at the ith position moves to indices[i] in the shuffled string.\n\nReturn the shuffled string.", "examples": "Input: s = \"codeleet\", indices = [4,5,6,7,0,2,1,3]\nOutput: \"leetcode\"\n\nInput: s = \"abc\", indices = [0,1,2]\nOutput: \"abc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "from typing import List\ndef shuffle_string(s: str, indices: List[int]) -> str:\n    def partitionString(s):\n      substrings = 1\n      cur_str = set()\n      for i in range(len(s)):\n        if s[i] in cur_str:\n          substrings += 1\n          cur_str = {s[i]}\n        else:\n          cur_str.add(s[i])\n      return substrings\n    ret = ['_']*len(s)\n    for idx, i in enumerate(indices):\n        ret[i] = s[idx]\n    return \"\".join(ret)\n", "asserts": ["assert shuffle_string(\"reoc\", [2, 0, 1, 3]) == \"eorc\"", "assert shuffle_string(\"aiohn\", [3,1,4,2,0]) == \"nihao\"", "assert shuffle_string(\"aax\", [0,2,1]) == \"axa\"", "assert shuffle_string(\"gh\", [1,0]) == \"hg\"", "assert shuffle_string(\"\", []) == \"\"  # Edge case: empty string", "assert shuffle_string(\"xy\", [0,1]) == \"xy\"  # No shuffle required", "assert shuffle_string(\"pqrstuvwxyzabcdefghijklmno\", list(range(25, -1, -1))) == \"onmlkjihgfedcbazyxwvutsrqp\"  # Reverse shuffle"]}, {"author": "Calvin", "UUID": "ac641352-08d5-4950-8993-6a143da92ecf", "question": "You are given a string s and an integer k. You can choose one of the first k letters of s and append it at the end of the string.\n\nReturn the lexicographically smallest string you could have after applying the mentioned step any number of moves.\n", "examples": "Input: s = \"cba\", k = 1\nOutput: \"acb\"\n\nInput: s = \"baaca\", k = 3\nOutput: \"aaabc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef orderlyQueue(s: str, k: int) -> str:\n    if k == 1:\n        n = len(s)\n        ss = s + s\n        lex_min_str = s\n        for i in range(n):\n            lex_min_str = min(lex_min_str, ss[i:i + n])\n        return lex_min_str\n    \n    return \"\".join(sorted(s))\n", "asserts": ["assert orderlyQueue(\"abcd\", 1) == \"abcd\"", "assert orderlyQueue(\"hello\", 2) == \"ehllo\"", "assert orderlyQueue(\"programming\", 1) == \"ammingprogr\"", "assert orderlyQueue(\"rotator\", 1) == \"atorrot\"", "assert orderlyQueue(\"zxyabc\", 5) == \"abcxyz\"", "assert orderlyQueue(\"xy\", 2) == \"xy\""]}], "category": "String", "prompt_tokens": 755, "total_tokens": 1033, "completion_tokens": 278, "completion": "You are given a string s that consists of lower case English letters and brackets. \n\nReverse the strings in each pair of matching parentheses, starting from the innermost one.\n\nYour result should not contain any brackets.\n\n###Code: \n\ndef reverseParentheses(s: str) -> str:\n    stack = []\n    for char in s:\n        if char == ')':\n            temp = []\n            while stack and stack[-1] != '(':\n                temp.append(stack.pop())\n            stack.pop()  # Remove the '(' from stack\n            stack.extend(temp)\n        else:\n            stack.append(char)\n    return ''.join(stack)\n\n\n###Testcases: \n\nassert reverseParentheses(\"(abcd)\") == \"dcba\"\nassert reverseParentheses(\"(u(love)i)\") == \"iloveu\"\nassert reverseParentheses(\"(ed(et(oc))el)\") == \"leetcode\"\nassert reverseParentheses(\"a(bcdefghijkl(mno)p)q\") == \"apmnolkjihgfedcbq\"\nassert reverseParentheses(\"\") == \"\"  # Edge case: empty string\nassert reverseParentheses(\"abc(cba)ab(bac)c\") == \"abcabcabcabc\"\nassert reverseParentheses(\"The ((quick (brown) (fox) jumps over the lazy) dog)\") == \"The god quick nworb xof jumps over the lazy\"\n\n[/Example 3]", "temperature": 0.928, "question": "You are given a string s that consists of lower case English letters and brackets. \n\nReverse the strings in each pair of matching parentheses, starting from the innermost one.\n\nYour result should not contain any brackets.", "code": "def reverseParentheses(s: str) -> str:\n    stack = []\n    for char in s:\n        if char == ')':\n            temp = []\n            while stack and stack[-1] != '(':\n                temp.append(stack.pop())\n            stack.pop()  # Remove the '(' from stack\n            stack.extend(temp)\n        else:\n            stack.append(char)\n    return ''.join(stack)", "asserts": ["assert reverseParentheses(\"(abcd)\") == \"dcba\"", "assert reverseParentheses(\"(u(love)i)\") == \"iloveu\"", "assert reverseParentheses(\"(ed(et(oc))el)\") == \"leetcode\"", "assert reverseParentheses(\"a(bcdefghijkl(mno)p)q\") == \"apmnolkjihgfedcbq\"", "assert reverseParentheses(\"\") == \"\"  # Edge case: empty string", "assert reverseParentheses(\"abc(cba)ab(bac)c\") == \"abcabcabcabc\"", "assert reverseParentheses(\"The ((quick (brown) (fox) jumps over the lazy) dog)\") == \"The god quick nworb xof jumps over the lazy\""], "author": "GPT", "UUID": "68a46a2c-08fa-4dde-842c-6a249d83d24c", "tc_status": [["assert reverseParentheses(\"(abcd)\") == \"dcba\"", "Passed"], ["assert reverseParentheses(\"(u(love)i)\") == \"iloveu\"", "Passed"], ["assert reverseParentheses(\"(ed(et(oc))el)\") == \"leetcode\"", "Passed"], ["assert reverseParentheses(\"a(bcdefghijkl(mno)p)q\") == \"apmnolkjihgfedcbq\"", "Passed"], ["assert reverseParentheses(\"\") == \"\"  # Edge case: empty string", "Passed"], ["assert reverseParentheses(\"abc(cba)ab(bac)c\") == \"abcabcabcabc\"", "Passed"], ["assert reverseParentheses(\"The ((quick (brown) (fox) jumps over the lazy) dog)\") == \"The god quick nworb xof jumps over the lazy\"", "Passed"]]}, {"few_shots": [{"author": "Calvin", "UUID": "87372a22-f5ef-4100-845b-28700ca3fde3", "question": "You are given a string s and an integer array indices of the same length. The string s will be shuffled such that the character at the ith position moves to indices[i] in the shuffled string.\n\nReturn the shuffled string.", "examples": "Input: s = \"codeleet\", indices = [4,5,6,7,0,2,1,3]\nOutput: \"leetcode\"\n\nInput: s = \"abc\", indices = [0,1,2]\nOutput: \"abc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "from typing import List\ndef shuffle_string(s: str, indices: List[int]) -> str:\n    def partitionString(s):\n      substrings = 1\n      cur_str = set()\n      for i in range(len(s)):\n        if s[i] in cur_str:\n          substrings += 1\n          cur_str = {s[i]}\n        else:\n          cur_str.add(s[i])\n      return substrings\n    ret = ['_']*len(s)\n    for idx, i in enumerate(indices):\n        ret[i] = s[idx]\n    return \"\".join(ret)\n", "asserts": ["assert shuffle_string(\"reoc\", [2, 0, 1, 3]) == \"eorc\"", "assert shuffle_string(\"aiohn\", [3,1,4,2,0]) == \"nihao\"", "assert shuffle_string(\"aax\", [0,2,1]) == \"axa\"", "assert shuffle_string(\"gh\", [1,0]) == \"hg\"", "assert shuffle_string(\"\", []) == \"\"  # Edge case: empty string", "assert shuffle_string(\"xy\", [0,1]) == \"xy\"  # No shuffle required", "assert shuffle_string(\"pqrstuvwxyzabcdefghijklmno\", list(range(25, -1, -1))) == \"onmlkjihgfedcbazyxwvutsrqp\"  # Reverse shuffle"]}, {"author": "Calvin", "UUID": "ac641352-08d5-4950-8993-6a143da92ecf", "question": "You are given a string s and an integer k. You can choose one of the first k letters of s and append it at the end of the string.\n\nReturn the lexicographically smallest string you could have after applying the mentioned step any number of moves.\n", "examples": "Input: s = \"cba\", k = 1\nOutput: \"acb\"\n\nInput: s = \"baaca\", k = 3\nOutput: \"aaabc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef orderlyQueue(s: str, k: int) -> str:\n    if k == 1:\n        n = len(s)\n        ss = s + s\n        lex_min_str = s\n        for i in range(n):\n            lex_min_str = min(lex_min_str, ss[i:i + n])\n        return lex_min_str\n    \n    return \"\".join(sorted(s))\n", "asserts": ["assert orderlyQueue(\"abcd\", 1) == \"abcd\"", "assert orderlyQueue(\"hello\", 2) == \"ehllo\"", "assert orderlyQueue(\"programming\", 1) == \"ammingprogr\"", "assert orderlyQueue(\"rotator\", 1) == \"atorrot\"", "assert orderlyQueue(\"zxyabc\", 5) == \"abcxyz\"", "assert orderlyQueue(\"xy\", 2) == \"xy\""]}], "category": "String", "prompt_tokens": 755, "total_tokens": 1054, "completion_tokens": 299, "completion": "Given a string s, reverse only all the vowels in the string and return it. The vowels are 'a', 'e', 'i', 'o', and 'u', and they can appear in both cases.\n\n###Code:\n\ndef reverseVowels(s: str) -> str:\n    vowels = set(\"aeiouAEIOU\")\n    s_list = list(s)\n    left, right = 0, len(s) - 1\n    \n    while left < right:\n        while left < right and s_list[left] not in vowels:\n            left += 1\n        while left < right and s_list[right] not in vowels:\n            right -= 1\n        \n        s_list[left], s_list[right] = s_list[right], s_list[left]\n        left, right = left + 1, right - 1\n    \n    return ''.join(s_list)\n\n###Testcases:\n\nassert reverseVowels(\"hello\") == \"holle\"\nassert reverseVowels(\"leetcode\") == \"leotcede\"\nassert reverseVowels(\"aA\") == \"Aa\"\nassert reverseVowels(\"programming\") == \"prigrammong\"\nassert reverseVowels(\" \") == \" \"  # Edge case: single space\nassert reverseVowels(\"\") == \"\"  # Edge case: empty string\nassert reverseVowels(\"bcdfg\") == \"bcdfg\"  # No vowels to reverse\n\n[/Example 3]", "temperature": 0.762, "question": "Given a string s, reverse only all the vowels in the string and return it. The vowels are 'a', 'e', 'i', 'o', and 'u', and they can appear in both cases.", "code": "def reverseVowels(s: str) -> str:\n    vowels = set(\"aeiouAEIOU\")\n    s_list = list(s)\n    left, right = 0, len(s) - 1\n    \n    while left < right:\n        while left < right and s_list[left] not in vowels:\n            left += 1\n        while left < right and s_list[right] not in vowels:\n            right -= 1\n        \n        s_list[left], s_list[right] = s_list[right], s_list[left]\n        left, right = left + 1, right - 1\n    \n    return ''.join(s_list)", "asserts": ["assert reverseVowels(\"hello\") == \"holle\"", "assert reverseVowels(\"leetcode\") == \"leotcede\"", "assert reverseVowels(\"aA\") == \"Aa\"", "assert reverseVowels(\"programming\") == \"prigrammong\"", "assert reverseVowels(\" \") == \" \"  # Edge case: single space", "assert reverseVowels(\"\") == \"\"  # Edge case: empty string", "assert reverseVowels(\"bcdfg\") == \"bcdfg\"  # No vowels to reverse"], "author": "GPT", "UUID": "32d21b23-40a2-43f5-805c-65a7e25952f7", "tc_status": [["assert reverseVowels(\"hello\") == \"holle\"", "Passed"], ["assert reverseVowels(\"leetcode\") == \"leotcede\"", "Passed"], ["assert reverseVowels(\"aA\") == \"Aa\"", "Passed"], ["assert reverseVowels(\"programming\") == \"prigrammong\"", "Passed"], ["assert reverseVowels(\" \") == \" \"  # Edge case: single space", "Passed"], ["assert reverseVowels(\"\") == \"\"  # Edge case: empty string", "Passed"], ["assert reverseVowels(\"bcdfg\") == \"bcdfg\"  # No vowels to reverse", "Passed"]]}, {"few_shots": [{"author": "Calvin", "UUID": "87372a22-f5ef-4100-845b-28700ca3fde3", "question": "You are given a string s and an integer array indices of the same length. The string s will be shuffled such that the character at the ith position moves to indices[i] in the shuffled string.\n\nReturn the shuffled string.", "examples": "Input: s = \"codeleet\", indices = [4,5,6,7,0,2,1,3]\nOutput: \"leetcode\"\n\nInput: s = \"abc\", indices = [0,1,2]\nOutput: \"abc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "from typing import List\ndef shuffle_string(s: str, indices: List[int]) -> str:\n    def partitionString(s):\n      substrings = 1\n      cur_str = set()\n      for i in range(len(s)):\n        if s[i] in cur_str:\n          substrings += 1\n          cur_str = {s[i]}\n        else:\n          cur_str.add(s[i])\n      return substrings\n    ret = ['_']*len(s)\n    for idx, i in enumerate(indices):\n        ret[i] = s[idx]\n    return \"\".join(ret)\n", "asserts": ["assert shuffle_string(\"reoc\", [2, 0, 1, 3]) == \"eorc\"", "assert shuffle_string(\"aiohn\", [3,1,4,2,0]) == \"nihao\"", "assert shuffle_string(\"aax\", [0,2,1]) == \"axa\"", "assert shuffle_string(\"gh\", [1,0]) == \"hg\"", "assert shuffle_string(\"\", []) == \"\"  # Edge case: empty string", "assert shuffle_string(\"xy\", [0,1]) == \"xy\"  # No shuffle required", "assert shuffle_string(\"pqrstuvwxyzabcdefghijklmno\", list(range(25, -1, -1))) == \"onmlkjihgfedcbazyxwvutsrqp\"  # Reverse shuffle"]}, {"author": "Calvin", "UUID": "ac641352-08d5-4950-8993-6a143da92ecf", "question": "You are given a string s and an integer k. You can choose one of the first k letters of s and append it at the end of the string.\n\nReturn the lexicographically smallest string you could have after applying the mentioned step any number of moves.\n", "examples": "Input: s = \"cba\", k = 1\nOutput: \"acb\"\n\nInput: s = \"baaca\", k = 3\nOutput: \"aaabc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef orderlyQueue(s: str, k: int) -> str:\n    if k == 1:\n        n = len(s)\n        ss = s + s\n        lex_min_str = s\n        for i in range(n):\n            lex_min_str = min(lex_min_str, ss[i:i + n])\n        return lex_min_str\n    \n    return \"\".join(sorted(s))\n", "asserts": ["assert orderlyQueue(\"abcd\", 1) == \"abcd\"", "assert orderlyQueue(\"hello\", 2) == \"ehllo\"", "assert orderlyQueue(\"programming\", 1) == \"ammingprogr\"", "assert orderlyQueue(\"rotator\", 1) == \"atorrot\"", "assert orderlyQueue(\"zxyabc\", 5) == \"abcxyz\"", "assert orderlyQueue(\"xy\", 2) == \"xy\""]}], "category": "String", "prompt_tokens": 755, "total_tokens": 1066, "completion_tokens": 311, "completion": "Given a non-empty string of lowercase letters and a non-negative integer representing a key, write a function that returns a new string obtained by shifting every letter in the input string by k positions in the alphabet, where k is the key. Letters should \"wrap\" around the alphabet; in other words, the letter `z` shifted by one returns `a`.\n\n###Code:\n\ndef caesar_cipher_encryptor(string: str, key: int) -> str:\n    new_letters = []\n    new_key = key % 26\n    for letter in string:\n        new_letter_code = ord(letter) + new_key\n        if new_letter_code <= 122:\n            new_letters.append(chr(new_letter_code))\n        else:\n            new_letters.append(chr(96 + new_letter_code % 122))\n    return \"\".join(new_letters)\n\n###Testcases:\n\nassert caesar_cipher_encryptor(\"xyz\", 2) == \"zab\"\nassert caesar_cipher_encryptor(\"abc\", 0) == \"abc\"  # No shift\nassert caesar_cipher_encryptor(\"abc\", 3) == \"def\"\nassert caesar_cipher_encryptor(\"z\", 1) == \"a\"\nassert caesar_cipher_encryptor(\"xyz\", 26) == \"xyz\"  # Full rotation\nassert caesar_cipher_encryptor(\"abc\", 52) == \"abc\"  # Double rotation\nassert caesar_cipher_encryptor(\"hello\", 57) == \"olssv\"  # Over rotation\n\n[/Example 3]", "temperature": 0.901, "question": "Given a non-empty string of lowercase letters and a non-negative integer representing a key, write a function that returns a new string obtained by shifting every letter in the input string by k positions in the alphabet, where k is the key. Letters should \"wrap\" around the alphabet; in other words, the letter `z` shifted by one returns `a`.", "code": "def caesar_cipher_encryptor(string: str, key: int) -> str:\n    new_letters = []\n    new_key = key % 26\n    for letter in string:\n        new_letter_code = ord(letter) + new_key\n        if new_letter_code <= 122:\n            new_letters.append(chr(new_letter_code))\n        else:\n            new_letters.append(chr(96 + new_letter_code % 122))\n    return \"\".join(new_letters)", "asserts": ["assert caesar_cipher_encryptor(\"xyz\", 2) == \"zab\"", "assert caesar_cipher_encryptor(\"abc\", 0) == \"abc\"  # No shift", "assert caesar_cipher_encryptor(\"abc\", 3) == \"def\"", "assert caesar_cipher_encryptor(\"z\", 1) == \"a\"", "assert caesar_cipher_encryptor(\"xyz\", 26) == \"xyz\"  # Full rotation", "assert caesar_cipher_encryptor(\"abc\", 52) == \"abc\"  # Double rotation"], "author": "GPT", "UUID": "dd4fe250-e003-4b07-b8c7-339a0d05e0ad", "tc_status": [["assert caesar_cipher_encryptor(\"xyz\", 2) == \"zab\"", "Passed"], ["assert caesar_cipher_encryptor(\"abc\", 0) == \"abc\"  # No shift", "Passed"], ["assert caesar_cipher_encryptor(\"abc\", 3) == \"def\"", "Passed"], ["assert caesar_cipher_encryptor(\"z\", 1) == \"a\"", "Passed"], ["assert caesar_cipher_encryptor(\"xyz\", 26) == \"xyz\"  # Full rotation", "Passed"], ["assert caesar_cipher_encryptor(\"abc\", 52) == \"abc\"  # Double rotation", "Passed"]]}, {"few_shots": [{"author": "Calvin", "UUID": "87372a22-f5ef-4100-845b-28700ca3fde3", "question": "You are given a string s and an integer array indices of the same length. The string s will be shuffled such that the character at the ith position moves to indices[i] in the shuffled string.\n\nReturn the shuffled string.", "examples": "Input: s = \"codeleet\", indices = [4,5,6,7,0,2,1,3]\nOutput: \"leetcode\"\n\nInput: s = \"abc\", indices = [0,1,2]\nOutput: \"abc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "from typing import List\ndef shuffle_string(s: str, indices: List[int]) -> str:\n    def partitionString(s):\n      substrings = 1\n      cur_str = set()\n      for i in range(len(s)):\n        if s[i] in cur_str:\n          substrings += 1\n          cur_str = {s[i]}\n        else:\n          cur_str.add(s[i])\n      return substrings\n    ret = ['_']*len(s)\n    for idx, i in enumerate(indices):\n        ret[i] = s[idx]\n    return \"\".join(ret)\n", "asserts": ["assert shuffle_string(\"reoc\", [2, 0, 1, 3]) == \"eorc\"", "assert shuffle_string(\"aiohn\", [3,1,4,2,0]) == \"nihao\"", "assert shuffle_string(\"aax\", [0,2,1]) == \"axa\"", "assert shuffle_string(\"gh\", [1,0]) == \"hg\"", "assert shuffle_string(\"\", []) == \"\"  # Edge case: empty string", "assert shuffle_string(\"xy\", [0,1]) == \"xy\"  # No shuffle required", "assert shuffle_string(\"pqrstuvwxyzabcdefghijklmno\", list(range(25, -1, -1))) == \"onmlkjihgfedcbazyxwvutsrqp\"  # Reverse shuffle"]}, {"author": "Calvin", "UUID": "80e34b28-16a8-46ac-8b6a-ee28beb1e8d4", "question": "Write a function that reverses a string. The input string is given as an array of characters s.\n\nYou must do this by modifying the input array in-place with O(1) extra memory.", "examples": "Input: [\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput: [\"o\",\"l\",\"l\",\"e\",\"h\"]\n\nInput: [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\nOutput: [\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def reverse_string(s: list) -> list:\n  l = 0\n  r = len(s) - 1\n  while l < r:\n    tmp = s[l]\n    s[l] = s[r]\n    s[r] = tmp\n    l += 1\n    r -= 1\n  return s\n", "asserts": ["assert reverse_string([\"a\",\"b\",\"c\",\"d\"]) == [\"d\", \"c\", \"b\", \"a\"]", "assert reverse_string([\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"]) == [\"n\", \"o\", \"h\", \"t\", \"y\", \"p\"]", "assert reverse_string([]) == []", "assert reverse_string([\"s\", \"i\", \"n\", \"g\", \"l\", \"e\"]) == [\"e\", \"l\", \"g\", \"n\", \"i\", \"s\"]", "assert reverse_string([\"A\"]) == [\"A\"]", "assert reverse_string([\"9\", \"8\", \"7\", \"6\", \"5\", \"4\", \"3\", \"2\", \"1\"]) == [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]", "assert reverse_string([\"B\", \"o\", \"b\"]) == [\"b\", \"o\", \"B\"]", "assert reverse_string([\"r\", \"e\", \"v\", \"e\", \"r\", \"s\", \"e\"]) == [\"e\", \"s\", \"r\", \"e\", \"v\", \"e\", \"r\"]", "assert reverse_string([\"1\", \"*\", \"2\", \"*\", \"3\"]) == [\"3\", \"*\", \"2\", \"*\", \"1\"]"]}], "category": "String", "prompt_tokens": 920, "total_tokens": 1195, "completion_tokens": 275, "completion": "Create a function that checks if a string can be formed by rearranging the characters of another string. If it is possible, return true; otherwise, return false.\n\nYou may assume the input contains only lowercase alphabets.\n\n###Code: \n\ndef can_form_by_rearranging(original: str, target: str) -> bool:\n    from collections import Counter\n    return Counter(original) == Counter(target)\n\n###Testcases: \n\nassert can_form_by_rearranging(\"anagram\", \"nagaram\") == True\nassert can_form_by_rearranging(\"hello\", \"billion\") == False\nassert can_form_by_rearranging(\"aabbcc\", \"abcabc\") == True\nassert can_form_by_rearranging(\"rat\", \"car\") == False\nassert can_form_by_rearranging(\"\", \"\") == True  # Edge case: both strings are empty\nassert can_form_by_rearranging(\"xyz\", \"zyx\") == True\nassert can_form_by_rearranging(\"aaa\", \"aaaa\") == False  # Different number of characters\nassert can_form_by_rearranging(\"silent\", \"listen\") == True\nassert can_form_by_rearranging(\"triangle\", \"integral\") == True\nassert can_form_by_rearranging(\"elevenplus\", \"twelveplus\") == False\n\n[/Example 3]", "temperature": 0.839, "question": "Create a function that checks if a string can be formed by rearranging the characters of another string. If it is possible, return true; otherwise, return false.\n\nYou may assume the input contains only lowercase alphabets.", "code": "def can_form_by_rearranging(original: str, target: str) -> bool:\n    from collections import Counter\n    return Counter(original) == Counter(target)", "asserts": ["assert can_form_by_rearranging(\"anagram\", \"nagaram\") == True", "assert can_form_by_rearranging(\"hello\", \"billion\") == False", "assert can_form_by_rearranging(\"aabbcc\", \"abcabc\") == True", "assert can_form_by_rearranging(\"rat\", \"car\") == False", "assert can_form_by_rearranging(\"\", \"\") == True  # Edge case: both strings are empty", "assert can_form_by_rearranging(\"xyz\", \"zyx\") == True", "assert can_form_by_rearranging(\"aaa\", \"aaaa\") == False  # Different number of characters", "assert can_form_by_rearranging(\"silent\", \"listen\") == True", "assert can_form_by_rearranging(\"triangle\", \"integral\") == True", "assert can_form_by_rearranging(\"elevenplus\", \"twelveplus\") == False"], "author": "GPT", "UUID": "92e14965-767e-4ca1-878d-33968564a4ad", "tc_status": [["assert can_form_by_rearranging(\"anagram\", \"nagaram\") == True", "Passed"], ["assert can_form_by_rearranging(\"hello\", \"billion\") == False", "Passed"], ["assert can_form_by_rearranging(\"aabbcc\", \"abcabc\") == True", "Passed"], ["assert can_form_by_rearranging(\"rat\", \"car\") == False", "Passed"], ["assert can_form_by_rearranging(\"\", \"\") == True  # Edge case: both strings are empty", "Passed"], ["assert can_form_by_rearranging(\"xyz\", \"zyx\") == True", "Passed"], ["assert can_form_by_rearranging(\"aaa\", \"aaaa\") == False  # Different number of characters", "Passed"], ["assert can_form_by_rearranging(\"silent\", \"listen\") == True", "Passed"], ["assert can_form_by_rearranging(\"triangle\", \"integral\") == True", "Passed"], ["assert can_form_by_rearranging(\"elevenplus\", \"twelveplus\") == False", "Passed"]]}, {"few_shots": [{"author": "Calvin", "UUID": "87372a22-f5ef-4100-845b-28700ca3fde3", "question": "You are given a string s and an integer array indices of the same length. The string s will be shuffled such that the character at the ith position moves to indices[i] in the shuffled string.\n\nReturn the shuffled string.", "examples": "Input: s = \"codeleet\", indices = [4,5,6,7,0,2,1,3]\nOutput: \"leetcode\"\n\nInput: s = \"abc\", indices = [0,1,2]\nOutput: \"abc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "from typing import List\ndef shuffle_string(s: str, indices: List[int]) -> str:\n    def partitionString(s):\n      substrings = 1\n      cur_str = set()\n      for i in range(len(s)):\n        if s[i] in cur_str:\n          substrings += 1\n          cur_str = {s[i]}\n        else:\n          cur_str.add(s[i])\n      return substrings\n    ret = ['_']*len(s)\n    for idx, i in enumerate(indices):\n        ret[i] = s[idx]\n    return \"\".join(ret)\n", "asserts": ["assert shuffle_string(\"reoc\", [2, 0, 1, 3]) == \"eorc\"", "assert shuffle_string(\"aiohn\", [3,1,4,2,0]) == \"nihao\"", "assert shuffle_string(\"aax\", [0,2,1]) == \"axa\"", "assert shuffle_string(\"gh\", [1,0]) == \"hg\"", "assert shuffle_string(\"\", []) == \"\"  # Edge case: empty string", "assert shuffle_string(\"xy\", [0,1]) == \"xy\"  # No shuffle required", "assert shuffle_string(\"pqrstuvwxyzabcdefghijklmno\", list(range(25, -1, -1))) == \"onmlkjihgfedcbazyxwvutsrqp\"  # Reverse shuffle"]}, {"author": "Calvin", "UUID": "80e34b28-16a8-46ac-8b6a-ee28beb1e8d4", "question": "Write a function that reverses a string. The input string is given as an array of characters s.\n\nYou must do this by modifying the input array in-place with O(1) extra memory.", "examples": "Input: [\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput: [\"o\",\"l\",\"l\",\"e\",\"h\"]\n\nInput: [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\nOutput: [\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def reverse_string(s: list) -> list:\n  l = 0\n  r = len(s) - 1\n  while l < r:\n    tmp = s[l]\n    s[l] = s[r]\n    s[r] = tmp\n    l += 1\n    r -= 1\n  return s\n", "asserts": ["assert reverse_string([\"a\",\"b\",\"c\",\"d\"]) == [\"d\", \"c\", \"b\", \"a\"]", "assert reverse_string([\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"]) == [\"n\", \"o\", \"h\", \"t\", \"y\", \"p\"]", "assert reverse_string([]) == []", "assert reverse_string([\"s\", \"i\", \"n\", \"g\", \"l\", \"e\"]) == [\"e\", \"l\", \"g\", \"n\", \"i\", \"s\"]", "assert reverse_string([\"A\"]) == [\"A\"]", "assert reverse_string([\"9\", \"8\", \"7\", \"6\", \"5\", \"4\", \"3\", \"2\", \"1\"]) == [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]", "assert reverse_string([\"B\", \"o\", \"b\"]) == [\"b\", \"o\", \"B\"]", "assert reverse_string([\"r\", \"e\", \"v\", \"e\", \"r\", \"s\", \"e\"]) == [\"e\", \"s\", \"r\", \"e\", \"v\", \"e\", \"r\"]", "assert reverse_string([\"1\", \"*\", \"2\", \"*\", \"3\"]) == [\"3\", \"*\", \"2\", \"*\", \"1\"]"]}], "category": "String", "prompt_tokens": 920, "total_tokens": 1376, "completion_tokens": 456, "completion": "Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent when dialed on a telephone keypad. Return the combinations in any order.\n\nA mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.\n\n```\n2: abc\n3: def\n4: ghi\n5: jkl\n6: mno\n7: pqrs\n8: tuv\n9: wxyz\n```\n\n###Code:\n\n```python\nfrom typing import List\n\ndef letter_combinations(digits: str) -> List[str]:\n    if not digits:\n        return []\n\n    digit_to_char = {\n        '2': 'abc',\n        '3': 'def',\n        '4': 'ghi',\n        '5': 'jkl',\n        '6': 'mno',\n        '7': 'pqrs',\n        '8': 'tuv',\n        '9': 'wxyz'\n    }\n\n    def backtrack(index, path):\n        if index == len(digits):\n            combinations.append(''.join(path))\n            return\n        possible_letters = digit_to_char[digits[index]]\n        for letter in possible_letters:\n            path.append(letter)\n            backtrack(index + 1, path)\n            path.pop()\n\n    combinations = []\n    backtrack(0, [])\n    return combinations\n\n```\n\n###Testcases:\n\n```python\nassert set(letter_combinations(\"23\")) == set([\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"])\nassert set(letter_combinations(\"\")) == set([])\nassert set(letter_combinations(\"2\")) == set([\"a\",\"b\",\"c\"])\nassert set(letter_combinations(\"9\")) == set([\"w\",\"x\",\"y\",\"z\"])\nassert set(letter_combinations(\"78\")) == set([\"pt\", \"pu\", \"pv\", \"qt\", \"qu\", \"qv\", \"rt\", \"ru\", \"rv\", \"st\", \"su\", \"sv\"])\nassert set(letter_combinations(\"56\")) == set([\"jm\", \"jn\", \"jo\", \"km\", \"kn\", \"ko\", \"lm\", \"ln\", \"lo\"])\n```\n\n[/Example 3]", "temperature": 0.838, "question": "Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent when dialed on a telephone keypad. Return the combinations in any order.\n\nA mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.\n\n```\n2: abc\n3: def\n4: ghi\n5: jkl\n6: mno\n7: pqrs\n8: tuv\n9: wxyz\n```", "code": "from typing import List\n\ndef letter_combinations(digits: str) -> List[str]:\n    if not digits:\n        return []\n\n    digit_to_char = {\n        '2': 'abc',\n        '3': 'def',\n        '4': 'ghi',\n        '5': 'jkl',\n        '6': 'mno',\n        '7': 'pqrs',\n        '8': 'tuv',\n        '9': 'wxyz'\n    }\n\n    def backtrack(index, path):\n        if index == len(digits):\n            combinations.append(''.join(path))\n            return\n        possible_letters = digit_to_char[digits[index]]\n        for letter in possible_letters:\n            path.append(letter)\n            backtrack(index + 1, path)\n            path.pop()\n\n    combinations = []\n    backtrack(0, [])\n    return combinations", "asserts": ["assert set(letter_combinations(\"23\")) == set([\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"])", "assert set(letter_combinations(\"\")) == set([])", "assert set(letter_combinations(\"2\")) == set([\"a\",\"b\",\"c\"])", "assert set(letter_combinations(\"9\")) == set([\"w\",\"x\",\"y\",\"z\"])", "assert set(letter_combinations(\"78\")) == set([\"pt\", \"pu\", \"pv\", \"qt\", \"qu\", \"qv\", \"rt\", \"ru\", \"rv\", \"st\", \"su\", \"sv\"])", "assert set(letter_combinations(\"56\")) == set([\"jm\", \"jn\", \"jo\", \"km\", \"kn\", \"ko\", \"lm\", \"ln\", \"lo\"])"], "author": "GPT", "UUID": "dc0f73a7-6fc0-4c4b-8bf7-aa98935aefa9", "tc_status": [["assert set(letter_combinations(\"23\")) == set([\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"])", "Passed"], ["assert set(letter_combinations(\"\")) == set([])", "Passed"], ["assert set(letter_combinations(\"2\")) == set([\"a\",\"b\",\"c\"])", "Passed"], ["assert set(letter_combinations(\"9\")) == set([\"w\",\"x\",\"y\",\"z\"])", "Passed"], ["assert set(letter_combinations(\"78\")) == set([\"pt\", \"pu\", \"pv\", \"qt\", \"qu\", \"qv\", \"rt\", \"ru\", \"rv\", \"st\", \"su\", \"sv\"])", "Passed"], ["assert set(letter_combinations(\"56\")) == set([\"jm\", \"jn\", \"jo\", \"km\", \"kn\", \"ko\", \"lm\", \"ln\", \"lo\"])", "Passed"]]}, {"few_shots": [{"author": "Calvin", "UUID": "87372a22-f5ef-4100-845b-28700ca3fde3", "question": "You are given a string s and an integer array indices of the same length. The string s will be shuffled such that the character at the ith position moves to indices[i] in the shuffled string.\n\nReturn the shuffled string.", "examples": "Input: s = \"codeleet\", indices = [4,5,6,7,0,2,1,3]\nOutput: \"leetcode\"\n\nInput: s = \"abc\", indices = [0,1,2]\nOutput: \"abc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "from typing import List\ndef shuffle_string(s: str, indices: List[int]) -> str:\n    def partitionString(s):\n      substrings = 1\n      cur_str = set()\n      for i in range(len(s)):\n        if s[i] in cur_str:\n          substrings += 1\n          cur_str = {s[i]}\n        else:\n          cur_str.add(s[i])\n      return substrings\n    ret = ['_']*len(s)\n    for idx, i in enumerate(indices):\n        ret[i] = s[idx]\n    return \"\".join(ret)\n", "asserts": ["assert shuffle_string(\"reoc\", [2, 0, 1, 3]) == \"eorc\"", "assert shuffle_string(\"aiohn\", [3,1,4,2,0]) == \"nihao\"", "assert shuffle_string(\"aax\", [0,2,1]) == \"axa\"", "assert shuffle_string(\"gh\", [1,0]) == \"hg\"", "assert shuffle_string(\"\", []) == \"\"  # Edge case: empty string", "assert shuffle_string(\"xy\", [0,1]) == \"xy\"  # No shuffle required", "assert shuffle_string(\"pqrstuvwxyzabcdefghijklmno\", list(range(25, -1, -1))) == \"onmlkjihgfedcbazyxwvutsrqp\"  # Reverse shuffle"]}, {"author": "Calvin", "UUID": "80e34b28-16a8-46ac-8b6a-ee28beb1e8d4", "question": "Write a function that reverses a string. The input string is given as an array of characters s.\n\nYou must do this by modifying the input array in-place with O(1) extra memory.", "examples": "Input: [\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput: [\"o\",\"l\",\"l\",\"e\",\"h\"]\n\nInput: [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\nOutput: [\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def reverse_string(s: list) -> list:\n  l = 0\n  r = len(s) - 1\n  while l < r:\n    tmp = s[l]\n    s[l] = s[r]\n    s[r] = tmp\n    l += 1\n    r -= 1\n  return s\n", "asserts": ["assert reverse_string([\"a\",\"b\",\"c\",\"d\"]) == [\"d\", \"c\", \"b\", \"a\"]", "assert reverse_string([\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"]) == [\"n\", \"o\", \"h\", \"t\", \"y\", \"p\"]", "assert reverse_string([]) == []", "assert reverse_string([\"s\", \"i\", \"n\", \"g\", \"l\", \"e\"]) == [\"e\", \"l\", \"g\", \"n\", \"i\", \"s\"]", "assert reverse_string([\"A\"]) == [\"A\"]", "assert reverse_string([\"9\", \"8\", \"7\", \"6\", \"5\", \"4\", \"3\", \"2\", \"1\"]) == [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]", "assert reverse_string([\"B\", \"o\", \"b\"]) == [\"b\", \"o\", \"B\"]", "assert reverse_string([\"r\", \"e\", \"v\", \"e\", \"r\", \"s\", \"e\"]) == [\"e\", \"s\", \"r\", \"e\", \"v\", \"e\", \"r\"]", "assert reverse_string([\"1\", \"*\", \"2\", \"*\", \"3\"]) == [\"3\", \"*\", \"2\", \"*\", \"1\"]"]}], "category": "String", "prompt_tokens": 920, "total_tokens": 1248, "completion_tokens": 328, "completion": "Given two strings s and goal, return true if and only if s can become goal after some number of shifts on s.\n\nA shift on s consists of moving the leftmost character of s to the rightmost position.\n\nFor example, if s = \"abcde\", then it will be \"bcdea\" after one shift.\n\n###Code:\n\n```python\ndef can_become_after_shift(s: str, goal: str) -> bool:\n    if len(s) != len(goal):\n        return False\n    if s == goal:\n        return True\n    for i in range(len(s)):\n        s = s[1:] + s[0]\n        if s == goal:\n            return True\n    return False\n```\n\n###Testcases:\n\n```python\nassert can_become_after_shift(\"abcde\", \"cdeab\") == True\nassert can_become_after_shift(\"abcde\", \"abced\") == False\nassert can_become_after_shift(\"xyz\", \"zyx\") == False\nassert can_become_after_shift(\"aaab\", \"baaa\") == True\nassert can_become_after_shift(\"\", \"\") == True  # Edge case: both strings are empty\nassert can_become_after_shift(\"a\", \"a\") == True  # Edge case: single-character strings\nassert can_become_after_shift(\"abc\", \"cab\") == True\nassert can_become_after_shift(\"clrwmpkwru\", \"wmpkwruclr\") == True\nassert can_become_after_shift(\"rotation\", \"tationro\") == True\n```\n\n[/Example 3]", "temperature": 0.778, "question": "Given two strings s and goal, return true if and only if s can become goal after some number of shifts on s.\n\nA shift on s consists of moving the leftmost character of s to the rightmost position.\n\nFor example, if s = \"abcde\", then it will be \"bcdea\" after one shift.", "code": "def can_become_after_shift(s: str, goal: str) -> bool:\n    if len(s) != len(goal):\n        return False\n    if s == goal:\n        return True\n    for i in range(len(s)):\n        s = s[1:] + s[0]\n        if s == goal:\n            return True\n    return False", "asserts": ["assert can_become_after_shift(\"abcde\", \"cdeab\") == True", "assert can_become_after_shift(\"abcde\", \"abced\") == False", "assert can_become_after_shift(\"xyz\", \"zyx\") == False", "assert can_become_after_shift(\"aaab\", \"baaa\") == True", "assert can_become_after_shift(\"\", \"\") == True  # Edge case: both strings are empty", "assert can_become_after_shift(\"a\", \"a\") == True  # Edge case: single-character strings", "assert can_become_after_shift(\"abc\", \"cab\") == True", "assert can_become_after_shift(\"clrwmpkwru\", \"wmpkwruclr\") == True", "assert can_become_after_shift(\"rotation\", \"tationro\") == True"], "author": "GPT", "UUID": "25cbe06e-0496-4411-bec0-60e8933a374f", "tc_status": [["assert can_become_after_shift(\"abcde\", \"cdeab\") == True", "Passed"], ["assert can_become_after_shift(\"abcde\", \"abced\") == False", "Passed"], ["assert can_become_after_shift(\"xyz\", \"zyx\") == False", "Passed"], ["assert can_become_after_shift(\"aaab\", \"baaa\") == True", "Passed"], ["assert can_become_after_shift(\"\", \"\") == True  # Edge case: both strings are empty", "Passed"], ["assert can_become_after_shift(\"a\", \"a\") == True  # Edge case: single-character strings", "Passed"], ["assert can_become_after_shift(\"abc\", \"cab\") == True", "Passed"], ["assert can_become_after_shift(\"clrwmpkwru\", \"wmpkwruclr\") == True", "Passed"], ["assert can_become_after_shift(\"rotation\", \"tationro\") == True", "Passed"]]}, {"few_shots": [{"author": "Calvin", "UUID": "87372a22-f5ef-4100-845b-28700ca3fde3", "question": "You are given a string s and an integer array indices of the same length. The string s will be shuffled such that the character at the ith position moves to indices[i] in the shuffled string.\n\nReturn the shuffled string.", "examples": "Input: s = \"codeleet\", indices = [4,5,6,7,0,2,1,3]\nOutput: \"leetcode\"\n\nInput: s = \"abc\", indices = [0,1,2]\nOutput: \"abc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "from typing import List\ndef shuffle_string(s: str, indices: List[int]) -> str:\n    def partitionString(s):\n      substrings = 1\n      cur_str = set()\n      for i in range(len(s)):\n        if s[i] in cur_str:\n          substrings += 1\n          cur_str = {s[i]}\n        else:\n          cur_str.add(s[i])\n      return substrings\n    ret = ['_']*len(s)\n    for idx, i in enumerate(indices):\n        ret[i] = s[idx]\n    return \"\".join(ret)\n", "asserts": ["assert shuffle_string(\"reoc\", [2, 0, 1, 3]) == \"eorc\"", "assert shuffle_string(\"aiohn\", [3,1,4,2,0]) == \"nihao\"", "assert shuffle_string(\"aax\", [0,2,1]) == \"axa\"", "assert shuffle_string(\"gh\", [1,0]) == \"hg\"", "assert shuffle_string(\"\", []) == \"\"  # Edge case: empty string", "assert shuffle_string(\"xy\", [0,1]) == \"xy\"  # No shuffle required", "assert shuffle_string(\"pqrstuvwxyzabcdefghijklmno\", list(range(25, -1, -1))) == \"onmlkjihgfedcbazyxwvutsrqp\"  # Reverse shuffle"]}, {"author": "Calvin", "UUID": "d0ce7430-cfcd-4c69-b161-b3b2a186422c", "question": "Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.\n\nIn other words, return true if one of s1's permutations is the substring of s2.", "examples": "Input: s1 = \"ab\", s2 = \"eidbaooo\"\nOutput: True\n\nInput: s1 = \"ab\", s2 = \"eidboaoo\"\nOutput: False", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef permutation_in_string(s1: str, s2: str) -> bool:\n  window = len(s1)\n  if window > len(s2):\n    return False\n  freq1 = [0]*26\n  freq2 = [0]*26\n  for i in range(window):\n    freq1[ord(s1[i])-ord('a')] += 1\n    freq2[ord(s2[i])-ord('a')] += 1\n\n  matches = 0\n  for i in range(26):\n    if freq1[i] == freq2[i]:\n      matches += 1\n  \n  for l in range(len(s2) - window):\n    if matches == 26:\n      return True\n\n    added = ord(s2[l + window]) - ord('a')\n    freq2[added] += 1\n    if freq1[added] == freq2[added]:\n      matches += 1\n    elif freq1[added] + 1 == freq2[added]:\n      matches -= 1\n\n    removed = ord(s2[l]) - ord('a')\n    freq2[removed] -= 1\n    if freq1[removed] == freq2[removed]:\n      matches += 1\n    elif freq1[removed] == freq2[removed] + 1:\n      matches -= 1\n    \n  return matches == 26\n", "asserts": ["assert permutation_in_string(\"hello\", \"ooollehhhhh\") == True", "assert permutation_in_string(\"abc\", \"ccccbbbbaaaa\") == False", "assert permutation_in_string(\"xyz\", \"zxyopqrstuv\") == True", "assert permutation_in_string(\"xyz\", \"xzygxzyzxyzk\") == True", "assert permutation_in_string(\"a\", \"a\") == True", "assert permutation_in_string(\"adc\", \"dcda\") == True", "assert permutation_in_string(\"pq\", \"qpqqp\") == True", "assert permutation_in_string(\"kitten\", \"sittingkite\") == False", "assert permutation_in_string(\"pq\", \"pqpqr\") == True", "assert permutation_in_string(\"aba\", \"aabaabaa\") == True", "assert permutation_in_string(\"\", \"\") == True  # Edge case: both strings are empty", "assert permutation_in_string(\"longerstring\", \"short\") == False  # s1 is longer than s2", "assert permutation_in_string(\"a\", \"b\") == False  # Single character, no match", "assert permutation_in_string(\"aab\", \"baa\") == True  # s1 is a permutation of s2", "assert permutation_in_string(\"ab\", \"a\") == False  # s2 is shorter than s1", "assert permutation_in_string(\"ba\", \"eidbaooo\") == True  # Same characters as Example 1 but different permutation", "assert permutation_in_string(\"eid\", \"eidbaooo\") == True  # s1 is a prefix of s2", "assert permutation_in_string(\"ooo\", \"eidbaooo\") == True  # s1 is a suffix of s2", "assert permutation_in_string(\"db\", \"eidbaooo\") == True  # s1 is a permutation within s2", "assert permutation_in_string(\"eidoo\", \"eidbaooo\") == False  # s1 is longer than any permutation within s2"]}], "category": "String", "prompt_tokens": 1265, "total_tokens": 1766, "completion_tokens": 501, "completion": "Given a string containing only three types of characters: '(', ')' and '*', write a function to check whether this string is valid. We define the validity of a string by these rules:\n\n1. Any left parenthesis '(' must have a corresponding right parenthesis ')'.\n2. Any right parenthesis ')' must have a corresponding left parenthesis '('.\n3. Left parenthesis '(' must go before the corresponding right parenthesis ')'.\n4. '*' could be treated as a single right parenthesis ')' or a single left parenthesis '(' or an empty string.\n5. An empty string is also valid.\n\nReturn true if the string is valid, otherwise return false.\n\n###Code: \n\ndef check_valid_string(s: str) -> bool:\n    balance_min = balance_max = 0\n    for char in s:\n        if char == '(':\n            balance_min += 1\n            balance_max += 1\n        elif char == ')':\n            balance_min = max(balance_min - 1, 0)\n            balance_max -= 1\n            if balance_max < 0:\n                return False\n        elif char == '*':\n            balance_min = max(balance_min - 1, 0)\n            balance_max += 1\n\n    return balance_min == 0\n\n###Testcases: \n\nassert check_valid_string(\"()\") == True\nassert check_valid_string(\"(*)\") == True\nassert check_valid_string(\"(*))\") == True\nassert check_valid_string(\"(*()\") == True\nassert check_valid_string(\")*()\") == False\nassert check_valid_string(\"(()\") == False\nassert check_valid_string(\"())\") == False\nassert check_valid_string(\"(*))*)\") == True\nassert check_valid_string(\"((*)\") == True\nassert check_valid_string(\"(*)*(**)\") == True\nassert check_valid_string(\"\") == True  # Edge case: empty string\nassert check_valid_string(\"(((((*)))**\") == True\nassert check_valid_string(\"(((((*)))\") == False\nassert check_valid_string(\"(())((())()()(*)(*()(())())())()()((()())((()))(*\") == False\nassert check_valid_string(\"*()(())*()(()()((()(()()*)(*(())((((((((()*)(()(*)\") == False\nassert check_valid_string(\"****\") == True  # All asterisks can be treated as empty\nassert check_valid_string(\"((((****))\") == True  # Asterisks balance uneven parentheses\n\n[/Example 3]", "temperature": 0.918, "question": "Given a string containing only three types of characters: '(', ')' and '*', write a function to check whether this string is valid. We define the validity of a string by these rules:\n\n1. Any left parenthesis '(' must have a corresponding right parenthesis ')'.\n2. Any right parenthesis ')' must have a corresponding left parenthesis '('.\n3. Left parenthesis '(' must go before the corresponding right parenthesis ')'.\n4. '*' could be treated as a single right parenthesis ')' or a single left parenthesis '(' or an empty string.\n5. An empty string is also valid.\n\nReturn true if the string is valid, otherwise return false.", "code": "def check_valid_string(s: str) -> bool:\n    balance_min = balance_max = 0\n    for char in s:\n        if char == '(':\n            balance_min += 1\n            balance_max += 1\n        elif char == ')':\n            balance_min = max(balance_min - 1, 0)\n            balance_max -= 1\n            if balance_max < 0:\n                return False\n        elif char == '*':\n            balance_min = max(balance_min - 1, 0)\n            balance_max += 1\n\n    return balance_min == 0", "asserts": ["assert check_valid_string(\"()\") == True", "assert check_valid_string(\"(*)\") == True", "assert check_valid_string(\"(*))\") == True", "assert check_valid_string(\"(*()\") == True", "assert check_valid_string(\")*()\") == False", "assert check_valid_string(\"(()\") == False", "assert check_valid_string(\"())\") == False", "assert check_valid_string(\"(*))*)\") == True", "assert check_valid_string(\"((*)\") == True", "assert check_valid_string(\"(*)*(**)\") == True", "assert check_valid_string(\"\") == True  # Edge case: empty string", "assert check_valid_string(\"(((((*)))**\") == True", "assert check_valid_string(\"(((((*)))\") == False", "assert check_valid_string(\"(())((())()()(*)(*()(())())())()()((()())((()))(*\") == False", "assert check_valid_string(\"*()(())*()(()()((()(()()*)(*(())((((((((()*)(()(*)\") == False", "assert check_valid_string(\"****\") == True  # All asterisks can be treated as empty", "assert check_valid_string(\"((((****))\") == True  # Asterisks balance uneven parentheses"], "author": "GPT", "UUID": "f2b531f7-2078-4299-8e02-149c0938641a", "tc_status": [["assert check_valid_string(\"()\") == True", "Passed"], ["assert check_valid_string(\"(*)\") == True", "Passed"], ["assert check_valid_string(\"(*))\") == True", "Passed"], ["assert check_valid_string(\"(*()\") == True", "Passed"], ["assert check_valid_string(\")*()\") == False", "Passed"], ["assert check_valid_string(\"(()\") == False", "Passed"], ["assert check_valid_string(\"())\") == False", "Passed"], ["assert check_valid_string(\"(*))*)\") == True", "Passed"], ["assert check_valid_string(\"((*)\") == True", "Passed"], ["assert check_valid_string(\"(*)*(**)\") == True", "Passed"], ["assert check_valid_string(\"\") == True  # Edge case: empty string", "Passed"], ["assert check_valid_string(\"(((((*)))**\") == True", "Passed"], ["assert check_valid_string(\"(((((*)))\") == False", "Passed"], ["assert check_valid_string(\"(())((())()()(*)(*()(())())())()()((()())((()))(*\") == False", "Passed"], ["assert check_valid_string(\"*()(())*()(()()((()(()()*)(*(())((((((((()*)(()(*)\") == False", "Passed"], ["assert check_valid_string(\"****\") == True  # All asterisks can be treated as empty", "Passed"], ["assert check_valid_string(\"((((****))\") == True  # Asterisks balance uneven parentheses", "Passed"]]}, {"few_shots": [{"author": "Calvin", "UUID": "87372a22-f5ef-4100-845b-28700ca3fde3", "question": "You are given a string s and an integer array indices of the same length. The string s will be shuffled such that the character at the ith position moves to indices[i] in the shuffled string.\n\nReturn the shuffled string.", "examples": "Input: s = \"codeleet\", indices = [4,5,6,7,0,2,1,3]\nOutput: \"leetcode\"\n\nInput: s = \"abc\", indices = [0,1,2]\nOutput: \"abc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "from typing import List\ndef shuffle_string(s: str, indices: List[int]) -> str:\n    def partitionString(s):\n      substrings = 1\n      cur_str = set()\n      for i in range(len(s)):\n        if s[i] in cur_str:\n          substrings += 1\n          cur_str = {s[i]}\n        else:\n          cur_str.add(s[i])\n      return substrings\n    ret = ['_']*len(s)\n    for idx, i in enumerate(indices):\n        ret[i] = s[idx]\n    return \"\".join(ret)\n", "asserts": ["assert shuffle_string(\"reoc\", [2, 0, 1, 3]) == \"eorc\"", "assert shuffle_string(\"aiohn\", [3,1,4,2,0]) == \"nihao\"", "assert shuffle_string(\"aax\", [0,2,1]) == \"axa\"", "assert shuffle_string(\"gh\", [1,0]) == \"hg\"", "assert shuffle_string(\"\", []) == \"\"  # Edge case: empty string", "assert shuffle_string(\"xy\", [0,1]) == \"xy\"  # No shuffle required", "assert shuffle_string(\"pqrstuvwxyzabcdefghijklmno\", list(range(25, -1, -1))) == \"onmlkjihgfedcbazyxwvutsrqp\"  # Reverse shuffle"]}, {"author": "Calvin", "UUID": "56b48f6d-0d81-478d-b838-4d47b62d3031", "question": "Given an integer n, return the number of strings of length n that consist only of vowels (a, e, i, o, u) and are lexicographically sorted.\n\nA string s is lexicographically sorted if for all valid i, s[i] is the same as or comes before s[i+1] in the alphabet.", "examples": "Input: 1\nOutput: 5\n\nInput: 2\nOutput: 15", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def helper(n, letter_idx):\n  letters = [\"a\",\"e\",\"i\",\"o\",\"u\"]\n  dynamic = {\n      'a1' : 5,\n      'e1' : 4,\n      'i1' : 3,\n      'o1' : 2,\n      'u1' : 1\n  }\n  ret = 0\n  key = letters[letter_idx] + str(n)\n  if key in dynamic.keys():\n    return dynamic[key]\n  else:\n    for i in range(letter_idx, len(letters)):\n      ret += helper(n-1, i)\n    dynamic[key] = ret\n  return ret\n  \n\ndef countVowelStrings(n: int) -> int:\n  return helper(n, 0)\n", "asserts": ["assert countVowelStrings(3) == 35", "assert countVowelStrings(4) == 70", "assert countVowelStrings(5) == 126", "assert countVowelStrings(6) == 210", "assert countVowelStrings(7) == 330", "assert countVowelStrings(10) == 1001", "assert countVowelStrings(15) == 3876"]}], "category": "String", "prompt_tokens": 851, "total_tokens": 1109, "completion_tokens": 258, "completion": "Given two strings, base and remove, return a new string where all occurrences of the string remove have been removed from the base. If the string remove does not appear in base, return the base string unchanged. The matching should be case-sensitive.\n\n###Code: \n\ndef removeOccurrences(base: str, remove: str) -> str:\n    while remove in base:\n        base = base.replace(remove, \"\", 1)  # Remove only one occurrence at a time\n    return base\n\n###Testcases: \n\nassert removeOccurrences(\"daabcbaabcbc\", \"abc\") == \"dab\"\nassert removeOccurrences(\"axxyxx\", \"xx\") == \"ay\"\nassert removeOccurrences(\"abababab\", \"abab\") == \"ab\"\nassert removeOccurrences(\"teststring\", \"test\") == \"string\"\nassert removeOccurrences(\"hellohello\", \"hello\") == \"\"\nassert removeOccurrences(\"mississippi\", \"iss\") == \"mippi\"\nassert removeOccurrences(\"foobarbarfoo\", \"bar\") == \"foofoo\"\nassert removeOccurrences(\"abc\", \"def\") == \"abc\"  # 'remove' does not exist in 'base'\nassert removeOccurrences(\"aaa\", \"a\") == \"\"  # All characters are removed\n\n[/Example 3]", "temperature": 0.895, "question": "Given two strings, base and remove, return a new string where all occurrences of the string remove have been removed from the base. If the string remove does not appear in base, return the base string unchanged. The matching should be case-sensitive.", "code": "def removeOccurrences(base: str, remove: str) -> str:\n    while remove in base:\n        base = base.replace(remove, \"\", 1)  # Remove only one occurrence at a time\n    return base", "asserts": ["assert removeOccurrences(\"daabcbaabcbc\", \"abc\") == \"dab\"", "assert removeOccurrences(\"axxyxx\", \"xx\") == \"ay\"", "assert removeOccurrences(\"teststring\", \"test\") == \"string\"", "assert removeOccurrences(\"hellohello\", \"hello\") == \"\"", "assert removeOccurrences(\"mississippi\", \"iss\") == \"mippi\"", "assert removeOccurrences(\"foobarbarfoo\", \"bar\") == \"foofoo\"", "assert removeOccurrences(\"abc\", \"def\") == \"abc\"  # 'remove' does not exist in 'base'", "assert removeOccurrences(\"aaa\", \"a\") == \"\"  # All characters are removed"], "author": "GPT", "UUID": "e35564ff-0718-4dda-b0b0-a3b7359eeb4b", "tc_status": [["assert removeOccurrences(\"daabcbaabcbc\", \"abc\") == \"dab\"", "Passed"], ["assert removeOccurrences(\"axxyxx\", \"xx\") == \"ay\"", "Passed"], ["assert removeOccurrences(\"teststring\", \"test\") == \"string\"", "Passed"], ["assert removeOccurrences(\"hellohello\", \"hello\") == \"\"", "Passed"], ["assert removeOccurrences(\"mississippi\", \"iss\") == \"mippi\"", "Passed"], ["assert removeOccurrences(\"foobarbarfoo\", \"bar\") == \"foofoo\"", "Passed"], ["assert removeOccurrences(\"abc\", \"def\") == \"abc\"  # 'remove' does not exist in 'base'", "Passed"], ["assert removeOccurrences(\"aaa\", \"a\") == \"\"  # All characters are removed", "Passed"]]}, {"few_shots": [{"author": "Calvin", "UUID": "87372a22-f5ef-4100-845b-28700ca3fde3", "question": "You are given a string s and an integer array indices of the same length. The string s will be shuffled such that the character at the ith position moves to indices[i] in the shuffled string.\n\nReturn the shuffled string.", "examples": "Input: s = \"codeleet\", indices = [4,5,6,7,0,2,1,3]\nOutput: \"leetcode\"\n\nInput: s = \"abc\", indices = [0,1,2]\nOutput: \"abc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "from typing import List\ndef shuffle_string(s: str, indices: List[int]) -> str:\n    def partitionString(s):\n      substrings = 1\n      cur_str = set()\n      for i in range(len(s)):\n        if s[i] in cur_str:\n          substrings += 1\n          cur_str = {s[i]}\n        else:\n          cur_str.add(s[i])\n      return substrings\n    ret = ['_']*len(s)\n    for idx, i in enumerate(indices):\n        ret[i] = s[idx]\n    return \"\".join(ret)\n", "asserts": ["assert shuffle_string(\"reoc\", [2, 0, 1, 3]) == \"eorc\"", "assert shuffle_string(\"aiohn\", [3,1,4,2,0]) == \"nihao\"", "assert shuffle_string(\"aax\", [0,2,1]) == \"axa\"", "assert shuffle_string(\"gh\", [1,0]) == \"hg\"", "assert shuffle_string(\"\", []) == \"\"  # Edge case: empty string", "assert shuffle_string(\"xy\", [0,1]) == \"xy\"  # No shuffle required", "assert shuffle_string(\"pqrstuvwxyzabcdefghijklmno\", list(range(25, -1, -1))) == \"onmlkjihgfedcbazyxwvutsrqp\"  # Reverse shuffle"]}, {"author": "Calvin", "UUID": "56b48f6d-0d81-478d-b838-4d47b62d3031", "question": "Given an integer n, return the number of strings of length n that consist only of vowels (a, e, i, o, u) and are lexicographically sorted.\n\nA string s is lexicographically sorted if for all valid i, s[i] is the same as or comes before s[i+1] in the alphabet.", "examples": "Input: 1\nOutput: 5\n\nInput: 2\nOutput: 15", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def helper(n, letter_idx):\n  letters = [\"a\",\"e\",\"i\",\"o\",\"u\"]\n  dynamic = {\n      'a1' : 5,\n      'e1' : 4,\n      'i1' : 3,\n      'o1' : 2,\n      'u1' : 1\n  }\n  ret = 0\n  key = letters[letter_idx] + str(n)\n  if key in dynamic.keys():\n    return dynamic[key]\n  else:\n    for i in range(letter_idx, len(letters)):\n      ret += helper(n-1, i)\n    dynamic[key] = ret\n  return ret\n  \n\ndef countVowelStrings(n: int) -> int:\n  return helper(n, 0)\n", "asserts": ["assert countVowelStrings(3) == 35", "assert countVowelStrings(4) == 70", "assert countVowelStrings(5) == 126", "assert countVowelStrings(6) == 210", "assert countVowelStrings(7) == 330", "assert countVowelStrings(10) == 1001", "assert countVowelStrings(15) == 3876"]}], "category": "String", "prompt_tokens": 851, "total_tokens": 1074, "completion_tokens": 223, "completion": "Write a function to check if a string contains all unique characters. Assume the string contains only ASCII characters.\n\n###Code: \n\ndef is_unique(s: str) -> bool:\n    if len(s) > 128:  # There are 128 different ASCII characters\n        return False\n    char_set = [False] * 128\n    for char in s:\n        val = ord(char)\n        if char_set[val]:\n            return False\n        char_set[val] = True\n    return True\n\n###Testcases: \n\nassert is_unique(\"abcdef\") == True\nassert is_unique(\"aabbcc\") == False\nassert is_unique(\"abcABC\") == True\nassert is_unique(\"1234567890\") == True\nassert is_unique(\"AaBbCc123!\") == True\nassert is_unique(\"!@#$%^&*()_+\") == True\nassert is_unique(\"The quick brown fox jumps over the lazy dog\") == False  # Contains every letter of the alphabet\nassert is_unique(\"\") == True  # Edge case: empty string\n\n[/Example 3]", "temperature": 0.669, "question": "Write a function to check if a string contains all unique characters. Assume the string contains only ASCII characters.", "code": "def is_unique(s: str) -> bool:\n    if len(s) > 128:  # There are 128 different ASCII characters\n        return False\n    char_set = [False] * 128\n    for char in s:\n        val = ord(char)\n        if char_set[val]:\n            return False\n        char_set[val] = True\n    return True", "asserts": ["assert is_unique(\"abcdef\") == True", "assert is_unique(\"aabbcc\") == False", "assert is_unique(\"abcABC\") == True", "assert is_unique(\"1234567890\") == True", "assert is_unique(\"AaBbCc123!\") == True", "assert is_unique(\"!@#$%^&*()_+\") == True", "assert is_unique(\"The quick brown fox jumps over the lazy dog\") == False  # Contains every letter of the alphabet", "assert is_unique(\"\") == True  # Edge case: empty string"], "author": "GPT", "UUID": "07854ded-61b6-4510-8c71-fd91355aeee1", "tc_status": [["assert is_unique(\"abcdef\") == True", "Passed"], ["assert is_unique(\"aabbcc\") == False", "Passed"], ["assert is_unique(\"abcABC\") == True", "Passed"], ["assert is_unique(\"1234567890\") == True", "Passed"], ["assert is_unique(\"AaBbCc123!\") == True", "Passed"], ["assert is_unique(\"!@#$%^&*()_+\") == True", "Passed"], ["assert is_unique(\"The quick brown fox jumps over the lazy dog\") == False  # Contains every letter of the alphabet", "Passed"], ["assert is_unique(\"\") == True  # Edge case: empty string", "Passed"]]}, {"few_shots": [{"author": "Calvin", "UUID": "87372a22-f5ef-4100-845b-28700ca3fde3", "question": "You are given a string s and an integer array indices of the same length. The string s will be shuffled such that the character at the ith position moves to indices[i] in the shuffled string.\n\nReturn the shuffled string.", "examples": "Input: s = \"codeleet\", indices = [4,5,6,7,0,2,1,3]\nOutput: \"leetcode\"\n\nInput: s = \"abc\", indices = [0,1,2]\nOutput: \"abc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "from typing import List\ndef shuffle_string(s: str, indices: List[int]) -> str:\n    def partitionString(s):\n      substrings = 1\n      cur_str = set()\n      for i in range(len(s)):\n        if s[i] in cur_str:\n          substrings += 1\n          cur_str = {s[i]}\n        else:\n          cur_str.add(s[i])\n      return substrings\n    ret = ['_']*len(s)\n    for idx, i in enumerate(indices):\n        ret[i] = s[idx]\n    return \"\".join(ret)\n", "asserts": ["assert shuffle_string(\"reoc\", [2, 0, 1, 3]) == \"eorc\"", "assert shuffle_string(\"aiohn\", [3,1,4,2,0]) == \"nihao\"", "assert shuffle_string(\"aax\", [0,2,1]) == \"axa\"", "assert shuffle_string(\"gh\", [1,0]) == \"hg\"", "assert shuffle_string(\"\", []) == \"\"  # Edge case: empty string", "assert shuffle_string(\"xy\", [0,1]) == \"xy\"  # No shuffle required", "assert shuffle_string(\"pqrstuvwxyzabcdefghijklmno\", list(range(25, -1, -1))) == \"onmlkjihgfedcbazyxwvutsrqp\"  # Reverse shuffle"]}, {"author": "Calvin", "UUID": "56b48f6d-0d81-478d-b838-4d47b62d3031", "question": "Given an integer n, return the number of strings of length n that consist only of vowels (a, e, i, o, u) and are lexicographically sorted.\n\nA string s is lexicographically sorted if for all valid i, s[i] is the same as or comes before s[i+1] in the alphabet.", "examples": "Input: 1\nOutput: 5\n\nInput: 2\nOutput: 15", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def helper(n, letter_idx):\n  letters = [\"a\",\"e\",\"i\",\"o\",\"u\"]\n  dynamic = {\n      'a1' : 5,\n      'e1' : 4,\n      'i1' : 3,\n      'o1' : 2,\n      'u1' : 1\n  }\n  ret = 0\n  key = letters[letter_idx] + str(n)\n  if key in dynamic.keys():\n    return dynamic[key]\n  else:\n    for i in range(letter_idx, len(letters)):\n      ret += helper(n-1, i)\n    dynamic[key] = ret\n  return ret\n  \n\ndef countVowelStrings(n: int) -> int:\n  return helper(n, 0)\n", "asserts": ["assert countVowelStrings(3) == 35", "assert countVowelStrings(4) == 70", "assert countVowelStrings(5) == 126", "assert countVowelStrings(6) == 210", "assert countVowelStrings(7) == 330", "assert countVowelStrings(10) == 1001", "assert countVowelStrings(15) == 3876"]}], "category": "String", "prompt_tokens": 851, "total_tokens": 1107, "completion_tokens": 256, "completion": "Given a string text and another string brokenLetters, return the number of words in text that are not broken.\n\nA word is broken if it contains any letters that are in brokenLetters. If a word does not contain any of these characters, it is not broken.\n\nWords are separated by a single space character.\n\n###Code:\n\ndef canBeTypedWords(text: str, brokenLetters: str) -> int:\n    words = text.split()\n    broken_set = set(brokenLetters)\n    return sum(not set(word) & broken_set for word in words)\n\n###Testcases:\n\nassert canBeTypedWords(\"hello world\", \"ad\") == 1\nassert canBeTypedWords(\"leet code\", \"lt\") == 1\nassert canBeTypedWords(\"broken words here\", \"brkn\") == 0\nassert canBeTypedWords(\"hello there\", \"xyz\") == 2\nassert canBeTypedWords(\"coding\", \"\") == 1  # Edge case: No broken letters\nassert canBeTypedWords(\"\", \"abc\") == 0  # Edge case: Empty text\nassert canBeTypedWords(\"this is a test sentence\", \"aeiou\") == 0  # Edge case: All vowels broken\n\n[/Example 3]", "temperature": 0.928, "question": "Given a string text and another string brokenLetters, return the number of words in text that are not broken.\n\nA word is broken if it contains any letters that are in brokenLetters. If a word does not contain any of these characters, it is not broken.\n\nWords are separated by a single space character.", "code": "def canBeTypedWords(text: str, brokenLetters: str) -> int:\n    words = text.split()\n    broken_set = set(brokenLetters)\n    return sum(not set(word) & broken_set for word in words)", "asserts": ["assert canBeTypedWords(\"hello world\", \"ad\") == 1", "assert canBeTypedWords(\"leet code\", \"lt\") == 1", "assert canBeTypedWords(\"broken words here\", \"brkn\") == 0", "assert canBeTypedWords(\"hello there\", \"xyz\") == 2", "assert canBeTypedWords(\"coding\", \"\") == 1  # Edge case: No broken letters", "assert canBeTypedWords(\"\", \"abc\") == 0  # Edge case: Empty text", "assert canBeTypedWords(\"this is a test sentence\", \"aeiou\") == 0  # Edge case: All vowels broken"], "author": "GPT", "UUID": "6241f005-dde8-4071-b2a5-4bf3ef77e9d6", "tc_status": [["assert canBeTypedWords(\"hello world\", \"ad\") == 1", "Passed"], ["assert canBeTypedWords(\"leet code\", \"lt\") == 1", "Passed"], ["assert canBeTypedWords(\"broken words here\", \"brkn\") == 0", "Passed"], ["assert canBeTypedWords(\"hello there\", \"xyz\") == 2", "Passed"], ["assert canBeTypedWords(\"coding\", \"\") == 1  # Edge case: No broken letters", "Passed"], ["assert canBeTypedWords(\"\", \"abc\") == 0  # Edge case: Empty text", "Passed"], ["assert canBeTypedWords(\"this is a test sentence\", \"aeiou\") == 0  # Edge case: All vowels broken", "Passed"]]}, {"few_shots": [{"author": "Calvin", "UUID": "56b48f6d-0d81-478d-b838-4d47b62d3031", "question": "Given an integer n, return the number of strings of length n that consist only of vowels (a, e, i, o, u) and are lexicographically sorted.\n\nA string s is lexicographically sorted if for all valid i, s[i] is the same as or comes before s[i+1] in the alphabet.", "examples": "Input: 1\nOutput: 5\n\nInput: 2\nOutput: 15", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def helper(n, letter_idx):\n  letters = [\"a\",\"e\",\"i\",\"o\",\"u\"]\n  dynamic = {\n      'a1' : 5,\n      'e1' : 4,\n      'i1' : 3,\n      'o1' : 2,\n      'u1' : 1\n  }\n  ret = 0\n  key = letters[letter_idx] + str(n)\n  if key in dynamic.keys():\n    return dynamic[key]\n  else:\n    for i in range(letter_idx, len(letters)):\n      ret += helper(n-1, i)\n    dynamic[key] = ret\n  return ret\n  \n\ndef countVowelStrings(n: int) -> int:\n  return helper(n, 0)\n", "asserts": ["assert countVowelStrings(3) == 35", "assert countVowelStrings(4) == 70", "assert countVowelStrings(5) == 126", "assert countVowelStrings(6) == 210", "assert countVowelStrings(7) == 330", "assert countVowelStrings(10) == 1001", "assert countVowelStrings(15) == 3876"]}, {"author": "Calvin", "UUID": "ac641352-08d5-4950-8993-6a143da92ecf", "question": "You are given a string s and an integer k. You can choose one of the first k letters of s and append it at the end of the string.\n\nReturn the lexicographically smallest string you could have after applying the mentioned step any number of moves.\n", "examples": "Input: s = \"cba\", k = 1\nOutput: \"acb\"\n\nInput: s = \"baaca\", k = 3\nOutput: \"aaabc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef orderlyQueue(s: str, k: int) -> str:\n    if k == 1:\n        n = len(s)\n        ss = s + s\n        lex_min_str = s\n        for i in range(n):\n            lex_min_str = min(lex_min_str, ss[i:i + n])\n        return lex_min_str\n    \n    return \"\".join(sorted(s))\n", "asserts": ["assert orderlyQueue(\"abcd\", 1) == \"abcd\"", "assert orderlyQueue(\"hello\", 2) == \"ehllo\"", "assert orderlyQueue(\"programming\", 1) == \"ammingprogr\"", "assert orderlyQueue(\"rotator\", 1) == \"atorrot\"", "assert orderlyQueue(\"zxyabc\", 5) == \"abcxyz\"", "assert orderlyQueue(\"xy\", 2) == \"xy\""]}], "category": "String", "prompt_tokens": 745, "total_tokens": 1014, "completion_tokens": 269, "completion": "Write a function that takes a string s and an integer k. The function should return a new string where each character in the new string is the letter that is k letters later in the alphabet than the corresponding character in the input string s. If the operation takes you past the end of the alphabet, start again at the letter 'a'. Assume all letters in s are lowercase, and k is a non-negative integer.\n\n###Code: \n\ndef caesarCipher(s: str, k: int) -> str:\n    result = []\n    for char in s:\n        if char.isalpha():\n            shifted = ord(char) + k % 26\n            if shifted > ord('z'):\n                shifted -= 26\n            result.append(chr(shifted))\n        else:\n            result.append(char)\n    return ''.join(result)\n\n###Testcases: \n\nassert caesarCipher(\"abcd\", 2) == \"cdef\"\nassert caesarCipher(\"xyz\", 3) == \"abc\"\nassert caesarCipher(\"hello\", 26) == \"hello\"\nassert caesarCipher(\"programming\", 5) == \"uwtlwfrrnsl\"\nassert caesarCipher(\"input\", 0) == \"input\"\nassert caesarCipher(\"zulu\", 1) == \"avmv\"\n\n[/Example 3]", "temperature": 0.812, "question": "Write a function that takes a string s and an integer k. The function should return a new string where each character in the new string is the letter that is k letters later in the alphabet than the corresponding character in the input string s. If the operation takes you past the end of the alphabet, start again at the letter 'a'. Assume all letters in s are lowercase, and k is a non-negative integer.", "code": "def caesarCipher(s: str, k: int) -> str:\n    result = []\n    for char in s:\n        if char.isalpha():\n            shifted = ord(char) + k % 26\n            if shifted > ord('z'):\n                shifted -= 26\n            result.append(chr(shifted))\n        else:\n            result.append(char)\n    return ''.join(result)", "asserts": ["assert caesarCipher(\"abcd\", 2) == \"cdef\"", "assert caesarCipher(\"xyz\", 3) == \"abc\"", "assert caesarCipher(\"hello\", 26) == \"hello\"", "assert caesarCipher(\"programming\", 5) == \"uwtlwfrrnsl\"", "assert caesarCipher(\"input\", 0) == \"input\"", "assert caesarCipher(\"zulu\", 1) == \"avmv\""], "author": "GPT", "UUID": "54bb3363-d63d-41f8-bb02-92a77be02ba9", "tc_status": [["assert caesarCipher(\"abcd\", 2) == \"cdef\"", "Passed"], ["assert caesarCipher(\"xyz\", 3) == \"abc\"", "Passed"], ["assert caesarCipher(\"hello\", 26) == \"hello\"", "Passed"], ["assert caesarCipher(\"programming\", 5) == \"uwtlwfrrnsl\"", "Passed"], ["assert caesarCipher(\"input\", 0) == \"input\"", "Passed"], ["assert caesarCipher(\"zulu\", 1) == \"avmv\"", "Passed"]]}, {"few_shots": [{"author": "Calvin", "UUID": "56b48f6d-0d81-478d-b838-4d47b62d3031", "question": "Given an integer n, return the number of strings of length n that consist only of vowels (a, e, i, o, u) and are lexicographically sorted.\n\nA string s is lexicographically sorted if for all valid i, s[i] is the same as or comes before s[i+1] in the alphabet.", "examples": "Input: 1\nOutput: 5\n\nInput: 2\nOutput: 15", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def helper(n, letter_idx):\n  letters = [\"a\",\"e\",\"i\",\"o\",\"u\"]\n  dynamic = {\n      'a1' : 5,\n      'e1' : 4,\n      'i1' : 3,\n      'o1' : 2,\n      'u1' : 1\n  }\n  ret = 0\n  key = letters[letter_idx] + str(n)\n  if key in dynamic.keys():\n    return dynamic[key]\n  else:\n    for i in range(letter_idx, len(letters)):\n      ret += helper(n-1, i)\n    dynamic[key] = ret\n  return ret\n  \n\ndef countVowelStrings(n: int) -> int:\n  return helper(n, 0)\n", "asserts": ["assert countVowelStrings(3) == 35", "assert countVowelStrings(4) == 70", "assert countVowelStrings(5) == 126", "assert countVowelStrings(6) == 210", "assert countVowelStrings(7) == 330", "assert countVowelStrings(10) == 1001", "assert countVowelStrings(15) == 3876"]}, {"author": "Calvin", "UUID": "ac641352-08d5-4950-8993-6a143da92ecf", "question": "You are given a string s and an integer k. You can choose one of the first k letters of s and append it at the end of the string.\n\nReturn the lexicographically smallest string you could have after applying the mentioned step any number of moves.\n", "examples": "Input: s = \"cba\", k = 1\nOutput: \"acb\"\n\nInput: s = \"baaca\", k = 3\nOutput: \"aaabc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef orderlyQueue(s: str, k: int) -> str:\n    if k == 1:\n        n = len(s)\n        ss = s + s\n        lex_min_str = s\n        for i in range(n):\n            lex_min_str = min(lex_min_str, ss[i:i + n])\n        return lex_min_str\n    \n    return \"\".join(sorted(s))\n", "asserts": ["assert orderlyQueue(\"abcd\", 1) == \"abcd\"", "assert orderlyQueue(\"hello\", 2) == \"ehllo\"", "assert orderlyQueue(\"programming\", 1) == \"ammingprogr\"", "assert orderlyQueue(\"rotator\", 1) == \"atorrot\"", "assert orderlyQueue(\"zxyabc\", 5) == \"abcxyz\"", "assert orderlyQueue(\"xy\", 2) == \"xy\""]}], "category": "String", "prompt_tokens": 745, "total_tokens": 1093, "completion_tokens": 348, "completion": "Given a string s and a non-empty string p, find all the start indices of p's anagrams in s. Strings s and p consist of lowercase English letters only.\n\nThe order of output does not matter.\n\n###Code: \n\nfrom collections import Counter\n\ndef findAnagrams(s: str, p: str):\n    p_counter = Counter(p)\n    s_counter = Counter(s[:len(p)-1])\n    start_indices = []\n\n    for i in range(len(p)-1, len(s)):\n        s_counter[s[i]] += 1   # include a new char in the window\n        if s_counter == p_counter:  # this step compares counts of all letters\n            start_indices.append(i-len(p)+1)  # append the starting index\n        s_counter[s[i-len(p)+1]] -= 1  # decrease the count of the oldest char in the window\n        if s_counter[s[i-len(p)+1]] == 0:\n            del s_counter[s[i-len(p)+1]]  # remove the count if it is zero to avoid unnecessary items\n\n    return start_indices\n\n###Testcases:\n\nassert findAnagrams(\"cbaebabacd\", \"abc\") == [0, 6]\nassert findAnagrams(\"abab\", \"ab\") == [0, 1, 2]\nassert findAnagrams(\"acdbacdacb\", \"abc\") == [3, 4, 7]\nassert findAnagrams(\"aa\", \"bb\") == []\nassert findAnagrams(\"a\" * 10000, \"a\" * 9999) == [0]\nassert findAnagrams(\"af\", \"be\") == []\n\n[/Example 3]", "temperature": 0.818, "question": "Given a string s and a non-empty string p, find all the start indices of p's anagrams in s. Strings s and p consist of lowercase English letters only.\n\nThe order of output does not matter.", "code": "from collections import Counter\n\ndef findAnagrams(s: str, p: str):\n    p_counter = Counter(p)\n    s_counter = Counter(s[:len(p)-1])\n    start_indices = []\n\n    for i in range(len(p)-1, len(s)):\n        s_counter[s[i]] += 1   # include a new char in the window\n        if s_counter == p_counter:  # this step compares counts of all letters\n            start_indices.append(i-len(p)+1)  # append the starting index\n        s_counter[s[i-len(p)+1]] -= 1  # decrease the count of the oldest char in the window\n        if s_counter[s[i-len(p)+1]] == 0:\n            del s_counter[s[i-len(p)+1]]  # remove the count if it is zero to avoid unnecessary items\n\n    return start_indices", "asserts": ["assert findAnagrams(\"cbaebabacd\", \"abc\") == [0, 6]", "assert findAnagrams(\"abab\", \"ab\") == [0, 1, 2]", "assert findAnagrams(\"aa\", \"bb\") == []", "assert findAnagrams(\"af\", \"be\") == []"], "author": "GPT", "UUID": "e5f37557-6547-43ce-9bfb-6a74b1bd48e1", "tc_status": [["assert findAnagrams(\"cbaebabacd\", \"abc\") == [0, 6]", "Passed"], ["assert findAnagrams(\"abab\", \"ab\") == [0, 1, 2]", "Passed"], ["assert findAnagrams(\"aa\", \"bb\") == []", "Passed"], ["assert findAnagrams(\"af\", \"be\") == []", "Passed"]]}, {"few_shots": [{"author": "Calvin", "UUID": "56b48f6d-0d81-478d-b838-4d47b62d3031", "question": "Given an integer n, return the number of strings of length n that consist only of vowels (a, e, i, o, u) and are lexicographically sorted.\n\nA string s is lexicographically sorted if for all valid i, s[i] is the same as or comes before s[i+1] in the alphabet.", "examples": "Input: 1\nOutput: 5\n\nInput: 2\nOutput: 15", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def helper(n, letter_idx):\n  letters = [\"a\",\"e\",\"i\",\"o\",\"u\"]\n  dynamic = {\n      'a1' : 5,\n      'e1' : 4,\n      'i1' : 3,\n      'o1' : 2,\n      'u1' : 1\n  }\n  ret = 0\n  key = letters[letter_idx] + str(n)\n  if key in dynamic.keys():\n    return dynamic[key]\n  else:\n    for i in range(letter_idx, len(letters)):\n      ret += helper(n-1, i)\n    dynamic[key] = ret\n  return ret\n  \n\ndef countVowelStrings(n: int) -> int:\n  return helper(n, 0)\n", "asserts": ["assert countVowelStrings(3) == 35", "assert countVowelStrings(4) == 70", "assert countVowelStrings(5) == 126", "assert countVowelStrings(6) == 210", "assert countVowelStrings(7) == 330", "assert countVowelStrings(10) == 1001", "assert countVowelStrings(15) == 3876"]}, {"author": "Calvin", "UUID": "ac641352-08d5-4950-8993-6a143da92ecf", "question": "You are given a string s and an integer k. You can choose one of the first k letters of s and append it at the end of the string.\n\nReturn the lexicographically smallest string you could have after applying the mentioned step any number of moves.\n", "examples": "Input: s = \"cba\", k = 1\nOutput: \"acb\"\n\nInput: s = \"baaca\", k = 3\nOutput: \"aaabc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef orderlyQueue(s: str, k: int) -> str:\n    if k == 1:\n        n = len(s)\n        ss = s + s\n        lex_min_str = s\n        for i in range(n):\n            lex_min_str = min(lex_min_str, ss[i:i + n])\n        return lex_min_str\n    \n    return \"\".join(sorted(s))\n", "asserts": ["assert orderlyQueue(\"abcd\", 1) == \"abcd\"", "assert orderlyQueue(\"hello\", 2) == \"ehllo\"", "assert orderlyQueue(\"programming\", 1) == \"ammingprogr\"", "assert orderlyQueue(\"rotator\", 1) == \"atorrot\"", "assert orderlyQueue(\"zxyabc\", 5) == \"abcxyz\"", "assert orderlyQueue(\"xy\", 2) == \"xy\""]}], "category": "String", "prompt_tokens": 745, "total_tokens": 989, "completion_tokens": 244, "completion": "Given a string containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.\n\nAn input string is valid if:\n1. Open brackets must be closed by the same type of brackets.\n2. Open brackets must be closed in the correct order.\n3. Every close bracket has a corresponding open bracket of the same type.\n\n###Code:\n\ndef isValid(s: str) -> bool:\n    stack = []\n    bracket_map = {\")\": \"(\", \"}\": \"{\", \"]\": \"[\"}\n\n    for char in s:\n        if char in bracket_map.values():\n            stack.append(char)\n        elif char in bracket_map.keys():\n            if stack == [] or bracket_map[char] != stack.pop():\n                return False\n        else:\n            return False\n    return stack == []\n\n###Testcases:\n\nassert isValid(\"()\") == True\nassert isValid(\"()[]{}\") == True\nassert isValid(\"(]\") == False\nassert isValid(\"([)]\") == False\nassert isValid(\"{[]}\") == True\nassert isValid(\"]\") == False\nassert isValid(\"\") == True\nassert isValid(\"((({{{[[[]]]}}})))\") == True\n\n[/Example 3]", "temperature": 0.82, "question": "Given a string containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.\n\nAn input string is valid if:\n1. Open brackets must be closed by the same type of brackets.\n2. Open brackets must be closed in the correct order.\n3. Every close bracket has a corresponding open bracket of the same type.", "code": "def isValid(s: str) -> bool:\n    stack = []\n    bracket_map = {\")\": \"(\", \"}\": \"{\", \"]\": \"[\"}\n\n    for char in s:\n        if char in bracket_map.values():\n            stack.append(char)\n        elif char in bracket_map.keys():\n            if stack == [] or bracket_map[char] != stack.pop():\n                return False\n        else:\n            return False\n    return stack == []", "asserts": ["assert isValid(\"()\") == True", "assert isValid(\"()[]{}\") == True", "assert isValid(\"(]\") == False", "assert isValid(\"([)]\") == False", "assert isValid(\"{[]}\") == True", "assert isValid(\"]\") == False", "assert isValid(\"\") == True", "assert isValid(\"((({{{[[[]]]}}})))\") == True"], "author": "GPT", "UUID": "fafc2af9-2437-4994-97d8-1ec18ed09bd2", "tc_status": [["assert isValid(\"()\") == True", "Passed"], ["assert isValid(\"()[]{}\") == True", "Passed"], ["assert isValid(\"(]\") == False", "Passed"], ["assert isValid(\"([)]\") == False", "Passed"], ["assert isValid(\"{[]}\") == True", "Passed"], ["assert isValid(\"]\") == False", "Passed"], ["assert isValid(\"\") == True", "Passed"], ["assert isValid(\"((({{{[[[]]]}}})))\") == True", "Passed"]]}, {"few_shots": [{"author": "Calvin", "UUID": "56b48f6d-0d81-478d-b838-4d47b62d3031", "question": "Given an integer n, return the number of strings of length n that consist only of vowels (a, e, i, o, u) and are lexicographically sorted.\n\nA string s is lexicographically sorted if for all valid i, s[i] is the same as or comes before s[i+1] in the alphabet.", "examples": "Input: 1\nOutput: 5\n\nInput: 2\nOutput: 15", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def helper(n, letter_idx):\n  letters = [\"a\",\"e\",\"i\",\"o\",\"u\"]\n  dynamic = {\n      'a1' : 5,\n      'e1' : 4,\n      'i1' : 3,\n      'o1' : 2,\n      'u1' : 1\n  }\n  ret = 0\n  key = letters[letter_idx] + str(n)\n  if key in dynamic.keys():\n    return dynamic[key]\n  else:\n    for i in range(letter_idx, len(letters)):\n      ret += helper(n-1, i)\n    dynamic[key] = ret\n  return ret\n  \n\ndef countVowelStrings(n: int) -> int:\n  return helper(n, 0)\n", "asserts": ["assert countVowelStrings(3) == 35", "assert countVowelStrings(4) == 70", "assert countVowelStrings(5) == 126", "assert countVowelStrings(6) == 210", "assert countVowelStrings(7) == 330", "assert countVowelStrings(10) == 1001", "assert countVowelStrings(15) == 3876"]}, {"author": "Calvin", "UUID": "ac641352-08d5-4950-8993-6a143da92ecf", "question": "You are given a string s and an integer k. You can choose one of the first k letters of s and append it at the end of the string.\n\nReturn the lexicographically smallest string you could have after applying the mentioned step any number of moves.\n", "examples": "Input: s = \"cba\", k = 1\nOutput: \"acb\"\n\nInput: s = \"baaca\", k = 3\nOutput: \"aaabc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef orderlyQueue(s: str, k: int) -> str:\n    if k == 1:\n        n = len(s)\n        ss = s + s\n        lex_min_str = s\n        for i in range(n):\n            lex_min_str = min(lex_min_str, ss[i:i + n])\n        return lex_min_str\n    \n    return \"\".join(sorted(s))\n", "asserts": ["assert orderlyQueue(\"abcd\", 1) == \"abcd\"", "assert orderlyQueue(\"hello\", 2) == \"ehllo\"", "assert orderlyQueue(\"programming\", 1) == \"ammingprogr\"", "assert orderlyQueue(\"rotator\", 1) == \"atorrot\"", "assert orderlyQueue(\"zxyabc\", 5) == \"abcxyz\"", "assert orderlyQueue(\"xy\", 2) == \"xy\""]}], "category": "String", "prompt_tokens": 745, "total_tokens": 933, "completion_tokens": 188, "completion": "Given a string s consisting of lowercase English letters, return the first non-repeating character in it. If there is no such character, return an empty string.\n\n###Code:\n\n```python\ndef firstUniqChar(s: str) -> str:\n    frequency = {}\n    for char in s:\n        frequency[char] = frequency.get(char, 0) + 1\n    for char in s:\n        if frequency[char] == 1:\n            return char\n    return \"\"\n```\n\n###Testcases:\n\n```python\nassert firstUniqChar(\"leetcode\") == \"l\"\nassert firstUniqChar(\"loveleetcode\") == \"v\"\nassert firstUniqChar(\"aabb\") == \"\"\nassert firstUniqChar(\"aabbc\") == \"c\"\nassert firstUniqChar(\"z\") == \"z\"\nassert firstUniqChar(\"dddccdbba\") == \"\"\n```\n\n[/Example 3]", "temperature": 0.851, "question": "Given a string s consisting of lowercase English letters, return the first non-repeating character in it. If there is no such character, return an empty string.", "code": "def firstUniqChar(s: str) -> str:\n    frequency = {}\n    for char in s:\n        frequency[char] = frequency.get(char, 0) + 1\n    for char in s:\n        if frequency[char] == 1:\n            return char\n    return \"\"", "asserts": ["assert firstUniqChar(\"leetcode\") == \"l\"", "assert firstUniqChar(\"loveleetcode\") == \"v\"", "assert firstUniqChar(\"aabb\") == \"\"", "assert firstUniqChar(\"aabbc\") == \"c\"", "assert firstUniqChar(\"z\") == \"z\""], "author": "GPT", "UUID": "ca7a0235-e8d0-4339-a773-6a3c22e6c6de", "tc_status": [["assert firstUniqChar(\"leetcode\") == \"l\"", "Passed"], ["assert firstUniqChar(\"loveleetcode\") == \"v\"", "Passed"], ["assert firstUniqChar(\"aabb\") == \"\"", "Passed"], ["assert firstUniqChar(\"aabbc\") == \"c\"", "Passed"], ["assert firstUniqChar(\"z\") == \"z\"", "Passed"]]}, {"few_shots": [{"author": "Calvin", "UUID": "56b48f6d-0d81-478d-b838-4d47b62d3031", "question": "Given an integer n, return the number of strings of length n that consist only of vowels (a, e, i, o, u) and are lexicographically sorted.\n\nA string s is lexicographically sorted if for all valid i, s[i] is the same as or comes before s[i+1] in the alphabet.", "examples": "Input: 1\nOutput: 5\n\nInput: 2\nOutput: 15", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def helper(n, letter_idx):\n  letters = [\"a\",\"e\",\"i\",\"o\",\"u\"]\n  dynamic = {\n      'a1' : 5,\n      'e1' : 4,\n      'i1' : 3,\n      'o1' : 2,\n      'u1' : 1\n  }\n  ret = 0\n  key = letters[letter_idx] + str(n)\n  if key in dynamic.keys():\n    return dynamic[key]\n  else:\n    for i in range(letter_idx, len(letters)):\n      ret += helper(n-1, i)\n    dynamic[key] = ret\n  return ret\n  \n\ndef countVowelStrings(n: int) -> int:\n  return helper(n, 0)\n", "asserts": ["assert countVowelStrings(3) == 35", "assert countVowelStrings(4) == 70", "assert countVowelStrings(5) == 126", "assert countVowelStrings(6) == 210", "assert countVowelStrings(7) == 330", "assert countVowelStrings(10) == 1001", "assert countVowelStrings(15) == 3876"]}, {"author": "Calvin", "UUID": "ac641352-08d5-4950-8993-6a143da92ecf", "question": "You are given a string s and an integer k. You can choose one of the first k letters of s and append it at the end of the string.\n\nReturn the lexicographically smallest string you could have after applying the mentioned step any number of moves.\n", "examples": "Input: s = \"cba\", k = 1\nOutput: \"acb\"\n\nInput: s = \"baaca\", k = 3\nOutput: \"aaabc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef orderlyQueue(s: str, k: int) -> str:\n    if k == 1:\n        n = len(s)\n        ss = s + s\n        lex_min_str = s\n        for i in range(n):\n            lex_min_str = min(lex_min_str, ss[i:i + n])\n        return lex_min_str\n    \n    return \"\".join(sorted(s))\n", "asserts": ["assert orderlyQueue(\"abcd\", 1) == \"abcd\"", "assert orderlyQueue(\"hello\", 2) == \"ehllo\"", "assert orderlyQueue(\"programming\", 1) == \"ammingprogr\"", "assert orderlyQueue(\"rotator\", 1) == \"atorrot\"", "assert orderlyQueue(\"zxyabc\", 5) == \"abcxyz\"", "assert orderlyQueue(\"xy\", 2) == \"xy\""]}], "category": "String", "prompt_tokens": 745, "total_tokens": 938, "completion_tokens": 193, "completion": "Given a string s, reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order.\n\n###Code: \n\ndef reverseWords(s: str) -> str:\n    return ' '.join(word[::-1] for word in s.split())\n\n###Testcases: \n\nassert reverseWords(\"Let's take LeetCode contest\") == \"s'teL ekat edoCteeL tsetnoc\"\nassert reverseWords(\"God Ding\") == \"doG gniD\"\nassert reverseWords(\"Hello World\") == \"olleH dlroW\"\nassert reverseWords(\"The quick brown fox jumps over the lazy dog\") == \"ehT kciuq nworb xof spmuj revo eht yzal god\"\nassert reverseWords(\"a b c d\") == \"a b c d\"\nassert reverseWords(\"double  spaces\") == \"elbuod  secaps\"\n\n[/Example 3]", "temperature": 0.658, "question": "Given a string s, reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order.", "code": "def reverseWords(s: str) -> str:\n    return ' '.join(word[::-1] for word in s.split())", "asserts": ["assert reverseWords(\"Let's take LeetCode contest\") == \"s'teL ekat edoCteeL tsetnoc\"", "assert reverseWords(\"God Ding\") == \"doG gniD\"", "assert reverseWords(\"Hello World\") == \"olleH dlroW\"", "assert reverseWords(\"The quick brown fox jumps over the lazy dog\") == \"ehT kciuq nworb xof spmuj revo eht yzal god\"", "assert reverseWords(\"a b c d\") == \"a b c d\""], "author": "GPT", "UUID": "935b97cf-2d65-4e6d-af08-82c16c90fc36", "tc_status": [["assert reverseWords(\"Let's take LeetCode contest\") == \"s'teL ekat edoCteeL tsetnoc\"", "Passed"], ["assert reverseWords(\"God Ding\") == \"doG gniD\"", "Passed"], ["assert reverseWords(\"Hello World\") == \"olleH dlroW\"", "Passed"], ["assert reverseWords(\"The quick brown fox jumps over the lazy dog\") == \"ehT kciuq nworb xof spmuj revo eht yzal god\"", "Passed"], ["assert reverseWords(\"a b c d\") == \"a b c d\"", "Passed"]]}, {"few_shots": [{"author": "Calvin", "UUID": "56b48f6d-0d81-478d-b838-4d47b62d3031", "question": "Given an integer n, return the number of strings of length n that consist only of vowels (a, e, i, o, u) and are lexicographically sorted.\n\nA string s is lexicographically sorted if for all valid i, s[i] is the same as or comes before s[i+1] in the alphabet.", "examples": "Input: 1\nOutput: 5\n\nInput: 2\nOutput: 15", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def helper(n, letter_idx):\n  letters = [\"a\",\"e\",\"i\",\"o\",\"u\"]\n  dynamic = {\n      'a1' : 5,\n      'e1' : 4,\n      'i1' : 3,\n      'o1' : 2,\n      'u1' : 1\n  }\n  ret = 0\n  key = letters[letter_idx] + str(n)\n  if key in dynamic.keys():\n    return dynamic[key]\n  else:\n    for i in range(letter_idx, len(letters)):\n      ret += helper(n-1, i)\n    dynamic[key] = ret\n  return ret\n  \n\ndef countVowelStrings(n: int) -> int:\n  return helper(n, 0)\n", "asserts": ["assert countVowelStrings(3) == 35", "assert countVowelStrings(4) == 70", "assert countVowelStrings(5) == 126", "assert countVowelStrings(6) == 210", "assert countVowelStrings(7) == 330", "assert countVowelStrings(10) == 1001", "assert countVowelStrings(15) == 3876"]}, {"author": "Calvin", "UUID": "80e34b28-16a8-46ac-8b6a-ee28beb1e8d4", "question": "Write a function that reverses a string. The input string is given as an array of characters s.\n\nYou must do this by modifying the input array in-place with O(1) extra memory.", "examples": "Input: [\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput: [\"o\",\"l\",\"l\",\"e\",\"h\"]\n\nInput: [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\nOutput: [\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def reverse_string(s: list) -> list:\n  l = 0\n  r = len(s) - 1\n  while l < r:\n    tmp = s[l]\n    s[l] = s[r]\n    s[r] = tmp\n    l += 1\n    r -= 1\n  return s\n", "asserts": ["assert reverse_string([\"a\",\"b\",\"c\",\"d\"]) == [\"d\", \"c\", \"b\", \"a\"]", "assert reverse_string([\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"]) == [\"n\", \"o\", \"h\", \"t\", \"y\", \"p\"]", "assert reverse_string([]) == []", "assert reverse_string([\"s\", \"i\", \"n\", \"g\", \"l\", \"e\"]) == [\"e\", \"l\", \"g\", \"n\", \"i\", \"s\"]", "assert reverse_string([\"A\"]) == [\"A\"]", "assert reverse_string([\"9\", \"8\", \"7\", \"6\", \"5\", \"4\", \"3\", \"2\", \"1\"]) == [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]", "assert reverse_string([\"B\", \"o\", \"b\"]) == [\"b\", \"o\", \"B\"]", "assert reverse_string([\"r\", \"e\", \"v\", \"e\", \"r\", \"s\", \"e\"]) == [\"e\", \"s\", \"r\", \"e\", \"v\", \"e\", \"r\"]", "assert reverse_string([\"1\", \"*\", \"2\", \"*\", \"3\"]) == [\"3\", \"*\", \"2\", \"*\", \"1\"]"]}], "category": "String", "prompt_tokens": 910, "total_tokens": 1142, "completion_tokens": 232, "completion": "Given a string s, remove all its adjacent duplicate characters repeatedly until no adjacent duplicates are left. You need to do this in-place and return the final string after all such duplicate removals have been made.\n\nNote that the input string may contain lowercase and uppercase letters.\n\n###Code: \n\ndef remove_adjacent_duplicates(s: str) -> str:\n  stack = []\n  for char in s:\n    if stack and stack[-1] == char:\n      stack.pop()\n    else:\n      stack.append(char)\n  return ''.join(stack)\n\n\n###Testcases: \n\nassert remove_adjacent_duplicates(\"abbaca\") == \"ca\"\nassert remove_adjacent_duplicates(\"azxxzy\") == \"ay\"\nassert remove_adjacent_duplicates(\"a\") == \"a\"\nassert remove_adjacent_duplicates(\"aabccddd\") == \"abd\"\nassert remove_adjacent_duplicates(\"aaaaa\") == \"\"\nassert remove_adjacent_duplicates(\"abbbbcddde\") == \"acde\"\nassert remove_adjacent_duplicates(\"AABBA\") == \"A\"\nassert remove_adjacent_duplicates(\"vVVeEEnnuUu\") == \"nv\"\n\n[/Example 3]", "temperature": 0.86, "question": "Given a string s, remove all its adjacent duplicate characters repeatedly until no adjacent duplicates are left. You need to do this in-place and return the final string after all such duplicate removals have been made.\n\nNote that the input string may contain lowercase and uppercase letters.", "code": "def remove_adjacent_duplicates(s: str) -> str:\n  stack = []\n  for char in s:\n    if stack and stack[-1] == char:\n      stack.pop()\n    else:\n      stack.append(char)\n  return ''.join(stack)", "asserts": ["assert remove_adjacent_duplicates(\"abbaca\") == \"ca\"", "assert remove_adjacent_duplicates(\"azxxzy\") == \"ay\"", "assert remove_adjacent_duplicates(\"a\") == \"a\"", "assert remove_adjacent_duplicates(\"abbbbcddde\") == \"acde\"", "assert remove_adjacent_duplicates(\"AABBA\") == \"A\""], "author": "GPT", "UUID": "45f2f276-4dac-4a81-aac3-a04326945b69", "tc_status": [["assert remove_adjacent_duplicates(\"abbaca\") == \"ca\"", "Passed"], ["assert remove_adjacent_duplicates(\"azxxzy\") == \"ay\"", "Passed"], ["assert remove_adjacent_duplicates(\"a\") == \"a\"", "Passed"], ["assert remove_adjacent_duplicates(\"abbbbcddde\") == \"acde\"", "Passed"], ["assert remove_adjacent_duplicates(\"AABBA\") == \"A\"", "Passed"]]}, {"few_shots": [{"author": "Calvin", "UUID": "56b48f6d-0d81-478d-b838-4d47b62d3031", "question": "Given an integer n, return the number of strings of length n that consist only of vowels (a, e, i, o, u) and are lexicographically sorted.\n\nA string s is lexicographically sorted if for all valid i, s[i] is the same as or comes before s[i+1] in the alphabet.", "examples": "Input: 1\nOutput: 5\n\nInput: 2\nOutput: 15", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def helper(n, letter_idx):\n  letters = [\"a\",\"e\",\"i\",\"o\",\"u\"]\n  dynamic = {\n      'a1' : 5,\n      'e1' : 4,\n      'i1' : 3,\n      'o1' : 2,\n      'u1' : 1\n  }\n  ret = 0\n  key = letters[letter_idx] + str(n)\n  if key in dynamic.keys():\n    return dynamic[key]\n  else:\n    for i in range(letter_idx, len(letters)):\n      ret += helper(n-1, i)\n    dynamic[key] = ret\n  return ret\n  \n\ndef countVowelStrings(n: int) -> int:\n  return helper(n, 0)\n", "asserts": ["assert countVowelStrings(3) == 35", "assert countVowelStrings(4) == 70", "assert countVowelStrings(5) == 126", "assert countVowelStrings(6) == 210", "assert countVowelStrings(7) == 330", "assert countVowelStrings(10) == 1001", "assert countVowelStrings(15) == 3876"]}, {"author": "Calvin", "UUID": "80e34b28-16a8-46ac-8b6a-ee28beb1e8d4", "question": "Write a function that reverses a string. The input string is given as an array of characters s.\n\nYou must do this by modifying the input array in-place with O(1) extra memory.", "examples": "Input: [\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput: [\"o\",\"l\",\"l\",\"e\",\"h\"]\n\nInput: [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\nOutput: [\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def reverse_string(s: list) -> list:\n  l = 0\n  r = len(s) - 1\n  while l < r:\n    tmp = s[l]\n    s[l] = s[r]\n    s[r] = tmp\n    l += 1\n    r -= 1\n  return s\n", "asserts": ["assert reverse_string([\"a\",\"b\",\"c\",\"d\"]) == [\"d\", \"c\", \"b\", \"a\"]", "assert reverse_string([\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"]) == [\"n\", \"o\", \"h\", \"t\", \"y\", \"p\"]", "assert reverse_string([]) == []", "assert reverse_string([\"s\", \"i\", \"n\", \"g\", \"l\", \"e\"]) == [\"e\", \"l\", \"g\", \"n\", \"i\", \"s\"]", "assert reverse_string([\"A\"]) == [\"A\"]", "assert reverse_string([\"9\", \"8\", \"7\", \"6\", \"5\", \"4\", \"3\", \"2\", \"1\"]) == [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]", "assert reverse_string([\"B\", \"o\", \"b\"]) == [\"b\", \"o\", \"B\"]", "assert reverse_string([\"r\", \"e\", \"v\", \"e\", \"r\", \"s\", \"e\"]) == [\"e\", \"s\", \"r\", \"e\", \"v\", \"e\", \"r\"]", "assert reverse_string([\"1\", \"*\", \"2\", \"*\", \"3\"]) == [\"3\", \"*\", \"2\", \"*\", \"1\"]"]}], "category": "String", "prompt_tokens": 910, "total_tokens": 1188, "completion_tokens": 278, "completion": "Write a function to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string \"\".\n\n###Code: \n\ndef longest_common_prefix(strs: list) -> str:\n    if not strs:\n        return \"\"\n    \n    min_len = min(len(s) for s in strs)\n    prefix = \"\"\n    \n    for i in range(min_len):\n        char_set = set(string[i] for string in strs)\n        if len(char_set) == 1:\n            prefix += strs[0][i]\n        else:\n            break\n            \n    return prefix\n\n\n###Testcases: \n\nassert longest_common_prefix([\"flower\", \"flow\", \"flight\"]) == \"fl\"\nassert longest_common_prefix([\"dog\", \"racecar\", \"car\"]) == \"\"\nassert longest_common_prefix([\"interspecies\", \"interstellar\", \"interstate\"]) == \"inters\"\nassert longest_common_prefix([\"throne\", \"throne\"]) == \"throne\"\nassert longest_common_prefix([\"throne\", \"dungeon\"]) == \"\"\nassert longest_common_prefix([\"cheese\"]) == \"cheese\"\nassert longest_common_prefix([\"patch\", \"path\"]) == \"pa\"\nassert longest_common_prefix([]) == \"\"\nassert longest_common_prefix([\"a\"]) == \"a\"\nassert longest_common_prefix([\"reflower\", \"flow\", \"flight\"]) == \"\"\n\n[/Example 3]", "temperature": 0.69, "question": "Write a function to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string \"\".", "code": "def longest_common_prefix(strs: list) -> str:\n    if not strs:\n        return \"\"\n    \n    min_len = min(len(s) for s in strs)\n    prefix = \"\"\n    \n    for i in range(min_len):\n        char_set = set(string[i] for string in strs)\n        if len(char_set) == 1:\n            prefix += strs[0][i]\n        else:\n            break\n            \n    return prefix", "asserts": ["assert longest_common_prefix([\"flower\", \"flow\", \"flight\"]) == \"fl\"", "assert longest_common_prefix([\"dog\", \"racecar\", \"car\"]) == \"\"", "assert longest_common_prefix([\"interspecies\", \"interstellar\", \"interstate\"]) == \"inters\"", "assert longest_common_prefix([\"throne\", \"throne\"]) == \"throne\"", "assert longest_common_prefix([\"throne\", \"dungeon\"]) == \"\"", "assert longest_common_prefix([\"cheese\"]) == \"cheese\"", "assert longest_common_prefix([]) == \"\"", "assert longest_common_prefix([\"a\"]) == \"a\"", "assert longest_common_prefix([\"reflower\", \"flow\", \"flight\"]) == \"\""], "author": "GPT", "UUID": "22826e61-be4e-49fa-aebd-be97c8e4d162", "tc_status": [["assert longest_common_prefix([\"flower\", \"flow\", \"flight\"]) == \"fl\"", "Passed"], ["assert longest_common_prefix([\"dog\", \"racecar\", \"car\"]) == \"\"", "Passed"], ["assert longest_common_prefix([\"interspecies\", \"interstellar\", \"interstate\"]) == \"inters\"", "Passed"], ["assert longest_common_prefix([\"throne\", \"throne\"]) == \"throne\"", "Passed"], ["assert longest_common_prefix([\"throne\", \"dungeon\"]) == \"\"", "Passed"], ["assert longest_common_prefix([\"cheese\"]) == \"cheese\"", "Passed"], ["assert longest_common_prefix([]) == \"\"", "Passed"], ["assert longest_common_prefix([\"a\"]) == \"a\"", "Passed"], ["assert longest_common_prefix([\"reflower\", \"flow\", \"flight\"]) == \"\"", "Passed"]]}, {"few_shots": [{"author": "Calvin", "UUID": "56b48f6d-0d81-478d-b838-4d47b62d3031", "question": "Given an integer n, return the number of strings of length n that consist only of vowels (a, e, i, o, u) and are lexicographically sorted.\n\nA string s is lexicographically sorted if for all valid i, s[i] is the same as or comes before s[i+1] in the alphabet.", "examples": "Input: 1\nOutput: 5\n\nInput: 2\nOutput: 15", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def helper(n, letter_idx):\n  letters = [\"a\",\"e\",\"i\",\"o\",\"u\"]\n  dynamic = {\n      'a1' : 5,\n      'e1' : 4,\n      'i1' : 3,\n      'o1' : 2,\n      'u1' : 1\n  }\n  ret = 0\n  key = letters[letter_idx] + str(n)\n  if key in dynamic.keys():\n    return dynamic[key]\n  else:\n    for i in range(letter_idx, len(letters)):\n      ret += helper(n-1, i)\n    dynamic[key] = ret\n  return ret\n  \n\ndef countVowelStrings(n: int) -> int:\n  return helper(n, 0)\n", "asserts": ["assert countVowelStrings(3) == 35", "assert countVowelStrings(4) == 70", "assert countVowelStrings(5) == 126", "assert countVowelStrings(6) == 210", "assert countVowelStrings(7) == 330", "assert countVowelStrings(10) == 1001", "assert countVowelStrings(15) == 3876"]}, {"author": "Calvin", "UUID": "80e34b28-16a8-46ac-8b6a-ee28beb1e8d4", "question": "Write a function that reverses a string. The input string is given as an array of characters s.\n\nYou must do this by modifying the input array in-place with O(1) extra memory.", "examples": "Input: [\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput: [\"o\",\"l\",\"l\",\"e\",\"h\"]\n\nInput: [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\nOutput: [\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def reverse_string(s: list) -> list:\n  l = 0\n  r = len(s) - 1\n  while l < r:\n    tmp = s[l]\n    s[l] = s[r]\n    s[r] = tmp\n    l += 1\n    r -= 1\n  return s\n", "asserts": ["assert reverse_string([\"a\",\"b\",\"c\",\"d\"]) == [\"d\", \"c\", \"b\", \"a\"]", "assert reverse_string([\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"]) == [\"n\", \"o\", \"h\", \"t\", \"y\", \"p\"]", "assert reverse_string([]) == []", "assert reverse_string([\"s\", \"i\", \"n\", \"g\", \"l\", \"e\"]) == [\"e\", \"l\", \"g\", \"n\", \"i\", \"s\"]", "assert reverse_string([\"A\"]) == [\"A\"]", "assert reverse_string([\"9\", \"8\", \"7\", \"6\", \"5\", \"4\", \"3\", \"2\", \"1\"]) == [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]", "assert reverse_string([\"B\", \"o\", \"b\"]) == [\"b\", \"o\", \"B\"]", "assert reverse_string([\"r\", \"e\", \"v\", \"e\", \"r\", \"s\", \"e\"]) == [\"e\", \"s\", \"r\", \"e\", \"v\", \"e\", \"r\"]", "assert reverse_string([\"1\", \"*\", \"2\", \"*\", \"3\"]) == [\"3\", \"*\", \"2\", \"*\", \"1\"]"]}], "category": "String", "prompt_tokens": 910, "total_tokens": 1144, "completion_tokens": 234, "completion": "Create a function that checks if a string is a palindrome. A palindrome is a word, phrase, number, or other sequences of characters which reads the same backward as forward, ignoring spaces, punctuation, and capitalization.\n\n###Code:\n\ndef is_palindrome(s: str) -> bool:\n    stripped = ''.join(c.lower() for c in s if c.isalnum())\n    return stripped == stripped[::-1]\n\n###Testcases:\n\nassert is_palindrome(\"A man, a plan, a canal, Panama\") == True\nassert is_palindrome(\"Was it a car or a cat I saw?\") == True\nassert is_palindrome(\"No 'x' in Nixon\") == True\nassert is_palindrome(\" \") == True\nassert is_palindrome(\"racecar\") == True\nassert is_palindrome(\"not a palindrome\") == False\nassert is_palindrome(\"Never Odd or Even\") == True\nassert is_palindrome(\"123454321\") == True\nassert is_palindrome(\"12345 5432\") == False\nassert is_palindrome(\"Sator Arepo tenet opera rotas\") == True\n\n[/Example 3]", "temperature": 0.909, "question": "Create a function that checks if a string is a palindrome. A palindrome is a word, phrase, number, or other sequences of characters which reads the same backward as forward, ignoring spaces, punctuation, and capitalization.", "code": "def is_palindrome(s: str) -> bool:\n    stripped = ''.join(c.lower() for c in s if c.isalnum())\n    return stripped == stripped[::-1]", "asserts": ["assert is_palindrome(\"A man, a plan, a canal, Panama\") == True", "assert is_palindrome(\"Was it a car or a cat I saw?\") == True", "assert is_palindrome(\"No 'x' in Nixon\") == True", "assert is_palindrome(\" \") == True", "assert is_palindrome(\"racecar\") == True", "assert is_palindrome(\"not a palindrome\") == False", "assert is_palindrome(\"Never Odd or Even\") == True", "assert is_palindrome(\"123454321\") == True", "assert is_palindrome(\"12345 5432\") == False", "assert is_palindrome(\"Sator Arepo tenet opera rotas\") == True"], "author": "GPT", "UUID": "a6f11d75-9a87-4d8b-b906-2129209a9d8e", "tc_status": [["assert is_palindrome(\"A man, a plan, a canal, Panama\") == True", "Passed"], ["assert is_palindrome(\"Was it a car or a cat I saw?\") == True", "Passed"], ["assert is_palindrome(\"No 'x' in Nixon\") == True", "Passed"], ["assert is_palindrome(\" \") == True", "Passed"], ["assert is_palindrome(\"racecar\") == True", "Passed"], ["assert is_palindrome(\"not a palindrome\") == False", "Passed"], ["assert is_palindrome(\"Never Odd or Even\") == True", "Passed"], ["assert is_palindrome(\"123454321\") == True", "Passed"], ["assert is_palindrome(\"12345 5432\") == False", "Passed"], ["assert is_palindrome(\"Sator Arepo tenet opera rotas\") == True", "Passed"]]}, {"few_shots": [{"author": "Calvin", "UUID": "56b48f6d-0d81-478d-b838-4d47b62d3031", "question": "Given an integer n, return the number of strings of length n that consist only of vowels (a, e, i, o, u) and are lexicographically sorted.\n\nA string s is lexicographically sorted if for all valid i, s[i] is the same as or comes before s[i+1] in the alphabet.", "examples": "Input: 1\nOutput: 5\n\nInput: 2\nOutput: 15", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def helper(n, letter_idx):\n  letters = [\"a\",\"e\",\"i\",\"o\",\"u\"]\n  dynamic = {\n      'a1' : 5,\n      'e1' : 4,\n      'i1' : 3,\n      'o1' : 2,\n      'u1' : 1\n  }\n  ret = 0\n  key = letters[letter_idx] + str(n)\n  if key in dynamic.keys():\n    return dynamic[key]\n  else:\n    for i in range(letter_idx, len(letters)):\n      ret += helper(n-1, i)\n    dynamic[key] = ret\n  return ret\n  \n\ndef countVowelStrings(n: int) -> int:\n  return helper(n, 0)\n", "asserts": ["assert countVowelStrings(3) == 35", "assert countVowelStrings(4) == 70", "assert countVowelStrings(5) == 126", "assert countVowelStrings(6) == 210", "assert countVowelStrings(7) == 330", "assert countVowelStrings(10) == 1001", "assert countVowelStrings(15) == 3876"]}, {"author": "Calvin", "UUID": "d0ce7430-cfcd-4c69-b161-b3b2a186422c", "question": "Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.\n\nIn other words, return true if one of s1's permutations is the substring of s2.", "examples": "Input: s1 = \"ab\", s2 = \"eidbaooo\"\nOutput: True\n\nInput: s1 = \"ab\", s2 = \"eidboaoo\"\nOutput: False", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef permutation_in_string(s1: str, s2: str) -> bool:\n  window = len(s1)\n  if window > len(s2):\n    return False\n  freq1 = [0]*26\n  freq2 = [0]*26\n  for i in range(window):\n    freq1[ord(s1[i])-ord('a')] += 1\n    freq2[ord(s2[i])-ord('a')] += 1\n\n  matches = 0\n  for i in range(26):\n    if freq1[i] == freq2[i]:\n      matches += 1\n  \n  for l in range(len(s2) - window):\n    if matches == 26:\n      return True\n\n    added = ord(s2[l + window]) - ord('a')\n    freq2[added] += 1\n    if freq1[added] == freq2[added]:\n      matches += 1\n    elif freq1[added] + 1 == freq2[added]:\n      matches -= 1\n\n    removed = ord(s2[l]) - ord('a')\n    freq2[removed] -= 1\n    if freq1[removed] == freq2[removed]:\n      matches += 1\n    elif freq1[removed] == freq2[removed] + 1:\n      matches -= 1\n    \n  return matches == 26\n", "asserts": ["assert permutation_in_string(\"hello\", \"ooollehhhhh\") == True", "assert permutation_in_string(\"abc\", \"ccccbbbbaaaa\") == False", "assert permutation_in_string(\"xyz\", \"zxyopqrstuv\") == True", "assert permutation_in_string(\"xyz\", \"xzygxzyzxyzk\") == True", "assert permutation_in_string(\"a\", \"a\") == True", "assert permutation_in_string(\"adc\", \"dcda\") == True", "assert permutation_in_string(\"pq\", \"qpqqp\") == True", "assert permutation_in_string(\"kitten\", \"sittingkite\") == False", "assert permutation_in_string(\"pq\", \"pqpqr\") == True", "assert permutation_in_string(\"aba\", \"aabaabaa\") == True", "assert permutation_in_string(\"\", \"\") == True  # Edge case: both strings are empty", "assert permutation_in_string(\"longerstring\", \"short\") == False  # s1 is longer than s2", "assert permutation_in_string(\"a\", \"b\") == False  # Single character, no match", "assert permutation_in_string(\"aab\", \"baa\") == True  # s1 is a permutation of s2", "assert permutation_in_string(\"ab\", \"a\") == False  # s2 is shorter than s1", "assert permutation_in_string(\"ba\", \"eidbaooo\") == True  # Same characters as Example 1 but different permutation", "assert permutation_in_string(\"eid\", \"eidbaooo\") == True  # s1 is a prefix of s2", "assert permutation_in_string(\"ooo\", \"eidbaooo\") == True  # s1 is a suffix of s2", "assert permutation_in_string(\"db\", \"eidbaooo\") == True  # s1 is a permutation within s2", "assert permutation_in_string(\"eidoo\", \"eidbaooo\") == False  # s1 is longer than any permutation within s2"]}], "category": "String", "prompt_tokens": 1255, "total_tokens": 1714, "completion_tokens": 459, "completion": "Write a function to check whether two given strings are isomorphic.\n\nTwo strings are isomorphic if the characters in string s can be replaced to get string t. No two characters may map to the same character, but a character may map to itself.\n\n###Code: \n\ndef is_isomorphic(s: str, t: str) -> bool:\n  if len(s) != len(t):\n    return False\n  \n  mapping_s_t = {}\n  mapping_t_s = {}\n  \n  for i in range(len(s)):\n    char_s, char_t = s[i], t[i]\n    \n    if char_s not in mapping_s_t and char_t not in mapping_t_s:\n      mapping_s_t[char_s] = char_t\n      mapping_t_s[char_t] = char_s\n    elif mapping_s_t.get(char_s) != char_t or mapping_t_s.get(char_t) != char_s:\n      return False\n\n  return True\n\n###Testcases: \n\nassert is_isomorphic(\"egg\", \"add\") == True\nassert is_isomorphic(\"foo\", \"bar\") == False\nassert is_isomorphic(\"paper\", \"title\") == True\nassert is_isomorphic(\"ab\", \"aa\") == False\nassert is_isomorphic(\"aacc\", \"bbdd\") == True\nassert is_isomorphic(\"abc\", \"def\") == True\nassert is_isomorphic(\"aab\", \"xyz\") == False\nassert is_isomorphic(\"\", \"\") == True  # Edge case: both strings are empty\nassert is_isomorphic(\"13\", \"42\") == True  # Testing with numeric characters\nassert is_isomorphic(\"it\", \"at\") == True  # Only two characters, same structure\nassert is_isomorphic(\"aba\", \"baa\") == False  # 'a' maps to two different characters\nassert is_isomorphic(\"turtle\", \"tletur\") == False  # Same letters, different structure\nassert is_isomorphic(\"abab\", \"baba\") == True  # Repeating pattern\nassert is_isomorphic(\"abba\", \"abab\") == False  # Different repeating pattern\nassert is_isomorphic(\"abcabc\", \"xyzxyz\") == True  # Repeated pattern with more characters\n\n[/Example 3]", "temperature": 0.748, "question": "Write a function to check whether two given strings are isomorphic.\n\nTwo strings are isomorphic if the characters in string s can be replaced to get string t. No two characters may map to the same character, but a character may map to itself.", "code": "def is_isomorphic(s: str, t: str) -> bool:\n  if len(s) != len(t):\n    return False\n  \n  mapping_s_t = {}\n  mapping_t_s = {}\n  \n  for i in range(len(s)):\n    char_s, char_t = s[i], t[i]\n    \n    if char_s not in mapping_s_t and char_t not in mapping_t_s:\n      mapping_s_t[char_s] = char_t\n      mapping_t_s[char_t] = char_s\n    elif mapping_s_t.get(char_s) != char_t or mapping_t_s.get(char_t) != char_s:\n      return False\n\n  return True", "asserts": ["assert is_isomorphic(\"egg\", \"add\") == True", "assert is_isomorphic(\"foo\", \"bar\") == False", "assert is_isomorphic(\"paper\", \"title\") == True", "assert is_isomorphic(\"ab\", \"aa\") == False", "assert is_isomorphic(\"aacc\", \"bbdd\") == True", "assert is_isomorphic(\"abc\", \"def\") == True", "assert is_isomorphic(\"aab\", \"xyz\") == False", "assert is_isomorphic(\"\", \"\") == True  # Edge case: both strings are empty", "assert is_isomorphic(\"13\", \"42\") == True  # Testing with numeric characters", "assert is_isomorphic(\"it\", \"at\") == True  # Only two characters, same structure", "assert is_isomorphic(\"aba\", \"baa\") == False  # 'a' maps to two different characters", "assert is_isomorphic(\"abab\", \"baba\") == True  # Repeating pattern", "assert is_isomorphic(\"abba\", \"abab\") == False  # Different repeating pattern", "assert is_isomorphic(\"abcabc\", \"xyzxyz\") == True  # Repeated pattern with more characters"], "author": "GPT", "UUID": "090db653-b446-45a2-a9d6-fc1fc74d1169", "tc_status": [["assert is_isomorphic(\"egg\", \"add\") == True", "Passed"], ["assert is_isomorphic(\"foo\", \"bar\") == False", "Passed"], ["assert is_isomorphic(\"paper\", \"title\") == True", "Passed"], ["assert is_isomorphic(\"ab\", \"aa\") == False", "Passed"], ["assert is_isomorphic(\"aacc\", \"bbdd\") == True", "Passed"], ["assert is_isomorphic(\"abc\", \"def\") == True", "Passed"], ["assert is_isomorphic(\"aab\", \"xyz\") == False", "Passed"], ["assert is_isomorphic(\"\", \"\") == True  # Edge case: both strings are empty", "Passed"], ["assert is_isomorphic(\"13\", \"42\") == True  # Testing with numeric characters", "Passed"], ["assert is_isomorphic(\"it\", \"at\") == True  # Only two characters, same structure", "Passed"], ["assert is_isomorphic(\"aba\", \"baa\") == False  # 'a' maps to two different characters", "Passed"], ["assert is_isomorphic(\"abab\", \"baba\") == True  # Repeating pattern", "Passed"], ["assert is_isomorphic(\"abba\", \"abab\") == False  # Different repeating pattern", "Passed"], ["assert is_isomorphic(\"abcabc\", \"xyzxyz\") == True  # Repeated pattern with more characters", "Passed"]]}, {"few_shots": [{"author": "Calvin", "UUID": "56b48f6d-0d81-478d-b838-4d47b62d3031", "question": "Given an integer n, return the number of strings of length n that consist only of vowels (a, e, i, o, u) and are lexicographically sorted.\n\nA string s is lexicographically sorted if for all valid i, s[i] is the same as or comes before s[i+1] in the alphabet.", "examples": "Input: 1\nOutput: 5\n\nInput: 2\nOutput: 15", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def helper(n, letter_idx):\n  letters = [\"a\",\"e\",\"i\",\"o\",\"u\"]\n  dynamic = {\n      'a1' : 5,\n      'e1' : 4,\n      'i1' : 3,\n      'o1' : 2,\n      'u1' : 1\n  }\n  ret = 0\n  key = letters[letter_idx] + str(n)\n  if key in dynamic.keys():\n    return dynamic[key]\n  else:\n    for i in range(letter_idx, len(letters)):\n      ret += helper(n-1, i)\n    dynamic[key] = ret\n  return ret\n  \n\ndef countVowelStrings(n: int) -> int:\n  return helper(n, 0)\n", "asserts": ["assert countVowelStrings(3) == 35", "assert countVowelStrings(4) == 70", "assert countVowelStrings(5) == 126", "assert countVowelStrings(6) == 210", "assert countVowelStrings(7) == 330", "assert countVowelStrings(10) == 1001", "assert countVowelStrings(15) == 3876"]}, {"author": "Calvin", "UUID": "d0ce7430-cfcd-4c69-b161-b3b2a186422c", "question": "Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.\n\nIn other words, return true if one of s1's permutations is the substring of s2.", "examples": "Input: s1 = \"ab\", s2 = \"eidbaooo\"\nOutput: True\n\nInput: s1 = \"ab\", s2 = \"eidboaoo\"\nOutput: False", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef permutation_in_string(s1: str, s2: str) -> bool:\n  window = len(s1)\n  if window > len(s2):\n    return False\n  freq1 = [0]*26\n  freq2 = [0]*26\n  for i in range(window):\n    freq1[ord(s1[i])-ord('a')] += 1\n    freq2[ord(s2[i])-ord('a')] += 1\n\n  matches = 0\n  for i in range(26):\n    if freq1[i] == freq2[i]:\n      matches += 1\n  \n  for l in range(len(s2) - window):\n    if matches == 26:\n      return True\n\n    added = ord(s2[l + window]) - ord('a')\n    freq2[added] += 1\n    if freq1[added] == freq2[added]:\n      matches += 1\n    elif freq1[added] + 1 == freq2[added]:\n      matches -= 1\n\n    removed = ord(s2[l]) - ord('a')\n    freq2[removed] -= 1\n    if freq1[removed] == freq2[removed]:\n      matches += 1\n    elif freq1[removed] == freq2[removed] + 1:\n      matches -= 1\n    \n  return matches == 26\n", "asserts": ["assert permutation_in_string(\"hello\", \"ooollehhhhh\") == True", "assert permutation_in_string(\"abc\", \"ccccbbbbaaaa\") == False", "assert permutation_in_string(\"xyz\", \"zxyopqrstuv\") == True", "assert permutation_in_string(\"xyz\", \"xzygxzyzxyzk\") == True", "assert permutation_in_string(\"a\", \"a\") == True", "assert permutation_in_string(\"adc\", \"dcda\") == True", "assert permutation_in_string(\"pq\", \"qpqqp\") == True", "assert permutation_in_string(\"kitten\", \"sittingkite\") == False", "assert permutation_in_string(\"pq\", \"pqpqr\") == True", "assert permutation_in_string(\"aba\", \"aabaabaa\") == True", "assert permutation_in_string(\"\", \"\") == True  # Edge case: both strings are empty", "assert permutation_in_string(\"longerstring\", \"short\") == False  # s1 is longer than s2", "assert permutation_in_string(\"a\", \"b\") == False  # Single character, no match", "assert permutation_in_string(\"aab\", \"baa\") == True  # s1 is a permutation of s2", "assert permutation_in_string(\"ab\", \"a\") == False  # s2 is shorter than s1", "assert permutation_in_string(\"ba\", \"eidbaooo\") == True  # Same characters as Example 1 but different permutation", "assert permutation_in_string(\"eid\", \"eidbaooo\") == True  # s1 is a prefix of s2", "assert permutation_in_string(\"ooo\", \"eidbaooo\") == True  # s1 is a suffix of s2", "assert permutation_in_string(\"db\", \"eidbaooo\") == True  # s1 is a permutation within s2", "assert permutation_in_string(\"eidoo\", \"eidbaooo\") == False  # s1 is longer than any permutation within s2"]}], "category": "String", "prompt_tokens": 1255, "total_tokens": 1671, "completion_tokens": 416, "completion": "Given a string containing just the characters '(' and ')', find the length of the longest valid (well-formed) parentheses substring.\n\n###Code:\n\n```python\ndef longest_valid_parentheses(s: str) -> int:\n    max_len = 0\n    stack = [-1]\n    for i, char in enumerate(s):\n        if char == '(':\n            stack.append(i)\n        else:\n            stack.pop()\n            if stack:\n                max_len = max(max_len, i - stack[-1])\n            else:\n                stack.append(i)\n    return max_len\n```\n\n###Testcases:\n\n```python\nassert longest_valid_parentheses(\"(()\") == 2\nassert longest_valid_parentheses(\")()())\") == 4\nassert longest_valid_parentheses(\"\") == 0\nassert longest_valid_parentheses(\"(((((((()\") == 2\nassert longest_valid_parentheses(\"()(()\") == 2\nassert longest_valid_parentheses(\"()((()))\") == 8\nassert longest_valid_parentheses(\"(()(((()\") == 2\nassert longest_valid_parentheses(\"((()()(()))(\") == 10\nassert longest_valid_parentheses(\"((())())\") == 8\nassert longest_valid_parentheses(\"()\") == 2\nassert longest_valid_parentheses(\"(()())\") == 6\nassert longest_valid_parentheses(\"())\") == 2\nassert longest_valid_parentheses(\"()(())\") == 6\nassert longest_valid_parentheses(\"()(()())\") == 8\nassert longest_valid_parentheses(\"(((((())\") == 4\nassert longest_valid_parentheses(\")(\") == 0\nassert longest_valid_parentheses(\"(()()\") == 4\nassert longest_valid_parentheses(\"((()))\") == 6\nassert longest_valid_parentheses(\")(())(\") == 4\nassert longest_valid_parentheses(\"()()\") == 4\n```\n\n[/Example 3]", "temperature": 0.811, "question": "Given a string containing just the characters '(' and ')', find the length of the longest valid (well-formed) parentheses substring.", "code": "def longest_valid_parentheses(s: str) -> int:\n    max_len = 0\n    stack = [-1]\n    for i, char in enumerate(s):\n        if char == '(':\n            stack.append(i)\n        else:\n            stack.pop()\n            if stack:\n                max_len = max(max_len, i - stack[-1])\n            else:\n                stack.append(i)\n    return max_len", "asserts": ["assert longest_valid_parentheses(\"(()\") == 2", "assert longest_valid_parentheses(\")()())\") == 4", "assert longest_valid_parentheses(\"\") == 0", "assert longest_valid_parentheses(\"(((((((()\") == 2", "assert longest_valid_parentheses(\"()(()\") == 2", "assert longest_valid_parentheses(\"()((()))\") == 8", "assert longest_valid_parentheses(\"(()(((()\") == 2", "assert longest_valid_parentheses(\"((()()(()))(\") == 10", "assert longest_valid_parentheses(\"((())())\") == 8", "assert longest_valid_parentheses(\"()\") == 2", "assert longest_valid_parentheses(\"(()())\") == 6", "assert longest_valid_parentheses(\"())\") == 2", "assert longest_valid_parentheses(\"()(())\") == 6", "assert longest_valid_parentheses(\"()(()())\") == 8", "assert longest_valid_parentheses(\"(((((())\") == 4", "assert longest_valid_parentheses(\")(\") == 0", "assert longest_valid_parentheses(\"(()()\") == 4", "assert longest_valid_parentheses(\"((()))\") == 6", "assert longest_valid_parentheses(\")(())(\") == 4", "assert longest_valid_parentheses(\"()()\") == 4"], "author": "GPT", "UUID": "8ded69c9-9bf8-4481-b774-3ecf4c314131", "tc_status": [["assert longest_valid_parentheses(\"(()\") == 2", "Passed"], ["assert longest_valid_parentheses(\")()())\") == 4", "Passed"], ["assert longest_valid_parentheses(\"\") == 0", "Passed"], ["assert longest_valid_parentheses(\"(((((((()\") == 2", "Passed"], ["assert longest_valid_parentheses(\"()(()\") == 2", "Passed"], ["assert longest_valid_parentheses(\"()((()))\") == 8", "Passed"], ["assert longest_valid_parentheses(\"(()(((()\") == 2", "Passed"], ["assert longest_valid_parentheses(\"((()()(()))(\") == 10", "Passed"], ["assert longest_valid_parentheses(\"((())())\") == 8", "Passed"], ["assert longest_valid_parentheses(\"()\") == 2", "Passed"], ["assert longest_valid_parentheses(\"(()())\") == 6", "Passed"], ["assert longest_valid_parentheses(\"())\") == 2", "Passed"], ["assert longest_valid_parentheses(\"()(())\") == 6", "Passed"], ["assert longest_valid_parentheses(\"()(()())\") == 8", "Passed"], ["assert longest_valid_parentheses(\"(((((())\") == 4", "Passed"], ["assert longest_valid_parentheses(\")(\") == 0", "Passed"], ["assert longest_valid_parentheses(\"(()()\") == 4", "Passed"], ["assert longest_valid_parentheses(\"((()))\") == 6", "Passed"], ["assert longest_valid_parentheses(\")(())(\") == 4", "Passed"], ["assert longest_valid_parentheses(\"()()\") == 4", "Passed"]]}, {"few_shots": [{"author": "Calvin", "UUID": "56b48f6d-0d81-478d-b838-4d47b62d3031", "question": "Given an integer n, return the number of strings of length n that consist only of vowels (a, e, i, o, u) and are lexicographically sorted.\n\nA string s is lexicographically sorted if for all valid i, s[i] is the same as or comes before s[i+1] in the alphabet.", "examples": "Input: 1\nOutput: 5\n\nInput: 2\nOutput: 15", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def helper(n, letter_idx):\n  letters = [\"a\",\"e\",\"i\",\"o\",\"u\"]\n  dynamic = {\n      'a1' : 5,\n      'e1' : 4,\n      'i1' : 3,\n      'o1' : 2,\n      'u1' : 1\n  }\n  ret = 0\n  key = letters[letter_idx] + str(n)\n  if key in dynamic.keys():\n    return dynamic[key]\n  else:\n    for i in range(letter_idx, len(letters)):\n      ret += helper(n-1, i)\n    dynamic[key] = ret\n  return ret\n  \n\ndef countVowelStrings(n: int) -> int:\n  return helper(n, 0)\n", "asserts": ["assert countVowelStrings(3) == 35", "assert countVowelStrings(4) == 70", "assert countVowelStrings(5) == 126", "assert countVowelStrings(6) == 210", "assert countVowelStrings(7) == 330", "assert countVowelStrings(10) == 1001", "assert countVowelStrings(15) == 3876"]}, {"author": "Calvin", "UUID": "d0ce7430-cfcd-4c69-b161-b3b2a186422c", "question": "Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.\n\nIn other words, return true if one of s1's permutations is the substring of s2.", "examples": "Input: s1 = \"ab\", s2 = \"eidbaooo\"\nOutput: True\n\nInput: s1 = \"ab\", s2 = \"eidboaoo\"\nOutput: False", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef permutation_in_string(s1: str, s2: str) -> bool:\n  window = len(s1)\n  if window > len(s2):\n    return False\n  freq1 = [0]*26\n  freq2 = [0]*26\n  for i in range(window):\n    freq1[ord(s1[i])-ord('a')] += 1\n    freq2[ord(s2[i])-ord('a')] += 1\n\n  matches = 0\n  for i in range(26):\n    if freq1[i] == freq2[i]:\n      matches += 1\n  \n  for l in range(len(s2) - window):\n    if matches == 26:\n      return True\n\n    added = ord(s2[l + window]) - ord('a')\n    freq2[added] += 1\n    if freq1[added] == freq2[added]:\n      matches += 1\n    elif freq1[added] + 1 == freq2[added]:\n      matches -= 1\n\n    removed = ord(s2[l]) - ord('a')\n    freq2[removed] -= 1\n    if freq1[removed] == freq2[removed]:\n      matches += 1\n    elif freq1[removed] == freq2[removed] + 1:\n      matches -= 1\n    \n  return matches == 26\n", "asserts": ["assert permutation_in_string(\"hello\", \"ooollehhhhh\") == True", "assert permutation_in_string(\"abc\", \"ccccbbbbaaaa\") == False", "assert permutation_in_string(\"xyz\", \"zxyopqrstuv\") == True", "assert permutation_in_string(\"xyz\", \"xzygxzyzxyzk\") == True", "assert permutation_in_string(\"a\", \"a\") == True", "assert permutation_in_string(\"adc\", \"dcda\") == True", "assert permutation_in_string(\"pq\", \"qpqqp\") == True", "assert permutation_in_string(\"kitten\", \"sittingkite\") == False", "assert permutation_in_string(\"pq\", \"pqpqr\") == True", "assert permutation_in_string(\"aba\", \"aabaabaa\") == True", "assert permutation_in_string(\"\", \"\") == True  # Edge case: both strings are empty", "assert permutation_in_string(\"longerstring\", \"short\") == False  # s1 is longer than s2", "assert permutation_in_string(\"a\", \"b\") == False  # Single character, no match", "assert permutation_in_string(\"aab\", \"baa\") == True  # s1 is a permutation of s2", "assert permutation_in_string(\"ab\", \"a\") == False  # s2 is shorter than s1", "assert permutation_in_string(\"ba\", \"eidbaooo\") == True  # Same characters as Example 1 but different permutation", "assert permutation_in_string(\"eid\", \"eidbaooo\") == True  # s1 is a prefix of s2", "assert permutation_in_string(\"ooo\", \"eidbaooo\") == True  # s1 is a suffix of s2", "assert permutation_in_string(\"db\", \"eidbaooo\") == True  # s1 is a permutation within s2", "assert permutation_in_string(\"eidoo\", \"eidbaooo\") == False  # s1 is longer than any permutation within s2"]}], "category": "String", "prompt_tokens": 1255, "total_tokens": 1777, "completion_tokens": 522, "completion": "Given a string s, return the longest palindromic substring in s.\n\nA string is called a palindrome if it reads the same backward as forward.\n\n###Code:\n\ndef longest_palindrome(s: str) -> str:\n    if len(s) == 0:\n        return \"\"\n    \n    start = end = 0\n    \n    def expand_around_center(left: int, right: int) -> int:\n        while left >= 0 and right < len(s) and s[left] == s[right]:\n            left -= 1\n            right += 1\n        return right - left - 1\n    \n    for i in range(len(s)):\n        len1 = expand_around_center(i, i)\n        len2 = expand_around_center(i, i + 1)\n        max_len = max(len1, len2)\n        \n        if max_len > (end - start):\n            start = i - (max_len - 1) // 2\n            end = i + max_len // 2\n        \n    return s[start:end + 1]\n\n###Testcases:\n\nassert longest_palindrome(\"babad\") == \"bab\" or longest_palindrome(\"babad\") == \"aba\"\nassert longest_palindrome(\"cbbd\") == \"bb\"\nassert longest_palindrome(\"a\") == \"a\"\nassert longest_palindrome(\"ac\") == \"a\" or longest_palindrome(\"ac\") == \"c\"\nassert longest_palindrome(\"racecar\") == \"racecar\"\nassert longest_palindrome(\"forgeeksskeegfor\") == \"geeksskeeg\"\nassert longest_palindrome(\"abacdfgdcaba\") == \"aba\"\nassert longest_palindrome(\"abacdfgdcabba\") == \"abba\"\nassert longest_palindrome(\"abacdedcaba\") == \"abacdedcaba\"\nassert longest_palindrome(\"\") == \"\"  # Edge case: empty string\nassert longest_palindrome(\"a\") == \"a\"  # Single character\nassert longest_palindrome(\"aa\") == \"aa\"  # Two of the same character\nassert longest_palindrome(\"ab\") == \"a\" or longest_palindrome(\"ab\") == \"b\"  # No palindrome longer than 1 character\nassert longest_palindrome(\"aaaa\") == \"aaaa\"  # Entire string is a palindrome\nassert longest_palindrome(\"banana\") == \"anana\"  # Palindrome in the middle\nassert longest_palindrome(\"million\") == \"illi\"  # Palindrome in the middle\n\n[/Example 3]", "temperature": 0.676, "question": "Given a string s, return the longest palindromic substring in s.\n\nA string is called a palindrome if it reads the same backward as forward.", "code": "def longest_palindrome(s: str) -> str:\n    if len(s) == 0:\n        return \"\"\n    \n    start = end = 0\n    \n    def expand_around_center(left: int, right: int) -> int:\n        while left >= 0 and right < len(s) and s[left] == s[right]:\n            left -= 1\n            right += 1\n        return right - left - 1\n    \n    for i in range(len(s)):\n        len1 = expand_around_center(i, i)\n        len2 = expand_around_center(i, i + 1)\n        max_len = max(len1, len2)\n        \n        if max_len > (end - start):\n            start = i - (max_len - 1) // 2\n            end = i + max_len // 2\n        \n    return s[start:end + 1]", "asserts": ["assert longest_palindrome(\"babad\") == \"bab\" or longest_palindrome(\"babad\") == \"aba\"", "assert longest_palindrome(\"cbbd\") == \"bb\"", "assert longest_palindrome(\"a\") == \"a\"", "assert longest_palindrome(\"ac\") == \"a\" or longest_palindrome(\"ac\") == \"c\"", "assert longest_palindrome(\"racecar\") == \"racecar\"", "assert longest_palindrome(\"forgeeksskeegfor\") == \"geeksskeeg\"", "assert longest_palindrome(\"abacdfgdcaba\") == \"aba\"", "assert longest_palindrome(\"abacdfgdcabba\") == \"abba\"", "assert longest_palindrome(\"abacdedcaba\") == \"abacdedcaba\"", "assert longest_palindrome(\"\") == \"\"  # Edge case: empty string", "assert longest_palindrome(\"a\") == \"a\"  # Single character", "assert longest_palindrome(\"aa\") == \"aa\"  # Two of the same character", "assert longest_palindrome(\"ab\") == \"a\" or longest_palindrome(\"ab\") == \"b\"  # No palindrome longer than 1 character", "assert longest_palindrome(\"aaaa\") == \"aaaa\"  # Entire string is a palindrome", "assert longest_palindrome(\"banana\") == \"anana\"  # Palindrome in the middle", "assert longest_palindrome(\"million\") == \"illi\"  # Palindrome in the middle"], "author": "GPT", "UUID": "9b111f19-2f63-46cb-8e9d-15eb1ed6b8a2", "tc_status": [["assert longest_palindrome(\"babad\") == \"bab\" or longest_palindrome(\"babad\") == \"aba\"", "Passed"], ["assert longest_palindrome(\"cbbd\") == \"bb\"", "Passed"], ["assert longest_palindrome(\"a\") == \"a\"", "Passed"], ["assert longest_palindrome(\"ac\") == \"a\" or longest_palindrome(\"ac\") == \"c\"", "Passed"], ["assert longest_palindrome(\"racecar\") == \"racecar\"", "Passed"], ["assert longest_palindrome(\"forgeeksskeegfor\") == \"geeksskeeg\"", "Passed"], ["assert longest_palindrome(\"abacdfgdcaba\") == \"aba\"", "Passed"], ["assert longest_palindrome(\"abacdfgdcabba\") == \"abba\"", "Passed"], ["assert longest_palindrome(\"abacdedcaba\") == \"abacdedcaba\"", "Passed"], ["assert longest_palindrome(\"\") == \"\"  # Edge case: empty string", "Passed"], ["assert longest_palindrome(\"a\") == \"a\"  # Single character", "Passed"], ["assert longest_palindrome(\"aa\") == \"aa\"  # Two of the same character", "Passed"], ["assert longest_palindrome(\"ab\") == \"a\" or longest_palindrome(\"ab\") == \"b\"  # No palindrome longer than 1 character", "Passed"], ["assert longest_palindrome(\"aaaa\") == \"aaaa\"  # Entire string is a palindrome", "Passed"], ["assert longest_palindrome(\"banana\") == \"anana\"  # Palindrome in the middle", "Passed"], ["assert longest_palindrome(\"million\") == \"illi\"  # Palindrome in the middle", "Passed"]]}, {"few_shots": [{"author": "Calvin", "UUID": "56b48f6d-0d81-478d-b838-4d47b62d3031", "question": "Given an integer n, return the number of strings of length n that consist only of vowels (a, e, i, o, u) and are lexicographically sorted.\n\nA string s is lexicographically sorted if for all valid i, s[i] is the same as or comes before s[i+1] in the alphabet.", "examples": "Input: 1\nOutput: 5\n\nInput: 2\nOutput: 15", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def helper(n, letter_idx):\n  letters = [\"a\",\"e\",\"i\",\"o\",\"u\"]\n  dynamic = {\n      'a1' : 5,\n      'e1' : 4,\n      'i1' : 3,\n      'o1' : 2,\n      'u1' : 1\n  }\n  ret = 0\n  key = letters[letter_idx] + str(n)\n  if key in dynamic.keys():\n    return dynamic[key]\n  else:\n    for i in range(letter_idx, len(letters)):\n      ret += helper(n-1, i)\n    dynamic[key] = ret\n  return ret\n  \n\ndef countVowelStrings(n: int) -> int:\n  return helper(n, 0)\n", "asserts": ["assert countVowelStrings(3) == 35", "assert countVowelStrings(4) == 70", "assert countVowelStrings(5) == 126", "assert countVowelStrings(6) == 210", "assert countVowelStrings(7) == 330", "assert countVowelStrings(10) == 1001", "assert countVowelStrings(15) == 3876"]}, {"author": "Calvin", "UUID": "87372a22-f5ef-4100-845b-28700ca3fde3", "question": "You are given a string s and an integer array indices of the same length. The string s will be shuffled such that the character at the ith position moves to indices[i] in the shuffled string.\n\nReturn the shuffled string.", "examples": "Input: s = \"codeleet\", indices = [4,5,6,7,0,2,1,3]\nOutput: \"leetcode\"\n\nInput: s = \"abc\", indices = [0,1,2]\nOutput: \"abc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "from typing import List\ndef shuffle_string(s: str, indices: List[int]) -> str:\n    def partitionString(s):\n      substrings = 1\n      cur_str = set()\n      for i in range(len(s)):\n        if s[i] in cur_str:\n          substrings += 1\n          cur_str = {s[i]}\n        else:\n          cur_str.add(s[i])\n      return substrings\n    ret = ['_']*len(s)\n    for idx, i in enumerate(indices):\n        ret[i] = s[idx]\n    return \"\".join(ret)\n", "asserts": ["assert shuffle_string(\"reoc\", [2, 0, 1, 3]) == \"eorc\"", "assert shuffle_string(\"aiohn\", [3,1,4,2,0]) == \"nihao\"", "assert shuffle_string(\"aax\", [0,2,1]) == \"axa\"", "assert shuffle_string(\"gh\", [1,0]) == \"hg\"", "assert shuffle_string(\"\", []) == \"\"  # Edge case: empty string", "assert shuffle_string(\"xy\", [0,1]) == \"xy\"  # No shuffle required", "assert shuffle_string(\"pqrstuvwxyzabcdefghijklmno\", list(range(25, -1, -1))) == \"onmlkjihgfedcbazyxwvutsrqp\"  # Reverse shuffle"]}], "category": "String", "prompt_tokens": 851, "total_tokens": 1105, "completion_tokens": 254, "completion": "Write a function to find the first non-repeating character in a given string and return its index. If it doesn't exist, return -1.\n\n###Code: \n\ndef first_uniq_char(s: str) -> int:\n    char_count = {}\n    for char in s:\n        char_count[char] = char_count.get(char, 0) + 1\n    \n    for index, char in enumerate(s):\n        if char_count[char] == 1:\n            return index\n    \n    return -1\n\n###Testcases: \n\nassert first_uniq_char(\"leetcode\") == 0\nassert first_uniq_char(\"loveleetcode\") == 2\nassert first_uniq_char(\"aabb\") == -1\nassert first_uniq_char(\"aadadaad\") == -1\nassert first_uniq_char(\"\") == -1  # Edge case: empty string\nassert first_uniq_char(\"xyz\") == 0  # All characters are unique\nassert first_uniq_char(\"xyyz\") == 0  # First unique character at index 0\nassert first_uniq_char(\"abacabad\") == 6  # c and d are non-repeating characters, d occurs first at index 6\n\n[/Example 3]", "temperature": 0.884, "question": "Write a function to find the first non-repeating character in a given string and return its index. If it doesn't exist, return -1.", "code": "def first_uniq_char(s: str) -> int:\n    char_count = {}\n    for char in s:\n        char_count[char] = char_count.get(char, 0) + 1\n    \n    for index, char in enumerate(s):\n        if char_count[char] == 1:\n            return index\n    \n    return -1", "asserts": ["assert first_uniq_char(\"leetcode\") == 0", "assert first_uniq_char(\"loveleetcode\") == 2", "assert first_uniq_char(\"aabb\") == -1", "assert first_uniq_char(\"aadadaad\") == -1", "assert first_uniq_char(\"\") == -1  # Edge case: empty string", "assert first_uniq_char(\"xyz\") == 0  # All characters are unique", "assert first_uniq_char(\"xyyz\") == 0  # First unique character at index 0"], "author": "GPT", "UUID": "2bfaa8f3-aa78-491f-bad8-9c176d9be296", "tc_status": [["assert first_uniq_char(\"leetcode\") == 0", "Passed"], ["assert first_uniq_char(\"loveleetcode\") == 2", "Passed"], ["assert first_uniq_char(\"aabb\") == -1", "Passed"], ["assert first_uniq_char(\"aadadaad\") == -1", "Passed"], ["assert first_uniq_char(\"\") == -1  # Edge case: empty string", "Passed"], ["assert first_uniq_char(\"xyz\") == 0  # All characters are unique", "Passed"], ["assert first_uniq_char(\"xyyz\") == 0  # First unique character at index 0", "Passed"]]}, {"few_shots": [{"author": "Calvin", "UUID": "56b48f6d-0d81-478d-b838-4d47b62d3031", "question": "Given an integer n, return the number of strings of length n that consist only of vowels (a, e, i, o, u) and are lexicographically sorted.\n\nA string s is lexicographically sorted if for all valid i, s[i] is the same as or comes before s[i+1] in the alphabet.", "examples": "Input: 1\nOutput: 5\n\nInput: 2\nOutput: 15", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def helper(n, letter_idx):\n  letters = [\"a\",\"e\",\"i\",\"o\",\"u\"]\n  dynamic = {\n      'a1' : 5,\n      'e1' : 4,\n      'i1' : 3,\n      'o1' : 2,\n      'u1' : 1\n  }\n  ret = 0\n  key = letters[letter_idx] + str(n)\n  if key in dynamic.keys():\n    return dynamic[key]\n  else:\n    for i in range(letter_idx, len(letters)):\n      ret += helper(n-1, i)\n    dynamic[key] = ret\n  return ret\n  \n\ndef countVowelStrings(n: int) -> int:\n  return helper(n, 0)\n", "asserts": ["assert countVowelStrings(3) == 35", "assert countVowelStrings(4) == 70", "assert countVowelStrings(5) == 126", "assert countVowelStrings(6) == 210", "assert countVowelStrings(7) == 330", "assert countVowelStrings(10) == 1001", "assert countVowelStrings(15) == 3876"]}, {"author": "Calvin", "UUID": "87372a22-f5ef-4100-845b-28700ca3fde3", "question": "You are given a string s and an integer array indices of the same length. The string s will be shuffled such that the character at the ith position moves to indices[i] in the shuffled string.\n\nReturn the shuffled string.", "examples": "Input: s = \"codeleet\", indices = [4,5,6,7,0,2,1,3]\nOutput: \"leetcode\"\n\nInput: s = \"abc\", indices = [0,1,2]\nOutput: \"abc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "from typing import List\ndef shuffle_string(s: str, indices: List[int]) -> str:\n    def partitionString(s):\n      substrings = 1\n      cur_str = set()\n      for i in range(len(s)):\n        if s[i] in cur_str:\n          substrings += 1\n          cur_str = {s[i]}\n        else:\n          cur_str.add(s[i])\n      return substrings\n    ret = ['_']*len(s)\n    for idx, i in enumerate(indices):\n        ret[i] = s[idx]\n    return \"\".join(ret)\n", "asserts": ["assert shuffle_string(\"reoc\", [2, 0, 1, 3]) == \"eorc\"", "assert shuffle_string(\"aiohn\", [3,1,4,2,0]) == \"nihao\"", "assert shuffle_string(\"aax\", [0,2,1]) == \"axa\"", "assert shuffle_string(\"gh\", [1,0]) == \"hg\"", "assert shuffle_string(\"\", []) == \"\"  # Edge case: empty string", "assert shuffle_string(\"xy\", [0,1]) == \"xy\"  # No shuffle required", "assert shuffle_string(\"pqrstuvwxyzabcdefghijklmno\", list(range(25, -1, -1))) == \"onmlkjihgfedcbazyxwvutsrqp\"  # Reverse shuffle"]}], "category": "String", "prompt_tokens": 851, "total_tokens": 1039, "completion_tokens": 188, "completion": "Design a function that takes a non-empty string and that string's length and reverses the string.\n\n###Code: \n\ndef reverse_string(s: str, length: int) -> str:\n    # We can ignore the length as Python's slicing will handle it\n    return s[::-1]\n\n###Testcases: \n\nassert reverse_string(\"hello\", 5) == \"olleh\"\nassert reverse_string(\"world\", 5) == \"dlrow\"\nassert reverse_string(\"a\", 1) == \"a\"  # Edge case: single character\nassert reverse_string(\"racecar\", 7) == \"racecar\"  # Palindrome\nassert reverse_string(\"1234567890\", 10) == \"0987654321\"  # Numbers\nassert reverse_string(\"!@#$%^&*()\", 10) == \")(*&^%$#@!\"  # Special characters\n\n[/Example 3]", "temperature": 0.777, "question": "Design a function that takes a non-empty string and that string's length and reverses the string.", "code": "def reverse_string(s: str, length: int) -> str:\n    # We can ignore the length as Python's slicing will handle it\n    return s[::-1]", "asserts": ["assert reverse_string(\"hello\", 5) == \"olleh\"", "assert reverse_string(\"world\", 5) == \"dlrow\"", "assert reverse_string(\"a\", 1) == \"a\"  # Edge case: single character", "assert reverse_string(\"racecar\", 7) == \"racecar\"  # Palindrome", "assert reverse_string(\"1234567890\", 10) == \"0987654321\"  # Numbers", "assert reverse_string(\"!@#$%^&*()\", 10) == \")(*&^%$#@!\"  # Special characters"], "author": "GPT", "UUID": "e5899aca-50bc-4157-9d27-8bd0a054eed7", "tc_status": [["assert reverse_string(\"hello\", 5) == \"olleh\"", "Passed"], ["assert reverse_string(\"world\", 5) == \"dlrow\"", "Passed"], ["assert reverse_string(\"a\", 1) == \"a\"  # Edge case: single character", "Passed"], ["assert reverse_string(\"racecar\", 7) == \"racecar\"  # Palindrome", "Passed"], ["assert reverse_string(\"1234567890\", 10) == \"0987654321\"  # Numbers", "Passed"], ["assert reverse_string(\"!@#$%^&*()\", 10) == \")(*&^%$#@!\"  # Special characters", "Passed"]]}, {"few_shots": [{"author": "Calvin", "UUID": "56b48f6d-0d81-478d-b838-4d47b62d3031", "question": "Given an integer n, return the number of strings of length n that consist only of vowels (a, e, i, o, u) and are lexicographically sorted.\n\nA string s is lexicographically sorted if for all valid i, s[i] is the same as or comes before s[i+1] in the alphabet.", "examples": "Input: 1\nOutput: 5\n\nInput: 2\nOutput: 15", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def helper(n, letter_idx):\n  letters = [\"a\",\"e\",\"i\",\"o\",\"u\"]\n  dynamic = {\n      'a1' : 5,\n      'e1' : 4,\n      'i1' : 3,\n      'o1' : 2,\n      'u1' : 1\n  }\n  ret = 0\n  key = letters[letter_idx] + str(n)\n  if key in dynamic.keys():\n    return dynamic[key]\n  else:\n    for i in range(letter_idx, len(letters)):\n      ret += helper(n-1, i)\n    dynamic[key] = ret\n  return ret\n  \n\ndef countVowelStrings(n: int) -> int:\n  return helper(n, 0)\n", "asserts": ["assert countVowelStrings(3) == 35", "assert countVowelStrings(4) == 70", "assert countVowelStrings(5) == 126", "assert countVowelStrings(6) == 210", "assert countVowelStrings(7) == 330", "assert countVowelStrings(10) == 1001", "assert countVowelStrings(15) == 3876"]}, {"author": "Calvin", "UUID": "87372a22-f5ef-4100-845b-28700ca3fde3", "question": "You are given a string s and an integer array indices of the same length. The string s will be shuffled such that the character at the ith position moves to indices[i] in the shuffled string.\n\nReturn the shuffled string.", "examples": "Input: s = \"codeleet\", indices = [4,5,6,7,0,2,1,3]\nOutput: \"leetcode\"\n\nInput: s = \"abc\", indices = [0,1,2]\nOutput: \"abc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "from typing import List\ndef shuffle_string(s: str, indices: List[int]) -> str:\n    def partitionString(s):\n      substrings = 1\n      cur_str = set()\n      for i in range(len(s)):\n        if s[i] in cur_str:\n          substrings += 1\n          cur_str = {s[i]}\n        else:\n          cur_str.add(s[i])\n      return substrings\n    ret = ['_']*len(s)\n    for idx, i in enumerate(indices):\n        ret[i] = s[idx]\n    return \"\".join(ret)\n", "asserts": ["assert shuffle_string(\"reoc\", [2, 0, 1, 3]) == \"eorc\"", "assert shuffle_string(\"aiohn\", [3,1,4,2,0]) == \"nihao\"", "assert shuffle_string(\"aax\", [0,2,1]) == \"axa\"", "assert shuffle_string(\"gh\", [1,0]) == \"hg\"", "assert shuffle_string(\"\", []) == \"\"  # Edge case: empty string", "assert shuffle_string(\"xy\", [0,1]) == \"xy\"  # No shuffle required", "assert shuffle_string(\"pqrstuvwxyzabcdefghijklmno\", list(range(25, -1, -1))) == \"onmlkjihgfedcbazyxwvutsrqp\"  # Reverse shuffle"]}], "category": "String", "prompt_tokens": 851, "total_tokens": 1102, "completion_tokens": 251, "completion": "Write a function that takes a string s and returns the length of the longest substring without repeating characters.\n\n###Code:\n\ndef length_of_longest_substring(s: str) -> int:\n    char_map = {}\n    left = 0\n    max_length = 0\n    for right in range(len(s)):\n        if s[right] in char_map:\n            left = max(left, char_map[s[right]] + 1)\n        char_map[s[right]] = right\n        max_length = max(max_length, right - left + 1)\n    return max_length\n\n###Testcases:\n\nassert length_of_longest_substring(\"abcabcbb\") == 3\nassert length_of_longest_substring(\"bbbbb\") == 1\nassert length_of_longest_substring(\"pwwkew\") == 3\nassert length_of_longest_substring(\"\") == 0  # Edge case: empty string\nassert length_of_longest_substring(\" \") == 1  # Single character\nassert length_of_longest_substring(\"dvdf\") == 3  # Non-contiguous repeat\nassert length_of_longest_substring(\"anviaj\") == 5  # Multiple unique characters\n\n[/Example 3]", "temperature": 0.67, "question": "Write a function that takes a string s and returns the length of the longest substring without repeating characters.", "code": "def length_of_longest_substring(s: str) -> int:\n    char_map = {}\n    left = 0\n    max_length = 0\n    for right in range(len(s)):\n        if s[right] in char_map:\n            left = max(left, char_map[s[right]] + 1)\n        char_map[s[right]] = right\n        max_length = max(max_length, right - left + 1)\n    return max_length", "asserts": ["assert length_of_longest_substring(\"abcabcbb\") == 3", "assert length_of_longest_substring(\"bbbbb\") == 1", "assert length_of_longest_substring(\"pwwkew\") == 3", "assert length_of_longest_substring(\"\") == 0  # Edge case: empty string", "assert length_of_longest_substring(\" \") == 1  # Single character", "assert length_of_longest_substring(\"dvdf\") == 3  # Non-contiguous repeat", "assert length_of_longest_substring(\"anviaj\") == 5  # Multiple unique characters"], "author": "GPT", "UUID": "ca23ccb1-d792-4c70-90ce-f7687a9be9ad", "tc_status": [["assert length_of_longest_substring(\"abcabcbb\") == 3", "Passed"], ["assert length_of_longest_substring(\"bbbbb\") == 1", "Passed"], ["assert length_of_longest_substring(\"pwwkew\") == 3", "Passed"], ["assert length_of_longest_substring(\"\") == 0  # Edge case: empty string", "Passed"], ["assert length_of_longest_substring(\" \") == 1  # Single character", "Passed"], ["assert length_of_longest_substring(\"dvdf\") == 3  # Non-contiguous repeat", "Passed"], ["assert length_of_longest_substring(\"anviaj\") == 5  # Multiple unique characters", "Passed"]]}, {"few_shots": [{"author": "Calvin", "UUID": "56b48f6d-0d81-478d-b838-4d47b62d3031", "question": "Given an integer n, return the number of strings of length n that consist only of vowels (a, e, i, o, u) and are lexicographically sorted.\n\nA string s is lexicographically sorted if for all valid i, s[i] is the same as or comes before s[i+1] in the alphabet.", "examples": "Input: 1\nOutput: 5\n\nInput: 2\nOutput: 15", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def helper(n, letter_idx):\n  letters = [\"a\",\"e\",\"i\",\"o\",\"u\"]\n  dynamic = {\n      'a1' : 5,\n      'e1' : 4,\n      'i1' : 3,\n      'o1' : 2,\n      'u1' : 1\n  }\n  ret = 0\n  key = letters[letter_idx] + str(n)\n  if key in dynamic.keys():\n    return dynamic[key]\n  else:\n    for i in range(letter_idx, len(letters)):\n      ret += helper(n-1, i)\n    dynamic[key] = ret\n  return ret\n  \n\ndef countVowelStrings(n: int) -> int:\n  return helper(n, 0)\n", "asserts": ["assert countVowelStrings(3) == 35", "assert countVowelStrings(4) == 70", "assert countVowelStrings(5) == 126", "assert countVowelStrings(6) == 210", "assert countVowelStrings(7) == 330", "assert countVowelStrings(10) == 1001", "assert countVowelStrings(15) == 3876"]}, {"author": "Calvin", "UUID": "87372a22-f5ef-4100-845b-28700ca3fde3", "question": "You are given a string s and an integer array indices of the same length. The string s will be shuffled such that the character at the ith position moves to indices[i] in the shuffled string.\n\nReturn the shuffled string.", "examples": "Input: s = \"codeleet\", indices = [4,5,6,7,0,2,1,3]\nOutput: \"leetcode\"\n\nInput: s = \"abc\", indices = [0,1,2]\nOutput: \"abc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "from typing import List\ndef shuffle_string(s: str, indices: List[int]) -> str:\n    def partitionString(s):\n      substrings = 1\n      cur_str = set()\n      for i in range(len(s)):\n        if s[i] in cur_str:\n          substrings += 1\n          cur_str = {s[i]}\n        else:\n          cur_str.add(s[i])\n      return substrings\n    ret = ['_']*len(s)\n    for idx, i in enumerate(indices):\n        ret[i] = s[idx]\n    return \"\".join(ret)\n", "asserts": ["assert shuffle_string(\"reoc\", [2, 0, 1, 3]) == \"eorc\"", "assert shuffle_string(\"aiohn\", [3,1,4,2,0]) == \"nihao\"", "assert shuffle_string(\"aax\", [0,2,1]) == \"axa\"", "assert shuffle_string(\"gh\", [1,0]) == \"hg\"", "assert shuffle_string(\"\", []) == \"\"  # Edge case: empty string", "assert shuffle_string(\"xy\", [0,1]) == \"xy\"  # No shuffle required", "assert shuffle_string(\"pqrstuvwxyzabcdefghijklmno\", list(range(25, -1, -1))) == \"onmlkjihgfedcbazyxwvutsrqp\"  # Reverse shuffle"]}], "category": "String", "prompt_tokens": 851, "total_tokens": 1074, "completion_tokens": 223, "completion": "Write a function that takes a string and returns a new string with all vowels removed.\n\n###Code: \n\ndef remove_vowels(s: str) -> str:\n    vowels = set(\"aeiouAEIOU\")\n    return ''.join([ch for ch in s if ch not in vowels])\n\n\n###Testcases: \n\nassert remove_vowels(\"This is a test string\") == \"Ths s  tst strng\"\nassert remove_vowels(\"The quick brown fox\") == \"Th qck brwn fx\"\nassert remove_vowels(\"AEIOUaeiou\") == \"\"\nassert remove_vowels(\"\") == \"\"  # Edge case: empty string\nassert remove_vowels(\"bcdfghjklmnpqrstvwxyz\") == \"bcdfghjklmnpqrstvwxyz\"  # No vowels to remove\nassert remove_vowels(\"I like to eat apples and bananas\") == \" lk t t ppls nd bnns\"\nassert remove_vowels(\"Programming is fun!\") == \"Prgrmmng s fn!\"\n\n[/Example 3]", "temperature": 0.923, "question": "Write a function that takes a string and returns a new string with all vowels removed.", "code": "def remove_vowels(s: str) -> str:\n    vowels = set(\"aeiouAEIOU\")\n    return ''.join([ch for ch in s if ch not in vowels])", "asserts": ["assert remove_vowels(\"This is a test string\") == \"Ths s  tst strng\"", "assert remove_vowels(\"The quick brown fox\") == \"Th qck brwn fx\"", "assert remove_vowels(\"AEIOUaeiou\") == \"\"", "assert remove_vowels(\"\") == \"\"  # Edge case: empty string", "assert remove_vowels(\"bcdfghjklmnpqrstvwxyz\") == \"bcdfghjklmnpqrstvwxyz\"  # No vowels to remove", "assert remove_vowels(\"I like to eat apples and bananas\") == \" lk t t ppls nd bnns\"", "assert remove_vowels(\"Programming is fun!\") == \"Prgrmmng s fn!\""], "author": "GPT", "UUID": "4cd2bc55-fe83-484e-8349-30277aab2e37", "tc_status": [["assert remove_vowels(\"This is a test string\") == \"Ths s  tst strng\"", "Passed"], ["assert remove_vowels(\"The quick brown fox\") == \"Th qck brwn fx\"", "Passed"], ["assert remove_vowels(\"AEIOUaeiou\") == \"\"", "Passed"], ["assert remove_vowels(\"\") == \"\"  # Edge case: empty string", "Passed"], ["assert remove_vowels(\"bcdfghjklmnpqrstvwxyz\") == \"bcdfghjklmnpqrstvwxyz\"  # No vowels to remove", "Passed"], ["assert remove_vowels(\"I like to eat apples and bananas\") == \" lk t t ppls nd bnns\"", "Passed"], ["assert remove_vowels(\"Programming is fun!\") == \"Prgrmmng s fn!\"", "Passed"]]}, {"few_shots": [{"author": "Calvin", "UUID": "56b48f6d-0d81-478d-b838-4d47b62d3031", "question": "Given an integer n, return the number of strings of length n that consist only of vowels (a, e, i, o, u) and are lexicographically sorted.\n\nA string s is lexicographically sorted if for all valid i, s[i] is the same as or comes before s[i+1] in the alphabet.", "examples": "Input: 1\nOutput: 5\n\nInput: 2\nOutput: 15", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def helper(n, letter_idx):\n  letters = [\"a\",\"e\",\"i\",\"o\",\"u\"]\n  dynamic = {\n      'a1' : 5,\n      'e1' : 4,\n      'i1' : 3,\n      'o1' : 2,\n      'u1' : 1\n  }\n  ret = 0\n  key = letters[letter_idx] + str(n)\n  if key in dynamic.keys():\n    return dynamic[key]\n  else:\n    for i in range(letter_idx, len(letters)):\n      ret += helper(n-1, i)\n    dynamic[key] = ret\n  return ret\n  \n\ndef countVowelStrings(n: int) -> int:\n  return helper(n, 0)\n", "asserts": ["assert countVowelStrings(3) == 35", "assert countVowelStrings(4) == 70", "assert countVowelStrings(5) == 126", "assert countVowelStrings(6) == 210", "assert countVowelStrings(7) == 330", "assert countVowelStrings(10) == 1001", "assert countVowelStrings(15) == 3876"]}, {"author": "Calvin", "UUID": "87372a22-f5ef-4100-845b-28700ca3fde3", "question": "You are given a string s and an integer array indices of the same length. The string s will be shuffled such that the character at the ith position moves to indices[i] in the shuffled string.\n\nReturn the shuffled string.", "examples": "Input: s = \"codeleet\", indices = [4,5,6,7,0,2,1,3]\nOutput: \"leetcode\"\n\nInput: s = \"abc\", indices = [0,1,2]\nOutput: \"abc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "from typing import List\ndef shuffle_string(s: str, indices: List[int]) -> str:\n    def partitionString(s):\n      substrings = 1\n      cur_str = set()\n      for i in range(len(s)):\n        if s[i] in cur_str:\n          substrings += 1\n          cur_str = {s[i]}\n        else:\n          cur_str.add(s[i])\n      return substrings\n    ret = ['_']*len(s)\n    for idx, i in enumerate(indices):\n        ret[i] = s[idx]\n    return \"\".join(ret)\n", "asserts": ["assert shuffle_string(\"reoc\", [2, 0, 1, 3]) == \"eorc\"", "assert shuffle_string(\"aiohn\", [3,1,4,2,0]) == \"nihao\"", "assert shuffle_string(\"aax\", [0,2,1]) == \"axa\"", "assert shuffle_string(\"gh\", [1,0]) == \"hg\"", "assert shuffle_string(\"\", []) == \"\"  # Edge case: empty string", "assert shuffle_string(\"xy\", [0,1]) == \"xy\"  # No shuffle required", "assert shuffle_string(\"pqrstuvwxyzabcdefghijklmno\", list(range(25, -1, -1))) == \"onmlkjihgfedcbazyxwvutsrqp\"  # Reverse shuffle"]}], "category": "String", "prompt_tokens": 851, "total_tokens": 1095, "completion_tokens": 244, "completion": "Write a function that takes a string and returns a new string with each character's position in the alphabet as a string concatenated together. For example, \"abc\" would be \"123\" because 'a' is the 1st letter, 'b' is the 2nd, and 'c' is the 3rd. You can assume the string will be lowercase and without any special characters or spaces.\n\n###Code: \n\ndef alphabet_position(text: str) -> str:\n    return ''.join(str(ord(char) - 96) for char in text if char.isalpha())\n\n###Testcases: \n\nassert alphabet_position(\"abc\") == \"123\"\nassert alphabet_position(\"encode\") == \"51431545\"\nassert alphabet_position(\"xyz\") == \"242526\"\nassert alphabet_position(\"hello\") == \"85121215\"\nassert alphabet_position(\"world\") == \"231518124\"\nassert alphabet_position(\"abcdefghijklmnopqrstuvwxyz\") == \"1234567891011121314151617181920212223242526\"\nassert alphabet_position(\"thequickbrownfoxjumpsoverthelazydog\") == \"2085172115918151816715915121315220512081262515\"\n\n[/Example 3]", "temperature": 0.779, "question": "Write a function that takes a string and returns a new string with each character's position in the alphabet as a string concatenated together. For example, \"abc\" would be \"123\" because 'a' is the 1st letter, 'b' is the 2nd, and 'c' is the 3rd. You can assume the string will be lowercase and without any special characters or spaces.", "code": "def alphabet_position(text: str) -> str:\n    return ''.join(str(ord(char) - 96) for char in text if char.isalpha())", "asserts": ["assert alphabet_position(\"abc\") == \"123\"", "assert alphabet_position(\"encode\") == \"51431545\"", "assert alphabet_position(\"xyz\") == \"242526\"", "assert alphabet_position(\"hello\") == \"85121215\"", "assert alphabet_position(\"world\") == \"231518124\"", "assert alphabet_position(\"abcdefghijklmnopqrstuvwxyz\") == \"1234567891011121314151617181920212223242526\""], "author": "GPT", "UUID": "a876ef19-c104-464a-bf52-de71daa4338e", "tc_status": [["assert alphabet_position(\"abc\") == \"123\"", "Passed"], ["assert alphabet_position(\"encode\") == \"51431545\"", "Passed"], ["assert alphabet_position(\"xyz\") == \"242526\"", "Passed"], ["assert alphabet_position(\"hello\") == \"85121215\"", "Passed"], ["assert alphabet_position(\"world\") == \"231518124\"", "Passed"], ["assert alphabet_position(\"abcdefghijklmnopqrstuvwxyz\") == \"1234567891011121314151617181920212223242526\"", "Passed"]]}, {"author": "Calvin", "UUID": "ac641352-08d5-4950-8993-6a143da92ecf", "question": "You are given a string s and an integer k. You can choose one of the first k letters of s and append it at the end of the string.\n\nReturn the lexicographically smallest string you could have after applying the mentioned step any number of moves.\n", "examples": "Input: s = \"cba\", k = 1\nOutput: \"acb\"\n\nInput: s = \"baaca\", k = 3\nOutput: \"aaabc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef orderlyQueue(s: str, k: int) -> str:\n    if k == 1:\n        n = len(s)\n        ss = s + s\n        lex_min_str = s\n        for i in range(n):\n            lex_min_str = min(lex_min_str, ss[i:i + n])\n        return lex_min_str\n    \n    return \"\".join(sorted(s))\n", "asserts": ["assert orderlyQueue(\"abcd\", 1) == \"abcd\"", "assert orderlyQueue(\"hello\", 2) == \"ehllo\"", "assert orderlyQueue(\"programming\", 1) == \"ammingprogr\"", "assert orderlyQueue(\"rotator\", 1) == \"atorrot\"", "assert orderlyQueue(\"zxyabc\", 5) == \"abcxyz\"", "assert orderlyQueue(\"xy\", 2) == \"xy\""], "category": "String"}, {"author": "Calvin", "UUID": "80e34b28-16a8-46ac-8b6a-ee28beb1e8d4", "question": "Write a function that reverses a string. The input string is given as an array of characters s.\n\nYou must do this by modifying the input array in-place with O(1) extra memory.", "examples": "Input: [\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput: [\"o\",\"l\",\"l\",\"e\",\"h\"]\n\nInput: [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\nOutput: [\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def reverse_string(s: list) -> list:\n  l = 0\n  r = len(s) - 1\n  while l < r:\n    tmp = s[l]\n    s[l] = s[r]\n    s[r] = tmp\n    l += 1\n    r -= 1\n  return s\n", "asserts": ["assert reverse_string([\"a\",\"b\",\"c\",\"d\"]) == [\"d\", \"c\", \"b\", \"a\"]", "assert reverse_string([\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"]) == [\"n\", \"o\", \"h\", \"t\", \"y\", \"p\"]", "assert reverse_string([]) == []", "assert reverse_string([\"s\", \"i\", \"n\", \"g\", \"l\", \"e\"]) == [\"e\", \"l\", \"g\", \"n\", \"i\", \"s\"]", "assert reverse_string([\"A\"]) == [\"A\"]", "assert reverse_string([\"9\", \"8\", \"7\", \"6\", \"5\", \"4\", \"3\", \"2\", \"1\"]) == [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]", "assert reverse_string([\"B\", \"o\", \"b\"]) == [\"b\", \"o\", \"B\"]", "assert reverse_string([\"r\", \"e\", \"v\", \"e\", \"r\", \"s\", \"e\"]) == [\"e\", \"s\", \"r\", \"e\", \"v\", \"e\", \"r\"]", "assert reverse_string([\"1\", \"*\", \"2\", \"*\", \"3\"]) == [\"3\", \"*\", \"2\", \"*\", \"1\"]"], "category": "String"}, {"author": "Calvin", "UUID": "d0ce7430-cfcd-4c69-b161-b3b2a186422c", "question": "Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.\n\nIn other words, return true if one of s1's permutations is the substring of s2.", "examples": "Input: s1 = \"ab\", s2 = \"eidbaooo\"\nOutput: True\n\nInput: s1 = \"ab\", s2 = \"eidboaoo\"\nOutput: False", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef permutation_in_string(s1: str, s2: str) -> bool:\n  window = len(s1)\n  if window > len(s2):\n    return False\n  freq1 = [0]*26\n  freq2 = [0]*26\n  for i in range(window):\n    freq1[ord(s1[i])-ord('a')] += 1\n    freq2[ord(s2[i])-ord('a')] += 1\n\n  matches = 0\n  for i in range(26):\n    if freq1[i] == freq2[i]:\n      matches += 1\n  \n  for l in range(len(s2) - window):\n    if matches == 26:\n      return True\n\n    added = ord(s2[l + window]) - ord('a')\n    freq2[added] += 1\n    if freq1[added] == freq2[added]:\n      matches += 1\n    elif freq1[added] + 1 == freq2[added]:\n      matches -= 1\n\n    removed = ord(s2[l]) - ord('a')\n    freq2[removed] -= 1\n    if freq1[removed] == freq2[removed]:\n      matches += 1\n    elif freq1[removed] == freq2[removed] + 1:\n      matches -= 1\n    \n  return matches == 26\n", "asserts": ["assert permutation_in_string(\"hello\", \"ooollehhhhh\") == True", "assert permutation_in_string(\"abc\", \"ccccbbbbaaaa\") == False", "assert permutation_in_string(\"xyz\", \"zxyopqrstuv\") == True", "assert permutation_in_string(\"xyz\", \"xzygxzyzxyzk\") == True", "assert permutation_in_string(\"a\", \"a\") == True", "assert permutation_in_string(\"adc\", \"dcda\") == True", "assert permutation_in_string(\"pq\", \"qpqqp\") == True", "assert permutation_in_string(\"kitten\", \"sittingkite\") == False", "assert permutation_in_string(\"pq\", \"pqpqr\") == True", "assert permutation_in_string(\"aba\", \"aabaabaa\") == True", "assert permutation_in_string(\"\", \"\") == True  # Edge case: both strings are empty", "assert permutation_in_string(\"longerstring\", \"short\") == False  # s1 is longer than s2", "assert permutation_in_string(\"a\", \"b\") == False  # Single character, no match", "assert permutation_in_string(\"aab\", \"baa\") == True  # s1 is a permutation of s2", "assert permutation_in_string(\"ab\", \"a\") == False  # s2 is shorter than s1", "assert permutation_in_string(\"ba\", \"eidbaooo\") == True  # Same characters as Example 1 but different permutation", "assert permutation_in_string(\"eid\", \"eidbaooo\") == True  # s1 is a prefix of s2", "assert permutation_in_string(\"ooo\", \"eidbaooo\") == True  # s1 is a suffix of s2", "assert permutation_in_string(\"db\", \"eidbaooo\") == True  # s1 is a permutation within s2", "assert permutation_in_string(\"eidoo\", \"eidbaooo\") == False  # s1 is longer than any permutation within s2"], "category": "String"}, {"author": "Calvin", "UUID": "87372a22-f5ef-4100-845b-28700ca3fde3", "question": "You are given a string s and an integer array indices of the same length. The string s will be shuffled such that the character at the ith position moves to indices[i] in the shuffled string.\n\nReturn the shuffled string.", "examples": "Input: s = \"codeleet\", indices = [4,5,6,7,0,2,1,3]\nOutput: \"leetcode\"\n\nInput: s = \"abc\", indices = [0,1,2]\nOutput: \"abc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "from typing import List\ndef shuffle_string(s: str, indices: List[int]) -> str:\n    def partitionString(s):\n      substrings = 1\n      cur_str = set()\n      for i in range(len(s)):\n        if s[i] in cur_str:\n          substrings += 1\n          cur_str = {s[i]}\n        else:\n          cur_str.add(s[i])\n      return substrings\n    ret = ['_']*len(s)\n    for idx, i in enumerate(indices):\n        ret[i] = s[idx]\n    return \"\".join(ret)\n", "asserts": ["assert shuffle_string(\"reoc\", [2, 0, 1, 3]) == \"eorc\"", "assert shuffle_string(\"aiohn\", [3,1,4,2,0]) == \"nihao\"", "assert shuffle_string(\"aax\", [0,2,1]) == \"axa\"", "assert shuffle_string(\"gh\", [1,0]) == \"hg\"", "assert shuffle_string(\"\", []) == \"\"  # Edge case: empty string", "assert shuffle_string(\"xy\", [0,1]) == \"xy\"  # No shuffle required", "assert shuffle_string(\"pqrstuvwxyzabcdefghijklmno\", list(range(25, -1, -1))) == \"onmlkjihgfedcbazyxwvutsrqp\"  # Reverse shuffle"], "category": "String"}, {"author": "Calvin", "UUID": "56b48f6d-0d81-478d-b838-4d47b62d3031", "question": "Given an integer n, return the number of strings of length n that consist only of vowels (a, e, i, o, u) and are lexicographically sorted.\n\nA string s is lexicographically sorted if for all valid i, s[i] is the same as or comes before s[i+1] in the alphabet.", "examples": "Input: 1\nOutput: 5\n\nInput: 2\nOutput: 15", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def helper(n, letter_idx):\n  letters = [\"a\",\"e\",\"i\",\"o\",\"u\"]\n  dynamic = {\n      'a1' : 5,\n      'e1' : 4,\n      'i1' : 3,\n      'o1' : 2,\n      'u1' : 1\n  }\n  ret = 0\n  key = letters[letter_idx] + str(n)\n  if key in dynamic.keys():\n    return dynamic[key]\n  else:\n    for i in range(letter_idx, len(letters)):\n      ret += helper(n-1, i)\n    dynamic[key] = ret\n  return ret\n  \n\ndef countVowelStrings(n: int) -> int:\n  return helper(n, 0)\n", "asserts": ["assert countVowelStrings(3) == 35", "assert countVowelStrings(4) == 70", "assert countVowelStrings(5) == 126", "assert countVowelStrings(6) == 210", "assert countVowelStrings(7) == 330", "assert countVowelStrings(10) == 1001", "assert countVowelStrings(15) == 3876"], "category": "String"}], "Array": [{"few_shots": [{"author": "Calvin", "UUID": "f795bda7-9822-4bc5-9c7e-b9c0f2752085", "question": "You are given two 0-indexed integer permutations A and B of length n.\n\nA prefix common array of A and B is an array C such that C[i] is equal to the count of numbers that are present at or before the index i in both A and B.\n\nReturn the prefix common array of A and B.\n\nA sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once.", "examples": "Input: A = [1,3,2,4], B = [3,1,2,4]\nOutput: [0,2,3,4]", "link": "https://leetcode.com/problems/find-the-prefix-common-array-of-two-arrays/", "difficulty": null, "categories": ["Array"], "code": "def findThePrefixCommonArray(arr1: list, arr2: list) -> list:\n  max = len(arr1) if len(arr1) > len(arr2) else len(arr2)\n  seen = set()\n  curCount = 0\n  ret = []\n  for i in range(max):\n    cur1 = arr1[i]\n    cur2 = arr2[i]\n    if cur1 in seen:\n      curCount += 1\n    else:\n      seen.add(cur1)\n    if cur2 in seen:\n      curCount += 1\n    else:\n      seen.add(cur2)\n    ret.append(curCount)\n  return ret\n", "asserts": ["assert findThePrefixCommonArray([1,3,2,4], [3,1,2,4]) == [0,2,3,4]", "assert findThePrefixCommonArray([1], [1]) == [1]", "assert findThePrefixCommonArray([2,3,1], [3,1,2]) == [0,1,3]"]}, {"author": "Calvin", "UUID": "1aeb3246-4c22-4d34-a48c-db7be8ba1b94", "question": "You are given n activities with their start and finish times. Select the maximum number of activities that can be performed by a single person and return their indexes. Assume that a person can only work on a single activity at a time. \n", "examples": "Input: start  =  {10, 12, 20}, finish =  {20, 25, 30}\nOutput: [0, 2]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "import numpy as np\ndef MaxActivities(s: list, f: list) -> list:\n    indices = np.argsort(f)\n    [s[i] for i in indices]\n    [f[i] for i in indices]\n    result = []\n    n = len(f)\n    i = 0\n    result.append(i)\n    for j in range(1, n):\n        if s[j] >= f[i]:\n            result.append(j)\n            i = j\n    return result\n", "asserts": ["assert MaxActivities([2, 4, 5, 6, 7, 8], [3, 5, 6, 7, 9, 10]) == [0, 1, 2, 3, 4]", "assert MaxActivities([1, 3, 0, 5, 8, 5], [2, 4, 6, 7, 9, 9]) == [0, 1, 3, 4]", "assert MaxActivities([1], [2]) == [0]"]}], "category": "Array", "prompt_tokens": 782, "total_tokens": 1069, "completion_tokens": 287, "completion": "Given an array of integers, find the maximum difference between any two elements such that the larger element comes after the smaller element in the array. Return the maximum difference found, or return -1 if no such element pair (i, j) exists such that i < j and arr[i] < arr[j].\n\n###Code:\n\ndef maxDifference(arr: list) -> int:\n    if len(arr) < 2:\n        return -1\n    min_element = arr[0]\n    max_diff = arr[1] - arr[0]\n    for i in range(1, len(arr)):\n        if arr[i] - min_element > max_diff:\n            max_diff = arr[i] - min_element\n        if arr[i] < min_element:\n            min_element = arr[i]\n    return max_diff if max_diff > 0 else -1\n\n\n###Testcases:\n\nassert maxDifference([2, 3, 10, 6, 4, 8, 1]) == 8\nassert maxDifference([7, 9, 5, 6, 3, 2]) == 2\nassert maxDifference([1, 2, 6, 4]) == 5\nassert maxDifference([9, 8, 7, 6, 5]) == -1\nassert maxDifference([5]) == -1\n\n[/Example 3]", "temperature": 0.713, "question": "Given an array of integers, find the maximum difference between any two elements such that the larger element comes after the smaller element in the array. Return the maximum difference found, or return -1 if no such element pair (i, j) exists such that i < j and arr[i] < arr[j].", "code": "def maxDifference(arr: list) -> int:\n    if len(arr) < 2:\n        return -1\n    min_element = arr[0]\n    max_diff = arr[1] - arr[0]\n    for i in range(1, len(arr)):\n        if arr[i] - min_element > max_diff:\n            max_diff = arr[i] - min_element\n        if arr[i] < min_element:\n            min_element = arr[i]\n    return max_diff if max_diff > 0 else -1", "asserts": ["assert maxDifference([2, 3, 10, 6, 4, 8, 1]) == 8", "assert maxDifference([7, 9, 5, 6, 3, 2]) == 2", "assert maxDifference([1, 2, 6, 4]) == 5", "assert maxDifference([9, 8, 7, 6, 5]) == -1", "assert maxDifference([5]) == -1"], "author": "GPT", "UUID": "dfc8ec7f-7953-4c50-a5d2-3608f81e94c4", "tc_status": [["assert maxDifference([2, 3, 10, 6, 4, 8, 1]) == 8", "Passed"], ["assert maxDifference([7, 9, 5, 6, 3, 2]) == 2", "Passed"], ["assert maxDifference([1, 2, 6, 4]) == 5", "Passed"], ["assert maxDifference([9, 8, 7, 6, 5]) == -1", "Passed"], ["assert maxDifference([5]) == -1", "Passed"]]}, {"few_shots": [{"author": "Calvin", "UUID": "9e45b73f-583d-40ab-b387-e0d1624af07b", "question": "Given two arrays return an array with the set intersection of their common elements", "examples": "Input: arr1 = [1, 2, 3, 4], arr2 = [2, 3]\nOutput: [2, 3]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def array_intersection(arr1: list, arr2: list) -> set:\n  set1 = set(arr1)\n  ret = set([x for x in arr2 if x in set1])\n  return list(ret)\n", "asserts": ["assert set(array_intersection([1,0,2,0,2,0,2,1,1,1], [2,1,0,2,0,2,2,2,1,0])) == {0,1,2}", "assert set(array_intersection([5, 6, 7, 8], [8, 9, 10, 11])) == {8}", "assert set(array_intersection([10, 20, 30], [40, 50, 60])) == set()", "assert set(array_intersection([], [1, 2, 3])) == set()", "assert set(array_intersection([-1, -2, -3], [-3, -4, -5, -6])) == {-3}", "assert set(array_intersection([9, 8, 7], [7, 8, 9, 10, 11, 12])) == {7, 8, 9}", "assert set(array_intersection(['a', 'b', 'c'], ['a', 'd', 'e', 'c'])) == {'a', 'c'}", "assert set(array_intersection(['apple', 'banana'], ['banana', 'cherry'])) == {'banana'}", "assert set(array_intersection([1.1, 2.2, 3.3], [2.2, 4.4])) == {2.2}", "assert set(array_intersection([False, True, False], [True, False, True])) == {True, False}", "assert set(array_intersection([(1, 2), (3, 4)], [(3, 4), (5, 6)])) == {(3, 4)}"]}, {"author": "Calvin", "UUID": "48c6aa37-e00d-4b55-9afc-6b1cf2a1aff2", "question": "There are N Mice and N holes are placed in a straight line. Each hole can accommodate only 1 mouse. A mouse can stay at his position, move one step right from x to x + 1, or move one step left from x to x -1. Any of these moves consumes 1 minute. Assign mice to holes so that the time when the last mouse gets inside a hole is minimized.\nYou are given a list of mice and hole positions as integer scalers.\n", "examples": "Input: Mices = [0, 10, 2, 3], Holes = [3, 2, 23, 0]\nOutput: 13", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def assignHole(mices: list, holes: list) -> int:\n    for i,j in zip(mices,holes):\n        if i<0 or j<0:\n            return -1\n    if (len(mices) != len(holes)):\n        return -1\n    mices.sort()\n    holes.sort()\n    Max = 0\n     \n    for i in range(len(holes)):\n        if (Max < abs(mices[i] - holes[i])):\n            Max = abs(mices[i] - holes[i])\n     \n    return Max\n", "asserts": ["assert assignHole([1, 2, 3, 4], [4, 3, 2, 1]) == 0", "assert assignHole([10, 20, 30, 40], [15, 25, 35, 45]) == 5", "assert assignHole([1, 4, 9, 15], [10, 13, 7, 20]) == 6", "assert assignHole([0], [0]) == 0", "assert assignHole([1, 2], [3]) == -1  # Edge case with non-equal amount of mice and holes", "assert assignHole([5, 5, 5], [5, 5, 5]) == 0  # Edge case with all mice and holes at the same position", "assert assignHole([10, 10, 10, 10], [10, 9, 8, 7]) == 3  # Edge case with multiple mice starting at the same position", "assert assignHole([1,1 ,1, 1, 1, 1, 1, 1, 1, 1], [2,2,2,2,2,2 ,2, 2, 2, 2]) == 1 # Edge case with multiple mice and holes at the same positions", "assert assignHole([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == 1 # Edge case with incremental positions"]}], "category": "Array", "prompt_tokens": 1208, "total_tokens": 1826, "completion_tokens": 618, "completion": "Given two equal-length arrays `nums1` and `nums2`, where `nums1[i]` is an element from the first array and `nums2[i]` is the corresponding element from the second array, create and return an array that for each element from the first array, contains the next greater element of that element in the second array.\n\nThe next greater element of a number in the second array is the first greater number to its right in the second array. If it does not exist, output -1 for that number.\n\n###Code: \n\ndef next_greater_element(nums1: list, nums2: list) -> list:\n    result = []\n    greater_dict = {}\n    stack = []\n    \n    # Generate a dictionary with all the next greater elements for nums2\n    for num in nums2:\n        while stack and stack[-1] < num:\n            greater_dict[stack.pop()] = num\n        stack.append(num)\n    \n    # If there is no next greater element, the dictionary will contain -1\n    while stack:\n        greater_dict[stack.pop()] = -1\n    \n    # Map the next greater elements from nums2 to nums1\n    for num in nums1:\n        result.append(greater_dict[num])\n        \n    return result\n\n###Testcases: \n\nassert next_greater_element([4, 1, 2], [1, 3, 4, 2]) == [-1, 3, 3]\nassert next_greater_element([2, 4], [1, 2, 3, 4]) == [3, -1]\nassert next_greater_element([1, 3, 5, 7], [7, 5, 3, 1]) == [-1, -1, -1, -1]\nassert next_greater_element([2, 4, 6], [6, 4, 2, 1, 5]) == [5, 5, -1]\nassert next_greater_element([], []) == []\nassert next_greater_element([10, 20, 30], [30, 10, 20, 5, 25]) == [30, 30, -1]\nassert next_greater_element([9, 8, 7], [7, 8, 9, 11, 10]) == [11, 9, 8]\nassert next_greater_element([1, 1, 1, 1], [1, 3, 4, 2]) == [3, 3, 3, 3]\nassert next_greater_element([5, 5, 5], [6, 5, 4, 3, 2, 1, 7]) == [7, 7, 7]\nassert next_greater_element([14, 10], [15, 13, 14, 17, 12, 10, 16]) == [17, 12]\n\n[/Example 3]", "temperature": 0.931, "question": "Given two equal-length arrays `nums1` and `nums2`, where `nums1[i]` is an element from the first array and `nums2[i]` is the corresponding element from the second array, create and return an array that for each element from the first array, contains the next greater element of that element in the second array.\n\nThe next greater element of a number in the second array is the first greater number to its right in the second array. If it does not exist, output -1 for that number.", "code": "def next_greater_element(nums1: list, nums2: list) -> list:\n    result = []\n    greater_dict = {}\n    stack = []\n    \n    # Generate a dictionary with all the next greater elements for nums2\n    for num in nums2:\n        while stack and stack[-1] < num:\n            greater_dict[stack.pop()] = num\n        stack.append(num)\n    \n    # If there is no next greater element, the dictionary will contain -1\n    while stack:\n        greater_dict[stack.pop()] = -1\n    \n    # Map the next greater elements from nums2 to nums1\n    for num in nums1:\n        result.append(greater_dict[num])\n        \n    return result", "asserts": ["assert next_greater_element([2, 4], [1, 2, 3, 4]) == [3, -1]", "assert next_greater_element([1, 3, 5, 7], [7, 5, 3, 1]) == [-1, -1, -1, -1]", "assert next_greater_element([2, 4, 6], [6, 4, 2, 1, 5]) == [5, 5, -1]", "assert next_greater_element([], []) == []", "assert next_greater_element([9, 8, 7], [7, 8, 9, 11, 10]) == [11, 9, 8]", "assert next_greater_element([1, 1, 1, 1], [1, 3, 4, 2]) == [3, 3, 3, 3]", "assert next_greater_element([5, 5, 5], [6, 5, 4, 3, 2, 1, 7]) == [7, 7, 7]"], "author": "GPT", "UUID": "3ebf7a81-109f-42c2-b7de-59c7d6ad130a", "tc_status": [["assert next_greater_element([2, 4], [1, 2, 3, 4]) == [3, -1]", "Passed"], ["assert next_greater_element([1, 3, 5, 7], [7, 5, 3, 1]) == [-1, -1, -1, -1]", "Passed"], ["assert next_greater_element([2, 4, 6], [6, 4, 2, 1, 5]) == [5, 5, -1]", "Passed"], ["assert next_greater_element([], []) == []", "Passed"], ["assert next_greater_element([9, 8, 7], [7, 8, 9, 11, 10]) == [11, 9, 8]", "Passed"], ["assert next_greater_element([1, 1, 1, 1], [1, 3, 4, 2]) == [3, 3, 3, 3]", "Passed"], ["assert next_greater_element([5, 5, 5], [6, 5, 4, 3, 2, 1, 7]) == [7, 7, 7]", "Passed"]]}, {"few_shots": [{"author": "Calvin", "UUID": "1aeb3246-4c22-4d34-a48c-db7be8ba1b94", "question": "You are given n activities with their start and finish times. Select the maximum number of activities that can be performed by a single person and return their indexes. Assume that a person can only work on a single activity at a time. \n", "examples": "Input: start  =  {10, 12, 20}, finish =  {20, 25, 30}\nOutput: [0, 2]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "import numpy as np\ndef MaxActivities(s: list, f: list) -> list:\n    indices = np.argsort(f)\n    [s[i] for i in indices]\n    [f[i] for i in indices]\n    result = []\n    n = len(f)\n    i = 0\n    result.append(i)\n    for j in range(1, n):\n        if s[j] >= f[i]:\n            result.append(j)\n            i = j\n    return result\n", "asserts": ["assert MaxActivities([2, 4, 5, 6, 7, 8], [3, 5, 6, 7, 9, 10]) == [0, 1, 2, 3, 4]", "assert MaxActivities([1, 3, 0, 5, 8, 5], [2, 4, 6, 7, 9, 9]) == [0, 1, 3, 4]", "assert MaxActivities([1], [2]) == [0]"]}, {"author": "Calvin", "UUID": "48c6aa37-e00d-4b55-9afc-6b1cf2a1aff2", "question": "There are N Mice and N holes are placed in a straight line. Each hole can accommodate only 1 mouse. A mouse can stay at his position, move one step right from x to x + 1, or move one step left from x to x -1. Any of these moves consumes 1 minute. Assign mice to holes so that the time when the last mouse gets inside a hole is minimized.\nYou are given a list of mice and hole positions as integer scalers.\n", "examples": "Input: Mices = [0, 10, 2, 3], Holes = [3, 2, 23, 0]\nOutput: 13", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def assignHole(mices: list, holes: list) -> int:\n    for i,j in zip(mices,holes):\n        if i<0 or j<0:\n            return -1\n    if (len(mices) != len(holes)):\n        return -1\n    mices.sort()\n    holes.sort()\n    Max = 0\n     \n    for i in range(len(holes)):\n        if (Max < abs(mices[i] - holes[i])):\n            Max = abs(mices[i] - holes[i])\n     \n    return Max\n", "asserts": ["assert assignHole([1, 2, 3, 4], [4, 3, 2, 1]) == 0", "assert assignHole([10, 20, 30, 40], [15, 25, 35, 45]) == 5", "assert assignHole([1, 4, 9, 15], [10, 13, 7, 20]) == 6", "assert assignHole([0], [0]) == 0", "assert assignHole([1, 2], [3]) == -1  # Edge case with non-equal amount of mice and holes", "assert assignHole([5, 5, 5], [5, 5, 5]) == 0  # Edge case with all mice and holes at the same position", "assert assignHole([10, 10, 10, 10], [10, 9, 8, 7]) == 3  # Edge case with multiple mice starting at the same position", "assert assignHole([1,1 ,1, 1, 1, 1, 1, 1, 1, 1], [2,2,2,2,2,2 ,2, 2, 2, 2]) == 1 # Edge case with multiple mice and holes at the same positions", "assert assignHole([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == 1 # Edge case with incremental positions"]}], "category": "Array", "prompt_tokens": 1068, "total_tokens": 1524, "completion_tokens": 456, "completion": "Given an array of integers, rearrange the array so that the even elements appear at the front of the array and the odd elements appear at the end. The relative order of the even and odd elements should not change. Return the rearranged array.\n\n###Code: \n\ndef rearrangeArray(arr: list) -> list:\n    even = [x for x in arr if x % 2 == 0]\n    odd = [x for x in arr if x % 2 != 0]\n    return even + odd\n\n###Testcases: \n\nassert rearrangeArray([1, 2, 3, 4, 5, 6, 7, 8]) == [2, 4, 6, 8, 1, 3, 5, 7]\nassert rearrangeArray([4, 2, 5, 7, 8]) == [4, 2, 8, 5, 7]\nassert rearrangeArray([11, 13, 15]) == [11, 13, 15] # Edge case with all odd numbers\nassert rearrangeArray([10, 6, 8, 20]) == [10, 6, 8, 20] # Edge case with all even numbers\nassert rearrangeArray([]) == [] # Edge case with an empty array\nassert rearrangeArray([1, 2, 1, 3, 2, 4, 5, 4, 6]) == [2, 4, 2, 4, 6, 1, 1, 3, 5] # Edge case with repeating elements\nassert rearrangeArray([3, 3, 3, 2, 2, 2]) == [2, 2, 2, 3, 3, 3] # Edge case with equal count of odd and even numbers\nassert rearrangeArray([-1, 4, -3, -2, 0, 5]) == [4, -2, 0, -1, -3, 5] # Edge case with negative numbers\n\n[/Example 3]", "temperature": 0.945, "question": "Given an array of integers, rearrange the array so that the even elements appear at the front of the array and the odd elements appear at the end. The relative order of the even and odd elements should not change. Return the rearranged array.", "code": "def rearrangeArray(arr: list) -> list:\n    even = [x for x in arr if x % 2 == 0]\n    odd = [x for x in arr if x % 2 != 0]\n    return even + odd", "asserts": ["assert rearrangeArray([1, 2, 3, 4, 5, 6, 7, 8]) == [2, 4, 6, 8, 1, 3, 5, 7]", "assert rearrangeArray([4, 2, 5, 7, 8]) == [4, 2, 8, 5, 7]", "assert rearrangeArray([11, 13, 15]) == [11, 13, 15] # Edge case with all odd numbers", "assert rearrangeArray([10, 6, 8, 20]) == [10, 6, 8, 20] # Edge case with all even numbers", "assert rearrangeArray([]) == [] # Edge case with an empty array", "assert rearrangeArray([3, 3, 3, 2, 2, 2]) == [2, 2, 2, 3, 3, 3] # Edge case with equal count of odd and even numbers", "assert rearrangeArray([-1, 4, -3, -2, 0, 5]) == [4, -2, 0, -1, -3, 5] # Edge case with negative numbers"], "author": "GPT", "UUID": "64501559-7645-479b-aa3b-edc9eb20311e", "tc_status": [["assert rearrangeArray([1, 2, 3, 4, 5, 6, 7, 8]) == [2, 4, 6, 8, 1, 3, 5, 7]", "Passed"], ["assert rearrangeArray([4, 2, 5, 7, 8]) == [4, 2, 8, 5, 7]", "Passed"], ["assert rearrangeArray([11, 13, 15]) == [11, 13, 15] # Edge case with all odd numbers", "Passed"], ["assert rearrangeArray([10, 6, 8, 20]) == [10, 6, 8, 20] # Edge case with all even numbers", "Passed"], ["assert rearrangeArray([]) == [] # Edge case with an empty array", "Passed"], ["assert rearrangeArray([3, 3, 3, 2, 2, 2]) == [2, 2, 2, 3, 3, 3] # Edge case with equal count of odd and even numbers", "Passed"], ["assert rearrangeArray([-1, 4, -3, -2, 0, 5]) == [4, -2, 0, -1, -3, 5] # Edge case with negative numbers", "Passed"]]}, {"few_shots": [{"author": "Calvin", "UUID": "a9c5e697-af5d-432b-8447-5675d739c728", "question": "Given an array reorder it so that even numbers appear first", "examples": "Input: [1,2,3,4,5,6,7,8,9]\r\nOutput: [8,2,6,4,5,7,3,9,1]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def even_odd_reorder(arr: list) -> list:\n  nextEven = 0\n  nextOdd = len(arr) - 1\n  while nextEven < nextOdd:\n    if arr[nextEven] % 2 == 0:\n      nextEven += 1\n    else:\n      temp = arr[nextEven]\n      arr[nextEven] = arr[nextOdd]\n      arr[nextOdd] = temp\n      nextOdd -= 1\n  return arr\n", "asserts": ["assert even_odd_reorder([1,2,3,4,5,6,7,8,9]) == [8, 2, 6, 4, 5, 7, 3, 9, 1]", "assert even_odd_reorder([]) == []", "assert even_odd_reorder([2, 4, 6, 8]) == [2, 4, 6, 8]", "assert even_odd_reorder([7, 9, 2]) == [2, 9, 7]", "assert even_odd_reorder([10, 13, 17, 16, 15, 12]) == [10, 12, 16, 15, 17, 13]"]}, {"author": "Calvin", "UUID": "fb94082f-4627-4f5a-b280-08d869823d70", "question": "You are given an array of people, people, which are the attributes of some people in a queue (not necessarily in order). Each people[i] = [hi, ki] represents the ith person of height hi with exactly ki other people in front who have a height greater than or equal to hi.\n\nReconstruct and return the queue that is represented by the input array people. The returned queue should be formatted as an array queue, where queue[j] = [hj, kj] is the attributes of the jth person in the queue (queue[0] is the person at the front of the queue).\n", "examples": "Input:  [[7, 0], [4, 4], [7, 1], [5, 0], [6, 1], [5, 2]]\nOutput: [[5, 0], [4, 1], [7, 0], [5, 2], [6, 1], [7, 1]]\n\nInput:  [[6, 0], [5, 0], [4, 0], [3, 2], [2, 2], [1, 4]]\nOutput: [[4, 0], [5, 0], [2, 2], [3, 2], [1, 4], [6, 0]]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "\ndef reconstructQueue(people: list) -> list:\n    output=[] \n    people.sort(key=lambda x: (-x[0], x[1]))                \n    for a in people:\n        output.insert(a[1], a)\n    \n    return output\n", "asserts": ["assert reconstructQueue([[8,1],[5,0],[6,1],[5,2],[4,4],[7,1]]) == [[5, 0], [8, 1], [5, 2], [6, 1], [4, 4], [7, 1]]", "assert reconstructQueue([[12,0], [6,3], [4,4], [9,2], [7,1]]) == [[12, 0], [7, 1], [9, 2], [6, 3], [4, 4]]", "assert reconstructQueue([[2,0], [1,1]]) == [[2, 0], [1, 1]]", "assert reconstructQueue([[3,0], [3,2], [3,1]]) == [[3, 0], [3, 1], [3, 2]]"]}], "category": "Array", "prompt_tokens": 842, "total_tokens": 1098, "completion_tokens": 256, "completion": "Find the \"pivot\" index of an array where the sum of the numbers to the left of the index is equal to the sum of the numbers to the right of the index. If no such index exists, return -1. If there are multiple pivot indexes, you should return the left-most pivot index.\n\n###Code: \n\n```python\ndef find_pivot_index(nums: list) -> int:\n    total_sum = sum(nums)\n    left_sum = 0\n    for i, num in enumerate(nums):\n        if left_sum == (total_sum - left_sum - num):\n            return i\n        left_sum += num\n    return -1\n```\n\n###Testcases: \n\n```python\nassert find_pivot_index([1, 7, 3, 6, 5, 6]) == 3\nassert find_pivot_index([1, 2, 3]) == -1\nassert find_pivot_index([2, 1, -1]) == 0\nassert find_pivot_index([]) == -1\nassert find_pivot_index([0, 0, 0, 0]) == 0  # The pivot could be any index in this case\n```\n\n[/Example 3]", "temperature": 0.896, "question": "Find the \"pivot\" index of an array where the sum of the numbers to the left of the index is equal to the sum of the numbers to the right of the index. If no such index exists, return -1. If there are multiple pivot indexes, you should return the left-most pivot index.", "code": "def find_pivot_index(nums: list) -> int:\n    total_sum = sum(nums)\n    left_sum = 0\n    for i, num in enumerate(nums):\n        if left_sum == (total_sum - left_sum - num):\n            return i\n        left_sum += num\n    return -1", "asserts": ["assert find_pivot_index([1, 7, 3, 6, 5, 6]) == 3", "assert find_pivot_index([1, 2, 3]) == -1", "assert find_pivot_index([2, 1, -1]) == 0", "assert find_pivot_index([]) == -1", "assert find_pivot_index([0, 0, 0, 0]) == 0  # The pivot could be any index in this case"], "author": "GPT", "UUID": "82c8f35a-e325-4146-90db-af6112fa5936", "tc_status": [["assert find_pivot_index([1, 7, 3, 6, 5, 6]) == 3", "Passed"], ["assert find_pivot_index([1, 2, 3]) == -1", "Passed"], ["assert find_pivot_index([2, 1, -1]) == 0", "Passed"], ["assert find_pivot_index([]) == -1", "Passed"], ["assert find_pivot_index([0, 0, 0, 0]) == 0  # The pivot could be any index in this case", "Passed"]]}, {"few_shots": [{"author": "Calvin", "UUID": "48c6aa37-e00d-4b55-9afc-6b1cf2a1aff2", "question": "There are N Mice and N holes are placed in a straight line. Each hole can accommodate only 1 mouse. A mouse can stay at his position, move one step right from x to x + 1, or move one step left from x to x -1. Any of these moves consumes 1 minute. Assign mice to holes so that the time when the last mouse gets inside a hole is minimized.\nYou are given a list of mice and hole positions as integer scalers.\n", "examples": "Input: Mices = [0, 10, 2, 3], Holes = [3, 2, 23, 0]\nOutput: 13", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def assignHole(mices: list, holes: list) -> int:\n    for i,j in zip(mices,holes):\n        if i<0 or j<0:\n            return -1\n    if (len(mices) != len(holes)):\n        return -1\n    mices.sort()\n    holes.sort()\n    Max = 0\n     \n    for i in range(len(holes)):\n        if (Max < abs(mices[i] - holes[i])):\n            Max = abs(mices[i] - holes[i])\n     \n    return Max\n", "asserts": ["assert assignHole([1, 2, 3, 4], [4, 3, 2, 1]) == 0", "assert assignHole([10, 20, 30, 40], [15, 25, 35, 45]) == 5", "assert assignHole([1, 4, 9, 15], [10, 13, 7, 20]) == 6", "assert assignHole([0], [0]) == 0", "assert assignHole([1, 2], [3]) == -1  # Edge case with non-equal amount of mice and holes", "assert assignHole([5, 5, 5], [5, 5, 5]) == 0  # Edge case with all mice and holes at the same position", "assert assignHole([10, 10, 10, 10], [10, 9, 8, 7]) == 3  # Edge case with multiple mice starting at the same position", "assert assignHole([1,1 ,1, 1, 1, 1, 1, 1, 1, 1], [2,2,2,2,2,2 ,2, 2, 2, 2]) == 1 # Edge case with multiple mice and holes at the same positions", "assert assignHole([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == 1 # Edge case with incremental positions"]}, {"author": "Calvin", "UUID": "9e45b73f-583d-40ab-b387-e0d1624af07b", "question": "Given two arrays return an array with the set intersection of their common elements", "examples": "Input: arr1 = [1, 2, 3, 4], arr2 = [2, 3]\nOutput: [2, 3]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def array_intersection(arr1: list, arr2: list) -> set:\n  set1 = set(arr1)\n  ret = set([x for x in arr2 if x in set1])\n  return list(ret)\n", "asserts": ["assert set(array_intersection([1,0,2,0,2,0,2,1,1,1], [2,1,0,2,0,2,2,2,1,0])) == {0,1,2}", "assert set(array_intersection([5, 6, 7, 8], [8, 9, 10, 11])) == {8}", "assert set(array_intersection([10, 20, 30], [40, 50, 60])) == set()", "assert set(array_intersection([], [1, 2, 3])) == set()", "assert set(array_intersection([-1, -2, -3], [-3, -4, -5, -6])) == {-3}", "assert set(array_intersection([9, 8, 7], [7, 8, 9, 10, 11, 12])) == {7, 8, 9}", "assert set(array_intersection(['a', 'b', 'c'], ['a', 'd', 'e', 'c'])) == {'a', 'c'}", "assert set(array_intersection(['apple', 'banana'], ['banana', 'cherry'])) == {'banana'}", "assert set(array_intersection([1.1, 2.2, 3.3], [2.2, 4.4])) == {2.2}", "assert set(array_intersection([False, True, False], [True, False, True])) == {True, False}", "assert set(array_intersection([(1, 2), (3, 4)], [(3, 4), (5, 6)])) == {(3, 4)}"]}], "category": "Array", "prompt_tokens": 1208, "total_tokens": 1644, "completion_tokens": 436, "completion": "Given an array of integers, find all pairs of elements that sum up to a specific target number. Return a list of pairs, each pair represented as a tuple.\n\n###Code: \n\ndef two_sum_pairs(arr: list, target: int) -> list:\n    seen = {}\n    pairs = []\n    for num in arr:\n        if target - num in seen:\n            pairs.append((target - num, num))\n        seen[num] = True\n    return pairs\n\n###Testcases: \n\nassert two_sum_pairs([1, 2, 3, 4, 5], 5) == [(2, 3), (1, 4)]\nassert two_sum_pairs([10, -1, 1, 0, 2, -2, -10], 0) == [(10, -10), (-1, 1), (2, -2)]\nassert two_sum_pairs([1, 1, 1, 1], 2) == [(1, 1), (1, 1), (1, 1)]\nassert two_sum_pairs([5, 5, 3, 0, -2, 3, -5], 3) == [(0, 3), (-2, 5), (0, 3), (-2, 5), (-5, 8)]\nassert two_sum_pairs([0, 2, 4, 6, 8, 10], 7) == []\nassert two_sum_pairs([], 100) == []\nassert two_sum_pairs([50], 100) == []\nassert two_sum_pairs([-3, -1, 1, 2, 5, 7], 4) == [(-1, 5), (1, 3)]\nassert two_sum_pairs([100, 200, 300, 400], 500) == [(100, 400), (200, 300)]\nassert two_sum_pairs([1, 5, 7, -1], 6) == [(1, 5), (7, -1)]\n\n[/Example 3]", "temperature": 0.669, "question": "Given an array of integers, find all pairs of elements that sum up to a specific target number. Return a list of pairs, each pair represented as a tuple.", "code": "def two_sum_pairs(arr: list, target: int) -> list:\n    seen = {}\n    pairs = []\n    for num in arr:\n        if target - num in seen:\n            pairs.append((target - num, num))\n        seen[num] = True\n    return pairs", "asserts": ["assert two_sum_pairs([1, 2, 3, 4, 5], 5) == [(2, 3), (1, 4)]", "assert two_sum_pairs([1, 1, 1, 1], 2) == [(1, 1), (1, 1), (1, 1)]", "assert two_sum_pairs([0, 2, 4, 6, 8, 10], 7) == []", "assert two_sum_pairs([], 100) == []", "assert two_sum_pairs([50], 100) == []", "assert two_sum_pairs([1, 5, 7, -1], 6) == [(1, 5), (7, -1)]"], "author": "GPT", "UUID": "41bda289-3717-4940-a870-57fdedca9bf7", "tc_status": [["assert two_sum_pairs([1, 2, 3, 4, 5], 5) == [(2, 3), (1, 4)]", "Passed"], ["assert two_sum_pairs([1, 1, 1, 1], 2) == [(1, 1), (1, 1), (1, 1)]", "Passed"], ["assert two_sum_pairs([0, 2, 4, 6, 8, 10], 7) == []", "Passed"], ["assert two_sum_pairs([], 100) == []", "Passed"], ["assert two_sum_pairs([50], 100) == []", "Passed"], ["assert two_sum_pairs([1, 5, 7, -1], 6) == [(1, 5), (7, -1)]", "Passed"]]}, {"few_shots": [{"author": "Calvin", "UUID": "48c6aa37-e00d-4b55-9afc-6b1cf2a1aff2", "question": "There are N Mice and N holes are placed in a straight line. Each hole can accommodate only 1 mouse. A mouse can stay at his position, move one step right from x to x + 1, or move one step left from x to x -1. Any of these moves consumes 1 minute. Assign mice to holes so that the time when the last mouse gets inside a hole is minimized.\nYou are given a list of mice and hole positions as integer scalers.\n", "examples": "Input: Mices = [0, 10, 2, 3], Holes = [3, 2, 23, 0]\nOutput: 13", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def assignHole(mices: list, holes: list) -> int:\n    for i,j in zip(mices,holes):\n        if i<0 or j<0:\n            return -1\n    if (len(mices) != len(holes)):\n        return -1\n    mices.sort()\n    holes.sort()\n    Max = 0\n     \n    for i in range(len(holes)):\n        if (Max < abs(mices[i] - holes[i])):\n            Max = abs(mices[i] - holes[i])\n     \n    return Max\n", "asserts": ["assert assignHole([1, 2, 3, 4], [4, 3, 2, 1]) == 0", "assert assignHole([10, 20, 30, 40], [15, 25, 35, 45]) == 5", "assert assignHole([1, 4, 9, 15], [10, 13, 7, 20]) == 6", "assert assignHole([0], [0]) == 0", "assert assignHole([1, 2], [3]) == -1  # Edge case with non-equal amount of mice and holes", "assert assignHole([5, 5, 5], [5, 5, 5]) == 0  # Edge case with all mice and holes at the same position", "assert assignHole([10, 10, 10, 10], [10, 9, 8, 7]) == 3  # Edge case with multiple mice starting at the same position", "assert assignHole([1,1 ,1, 1, 1, 1, 1, 1, 1, 1], [2,2,2,2,2,2 ,2, 2, 2, 2]) == 1 # Edge case with multiple mice and holes at the same positions", "assert assignHole([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == 1 # Edge case with incremental positions"]}, {"author": "Calvin", "UUID": "9e45b73f-583d-40ab-b387-e0d1624af07b", "question": "Given two arrays return an array with the set intersection of their common elements", "examples": "Input: arr1 = [1, 2, 3, 4], arr2 = [2, 3]\nOutput: [2, 3]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def array_intersection(arr1: list, arr2: list) -> set:\n  set1 = set(arr1)\n  ret = set([x for x in arr2 if x in set1])\n  return list(ret)\n", "asserts": ["assert set(array_intersection([1,0,2,0,2,0,2,1,1,1], [2,1,0,2,0,2,2,2,1,0])) == {0,1,2}", "assert set(array_intersection([5, 6, 7, 8], [8, 9, 10, 11])) == {8}", "assert set(array_intersection([10, 20, 30], [40, 50, 60])) == set()", "assert set(array_intersection([], [1, 2, 3])) == set()", "assert set(array_intersection([-1, -2, -3], [-3, -4, -5, -6])) == {-3}", "assert set(array_intersection([9, 8, 7], [7, 8, 9, 10, 11, 12])) == {7, 8, 9}", "assert set(array_intersection(['a', 'b', 'c'], ['a', 'd', 'e', 'c'])) == {'a', 'c'}", "assert set(array_intersection(['apple', 'banana'], ['banana', 'cherry'])) == {'banana'}", "assert set(array_intersection([1.1, 2.2, 3.3], [2.2, 4.4])) == {2.2}", "assert set(array_intersection([False, True, False], [True, False, True])) == {True, False}", "assert set(array_intersection([(1, 2), (3, 4)], [(3, 4), (5, 6)])) == {(3, 4)}"]}], "category": "Array", "prompt_tokens": 1208, "total_tokens": 1785, "completion_tokens": 577, "completion": "Given an array arr[] of N integers, arrange the elements of the array in zig-zag fashion. The converted array should be in form a < b > c < d > e < f. The relative order of elements is same in the output, i.e., you have to iterate over the array only once.\n\n###Code: \n\ndef zigzag_arrangement(arr: list) -> list:\n    flag = True\n  \n    for i in range(len(arr)-1):\n        if flag:\n            if arr[i] > arr[i+1]:\n                arr[i], arr[i+1] = arr[i+1], arr[i]\n        else:\n            if arr[i] < arr[i+1]:\n                arr[i], arr[i+1] = arr[i+1], arr[i]\n        flag = not flag\n    \n    return arr\n\n###Testcases: \n\nassert zigzag_arrangement([4, 3, 7, 8, 6, 2, 1]) == [3, 7, 4, 8, 2, 6, 1]\nassert zigzag_arrangement([1, 4, 3, 2]) == [1, 4, 2, 3]\nassert zigzag_arrangement([1, 3, 2, 4]) == [1, 3, 2, 4]\nassert zigzag_arrangement([1]) == [1]\nassert zigzag_arrangement([4, 3, 2, 1]) == [3, 4, 1, 2]\nassert zigzag_arrangement([1, 2, 3, 4, 5, 6, 7]) == [1, 3, 2, 5, 4, 7, 6]\nassert zigzag_arrangement([100, 90, 40, 50, 30]) == [90, 100, 40, 50, 30]\nassert zigzag_arrangement([1, 2, 3, 4]) == [1, 3, 2, 4]\nassert zigzag_arrangement([-1, -2, -3, -4, -5, -6, -7]) == [-2, -1, -4, -3, -6, -5, -7]\nassert zigzag_arrangement([0, 1, 0, 1, 0, 1]) == [0, 1, 0, 1, 0, 1]\nassert zigzag_arrangement([10]) == [10]\nassert zigzag_arrangement([1, 0, 0, -1]) == [0, 1, -1, 0] \n\n[/Example 3]", "temperature": 0.912, "question": "Given an array arr[] of N integers, arrange the elements of the array in zig-zag fashion. The converted array should be in form a < b > c < d > e < f. The relative order of elements is same in the output, i.e., you have to iterate over the array only once.", "code": "def zigzag_arrangement(arr: list) -> list:\n    flag = True\n  \n    for i in range(len(arr)-1):\n        if flag:\n            if arr[i] > arr[i+1]:\n                arr[i], arr[i+1] = arr[i+1], arr[i]\n        else:\n            if arr[i] < arr[i+1]:\n                arr[i], arr[i+1] = arr[i+1], arr[i]\n        flag = not flag\n    \n    return arr", "asserts": ["assert zigzag_arrangement([4, 3, 7, 8, 6, 2, 1]) == [3, 7, 4, 8, 2, 6, 1]", "assert zigzag_arrangement([1, 4, 3, 2]) == [1, 4, 2, 3]", "assert zigzag_arrangement([1, 3, 2, 4]) == [1, 3, 2, 4]", "assert zigzag_arrangement([1]) == [1]", "assert zigzag_arrangement([4, 3, 2, 1]) == [3, 4, 1, 2]", "assert zigzag_arrangement([1, 2, 3, 4, 5, 6, 7]) == [1, 3, 2, 5, 4, 7, 6]", "assert zigzag_arrangement([100, 90, 40, 50, 30]) == [90, 100, 40, 50, 30]", "assert zigzag_arrangement([1, 2, 3, 4]) == [1, 3, 2, 4]", "assert zigzag_arrangement([-1, -2, -3, -4, -5, -6, -7]) == [-2, -1, -4, -3, -6, -5, -7]", "assert zigzag_arrangement([0, 1, 0, 1, 0, 1]) == [0, 1, 0, 1, 0, 1]", "assert zigzag_arrangement([10]) == [10]", "assert zigzag_arrangement([1, 0, 0, -1]) == [0, 1, -1, 0]"], "author": "GPT", "UUID": "86267819-6dff-4d9a-8e1c-f4f1af06a3e4", "tc_status": [["assert zigzag_arrangement([4, 3, 7, 8, 6, 2, 1]) == [3, 7, 4, 8, 2, 6, 1]", "Passed"], ["assert zigzag_arrangement([1, 4, 3, 2]) == [1, 4, 2, 3]", "Passed"], ["assert zigzag_arrangement([1, 3, 2, 4]) == [1, 3, 2, 4]", "Passed"], ["assert zigzag_arrangement([1]) == [1]", "Passed"], ["assert zigzag_arrangement([4, 3, 2, 1]) == [3, 4, 1, 2]", "Passed"], ["assert zigzag_arrangement([1, 2, 3, 4, 5, 6, 7]) == [1, 3, 2, 5, 4, 7, 6]", "Passed"], ["assert zigzag_arrangement([100, 90, 40, 50, 30]) == [90, 100, 40, 50, 30]", "Passed"], ["assert zigzag_arrangement([1, 2, 3, 4]) == [1, 3, 2, 4]", "Passed"], ["assert zigzag_arrangement([-1, -2, -3, -4, -5, -6, -7]) == [-2, -1, -4, -3, -6, -5, -7]", "Passed"], ["assert zigzag_arrangement([0, 1, 0, 1, 0, 1]) == [0, 1, 0, 1, 0, 1]", "Passed"], ["assert zigzag_arrangement([10]) == [10]", "Passed"], ["assert zigzag_arrangement([1, 0, 0, -1]) == [0, 1, -1, 0]", "Passed"]]}, {"few_shots": [{"author": "Calvin", "UUID": "f795bda7-9822-4bc5-9c7e-b9c0f2752085", "question": "You are given two 0-indexed integer permutations A and B of length n.\n\nA prefix common array of A and B is an array C such that C[i] is equal to the count of numbers that are present at or before the index i in both A and B.\n\nReturn the prefix common array of A and B.\n\nA sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once.", "examples": "Input: A = [1,3,2,4], B = [3,1,2,4]\nOutput: [0,2,3,4]", "link": "https://leetcode.com/problems/find-the-prefix-common-array-of-two-arrays/", "difficulty": null, "categories": ["Array"], "code": "def findThePrefixCommonArray(arr1: list, arr2: list) -> list:\n  max = len(arr1) if len(arr1) > len(arr2) else len(arr2)\n  seen = set()\n  curCount = 0\n  ret = []\n  for i in range(max):\n    cur1 = arr1[i]\n    cur2 = arr2[i]\n    if cur1 in seen:\n      curCount += 1\n    else:\n      seen.add(cur1)\n    if cur2 in seen:\n      curCount += 1\n    else:\n      seen.add(cur2)\n    ret.append(curCount)\n  return ret\n", "asserts": ["assert findThePrefixCommonArray([1,3,2,4], [3,1,2,4]) == [0,2,3,4]", "assert findThePrefixCommonArray([1], [1]) == [1]", "assert findThePrefixCommonArray([2,3,1], [3,1,2]) == [0,1,3]"]}, {"author": "Calvin", "UUID": "fb94082f-4627-4f5a-b280-08d869823d70", "question": "You are given an array of people, people, which are the attributes of some people in a queue (not necessarily in order). Each people[i] = [hi, ki] represents the ith person of height hi with exactly ki other people in front who have a height greater than or equal to hi.\n\nReconstruct and return the queue that is represented by the input array people. The returned queue should be formatted as an array queue, where queue[j] = [hj, kj] is the attributes of the jth person in the queue (queue[0] is the person at the front of the queue).\n", "examples": "Input:  [[7, 0], [4, 4], [7, 1], [5, 0], [6, 1], [5, 2]]\nOutput: [[5, 0], [4, 1], [7, 0], [5, 2], [6, 1], [7, 1]]\n\nInput:  [[6, 0], [5, 0], [4, 0], [3, 2], [2, 2], [1, 4]]\nOutput: [[4, 0], [5, 0], [2, 2], [3, 2], [1, 4], [6, 0]]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "\ndef reconstructQueue(people: list) -> list:\n    output=[] \n    people.sort(key=lambda x: (-x[0], x[1]))                \n    for a in people:\n        output.insert(a[1], a)\n    \n    return output\n", "asserts": ["assert reconstructQueue([[8,1],[5,0],[6,1],[5,2],[4,4],[7,1]]) == [[5, 0], [8, 1], [5, 2], [6, 1], [4, 4], [7, 1]]", "assert reconstructQueue([[12,0], [6,3], [4,4], [9,2], [7,1]]) == [[12, 0], [7, 1], [9, 2], [6, 3], [4, 4]]", "assert reconstructQueue([[2,0], [1,1]]) == [[2, 0], [1, 1]]", "assert reconstructQueue([[3,0], [3,2], [3,1]]) == [[3, 0], [3, 1], [3, 2]]"]}], "category": "Array", "prompt_tokens": 878, "total_tokens": 1185, "completion_tokens": 307, "completion": "Given an array of intervals where intervals[i] = [starti, endi], merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input.\n\n###Code: \n\ndef mergeIntervals(intervals: list) -> list:\n    intervals.sort(key=lambda x: x[0])  # Sort the intervals by their start value.\n    merged = []\n    for interval in intervals:\n        # If the list of merged intervals is empty, or if the current interval doesn't overlap\n        # with the previous one, simply append it.\n        if not merged or merged[-1][1] < interval[0]:\n            merged.append(interval)\n        else:\n            # There is overlap, so we merge the current and previous intervals.\n            merged[-1][1] = max(merged[-1][1], interval[1])\n    return merged\n\n###Testcases: \n\nassert mergeIntervals([[1,3],[2,6],[8,10],[15,18]]) == [[1,6],[8,10],[15,18]]\nassert mergeIntervals([[1,4],[4,5]]) == [[1,5]]\nassert mergeIntervals([[1,4],[0,2],[3,5]]) == [[0,5]]\nassert mergeIntervals([[1,4],[0,4]]) == [[0,4]]\nassert mergeIntervals([[1,4],[2,3]]) == [[1,4]]\n\n[/Example 3]", "temperature": 0.931, "question": "Given an array of intervals where intervals[i] = [starti, endi], merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input.", "code": "def mergeIntervals(intervals: list) -> list:\n    intervals.sort(key=lambda x: x[0])  # Sort the intervals by their start value.\n    merged = []\n    for interval in intervals:\n        # If the list of merged intervals is empty, or if the current interval doesn't overlap\n        # with the previous one, simply append it.\n        if not merged or merged[-1][1] < interval[0]:\n            merged.append(interval)\n        else:\n            # There is overlap, so we merge the current and previous intervals.\n            merged[-1][1] = max(merged[-1][1], interval[1])\n    return merged", "asserts": ["assert mergeIntervals([[1,3],[2,6],[8,10],[15,18]]) == [[1,6],[8,10],[15,18]]", "assert mergeIntervals([[1,4],[4,5]]) == [[1,5]]", "assert mergeIntervals([[1,4],[0,2],[3,5]]) == [[0,5]]", "assert mergeIntervals([[1,4],[0,4]]) == [[0,4]]", "assert mergeIntervals([[1,4],[2,3]]) == [[1,4]]"], "author": "GPT", "UUID": "8c1c3fa3-3d96-4520-8cb1-80448e9b1522", "tc_status": [["assert mergeIntervals([[1,3],[2,6],[8,10],[15,18]]) == [[1,6],[8,10],[15,18]]", "Passed"], ["assert mergeIntervals([[1,4],[4,5]]) == [[1,5]]", "Passed"], ["assert mergeIntervals([[1,4],[0,2],[3,5]]) == [[0,5]]", "Passed"], ["assert mergeIntervals([[1,4],[0,4]]) == [[0,4]]", "Passed"], ["assert mergeIntervals([[1,4],[2,3]]) == [[1,4]]", "Passed"]]}, {"few_shots": [{"author": "Calvin", "UUID": "a9c5e697-af5d-432b-8447-5675d739c728", "question": "Given an array reorder it so that even numbers appear first", "examples": "Input: [1,2,3,4,5,6,7,8,9]\r\nOutput: [8,2,6,4,5,7,3,9,1]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def even_odd_reorder(arr: list) -> list:\n  nextEven = 0\n  nextOdd = len(arr) - 1\n  while nextEven < nextOdd:\n    if arr[nextEven] % 2 == 0:\n      nextEven += 1\n    else:\n      temp = arr[nextEven]\n      arr[nextEven] = arr[nextOdd]\n      arr[nextOdd] = temp\n      nextOdd -= 1\n  return arr\n", "asserts": ["assert even_odd_reorder([1,2,3,4,5,6,7,8,9]) == [8, 2, 6, 4, 5, 7, 3, 9, 1]", "assert even_odd_reorder([]) == []", "assert even_odd_reorder([2, 4, 6, 8]) == [2, 4, 6, 8]", "assert even_odd_reorder([7, 9, 2]) == [2, 9, 7]", "assert even_odd_reorder([10, 13, 17, 16, 15, 12]) == [10, 12, 16, 15, 17, 13]"]}, {"author": "Calvin", "UUID": "48c6aa37-e00d-4b55-9afc-6b1cf2a1aff2", "question": "There are N Mice and N holes are placed in a straight line. Each hole can accommodate only 1 mouse. A mouse can stay at his position, move one step right from x to x + 1, or move one step left from x to x -1. Any of these moves consumes 1 minute. Assign mice to holes so that the time when the last mouse gets inside a hole is minimized.\nYou are given a list of mice and hole positions as integer scalers.\n", "examples": "Input: Mices = [0, 10, 2, 3], Holes = [3, 2, 23, 0]\nOutput: 13", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def assignHole(mices: list, holes: list) -> int:\n    for i,j in zip(mices,holes):\n        if i<0 or j<0:\n            return -1\n    if (len(mices) != len(holes)):\n        return -1\n    mices.sort()\n    holes.sort()\n    Max = 0\n     \n    for i in range(len(holes)):\n        if (Max < abs(mices[i] - holes[i])):\n            Max = abs(mices[i] - holes[i])\n     \n    return Max\n", "asserts": ["assert assignHole([1, 2, 3, 4], [4, 3, 2, 1]) == 0", "assert assignHole([10, 20, 30, 40], [15, 25, 35, 45]) == 5", "assert assignHole([1, 4, 9, 15], [10, 13, 7, 20]) == 6", "assert assignHole([0], [0]) == 0", "assert assignHole([1, 2], [3]) == -1  # Edge case with non-equal amount of mice and holes", "assert assignHole([5, 5, 5], [5, 5, 5]) == 0  # Edge case with all mice and holes at the same position", "assert assignHole([10, 10, 10, 10], [10, 9, 8, 7]) == 3  # Edge case with multiple mice starting at the same position", "assert assignHole([1,1 ,1, 1, 1, 1, 1, 1, 1, 1], [2,2,2,2,2,2 ,2, 2, 2, 2]) == 1 # Edge case with multiple mice and holes at the same positions", "assert assignHole([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == 1 # Edge case with incremental positions"]}], "category": "Array", "prompt_tokens": 1067, "total_tokens": 1485, "completion_tokens": 418, "completion": "Given an array of integers, determine if it is monotonically increasing or decreasing. An array is monotonically increasing if for all i <= j, arr[i] <= arr[j]. Similarly, an array is monotonically decreasing if for all i <= j, arr[i] >= arr[j]. If the array is either monotonically increasing or decreasing, return `True`. Otherwise, return `False`.\n\n###Code: \n\n```python\ndef isMonotonic(arr: list) -> bool:\n    if not arr:\n        return True\n    \n    increasing = decreasing = True\n    \n    for i in range(1, len(arr)):\n        if arr[i] > arr[i - 1]:\n            decreasing = False\n        elif arr[i] < arr[i - 1]:\n            increasing = False\n            \n    return increasing or decreasing\n```\n\n###Testcases: \n\n```python\nassert isMonotonic([1, 2, 2, 3]) == True\nassert isMonotonic([6, 5, 4, 4]) == True\nassert isMonotonic([1, 3, 2]) == False\nassert isMonotonic([1, 2, 4, 5]) == True\nassert isMonotonic([1]) == True\nassert isMonotonic([]) == True\nassert isMonotonic([5, 5, 5, 5, 5]) == True\nassert isMonotonic([10, 10, 8, 7, 6, 5, 5, 3]) == True\nassert isMonotonic([1, 2, 0, 3, 4, 5, 6, 7, 8, 9]) == False\nassert isMonotonic([5, 4, 3, 2, 1, 0, -1, -2, -3, -4, -5]) == True\n```\n\n[/Example 3]", "temperature": 0.876, "question": "Given an array of integers, determine if it is monotonically increasing or decreasing. An array is monotonically increasing if for all i <= j, arr[i] <= arr[j]. Similarly, an array is monotonically decreasing if for all i <= j, arr[i] >= arr[j]. If the array is either monotonically increasing or decreasing, return `True`. Otherwise, return `False`.", "code": "def isMonotonic(arr: list) -> bool:\n    if not arr:\n        return True\n    \n    increasing = decreasing = True\n    \n    for i in range(1, len(arr)):\n        if arr[i] > arr[i - 1]:\n            decreasing = False\n        elif arr[i] < arr[i - 1]:\n            increasing = False\n            \n    return increasing or decreasing", "asserts": ["assert isMonotonic([1, 2, 2, 3]) == True", "assert isMonotonic([6, 5, 4, 4]) == True", "assert isMonotonic([1, 3, 2]) == False", "assert isMonotonic([1, 2, 4, 5]) == True", "assert isMonotonic([1]) == True", "assert isMonotonic([]) == True", "assert isMonotonic([5, 5, 5, 5, 5]) == True", "assert isMonotonic([10, 10, 8, 7, 6, 5, 5, 3]) == True", "assert isMonotonic([1, 2, 0, 3, 4, 5, 6, 7, 8, 9]) == False", "assert isMonotonic([5, 4, 3, 2, 1, 0, -1, -2, -3, -4, -5]) == True"], "author": "GPT", "UUID": "fa995d72-cb4b-41d3-9a0d-55e87c3e74e2", "tc_status": [["assert isMonotonic([1, 2, 2, 3]) == True", "Passed"], ["assert isMonotonic([6, 5, 4, 4]) == True", "Passed"], ["assert isMonotonic([1, 3, 2]) == False", "Passed"], ["assert isMonotonic([1, 2, 4, 5]) == True", "Passed"], ["assert isMonotonic([1]) == True", "Passed"], ["assert isMonotonic([]) == True", "Passed"], ["assert isMonotonic([5, 5, 5, 5, 5]) == True", "Passed"], ["assert isMonotonic([10, 10, 8, 7, 6, 5, 5, 3]) == True", "Passed"], ["assert isMonotonic([1, 2, 0, 3, 4, 5, 6, 7, 8, 9]) == False", "Passed"], ["assert isMonotonic([5, 4, 3, 2, 1, 0, -1, -2, -3, -4, -5]) == True", "Passed"]]}, {"few_shots": [{"author": "Calvin", "UUID": "a9c5e697-af5d-432b-8447-5675d739c728", "question": "Given an array reorder it so that even numbers appear first", "examples": "Input: [1,2,3,4,5,6,7,8,9]\r\nOutput: [8,2,6,4,5,7,3,9,1]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def even_odd_reorder(arr: list) -> list:\n  nextEven = 0\n  nextOdd = len(arr) - 1\n  while nextEven < nextOdd:\n    if arr[nextEven] % 2 == 0:\n      nextEven += 1\n    else:\n      temp = arr[nextEven]\n      arr[nextEven] = arr[nextOdd]\n      arr[nextOdd] = temp\n      nextOdd -= 1\n  return arr\n", "asserts": ["assert even_odd_reorder([1,2,3,4,5,6,7,8,9]) == [8, 2, 6, 4, 5, 7, 3, 9, 1]", "assert even_odd_reorder([]) == []", "assert even_odd_reorder([2, 4, 6, 8]) == [2, 4, 6, 8]", "assert even_odd_reorder([7, 9, 2]) == [2, 9, 7]", "assert even_odd_reorder([10, 13, 17, 16, 15, 12]) == [10, 12, 16, 15, 17, 13]"]}, {"author": "Calvin", "UUID": "1aeb3246-4c22-4d34-a48c-db7be8ba1b94", "question": "You are given n activities with their start and finish times. Select the maximum number of activities that can be performed by a single person and return their indexes. Assume that a person can only work on a single activity at a time. \n", "examples": "Input: start  =  {10, 12, 20}, finish =  {20, 25, 30}\nOutput: [0, 2]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "import numpy as np\ndef MaxActivities(s: list, f: list) -> list:\n    indices = np.argsort(f)\n    [s[i] for i in indices]\n    [f[i] for i in indices]\n    result = []\n    n = len(f)\n    i = 0\n    result.append(i)\n    for j in range(1, n):\n        if s[j] >= f[i]:\n            result.append(j)\n            i = j\n    return result\n", "asserts": ["assert MaxActivities([2, 4, 5, 6, 7, 8], [3, 5, 6, 7, 9, 10]) == [0, 1, 2, 3, 4]", "assert MaxActivities([1, 3, 0, 5, 8, 5], [2, 4, 6, 7, 9, 9]) == [0, 1, 3, 4]", "assert MaxActivities([1], [2]) == [0]"]}], "category": "Array", "prompt_tokens": 746, "total_tokens": 1033, "completion_tokens": 287, "completion": "Given an array of integers, return true if and only if it is possible to rearrange the array such that arithmetic progression can be formed with a common difference. If possible, return the common difference.\n\n###Code:\n\ndef can_reform_to_arithmetic_progression(arr: list) -> tuple:\n    if len(arr) < 2:\n        return (False, None)\n    arr.sort()\n    common_diff = arr[1] - arr[0]\n    for i in range(2, len(arr)):\n        if arr[i] - arr[i - 1] != common_diff:\n            return (False, None)\n    return (True, common_diff)\n\n###Testcases:\n\nassert can_reform_to_arithmetic_progression([3, 5, 1]) == (True, 2)\nassert can_reform_to_arithmetic_progression([1, 2, 4]) == (False, None)\nassert can_reform_to_arithmetic_progression([5, 5, 5]) == (True, 0)\nassert can_reform_to_arithmetic_progression([]) == (False, None)\nassert can_reform_to_arithmetic_progression([1]) == (True, 0)\nassert can_reform_to_arithmetic_progression([11, 1, 5, 3, 7, 9]) == (True, 2)\n\n[/Example 3]", "temperature": 0.882, "question": "Given an array of integers, return true if and only if it is possible to rearrange the array such that arithmetic progression can be formed with a common difference. If possible, return the common difference.", "code": "def can_reform_to_arithmetic_progression(arr: list) -> tuple:\n    if len(arr) < 2:\n        return (False, None)\n    arr.sort()\n    common_diff = arr[1] - arr[0]\n    for i in range(2, len(arr)):\n        if arr[i] - arr[i - 1] != common_diff:\n            return (False, None)\n    return (True, common_diff)", "asserts": ["assert can_reform_to_arithmetic_progression([3, 5, 1]) == (True, 2)", "assert can_reform_to_arithmetic_progression([1, 2, 4]) == (False, None)", "assert can_reform_to_arithmetic_progression([5, 5, 5]) == (True, 0)", "assert can_reform_to_arithmetic_progression([]) == (False, None)", "assert can_reform_to_arithmetic_progression([11, 1, 5, 3, 7, 9]) == (True, 2)"], "author": "GPT", "UUID": "e6dbed86-2559-40fe-8c25-86c960d7e0ba", "tc_status": [["assert can_reform_to_arithmetic_progression([3, 5, 1]) == (True, 2)", "Passed"], ["assert can_reform_to_arithmetic_progression([1, 2, 4]) == (False, None)", "Passed"], ["assert can_reform_to_arithmetic_progression([5, 5, 5]) == (True, 0)", "Passed"], ["assert can_reform_to_arithmetic_progression([]) == (False, None)", "Passed"], ["assert can_reform_to_arithmetic_progression([11, 1, 5, 3, 7, 9]) == (True, 2)", "Passed"]]}, {"few_shots": [{"author": "Calvin", "UUID": "a9c5e697-af5d-432b-8447-5675d739c728", "question": "Given an array reorder it so that even numbers appear first", "examples": "Input: [1,2,3,4,5,6,7,8,9]\r\nOutput: [8,2,6,4,5,7,3,9,1]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def even_odd_reorder(arr: list) -> list:\n  nextEven = 0\n  nextOdd = len(arr) - 1\n  while nextEven < nextOdd:\n    if arr[nextEven] % 2 == 0:\n      nextEven += 1\n    else:\n      temp = arr[nextEven]\n      arr[nextEven] = arr[nextOdd]\n      arr[nextOdd] = temp\n      nextOdd -= 1\n  return arr\n", "asserts": ["assert even_odd_reorder([1,2,3,4,5,6,7,8,9]) == [8, 2, 6, 4, 5, 7, 3, 9, 1]", "assert even_odd_reorder([]) == []", "assert even_odd_reorder([2, 4, 6, 8]) == [2, 4, 6, 8]", "assert even_odd_reorder([7, 9, 2]) == [2, 9, 7]", "assert even_odd_reorder([10, 13, 17, 16, 15, 12]) == [10, 12, 16, 15, 17, 13]"]}, {"author": "Calvin", "UUID": "fb94082f-4627-4f5a-b280-08d869823d70", "question": "You are given an array of people, people, which are the attributes of some people in a queue (not necessarily in order). Each people[i] = [hi, ki] represents the ith person of height hi with exactly ki other people in front who have a height greater than or equal to hi.\n\nReconstruct and return the queue that is represented by the input array people. The returned queue should be formatted as an array queue, where queue[j] = [hj, kj] is the attributes of the jth person in the queue (queue[0] is the person at the front of the queue).\n", "examples": "Input:  [[7, 0], [4, 4], [7, 1], [5, 0], [6, 1], [5, 2]]\nOutput: [[5, 0], [4, 1], [7, 0], [5, 2], [6, 1], [7, 1]]\n\nInput:  [[6, 0], [5, 0], [4, 0], [3, 2], [2, 2], [1, 4]]\nOutput: [[4, 0], [5, 0], [2, 2], [3, 2], [1, 4], [6, 0]]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "\ndef reconstructQueue(people: list) -> list:\n    output=[] \n    people.sort(key=lambda x: (-x[0], x[1]))                \n    for a in people:\n        output.insert(a[1], a)\n    \n    return output\n", "asserts": ["assert reconstructQueue([[8,1],[5,0],[6,1],[5,2],[4,4],[7,1]]) == [[5, 0], [8, 1], [5, 2], [6, 1], [4, 4], [7, 1]]", "assert reconstructQueue([[12,0], [6,3], [4,4], [9,2], [7,1]]) == [[12, 0], [7, 1], [9, 2], [6, 3], [4, 4]]", "assert reconstructQueue([[2,0], [1,1]]) == [[2, 0], [1, 1]]", "assert reconstructQueue([[3,0], [3,2], [3,1]]) == [[3, 0], [3, 1], [3, 2]]"]}], "category": "Array", "prompt_tokens": 842, "total_tokens": 1035, "completion_tokens": 193, "completion": "Given two integer arrays, return their intersection. Each element in the result must be unique and you may return the result in any order.\n\n###Code:\n\ndef intersection(nums1: list, nums2: list) -> list:\n    # Convert both lists to sets to remove duplicates and then find intersection.\n    result = list(set(nums1) & set(nums2))\n    return result\n\n###Testcases:\n\nassert sorted(intersection([1,2,2,1], [2,2])) == [2]\nassert sorted(intersection([4,9,5], [9,4,9,8,4])) == [4, 9]\nassert sorted(intersection([1,7,3], [2,4,6])) == []\nassert sorted(intersection([], [1, 2, 3])) == []\nassert sorted(intersection([2,2,2], [2,2])) == [2]\n\n[/Example 3]", "temperature": 0.935, "question": "Given two integer arrays, return their intersection. Each element in the result must be unique and you may return the result in any order.", "code": "def intersection(nums1: list, nums2: list) -> list:\n    # Convert both lists to sets to remove duplicates and then find intersection.\n    result = list(set(nums1) & set(nums2))\n    return result", "asserts": ["assert sorted(intersection([1,2,2,1], [2,2])) == [2]", "assert sorted(intersection([4,9,5], [9,4,9,8,4])) == [4, 9]", "assert sorted(intersection([1,7,3], [2,4,6])) == []", "assert sorted(intersection([], [1, 2, 3])) == []", "assert sorted(intersection([2,2,2], [2,2])) == [2]"], "author": "GPT", "UUID": "0a561c6a-f1c3-45a3-9cc5-7f931fda01a3", "tc_status": [["assert sorted(intersection([1,2,2,1], [2,2])) == [2]", "Passed"], ["assert sorted(intersection([4,9,5], [9,4,9,8,4])) == [4, 9]", "Passed"], ["assert sorted(intersection([1,7,3], [2,4,6])) == []", "Passed"], ["assert sorted(intersection([], [1, 2, 3])) == []", "Passed"], ["assert sorted(intersection([2,2,2], [2,2])) == [2]", "Passed"]]}, {"few_shots": [{"author": "Calvin", "UUID": "48c6aa37-e00d-4b55-9afc-6b1cf2a1aff2", "question": "There are N Mice and N holes are placed in a straight line. Each hole can accommodate only 1 mouse. A mouse can stay at his position, move one step right from x to x + 1, or move one step left from x to x -1. Any of these moves consumes 1 minute. Assign mice to holes so that the time when the last mouse gets inside a hole is minimized.\nYou are given a list of mice and hole positions as integer scalers.\n", "examples": "Input: Mices = [0, 10, 2, 3], Holes = [3, 2, 23, 0]\nOutput: 13", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def assignHole(mices: list, holes: list) -> int:\n    for i,j in zip(mices,holes):\n        if i<0 or j<0:\n            return -1\n    if (len(mices) != len(holes)):\n        return -1\n    mices.sort()\n    holes.sort()\n    Max = 0\n     \n    for i in range(len(holes)):\n        if (Max < abs(mices[i] - holes[i])):\n            Max = abs(mices[i] - holes[i])\n     \n    return Max\n", "asserts": ["assert assignHole([1, 2, 3, 4], [4, 3, 2, 1]) == 0", "assert assignHole([10, 20, 30, 40], [15, 25, 35, 45]) == 5", "assert assignHole([1, 4, 9, 15], [10, 13, 7, 20]) == 6", "assert assignHole([0], [0]) == 0", "assert assignHole([1, 2], [3]) == -1  # Edge case with non-equal amount of mice and holes", "assert assignHole([5, 5, 5], [5, 5, 5]) == 0  # Edge case with all mice and holes at the same position", "assert assignHole([10, 10, 10, 10], [10, 9, 8, 7]) == 3  # Edge case with multiple mice starting at the same position", "assert assignHole([1,1 ,1, 1, 1, 1, 1, 1, 1, 1], [2,2,2,2,2,2 ,2, 2, 2, 2]) == 1 # Edge case with multiple mice and holes at the same positions", "assert assignHole([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == 1 # Edge case with incremental positions"]}, {"author": "Calvin", "UUID": "9e45b73f-583d-40ab-b387-e0d1624af07b", "question": "Given two arrays return an array with the set intersection of their common elements", "examples": "Input: arr1 = [1, 2, 3, 4], arr2 = [2, 3]\nOutput: [2, 3]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def array_intersection(arr1: list, arr2: list) -> set:\n  set1 = set(arr1)\n  ret = set([x for x in arr2 if x in set1])\n  return list(ret)\n", "asserts": ["assert set(array_intersection([1,0,2,0,2,0,2,1,1,1], [2,1,0,2,0,2,2,2,1,0])) == {0,1,2}", "assert set(array_intersection([5, 6, 7, 8], [8, 9, 10, 11])) == {8}", "assert set(array_intersection([10, 20, 30], [40, 50, 60])) == set()", "assert set(array_intersection([], [1, 2, 3])) == set()", "assert set(array_intersection([-1, -2, -3], [-3, -4, -5, -6])) == {-3}", "assert set(array_intersection([9, 8, 7], [7, 8, 9, 10, 11, 12])) == {7, 8, 9}", "assert set(array_intersection(['a', 'b', 'c'], ['a', 'd', 'e', 'c'])) == {'a', 'c'}", "assert set(array_intersection(['apple', 'banana'], ['banana', 'cherry'])) == {'banana'}", "assert set(array_intersection([1.1, 2.2, 3.3], [2.2, 4.4])) == {2.2}", "assert set(array_intersection([False, True, False], [True, False, True])) == {True, False}", "assert set(array_intersection([(1, 2), (3, 4)], [(3, 4), (5, 6)])) == {(3, 4)}"]}], "category": "Array", "prompt_tokens": 1208, "total_tokens": 1530, "completion_tokens": 322, "completion": "Given an array of unique integers and a target value, determine if there is a pair of integers in the array that sums up to the target value.\n\n###Code: \n\ndef has_pair_with_sum(arr: list, target: int) -> bool:\n    seen = set()\n    for num in arr:\n        if target - num in seen:\n            return True\n        seen.add(num)\n    return False\n\n###Testcases: \n\nassert has_pair_with_sum([1, 2, 3, 4], 5) == True\nassert has_pair_with_sum([1, 2, 3, 4], 8) == False\nassert has_pair_with_sum([-1, -2, -3, -4], -7) == True\nassert has_pair_with_sum([1, 3, 5, 7], 12) == False\nassert has_pair_with_sum([0, 14, 3, 7], 17) == True\nassert has_pair_with_sum([1, 5, 7, -1], 6) == True\nassert has_pair_with_sum([10, 15, 3, 7], 17) == True\nassert has_pair_with_sum([10, 15, 3, 4], 19) == True\nassert has_pair_with_sum([1, 2, 3, 6], 9) == True\nassert has_pair_with_sum([0, 2, 9, 11], 0) == False\n\n[/Example 3]", "temperature": 0.847, "question": "Given an array of unique integers and a target value, determine if there is a pair of integers in the array that sums up to the target value.", "code": "def has_pair_with_sum(arr: list, target: int) -> bool:\n    seen = set()\n    for num in arr:\n        if target - num in seen:\n            return True\n        seen.add(num)\n    return False", "asserts": ["assert has_pair_with_sum([1, 2, 3, 4], 5) == True", "assert has_pair_with_sum([1, 2, 3, 4], 8) == False", "assert has_pair_with_sum([-1, -2, -3, -4], -7) == True", "assert has_pair_with_sum([0, 14, 3, 7], 17) == True", "assert has_pair_with_sum([1, 5, 7, -1], 6) == True", "assert has_pair_with_sum([10, 15, 3, 7], 17) == True", "assert has_pair_with_sum([10, 15, 3, 4], 19) == True", "assert has_pair_with_sum([1, 2, 3, 6], 9) == True", "assert has_pair_with_sum([0, 2, 9, 11], 0) == False"], "author": "GPT", "UUID": "9c61529a-b8ca-4167-b05d-465d4ff7e5c6", "tc_status": [["assert has_pair_with_sum([1, 2, 3, 4], 5) == True", "Passed"], ["assert has_pair_with_sum([1, 2, 3, 4], 8) == False", "Passed"], ["assert has_pair_with_sum([-1, -2, -3, -4], -7) == True", "Passed"], ["assert has_pair_with_sum([0, 14, 3, 7], 17) == True", "Passed"], ["assert has_pair_with_sum([1, 5, 7, -1], 6) == True", "Passed"], ["assert has_pair_with_sum([10, 15, 3, 7], 17) == True", "Passed"], ["assert has_pair_with_sum([10, 15, 3, 4], 19) == True", "Passed"], ["assert has_pair_with_sum([1, 2, 3, 6], 9) == True", "Passed"], ["assert has_pair_with_sum([0, 2, 9, 11], 0) == False", "Passed"]]}, {"few_shots": [{"author": "Calvin", "UUID": "1aeb3246-4c22-4d34-a48c-db7be8ba1b94", "question": "You are given n activities with their start and finish times. Select the maximum number of activities that can be performed by a single person and return their indexes. Assume that a person can only work on a single activity at a time. \n", "examples": "Input: start  =  {10, 12, 20}, finish =  {20, 25, 30}\nOutput: [0, 2]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "import numpy as np\ndef MaxActivities(s: list, f: list) -> list:\n    indices = np.argsort(f)\n    [s[i] for i in indices]\n    [f[i] for i in indices]\n    result = []\n    n = len(f)\n    i = 0\n    result.append(i)\n    for j in range(1, n):\n        if s[j] >= f[i]:\n            result.append(j)\n            i = j\n    return result\n", "asserts": ["assert MaxActivities([2, 4, 5, 6, 7, 8], [3, 5, 6, 7, 9, 10]) == [0, 1, 2, 3, 4]", "assert MaxActivities([1, 3, 0, 5, 8, 5], [2, 4, 6, 7, 9, 9]) == [0, 1, 3, 4]", "assert MaxActivities([1], [2]) == [0]"]}, {"author": "Calvin", "UUID": "f795bda7-9822-4bc5-9c7e-b9c0f2752085", "question": "You are given two 0-indexed integer permutations A and B of length n.\n\nA prefix common array of A and B is an array C such that C[i] is equal to the count of numbers that are present at or before the index i in both A and B.\n\nReturn the prefix common array of A and B.\n\nA sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once.", "examples": "Input: A = [1,3,2,4], B = [3,1,2,4]\nOutput: [0,2,3,4]", "link": "https://leetcode.com/problems/find-the-prefix-common-array-of-two-arrays/", "difficulty": null, "categories": ["Array"], "code": "def findThePrefixCommonArray(arr1: list, arr2: list) -> list:\n  max = len(arr1) if len(arr1) > len(arr2) else len(arr2)\n  seen = set()\n  curCount = 0\n  ret = []\n  for i in range(max):\n    cur1 = arr1[i]\n    cur2 = arr2[i]\n    if cur1 in seen:\n      curCount += 1\n    else:\n      seen.add(cur1)\n    if cur2 in seen:\n      curCount += 1\n    else:\n      seen.add(cur2)\n    ret.append(curCount)\n  return ret\n", "asserts": ["assert findThePrefixCommonArray([1,3,2,4], [3,1,2,4]) == [0,2,3,4]", "assert findThePrefixCommonArray([1], [1]) == [1]", "assert findThePrefixCommonArray([2,3,1], [3,1,2]) == [0,1,3]"]}], "category": "Array", "prompt_tokens": 782, "total_tokens": 1018, "completion_tokens": 236, "completion": "Given an array of non-negative integers arr and an integer target, find the length of the shortest non-empty subarray of arr whose sum is at least target. If no such subarray exists, return 0.\n\n###Code:\n\ndef minSubArrayLen(target: int, nums: list) -> int:\n    n = len(nums)\n    ans = n + 1  # Set ans to a large value\n    left = 0\n    sum = 0\n    for right in range(n):\n        sum += nums[right]\n        while sum >= target:\n            ans = min(ans, right - left + 1)\n            sum -= nums[left]\n            left += 1\n    return ans if ans != n + 1 else 0\n\n###Testcases:\n\nassert minSubArrayLen(7, [2,3,1,2,4,3]) == 2\nassert minSubArrayLen(4, [1,4,4]) == 1\nassert minSubArrayLen(11, [1,1,1,1,1,1,1,1]) == 0\n\n[/Example 3]", "temperature": 0.888, "question": "Given an array of non-negative integers arr and an integer target, find the length of the shortest non-empty subarray of arr whose sum is at least target. If no such subarray exists, return 0.", "code": "def minSubArrayLen(target: int, nums: list) -> int:\n    n = len(nums)\n    ans = n + 1  # Set ans to a large value\n    left = 0\n    sum = 0\n    for right in range(n):\n        sum += nums[right]\n        while sum >= target:\n            ans = min(ans, right - left + 1)\n            sum -= nums[left]\n            left += 1\n    return ans if ans != n + 1 else 0", "asserts": ["assert minSubArrayLen(7, [2,3,1,2,4,3]) == 2", "assert minSubArrayLen(4, [1,4,4]) == 1", "assert minSubArrayLen(11, [1,1,1,1,1,1,1,1]) == 0"], "author": "GPT", "UUID": "4c25fb7e-4af0-404f-8b19-d3ac1f3b0b15", "tc_status": [["assert minSubArrayLen(7, [2,3,1,2,4,3]) == 2", "Passed"], ["assert minSubArrayLen(4, [1,4,4]) == 1", "Passed"], ["assert minSubArrayLen(11, [1,1,1,1,1,1,1,1]) == 0", "Passed"]]}, {"few_shots": [{"author": "Calvin", "UUID": "48c6aa37-e00d-4b55-9afc-6b1cf2a1aff2", "question": "There are N Mice and N holes are placed in a straight line. Each hole can accommodate only 1 mouse. A mouse can stay at his position, move one step right from x to x + 1, or move one step left from x to x -1. Any of these moves consumes 1 minute. Assign mice to holes so that the time when the last mouse gets inside a hole is minimized.\nYou are given a list of mice and hole positions as integer scalers.\n", "examples": "Input: Mices = [0, 10, 2, 3], Holes = [3, 2, 23, 0]\nOutput: 13", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def assignHole(mices: list, holes: list) -> int:\n    for i,j in zip(mices,holes):\n        if i<0 or j<0:\n            return -1\n    if (len(mices) != len(holes)):\n        return -1\n    mices.sort()\n    holes.sort()\n    Max = 0\n     \n    for i in range(len(holes)):\n        if (Max < abs(mices[i] - holes[i])):\n            Max = abs(mices[i] - holes[i])\n     \n    return Max\n", "asserts": ["assert assignHole([1, 2, 3, 4], [4, 3, 2, 1]) == 0", "assert assignHole([10, 20, 30, 40], [15, 25, 35, 45]) == 5", "assert assignHole([1, 4, 9, 15], [10, 13, 7, 20]) == 6", "assert assignHole([0], [0]) == 0", "assert assignHole([1, 2], [3]) == -1  # Edge case with non-equal amount of mice and holes", "assert assignHole([5, 5, 5], [5, 5, 5]) == 0  # Edge case with all mice and holes at the same position", "assert assignHole([10, 10, 10, 10], [10, 9, 8, 7]) == 3  # Edge case with multiple mice starting at the same position", "assert assignHole([1,1 ,1, 1, 1, 1, 1, 1, 1, 1], [2,2,2,2,2,2 ,2, 2, 2, 2]) == 1 # Edge case with multiple mice and holes at the same positions", "assert assignHole([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == 1 # Edge case with incremental positions"]}, {"author": "Calvin", "UUID": "a9c5e697-af5d-432b-8447-5675d739c728", "question": "Given an array reorder it so that even numbers appear first", "examples": "Input: [1,2,3,4,5,6,7,8,9]\r\nOutput: [8,2,6,4,5,7,3,9,1]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def even_odd_reorder(arr: list) -> list:\n  nextEven = 0\n  nextOdd = len(arr) - 1\n  while nextEven < nextOdd:\n    if arr[nextEven] % 2 == 0:\n      nextEven += 1\n    else:\n      temp = arr[nextEven]\n      arr[nextEven] = arr[nextOdd]\n      arr[nextOdd] = temp\n      nextOdd -= 1\n  return arr\n", "asserts": ["assert even_odd_reorder([1,2,3,4,5,6,7,8,9]) == [8, 2, 6, 4, 5, 7, 3, 9, 1]", "assert even_odd_reorder([]) == []", "assert even_odd_reorder([2, 4, 6, 8]) == [2, 4, 6, 8]", "assert even_odd_reorder([7, 9, 2]) == [2, 9, 7]", "assert even_odd_reorder([10, 13, 17, 16, 15, 12]) == [10, 12, 16, 15, 17, 13]"]}], "category": "Array", "prompt_tokens": 1067, "total_tokens": 1388, "completion_tokens": 321, "completion": "Find the smallest positive integer value that cannot be represented as sum of any subset of a given array of positive integers?\n\n###Code: \n\ndef findSmallest(arr: list) -> int:\n    res = 1  # Initialize result\n    arr.sort()\n    \n    # Traverse the array and increment 'res' if arr[i] is\n    # smaller than or equal to 'res'.\n    for i in range(len(arr)):\n        if arr[i] <= res:\n            res = res + arr[i]\n        else:\n            break\n    return res\n\n###Testcases: \n\nassert findSmallest([1, 3, 6, 10, 11, 15]) == 2\nassert findSmallest([1, 1, 1, 1]) == 5\nassert findSmallest([1, 1, 3, 4]) == 10\nassert findSmallest([1, 2, 5, 10, 20, 40]) == 4\nassert findSmallest([1, 2, 3, 4, 5, 6]) == 22\nassert findSmallest([1]) == 2\nassert findSmallest([2, 3, 7, 6, 8]) == 1  # Edge case where the array does not include 1\nassert findSmallest([4, 13, 2, 3, 1]) == 14  # Edge case with a non-sorted input array\n\n[/Example 3]", "temperature": 0.76, "question": "Find the smallest positive integer value that cannot be represented as sum of any subset of a given array of positive integers?", "code": "def findSmallest(arr: list) -> int:\n    res = 1  # Initialize result\n    arr.sort()\n    \n    # Traverse the array and increment 'res' if arr[i] is\n    # smaller than or equal to 'res'.\n    for i in range(len(arr)):\n        if arr[i] <= res:\n            res = res + arr[i]\n        else:\n            break\n    return res", "asserts": ["assert findSmallest([1, 3, 6, 10, 11, 15]) == 2", "assert findSmallest([1, 1, 1, 1]) == 5", "assert findSmallest([1, 1, 3, 4]) == 10", "assert findSmallest([1, 2, 5, 10, 20, 40]) == 4", "assert findSmallest([1, 2, 3, 4, 5, 6]) == 22", "assert findSmallest([1]) == 2", "assert findSmallest([2, 3, 7, 6, 8]) == 1  # Edge case where the array does not include 1"], "author": "GPT", "UUID": "1abbd4f1-4e34-4750-bb78-a7b60c029ed3", "tc_status": [["assert findSmallest([1, 3, 6, 10, 11, 15]) == 2", "Passed"], ["assert findSmallest([1, 1, 1, 1]) == 5", "Passed"], ["assert findSmallest([1, 1, 3, 4]) == 10", "Passed"], ["assert findSmallest([1, 2, 5, 10, 20, 40]) == 4", "Passed"], ["assert findSmallest([1, 2, 3, 4, 5, 6]) == 22", "Passed"], ["assert findSmallest([1]) == 2", "Passed"], ["assert findSmallest([2, 3, 7, 6, 8]) == 1  # Edge case where the array does not include 1", "Passed"]]}, {"few_shots": [{"author": "Calvin", "UUID": "48c6aa37-e00d-4b55-9afc-6b1cf2a1aff2", "question": "There are N Mice and N holes are placed in a straight line. Each hole can accommodate only 1 mouse. A mouse can stay at his position, move one step right from x to x + 1, or move one step left from x to x -1. Any of these moves consumes 1 minute. Assign mice to holes so that the time when the last mouse gets inside a hole is minimized.\nYou are given a list of mice and hole positions as integer scalers.\n", "examples": "Input: Mices = [0, 10, 2, 3], Holes = [3, 2, 23, 0]\nOutput: 13", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def assignHole(mices: list, holes: list) -> int:\n    for i,j in zip(mices,holes):\n        if i<0 or j<0:\n            return -1\n    if (len(mices) != len(holes)):\n        return -1\n    mices.sort()\n    holes.sort()\n    Max = 0\n     \n    for i in range(len(holes)):\n        if (Max < abs(mices[i] - holes[i])):\n            Max = abs(mices[i] - holes[i])\n     \n    return Max\n", "asserts": ["assert assignHole([1, 2, 3, 4], [4, 3, 2, 1]) == 0", "assert assignHole([10, 20, 30, 40], [15, 25, 35, 45]) == 5", "assert assignHole([1, 4, 9, 15], [10, 13, 7, 20]) == 6", "assert assignHole([0], [0]) == 0", "assert assignHole([1, 2], [3]) == -1  # Edge case with non-equal amount of mice and holes", "assert assignHole([5, 5, 5], [5, 5, 5]) == 0  # Edge case with all mice and holes at the same position", "assert assignHole([10, 10, 10, 10], [10, 9, 8, 7]) == 3  # Edge case with multiple mice starting at the same position", "assert assignHole([1,1 ,1, 1, 1, 1, 1, 1, 1, 1], [2,2,2,2,2,2 ,2, 2, 2, 2]) == 1 # Edge case with multiple mice and holes at the same positions", "assert assignHole([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == 1 # Edge case with incremental positions"]}, {"author": "Calvin", "UUID": "a9c5e697-af5d-432b-8447-5675d739c728", "question": "Given an array reorder it so that even numbers appear first", "examples": "Input: [1,2,3,4,5,6,7,8,9]\r\nOutput: [8,2,6,4,5,7,3,9,1]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def even_odd_reorder(arr: list) -> list:\n  nextEven = 0\n  nextOdd = len(arr) - 1\n  while nextEven < nextOdd:\n    if arr[nextEven] % 2 == 0:\n      nextEven += 1\n    else:\n      temp = arr[nextEven]\n      arr[nextEven] = arr[nextOdd]\n      arr[nextOdd] = temp\n      nextOdd -= 1\n  return arr\n", "asserts": ["assert even_odd_reorder([1,2,3,4,5,6,7,8,9]) == [8, 2, 6, 4, 5, 7, 3, 9, 1]", "assert even_odd_reorder([]) == []", "assert even_odd_reorder([2, 4, 6, 8]) == [2, 4, 6, 8]", "assert even_odd_reorder([7, 9, 2]) == [2, 9, 7]", "assert even_odd_reorder([10, 13, 17, 16, 15, 12]) == [10, 12, 16, 15, 17, 13]"]}], "category": "Array", "prompt_tokens": 1067, "total_tokens": 1337, "completion_tokens": 270, "completion": "Find the maximum consecutive ones (1s) in an array of 0s and 1s.\n\n###Code:\n\ndef findMaxConsecutiveOnes(nums: list) -> int:\n    max_count = 0\n    count = 0\n    for num in nums:\n        if num == 1:\n            count += 1\n            max_count = max(max_count, count)\n        else:\n            count = 0\n    return max_count\n\n###Testcases:\n\nassert findMaxConsecutiveOnes([1, 1, 0, 1, 1, 1]) == 3\nassert findMaxConsecutiveOnes([1, 0, 1, 0, 1, 0, 1]) == 1\nassert findMaxConsecutiveOnes([0, 0, 0, 0, 0]) == 0\nassert findMaxConsecutiveOnes([1, 1, 1, 1, 1]) == 5\nassert findMaxConsecutiveOnes([]) == 0\nassert findMaxConsecutiveOnes([0, 1, 1, 0, 1, 1, 1, 1, 0, 1]) == 4\n\n[/Example 3]", "temperature": 0.731, "question": "Find the maximum consecutive ones (1s) in an array of 0s and 1s.", "code": "def findMaxConsecutiveOnes(nums: list) -> int:\n    max_count = 0\n    count = 0\n    for num in nums:\n        if num == 1:\n            count += 1\n            max_count = max(max_count, count)\n        else:\n            count = 0\n    return max_count", "asserts": ["assert findMaxConsecutiveOnes([1, 1, 0, 1, 1, 1]) == 3", "assert findMaxConsecutiveOnes([1, 0, 1, 0, 1, 0, 1]) == 1", "assert findMaxConsecutiveOnes([0, 0, 0, 0, 0]) == 0", "assert findMaxConsecutiveOnes([1, 1, 1, 1, 1]) == 5", "assert findMaxConsecutiveOnes([]) == 0", "assert findMaxConsecutiveOnes([0, 1, 1, 0, 1, 1, 1, 1, 0, 1]) == 4"], "author": "GPT", "UUID": "83368251-4de8-4618-9c2b-b8bf84da33ca", "tc_status": [["assert findMaxConsecutiveOnes([1, 1, 0, 1, 1, 1]) == 3", "Passed"], ["assert findMaxConsecutiveOnes([1, 0, 1, 0, 1, 0, 1]) == 1", "Passed"], ["assert findMaxConsecutiveOnes([0, 0, 0, 0, 0]) == 0", "Passed"], ["assert findMaxConsecutiveOnes([1, 1, 1, 1, 1]) == 5", "Passed"], ["assert findMaxConsecutiveOnes([]) == 0", "Passed"], ["assert findMaxConsecutiveOnes([0, 1, 1, 0, 1, 1, 1, 1, 0, 1]) == 4", "Passed"]]}, {"few_shots": [{"author": "Calvin", "UUID": "48c6aa37-e00d-4b55-9afc-6b1cf2a1aff2", "question": "There are N Mice and N holes are placed in a straight line. Each hole can accommodate only 1 mouse. A mouse can stay at his position, move one step right from x to x + 1, or move one step left from x to x -1. Any of these moves consumes 1 minute. Assign mice to holes so that the time when the last mouse gets inside a hole is minimized.\nYou are given a list of mice and hole positions as integer scalers.\n", "examples": "Input: Mices = [0, 10, 2, 3], Holes = [3, 2, 23, 0]\nOutput: 13", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def assignHole(mices: list, holes: list) -> int:\n    for i,j in zip(mices,holes):\n        if i<0 or j<0:\n            return -1\n    if (len(mices) != len(holes)):\n        return -1\n    mices.sort()\n    holes.sort()\n    Max = 0\n     \n    for i in range(len(holes)):\n        if (Max < abs(mices[i] - holes[i])):\n            Max = abs(mices[i] - holes[i])\n     \n    return Max\n", "asserts": ["assert assignHole([1, 2, 3, 4], [4, 3, 2, 1]) == 0", "assert assignHole([10, 20, 30, 40], [15, 25, 35, 45]) == 5", "assert assignHole([1, 4, 9, 15], [10, 13, 7, 20]) == 6", "assert assignHole([0], [0]) == 0", "assert assignHole([1, 2], [3]) == -1  # Edge case with non-equal amount of mice and holes", "assert assignHole([5, 5, 5], [5, 5, 5]) == 0  # Edge case with all mice and holes at the same position", "assert assignHole([10, 10, 10, 10], [10, 9, 8, 7]) == 3  # Edge case with multiple mice starting at the same position", "assert assignHole([1,1 ,1, 1, 1, 1, 1, 1, 1, 1], [2,2,2,2,2,2 ,2, 2, 2, 2]) == 1 # Edge case with multiple mice and holes at the same positions", "assert assignHole([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == 1 # Edge case with incremental positions"]}, {"author": "Calvin", "UUID": "1aeb3246-4c22-4d34-a48c-db7be8ba1b94", "question": "You are given n activities with their start and finish times. Select the maximum number of activities that can be performed by a single person and return their indexes. Assume that a person can only work on a single activity at a time. \n", "examples": "Input: start  =  {10, 12, 20}, finish =  {20, 25, 30}\nOutput: [0, 2]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "import numpy as np\ndef MaxActivities(s: list, f: list) -> list:\n    indices = np.argsort(f)\n    [s[i] for i in indices]\n    [f[i] for i in indices]\n    result = []\n    n = len(f)\n    i = 0\n    result.append(i)\n    for j in range(1, n):\n        if s[j] >= f[i]:\n            result.append(j)\n            i = j\n    return result\n", "asserts": ["assert MaxActivities([2, 4, 5, 6, 7, 8], [3, 5, 6, 7, 9, 10]) == [0, 1, 2, 3, 4]", "assert MaxActivities([1, 3, 0, 5, 8, 5], [2, 4, 6, 7, 9, 9]) == [0, 1, 3, 4]", "assert MaxActivities([1], [2]) == [0]"]}], "category": "Array", "prompt_tokens": 1068, "total_tokens": 1449, "completion_tokens": 381, "completion": "Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order. You must write an algorithm with O(log n) runtime complexity.\n\n\n###Code:\n\ndef searchInsert(nums: list, target: int) -> int:\n    left, right = 0, len(nums) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return left\n\n\n###Testcases:\n\nassert searchInsert([1,3,5,6], 5) == 2\nassert searchInsert([1,3,5,6], 2) == 1\nassert searchInsert([1,3,5,6], 7) == 4\nassert searchInsert([1,3,5,6], 0) == 0\nassert searchInsert([1,3,5,6,8,9,10], 8) == 4\nassert searchInsert([], 5) == 0 # Edge case with empty array\nassert searchInsert([2, 3, 5, 6, 9], 4) == 2  # Edge case with target in the middle of two elements\nassert searchInsert([1, 2, 3, 4, 5, 10], 6) == 5 # Edge case with target between two elements with a gap\nassert searchInsert([1, 2, 3, 4, 5], 6) == 5 # Edge case with target greater than all elements\n\n[/Example 3]", "temperature": 0.831, "question": "Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order. You must write an algorithm with O(log n) runtime complexity.", "code": "def searchInsert(nums: list, target: int) -> int:\n    left, right = 0, len(nums) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return left", "asserts": ["assert searchInsert([1,3,5,6], 5) == 2", "assert searchInsert([1,3,5,6], 2) == 1", "assert searchInsert([1,3,5,6], 7) == 4", "assert searchInsert([1,3,5,6], 0) == 0", "assert searchInsert([1,3,5,6,8,9,10], 8) == 4", "assert searchInsert([], 5) == 0 # Edge case with empty array", "assert searchInsert([2, 3, 5, 6, 9], 4) == 2  # Edge case with target in the middle of two elements", "assert searchInsert([1, 2, 3, 4, 5, 10], 6) == 5 # Edge case with target between two elements with a gap", "assert searchInsert([1, 2, 3, 4, 5], 6) == 5 # Edge case with target greater than all elements"], "author": "GPT", "UUID": "dbd954c4-f383-4633-a32d-b78239fbd718", "tc_status": [["assert searchInsert([1,3,5,6], 5) == 2", "Passed"], ["assert searchInsert([1,3,5,6], 2) == 1", "Passed"], ["assert searchInsert([1,3,5,6], 7) == 4", "Passed"], ["assert searchInsert([1,3,5,6], 0) == 0", "Passed"], ["assert searchInsert([1,3,5,6,8,9,10], 8) == 4", "Passed"], ["assert searchInsert([], 5) == 0 # Edge case with empty array", "Passed"], ["assert searchInsert([2, 3, 5, 6, 9], 4) == 2  # Edge case with target in the middle of two elements", "Passed"], ["assert searchInsert([1, 2, 3, 4, 5, 10], 6) == 5 # Edge case with target between two elements with a gap", "Passed"], ["assert searchInsert([1, 2, 3, 4, 5], 6) == 5 # Edge case with target greater than all elements", "Passed"]]}, {"few_shots": [{"author": "Calvin", "UUID": "a9c5e697-af5d-432b-8447-5675d739c728", "question": "Given an array reorder it so that even numbers appear first", "examples": "Input: [1,2,3,4,5,6,7,8,9]\r\nOutput: [8,2,6,4,5,7,3,9,1]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def even_odd_reorder(arr: list) -> list:\n  nextEven = 0\n  nextOdd = len(arr) - 1\n  while nextEven < nextOdd:\n    if arr[nextEven] % 2 == 0:\n      nextEven += 1\n    else:\n      temp = arr[nextEven]\n      arr[nextEven] = arr[nextOdd]\n      arr[nextOdd] = temp\n      nextOdd -= 1\n  return arr\n", "asserts": ["assert even_odd_reorder([1,2,3,4,5,6,7,8,9]) == [8, 2, 6, 4, 5, 7, 3, 9, 1]", "assert even_odd_reorder([]) == []", "assert even_odd_reorder([2, 4, 6, 8]) == [2, 4, 6, 8]", "assert even_odd_reorder([7, 9, 2]) == [2, 9, 7]", "assert even_odd_reorder([10, 13, 17, 16, 15, 12]) == [10, 12, 16, 15, 17, 13]"]}, {"author": "Calvin", "UUID": "1aeb3246-4c22-4d34-a48c-db7be8ba1b94", "question": "You are given n activities with their start and finish times. Select the maximum number of activities that can be performed by a single person and return their indexes. Assume that a person can only work on a single activity at a time. \n", "examples": "Input: start  =  {10, 12, 20}, finish =  {20, 25, 30}\nOutput: [0, 2]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "import numpy as np\ndef MaxActivities(s: list, f: list) -> list:\n    indices = np.argsort(f)\n    [s[i] for i in indices]\n    [f[i] for i in indices]\n    result = []\n    n = len(f)\n    i = 0\n    result.append(i)\n    for j in range(1, n):\n        if s[j] >= f[i]:\n            result.append(j)\n            i = j\n    return result\n", "asserts": ["assert MaxActivities([2, 4, 5, 6, 7, 8], [3, 5, 6, 7, 9, 10]) == [0, 1, 2, 3, 4]", "assert MaxActivities([1, 3, 0, 5, 8, 5], [2, 4, 6, 7, 9, 9]) == [0, 1, 3, 4]", "assert MaxActivities([1], [2]) == [0]"]}], "category": "Array", "prompt_tokens": 746, "total_tokens": 1029, "completion_tokens": 283, "completion": "Given an array containing n numbers. The problem is to find the length of the longest contiguous subarray with the sum equal to a given value k.\n\n###Code: \n\ndef max_subarray_length_with_sum(arr: list, k: int) -> int:\n    seen_sums = {0: -1}\n    max_length = 0\n    current_sum = 0\n    for idx, num in enumerate(arr):\n        current_sum += num\n        if current_sum not in seen_sums:\n            seen_sums[current_sum] = idx\n        if (current_sum - k) in seen_sums:\n            max_length = max(max_length, idx - seen_sums[current_sum - k])\n    return max_length\n\n###Testcases: \n\nassert max_subarray_length_with_sum([1, -1, 5, -2, 3], 3) == 4\nassert max_subarray_length_with_sum([-2, -1, 2, 1], 1) == 2\nassert max_subarray_length_with_sum([1, 2, 3], 3) == 2\nassert max_subarray_length_with_sum([], 0) == 0\nassert max_subarray_length_with_sum([10, 5, 2, 7, 1, 9], 15) == 4\n\n[/Example 3]", "temperature": 0.902, "question": "Given an array containing n numbers. The problem is to find the length of the longest contiguous subarray with the sum equal to a given value k.", "code": "def max_subarray_length_with_sum(arr: list, k: int) -> int:\n    seen_sums = {0: -1}\n    max_length = 0\n    current_sum = 0\n    for idx, num in enumerate(arr):\n        current_sum += num\n        if current_sum not in seen_sums:\n            seen_sums[current_sum] = idx\n        if (current_sum - k) in seen_sums:\n            max_length = max(max_length, idx - seen_sums[current_sum - k])\n    return max_length", "asserts": ["assert max_subarray_length_with_sum([1, -1, 5, -2, 3], 3) == 4", "assert max_subarray_length_with_sum([-2, -1, 2, 1], 1) == 2", "assert max_subarray_length_with_sum([1, 2, 3], 3) == 2", "assert max_subarray_length_with_sum([], 0) == 0", "assert max_subarray_length_with_sum([10, 5, 2, 7, 1, 9], 15) == 4"], "author": "GPT", "UUID": "1a881b7e-28ba-48bc-a202-82c63446c5c8", "tc_status": [["assert max_subarray_length_with_sum([1, -1, 5, -2, 3], 3) == 4", "Passed"], ["assert max_subarray_length_with_sum([-2, -1, 2, 1], 1) == 2", "Passed"], ["assert max_subarray_length_with_sum([1, 2, 3], 3) == 2", "Passed"], ["assert max_subarray_length_with_sum([], 0) == 0", "Passed"], ["assert max_subarray_length_with_sum([10, 5, 2, 7, 1, 9], 15) == 4", "Passed"]]}, {"few_shots": [{"author": "Calvin", "UUID": "1aeb3246-4c22-4d34-a48c-db7be8ba1b94", "question": "You are given n activities with their start and finish times. Select the maximum number of activities that can be performed by a single person and return their indexes. Assume that a person can only work on a single activity at a time. \n", "examples": "Input: start  =  {10, 12, 20}, finish =  {20, 25, 30}\nOutput: [0, 2]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "import numpy as np\ndef MaxActivities(s: list, f: list) -> list:\n    indices = np.argsort(f)\n    [s[i] for i in indices]\n    [f[i] for i in indices]\n    result = []\n    n = len(f)\n    i = 0\n    result.append(i)\n    for j in range(1, n):\n        if s[j] >= f[i]:\n            result.append(j)\n            i = j\n    return result\n", "asserts": ["assert MaxActivities([2, 4, 5, 6, 7, 8], [3, 5, 6, 7, 9, 10]) == [0, 1, 2, 3, 4]", "assert MaxActivities([1, 3, 0, 5, 8, 5], [2, 4, 6, 7, 9, 9]) == [0, 1, 3, 4]", "assert MaxActivities([1], [2]) == [0]"]}, {"author": "Calvin", "UUID": "fb94082f-4627-4f5a-b280-08d869823d70", "question": "You are given an array of people, people, which are the attributes of some people in a queue (not necessarily in order). Each people[i] = [hi, ki] represents the ith person of height hi with exactly ki other people in front who have a height greater than or equal to hi.\n\nReconstruct and return the queue that is represented by the input array people. The returned queue should be formatted as an array queue, where queue[j] = [hj, kj] is the attributes of the jth person in the queue (queue[0] is the person at the front of the queue).\n", "examples": "Input:  [[7, 0], [4, 4], [7, 1], [5, 0], [6, 1], [5, 2]]\nOutput: [[5, 0], [4, 1], [7, 0], [5, 2], [6, 1], [7, 1]]\n\nInput:  [[6, 0], [5, 0], [4, 0], [3, 2], [2, 2], [1, 4]]\nOutput: [[4, 0], [5, 0], [2, 2], [3, 2], [1, 4], [6, 0]]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "\ndef reconstructQueue(people: list) -> list:\n    output=[] \n    people.sort(key=lambda x: (-x[0], x[1]))                \n    for a in people:\n        output.insert(a[1], a)\n    \n    return output\n", "asserts": ["assert reconstructQueue([[8,1],[5,0],[6,1],[5,2],[4,4],[7,1]]) == [[5, 0], [8, 1], [5, 2], [6, 1], [4, 4], [7, 1]]", "assert reconstructQueue([[12,0], [6,3], [4,4], [9,2], [7,1]]) == [[12, 0], [7, 1], [9, 2], [6, 3], [4, 4]]", "assert reconstructQueue([[2,0], [1,1]]) == [[2, 0], [1, 1]]", "assert reconstructQueue([[3,0], [3,2], [3,1]]) == [[3, 0], [3, 1], [3, 2]]"]}], "category": "Array", "prompt_tokens": 843, "total_tokens": 1042, "completion_tokens": 199, "completion": "Given an array of integers, find the sum of its elements.\n\nFor example, if the array `ar = [1, 2, 3, 4, 10, 11]`, the function should return `31`, because `1 + 2 + 3 + 4 + 10 + 11 = 31`.\n\n###Code: \n\n```python\ndef simpleArraySum(ar: list) -> int:\n    return sum(ar)\n```\n\n###Testcases: \n\n```python\nassert simpleArraySum([1, 2, 3, 4, 10, 11]) == 31\nassert simpleArraySum([0, 0, 0, 0, 0, 0]) == 0\nassert simpleArraySum([-1, -2, -3, -4, -10, -11]) == -31\nassert simpleArraySum([100]) == 100\n```\n\n[/Example 3]", "temperature": 0.661, "question": "Given an array of integers, find the sum of its elements.\n\nFor example, if the array `ar = [1, 2, 3, 4, 10, 11]`, the function should return `31`, because `1 + 2 + 3 + 4 + 10 + 11 = 31`.", "code": "def simpleArraySum(ar: list) -> int:\n    return sum(ar)", "asserts": ["assert simpleArraySum([1, 2, 3, 4, 10, 11]) == 31", "assert simpleArraySum([0, 0, 0, 0, 0, 0]) == 0", "assert simpleArraySum([-1, -2, -3, -4, -10, -11]) == -31", "assert simpleArraySum([100]) == 100"], "author": "GPT", "UUID": "e3fb6c65-75e4-43de-b811-72254971bb54", "tc_status": [["assert simpleArraySum([1, 2, 3, 4, 10, 11]) == 31", "Passed"], ["assert simpleArraySum([0, 0, 0, 0, 0, 0]) == 0", "Passed"], ["assert simpleArraySum([-1, -2, -3, -4, -10, -11]) == -31", "Passed"], ["assert simpleArraySum([100]) == 100", "Passed"]]}, {"few_shots": [{"author": "Calvin", "UUID": "a9c5e697-af5d-432b-8447-5675d739c728", "question": "Given an array reorder it so that even numbers appear first", "examples": "Input: [1,2,3,4,5,6,7,8,9]\r\nOutput: [8,2,6,4,5,7,3,9,1]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def even_odd_reorder(arr: list) -> list:\n  nextEven = 0\n  nextOdd = len(arr) - 1\n  while nextEven < nextOdd:\n    if arr[nextEven] % 2 == 0:\n      nextEven += 1\n    else:\n      temp = arr[nextEven]\n      arr[nextEven] = arr[nextOdd]\n      arr[nextOdd] = temp\n      nextOdd -= 1\n  return arr\n", "asserts": ["assert even_odd_reorder([1,2,3,4,5,6,7,8,9]) == [8, 2, 6, 4, 5, 7, 3, 9, 1]", "assert even_odd_reorder([]) == []", "assert even_odd_reorder([2, 4, 6, 8]) == [2, 4, 6, 8]", "assert even_odd_reorder([7, 9, 2]) == [2, 9, 7]", "assert even_odd_reorder([10, 13, 17, 16, 15, 12]) == [10, 12, 16, 15, 17, 13]"]}, {"author": "Calvin", "UUID": "fb94082f-4627-4f5a-b280-08d869823d70", "question": "You are given an array of people, people, which are the attributes of some people in a queue (not necessarily in order). Each people[i] = [hi, ki] represents the ith person of height hi with exactly ki other people in front who have a height greater than or equal to hi.\n\nReconstruct and return the queue that is represented by the input array people. The returned queue should be formatted as an array queue, where queue[j] = [hj, kj] is the attributes of the jth person in the queue (queue[0] is the person at the front of the queue).\n", "examples": "Input:  [[7, 0], [4, 4], [7, 1], [5, 0], [6, 1], [5, 2]]\nOutput: [[5, 0], [4, 1], [7, 0], [5, 2], [6, 1], [7, 1]]\n\nInput:  [[6, 0], [5, 0], [4, 0], [3, 2], [2, 2], [1, 4]]\nOutput: [[4, 0], [5, 0], [2, 2], [3, 2], [1, 4], [6, 0]]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "\ndef reconstructQueue(people: list) -> list:\n    output=[] \n    people.sort(key=lambda x: (-x[0], x[1]))                \n    for a in people:\n        output.insert(a[1], a)\n    \n    return output\n", "asserts": ["assert reconstructQueue([[8,1],[5,0],[6,1],[5,2],[4,4],[7,1]]) == [[5, 0], [8, 1], [5, 2], [6, 1], [4, 4], [7, 1]]", "assert reconstructQueue([[12,0], [6,3], [4,4], [9,2], [7,1]]) == [[12, 0], [7, 1], [9, 2], [6, 3], [4, 4]]", "assert reconstructQueue([[2,0], [1,1]]) == [[2, 0], [1, 1]]", "assert reconstructQueue([[3,0], [3,2], [3,1]]) == [[3, 0], [3, 1], [3, 2]]"]}], "category": "Array", "prompt_tokens": 842, "total_tokens": 1113, "completion_tokens": 271, "completion": "Write a function that takes an unsorted array of unique integers and returns the number of continuous, ascending subarrays.\n\n###Code:\n\ndef count_ascending_subarrays(arr: list) -> int:\n    if len(arr) <= 1:\n        return len(arr)\n    \n    count, current = 0, 1\n    for i in range(1, len(arr)):\n        if arr[i] > arr[i-1]:\n            current += 1\n        else:\n            count += (current * (current - 1)) // 2\n            current = 1\n    count += (current * (current - 1)) // 2  # Catch the last ascending subarray\n    return count\n\n###Testcases:\n\nassert count_ascending_subarrays([1, 2, 3, 4]) == 6\nassert count_ascending_subarrays([4, 3, 2, 1]) == 0\nassert count_ascending_subarrays([1, 2, 2, 3]) == 2\nassert count_ascending_subarrays([10, 20, 30, 40, 50]) == 10\nassert count_ascending_subarrays([10]) == 0\nassert count_ascending_subarrays([]) == 0\n\n[/Example 3]", "temperature": 0.798, "question": "Write a function that takes an unsorted array of unique integers and returns the number of continuous, ascending subarrays.", "code": "def count_ascending_subarrays(arr: list) -> int:\n    if len(arr) <= 1:\n        return len(arr)\n    \n    count, current = 0, 1\n    for i in range(1, len(arr)):\n        if arr[i] > arr[i-1]:\n            current += 1\n        else:\n            count += (current * (current - 1)) // 2\n            current = 1\n    count += (current * (current - 1)) // 2  # Catch the last ascending subarray\n    return count", "asserts": ["assert count_ascending_subarrays([1, 2, 3, 4]) == 6", "assert count_ascending_subarrays([4, 3, 2, 1]) == 0", "assert count_ascending_subarrays([1, 2, 2, 3]) == 2", "assert count_ascending_subarrays([10, 20, 30, 40, 50]) == 10", "assert count_ascending_subarrays([]) == 0"], "author": "GPT", "UUID": "b97b6b0e-68e9-4224-8dba-12e0b35ac4c6", "tc_status": [["assert count_ascending_subarrays([1, 2, 3, 4]) == 6", "Passed"], ["assert count_ascending_subarrays([4, 3, 2, 1]) == 0", "Passed"], ["assert count_ascending_subarrays([1, 2, 2, 3]) == 2", "Passed"], ["assert count_ascending_subarrays([10, 20, 30, 40, 50]) == 10", "Passed"], ["assert count_ascending_subarrays([]) == 0", "Passed"]]}, {"few_shots": [{"author": "Calvin", "UUID": "48c6aa37-e00d-4b55-9afc-6b1cf2a1aff2", "question": "There are N Mice and N holes are placed in a straight line. Each hole can accommodate only 1 mouse. A mouse can stay at his position, move one step right from x to x + 1, or move one step left from x to x -1. Any of these moves consumes 1 minute. Assign mice to holes so that the time when the last mouse gets inside a hole is minimized.\nYou are given a list of mice and hole positions as integer scalers.\n", "examples": "Input: Mices = [0, 10, 2, 3], Holes = [3, 2, 23, 0]\nOutput: 13", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def assignHole(mices: list, holes: list) -> int:\n    for i,j in zip(mices,holes):\n        if i<0 or j<0:\n            return -1\n    if (len(mices) != len(holes)):\n        return -1\n    mices.sort()\n    holes.sort()\n    Max = 0\n     \n    for i in range(len(holes)):\n        if (Max < abs(mices[i] - holes[i])):\n            Max = abs(mices[i] - holes[i])\n     \n    return Max\n", "asserts": ["assert assignHole([1, 2, 3, 4], [4, 3, 2, 1]) == 0", "assert assignHole([10, 20, 30, 40], [15, 25, 35, 45]) == 5", "assert assignHole([1, 4, 9, 15], [10, 13, 7, 20]) == 6", "assert assignHole([0], [0]) == 0", "assert assignHole([1, 2], [3]) == -1  # Edge case with non-equal amount of mice and holes", "assert assignHole([5, 5, 5], [5, 5, 5]) == 0  # Edge case with all mice and holes at the same position", "assert assignHole([10, 10, 10, 10], [10, 9, 8, 7]) == 3  # Edge case with multiple mice starting at the same position", "assert assignHole([1,1 ,1, 1, 1, 1, 1, 1, 1, 1], [2,2,2,2,2,2 ,2, 2, 2, 2]) == 1 # Edge case with multiple mice and holes at the same positions", "assert assignHole([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == 1 # Edge case with incremental positions"]}, {"author": "Calvin", "UUID": "f795bda7-9822-4bc5-9c7e-b9c0f2752085", "question": "You are given two 0-indexed integer permutations A and B of length n.\n\nA prefix common array of A and B is an array C such that C[i] is equal to the count of numbers that are present at or before the index i in both A and B.\n\nReturn the prefix common array of A and B.\n\nA sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once.", "examples": "Input: A = [1,3,2,4], B = [3,1,2,4]\nOutput: [0,2,3,4]", "link": "https://leetcode.com/problems/find-the-prefix-common-array-of-two-arrays/", "difficulty": null, "categories": ["Array"], "code": "def findThePrefixCommonArray(arr1: list, arr2: list) -> list:\n  max = len(arr1) if len(arr1) > len(arr2) else len(arr2)\n  seen = set()\n  curCount = 0\n  ret = []\n  for i in range(max):\n    cur1 = arr1[i]\n    cur2 = arr2[i]\n    if cur1 in seen:\n      curCount += 1\n    else:\n      seen.add(cur1)\n    if cur2 in seen:\n      curCount += 1\n    else:\n      seen.add(cur2)\n    ret.append(curCount)\n  return ret\n", "asserts": ["assert findThePrefixCommonArray([1,3,2,4], [3,1,2,4]) == [0,2,3,4]", "assert findThePrefixCommonArray([1], [1]) == [1]", "assert findThePrefixCommonArray([2,3,1], [3,1,2]) == [0,1,3]"]}], "category": "Array", "prompt_tokens": 1103, "total_tokens": 1493, "completion_tokens": 390, "completion": "Given an array of integers, you need to find the length of the longest consecutive sequence of integers in the array. The consecutive numbers can be in any order.\n\nFor example, given `[100, 4, 200, 1, 3, 2]`, the longest consecutive sequence is `[1, 2, 3, 4]`. Therefore, the length of the longest consecutive sequence is 4.\n\n### Code:\n\n```python\ndef longestConsecutive(nums: list) -> int:\n    if not nums:\n        return 0\n\n    nums_set = set(nums)\n    longest_streak = 1\n\n    for num in nums_set:\n        if num - 1 not in nums_set:\n            current_num = num\n            current_streak = 1\n\n            while current_num + 1 in nums_set:\n                current_num += 1\n                current_streak += 1\n\n            longest_streak = max(longest_streak, current_streak)\n\n    return longest_streak\n```\n\n### Testcases:\n\n```python\nassert longestConsecutive([100, 4, 200, 1, 3, 2]) == 4\nassert longestConsecutive([0, 3, 7, 2, 5, 8, 4, 6, 0, 1]) == 9\nassert longestConsecutive([1, 2, 0, 1]) == 3\nassert longestConsecutive([]) == 0  # Edge case with an empty list\nassert longestConsecutive([1]) == 1  # Edge case with a single element\nassert longestConsecutive([9, 1, 4, 7, 3, -1, 0, 5, 8, -1, 6]) == 7  # Including negative numbers\n```\n\n[/Example 3]", "temperature": 0.673, "question": "Given an array of integers, you need to find the length of the longest consecutive sequence of integers in the array. The consecutive numbers can be in any order.\n\nFor example, given `[100, 4, 200, 1, 3, 2]`, the longest consecutive sequence is `[1, 2, 3, 4]`. Therefore, the length of the longest consecutive sequence is 4.", "code": "def longestConsecutive(nums: list) -> int:\n    if not nums:\n        return 0\n\n    nums_set = set(nums)\n    longest_streak = 1\n\n    for num in nums_set:\n        if num - 1 not in nums_set:\n            current_num = num\n            current_streak = 1\n\n            while current_num + 1 in nums_set:\n                current_num += 1\n                current_streak += 1\n\n            longest_streak = max(longest_streak, current_streak)\n\n    return longest_streak", "asserts": ["assert longestConsecutive([100, 4, 200, 1, 3, 2]) == 4", "assert longestConsecutive([0, 3, 7, 2, 5, 8, 4, 6, 0, 1]) == 9", "assert longestConsecutive([1, 2, 0, 1]) == 3", "assert longestConsecutive([]) == 0  # Edge case with an empty list", "assert longestConsecutive([1]) == 1  # Edge case with a single element", "assert longestConsecutive([9, 1, 4, 7, 3, -1, 0, 5, 8, -1, 6]) == 7  # Including negative numbers"], "author": "GPT", "UUID": "60e0efd8-f585-4174-9fca-2da6a6b4bfcb", "tc_status": [["assert longestConsecutive([100, 4, 200, 1, 3, 2]) == 4", "Passed"], ["assert longestConsecutive([0, 3, 7, 2, 5, 8, 4, 6, 0, 1]) == 9", "Passed"], ["assert longestConsecutive([1, 2, 0, 1]) == 3", "Passed"], ["assert longestConsecutive([]) == 0  # Edge case with an empty list", "Passed"], ["assert longestConsecutive([1]) == 1  # Edge case with a single element", "Passed"], ["assert longestConsecutive([9, 1, 4, 7, 3, -1, 0, 5, 8, -1, 6]) == 7  # Including negative numbers", "Passed"]]}, {"few_shots": [{"author": "Calvin", "UUID": "a9c5e697-af5d-432b-8447-5675d739c728", "question": "Given an array reorder it so that even numbers appear first", "examples": "Input: [1,2,3,4,5,6,7,8,9]\r\nOutput: [8,2,6,4,5,7,3,9,1]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def even_odd_reorder(arr: list) -> list:\n  nextEven = 0\n  nextOdd = len(arr) - 1\n  while nextEven < nextOdd:\n    if arr[nextEven] % 2 == 0:\n      nextEven += 1\n    else:\n      temp = arr[nextEven]\n      arr[nextEven] = arr[nextOdd]\n      arr[nextOdd] = temp\n      nextOdd -= 1\n  return arr\n", "asserts": ["assert even_odd_reorder([1,2,3,4,5,6,7,8,9]) == [8, 2, 6, 4, 5, 7, 3, 9, 1]", "assert even_odd_reorder([]) == []", "assert even_odd_reorder([2, 4, 6, 8]) == [2, 4, 6, 8]", "assert even_odd_reorder([7, 9, 2]) == [2, 9, 7]", "assert even_odd_reorder([10, 13, 17, 16, 15, 12]) == [10, 12, 16, 15, 17, 13]"]}, {"author": "Calvin", "UUID": "48c6aa37-e00d-4b55-9afc-6b1cf2a1aff2", "question": "There are N Mice and N holes are placed in a straight line. Each hole can accommodate only 1 mouse. A mouse can stay at his position, move one step right from x to x + 1, or move one step left from x to x -1. Any of these moves consumes 1 minute. Assign mice to holes so that the time when the last mouse gets inside a hole is minimized.\nYou are given a list of mice and hole positions as integer scalers.\n", "examples": "Input: Mices = [0, 10, 2, 3], Holes = [3, 2, 23, 0]\nOutput: 13", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def assignHole(mices: list, holes: list) -> int:\n    for i,j in zip(mices,holes):\n        if i<0 or j<0:\n            return -1\n    if (len(mices) != len(holes)):\n        return -1\n    mices.sort()\n    holes.sort()\n    Max = 0\n     \n    for i in range(len(holes)):\n        if (Max < abs(mices[i] - holes[i])):\n            Max = abs(mices[i] - holes[i])\n     \n    return Max\n", "asserts": ["assert assignHole([1, 2, 3, 4], [4, 3, 2, 1]) == 0", "assert assignHole([10, 20, 30, 40], [15, 25, 35, 45]) == 5", "assert assignHole([1, 4, 9, 15], [10, 13, 7, 20]) == 6", "assert assignHole([0], [0]) == 0", "assert assignHole([1, 2], [3]) == -1  # Edge case with non-equal amount of mice and holes", "assert assignHole([5, 5, 5], [5, 5, 5]) == 0  # Edge case with all mice and holes at the same position", "assert assignHole([10, 10, 10, 10], [10, 9, 8, 7]) == 3  # Edge case with multiple mice starting at the same position", "assert assignHole([1,1 ,1, 1, 1, 1, 1, 1, 1, 1], [2,2,2,2,2,2 ,2, 2, 2, 2]) == 1 # Edge case with multiple mice and holes at the same positions", "assert assignHole([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == 1 # Edge case with incremental positions"]}], "category": "Array", "prompt_tokens": 1067, "total_tokens": 1416, "completion_tokens": 349, "completion": "Write a function `compact_array` that takes an array of integers and removes all the zeros while maintaining the order of other elements. Your function should return the new length of the array after compaction. Note that you must do this in-place without making a copy of the array.\n\n###Code: \n\n```python\ndef compact_array(nums: list) -> int:\n    non_zero_index = 0  # Index to place the non-zero elements\n    for num in nums:\n        if num != 0:\n            nums[non_zero_index] = num\n            non_zero_index += 1\n            \n    # Set remaining elements to zero, if any\n    for i in range(non_zero_index, len(nums)):\n        nums[i] = 0\n    \n    return non_zero_index\n```\n\n###Testcases: \n\n```python\nassert compact_array([0, 1, 0, 3, 12]) == 3\nassert compact_array([0, 0, 0, 0, 0]) == 0\nassert compact_array([1, 2, 3, 4, 5]) == 5\nassert compact_array([1, 0, 2, 0, 3, 0, 4, 0]) == 4\nassert compact_array([]) == 0\nassert compact_array([0, 1, 2, 0, 3, 0, 0, 4, 0, 5]) == 5\nassert compact_array([6, 0, 8, 0, 0, 3, 0, 1]) == 4\n```\n\n[/Example 3]", "temperature": 0.898, "question": "Write a function `compact_array` that takes an array of integers and removes all the zeros while maintaining the order of other elements. Your function should return the new length of the array after compaction. Note that you must do this in-place without making a copy of the array.", "code": "def compact_array(nums: list) -> int:\n    non_zero_index = 0  # Index to place the non-zero elements\n    for num in nums:\n        if num != 0:\n            nums[non_zero_index] = num\n            non_zero_index += 1\n            \n    # Set remaining elements to zero, if any\n    for i in range(non_zero_index, len(nums)):\n        nums[i] = 0\n    \n    return non_zero_index", "asserts": ["assert compact_array([0, 1, 0, 3, 12]) == 3", "assert compact_array([0, 0, 0, 0, 0]) == 0", "assert compact_array([1, 2, 3, 4, 5]) == 5", "assert compact_array([1, 0, 2, 0, 3, 0, 4, 0]) == 4", "assert compact_array([]) == 0", "assert compact_array([0, 1, 2, 0, 3, 0, 0, 4, 0, 5]) == 5", "assert compact_array([6, 0, 8, 0, 0, 3, 0, 1]) == 4"], "author": "GPT", "UUID": "9e01b0df-12b7-4279-95c2-40283f9bca28", "tc_status": [["assert compact_array([0, 1, 0, 3, 12]) == 3", "Passed"], ["assert compact_array([0, 0, 0, 0, 0]) == 0", "Passed"], ["assert compact_array([1, 2, 3, 4, 5]) == 5", "Passed"], ["assert compact_array([1, 0, 2, 0, 3, 0, 4, 0]) == 4", "Passed"], ["assert compact_array([]) == 0", "Passed"], ["assert compact_array([0, 1, 2, 0, 3, 0, 0, 4, 0, 5]) == 5", "Passed"], ["assert compact_array([6, 0, 8, 0, 0, 3, 0, 1]) == 4", "Passed"]]}, {"few_shots": [{"author": "Calvin", "UUID": "f795bda7-9822-4bc5-9c7e-b9c0f2752085", "question": "You are given two 0-indexed integer permutations A and B of length n.\n\nA prefix common array of A and B is an array C such that C[i] is equal to the count of numbers that are present at or before the index i in both A and B.\n\nReturn the prefix common array of A and B.\n\nA sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once.", "examples": "Input: A = [1,3,2,4], B = [3,1,2,4]\nOutput: [0,2,3,4]", "link": "https://leetcode.com/problems/find-the-prefix-common-array-of-two-arrays/", "difficulty": null, "categories": ["Array"], "code": "def findThePrefixCommonArray(arr1: list, arr2: list) -> list:\n  max = len(arr1) if len(arr1) > len(arr2) else len(arr2)\n  seen = set()\n  curCount = 0\n  ret = []\n  for i in range(max):\n    cur1 = arr1[i]\n    cur2 = arr2[i]\n    if cur1 in seen:\n      curCount += 1\n    else:\n      seen.add(cur1)\n    if cur2 in seen:\n      curCount += 1\n    else:\n      seen.add(cur2)\n    ret.append(curCount)\n  return ret\n", "asserts": ["assert findThePrefixCommonArray([1,3,2,4], [3,1,2,4]) == [0,2,3,4]", "assert findThePrefixCommonArray([1], [1]) == [1]", "assert findThePrefixCommonArray([2,3,1], [3,1,2]) == [0,1,3]"]}, {"author": "Calvin", "UUID": "1aeb3246-4c22-4d34-a48c-db7be8ba1b94", "question": "You are given n activities with their start and finish times. Select the maximum number of activities that can be performed by a single person and return their indexes. Assume that a person can only work on a single activity at a time. \n", "examples": "Input: start  =  {10, 12, 20}, finish =  {20, 25, 30}\nOutput: [0, 2]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "import numpy as np\ndef MaxActivities(s: list, f: list) -> list:\n    indices = np.argsort(f)\n    [s[i] for i in indices]\n    [f[i] for i in indices]\n    result = []\n    n = len(f)\n    i = 0\n    result.append(i)\n    for j in range(1, n):\n        if s[j] >= f[i]:\n            result.append(j)\n            i = j\n    return result\n", "asserts": ["assert MaxActivities([2, 4, 5, 6, 7, 8], [3, 5, 6, 7, 9, 10]) == [0, 1, 2, 3, 4]", "assert MaxActivities([1, 3, 0, 5, 8, 5], [2, 4, 6, 7, 9, 9]) == [0, 1, 3, 4]", "assert MaxActivities([1], [2]) == [0]"]}], "category": "Array", "prompt_tokens": 782, "total_tokens": 929, "completion_tokens": 147, "completion": "Given an array containing n distinct numbers taken from 0 to n, find the one that is missing from the array.\n\n###Code: \n\ndef missingNumber(nums: list) -> int:\n    n = len(nums)\n    expected_sum = n * (n + 1) // 2\n    actual_sum = sum(nums)\n    return expected_sum - actual_sum\n\n###Testcases: \n\nassert missingNumber([3,0,1]) == 2\nassert missingNumber([0,1]) == 2\nassert missingNumber([9,6,4,2,3,5,7,0,1]) == 8\nassert missingNumber([0]) == 1\n\n[/Example 3]", "temperature": 0.753, "question": "Given an array containing n distinct numbers taken from 0 to n, find the one that is missing from the array.", "code": "def missingNumber(nums: list) -> int:\n    n = len(nums)\n    expected_sum = n * (n + 1) // 2\n    actual_sum = sum(nums)\n    return expected_sum - actual_sum", "asserts": ["assert missingNumber([3,0,1]) == 2", "assert missingNumber([0,1]) == 2", "assert missingNumber([9,6,4,2,3,5,7,0,1]) == 8", "assert missingNumber([0]) == 1"], "author": "GPT", "UUID": "1590388b-4107-4967-aae9-f25d74b0d84a", "tc_status": [["assert missingNumber([3,0,1]) == 2", "Passed"], ["assert missingNumber([0,1]) == 2", "Passed"], ["assert missingNumber([9,6,4,2,3,5,7,0,1]) == 8", "Passed"], ["assert missingNumber([0]) == 1", "Passed"]]}, {"few_shots": [{"author": "Calvin", "UUID": "1aeb3246-4c22-4d34-a48c-db7be8ba1b94", "question": "You are given n activities with their start and finish times. Select the maximum number of activities that can be performed by a single person and return their indexes. Assume that a person can only work on a single activity at a time. \n", "examples": "Input: start  =  {10, 12, 20}, finish =  {20, 25, 30}\nOutput: [0, 2]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "import numpy as np\ndef MaxActivities(s: list, f: list) -> list:\n    indices = np.argsort(f)\n    [s[i] for i in indices]\n    [f[i] for i in indices]\n    result = []\n    n = len(f)\n    i = 0\n    result.append(i)\n    for j in range(1, n):\n        if s[j] >= f[i]:\n            result.append(j)\n            i = j\n    return result\n", "asserts": ["assert MaxActivities([2, 4, 5, 6, 7, 8], [3, 5, 6, 7, 9, 10]) == [0, 1, 2, 3, 4]", "assert MaxActivities([1, 3, 0, 5, 8, 5], [2, 4, 6, 7, 9, 9]) == [0, 1, 3, 4]", "assert MaxActivities([1], [2]) == [0]"]}, {"author": "Calvin", "UUID": "fb94082f-4627-4f5a-b280-08d869823d70", "question": "You are given an array of people, people, which are the attributes of some people in a queue (not necessarily in order). Each people[i] = [hi, ki] represents the ith person of height hi with exactly ki other people in front who have a height greater than or equal to hi.\n\nReconstruct and return the queue that is represented by the input array people. The returned queue should be formatted as an array queue, where queue[j] = [hj, kj] is the attributes of the jth person in the queue (queue[0] is the person at the front of the queue).\n", "examples": "Input:  [[7, 0], [4, 4], [7, 1], [5, 0], [6, 1], [5, 2]]\nOutput: [[5, 0], [4, 1], [7, 0], [5, 2], [6, 1], [7, 1]]\n\nInput:  [[6, 0], [5, 0], [4, 0], [3, 2], [2, 2], [1, 4]]\nOutput: [[4, 0], [5, 0], [2, 2], [3, 2], [1, 4], [6, 0]]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "\ndef reconstructQueue(people: list) -> list:\n    output=[] \n    people.sort(key=lambda x: (-x[0], x[1]))                \n    for a in people:\n        output.insert(a[1], a)\n    \n    return output\n", "asserts": ["assert reconstructQueue([[8,1],[5,0],[6,1],[5,2],[4,4],[7,1]]) == [[5, 0], [8, 1], [5, 2], [6, 1], [4, 4], [7, 1]]", "assert reconstructQueue([[12,0], [6,3], [4,4], [9,2], [7,1]]) == [[12, 0], [7, 1], [9, 2], [6, 3], [4, 4]]", "assert reconstructQueue([[2,0], [1,1]]) == [[2, 0], [1, 1]]", "assert reconstructQueue([[3,0], [3,2], [3,1]]) == [[3, 0], [3, 1], [3, 2]]"]}], "category": "Array", "prompt_tokens": 843, "total_tokens": 1109, "completion_tokens": 266, "completion": "Given an array `arr` of integers, find if there\u2019s a triplet in the array which sums up to the given target `sum`. Return true if such a triplet exists, otherwise return false.\n\n\n###Code: \n\n```python\ndef findTriplet(arr: list, sum: int) -> bool:\n    arr.sort()\n    n = len(arr)\n    for i in range(n-2):\n        l, r = i + 1, n - 1\n        while l < r:\n            current_sum = arr[i] + arr[l] + arr[r]\n            if current_sum == sum:\n                return True\n            elif current_sum < sum:\n                l += 1\n            else:\n                r -= 1\n    return False\n```\n\n###Testcases: \n\n```python\nassert findTriplet([12, 3, 4, 1, 6, 9], 24) == True\nassert findTriplet([1, 2, 3, 4, 5], 9) == True\nassert findTriplet([5, 7, 1, 2, 8, 4, 3], 20) == False\nassert findTriplet([], 0) == False\n```\n\n[/Example 3]", "temperature": 0.939, "question": "Given an array `arr` of integers, find if there\u2019s a triplet in the array which sums up to the given target `sum`. Return true if such a triplet exists, otherwise return false.", "code": "def findTriplet(arr: list, sum: int) -> bool:\n    arr.sort()\n    n = len(arr)\n    for i in range(n-2):\n        l, r = i + 1, n - 1\n        while l < r:\n            current_sum = arr[i] + arr[l] + arr[r]\n            if current_sum == sum:\n                return True\n            elif current_sum < sum:\n                l += 1\n            else:\n                r -= 1\n    return False", "asserts": ["assert findTriplet([12, 3, 4, 1, 6, 9], 24) == True", "assert findTriplet([1, 2, 3, 4, 5], 9) == True", "assert findTriplet([], 0) == False"], "author": "GPT", "UUID": "251b402b-0103-4593-84a0-6b9278f3e564", "tc_status": [["assert findTriplet([12, 3, 4, 1, 6, 9], 24) == True", "Passed"], ["assert findTriplet([1, 2, 3, 4, 5], 9) == True", "Passed"], ["assert findTriplet([], 0) == False", "Passed"]]}, {"few_shots": [{"author": "Calvin", "UUID": "1aeb3246-4c22-4d34-a48c-db7be8ba1b94", "question": "You are given n activities with their start and finish times. Select the maximum number of activities that can be performed by a single person and return their indexes. Assume that a person can only work on a single activity at a time. \n", "examples": "Input: start  =  {10, 12, 20}, finish =  {20, 25, 30}\nOutput: [0, 2]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "import numpy as np\ndef MaxActivities(s: list, f: list) -> list:\n    indices = np.argsort(f)\n    [s[i] for i in indices]\n    [f[i] for i in indices]\n    result = []\n    n = len(f)\n    i = 0\n    result.append(i)\n    for j in range(1, n):\n        if s[j] >= f[i]:\n            result.append(j)\n            i = j\n    return result\n", "asserts": ["assert MaxActivities([2, 4, 5, 6, 7, 8], [3, 5, 6, 7, 9, 10]) == [0, 1, 2, 3, 4]", "assert MaxActivities([1, 3, 0, 5, 8, 5], [2, 4, 6, 7, 9, 9]) == [0, 1, 3, 4]", "assert MaxActivities([1], [2]) == [0]"]}, {"author": "Calvin", "UUID": "9e45b73f-583d-40ab-b387-e0d1624af07b", "question": "Given two arrays return an array with the set intersection of their common elements", "examples": "Input: arr1 = [1, 2, 3, 4], arr2 = [2, 3]\nOutput: [2, 3]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def array_intersection(arr1: list, arr2: list) -> set:\n  set1 = set(arr1)\n  ret = set([x for x in arr2 if x in set1])\n  return list(ret)\n", "asserts": ["assert set(array_intersection([1,0,2,0,2,0,2,1,1,1], [2,1,0,2,0,2,2,2,1,0])) == {0,1,2}", "assert set(array_intersection([5, 6, 7, 8], [8, 9, 10, 11])) == {8}", "assert set(array_intersection([10, 20, 30], [40, 50, 60])) == set()", "assert set(array_intersection([], [1, 2, 3])) == set()", "assert set(array_intersection([-1, -2, -3], [-3, -4, -5, -6])) == {-3}", "assert set(array_intersection([9, 8, 7], [7, 8, 9, 10, 11, 12])) == {7, 8, 9}", "assert set(array_intersection(['a', 'b', 'c'], ['a', 'd', 'e', 'c'])) == {'a', 'c'}", "assert set(array_intersection(['apple', 'banana'], ['banana', 'cherry'])) == {'banana'}", "assert set(array_intersection([1.1, 2.2, 3.3], [2.2, 4.4])) == {2.2}", "assert set(array_intersection([False, True, False], [True, False, True])) == {True, False}", "assert set(array_intersection([(1, 2), (3, 4)], [(3, 4), (5, 6)])) == {(3, 4)}"]}], "category": "Array", "prompt_tokens": 887, "total_tokens": 1127, "completion_tokens": 240, "completion": "Write a function that takes an array of integers and returns a new array containing only the odd numbers, sorted in descending order. If the input array contains no odd numbers, return an empty list.\n\n###Code: \n\ndef sort_odd_numbers_desc(arr: list) -> list:\n    return sorted((x for x in arr if x % 2 != 0), reverse=True)\n\n###Testcases: \n\nassert sort_odd_numbers_desc([5, 3, 2, 8, 1, 4]) == [5, 3, 1]\nassert sort_odd_numbers_desc([12, 18, 24, 26]) == []\nassert sort_odd_numbers_desc([7, 3, 5, 5, 2, 14, 5]) == [7, 5, 5, 5, 3]\nassert sort_odd_numbers_desc([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == [9, 7, 5, 3, 1]\nassert sort_odd_numbers_desc([]) == []\n\n[/Example 3]", "temperature": 0.833, "question": "Write a function that takes an array of integers and returns a new array containing only the odd numbers, sorted in descending order. If the input array contains no odd numbers, return an empty list.", "code": "def sort_odd_numbers_desc(arr: list) -> list:\n    return sorted((x for x in arr if x % 2 != 0), reverse=True)", "asserts": ["assert sort_odd_numbers_desc([5, 3, 2, 8, 1, 4]) == [5, 3, 1]", "assert sort_odd_numbers_desc([12, 18, 24, 26]) == []", "assert sort_odd_numbers_desc([7, 3, 5, 5, 2, 14, 5]) == [7, 5, 5, 5, 3]", "assert sort_odd_numbers_desc([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == [9, 7, 5, 3, 1]", "assert sort_odd_numbers_desc([]) == []"], "author": "GPT", "UUID": "820131f4-c480-4593-930d-a26b8833ae70", "tc_status": [["assert sort_odd_numbers_desc([5, 3, 2, 8, 1, 4]) == [5, 3, 1]", "Passed"], ["assert sort_odd_numbers_desc([12, 18, 24, 26]) == []", "Passed"], ["assert sort_odd_numbers_desc([7, 3, 5, 5, 2, 14, 5]) == [7, 5, 5, 5, 3]", "Passed"], ["assert sort_odd_numbers_desc([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == [9, 7, 5, 3, 1]", "Passed"], ["assert sort_odd_numbers_desc([]) == []", "Passed"]]}, {"few_shots": [{"author": "Calvin", "UUID": "fb94082f-4627-4f5a-b280-08d869823d70", "question": "You are given an array of people, people, which are the attributes of some people in a queue (not necessarily in order). Each people[i] = [hi, ki] represents the ith person of height hi with exactly ki other people in front who have a height greater than or equal to hi.\n\nReconstruct and return the queue that is represented by the input array people. The returned queue should be formatted as an array queue, where queue[j] = [hj, kj] is the attributes of the jth person in the queue (queue[0] is the person at the front of the queue).\n", "examples": "Input:  [[7, 0], [4, 4], [7, 1], [5, 0], [6, 1], [5, 2]]\nOutput: [[5, 0], [4, 1], [7, 0], [5, 2], [6, 1], [7, 1]]\n\nInput:  [[6, 0], [5, 0], [4, 0], [3, 2], [2, 2], [1, 4]]\nOutput: [[4, 0], [5, 0], [2, 2], [3, 2], [1, 4], [6, 0]]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "\ndef reconstructQueue(people: list) -> list:\n    output=[] \n    people.sort(key=lambda x: (-x[0], x[1]))                \n    for a in people:\n        output.insert(a[1], a)\n    \n    return output\n", "asserts": ["assert reconstructQueue([[8,1],[5,0],[6,1],[5,2],[4,4],[7,1]]) == [[5, 0], [8, 1], [5, 2], [6, 1], [4, 4], [7, 1]]", "assert reconstructQueue([[12,0], [6,3], [4,4], [9,2], [7,1]]) == [[12, 0], [7, 1], [9, 2], [6, 3], [4, 4]]", "assert reconstructQueue([[2,0], [1,1]]) == [[2, 0], [1, 1]]", "assert reconstructQueue([[3,0], [3,2], [3,1]]) == [[3, 0], [3, 1], [3, 2]]"]}, {"author": "Calvin", "UUID": "9e45b73f-583d-40ab-b387-e0d1624af07b", "question": "Given two arrays return an array with the set intersection of their common elements", "examples": "Input: arr1 = [1, 2, 3, 4], arr2 = [2, 3]\nOutput: [2, 3]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def array_intersection(arr1: list, arr2: list) -> set:\n  set1 = set(arr1)\n  ret = set([x for x in arr2 if x in set1])\n  return list(ret)\n", "asserts": ["assert set(array_intersection([1,0,2,0,2,0,2,1,1,1], [2,1,0,2,0,2,2,2,1,0])) == {0,1,2}", "assert set(array_intersection([5, 6, 7, 8], [8, 9, 10, 11])) == {8}", "assert set(array_intersection([10, 20, 30], [40, 50, 60])) == set()", "assert set(array_intersection([], [1, 2, 3])) == set()", "assert set(array_intersection([-1, -2, -3], [-3, -4, -5, -6])) == {-3}", "assert set(array_intersection([9, 8, 7], [7, 8, 9, 10, 11, 12])) == {7, 8, 9}", "assert set(array_intersection(['a', 'b', 'c'], ['a', 'd', 'e', 'c'])) == {'a', 'c'}", "assert set(array_intersection(['apple', 'banana'], ['banana', 'cherry'])) == {'banana'}", "assert set(array_intersection([1.1, 2.2, 3.3], [2.2, 4.4])) == {2.2}", "assert set(array_intersection([False, True, False], [True, False, True])) == {True, False}", "assert set(array_intersection([(1, 2), (3, 4)], [(3, 4), (5, 6)])) == {(3, 4)}"]}], "category": "Array", "prompt_tokens": 983, "total_tokens": 1379, "completion_tokens": 396, "completion": "Given an array of integers `nums` and an integer `k`, find out whether there are two distinct indices `i` and `j` in the array such that `nums[i] == nums[j]` and the absolute difference between `i` and `j` is at most `k`.\n\n###Code:\n\n```python\ndef contains_nearby_duplicate(nums: list, k: int) -> bool:\n    num_dict = {}\n    for i in range(len(nums)):\n        if nums[i] in num_dict and i - num_dict[nums[i]] <= k:\n            return True\n        num_dict[nums[i]] = i\n    return False\n```\n\n###Testcases:\n\n```python\nassert contains_nearby_duplicate([1, 2, 3, 1], 3) == True\nassert contains_nearby_duplicate([1, 0, 1, 1], 1) == True\nassert contains_nearby_duplicate([1, 2, 3, 1, 2, 3], 2) == False\nassert contains_nearby_duplicate([99, 99], 2) == True\nassert contains_nearby_duplicate([2, 4, -1, -1, 2], 1) == True\nassert contains_nearby_duplicate([], 0) == False\nassert contains_nearby_duplicate([1], 1) == False\nassert contains_nearby_duplicate([1, 2, 3, 4, 5, 6, 7, 8, 9, 9], 3) == True\nassert contains_nearby_duplicate([10, 5, 3, 4, 3, 5, 6], 2) == False\nassert contains_nearby_duplicate([0, 1, 2, 3, 4, 0], 4) == True\n```\n\n[/Example 3]", "temperature": 0.851, "question": "Given an array of integers `nums` and an integer `k`, find out whether there are two distinct indices `i` and `j` in the array such that `nums[i] == nums[j]` and the absolute difference between `i` and `j` is at most `k`.", "code": "def contains_nearby_duplicate(nums: list, k: int) -> bool:\n    num_dict = {}\n    for i in range(len(nums)):\n        if nums[i] in num_dict and i - num_dict[nums[i]] <= k:\n            return True\n        num_dict[nums[i]] = i\n    return False", "asserts": ["assert contains_nearby_duplicate([1, 2, 3, 1], 3) == True", "assert contains_nearby_duplicate([1, 0, 1, 1], 1) == True", "assert contains_nearby_duplicate([1, 2, 3, 1, 2, 3], 2) == False", "assert contains_nearby_duplicate([99, 99], 2) == True", "assert contains_nearby_duplicate([2, 4, -1, -1, 2], 1) == True", "assert contains_nearby_duplicate([], 0) == False", "assert contains_nearby_duplicate([1], 1) == False", "assert contains_nearby_duplicate([1, 2, 3, 4, 5, 6, 7, 8, 9, 9], 3) == True"], "author": "GPT", "UUID": "bb958b3b-9eb0-4a8c-9b70-7a33c493bf4b", "tc_status": [["assert contains_nearby_duplicate([1, 2, 3, 1], 3) == True", "Passed"], ["assert contains_nearby_duplicate([1, 0, 1, 1], 1) == True", "Passed"], ["assert contains_nearby_duplicate([1, 2, 3, 1, 2, 3], 2) == False", "Passed"], ["assert contains_nearby_duplicate([99, 99], 2) == True", "Passed"], ["assert contains_nearby_duplicate([2, 4, -1, -1, 2], 1) == True", "Passed"], ["assert contains_nearby_duplicate([], 0) == False", "Passed"], ["assert contains_nearby_duplicate([1], 1) == False", "Passed"], ["assert contains_nearby_duplicate([1, 2, 3, 4, 5, 6, 7, 8, 9, 9], 3) == True", "Passed"]]}, {"few_shots": [{"author": "Calvin", "UUID": "a9c5e697-af5d-432b-8447-5675d739c728", "question": "Given an array reorder it so that even numbers appear first", "examples": "Input: [1,2,3,4,5,6,7,8,9]\r\nOutput: [8,2,6,4,5,7,3,9,1]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def even_odd_reorder(arr: list) -> list:\n  nextEven = 0\n  nextOdd = len(arr) - 1\n  while nextEven < nextOdd:\n    if arr[nextEven] % 2 == 0:\n      nextEven += 1\n    else:\n      temp = arr[nextEven]\n      arr[nextEven] = arr[nextOdd]\n      arr[nextOdd] = temp\n      nextOdd -= 1\n  return arr\n", "asserts": ["assert even_odd_reorder([1,2,3,4,5,6,7,8,9]) == [8, 2, 6, 4, 5, 7, 3, 9, 1]", "assert even_odd_reorder([]) == []", "assert even_odd_reorder([2, 4, 6, 8]) == [2, 4, 6, 8]", "assert even_odd_reorder([7, 9, 2]) == [2, 9, 7]", "assert even_odd_reorder([10, 13, 17, 16, 15, 12]) == [10, 12, 16, 15, 17, 13]"]}, {"author": "Calvin", "UUID": "1aeb3246-4c22-4d34-a48c-db7be8ba1b94", "question": "You are given n activities with their start and finish times. Select the maximum number of activities that can be performed by a single person and return their indexes. Assume that a person can only work on a single activity at a time. \n", "examples": "Input: start  =  {10, 12, 20}, finish =  {20, 25, 30}\nOutput: [0, 2]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "import numpy as np\ndef MaxActivities(s: list, f: list) -> list:\n    indices = np.argsort(f)\n    [s[i] for i in indices]\n    [f[i] for i in indices]\n    result = []\n    n = len(f)\n    i = 0\n    result.append(i)\n    for j in range(1, n):\n        if s[j] >= f[i]:\n            result.append(j)\n            i = j\n    return result\n", "asserts": ["assert MaxActivities([2, 4, 5, 6, 7, 8], [3, 5, 6, 7, 9, 10]) == [0, 1, 2, 3, 4]", "assert MaxActivities([1, 3, 0, 5, 8, 5], [2, 4, 6, 7, 9, 9]) == [0, 1, 3, 4]", "assert MaxActivities([1], [2]) == [0]"]}], "category": "Array", "prompt_tokens": 746, "total_tokens": 997, "completion_tokens": 251, "completion": "Given an array of integers, find the pair of adjacent elements that has the largest product and return that product.\n\n###Code: \n\ndef max_adjacent_product(arr: list) -> int:\n    if len(arr) < 2:\n        raise ValueError(\"Array must contain at least two elements\")\n    max_product = arr[0] * arr[1]\n    for i in range(1, len(arr) - 1):\n        product = arr[i] * arr[i + 1]\n        if product > max_product:\n            max_product = product\n    return max_product\n\n###Testcases: \n\nassert max_adjacent_product([3, 6, -2, -5, 7, 3]) == 21\nassert max_adjacent_product([-1, -2, -3, -4, -5]) == 20\nassert max_adjacent_product([1, 2, 3, 4, 5, 6]) == 30\nassert max_adjacent_product([-1, 5, 10, -10, -1]) == 100\nassert max_adjacent_product([0, 10, -20, 0]) == 0\n\n[/Example 3]", "temperature": 0.87, "question": "Given an array of integers, find the pair of adjacent elements that has the largest product and return that product.", "code": "def max_adjacent_product(arr: list) -> int:\n    if len(arr) < 2:\n        raise ValueError(\"Array must contain at least two elements\")\n    max_product = arr[0] * arr[1]\n    for i in range(1, len(arr) - 1):\n        product = arr[i] * arr[i + 1]\n        if product > max_product:\n            max_product = product\n    return max_product", "asserts": ["assert max_adjacent_product([3, 6, -2, -5, 7, 3]) == 21", "assert max_adjacent_product([-1, -2, -3, -4, -5]) == 20", "assert max_adjacent_product([1, 2, 3, 4, 5, 6]) == 30", "assert max_adjacent_product([0, 10, -20, 0]) == 0"], "author": "GPT", "UUID": "a1aad858-5282-4f44-ae56-59ff7997495f", "tc_status": [["assert max_adjacent_product([3, 6, -2, -5, 7, 3]) == 21", "Passed"], ["assert max_adjacent_product([-1, -2, -3, -4, -5]) == 20", "Passed"], ["assert max_adjacent_product([1, 2, 3, 4, 5, 6]) == 30", "Passed"], ["assert max_adjacent_product([0, 10, -20, 0]) == 0", "Passed"]]}, {"few_shots": [{"author": "Calvin", "UUID": "f795bda7-9822-4bc5-9c7e-b9c0f2752085", "question": "You are given two 0-indexed integer permutations A and B of length n.\n\nA prefix common array of A and B is an array C such that C[i] is equal to the count of numbers that are present at or before the index i in both A and B.\n\nReturn the prefix common array of A and B.\n\nA sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once.", "examples": "Input: A = [1,3,2,4], B = [3,1,2,4]\nOutput: [0,2,3,4]", "link": "https://leetcode.com/problems/find-the-prefix-common-array-of-two-arrays/", "difficulty": null, "categories": ["Array"], "code": "def findThePrefixCommonArray(arr1: list, arr2: list) -> list:\n  max = len(arr1) if len(arr1) > len(arr2) else len(arr2)\n  seen = set()\n  curCount = 0\n  ret = []\n  for i in range(max):\n    cur1 = arr1[i]\n    cur2 = arr2[i]\n    if cur1 in seen:\n      curCount += 1\n    else:\n      seen.add(cur1)\n    if cur2 in seen:\n      curCount += 1\n    else:\n      seen.add(cur2)\n    ret.append(curCount)\n  return ret\n", "asserts": ["assert findThePrefixCommonArray([1,3,2,4], [3,1,2,4]) == [0,2,3,4]", "assert findThePrefixCommonArray([1], [1]) == [1]", "assert findThePrefixCommonArray([2,3,1], [3,1,2]) == [0,1,3]"]}, {"author": "Calvin", "UUID": "a9c5e697-af5d-432b-8447-5675d739c728", "question": "Given an array reorder it so that even numbers appear first", "examples": "Input: [1,2,3,4,5,6,7,8,9]\r\nOutput: [8,2,6,4,5,7,3,9,1]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def even_odd_reorder(arr: list) -> list:\n  nextEven = 0\n  nextOdd = len(arr) - 1\n  while nextEven < nextOdd:\n    if arr[nextEven] % 2 == 0:\n      nextEven += 1\n    else:\n      temp = arr[nextEven]\n      arr[nextEven] = arr[nextOdd]\n      arr[nextOdd] = temp\n      nextOdd -= 1\n  return arr\n", "asserts": ["assert even_odd_reorder([1,2,3,4,5,6,7,8,9]) == [8, 2, 6, 4, 5, 7, 3, 9, 1]", "assert even_odd_reorder([]) == []", "assert even_odd_reorder([2, 4, 6, 8]) == [2, 4, 6, 8]", "assert even_odd_reorder([7, 9, 2]) == [2, 9, 7]", "assert even_odd_reorder([10, 13, 17, 16, 15, 12]) == [10, 12, 16, 15, 17, 13]"]}], "category": "Array", "prompt_tokens": 781, "total_tokens": 943, "completion_tokens": 162, "completion": "Given a non-empty array of integers nums, every element appears twice except for one. Find that single one.\n\nYou must implement a solution with a linear runtime complexity and use only constant extra space.\n\n###Code: \n\ndef singleNumber(nums: list) -> int:\n    single = 0\n    for num in nums:\n        single ^= num\n    return single\n\n\n###Testcases: \n\nassert singleNumber([2,2,1]) == 1\nassert singleNumber([4,1,2,1,2]) == 4\nassert singleNumber([1]) == 1\nassert singleNumber([1,3,1,-1,3]) == -1\nassert singleNumber([0,1,0,1,0]) == 0\n\n[/Example 3]", "temperature": 0.652, "question": "Given a non-empty array of integers nums, every element appears twice except for one. Find that single one.\n\nYou must implement a solution with a linear runtime complexity and use only constant extra space.", "code": "def singleNumber(nums: list) -> int:\n    single = 0\n    for num in nums:\n        single ^= num\n    return single", "asserts": ["assert singleNumber([2,2,1]) == 1", "assert singleNumber([4,1,2,1,2]) == 4", "assert singleNumber([1]) == 1", "assert singleNumber([1,3,1,-1,3]) == -1", "assert singleNumber([0,1,0,1,0]) == 0"], "author": "GPT", "UUID": "11f397f0-cdfa-4355-97c8-75472b868924", "tc_status": [["assert singleNumber([2,2,1]) == 1", "Passed"], ["assert singleNumber([4,1,2,1,2]) == 4", "Passed"], ["assert singleNumber([1]) == 1", "Passed"], ["assert singleNumber([1,3,1,-1,3]) == -1", "Passed"], ["assert singleNumber([0,1,0,1,0]) == 0", "Passed"]]}, {"few_shots": [{"author": "Calvin", "UUID": "fb94082f-4627-4f5a-b280-08d869823d70", "question": "You are given an array of people, people, which are the attributes of some people in a queue (not necessarily in order). Each people[i] = [hi, ki] represents the ith person of height hi with exactly ki other people in front who have a height greater than or equal to hi.\n\nReconstruct and return the queue that is represented by the input array people. The returned queue should be formatted as an array queue, where queue[j] = [hj, kj] is the attributes of the jth person in the queue (queue[0] is the person at the front of the queue).\n", "examples": "Input:  [[7, 0], [4, 4], [7, 1], [5, 0], [6, 1], [5, 2]]\nOutput: [[5, 0], [4, 1], [7, 0], [5, 2], [6, 1], [7, 1]]\n\nInput:  [[6, 0], [5, 0], [4, 0], [3, 2], [2, 2], [1, 4]]\nOutput: [[4, 0], [5, 0], [2, 2], [3, 2], [1, 4], [6, 0]]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "\ndef reconstructQueue(people: list) -> list:\n    output=[] \n    people.sort(key=lambda x: (-x[0], x[1]))                \n    for a in people:\n        output.insert(a[1], a)\n    \n    return output\n", "asserts": ["assert reconstructQueue([[8,1],[5,0],[6,1],[5,2],[4,4],[7,1]]) == [[5, 0], [8, 1], [5, 2], [6, 1], [4, 4], [7, 1]]", "assert reconstructQueue([[12,0], [6,3], [4,4], [9,2], [7,1]]) == [[12, 0], [7, 1], [9, 2], [6, 3], [4, 4]]", "assert reconstructQueue([[2,0], [1,1]]) == [[2, 0], [1, 1]]", "assert reconstructQueue([[3,0], [3,2], [3,1]]) == [[3, 0], [3, 1], [3, 2]]"]}, {"author": "Calvin", "UUID": "a9c5e697-af5d-432b-8447-5675d739c728", "question": "Given an array reorder it so that even numbers appear first", "examples": "Input: [1,2,3,4,5,6,7,8,9]\r\nOutput: [8,2,6,4,5,7,3,9,1]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def even_odd_reorder(arr: list) -> list:\n  nextEven = 0\n  nextOdd = len(arr) - 1\n  while nextEven < nextOdd:\n    if arr[nextEven] % 2 == 0:\n      nextEven += 1\n    else:\n      temp = arr[nextEven]\n      arr[nextEven] = arr[nextOdd]\n      arr[nextOdd] = temp\n      nextOdd -= 1\n  return arr\n", "asserts": ["assert even_odd_reorder([1,2,3,4,5,6,7,8,9]) == [8, 2, 6, 4, 5, 7, 3, 9, 1]", "assert even_odd_reorder([]) == []", "assert even_odd_reorder([2, 4, 6, 8]) == [2, 4, 6, 8]", "assert even_odd_reorder([7, 9, 2]) == [2, 9, 7]", "assert even_odd_reorder([10, 13, 17, 16, 15, 12]) == [10, 12, 16, 15, 17, 13]"]}], "category": "Array", "prompt_tokens": 842, "total_tokens": 1070, "completion_tokens": 228, "completion": "Given an array of integers, return the third maximum number in this array. If the third maximum does not exist, return the maximum number. The time complexity of the function should be O(n).\n\n###Code: \n\ndef thirdMax(nums: list) -> int:\n    first = second = third = float('-inf')\n    \n    for num in nums:\n        if num > first:\n            third = second\n            second = first\n            first = num\n        elif first > num > second:\n            third = second\n            second = num\n        elif second > num > third:\n            third = num\n    \n    return third if third != float('-inf') else first\n\n###Testcases: \n\nassert thirdMax([3, 2, 1]) == 1\nassert thirdMax([1, 2]) == 2\nassert thirdMax([2, 2, 3, 1]) == 1\nassert thirdMax([1,1,2]) == 2\nassert thirdMax([1,2,2,5,3,5]) == 2\n\n[/Example 3]", "temperature": 0.764, "question": "Given an array of integers, return the third maximum number in this array. If the third maximum does not exist, return the maximum number. The time complexity of the function should be O(n).", "code": "def thirdMax(nums: list) -> int:\n    first = second = third = float('-inf')\n    \n    for num in nums:\n        if num > first:\n            third = second\n            second = first\n            first = num\n        elif first > num > second:\n            third = second\n            second = num\n        elif second > num > third:\n            third = num\n    \n    return third if third != float('-inf') else first", "asserts": ["assert thirdMax([3, 2, 1]) == 1", "assert thirdMax([1, 2]) == 2", "assert thirdMax([2, 2, 3, 1]) == 1", "assert thirdMax([1,1,2]) == 2", "assert thirdMax([1,2,2,5,3,5]) == 2"], "author": "GPT", "UUID": "257ad0f9-8b47-45c6-be9b-f009aada6fa7", "tc_status": [["assert thirdMax([3, 2, 1]) == 1", "Passed"], ["assert thirdMax([1, 2]) == 2", "Passed"], ["assert thirdMax([2, 2, 3, 1]) == 1", "Passed"], ["assert thirdMax([1,1,2]) == 2", "Passed"], ["assert thirdMax([1,2,2,5,3,5]) == 2", "Passed"]]}, {"few_shots": [{"author": "Calvin", "UUID": "a9c5e697-af5d-432b-8447-5675d739c728", "question": "Given an array reorder it so that even numbers appear first", "examples": "Input: [1,2,3,4,5,6,7,8,9]\r\nOutput: [8,2,6,4,5,7,3,9,1]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def even_odd_reorder(arr: list) -> list:\n  nextEven = 0\n  nextOdd = len(arr) - 1\n  while nextEven < nextOdd:\n    if arr[nextEven] % 2 == 0:\n      nextEven += 1\n    else:\n      temp = arr[nextEven]\n      arr[nextEven] = arr[nextOdd]\n      arr[nextOdd] = temp\n      nextOdd -= 1\n  return arr\n", "asserts": ["assert even_odd_reorder([1,2,3,4,5,6,7,8,9]) == [8, 2, 6, 4, 5, 7, 3, 9, 1]", "assert even_odd_reorder([]) == []", "assert even_odd_reorder([2, 4, 6, 8]) == [2, 4, 6, 8]", "assert even_odd_reorder([7, 9, 2]) == [2, 9, 7]", "assert even_odd_reorder([10, 13, 17, 16, 15, 12]) == [10, 12, 16, 15, 17, 13]"]}, {"author": "Calvin", "UUID": "48c6aa37-e00d-4b55-9afc-6b1cf2a1aff2", "question": "There are N Mice and N holes are placed in a straight line. Each hole can accommodate only 1 mouse. A mouse can stay at his position, move one step right from x to x + 1, or move one step left from x to x -1. Any of these moves consumes 1 minute. Assign mice to holes so that the time when the last mouse gets inside a hole is minimized.\nYou are given a list of mice and hole positions as integer scalers.\n", "examples": "Input: Mices = [0, 10, 2, 3], Holes = [3, 2, 23, 0]\nOutput: 13", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def assignHole(mices: list, holes: list) -> int:\n    for i,j in zip(mices,holes):\n        if i<0 or j<0:\n            return -1\n    if (len(mices) != len(holes)):\n        return -1\n    mices.sort()\n    holes.sort()\n    Max = 0\n     \n    for i in range(len(holes)):\n        if (Max < abs(mices[i] - holes[i])):\n            Max = abs(mices[i] - holes[i])\n     \n    return Max\n", "asserts": ["assert assignHole([1, 2, 3, 4], [4, 3, 2, 1]) == 0", "assert assignHole([10, 20, 30, 40], [15, 25, 35, 45]) == 5", "assert assignHole([1, 4, 9, 15], [10, 13, 7, 20]) == 6", "assert assignHole([0], [0]) == 0", "assert assignHole([1, 2], [3]) == -1  # Edge case with non-equal amount of mice and holes", "assert assignHole([5, 5, 5], [5, 5, 5]) == 0  # Edge case with all mice and holes at the same position", "assert assignHole([10, 10, 10, 10], [10, 9, 8, 7]) == 3  # Edge case with multiple mice starting at the same position", "assert assignHole([1,1 ,1, 1, 1, 1, 1, 1, 1, 1], [2,2,2,2,2,2 ,2, 2, 2, 2]) == 1 # Edge case with multiple mice and holes at the same positions", "assert assignHole([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == 1 # Edge case with incremental positions"]}], "category": "Array", "prompt_tokens": 1067, "total_tokens": 1505, "completion_tokens": 438, "completion": "Given an array of integers, return the maximum sum of non-adjacent elements. Non-adjacent elements are elements that are not immediately next to each other in the array (i.e., they are at least one element apart).\n\n###Code: \n\ndef max_subset_sum_no_adjacent(arr: list) -> int:\n    if not arr:\n        return 0\n    elif len(arr) <= 2:\n        return max(arr)\n    \n    max_sums = arr[:]\n    max_sums[1] = max(arr[0], arr[1])\n    for i in range(2, len(arr)):\n        max_sums[i] = max(max_sums[i-1], max_sums[i-2] + arr[i])\n    return max_sums[-1]\n\n###Testcases: \n\nassert max_subset_sum_no_adjacent([3, 2, 7, 10]) == 13  # Pick 3 and 10\nassert max_subset_sum_no_adjacent([3, 2, 5, 10, 7]) == 15  # Pick 3, 5 and 7\nassert max_subset_sum_no_adjacent([5, 5, 10, 100, 10, 5]) == 110  # Pick 5, 100 and 5\nassert max_subset_sum_no_adjacent([1, 0, 3, 9, 2]) == 10  # Pick 1 and 9\nassert max_subset_sum_no_adjacent([]) == 0  # Empty array\nassert max_subset_sum_no_adjacent([0, 0, 0, 0, 0]) == 0  # Array with all elements as 0\nassert max_subset_sum_no_adjacent([1]) == 1  # Array with one element\nassert max_subset_sum_no_adjacent([2, 4]) == 4  # Array with two elements\nassert max_subset_sum_no_adjacent([-2, 1, 3, -4, 5]) == 8  # Array containing negative numbers\n\n[/Example 3]", "temperature": 0.846, "question": "Given an array of integers, return the maximum sum of non-adjacent elements. Non-adjacent elements are elements that are not immediately next to each other in the array (i.e., they are at least one element apart).", "code": "def max_subset_sum_no_adjacent(arr: list) -> int:\n    if not arr:\n        return 0\n    elif len(arr) <= 2:\n        return max(arr)\n    \n    max_sums = arr[:]\n    max_sums[1] = max(arr[0], arr[1])\n    for i in range(2, len(arr)):\n        max_sums[i] = max(max_sums[i-1], max_sums[i-2] + arr[i])\n    return max_sums[-1]", "asserts": ["assert max_subset_sum_no_adjacent([3, 2, 7, 10]) == 13  # Pick 3 and 10", "assert max_subset_sum_no_adjacent([3, 2, 5, 10, 7]) == 15  # Pick 3, 5 and 7", "assert max_subset_sum_no_adjacent([5, 5, 10, 100, 10, 5]) == 110  # Pick 5, 100 and 5", "assert max_subset_sum_no_adjacent([1, 0, 3, 9, 2]) == 10  # Pick 1 and 9", "assert max_subset_sum_no_adjacent([]) == 0  # Empty array", "assert max_subset_sum_no_adjacent([0, 0, 0, 0, 0]) == 0  # Array with all elements as 0", "assert max_subset_sum_no_adjacent([1]) == 1  # Array with one element", "assert max_subset_sum_no_adjacent([2, 4]) == 4  # Array with two elements"], "author": "GPT", "UUID": "efd0713d-bb94-4cd1-9d5d-99dc80219233", "tc_status": [["assert max_subset_sum_no_adjacent([3, 2, 7, 10]) == 13  # Pick 3 and 10", "Passed"], ["assert max_subset_sum_no_adjacent([3, 2, 5, 10, 7]) == 15  # Pick 3, 5 and 7", "Passed"], ["assert max_subset_sum_no_adjacent([5, 5, 10, 100, 10, 5]) == 110  # Pick 5, 100 and 5", "Passed"], ["assert max_subset_sum_no_adjacent([1, 0, 3, 9, 2]) == 10  # Pick 1 and 9", "Passed"], ["assert max_subset_sum_no_adjacent([]) == 0  # Empty array", "Passed"], ["assert max_subset_sum_no_adjacent([0, 0, 0, 0, 0]) == 0  # Array with all elements as 0", "Passed"], ["assert max_subset_sum_no_adjacent([1]) == 1  # Array with one element", "Passed"], ["assert max_subset_sum_no_adjacent([2, 4]) == 4  # Array with two elements", "Passed"]]}, {"few_shots": [{"author": "Calvin", "UUID": "fb94082f-4627-4f5a-b280-08d869823d70", "question": "You are given an array of people, people, which are the attributes of some people in a queue (not necessarily in order). Each people[i] = [hi, ki] represents the ith person of height hi with exactly ki other people in front who have a height greater than or equal to hi.\n\nReconstruct and return the queue that is represented by the input array people. The returned queue should be formatted as an array queue, where queue[j] = [hj, kj] is the attributes of the jth person in the queue (queue[0] is the person at the front of the queue).\n", "examples": "Input:  [[7, 0], [4, 4], [7, 1], [5, 0], [6, 1], [5, 2]]\nOutput: [[5, 0], [4, 1], [7, 0], [5, 2], [6, 1], [7, 1]]\n\nInput:  [[6, 0], [5, 0], [4, 0], [3, 2], [2, 2], [1, 4]]\nOutput: [[4, 0], [5, 0], [2, 2], [3, 2], [1, 4], [6, 0]]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "\ndef reconstructQueue(people: list) -> list:\n    output=[] \n    people.sort(key=lambda x: (-x[0], x[1]))                \n    for a in people:\n        output.insert(a[1], a)\n    \n    return output\n", "asserts": ["assert reconstructQueue([[8,1],[5,0],[6,1],[5,2],[4,4],[7,1]]) == [[5, 0], [8, 1], [5, 2], [6, 1], [4, 4], [7, 1]]", "assert reconstructQueue([[12,0], [6,3], [4,4], [9,2], [7,1]]) == [[12, 0], [7, 1], [9, 2], [6, 3], [4, 4]]", "assert reconstructQueue([[2,0], [1,1]]) == [[2, 0], [1, 1]]", "assert reconstructQueue([[3,0], [3,2], [3,1]]) == [[3, 0], [3, 1], [3, 2]]"]}, {"author": "Calvin", "UUID": "1aeb3246-4c22-4d34-a48c-db7be8ba1b94", "question": "You are given n activities with their start and finish times. Select the maximum number of activities that can be performed by a single person and return their indexes. Assume that a person can only work on a single activity at a time. \n", "examples": "Input: start  =  {10, 12, 20}, finish =  {20, 25, 30}\nOutput: [0, 2]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "import numpy as np\ndef MaxActivities(s: list, f: list) -> list:\n    indices = np.argsort(f)\n    [s[i] for i in indices]\n    [f[i] for i in indices]\n    result = []\n    n = len(f)\n    i = 0\n    result.append(i)\n    for j in range(1, n):\n        if s[j] >= f[i]:\n            result.append(j)\n            i = j\n    return result\n", "asserts": ["assert MaxActivities([2, 4, 5, 6, 7, 8], [3, 5, 6, 7, 9, 10]) == [0, 1, 2, 3, 4]", "assert MaxActivities([1, 3, 0, 5, 8, 5], [2, 4, 6, 7, 9, 9]) == [0, 1, 3, 4]", "assert MaxActivities([1], [2]) == [0]"]}], "category": "Array", "prompt_tokens": 843, "total_tokens": 1255, "completion_tokens": 412, "completion": "Write a function that takes in a non-empty array of distinct integers and an integer representing a target sum. The function should find all triplets in the array that sum up to the target sum and return a two-dimensional array of all these triplets. The numbers in each triplet should be ordered in ascending order, and the triplets themselves should be ordered in ascending order with respect to the numbers they hold.\n\nIf no three numbers sum up to the target sum, the function should return an empty array.\n\n\n###Code:\n\n```python\ndef threeNumberSum(array, targetSum):\n    array.sort()\n    triplets = []\n    for i in range(len(array) - 2):\n        left = i + 1\n        right = len(array) - 1\n        while left < right:\n            currentSum = array[i] + array[left] + array[right]\n            if currentSum == targetSum:\n                triplets.append([array[i], array[left], array[right]])\n                left += 1\n                right -= 1\n            elif currentSum < targetSum:\n                left += 1\n            elif currentSum > targetSum:\n                right -= 1\n    return triplets\n```\n\n\n###Testcases: \n\n```python\nassert threeNumberSum([12, 3, 1, 2, -6, 5, -8, 6], 0) == [[-8, 2, 6], [-8, 3, 5], [-6, 1, 5]]\nassert threeNumberSum([1, 2, 3], 6) == [[1, 2, 3]]\nassert threeNumberSum([-1, 0, 1, 2, -1, -4], -1) == [[-4, 0, 3], [-1, -1, 1]]\nassert threeNumberSum([], 0) == []\nassert threeNumberSum([1], 0) == []\n```\n\n[/Example 3]", "temperature": 0.854, "question": "Write a function that takes in a non-empty array of distinct integers and an integer representing a target sum. The function should find all triplets in the array that sum up to the target sum and return a two-dimensional array of all these triplets. The numbers in each triplet should be ordered in ascending order, and the triplets themselves should be ordered in ascending order with respect to the numbers they hold.\n\nIf no three numbers sum up to the target sum, the function should return an empty array.", "code": "def threeNumberSum(array, targetSum):\n    array.sort()\n    triplets = []\n    for i in range(len(array) - 2):\n        left = i + 1\n        right = len(array) - 1\n        while left < right:\n            currentSum = array[i] + array[left] + array[right]\n            if currentSum == targetSum:\n                triplets.append([array[i], array[left], array[right]])\n                left += 1\n                right -= 1\n            elif currentSum < targetSum:\n                left += 1\n            elif currentSum > targetSum:\n                right -= 1\n    return triplets", "asserts": ["assert threeNumberSum([12, 3, 1, 2, -6, 5, -8, 6], 0) == [[-8, 2, 6], [-8, 3, 5], [-6, 1, 5]]", "assert threeNumberSum([1, 2, 3], 6) == [[1, 2, 3]]", "assert threeNumberSum([], 0) == []", "assert threeNumberSum([1], 0) == []"], "author": "GPT", "UUID": "e118d715-42fc-4957-b487-a97650e9e6e8", "tc_status": [["assert threeNumberSum([12, 3, 1, 2, -6, 5, -8, 6], 0) == [[-8, 2, 6], [-8, 3, 5], [-6, 1, 5]]", "Passed"], ["assert threeNumberSum([1, 2, 3], 6) == [[1, 2, 3]]", "Passed"], ["assert threeNumberSum([], 0) == []", "Passed"], ["assert threeNumberSum([1], 0) == []", "Passed"]]}, {"few_shots": [{"author": "Calvin", "UUID": "9e45b73f-583d-40ab-b387-e0d1624af07b", "question": "Given two arrays return an array with the set intersection of their common elements", "examples": "Input: arr1 = [1, 2, 3, 4], arr2 = [2, 3]\nOutput: [2, 3]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def array_intersection(arr1: list, arr2: list) -> set:\n  set1 = set(arr1)\n  ret = set([x for x in arr2 if x in set1])\n  return list(ret)\n", "asserts": ["assert set(array_intersection([1,0,2,0,2,0,2,1,1,1], [2,1,0,2,0,2,2,2,1,0])) == {0,1,2}", "assert set(array_intersection([5, 6, 7, 8], [8, 9, 10, 11])) == {8}", "assert set(array_intersection([10, 20, 30], [40, 50, 60])) == set()", "assert set(array_intersection([], [1, 2, 3])) == set()", "assert set(array_intersection([-1, -2, -3], [-3, -4, -5, -6])) == {-3}", "assert set(array_intersection([9, 8, 7], [7, 8, 9, 10, 11, 12])) == {7, 8, 9}", "assert set(array_intersection(['a', 'b', 'c'], ['a', 'd', 'e', 'c'])) == {'a', 'c'}", "assert set(array_intersection(['apple', 'banana'], ['banana', 'cherry'])) == {'banana'}", "assert set(array_intersection([1.1, 2.2, 3.3], [2.2, 4.4])) == {2.2}", "assert set(array_intersection([False, True, False], [True, False, True])) == {True, False}", "assert set(array_intersection([(1, 2), (3, 4)], [(3, 4), (5, 6)])) == {(3, 4)}"]}, {"author": "Calvin", "UUID": "fb94082f-4627-4f5a-b280-08d869823d70", "question": "You are given an array of people, people, which are the attributes of some people in a queue (not necessarily in order). Each people[i] = [hi, ki] represents the ith person of height hi with exactly ki other people in front who have a height greater than or equal to hi.\n\nReconstruct and return the queue that is represented by the input array people. The returned queue should be formatted as an array queue, where queue[j] = [hj, kj] is the attributes of the jth person in the queue (queue[0] is the person at the front of the queue).\n", "examples": "Input:  [[7, 0], [4, 4], [7, 1], [5, 0], [6, 1], [5, 2]]\nOutput: [[5, 0], [4, 1], [7, 0], [5, 2], [6, 1], [7, 1]]\n\nInput:  [[6, 0], [5, 0], [4, 0], [3, 2], [2, 2], [1, 4]]\nOutput: [[4, 0], [5, 0], [2, 2], [3, 2], [1, 4], [6, 0]]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "\ndef reconstructQueue(people: list) -> list:\n    output=[] \n    people.sort(key=lambda x: (-x[0], x[1]))                \n    for a in people:\n        output.insert(a[1], a)\n    \n    return output\n", "asserts": ["assert reconstructQueue([[8,1],[5,0],[6,1],[5,2],[4,4],[7,1]]) == [[5, 0], [8, 1], [5, 2], [6, 1], [4, 4], [7, 1]]", "assert reconstructQueue([[12,0], [6,3], [4,4], [9,2], [7,1]]) == [[12, 0], [7, 1], [9, 2], [6, 3], [4, 4]]", "assert reconstructQueue([[2,0], [1,1]]) == [[2, 0], [1, 1]]", "assert reconstructQueue([[3,0], [3,2], [3,1]]) == [[3, 0], [3, 1], [3, 2]]"]}], "category": "Array", "prompt_tokens": 983, "total_tokens": 1366, "completion_tokens": 383, "completion": "Given an array of integers, return a new array such that each element at index i of the new array is the product of all the numbers in the original array except the one at i.\n\n###Code: \n\ndef product_except_self(nums: list) -> list:\n    product = 1\n    zero_count = nums.count(0)\n    if zero_count > 1:\n        return [0] * len(nums)\n    elif zero_count == 1:\n        product_without_zero = 1\n        for num in nums:\n            if num != 0:\n                product_without_zero *= num\n        return [product_without_zero if num == 0 else 0 for num in nums]\n    else:\n        for num in nums:\n            product *= num\n        return [product // num for num in nums]\n\n\n###Testcases: \n\nassert product_except_self([1, 2, 3, 4]) == [24, 12, 8, 6]\nassert product_except_self([0, 1, 2, 3, 4]) == [24, 0, 0, 0, 0]\nassert product_except_self([1, 0, 3, 0]) == [0, 0, 0, 0]\nassert product_except_self([-1, 1, -2, 2]) == [-4, 4, -2, 2]\nassert product_except_self([9]) == [1]\nassert product_except_self([1, -1]) == [-1, 1]\nassert product_except_self([1, 2, 3, 0, 0]) == [0, 0, 0, 0, 0]\nassert product_except_self([-3, 0, 2]) == [0, -6, 0]\n\n[/Example 3]", "temperature": 0.837, "question": "Given an array of integers, return a new array such that each element at index i of the new array is the product of all the numbers in the original array except the one at i.", "code": "def product_except_self(nums: list) -> list:\n    product = 1\n    zero_count = nums.count(0)\n    if zero_count > 1:\n        return [0] * len(nums)\n    elif zero_count == 1:\n        product_without_zero = 1\n        for num in nums:\n            if num != 0:\n                product_without_zero *= num\n        return [product_without_zero if num == 0 else 0 for num in nums]\n    else:\n        for num in nums:\n            product *= num\n        return [product // num for num in nums]", "asserts": ["assert product_except_self([1, 2, 3, 4]) == [24, 12, 8, 6]", "assert product_except_self([0, 1, 2, 3, 4]) == [24, 0, 0, 0, 0]", "assert product_except_self([1, 0, 3, 0]) == [0, 0, 0, 0]", "assert product_except_self([-1, 1, -2, 2]) == [-4, 4, -2, 2]", "assert product_except_self([9]) == [1]", "assert product_except_self([1, -1]) == [-1, 1]", "assert product_except_self([1, 2, 3, 0, 0]) == [0, 0, 0, 0, 0]", "assert product_except_self([-3, 0, 2]) == [0, -6, 0]"], "author": "GPT", "UUID": "44a6694f-80b7-4f00-b510-eebc1f5438ea", "tc_status": [["assert product_except_self([1, 2, 3, 4]) == [24, 12, 8, 6]", "Passed"], ["assert product_except_self([0, 1, 2, 3, 4]) == [24, 0, 0, 0, 0]", "Passed"], ["assert product_except_self([1, 0, 3, 0]) == [0, 0, 0, 0]", "Passed"], ["assert product_except_self([-1, 1, -2, 2]) == [-4, 4, -2, 2]", "Passed"], ["assert product_except_self([9]) == [1]", "Passed"], ["assert product_except_self([1, -1]) == [-1, 1]", "Passed"], ["assert product_except_self([1, 2, 3, 0, 0]) == [0, 0, 0, 0, 0]", "Passed"], ["assert product_except_self([-3, 0, 2]) == [0, -6, 0]", "Passed"]]}, {"few_shots": [{"author": "Calvin", "UUID": "f795bda7-9822-4bc5-9c7e-b9c0f2752085", "question": "You are given two 0-indexed integer permutations A and B of length n.\n\nA prefix common array of A and B is an array C such that C[i] is equal to the count of numbers that are present at or before the index i in both A and B.\n\nReturn the prefix common array of A and B.\n\nA sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once.", "examples": "Input: A = [1,3,2,4], B = [3,1,2,4]\nOutput: [0,2,3,4]", "link": "https://leetcode.com/problems/find-the-prefix-common-array-of-two-arrays/", "difficulty": null, "categories": ["Array"], "code": "def findThePrefixCommonArray(arr1: list, arr2: list) -> list:\n  max = len(arr1) if len(arr1) > len(arr2) else len(arr2)\n  seen = set()\n  curCount = 0\n  ret = []\n  for i in range(max):\n    cur1 = arr1[i]\n    cur2 = arr2[i]\n    if cur1 in seen:\n      curCount += 1\n    else:\n      seen.add(cur1)\n    if cur2 in seen:\n      curCount += 1\n    else:\n      seen.add(cur2)\n    ret.append(curCount)\n  return ret\n", "asserts": ["assert findThePrefixCommonArray([1,3,2,4], [3,1,2,4]) == [0,2,3,4]", "assert findThePrefixCommonArray([1], [1]) == [1]", "assert findThePrefixCommonArray([2,3,1], [3,1,2]) == [0,1,3]"]}, {"author": "Calvin", "UUID": "a9c5e697-af5d-432b-8447-5675d739c728", "question": "Given an array reorder it so that even numbers appear first", "examples": "Input: [1,2,3,4,5,6,7,8,9]\r\nOutput: [8,2,6,4,5,7,3,9,1]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def even_odd_reorder(arr: list) -> list:\n  nextEven = 0\n  nextOdd = len(arr) - 1\n  while nextEven < nextOdd:\n    if arr[nextEven] % 2 == 0:\n      nextEven += 1\n    else:\n      temp = arr[nextEven]\n      arr[nextEven] = arr[nextOdd]\n      arr[nextOdd] = temp\n      nextOdd -= 1\n  return arr\n", "asserts": ["assert even_odd_reorder([1,2,3,4,5,6,7,8,9]) == [8, 2, 6, 4, 5, 7, 3, 9, 1]", "assert even_odd_reorder([]) == []", "assert even_odd_reorder([2, 4, 6, 8]) == [2, 4, 6, 8]", "assert even_odd_reorder([7, 9, 2]) == [2, 9, 7]", "assert even_odd_reorder([10, 13, 17, 16, 15, 12]) == [10, 12, 16, 15, 17, 13]"]}], "category": "Array", "prompt_tokens": 781, "total_tokens": 1070, "completion_tokens": 289, "completion": "Given an array of integers, return the indices of the two numbers that add up to a specific target.\n\nYou may assume that each input would have exactly one solution, and you may not use the same element twice.\n\n###Code: \n\n```python\ndef two_sum(nums: list, target: int) -> list:\n    num_to_index = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_to_index:\n            return [num_to_index[complement], i]\n        num_to_index[num] = i\n    return []\n```\n\n###Testcases: \n\n```python\nassert two_sum([2, 7, 11, 15], 9) == [0, 1], \"Test case 1 failed\"\nassert two_sum([3, 2, 4], 6) == [1, 2], \"Test case 2 failed\"\nassert two_sum([3, 3], 6) == [0, 1], \"Test case 3 failed\"\nassert two_sum([0, 4, 3, 0], 0) == [0, 3], \"Test case 4 failed\"\nassert two_sum([-1, -2, -3, -4, -5], -8) == [2, 4], \"Test case 5 failed\"\n```\n\n[/Example 3]", "temperature": 0.755, "question": "Given an array of integers, return the indices of the two numbers that add up to a specific target.\n\nYou may assume that each input would have exactly one solution, and you may not use the same element twice.", "code": "def two_sum(nums: list, target: int) -> list:\n    num_to_index = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_to_index:\n            return [num_to_index[complement], i]\n        num_to_index[num] = i\n    return []", "asserts": ["assert two_sum([2, 7, 11, 15], 9) == [0, 1], \"Test case 1 failed\"", "assert two_sum([3, 2, 4], 6) == [1, 2], \"Test case 2 failed\"", "assert two_sum([3, 3], 6) == [0, 1], \"Test case 3 failed\"", "assert two_sum([0, 4, 3, 0], 0) == [0, 3], \"Test case 4 failed\"", "assert two_sum([-1, -2, -3, -4, -5], -8) == [2, 4], \"Test case 5 failed\""], "author": "GPT", "UUID": "809243d0-a1c1-4c00-af9a-ebde279cd37d", "tc_status": [["assert two_sum([2, 7, 11, 15], 9) == [0, 1], \"Test case 1 failed\"", "Passed"], ["assert two_sum([3, 2, 4], 6) == [1, 2], \"Test case 2 failed\"", "Passed"], ["assert two_sum([3, 3], 6) == [0, 1], \"Test case 3 failed\"", "Passed"], ["assert two_sum([0, 4, 3, 0], 0) == [0, 3], \"Test case 4 failed\"", "Passed"], ["assert two_sum([-1, -2, -3, -4, -5], -8) == [2, 4], \"Test case 5 failed\"", "Passed"]]}, {"few_shots": [{"author": "Calvin", "UUID": "f795bda7-9822-4bc5-9c7e-b9c0f2752085", "question": "You are given two 0-indexed integer permutations A and B of length n.\n\nA prefix common array of A and B is an array C such that C[i] is equal to the count of numbers that are present at or before the index i in both A and B.\n\nReturn the prefix common array of A and B.\n\nA sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once.", "examples": "Input: A = [1,3,2,4], B = [3,1,2,4]\nOutput: [0,2,3,4]", "link": "https://leetcode.com/problems/find-the-prefix-common-array-of-two-arrays/", "difficulty": null, "categories": ["Array"], "code": "def findThePrefixCommonArray(arr1: list, arr2: list) -> list:\n  max = len(arr1) if len(arr1) > len(arr2) else len(arr2)\n  seen = set()\n  curCount = 0\n  ret = []\n  for i in range(max):\n    cur1 = arr1[i]\n    cur2 = arr2[i]\n    if cur1 in seen:\n      curCount += 1\n    else:\n      seen.add(cur1)\n    if cur2 in seen:\n      curCount += 1\n    else:\n      seen.add(cur2)\n    ret.append(curCount)\n  return ret\n", "asserts": ["assert findThePrefixCommonArray([1,3,2,4], [3,1,2,4]) == [0,2,3,4]", "assert findThePrefixCommonArray([1], [1]) == [1]", "assert findThePrefixCommonArray([2,3,1], [3,1,2]) == [0,1,3]"]}, {"author": "Calvin", "UUID": "9e45b73f-583d-40ab-b387-e0d1624af07b", "question": "Given two arrays return an array with the set intersection of their common elements", "examples": "Input: arr1 = [1, 2, 3, 4], arr2 = [2, 3]\nOutput: [2, 3]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def array_intersection(arr1: list, arr2: list) -> set:\n  set1 = set(arr1)\n  ret = set([x for x in arr2 if x in set1])\n  return list(ret)\n", "asserts": ["assert set(array_intersection([1,0,2,0,2,0,2,1,1,1], [2,1,0,2,0,2,2,2,1,0])) == {0,1,2}", "assert set(array_intersection([5, 6, 7, 8], [8, 9, 10, 11])) == {8}", "assert set(array_intersection([10, 20, 30], [40, 50, 60])) == set()", "assert set(array_intersection([], [1, 2, 3])) == set()", "assert set(array_intersection([-1, -2, -3], [-3, -4, -5, -6])) == {-3}", "assert set(array_intersection([9, 8, 7], [7, 8, 9, 10, 11, 12])) == {7, 8, 9}", "assert set(array_intersection(['a', 'b', 'c'], ['a', 'd', 'e', 'c'])) == {'a', 'c'}", "assert set(array_intersection(['apple', 'banana'], ['banana', 'cherry'])) == {'banana'}", "assert set(array_intersection([1.1, 2.2, 3.3], [2.2, 4.4])) == {2.2}", "assert set(array_intersection([False, True, False], [True, False, True])) == {True, False}", "assert set(array_intersection([(1, 2), (3, 4)], [(3, 4), (5, 6)])) == {(3, 4)}"]}], "category": "Array", "prompt_tokens": 922, "total_tokens": 1237, "completion_tokens": 315, "completion": "Given an array of integers, return the array with all its elements sorted in non-decreasing order.\n\n###Code: \n\ndef sort_array(arr: list) -> list:\n    return sorted(arr)\n\n###Testcases: \n\nassert sort_array([4, 2, 5, 1, 3]) == [1, 2, 3, 4, 5]\nassert sort_array([10, 9, 8, 7, 6]) == [6, 7, 8, 9, 10]\nassert sort_array([5]) == [5]\nassert sort_array([]) == []\nassert sort_array([3, 3, 3]) == [3, 3, 3]\nassert sort_array([-1, -5, -3]) == [-5, -3, -1]\nassert sort_array([4, 1, 4, 2, 4]) == [1, 2, 4, 4, 4]\nassert sort_array([0, 0, 0, -1]) == [-1, 0, 0, 0]\nassert sort_array([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]  # already sorted\nassert sort_array([-2, -2, -2, -2]) == [-2, -2, -2, -2]  # all elements are the same\n\n[/Example 3]", "temperature": 0.687, "question": "Given an array of integers, return the array with all its elements sorted in non-decreasing order.", "code": "def sort_array(arr: list) -> list:\n    return sorted(arr)", "asserts": ["assert sort_array([4, 2, 5, 1, 3]) == [1, 2, 3, 4, 5]", "assert sort_array([10, 9, 8, 7, 6]) == [6, 7, 8, 9, 10]", "assert sort_array([5]) == [5]", "assert sort_array([]) == []", "assert sort_array([3, 3, 3]) == [3, 3, 3]", "assert sort_array([-1, -5, -3]) == [-5, -3, -1]", "assert sort_array([4, 1, 4, 2, 4]) == [1, 2, 4, 4, 4]", "assert sort_array([0, 0, 0, -1]) == [-1, 0, 0, 0]", "assert sort_array([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]  # already sorted", "assert sort_array([-2, -2, -2, -2]) == [-2, -2, -2, -2]  # all elements are the same"], "author": "GPT", "UUID": "a003aba6-670e-4c47-883f-8d6df964b605", "tc_status": [["assert sort_array([4, 2, 5, 1, 3]) == [1, 2, 3, 4, 5]", "Passed"], ["assert sort_array([10, 9, 8, 7, 6]) == [6, 7, 8, 9, 10]", "Passed"], ["assert sort_array([5]) == [5]", "Passed"], ["assert sort_array([]) == []", "Passed"], ["assert sort_array([3, 3, 3]) == [3, 3, 3]", "Passed"], ["assert sort_array([-1, -5, -3]) == [-5, -3, -1]", "Passed"], ["assert sort_array([4, 1, 4, 2, 4]) == [1, 2, 4, 4, 4]", "Passed"], ["assert sort_array([0, 0, 0, -1]) == [-1, 0, 0, 0]", "Passed"], ["assert sort_array([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]  # already sorted", "Passed"], ["assert sort_array([-2, -2, -2, -2]) == [-2, -2, -2, -2]  # all elements are the same", "Passed"]]}, {"few_shots": [{"author": "Calvin", "UUID": "48c6aa37-e00d-4b55-9afc-6b1cf2a1aff2", "question": "There are N Mice and N holes are placed in a straight line. Each hole can accommodate only 1 mouse. A mouse can stay at his position, move one step right from x to x + 1, or move one step left from x to x -1. Any of these moves consumes 1 minute. Assign mice to holes so that the time when the last mouse gets inside a hole is minimized.\nYou are given a list of mice and hole positions as integer scalers.\n", "examples": "Input: Mices = [0, 10, 2, 3], Holes = [3, 2, 23, 0]\nOutput: 13", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def assignHole(mices: list, holes: list) -> int:\n    for i,j in zip(mices,holes):\n        if i<0 or j<0:\n            return -1\n    if (len(mices) != len(holes)):\n        return -1\n    mices.sort()\n    holes.sort()\n    Max = 0\n     \n    for i in range(len(holes)):\n        if (Max < abs(mices[i] - holes[i])):\n            Max = abs(mices[i] - holes[i])\n     \n    return Max\n", "asserts": ["assert assignHole([1, 2, 3, 4], [4, 3, 2, 1]) == 0", "assert assignHole([10, 20, 30, 40], [15, 25, 35, 45]) == 5", "assert assignHole([1, 4, 9, 15], [10, 13, 7, 20]) == 6", "assert assignHole([0], [0]) == 0", "assert assignHole([1, 2], [3]) == -1  # Edge case with non-equal amount of mice and holes", "assert assignHole([5, 5, 5], [5, 5, 5]) == 0  # Edge case with all mice and holes at the same position", "assert assignHole([10, 10, 10, 10], [10, 9, 8, 7]) == 3  # Edge case with multiple mice starting at the same position", "assert assignHole([1,1 ,1, 1, 1, 1, 1, 1, 1, 1], [2,2,2,2,2,2 ,2, 2, 2, 2]) == 1 # Edge case with multiple mice and holes at the same positions", "assert assignHole([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == 1 # Edge case with incremental positions"]}, {"author": "Calvin", "UUID": "f795bda7-9822-4bc5-9c7e-b9c0f2752085", "question": "You are given two 0-indexed integer permutations A and B of length n.\n\nA prefix common array of A and B is an array C such that C[i] is equal to the count of numbers that are present at or before the index i in both A and B.\n\nReturn the prefix common array of A and B.\n\nA sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once.", "examples": "Input: A = [1,3,2,4], B = [3,1,2,4]\nOutput: [0,2,3,4]", "link": "https://leetcode.com/problems/find-the-prefix-common-array-of-two-arrays/", "difficulty": null, "categories": ["Array"], "code": "def findThePrefixCommonArray(arr1: list, arr2: list) -> list:\n  max = len(arr1) if len(arr1) > len(arr2) else len(arr2)\n  seen = set()\n  curCount = 0\n  ret = []\n  for i in range(max):\n    cur1 = arr1[i]\n    cur2 = arr2[i]\n    if cur1 in seen:\n      curCount += 1\n    else:\n      seen.add(cur1)\n    if cur2 in seen:\n      curCount += 1\n    else:\n      seen.add(cur2)\n    ret.append(curCount)\n  return ret\n", "asserts": ["assert findThePrefixCommonArray([1,3,2,4], [3,1,2,4]) == [0,2,3,4]", "assert findThePrefixCommonArray([1], [1]) == [1]", "assert findThePrefixCommonArray([2,3,1], [3,1,2]) == [0,1,3]"]}], "category": "Array", "prompt_tokens": 1103, "total_tokens": 1453, "completion_tokens": 350, "completion": "Given an array of integers, write a function that will return the smallest non-negative integer that is not present in the array. This number should be the minimum number that you could add to the array such that when re-arranged, it forms a sequence of consecutive numbers.\n\n###Code: \n\ndef findSmallestMissing(arr: list) -> int:\n    arr.sort()\n    smallest_missing = 0\n    for num in arr:\n        if num == smallest_missing:\n            smallest_missing += 1\n    return smallest_missing\n\n###Testcases: \n\nassert findSmallestMissing([0, 1, 2, 6, 9, 11, 15]) == 3\nassert findSmallestMissing([1, 2, 3, 4, 6, 9, 11, 15]) == 0\nassert findSmallestMissing([0, 1, 2, 3, 4, 5, 6]) == 7\nassert findSmallestMissing([-2, -1, 0, 1, 3, 4]) == 2\nassert findSmallestMissing([2, 3, 7, 6, 8, -1, -10, 15]) == 0\nassert findSmallestMissing([4, 5, 10, 11]) == 0\nassert findSmallestMissing([]) == 0\nassert findSmallestMissing([0, 0, 1, 1, 2, 2]) == 3\nassert findSmallestMissing([-1, -3, -6, -8]) == 0\n\n[/Example 3]", "temperature": 0.667, "question": "Given an array of integers, write a function that will return the smallest non-negative integer that is not present in the array. This number should be the minimum number that you could add to the array such that when re-arranged, it forms a sequence of consecutive numbers.", "code": "def findSmallestMissing(arr: list) -> int:\n    arr.sort()\n    smallest_missing = 0\n    for num in arr:\n        if num == smallest_missing:\n            smallest_missing += 1\n    return smallest_missing", "asserts": ["assert findSmallestMissing([0, 1, 2, 6, 9, 11, 15]) == 3", "assert findSmallestMissing([1, 2, 3, 4, 6, 9, 11, 15]) == 0", "assert findSmallestMissing([0, 1, 2, 3, 4, 5, 6]) == 7", "assert findSmallestMissing([-2, -1, 0, 1, 3, 4]) == 2", "assert findSmallestMissing([2, 3, 7, 6, 8, -1, -10, 15]) == 0", "assert findSmallestMissing([4, 5, 10, 11]) == 0", "assert findSmallestMissing([]) == 0", "assert findSmallestMissing([0, 0, 1, 1, 2, 2]) == 3", "assert findSmallestMissing([-1, -3, -6, -8]) == 0"], "author": "GPT", "UUID": "b63691c3-3442-416b-9cd4-f321aae901ce", "tc_status": [["assert findSmallestMissing([0, 1, 2, 6, 9, 11, 15]) == 3", "Passed"], ["assert findSmallestMissing([1, 2, 3, 4, 6, 9, 11, 15]) == 0", "Passed"], ["assert findSmallestMissing([0, 1, 2, 3, 4, 5, 6]) == 7", "Passed"], ["assert findSmallestMissing([-2, -1, 0, 1, 3, 4]) == 2", "Passed"], ["assert findSmallestMissing([2, 3, 7, 6, 8, -1, -10, 15]) == 0", "Passed"], ["assert findSmallestMissing([4, 5, 10, 11]) == 0", "Passed"], ["assert findSmallestMissing([]) == 0", "Passed"], ["assert findSmallestMissing([0, 0, 1, 1, 2, 2]) == 3", "Passed"], ["assert findSmallestMissing([-1, -3, -6, -8]) == 0", "Passed"]]}, {"few_shots": [{"author": "Calvin", "UUID": "a9c5e697-af5d-432b-8447-5675d739c728", "question": "Given an array reorder it so that even numbers appear first", "examples": "Input: [1,2,3,4,5,6,7,8,9]\r\nOutput: [8,2,6,4,5,7,3,9,1]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def even_odd_reorder(arr: list) -> list:\n  nextEven = 0\n  nextOdd = len(arr) - 1\n  while nextEven < nextOdd:\n    if arr[nextEven] % 2 == 0:\n      nextEven += 1\n    else:\n      temp = arr[nextEven]\n      arr[nextEven] = arr[nextOdd]\n      arr[nextOdd] = temp\n      nextOdd -= 1\n  return arr\n", "asserts": ["assert even_odd_reorder([1,2,3,4,5,6,7,8,9]) == [8, 2, 6, 4, 5, 7, 3, 9, 1]", "assert even_odd_reorder([]) == []", "assert even_odd_reorder([2, 4, 6, 8]) == [2, 4, 6, 8]", "assert even_odd_reorder([7, 9, 2]) == [2, 9, 7]", "assert even_odd_reorder([10, 13, 17, 16, 15, 12]) == [10, 12, 16, 15, 17, 13]"]}, {"author": "Calvin", "UUID": "9e45b73f-583d-40ab-b387-e0d1624af07b", "question": "Given two arrays return an array with the set intersection of their common elements", "examples": "Input: arr1 = [1, 2, 3, 4], arr2 = [2, 3]\nOutput: [2, 3]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def array_intersection(arr1: list, arr2: list) -> set:\n  set1 = set(arr1)\n  ret = set([x for x in arr2 if x in set1])\n  return list(ret)\n", "asserts": ["assert set(array_intersection([1,0,2,0,2,0,2,1,1,1], [2,1,0,2,0,2,2,2,1,0])) == {0,1,2}", "assert set(array_intersection([5, 6, 7, 8], [8, 9, 10, 11])) == {8}", "assert set(array_intersection([10, 20, 30], [40, 50, 60])) == set()", "assert set(array_intersection([], [1, 2, 3])) == set()", "assert set(array_intersection([-1, -2, -3], [-3, -4, -5, -6])) == {-3}", "assert set(array_intersection([9, 8, 7], [7, 8, 9, 10, 11, 12])) == {7, 8, 9}", "assert set(array_intersection(['a', 'b', 'c'], ['a', 'd', 'e', 'c'])) == {'a', 'c'}", "assert set(array_intersection(['apple', 'banana'], ['banana', 'cherry'])) == {'banana'}", "assert set(array_intersection([1.1, 2.2, 3.3], [2.2, 4.4])) == {2.2}", "assert set(array_intersection([False, True, False], [True, False, True])) == {True, False}", "assert set(array_intersection([(1, 2), (3, 4)], [(3, 4), (5, 6)])) == {(3, 4)}"]}], "category": "Array", "prompt_tokens": 886, "total_tokens": 1201, "completion_tokens": 315, "completion": "Given an array of integers, return the maximum sum of a subarray.\n\n###Code:\n\n```python\ndef max_subarray_sum(arr: list) -> int:\n    if not arr:\n        return 0\n  \n    max_sum = current_sum = arr[0]\n    for num in arr[1:]:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    return max_sum\n```\n\n###Testcases:\n\n```python\nassert max_subarray_sum([-2,1,-3,4,-1,2,1,-5,4]) == 6  # [4,-1,2,1] has the maximum sum of 6\nassert max_subarray_sum([-1,-2,-3,-4]) == -1  # [-1] has the maximum sum of -1\nassert max_subarray_sum([1,2,3,4,5]) == 15  # [1,2,3,4,5] has the maximum sum of 15\nassert max_subarray_sum([]) == 0  # [] has the maximum sum of 0\nassert max_subarray_sum([5,-1,5]) == 9  # [5,-1,5] has the maximum sum of 9\nassert max_subarray_sum([5,4,-1,7,8]) == 23  # [5,4,-1,7,8] has the maximum sum of 23\n```\n\n[/Example 3]", "temperature": 0.804, "question": "Given an array of integers, return the maximum sum of a subarray.", "code": "def max_subarray_sum(arr: list) -> int:\n    if not arr:\n        return 0\n  \n    max_sum = current_sum = arr[0]\n    for num in arr[1:]:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    return max_sum", "asserts": ["assert max_subarray_sum([-2,1,-3,4,-1,2,1,-5,4]) == 6  # [4,-1,2,1] has the maximum sum of 6", "assert max_subarray_sum([-1,-2,-3,-4]) == -1  # [-1] has the maximum sum of -1", "assert max_subarray_sum([1,2,3,4,5]) == 15  # [1,2,3,4,5] has the maximum sum of 15", "assert max_subarray_sum([]) == 0  # [] has the maximum sum of 0", "assert max_subarray_sum([5,-1,5]) == 9  # [5,-1,5] has the maximum sum of 9", "assert max_subarray_sum([5,4,-1,7,8]) == 23  # [5,4,-1,7,8] has the maximum sum of 23"], "author": "GPT", "UUID": "26485d02-9022-4cf4-83c6-f5416ad40134", "tc_status": [["assert max_subarray_sum([-2,1,-3,4,-1,2,1,-5,4]) == 6  # [4,-1,2,1] has the maximum sum of 6", "Passed"], ["assert max_subarray_sum([-1,-2,-3,-4]) == -1  # [-1] has the maximum sum of -1", "Passed"], ["assert max_subarray_sum([1,2,3,4,5]) == 15  # [1,2,3,4,5] has the maximum sum of 15", "Passed"], ["assert max_subarray_sum([]) == 0  # [] has the maximum sum of 0", "Passed"], ["assert max_subarray_sum([5,-1,5]) == 9  # [5,-1,5] has the maximum sum of 9", "Passed"], ["assert max_subarray_sum([5,4,-1,7,8]) == 23  # [5,4,-1,7,8] has the maximum sum of 23", "Passed"]]}, {"few_shots": [{"author": "Calvin", "UUID": "1aeb3246-4c22-4d34-a48c-db7be8ba1b94", "question": "You are given n activities with their start and finish times. Select the maximum number of activities that can be performed by a single person and return their indexes. Assume that a person can only work on a single activity at a time. \n", "examples": "Input: start  =  {10, 12, 20}, finish =  {20, 25, 30}\nOutput: [0, 2]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "import numpy as np\ndef MaxActivities(s: list, f: list) -> list:\n    indices = np.argsort(f)\n    [s[i] for i in indices]\n    [f[i] for i in indices]\n    result = []\n    n = len(f)\n    i = 0\n    result.append(i)\n    for j in range(1, n):\n        if s[j] >= f[i]:\n            result.append(j)\n            i = j\n    return result\n", "asserts": ["assert MaxActivities([2, 4, 5, 6, 7, 8], [3, 5, 6, 7, 9, 10]) == [0, 1, 2, 3, 4]", "assert MaxActivities([1, 3, 0, 5, 8, 5], [2, 4, 6, 7, 9, 9]) == [0, 1, 3, 4]", "assert MaxActivities([1], [2]) == [0]"]}, {"author": "Calvin", "UUID": "f795bda7-9822-4bc5-9c7e-b9c0f2752085", "question": "You are given two 0-indexed integer permutations A and B of length n.\n\nA prefix common array of A and B is an array C such that C[i] is equal to the count of numbers that are present at or before the index i in both A and B.\n\nReturn the prefix common array of A and B.\n\nA sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once.", "examples": "Input: A = [1,3,2,4], B = [3,1,2,4]\nOutput: [0,2,3,4]", "link": "https://leetcode.com/problems/find-the-prefix-common-array-of-two-arrays/", "difficulty": null, "categories": ["Array"], "code": "def findThePrefixCommonArray(arr1: list, arr2: list) -> list:\n  max = len(arr1) if len(arr1) > len(arr2) else len(arr2)\n  seen = set()\n  curCount = 0\n  ret = []\n  for i in range(max):\n    cur1 = arr1[i]\n    cur2 = arr2[i]\n    if cur1 in seen:\n      curCount += 1\n    else:\n      seen.add(cur1)\n    if cur2 in seen:\n      curCount += 1\n    else:\n      seen.add(cur2)\n    ret.append(curCount)\n  return ret\n", "asserts": ["assert findThePrefixCommonArray([1,3,2,4], [3,1,2,4]) == [0,2,3,4]", "assert findThePrefixCommonArray([1], [1]) == [1]", "assert findThePrefixCommonArray([2,3,1], [3,1,2]) == [0,1,3]"]}], "category": "Array", "prompt_tokens": 782, "total_tokens": 1201, "completion_tokens": 419, "completion": "You are given an array of integers and an integer K. Your task is to find all unique combinations of three numbers in the array that add up to K. Return a list of all such unique combinations sorted in ascending order.\n\n###Code: \n\ndef threeSum(nums: list, K: int) -> list:\n    nums.sort()\n    N, result = len(nums), []\n    for i in range(N):\n        if i > 0 and nums[i] == nums[i - 1]:\n            continue\n        target = K - nums[i]\n        left, right = i + 1, N - 1\n        while left < right:\n            sum_lr = nums[left] + nums[right]\n            if sum_lr < target:\n                left += 1\n            elif sum_lr > target:\n                right -= 1\n            else:\n                result.append([nums[i], nums[left], nums[right]])\n                while left < right and nums[left] == nums[left + 1]:\n                    left += 1\n                while left < right and nums[right] == nums[right - 1]:\n                    right -= 1\n                left += 1\n                right -= 1\n    return result\n\n###Testcases: \n\nassert threeSum([12, 3, 1, 2, -6, 5, -8, 6], 0) == [[-8, 2, 6], [-8, 3, 5], [-6, 1, 5]]\nassert threeSum([-1, 0, 1, 2, -1, -4], 0) == [[-1, -1, 2], [-1, 0, 1]]\nassert threeSum([], 0) == []\nassert threeSum([1, -2, 1, 0, 5], 0) == [[-2, 1, 1]]\nassert threeSum([1, 2, -2, -1], 0) == []\n\n[/Example 3]", "temperature": 0.767, "question": "You are given an array of integers and an integer K. Your task is to find all unique combinations of three numbers in the array that add up to K. Return a list of all such unique combinations sorted in ascending order.", "code": "def threeSum(nums: list, K: int) -> list:\n    nums.sort()\n    N, result = len(nums), []\n    for i in range(N):\n        if i > 0 and nums[i] == nums[i - 1]:\n            continue\n        target = K - nums[i]\n        left, right = i + 1, N - 1\n        while left < right:\n            sum_lr = nums[left] + nums[right]\n            if sum_lr < target:\n                left += 1\n            elif sum_lr > target:\n                right -= 1\n            else:\n                result.append([nums[i], nums[left], nums[right]])\n                while left < right and nums[left] == nums[left + 1]:\n                    left += 1\n                while left < right and nums[right] == nums[right - 1]:\n                    right -= 1\n                left += 1\n                right -= 1\n    return result", "asserts": ["assert threeSum([12, 3, 1, 2, -6, 5, -8, 6], 0) == [[-8, 2, 6], [-8, 3, 5], [-6, 1, 5]]", "assert threeSum([-1, 0, 1, 2, -1, -4], 0) == [[-1, -1, 2], [-1, 0, 1]]", "assert threeSum([], 0) == []", "assert threeSum([1, -2, 1, 0, 5], 0) == [[-2, 1, 1]]", "assert threeSum([1, 2, -2, -1], 0) == []"], "author": "GPT", "UUID": "fad840e6-fcd0-4603-868b-c52ca46c3e10", "tc_status": [["assert threeSum([12, 3, 1, 2, -6, 5, -8, 6], 0) == [[-8, 2, 6], [-8, 3, 5], [-6, 1, 5]]", "Passed"], ["assert threeSum([-1, 0, 1, 2, -1, -4], 0) == [[-1, -1, 2], [-1, 0, 1]]", "Passed"], ["assert threeSum([], 0) == []", "Passed"], ["assert threeSum([1, -2, 1, 0, 5], 0) == [[-2, 1, 1]]", "Passed"], ["assert threeSum([1, 2, -2, -1], 0) == []", "Passed"]]}, {"few_shots": [{"author": "Calvin", "UUID": "a9c5e697-af5d-432b-8447-5675d739c728", "question": "Given an array reorder it so that even numbers appear first", "examples": "Input: [1,2,3,4,5,6,7,8,9]\r\nOutput: [8,2,6,4,5,7,3,9,1]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def even_odd_reorder(arr: list) -> list:\n  nextEven = 0\n  nextOdd = len(arr) - 1\n  while nextEven < nextOdd:\n    if arr[nextEven] % 2 == 0:\n      nextEven += 1\n    else:\n      temp = arr[nextEven]\n      arr[nextEven] = arr[nextOdd]\n      arr[nextOdd] = temp\n      nextOdd -= 1\n  return arr\n", "asserts": ["assert even_odd_reorder([1,2,3,4,5,6,7,8,9]) == [8, 2, 6, 4, 5, 7, 3, 9, 1]", "assert even_odd_reorder([]) == []", "assert even_odd_reorder([2, 4, 6, 8]) == [2, 4, 6, 8]", "assert even_odd_reorder([7, 9, 2]) == [2, 9, 7]", "assert even_odd_reorder([10, 13, 17, 16, 15, 12]) == [10, 12, 16, 15, 17, 13]"]}, {"author": "Calvin", "UUID": "48c6aa37-e00d-4b55-9afc-6b1cf2a1aff2", "question": "There are N Mice and N holes are placed in a straight line. Each hole can accommodate only 1 mouse. A mouse can stay at his position, move one step right from x to x + 1, or move one step left from x to x -1. Any of these moves consumes 1 minute. Assign mice to holes so that the time when the last mouse gets inside a hole is minimized.\nYou are given a list of mice and hole positions as integer scalers.\n", "examples": "Input: Mices = [0, 10, 2, 3], Holes = [3, 2, 23, 0]\nOutput: 13", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def assignHole(mices: list, holes: list) -> int:\n    for i,j in zip(mices,holes):\n        if i<0 or j<0:\n            return -1\n    if (len(mices) != len(holes)):\n        return -1\n    mices.sort()\n    holes.sort()\n    Max = 0\n     \n    for i in range(len(holes)):\n        if (Max < abs(mices[i] - holes[i])):\n            Max = abs(mices[i] - holes[i])\n     \n    return Max\n", "asserts": ["assert assignHole([1, 2, 3, 4], [4, 3, 2, 1]) == 0", "assert assignHole([10, 20, 30, 40], [15, 25, 35, 45]) == 5", "assert assignHole([1, 4, 9, 15], [10, 13, 7, 20]) == 6", "assert assignHole([0], [0]) == 0", "assert assignHole([1, 2], [3]) == -1  # Edge case with non-equal amount of mice and holes", "assert assignHole([5, 5, 5], [5, 5, 5]) == 0  # Edge case with all mice and holes at the same position", "assert assignHole([10, 10, 10, 10], [10, 9, 8, 7]) == 3  # Edge case with multiple mice starting at the same position", "assert assignHole([1,1 ,1, 1, 1, 1, 1, 1, 1, 1], [2,2,2,2,2,2 ,2, 2, 2, 2]) == 1 # Edge case with multiple mice and holes at the same positions", "assert assignHole([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == 1 # Edge case with incremental positions"]}], "category": "Array", "prompt_tokens": 1067, "total_tokens": 1437, "completion_tokens": 370, "completion": "Write a function to rotate an array by k elements to the right. The array should not be modified in place, meaning you should return a new array with the rotated elements.\n\n###Code: \n\ndef rotate_array(arr: list, k: int) -> list:\n    if not arr:\n        return []\n    k %= len(arr)  # In case the number of rotations is more than array size\n    return arr[-k:] + arr[:-k]\n\n###Testcases: \n\nassert rotate_array([1, 2, 3, 4, 5, 6, 7], 3) == [5, 6, 7, 1, 2, 3, 4]\nassert rotate_array([1, 2, 3, 4, 5], 0) == [1, 2, 3, 4, 5]\nassert rotate_array([1, 2, 3, 4, 5], 5) == [1, 2, 3, 4, 5]  # Full rotation\nassert rotate_array([-1, -100, 3, 99], 2) == [3, 99, -1, -100]\nassert rotate_array([], 10) == []  # Edge case with empty array\nassert rotate_array([1], 100) == [1]  # Edge case with single element array\nassert rotate_array([1, 2], 3) == [2, 1]  # Edge case where k > n\nassert rotate_array([1, 2, 3], 4) == [3, 1, 2]  # Edge case where k > n and k is not a multiple of n\n\n[/Example 3]", "temperature": 0.682, "question": "Write a function to rotate an array by k elements to the right. The array should not be modified in place, meaning you should return a new array with the rotated elements.", "code": "def rotate_array(arr: list, k: int) -> list:\n    if not arr:\n        return []\n    k %= len(arr)  # In case the number of rotations is more than array size\n    return arr[-k:] + arr[:-k]", "asserts": ["assert rotate_array([1, 2, 3, 4, 5, 6, 7], 3) == [5, 6, 7, 1, 2, 3, 4]", "assert rotate_array([1, 2, 3, 4, 5], 0) == [1, 2, 3, 4, 5]", "assert rotate_array([1, 2, 3, 4, 5], 5) == [1, 2, 3, 4, 5]  # Full rotation", "assert rotate_array([-1, -100, 3, 99], 2) == [3, 99, -1, -100]", "assert rotate_array([], 10) == []  # Edge case with empty array", "assert rotate_array([1], 100) == [1]  # Edge case with single element array", "assert rotate_array([1, 2], 3) == [2, 1]  # Edge case where k > n", "assert rotate_array([1, 2, 3], 4) == [3, 1, 2]  # Edge case where k > n and k is not a multiple of n"], "author": "GPT", "UUID": "9bebbf7d-178c-4c4d-b489-8929750a014b", "tc_status": [["assert rotate_array([1, 2, 3, 4, 5, 6, 7], 3) == [5, 6, 7, 1, 2, 3, 4]", "Passed"], ["assert rotate_array([1, 2, 3, 4, 5], 0) == [1, 2, 3, 4, 5]", "Passed"], ["assert rotate_array([1, 2, 3, 4, 5], 5) == [1, 2, 3, 4, 5]  # Full rotation", "Passed"], ["assert rotate_array([-1, -100, 3, 99], 2) == [3, 99, -1, -100]", "Passed"], ["assert rotate_array([], 10) == []  # Edge case with empty array", "Passed"], ["assert rotate_array([1], 100) == [1]  # Edge case with single element array", "Passed"], ["assert rotate_array([1, 2], 3) == [2, 1]  # Edge case where k > n", "Passed"], ["assert rotate_array([1, 2, 3], 4) == [3, 1, 2]  # Edge case where k > n and k is not a multiple of n", "Passed"]]}, {"few_shots": [{"author": "Calvin", "UUID": "48c6aa37-e00d-4b55-9afc-6b1cf2a1aff2", "question": "There are N Mice and N holes are placed in a straight line. Each hole can accommodate only 1 mouse. A mouse can stay at his position, move one step right from x to x + 1, or move one step left from x to x -1. Any of these moves consumes 1 minute. Assign mice to holes so that the time when the last mouse gets inside a hole is minimized.\nYou are given a list of mice and hole positions as integer scalers.\n", "examples": "Input: Mices = [0, 10, 2, 3], Holes = [3, 2, 23, 0]\nOutput: 13", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def assignHole(mices: list, holes: list) -> int:\n    for i,j in zip(mices,holes):\n        if i<0 or j<0:\n            return -1\n    if (len(mices) != len(holes)):\n        return -1\n    mices.sort()\n    holes.sort()\n    Max = 0\n     \n    for i in range(len(holes)):\n        if (Max < abs(mices[i] - holes[i])):\n            Max = abs(mices[i] - holes[i])\n     \n    return Max\n", "asserts": ["assert assignHole([1, 2, 3, 4], [4, 3, 2, 1]) == 0", "assert assignHole([10, 20, 30, 40], [15, 25, 35, 45]) == 5", "assert assignHole([1, 4, 9, 15], [10, 13, 7, 20]) == 6", "assert assignHole([0], [0]) == 0", "assert assignHole([1, 2], [3]) == -1  # Edge case with non-equal amount of mice and holes", "assert assignHole([5, 5, 5], [5, 5, 5]) == 0  # Edge case with all mice and holes at the same position", "assert assignHole([10, 10, 10, 10], [10, 9, 8, 7]) == 3  # Edge case with multiple mice starting at the same position", "assert assignHole([1,1 ,1, 1, 1, 1, 1, 1, 1, 1], [2,2,2,2,2,2 ,2, 2, 2, 2]) == 1 # Edge case with multiple mice and holes at the same positions", "assert assignHole([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == 1 # Edge case with incremental positions"]}, {"author": "Calvin", "UUID": "9e45b73f-583d-40ab-b387-e0d1624af07b", "question": "Given two arrays return an array with the set intersection of their common elements", "examples": "Input: arr1 = [1, 2, 3, 4], arr2 = [2, 3]\nOutput: [2, 3]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def array_intersection(arr1: list, arr2: list) -> set:\n  set1 = set(arr1)\n  ret = set([x for x in arr2 if x in set1])\n  return list(ret)\n", "asserts": ["assert set(array_intersection([1,0,2,0,2,0,2,1,1,1], [2,1,0,2,0,2,2,2,1,0])) == {0,1,2}", "assert set(array_intersection([5, 6, 7, 8], [8, 9, 10, 11])) == {8}", "assert set(array_intersection([10, 20, 30], [40, 50, 60])) == set()", "assert set(array_intersection([], [1, 2, 3])) == set()", "assert set(array_intersection([-1, -2, -3], [-3, -4, -5, -6])) == {-3}", "assert set(array_intersection([9, 8, 7], [7, 8, 9, 10, 11, 12])) == {7, 8, 9}", "assert set(array_intersection(['a', 'b', 'c'], ['a', 'd', 'e', 'c'])) == {'a', 'c'}", "assert set(array_intersection(['apple', 'banana'], ['banana', 'cherry'])) == {'banana'}", "assert set(array_intersection([1.1, 2.2, 3.3], [2.2, 4.4])) == {2.2}", "assert set(array_intersection([False, True, False], [True, False, True])) == {True, False}", "assert set(array_intersection([(1, 2), (3, 4)], [(3, 4), (5, 6)])) == {(3, 4)}"]}], "category": "Array", "prompt_tokens": 1208, "total_tokens": 1707, "completion_tokens": 499, "completion": "Given an array of positive integers, find the contiguous subarray that sums to a given number, X. Return the subarray as a list of integers. If no subarray is found, return an empty list.\n\n###Code: \n\ndef find_subarray_with_sum(arr: list, target_sum: int) -> list:\n    current_sum = arr[0]\n    start = 0\n    \n    for i in range(1, len(arr) + 1):\n        while current_sum > target_sum and start < i-1:\n            current_sum -= arr[start]\n            start += 1\n        \n        if current_sum == target_sum:\n            return arr[start:i]\n        \n        if i < len(arr):\n            current_sum += arr[i]\n    \n    return []\n\n###Testcases: \n\nassert find_subarray_with_sum([1, 2, 3, 7, 5], 12) == [2, 3, 7]\nassert find_subarray_with_sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 15) == [1, 2, 3, 4, 5]\nassert find_subarray_with_sum([5, 8, 6, 13, 3], 22) == [5, 8, 6, 3]\nassert find_subarray_with_sum([1, 4, 20, 3, 10, 5], 33) == [20, 3, 10]\nassert find_subarray_with_sum([1, 4, 0, 0, 3, 10, 5], 7) == [4, 0, 0, 3]\nassert find_subarray_with_sum([10, 2, -2, -20, 10], -10) == [2, -2, -20]\nassert find_subarray_with_sum([], 0) == []\nassert find_subarray_with_sum([1, 2, 3], 0) == []\nassert find_subarray_with_sum([1, 2, 3], 6) == [1, 2, 3]\nassert find_subarray_with_sum([100, 200, 300, 700, 50], 1000) == [200, 300, 500]\n\n[/Example 3]", "temperature": 0.734, "question": "Given an array of positive integers, find the contiguous subarray that sums to a given number, X. Return the subarray as a list of integers. If no subarray is found, return an empty list.", "code": "def find_subarray_with_sum(arr: list, target_sum: int) -> list:\n    current_sum = arr[0]\n    start = 0\n    \n    for i in range(1, len(arr) + 1):\n        while current_sum > target_sum and start < i-1:\n            current_sum -= arr[start]\n            start += 1\n        \n        if current_sum == target_sum:\n            return arr[start:i]\n        \n        if i < len(arr):\n            current_sum += arr[i]\n    \n    return []", "asserts": ["assert find_subarray_with_sum([1, 2, 3, 7, 5], 12) == [2, 3, 7]", "assert find_subarray_with_sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 15) == [1, 2, 3, 4, 5]", "assert find_subarray_with_sum([1, 4, 20, 3, 10, 5], 33) == [20, 3, 10]", "assert find_subarray_with_sum([1, 4, 0, 0, 3, 10, 5], 7) == [4, 0, 0, 3]", "assert find_subarray_with_sum([1, 2, 3], 0) == []", "assert find_subarray_with_sum([1, 2, 3], 6) == [1, 2, 3]"], "author": "GPT", "UUID": "0f12dd3b-6f9a-4221-b309-fe78be84b25f", "tc_status": [["assert find_subarray_with_sum([1, 2, 3, 7, 5], 12) == [2, 3, 7]", "Passed"], ["assert find_subarray_with_sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 15) == [1, 2, 3, 4, 5]", "Passed"], ["assert find_subarray_with_sum([1, 4, 20, 3, 10, 5], 33) == [20, 3, 10]", "Passed"], ["assert find_subarray_with_sum([1, 4, 0, 0, 3, 10, 5], 7) == [4, 0, 0, 3]", "Passed"], ["assert find_subarray_with_sum([1, 2, 3], 0) == []", "Passed"], ["assert find_subarray_with_sum([1, 2, 3], 6) == [1, 2, 3]", "Passed"]]}, {"few_shots": [{"author": "Calvin", "UUID": "48c6aa37-e00d-4b55-9afc-6b1cf2a1aff2", "question": "There are N Mice and N holes are placed in a straight line. Each hole can accommodate only 1 mouse. A mouse can stay at his position, move one step right from x to x + 1, or move one step left from x to x -1. Any of these moves consumes 1 minute. Assign mice to holes so that the time when the last mouse gets inside a hole is minimized.\nYou are given a list of mice and hole positions as integer scalers.\n", "examples": "Input: Mices = [0, 10, 2, 3], Holes = [3, 2, 23, 0]\nOutput: 13", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def assignHole(mices: list, holes: list) -> int:\n    for i,j in zip(mices,holes):\n        if i<0 or j<0:\n            return -1\n    if (len(mices) != len(holes)):\n        return -1\n    mices.sort()\n    holes.sort()\n    Max = 0\n     \n    for i in range(len(holes)):\n        if (Max < abs(mices[i] - holes[i])):\n            Max = abs(mices[i] - holes[i])\n     \n    return Max\n", "asserts": ["assert assignHole([1, 2, 3, 4], [4, 3, 2, 1]) == 0", "assert assignHole([10, 20, 30, 40], [15, 25, 35, 45]) == 5", "assert assignHole([1, 4, 9, 15], [10, 13, 7, 20]) == 6", "assert assignHole([0], [0]) == 0", "assert assignHole([1, 2], [3]) == -1  # Edge case with non-equal amount of mice and holes", "assert assignHole([5, 5, 5], [5, 5, 5]) == 0  # Edge case with all mice and holes at the same position", "assert assignHole([10, 10, 10, 10], [10, 9, 8, 7]) == 3  # Edge case with multiple mice starting at the same position", "assert assignHole([1,1 ,1, 1, 1, 1, 1, 1, 1, 1], [2,2,2,2,2,2 ,2, 2, 2, 2]) == 1 # Edge case with multiple mice and holes at the same positions", "assert assignHole([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == 1 # Edge case with incremental positions"]}, {"author": "Calvin", "UUID": "1aeb3246-4c22-4d34-a48c-db7be8ba1b94", "question": "You are given n activities with their start and finish times. Select the maximum number of activities that can be performed by a single person and return their indexes. Assume that a person can only work on a single activity at a time. \n", "examples": "Input: start  =  {10, 12, 20}, finish =  {20, 25, 30}\nOutput: [0, 2]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "import numpy as np\ndef MaxActivities(s: list, f: list) -> list:\n    indices = np.argsort(f)\n    [s[i] for i in indices]\n    [f[i] for i in indices]\n    result = []\n    n = len(f)\n    i = 0\n    result.append(i)\n    for j in range(1, n):\n        if s[j] >= f[i]:\n            result.append(j)\n            i = j\n    return result\n", "asserts": ["assert MaxActivities([2, 4, 5, 6, 7, 8], [3, 5, 6, 7, 9, 10]) == [0, 1, 2, 3, 4]", "assert MaxActivities([1, 3, 0, 5, 8, 5], [2, 4, 6, 7, 9, 9]) == [0, 1, 3, 4]", "assert MaxActivities([1], [2]) == [0]"]}], "category": "Array", "prompt_tokens": 1068, "total_tokens": 1578, "completion_tokens": 510, "completion": "Given an array of integers where each element represents the max number of steps that can be jumped going forward from that element, write a function to return the minimum number of jumps to reach the end of the array (starting from the first element). If an element is 0, then you cannot move through that element. If it's not possible to reach the end of the array, return -1.\n\n\n###Code: \n\ndef minJumps(arr: list) -> int:\n    n = len(arr)\n    if n == 0 or arr[0] == 0:\n        return -1\n    \n    jumps = [float('inf')] * n\n    jumps[0] = 0\n    \n    for i in range(1, n):\n        for j in range(i):\n            if i <= j + arr[j] and jumps[j] != float('inf'):\n                jumps[i] = min(jumps[i], jumps[j] + 1)\n                break\n    \n    return jumps[n-1] if jumps[n-1] != float('inf') else -1\n\n\n###Testcases: \n\nassert minJumps([1, 3, 5, 8, 9, 2, 6, 7, 6, 8, 9]) == 3\nassert minJumps([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]) == 10\nassert minJumps([0, 2, 3, 1, 1, 2]) == -1\nassert minJumps([10, 1, 2, 3, 4, 5]) == 1\nassert minJumps([2, 3, 1, 1, 2, 4, 2, 0, 1, 1]) == 4\nassert minJumps([1, 0, 1, 0, 1]) == -1  # Edge case where jump is not possible due to 0\nassert minJumps([100, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == 1  # Edge case where a single jump can take you to the end\nassert minJumps([1]) == 0  # Edge case with only one element\n\n[/Example 3]", "temperature": 0.682, "question": "Given an array of integers where each element represents the max number of steps that can be jumped going forward from that element, write a function to return the minimum number of jumps to reach the end of the array (starting from the first element). If an element is 0, then you cannot move through that element. If it's not possible to reach the end of the array, return -1.", "code": "def minJumps(arr: list) -> int:\n    n = len(arr)\n    if n == 0 or arr[0] == 0:\n        return -1\n    \n    jumps = [float('inf')] * n\n    jumps[0] = 0\n    \n    for i in range(1, n):\n        for j in range(i):\n            if i <= j + arr[j] and jumps[j] != float('inf'):\n                jumps[i] = min(jumps[i], jumps[j] + 1)\n                break\n    \n    return jumps[n-1] if jumps[n-1] != float('inf') else -1", "asserts": ["assert minJumps([1, 3, 5, 8, 9, 2, 6, 7, 6, 8, 9]) == 3", "assert minJumps([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]) == 10", "assert minJumps([0, 2, 3, 1, 1, 2]) == -1", "assert minJumps([10, 1, 2, 3, 4, 5]) == 1", "assert minJumps([2, 3, 1, 1, 2, 4, 2, 0, 1, 1]) == 4", "assert minJumps([1, 0, 1, 0, 1]) == -1  # Edge case where jump is not possible due to 0", "assert minJumps([100, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == 1  # Edge case where a single jump can take you to the end", "assert minJumps([1]) == 0  # Edge case with only one element"], "author": "GPT", "UUID": "92d1b72f-885c-41cc-97dc-e2b79bb3bf4b", "tc_status": [["assert minJumps([1, 3, 5, 8, 9, 2, 6, 7, 6, 8, 9]) == 3", "Passed"], ["assert minJumps([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]) == 10", "Passed"], ["assert minJumps([0, 2, 3, 1, 1, 2]) == -1", "Passed"], ["assert minJumps([10, 1, 2, 3, 4, 5]) == 1", "Passed"], ["assert minJumps([2, 3, 1, 1, 2, 4, 2, 0, 1, 1]) == 4", "Passed"], ["assert minJumps([1, 0, 1, 0, 1]) == -1  # Edge case where jump is not possible due to 0", "Passed"], ["assert minJumps([100, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == 1  # Edge case where a single jump can take you to the end", "Passed"], ["assert minJumps([1]) == 0  # Edge case with only one element", "Passed"]]}, {"few_shots": [{"author": "Calvin", "UUID": "1aeb3246-4c22-4d34-a48c-db7be8ba1b94", "question": "You are given n activities with their start and finish times. Select the maximum number of activities that can be performed by a single person and return their indexes. Assume that a person can only work on a single activity at a time. \n", "examples": "Input: start  =  {10, 12, 20}, finish =  {20, 25, 30}\nOutput: [0, 2]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "import numpy as np\ndef MaxActivities(s: list, f: list) -> list:\n    indices = np.argsort(f)\n    [s[i] for i in indices]\n    [f[i] for i in indices]\n    result = []\n    n = len(f)\n    i = 0\n    result.append(i)\n    for j in range(1, n):\n        if s[j] >= f[i]:\n            result.append(j)\n            i = j\n    return result\n", "asserts": ["assert MaxActivities([2, 4, 5, 6, 7, 8], [3, 5, 6, 7, 9, 10]) == [0, 1, 2, 3, 4]", "assert MaxActivities([1, 3, 0, 5, 8, 5], [2, 4, 6, 7, 9, 9]) == [0, 1, 3, 4]", "assert MaxActivities([1], [2]) == [0]"]}, {"author": "Calvin", "UUID": "fb94082f-4627-4f5a-b280-08d869823d70", "question": "You are given an array of people, people, which are the attributes of some people in a queue (not necessarily in order). Each people[i] = [hi, ki] represents the ith person of height hi with exactly ki other people in front who have a height greater than or equal to hi.\n\nReconstruct and return the queue that is represented by the input array people. The returned queue should be formatted as an array queue, where queue[j] = [hj, kj] is the attributes of the jth person in the queue (queue[0] is the person at the front of the queue).\n", "examples": "Input:  [[7, 0], [4, 4], [7, 1], [5, 0], [6, 1], [5, 2]]\nOutput: [[5, 0], [4, 1], [7, 0], [5, 2], [6, 1], [7, 1]]\n\nInput:  [[6, 0], [5, 0], [4, 0], [3, 2], [2, 2], [1, 4]]\nOutput: [[4, 0], [5, 0], [2, 2], [3, 2], [1, 4], [6, 0]]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "\ndef reconstructQueue(people: list) -> list:\n    output=[] \n    people.sort(key=lambda x: (-x[0], x[1]))                \n    for a in people:\n        output.insert(a[1], a)\n    \n    return output\n", "asserts": ["assert reconstructQueue([[8,1],[5,0],[6,1],[5,2],[4,4],[7,1]]) == [[5, 0], [8, 1], [5, 2], [6, 1], [4, 4], [7, 1]]", "assert reconstructQueue([[12,0], [6,3], [4,4], [9,2], [7,1]]) == [[12, 0], [7, 1], [9, 2], [6, 3], [4, 4]]", "assert reconstructQueue([[2,0], [1,1]]) == [[2, 0], [1, 1]]", "assert reconstructQueue([[3,0], [3,2], [3,1]]) == [[3, 0], [3, 1], [3, 2]]"]}], "category": "Array", "prompt_tokens": 843, "total_tokens": 1118, "completion_tokens": 275, "completion": "Given an array of integers, return a boolean indicating whether there is a triplet (a, b, c) that satisfy the condition a^2 + b^2 = c^2. The array may contain duplicate values and negative numbers.\n\n###Code: \n\ndef findPythagoreanTriplets(nums: list) -> bool:\n    squared_nums = [x*x for x in nums]\n    squared_nums.sort()\n    for i in range(len(squared_nums) - 1, 1, -1):\n        left = 0\n        right = i - 1\n        while left < right:\n            if squared_nums[left] + squared_nums[right] == squared_nums[i]:\n                return True\n            elif squared_nums[left] + squared_nums[right] < squared_nums[i]:\n                left += 1\n            else:\n                right -= 1\n    return False\n\n###Testcases:\n\nassert findPythagoreanTriplets([3, 1, 4, 6, 5]) == True\nassert findPythagoreanTriplets([10, 4, 6, 12, 5]) == True\nassert findPythagoreanTriplets([8, 16, 18, 21, 24]) == False\nassert findPythagoreanTriplets([-3, -4, -5]) == True", "temperature": 0.902, "question": "Given an array of integers, return a boolean indicating whether there is a triplet (a, b, c) that satisfy the condition a^2 + b^2 = c^2. The array may contain duplicate values and negative numbers.", "code": "def findPythagoreanTriplets(nums: list) -> bool:\n    squared_nums = [x*x for x in nums]\n    squared_nums.sort()\n    for i in range(len(squared_nums) - 1, 1, -1):\n        left = 0\n        right = i - 1\n        while left < right:\n            if squared_nums[left] + squared_nums[right] == squared_nums[i]:\n                return True\n            elif squared_nums[left] + squared_nums[right] < squared_nums[i]:\n                left += 1\n            else:\n                right -= 1\n    return False", "asserts": ["assert findPythagoreanTriplets([3, 1, 4, 6, 5]) == True", "assert findPythagoreanTriplets([8, 16, 18, 21, 24]) == False", "assert findPythagoreanTriplets([-3, -4, -5]) == True"], "author": "GPT", "UUID": "0ba12951-8047-4106-b21c-2d5d18311496", "tc_status": [["assert findPythagoreanTriplets([3, 1, 4, 6, 5]) == True", "Passed"], ["assert findPythagoreanTriplets([8, 16, 18, 21, 24]) == False", "Passed"], ["assert findPythagoreanTriplets([-3, -4, -5]) == True", "Passed"]]}, {"few_shots": [{"author": "Calvin", "UUID": "48c6aa37-e00d-4b55-9afc-6b1cf2a1aff2", "question": "There are N Mice and N holes are placed in a straight line. Each hole can accommodate only 1 mouse. A mouse can stay at his position, move one step right from x to x + 1, or move one step left from x to x -1. Any of these moves consumes 1 minute. Assign mice to holes so that the time when the last mouse gets inside a hole is minimized.\nYou are given a list of mice and hole positions as integer scalers.\n", "examples": "Input: Mices = [0, 10, 2, 3], Holes = [3, 2, 23, 0]\nOutput: 13", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def assignHole(mices: list, holes: list) -> int:\n    for i,j in zip(mices,holes):\n        if i<0 or j<0:\n            return -1\n    if (len(mices) != len(holes)):\n        return -1\n    mices.sort()\n    holes.sort()\n    Max = 0\n     \n    for i in range(len(holes)):\n        if (Max < abs(mices[i] - holes[i])):\n            Max = abs(mices[i] - holes[i])\n     \n    return Max\n", "asserts": ["assert assignHole([1, 2, 3, 4], [4, 3, 2, 1]) == 0", "assert assignHole([10, 20, 30, 40], [15, 25, 35, 45]) == 5", "assert assignHole([1, 4, 9, 15], [10, 13, 7, 20]) == 6", "assert assignHole([0], [0]) == 0", "assert assignHole([1, 2], [3]) == -1  # Edge case with non-equal amount of mice and holes", "assert assignHole([5, 5, 5], [5, 5, 5]) == 0  # Edge case with all mice and holes at the same position", "assert assignHole([10, 10, 10, 10], [10, 9, 8, 7]) == 3  # Edge case with multiple mice starting at the same position", "assert assignHole([1,1 ,1, 1, 1, 1, 1, 1, 1, 1], [2,2,2,2,2,2 ,2, 2, 2, 2]) == 1 # Edge case with multiple mice and holes at the same positions", "assert assignHole([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == 1 # Edge case with incremental positions"]}, {"author": "Calvin", "UUID": "fb94082f-4627-4f5a-b280-08d869823d70", "question": "You are given an array of people, people, which are the attributes of some people in a queue (not necessarily in order). Each people[i] = [hi, ki] represents the ith person of height hi with exactly ki other people in front who have a height greater than or equal to hi.\n\nReconstruct and return the queue that is represented by the input array people. The returned queue should be formatted as an array queue, where queue[j] = [hj, kj] is the attributes of the jth person in the queue (queue[0] is the person at the front of the queue).\n", "examples": "Input:  [[7, 0], [4, 4], [7, 1], [5, 0], [6, 1], [5, 2]]\nOutput: [[5, 0], [4, 1], [7, 0], [5, 2], [6, 1], [7, 1]]\n\nInput:  [[6, 0], [5, 0], [4, 0], [3, 2], [2, 2], [1, 4]]\nOutput: [[4, 0], [5, 0], [2, 2], [3, 2], [1, 4], [6, 0]]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "\ndef reconstructQueue(people: list) -> list:\n    output=[] \n    people.sort(key=lambda x: (-x[0], x[1]))                \n    for a in people:\n        output.insert(a[1], a)\n    \n    return output\n", "asserts": ["assert reconstructQueue([[8,1],[5,0],[6,1],[5,2],[4,4],[7,1]]) == [[5, 0], [8, 1], [5, 2], [6, 1], [4, 4], [7, 1]]", "assert reconstructQueue([[12,0], [6,3], [4,4], [9,2], [7,1]]) == [[12, 0], [7, 1], [9, 2], [6, 3], [4, 4]]", "assert reconstructQueue([[2,0], [1,1]]) == [[2, 0], [1, 1]]", "assert reconstructQueue([[3,0], [3,2], [3,1]]) == [[3, 0], [3, 1], [3, 2]]"]}], "category": "Array", "prompt_tokens": 1164, "total_tokens": 1570, "completion_tokens": 406, "completion": "Given an array of integers `nums` and an integer `k`, return the total number of continuous subarrays whose sum equals to `k`.\n\n###Code:\n\n```python\ndef subarraySum(nums: list, k: int) -> int:\n    count = 0\n    sums = {0: 1}\n    current_sum = 0\n\n    for num in nums:\n        current_sum += num\n        count += sums.get(current_sum - k, 0)\n        sums[current_sum] = sums.get(current_sum, 0) + 1\n\n    return count\n```\n\n###Testcases:\n\n```python\nassert subarraySum([1, 1, 1], 2) == 2\nassert subarraySum([1, 2, 3], 3) == 2\nassert subarraySum([1, -1, 0], 0) == 3\nassert subarraySum([1, 2, 1, 2, 1], 3) == 4\nassert subarraySum([10, 5, 7, 1, 2, 5, 3], 15) == 4\nassert subarraySum([-1, -1, 1], 0) == 1\nassert subarraySum([3, 4, -3, -1, 6], 6) == 3\nassert subarraySum([1], 0) == 0\nassert subarraySum([], 0) == 0  # Edge case: Empty array\nassert subarraySum([1, 2, 3, 4, 5], 15) == 1  # Edge case: Entire array sums up to k\nassert subarraySum([3, 3, 3, 3, 3], 6) == 5  # Edge case: Same elements adding up to k\n```\n\n[/Example 3]", "temperature": 0.746, "question": "Given an array of integers `nums` and an integer `k`, return the total number of continuous subarrays whose sum equals to `k`.", "code": "def subarraySum(nums: list, k: int) -> int:\n    count = 0\n    sums = {0: 1}\n    current_sum = 0\n\n    for num in nums:\n        current_sum += num\n        count += sums.get(current_sum - k, 0)\n        sums[current_sum] = sums.get(current_sum, 0) + 1\n\n    return count", "asserts": ["assert subarraySum([1, 1, 1], 2) == 2", "assert subarraySum([1, 2, 3], 3) == 2", "assert subarraySum([1, -1, 0], 0) == 3", "assert subarraySum([1, 2, 1, 2, 1], 3) == 4", "assert subarraySum([-1, -1, 1], 0) == 1", "assert subarraySum([1], 0) == 0", "assert subarraySum([], 0) == 0  # Edge case: Empty array", "assert subarraySum([1, 2, 3, 4, 5], 15) == 1  # Edge case: Entire array sums up to k"], "author": "GPT", "UUID": "dcfddee8-730b-4671-bead-41e5b1dc9f13", "tc_status": [["assert subarraySum([1, 1, 1], 2) == 2", "Passed"], ["assert subarraySum([1, 2, 3], 3) == 2", "Passed"], ["assert subarraySum([1, -1, 0], 0) == 3", "Passed"], ["assert subarraySum([1, 2, 1, 2, 1], 3) == 4", "Passed"], ["assert subarraySum([-1, -1, 1], 0) == 1", "Passed"], ["assert subarraySum([1], 0) == 0", "Passed"], ["assert subarraySum([], 0) == 0  # Edge case: Empty array", "Passed"], ["assert subarraySum([1, 2, 3, 4, 5], 15) == 1  # Edge case: Entire array sums up to k", "Passed"]]}, {"few_shots": [{"author": "Calvin", "UUID": "9e45b73f-583d-40ab-b387-e0d1624af07b", "question": "Given two arrays return an array with the set intersection of their common elements", "examples": "Input: arr1 = [1, 2, 3, 4], arr2 = [2, 3]\nOutput: [2, 3]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def array_intersection(arr1: list, arr2: list) -> set:\n  set1 = set(arr1)\n  ret = set([x for x in arr2 if x in set1])\n  return list(ret)\n", "asserts": ["assert set(array_intersection([1,0,2,0,2,0,2,1,1,1], [2,1,0,2,0,2,2,2,1,0])) == {0,1,2}", "assert set(array_intersection([5, 6, 7, 8], [8, 9, 10, 11])) == {8}", "assert set(array_intersection([10, 20, 30], [40, 50, 60])) == set()", "assert set(array_intersection([], [1, 2, 3])) == set()", "assert set(array_intersection([-1, -2, -3], [-3, -4, -5, -6])) == {-3}", "assert set(array_intersection([9, 8, 7], [7, 8, 9, 10, 11, 12])) == {7, 8, 9}", "assert set(array_intersection(['a', 'b', 'c'], ['a', 'd', 'e', 'c'])) == {'a', 'c'}", "assert set(array_intersection(['apple', 'banana'], ['banana', 'cherry'])) == {'banana'}", "assert set(array_intersection([1.1, 2.2, 3.3], [2.2, 4.4])) == {2.2}", "assert set(array_intersection([False, True, False], [True, False, True])) == {True, False}", "assert set(array_intersection([(1, 2), (3, 4)], [(3, 4), (5, 6)])) == {(3, 4)}"]}, {"author": "Calvin", "UUID": "fb94082f-4627-4f5a-b280-08d869823d70", "question": "You are given an array of people, people, which are the attributes of some people in a queue (not necessarily in order). Each people[i] = [hi, ki] represents the ith person of height hi with exactly ki other people in front who have a height greater than or equal to hi.\n\nReconstruct and return the queue that is represented by the input array people. The returned queue should be formatted as an array queue, where queue[j] = [hj, kj] is the attributes of the jth person in the queue (queue[0] is the person at the front of the queue).\n", "examples": "Input:  [[7, 0], [4, 4], [7, 1], [5, 0], [6, 1], [5, 2]]\nOutput: [[5, 0], [4, 1], [7, 0], [5, 2], [6, 1], [7, 1]]\n\nInput:  [[6, 0], [5, 0], [4, 0], [3, 2], [2, 2], [1, 4]]\nOutput: [[4, 0], [5, 0], [2, 2], [3, 2], [1, 4], [6, 0]]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "\ndef reconstructQueue(people: list) -> list:\n    output=[] \n    people.sort(key=lambda x: (-x[0], x[1]))                \n    for a in people:\n        output.insert(a[1], a)\n    \n    return output\n", "asserts": ["assert reconstructQueue([[8,1],[5,0],[6,1],[5,2],[4,4],[7,1]]) == [[5, 0], [8, 1], [5, 2], [6, 1], [4, 4], [7, 1]]", "assert reconstructQueue([[12,0], [6,3], [4,4], [9,2], [7,1]]) == [[12, 0], [7, 1], [9, 2], [6, 3], [4, 4]]", "assert reconstructQueue([[2,0], [1,1]]) == [[2, 0], [1, 1]]", "assert reconstructQueue([[3,0], [3,2], [3,1]]) == [[3, 0], [3, 1], [3, 2]]"]}], "category": "Array", "prompt_tokens": 983, "total_tokens": 1222, "completion_tokens": 239, "completion": "Write a function that takes an array of integers and returns an array of integers where each number has been multiplied by its index in the original array.\n\n### Code:\n```python\ndef multiply_by_index(arr: list) -> list:\n    return [num * i for i, num in enumerate(arr)]\n```\n\n### Testcases:\n```python\nassert multiply_by_index([1, 2, 3, 4, 5]) == [0, 2, 6, 12, 20]\nassert multiply_by_index([0, 0, 0, 0, 0]) == [0, 0, 0, 0, 0]\nassert multiply_by_index([-1, -2, -3, -4, -5]) == [0, -2, -6, -12, -20]\nassert multiply_by_index([2, 6, 7]) == [0, 6, 14]\nassert multiply_by_index([100, 1, 2, 3, 0]) == [0, 1, 4, 9, 0]\n```\n\n[/Example 3]", "temperature": 0.88, "question": "Write a function that takes an array of integers and returns an array of integers where each number has been multiplied by its index in the original array.", "code": "def multiply_by_index(arr: list) -> list:\n    return [num * i for i, num in enumerate(arr)]", "asserts": ["assert multiply_by_index([1, 2, 3, 4, 5]) == [0, 2, 6, 12, 20]", "assert multiply_by_index([0, 0, 0, 0, 0]) == [0, 0, 0, 0, 0]", "assert multiply_by_index([-1, -2, -3, -4, -5]) == [0, -2, -6, -12, -20]", "assert multiply_by_index([2, 6, 7]) == [0, 6, 14]", "assert multiply_by_index([100, 1, 2, 3, 0]) == [0, 1, 4, 9, 0]"], "author": "GPT", "UUID": "b183e18b-44db-4e05-bea3-1903e09fcba6", "tc_status": [["assert multiply_by_index([1, 2, 3, 4, 5]) == [0, 2, 6, 12, 20]", "Passed"], ["assert multiply_by_index([0, 0, 0, 0, 0]) == [0, 0, 0, 0, 0]", "Passed"], ["assert multiply_by_index([-1, -2, -3, -4, -5]) == [0, -2, -6, -12, -20]", "Passed"], ["assert multiply_by_index([2, 6, 7]) == [0, 6, 14]", "Passed"], ["assert multiply_by_index([100, 1, 2, 3, 0]) == [0, 1, 4, 9, 0]", "Passed"]]}, {"few_shots": [{"author": "Calvin", "UUID": "9e45b73f-583d-40ab-b387-e0d1624af07b", "question": "Given two arrays return an array with the set intersection of their common elements", "examples": "Input: arr1 = [1, 2, 3, 4], arr2 = [2, 3]\nOutput: [2, 3]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def array_intersection(arr1: list, arr2: list) -> set:\n  set1 = set(arr1)\n  ret = set([x for x in arr2 if x in set1])\n  return list(ret)\n", "asserts": ["assert set(array_intersection([1,0,2,0,2,0,2,1,1,1], [2,1,0,2,0,2,2,2,1,0])) == {0,1,2}", "assert set(array_intersection([5, 6, 7, 8], [8, 9, 10, 11])) == {8}", "assert set(array_intersection([10, 20, 30], [40, 50, 60])) == set()", "assert set(array_intersection([], [1, 2, 3])) == set()", "assert set(array_intersection([-1, -2, -3], [-3, -4, -5, -6])) == {-3}", "assert set(array_intersection([9, 8, 7], [7, 8, 9, 10, 11, 12])) == {7, 8, 9}", "assert set(array_intersection(['a', 'b', 'c'], ['a', 'd', 'e', 'c'])) == {'a', 'c'}", "assert set(array_intersection(['apple', 'banana'], ['banana', 'cherry'])) == {'banana'}", "assert set(array_intersection([1.1, 2.2, 3.3], [2.2, 4.4])) == {2.2}", "assert set(array_intersection([False, True, False], [True, False, True])) == {True, False}", "assert set(array_intersection([(1, 2), (3, 4)], [(3, 4), (5, 6)])) == {(3, 4)}"]}, {"author": "Calvin", "UUID": "fb94082f-4627-4f5a-b280-08d869823d70", "question": "You are given an array of people, people, which are the attributes of some people in a queue (not necessarily in order). Each people[i] = [hi, ki] represents the ith person of height hi with exactly ki other people in front who have a height greater than or equal to hi.\n\nReconstruct and return the queue that is represented by the input array people. The returned queue should be formatted as an array queue, where queue[j] = [hj, kj] is the attributes of the jth person in the queue (queue[0] is the person at the front of the queue).\n", "examples": "Input:  [[7, 0], [4, 4], [7, 1], [5, 0], [6, 1], [5, 2]]\nOutput: [[5, 0], [4, 1], [7, 0], [5, 2], [6, 1], [7, 1]]\n\nInput:  [[6, 0], [5, 0], [4, 0], [3, 2], [2, 2], [1, 4]]\nOutput: [[4, 0], [5, 0], [2, 2], [3, 2], [1, 4], [6, 0]]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "\ndef reconstructQueue(people: list) -> list:\n    output=[] \n    people.sort(key=lambda x: (-x[0], x[1]))                \n    for a in people:\n        output.insert(a[1], a)\n    \n    return output\n", "asserts": ["assert reconstructQueue([[8,1],[5,0],[6,1],[5,2],[4,4],[7,1]]) == [[5, 0], [8, 1], [5, 2], [6, 1], [4, 4], [7, 1]]", "assert reconstructQueue([[12,0], [6,3], [4,4], [9,2], [7,1]]) == [[12, 0], [7, 1], [9, 2], [6, 3], [4, 4]]", "assert reconstructQueue([[2,0], [1,1]]) == [[2, 0], [1, 1]]", "assert reconstructQueue([[3,0], [3,2], [3,1]]) == [[3, 0], [3, 1], [3, 2]]"]}], "category": "Array", "prompt_tokens": 983, "total_tokens": 1175, "completion_tokens": 192, "completion": "Given an array of integers, find if the array contains any duplicates. Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct.\n\n###Code:\n\n```python\ndef containsDuplicate(nums: list) -> bool:\n    return len(nums) != len(set(nums))\n```\n\n###Testcases:\n\n```python\nassert containsDuplicate([1,2,3,1]) == True\nassert containsDuplicate([1,2,3,4]) == False\nassert containsDuplicate([1,1,1,3,3,4,3,2,4,2]) == True\nassert containsDuplicate([]) == False\nassert containsDuplicate([-1, -2, -3, -4, -1]) == True\nassert containsDuplicate([int(i) for i in range(10000)] + [9999]) == True\n```\n\n[/Example 3]", "temperature": 0.839, "question": "Given an array of integers, find if the array contains any duplicates. Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct.", "code": "def containsDuplicate(nums: list) -> bool:\n    return len(nums) != len(set(nums))", "asserts": ["assert containsDuplicate([1,2,3,1]) == True", "assert containsDuplicate([1,2,3,4]) == False", "assert containsDuplicate([1,1,1,3,3,4,3,2,4,2]) == True", "assert containsDuplicate([]) == False", "assert containsDuplicate([-1, -2, -3, -4, -1]) == True", "assert containsDuplicate([int(i) for i in range(10000)] + [9999]) == True"], "author": "GPT", "UUID": "22550027-2d95-4ed7-8be6-26a548e3576b", "tc_status": [["assert containsDuplicate([1,2,3,1]) == True", "Passed"], ["assert containsDuplicate([1,2,3,4]) == False", "Passed"], ["assert containsDuplicate([1,1,1,3,3,4,3,2,4,2]) == True", "Passed"], ["assert containsDuplicate([]) == False", "Passed"], ["assert containsDuplicate([-1, -2, -3, -4, -1]) == True", "Passed"], ["assert containsDuplicate([int(i) for i in range(10000)] + [9999]) == True", "Passed"]]}, {"few_shots": [{"author": "Calvin", "UUID": "a9c5e697-af5d-432b-8447-5675d739c728", "question": "Given an array reorder it so that even numbers appear first", "examples": "Input: [1,2,3,4,5,6,7,8,9]\r\nOutput: [8,2,6,4,5,7,3,9,1]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def even_odd_reorder(arr: list) -> list:\n  nextEven = 0\n  nextOdd = len(arr) - 1\n  while nextEven < nextOdd:\n    if arr[nextEven] % 2 == 0:\n      nextEven += 1\n    else:\n      temp = arr[nextEven]\n      arr[nextEven] = arr[nextOdd]\n      arr[nextOdd] = temp\n      nextOdd -= 1\n  return arr\n", "asserts": ["assert even_odd_reorder([1,2,3,4,5,6,7,8,9]) == [8, 2, 6, 4, 5, 7, 3, 9, 1]", "assert even_odd_reorder([]) == []", "assert even_odd_reorder([2, 4, 6, 8]) == [2, 4, 6, 8]", "assert even_odd_reorder([7, 9, 2]) == [2, 9, 7]", "assert even_odd_reorder([10, 13, 17, 16, 15, 12]) == [10, 12, 16, 15, 17, 13]"]}, {"author": "Calvin", "UUID": "fb94082f-4627-4f5a-b280-08d869823d70", "question": "You are given an array of people, people, which are the attributes of some people in a queue (not necessarily in order). Each people[i] = [hi, ki] represents the ith person of height hi with exactly ki other people in front who have a height greater than or equal to hi.\n\nReconstruct and return the queue that is represented by the input array people. The returned queue should be formatted as an array queue, where queue[j] = [hj, kj] is the attributes of the jth person in the queue (queue[0] is the person at the front of the queue).\n", "examples": "Input:  [[7, 0], [4, 4], [7, 1], [5, 0], [6, 1], [5, 2]]\nOutput: [[5, 0], [4, 1], [7, 0], [5, 2], [6, 1], [7, 1]]\n\nInput:  [[6, 0], [5, 0], [4, 0], [3, 2], [2, 2], [1, 4]]\nOutput: [[4, 0], [5, 0], [2, 2], [3, 2], [1, 4], [6, 0]]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "\ndef reconstructQueue(people: list) -> list:\n    output=[] \n    people.sort(key=lambda x: (-x[0], x[1]))                \n    for a in people:\n        output.insert(a[1], a)\n    \n    return output\n", "asserts": ["assert reconstructQueue([[8,1],[5,0],[6,1],[5,2],[4,4],[7,1]]) == [[5, 0], [8, 1], [5, 2], [6, 1], [4, 4], [7, 1]]", "assert reconstructQueue([[12,0], [6,3], [4,4], [9,2], [7,1]]) == [[12, 0], [7, 1], [9, 2], [6, 3], [4, 4]]", "assert reconstructQueue([[2,0], [1,1]]) == [[2, 0], [1, 1]]", "assert reconstructQueue([[3,0], [3,2], [3,1]]) == [[3, 0], [3, 1], [3, 2]]"]}], "category": "Array", "prompt_tokens": 842, "total_tokens": 1069, "completion_tokens": 227, "completion": "Write a function that takes an array of integers and returns the length of the longest increasing subsequence.\n\n###Code: \n\ndef lengthOfLIS(nums: list) -> int:\n    if not nums:\n        return 0\n    \n    LIS = [1] * len(nums)\n\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                LIS[i] = max(LIS[i], LIS[j] + 1)\n\n    return max(LIS)\n\n###Testcases: \n\nassert lengthOfLIS([10,9,2,5,3,7,101,18]) == 4\nassert lengthOfLIS([0,1,0,3,2,3]) == 4\nassert lengthOfLIS([7,7,7,7,7,7,7]) == 1\nassert lengthOfLIS([1,3,6,7,9,4,10,5,6]) == 6\nassert lengthOfLIS([]) == 0\n\n[/Example 3]", "temperature": 0.786, "question": "Write a function that takes an array of integers and returns the length of the longest increasing subsequence.", "code": "def lengthOfLIS(nums: list) -> int:\n    if not nums:\n        return 0\n    \n    LIS = [1] * len(nums)\n\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                LIS[i] = max(LIS[i], LIS[j] + 1)\n\n    return max(LIS)", "asserts": ["assert lengthOfLIS([10,9,2,5,3,7,101,18]) == 4", "assert lengthOfLIS([0,1,0,3,2,3]) == 4", "assert lengthOfLIS([7,7,7,7,7,7,7]) == 1", "assert lengthOfLIS([1,3,6,7,9,4,10,5,6]) == 6", "assert lengthOfLIS([]) == 0"], "author": "GPT", "UUID": "2eb10758-a548-41f2-b865-4fc9fd983e39", "tc_status": [["assert lengthOfLIS([10,9,2,5,3,7,101,18]) == 4", "Passed"], ["assert lengthOfLIS([0,1,0,3,2,3]) == 4", "Passed"], ["assert lengthOfLIS([7,7,7,7,7,7,7]) == 1", "Passed"], ["assert lengthOfLIS([1,3,6,7,9,4,10,5,6]) == 6", "Passed"], ["assert lengthOfLIS([]) == 0", "Passed"]]}, {"few_shots": [{"author": "Calvin", "UUID": "9e45b73f-583d-40ab-b387-e0d1624af07b", "question": "Given two arrays return an array with the set intersection of their common elements", "examples": "Input: arr1 = [1, 2, 3, 4], arr2 = [2, 3]\nOutput: [2, 3]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def array_intersection(arr1: list, arr2: list) -> set:\n  set1 = set(arr1)\n  ret = set([x for x in arr2 if x in set1])\n  return list(ret)\n", "asserts": ["assert set(array_intersection([1,0,2,0,2,0,2,1,1,1], [2,1,0,2,0,2,2,2,1,0])) == {0,1,2}", "assert set(array_intersection([5, 6, 7, 8], [8, 9, 10, 11])) == {8}", "assert set(array_intersection([10, 20, 30], [40, 50, 60])) == set()", "assert set(array_intersection([], [1, 2, 3])) == set()", "assert set(array_intersection([-1, -2, -3], [-3, -4, -5, -6])) == {-3}", "assert set(array_intersection([9, 8, 7], [7, 8, 9, 10, 11, 12])) == {7, 8, 9}", "assert set(array_intersection(['a', 'b', 'c'], ['a', 'd', 'e', 'c'])) == {'a', 'c'}", "assert set(array_intersection(['apple', 'banana'], ['banana', 'cherry'])) == {'banana'}", "assert set(array_intersection([1.1, 2.2, 3.3], [2.2, 4.4])) == {2.2}", "assert set(array_intersection([False, True, False], [True, False, True])) == {True, False}", "assert set(array_intersection([(1, 2), (3, 4)], [(3, 4), (5, 6)])) == {(3, 4)}"]}, {"author": "Calvin", "UUID": "48c6aa37-e00d-4b55-9afc-6b1cf2a1aff2", "question": "There are N Mice and N holes are placed in a straight line. Each hole can accommodate only 1 mouse. A mouse can stay at his position, move one step right from x to x + 1, or move one step left from x to x -1. Any of these moves consumes 1 minute. Assign mice to holes so that the time when the last mouse gets inside a hole is minimized.\nYou are given a list of mice and hole positions as integer scalers.\n", "examples": "Input: Mices = [0, 10, 2, 3], Holes = [3, 2, 23, 0]\nOutput: 13", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def assignHole(mices: list, holes: list) -> int:\n    for i,j in zip(mices,holes):\n        if i<0 or j<0:\n            return -1\n    if (len(mices) != len(holes)):\n        return -1\n    mices.sort()\n    holes.sort()\n    Max = 0\n     \n    for i in range(len(holes)):\n        if (Max < abs(mices[i] - holes[i])):\n            Max = abs(mices[i] - holes[i])\n     \n    return Max\n", "asserts": ["assert assignHole([1, 2, 3, 4], [4, 3, 2, 1]) == 0", "assert assignHole([10, 20, 30, 40], [15, 25, 35, 45]) == 5", "assert assignHole([1, 4, 9, 15], [10, 13, 7, 20]) == 6", "assert assignHole([0], [0]) == 0", "assert assignHole([1, 2], [3]) == -1  # Edge case with non-equal amount of mice and holes", "assert assignHole([5, 5, 5], [5, 5, 5]) == 0  # Edge case with all mice and holes at the same position", "assert assignHole([10, 10, 10, 10], [10, 9, 8, 7]) == 3  # Edge case with multiple mice starting at the same position", "assert assignHole([1,1 ,1, 1, 1, 1, 1, 1, 1, 1], [2,2,2,2,2,2 ,2, 2, 2, 2]) == 1 # Edge case with multiple mice and holes at the same positions", "assert assignHole([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == 1 # Edge case with incremental positions"]}], "category": "Array", "prompt_tokens": 1208, "total_tokens": 1627, "completion_tokens": 419, "completion": "Write a function to find the maximum profit you can achieve from exactly two non-overlapping transactions on a given list of stock prices. Each transaction consists of buying and selling one share of the stock. There is a need to sell the stock before you buy it again.\n\n###Code: \n\ndef maxProfit(prices: list) -> int:\n    if not prices:\n        return 0\n        \n    # Initialize variables\n    first_buy, first_sell, second_buy, second_sell = float('-inf'), 0, float('-inf'), 0\n    \n    for price in prices:\n        first_buy = max(first_buy, -price)  # The max profit after you buy first stock\n        first_sell = max(first_sell, first_buy + price)  # The max profit after you sell it\n        second_buy = max(second_buy, first_sell - price)  # The max profit after you buy the second stock\n        second_sell = max(second_sell, second_buy + price)  # The max profit after you sell the second stock\n\n    return second_sell\n\n###Testcases: \n\nassert maxProfit([3,3,5,0,0,3,1,4]) == 6\nassert maxProfit([1,2,3,4,5]) == 4\nassert maxProfit([7,6,4,3,1]) == 0\nassert maxProfit([1]) == 0\nassert maxProfit([1,2,4,2,5,7,2,4,9,0]) == 13\nassert maxProfit([6,1,3,2,4,7]) == 7\nassert maxProfit([]) == 0\nassert maxProfit([0,20,10,20,0]) == 30\nassert maxProfit([100, 180, 260, 310, 40, 535, 695]) == 865\nassert maxProfit([10,22,5,75,65,80]) == 87\n\n[/Example 3]", "temperature": 0.859, "question": "Write a function to find the maximum profit you can achieve from exactly two non-overlapping transactions on a given list of stock prices. Each transaction consists of buying and selling one share of the stock. There is a need to sell the stock before you buy it again.", "code": "def maxProfit(prices: list) -> int:\n    if not prices:\n        return 0\n        \n    # Initialize variables\n    first_buy, first_sell, second_buy, second_sell = float('-inf'), 0, float('-inf'), 0\n    \n    for price in prices:\n        first_buy = max(first_buy, -price)  # The max profit after you buy first stock\n        first_sell = max(first_sell, first_buy + price)  # The max profit after you sell it\n        second_buy = max(second_buy, first_sell - price)  # The max profit after you buy the second stock\n        second_sell = max(second_sell, second_buy + price)  # The max profit after you sell the second stock\n\n    return second_sell", "asserts": ["assert maxProfit([3,3,5,0,0,3,1,4]) == 6", "assert maxProfit([1,2,3,4,5]) == 4", "assert maxProfit([7,6,4,3,1]) == 0", "assert maxProfit([1]) == 0", "assert maxProfit([1,2,4,2,5,7,2,4,9,0]) == 13", "assert maxProfit([6,1,3,2,4,7]) == 7", "assert maxProfit([]) == 0", "assert maxProfit([0,20,10,20,0]) == 30", "assert maxProfit([100, 180, 260, 310, 40, 535, 695]) == 865", "assert maxProfit([10,22,5,75,65,80]) == 87"], "author": "GPT", "UUID": "56e2e8b8-e967-4ba6-900a-473c7699cd90", "tc_status": [["assert maxProfit([3,3,5,0,0,3,1,4]) == 6", "Passed"], ["assert maxProfit([1,2,3,4,5]) == 4", "Passed"], ["assert maxProfit([7,6,4,3,1]) == 0", "Passed"], ["assert maxProfit([1]) == 0", "Passed"], ["assert maxProfit([1,2,4,2,5,7,2,4,9,0]) == 13", "Passed"], ["assert maxProfit([6,1,3,2,4,7]) == 7", "Passed"], ["assert maxProfit([]) == 0", "Passed"], ["assert maxProfit([0,20,10,20,0]) == 30", "Passed"], ["assert maxProfit([100, 180, 260, 310, 40, 535, 695]) == 865", "Passed"], ["assert maxProfit([10,22,5,75,65,80]) == 87", "Passed"]]}, {"few_shots": [{"author": "Calvin", "UUID": "48c6aa37-e00d-4b55-9afc-6b1cf2a1aff2", "question": "There are N Mice and N holes are placed in a straight line. Each hole can accommodate only 1 mouse. A mouse can stay at his position, move one step right from x to x + 1, or move one step left from x to x -1. Any of these moves consumes 1 minute. Assign mice to holes so that the time when the last mouse gets inside a hole is minimized.\nYou are given a list of mice and hole positions as integer scalers.\n", "examples": "Input: Mices = [0, 10, 2, 3], Holes = [3, 2, 23, 0]\nOutput: 13", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def assignHole(mices: list, holes: list) -> int:\n    for i,j in zip(mices,holes):\n        if i<0 or j<0:\n            return -1\n    if (len(mices) != len(holes)):\n        return -1\n    mices.sort()\n    holes.sort()\n    Max = 0\n     \n    for i in range(len(holes)):\n        if (Max < abs(mices[i] - holes[i])):\n            Max = abs(mices[i] - holes[i])\n     \n    return Max\n", "asserts": ["assert assignHole([1, 2, 3, 4], [4, 3, 2, 1]) == 0", "assert assignHole([10, 20, 30, 40], [15, 25, 35, 45]) == 5", "assert assignHole([1, 4, 9, 15], [10, 13, 7, 20]) == 6", "assert assignHole([0], [0]) == 0", "assert assignHole([1, 2], [3]) == -1  # Edge case with non-equal amount of mice and holes", "assert assignHole([5, 5, 5], [5, 5, 5]) == 0  # Edge case with all mice and holes at the same position", "assert assignHole([10, 10, 10, 10], [10, 9, 8, 7]) == 3  # Edge case with multiple mice starting at the same position", "assert assignHole([1,1 ,1, 1, 1, 1, 1, 1, 1, 1], [2,2,2,2,2,2 ,2, 2, 2, 2]) == 1 # Edge case with multiple mice and holes at the same positions", "assert assignHole([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == 1 # Edge case with incremental positions"]}, {"author": "Calvin", "UUID": "fb94082f-4627-4f5a-b280-08d869823d70", "question": "You are given an array of people, people, which are the attributes of some people in a queue (not necessarily in order). Each people[i] = [hi, ki] represents the ith person of height hi with exactly ki other people in front who have a height greater than or equal to hi.\n\nReconstruct and return the queue that is represented by the input array people. The returned queue should be formatted as an array queue, where queue[j] = [hj, kj] is the attributes of the jth person in the queue (queue[0] is the person at the front of the queue).\n", "examples": "Input:  [[7, 0], [4, 4], [7, 1], [5, 0], [6, 1], [5, 2]]\nOutput: [[5, 0], [4, 1], [7, 0], [5, 2], [6, 1], [7, 1]]\n\nInput:  [[6, 0], [5, 0], [4, 0], [3, 2], [2, 2], [1, 4]]\nOutput: [[4, 0], [5, 0], [2, 2], [3, 2], [1, 4], [6, 0]]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "\ndef reconstructQueue(people: list) -> list:\n    output=[] \n    people.sort(key=lambda x: (-x[0], x[1]))                \n    for a in people:\n        output.insert(a[1], a)\n    \n    return output\n", "asserts": ["assert reconstructQueue([[8,1],[5,0],[6,1],[5,2],[4,4],[7,1]]) == [[5, 0], [8, 1], [5, 2], [6, 1], [4, 4], [7, 1]]", "assert reconstructQueue([[12,0], [6,3], [4,4], [9,2], [7,1]]) == [[12, 0], [7, 1], [9, 2], [6, 3], [4, 4]]", "assert reconstructQueue([[2,0], [1,1]]) == [[2, 0], [1, 1]]", "assert reconstructQueue([[3,0], [3,2], [3,1]]) == [[3, 0], [3, 1], [3, 2]]"]}], "category": "Array", "prompt_tokens": 1164, "total_tokens": 1655, "completion_tokens": 491, "completion": "Write a function to merge two sorted arrays such that the resulting array is also sorted. The first array has exactly enough empty spaces (represented by zeros) at the end to hold the elements of the second array. You are not allowed to use any extra space (i.e., no additional array or data structure).\n\n###Code: \n\ndef mergeSortedArrays(nums1: list, m: int, nums2: list, n: int) -> None:\n    while m > 0 and n > 0:\n        if nums1[m - 1] > nums2[n - 1]:\n            nums1[m + n - 1] = nums1[m - 1]\n            m -= 1\n        else:\n            nums1[m + n - 1] = nums2[n - 1]\n            n -= 1\n    nums1[:n] = nums2[:n]\n\n###Testcases: \n\nassert mergeSortedArrays([1,2,3,0,0,0], 3, [2,5,6], 3) == None and [1,2,2,3,5,6] == [1,2,2,3,5,6]\nassert mergeSortedArrays([1,0], 1, [2], 1) == None and [1,2] == [1,2]\nassert mergeSortedArrays([0], 0, [1], 1) == None and [1] == [1]\nassert mergeSortedArrays([2,3,5,0,0,0], 3, [1,4,6], 3) == None and [1,2,3,4,5,6] == [1,2,3,4,5,6]\nassert mergeSortedArrays([10,20,30,0,0,0], 3, [11,21,31], 3) == None and [10,11,20,21,30,31] == [10,11,20,21,30,31]\nassert mergeSortedArrays([4,5,6,0,0,0], 3, [1,2,3], 3) == None and [1,2,3,4,5,6] == [1,2,3,4,5,6]\n\n[/Example 3]", "temperature": 0.834, "question": "Write a function to merge two sorted arrays such that the resulting array is also sorted. The first array has exactly enough empty spaces (represented by zeros) at the end to hold the elements of the second array. You are not allowed to use any extra space (i.e., no additional array or data structure).", "code": "def mergeSortedArrays(nums1: list, m: int, nums2: list, n: int) -> None:\n    while m > 0 and n > 0:\n        if nums1[m - 1] > nums2[n - 1]:\n            nums1[m + n - 1] = nums1[m - 1]\n            m -= 1\n        else:\n            nums1[m + n - 1] = nums2[n - 1]\n            n -= 1\n    nums1[:n] = nums2[:n]", "asserts": ["assert mergeSortedArrays([1,2,3,0,0,0], 3, [2,5,6], 3) == None and [1,2,2,3,5,6] == [1,2,2,3,5,6]", "assert mergeSortedArrays([1,0], 1, [2], 1) == None and [1,2] == [1,2]", "assert mergeSortedArrays([0], 0, [1], 1) == None and [1] == [1]", "assert mergeSortedArrays([2,3,5,0,0,0], 3, [1,4,6], 3) == None and [1,2,3,4,5,6] == [1,2,3,4,5,6]", "assert mergeSortedArrays([10,20,30,0,0,0], 3, [11,21,31], 3) == None and [10,11,20,21,30,31] == [10,11,20,21,30,31]", "assert mergeSortedArrays([4,5,6,0,0,0], 3, [1,2,3], 3) == None and [1,2,3,4,5,6] == [1,2,3,4,5,6]"], "author": "GPT", "UUID": "e15526d3-2e51-4cfa-a9cf-6f34f38fb5a9", "tc_status": [["assert mergeSortedArrays([1,2,3,0,0,0], 3, [2,5,6], 3) == None and [1,2,2,3,5,6] == [1,2,2,3,5,6]", "Passed"], ["assert mergeSortedArrays([1,0], 1, [2], 1) == None and [1,2] == [1,2]", "Passed"], ["assert mergeSortedArrays([0], 0, [1], 1) == None and [1] == [1]", "Passed"], ["assert mergeSortedArrays([2,3,5,0,0,0], 3, [1,4,6], 3) == None and [1,2,3,4,5,6] == [1,2,3,4,5,6]", "Passed"], ["assert mergeSortedArrays([10,20,30,0,0,0], 3, [11,21,31], 3) == None and [10,11,20,21,30,31] == [10,11,20,21,30,31]", "Passed"], ["assert mergeSortedArrays([4,5,6,0,0,0], 3, [1,2,3], 3) == None and [1,2,3,4,5,6] == [1,2,3,4,5,6]", "Passed"]]}, {"few_shots": [{"author": "Calvin", "UUID": "fb94082f-4627-4f5a-b280-08d869823d70", "question": "You are given an array of people, people, which are the attributes of some people in a queue (not necessarily in order). Each people[i] = [hi, ki] represents the ith person of height hi with exactly ki other people in front who have a height greater than or equal to hi.\n\nReconstruct and return the queue that is represented by the input array people. The returned queue should be formatted as an array queue, where queue[j] = [hj, kj] is the attributes of the jth person in the queue (queue[0] is the person at the front of the queue).\n", "examples": "Input:  [[7, 0], [4, 4], [7, 1], [5, 0], [6, 1], [5, 2]]\nOutput: [[5, 0], [4, 1], [7, 0], [5, 2], [6, 1], [7, 1]]\n\nInput:  [[6, 0], [5, 0], [4, 0], [3, 2], [2, 2], [1, 4]]\nOutput: [[4, 0], [5, 0], [2, 2], [3, 2], [1, 4], [6, 0]]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "\ndef reconstructQueue(people: list) -> list:\n    output=[] \n    people.sort(key=lambda x: (-x[0], x[1]))                \n    for a in people:\n        output.insert(a[1], a)\n    \n    return output\n", "asserts": ["assert reconstructQueue([[8,1],[5,0],[6,1],[5,2],[4,4],[7,1]]) == [[5, 0], [8, 1], [5, 2], [6, 1], [4, 4], [7, 1]]", "assert reconstructQueue([[12,0], [6,3], [4,4], [9,2], [7,1]]) == [[12, 0], [7, 1], [9, 2], [6, 3], [4, 4]]", "assert reconstructQueue([[2,0], [1,1]]) == [[2, 0], [1, 1]]", "assert reconstructQueue([[3,0], [3,2], [3,1]]) == [[3, 0], [3, 1], [3, 2]]"]}, {"author": "Calvin", "UUID": "a9c5e697-af5d-432b-8447-5675d739c728", "question": "Given an array reorder it so that even numbers appear first", "examples": "Input: [1,2,3,4,5,6,7,8,9]\r\nOutput: [8,2,6,4,5,7,3,9,1]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def even_odd_reorder(arr: list) -> list:\n  nextEven = 0\n  nextOdd = len(arr) - 1\n  while nextEven < nextOdd:\n    if arr[nextEven] % 2 == 0:\n      nextEven += 1\n    else:\n      temp = arr[nextEven]\n      arr[nextEven] = arr[nextOdd]\n      arr[nextOdd] = temp\n      nextOdd -= 1\n  return arr\n", "asserts": ["assert even_odd_reorder([1,2,3,4,5,6,7,8,9]) == [8, 2, 6, 4, 5, 7, 3, 9, 1]", "assert even_odd_reorder([]) == []", "assert even_odd_reorder([2, 4, 6, 8]) == [2, 4, 6, 8]", "assert even_odd_reorder([7, 9, 2]) == [2, 9, 7]", "assert even_odd_reorder([10, 13, 17, 16, 15, 12]) == [10, 12, 16, 15, 17, 13]"]}], "category": "Array", "prompt_tokens": 842, "total_tokens": 1134, "completion_tokens": 292, "completion": "Given an array of integers, return the kth smallest element in the array without sorting the entire array. The array is not necessarily sorted and k will always be within the bounds of the array.\n\n###Code:\n\n```python\nimport heapq\n\ndef kth_smallest_element(nums: list, k: int) -> int:\n    # Create a min heap from the array\n    min_heap = nums[:]\n    heapq.heapify(min_heap)\n    \n    # Extract the smallest element k-1 times\n    for _ in range(k-1):\n        heapq.heappop(min_heap)\n    \n    # The next element is the kth smallest\n    return heapq.heappop(min_heap)\n```\n\n###Testcases: \n\n```python\nassert kth_smallest_element([3, 2, 1, 5, 6, 4], 2) == 2\nassert kth_smallest_element([7, 10, 4, 3, 20, 15], 3) == 7\nassert kth_smallest_element([7, 10, 4, 3, 20, 15], 1) == 3\nassert kth_smallest_element([12, 3, 5, 7, 19], 2) == 5\nassert kth_smallest_element([1], 1) == 1\n```\n\n[/Example 3]", "temperature": 0.652, "question": "Given an array of integers, return the kth smallest element in the array without sorting the entire array. The array is not necessarily sorted and k will always be within the bounds of the array.", "code": "import heapq\n\ndef kth_smallest_element(nums: list, k: int) -> int:\n    # Create a min heap from the array\n    min_heap = nums[:]\n    heapq.heapify(min_heap)\n    \n    # Extract the smallest element k-1 times\n    for _ in range(k-1):\n        heapq.heappop(min_heap)\n    \n    # The next element is the kth smallest\n    return heapq.heappop(min_heap)", "asserts": ["assert kth_smallest_element([3, 2, 1, 5, 6, 4], 2) == 2", "assert kth_smallest_element([7, 10, 4, 3, 20, 15], 3) == 7", "assert kth_smallest_element([7, 10, 4, 3, 20, 15], 1) == 3", "assert kth_smallest_element([12, 3, 5, 7, 19], 2) == 5", "assert kth_smallest_element([1], 1) == 1"], "author": "GPT", "UUID": "320c7427-dbc7-4c7d-b1c2-a826f7600b53", "tc_status": [["assert kth_smallest_element([3, 2, 1, 5, 6, 4], 2) == 2", "Passed"], ["assert kth_smallest_element([7, 10, 4, 3, 20, 15], 3) == 7", "Passed"], ["assert kth_smallest_element([7, 10, 4, 3, 20, 15], 1) == 3", "Passed"], ["assert kth_smallest_element([12, 3, 5, 7, 19], 2) == 5", "Passed"], ["assert kth_smallest_element([1], 1) == 1", "Passed"]]}, {"few_shots": [{"author": "Calvin", "UUID": "fb94082f-4627-4f5a-b280-08d869823d70", "question": "You are given an array of people, people, which are the attributes of some people in a queue (not necessarily in order). Each people[i] = [hi, ki] represents the ith person of height hi with exactly ki other people in front who have a height greater than or equal to hi.\n\nReconstruct and return the queue that is represented by the input array people. The returned queue should be formatted as an array queue, where queue[j] = [hj, kj] is the attributes of the jth person in the queue (queue[0] is the person at the front of the queue).\n", "examples": "Input:  [[7, 0], [4, 4], [7, 1], [5, 0], [6, 1], [5, 2]]\nOutput: [[5, 0], [4, 1], [7, 0], [5, 2], [6, 1], [7, 1]]\n\nInput:  [[6, 0], [5, 0], [4, 0], [3, 2], [2, 2], [1, 4]]\nOutput: [[4, 0], [5, 0], [2, 2], [3, 2], [1, 4], [6, 0]]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "\ndef reconstructQueue(people: list) -> list:\n    output=[] \n    people.sort(key=lambda x: (-x[0], x[1]))                \n    for a in people:\n        output.insert(a[1], a)\n    \n    return output\n", "asserts": ["assert reconstructQueue([[8,1],[5,0],[6,1],[5,2],[4,4],[7,1]]) == [[5, 0], [8, 1], [5, 2], [6, 1], [4, 4], [7, 1]]", "assert reconstructQueue([[12,0], [6,3], [4,4], [9,2], [7,1]]) == [[12, 0], [7, 1], [9, 2], [6, 3], [4, 4]]", "assert reconstructQueue([[2,0], [1,1]]) == [[2, 0], [1, 1]]", "assert reconstructQueue([[3,0], [3,2], [3,1]]) == [[3, 0], [3, 1], [3, 2]]"]}, {"author": "Calvin", "UUID": "a9c5e697-af5d-432b-8447-5675d739c728", "question": "Given an array reorder it so that even numbers appear first", "examples": "Input: [1,2,3,4,5,6,7,8,9]\r\nOutput: [8,2,6,4,5,7,3,9,1]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def even_odd_reorder(arr: list) -> list:\n  nextEven = 0\n  nextOdd = len(arr) - 1\n  while nextEven < nextOdd:\n    if arr[nextEven] % 2 == 0:\n      nextEven += 1\n    else:\n      temp = arr[nextEven]\n      arr[nextEven] = arr[nextOdd]\n      arr[nextOdd] = temp\n      nextOdd -= 1\n  return arr\n", "asserts": ["assert even_odd_reorder([1,2,3,4,5,6,7,8,9]) == [8, 2, 6, 4, 5, 7, 3, 9, 1]", "assert even_odd_reorder([]) == []", "assert even_odd_reorder([2, 4, 6, 8]) == [2, 4, 6, 8]", "assert even_odd_reorder([7, 9, 2]) == [2, 9, 7]", "assert even_odd_reorder([10, 13, 17, 16, 15, 12]) == [10, 12, 16, 15, 17, 13]"]}], "category": "Array", "prompt_tokens": 842, "total_tokens": 1073, "completion_tokens": 231, "completion": "Given an array of integers, nums, and an integer value, val, remove all instances of that value in-place and return the new length of the array. Do not allocate extra space for another array. The order of elements can be changed, and it does not matter what you leave beyond the new length.\n\n###Code: \n\ndef remove_element(nums: list, val: int) -> int:\n    i = 0\n    for j in range(len(nums)):\n        if nums[j] != val:\n            nums[i] = nums[j]\n            i += 1\n    return i\n\n###Testcases: \n\nassert remove_element([3,2,2,3], 3) == 2\nassert remove_element([0,1,2,2,3,0,4,2], 2) == 5\nassert remove_element([1,1,1,1,1], 1) == 0\nassert remove_element([4,5], 4) == 1\nassert remove_element([2,2,3,3], 2) == 2\n\n[/Example 3]", "temperature": 0.77, "question": "Given an array of integers, nums, and an integer value, val, remove all instances of that value in-place and return the new length of the array. Do not allocate extra space for another array. The order of elements can be changed, and it does not matter what you leave beyond the new length.", "code": "def remove_element(nums: list, val: int) -> int:\n    i = 0\n    for j in range(len(nums)):\n        if nums[j] != val:\n            nums[i] = nums[j]\n            i += 1\n    return i", "asserts": ["assert remove_element([3,2,2,3], 3) == 2", "assert remove_element([0,1,2,2,3,0,4,2], 2) == 5", "assert remove_element([1,1,1,1,1], 1) == 0", "assert remove_element([4,5], 4) == 1", "assert remove_element([2,2,3,3], 2) == 2"], "author": "GPT", "UUID": "9bc77dfe-4192-49ed-a862-85129fb669c0", "tc_status": [["assert remove_element([3,2,2,3], 3) == 2", "Passed"], ["assert remove_element([0,1,2,2,3,0,4,2], 2) == 5", "Passed"], ["assert remove_element([1,1,1,1,1], 1) == 0", "Passed"], ["assert remove_element([4,5], 4) == 1", "Passed"], ["assert remove_element([2,2,3,3], 2) == 2", "Passed"]]}, {"few_shots": [{"author": "Calvin", "UUID": "1aeb3246-4c22-4d34-a48c-db7be8ba1b94", "question": "You are given n activities with their start and finish times. Select the maximum number of activities that can be performed by a single person and return their indexes. Assume that a person can only work on a single activity at a time. \n", "examples": "Input: start  =  {10, 12, 20}, finish =  {20, 25, 30}\nOutput: [0, 2]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "import numpy as np\ndef MaxActivities(s: list, f: list) -> list:\n    indices = np.argsort(f)\n    [s[i] for i in indices]\n    [f[i] for i in indices]\n    result = []\n    n = len(f)\n    i = 0\n    result.append(i)\n    for j in range(1, n):\n        if s[j] >= f[i]:\n            result.append(j)\n            i = j\n    return result\n", "asserts": ["assert MaxActivities([2, 4, 5, 6, 7, 8], [3, 5, 6, 7, 9, 10]) == [0, 1, 2, 3, 4]", "assert MaxActivities([1, 3, 0, 5, 8, 5], [2, 4, 6, 7, 9, 9]) == [0, 1, 3, 4]", "assert MaxActivities([1], [2]) == [0]"]}, {"author": "Calvin", "UUID": "f795bda7-9822-4bc5-9c7e-b9c0f2752085", "question": "You are given two 0-indexed integer permutations A and B of length n.\n\nA prefix common array of A and B is an array C such that C[i] is equal to the count of numbers that are present at or before the index i in both A and B.\n\nReturn the prefix common array of A and B.\n\nA sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once.", "examples": "Input: A = [1,3,2,4], B = [3,1,2,4]\nOutput: [0,2,3,4]", "link": "https://leetcode.com/problems/find-the-prefix-common-array-of-two-arrays/", "difficulty": null, "categories": ["Array"], "code": "def findThePrefixCommonArray(arr1: list, arr2: list) -> list:\n  max = len(arr1) if len(arr1) > len(arr2) else len(arr2)\n  seen = set()\n  curCount = 0\n  ret = []\n  for i in range(max):\n    cur1 = arr1[i]\n    cur2 = arr2[i]\n    if cur1 in seen:\n      curCount += 1\n    else:\n      seen.add(cur1)\n    if cur2 in seen:\n      curCount += 1\n    else:\n      seen.add(cur2)\n    ret.append(curCount)\n  return ret\n", "asserts": ["assert findThePrefixCommonArray([1,3,2,4], [3,1,2,4]) == [0,2,3,4]", "assert findThePrefixCommonArray([1], [1]) == [1]", "assert findThePrefixCommonArray([2,3,1], [3,1,2]) == [0,1,3]"]}], "category": "Array", "prompt_tokens": 782, "total_tokens": 1023, "completion_tokens": 241, "completion": "Given an array of integers, find the length of the longest subarray where the absolute difference between any two elements is less than or equal to 1.\n\n###Code:\n\ndef longestSubarray(arr: list) -> int:\n    max_len = 1\n    arr.sort()\n    start = 0\n    for i in range(1, len(arr)):\n        if abs(arr[i] - arr[start]) > 1:\n            start = i\n        max_len = max(max_len, i - start + 1)\n    return max_len\n\n###Testcases: \n\nassert longestSubarray([1, 1, 2, 2, 4, 4, 5, 5, 5]) == 5\nassert longestSubarray([1, 2, 2, 3, 4, 4, 5, 5, 6]) == 4\nassert longestSubarray([4, 6, 5, 3, 3, 1]) == 3\nassert longestSubarray([1, 2, 3, 4, 5]) == 2\n\n[/Example 3]", "temperature": 0.762, "question": "Given an array of integers, find the length of the longest subarray where the absolute difference between any two elements is less than or equal to 1.", "code": "def longestSubarray(arr: list) -> int:\n    max_len = 1\n    arr.sort()\n    start = 0\n    for i in range(1, len(arr)):\n        if abs(arr[i] - arr[start]) > 1:\n            start = i\n        max_len = max(max_len, i - start + 1)\n    return max_len", "asserts": ["assert longestSubarray([1, 1, 2, 2, 4, 4, 5, 5, 5]) == 5", "assert longestSubarray([4, 6, 5, 3, 3, 1]) == 3", "assert longestSubarray([1, 2, 3, 4, 5]) == 2"], "author": "GPT", "UUID": "f97cbec9-fdda-47b8-8170-b3f33878065b", "tc_status": [["assert longestSubarray([1, 1, 2, 2, 4, 4, 5, 5, 5]) == 5", "Passed"], ["assert longestSubarray([4, 6, 5, 3, 3, 1]) == 3", "Passed"], ["assert longestSubarray([1, 2, 3, 4, 5]) == 2", "Passed"]]}, {"few_shots": [{"author": "Calvin", "UUID": "a9c5e697-af5d-432b-8447-5675d739c728", "question": "Given an array reorder it so that even numbers appear first", "examples": "Input: [1,2,3,4,5,6,7,8,9]\r\nOutput: [8,2,6,4,5,7,3,9,1]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def even_odd_reorder(arr: list) -> list:\n  nextEven = 0\n  nextOdd = len(arr) - 1\n  while nextEven < nextOdd:\n    if arr[nextEven] % 2 == 0:\n      nextEven += 1\n    else:\n      temp = arr[nextEven]\n      arr[nextEven] = arr[nextOdd]\n      arr[nextOdd] = temp\n      nextOdd -= 1\n  return arr\n", "asserts": ["assert even_odd_reorder([1,2,3,4,5,6,7,8,9]) == [8, 2, 6, 4, 5, 7, 3, 9, 1]", "assert even_odd_reorder([]) == []", "assert even_odd_reorder([2, 4, 6, 8]) == [2, 4, 6, 8]", "assert even_odd_reorder([7, 9, 2]) == [2, 9, 7]", "assert even_odd_reorder([10, 13, 17, 16, 15, 12]) == [10, 12, 16, 15, 17, 13]"]}, {"author": "Calvin", "UUID": "9e45b73f-583d-40ab-b387-e0d1624af07b", "question": "Given two arrays return an array with the set intersection of their common elements", "examples": "Input: arr1 = [1, 2, 3, 4], arr2 = [2, 3]\nOutput: [2, 3]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def array_intersection(arr1: list, arr2: list) -> set:\n  set1 = set(arr1)\n  ret = set([x for x in arr2 if x in set1])\n  return list(ret)\n", "asserts": ["assert set(array_intersection([1,0,2,0,2,0,2,1,1,1], [2,1,0,2,0,2,2,2,1,0])) == {0,1,2}", "assert set(array_intersection([5, 6, 7, 8], [8, 9, 10, 11])) == {8}", "assert set(array_intersection([10, 20, 30], [40, 50, 60])) == set()", "assert set(array_intersection([], [1, 2, 3])) == set()", "assert set(array_intersection([-1, -2, -3], [-3, -4, -5, -6])) == {-3}", "assert set(array_intersection([9, 8, 7], [7, 8, 9, 10, 11, 12])) == {7, 8, 9}", "assert set(array_intersection(['a', 'b', 'c'], ['a', 'd', 'e', 'c'])) == {'a', 'c'}", "assert set(array_intersection(['apple', 'banana'], ['banana', 'cherry'])) == {'banana'}", "assert set(array_intersection([1.1, 2.2, 3.3], [2.2, 4.4])) == {2.2}", "assert set(array_intersection([False, True, False], [True, False, True])) == {True, False}", "assert set(array_intersection([(1, 2), (3, 4)], [(3, 4), (5, 6)])) == {(3, 4)}"]}], "category": "Array", "prompt_tokens": 886, "total_tokens": 1226, "completion_tokens": 340, "completion": "Given an array of integers, move all zeroes to the end of the array without changing the order of the non-zero elements.\n\n###Code: \n\ndef move_zeroes_to_end(arr: list) -> list:\n    zero_count = arr.count(0)\n    arr = [num for num in arr if num != 0]\n    arr.extend([0] * zero_count)\n    return arr\n\n###Testcases: \n\nassert move_zeroes_to_end([0, 1, 0, 3, 12]) == [1, 3, 12, 0, 0]\nassert move_zeroes_to_end([0, 0, 0, 0, 1]) == [1, 0, 0, 0, 0]\nassert move_zeroes_to_end([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]\nassert move_zeroes_to_end([]) == []\nassert move_zeroes_to_end([4, 2, 4, 0, 0, 3, 0, 5, 1, 0]) == [4, 2, 4, 3, 5, 1, 0, 0, 0, 0]\nassert move_zeroes_to_end([0, -1, 0, -3, 12]) == [-1, -3, 12, 0, 0]\nassert move_zeroes_to_end([0, 0, 1]) == [1, 0, 0]\n\n[/Example 3]", "temperature": 0.861, "question": "Given an array of integers, move all zeroes to the end of the array without changing the order of the non-zero elements.", "code": "def move_zeroes_to_end(arr: list) -> list:\n    zero_count = arr.count(0)\n    arr = [num for num in arr if num != 0]\n    arr.extend([0] * zero_count)\n    return arr", "asserts": ["assert move_zeroes_to_end([0, 1, 0, 3, 12]) == [1, 3, 12, 0, 0]", "assert move_zeroes_to_end([0, 0, 0, 0, 1]) == [1, 0, 0, 0, 0]", "assert move_zeroes_to_end([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]", "assert move_zeroes_to_end([]) == []", "assert move_zeroes_to_end([4, 2, 4, 0, 0, 3, 0, 5, 1, 0]) == [4, 2, 4, 3, 5, 1, 0, 0, 0, 0]", "assert move_zeroes_to_end([0, -1, 0, -3, 12]) == [-1, -3, 12, 0, 0]", "assert move_zeroes_to_end([0, 0, 1]) == [1, 0, 0]"], "author": "GPT", "UUID": "7eaef2ee-e910-43a6-a013-52c9f75dcc27", "tc_status": [["assert move_zeroes_to_end([0, 1, 0, 3, 12]) == [1, 3, 12, 0, 0]", "Passed"], ["assert move_zeroes_to_end([0, 0, 0, 0, 1]) == [1, 0, 0, 0, 0]", "Passed"], ["assert move_zeroes_to_end([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]", "Passed"], ["assert move_zeroes_to_end([]) == []", "Passed"], ["assert move_zeroes_to_end([4, 2, 4, 0, 0, 3, 0, 5, 1, 0]) == [4, 2, 4, 3, 5, 1, 0, 0, 0, 0]", "Passed"], ["assert move_zeroes_to_end([0, -1, 0, -3, 12]) == [-1, -3, 12, 0, 0]", "Passed"], ["assert move_zeroes_to_end([0, 0, 1]) == [1, 0, 0]", "Passed"]]}, {"author": "Calvin", "UUID": "a9c5e697-af5d-432b-8447-5675d739c728", "question": "Given an array reorder it so that even numbers appear first", "examples": "Input: [1,2,3,4,5,6,7,8,9]\r\nOutput: [8,2,6,4,5,7,3,9,1]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def even_odd_reorder(arr: list) -> list:\n  nextEven = 0\n  nextOdd = len(arr) - 1\n  while nextEven < nextOdd:\n    if arr[nextEven] % 2 == 0:\n      nextEven += 1\n    else:\n      temp = arr[nextEven]\n      arr[nextEven] = arr[nextOdd]\n      arr[nextOdd] = temp\n      nextOdd -= 1\n  return arr\n", "asserts": ["assert even_odd_reorder([1,2,3,4,5,6,7,8,9]) == [8, 2, 6, 4, 5, 7, 3, 9, 1]", "assert even_odd_reorder([]) == []", "assert even_odd_reorder([2, 4, 6, 8]) == [2, 4, 6, 8]", "assert even_odd_reorder([7, 9, 2]) == [2, 9, 7]", "assert even_odd_reorder([10, 13, 17, 16, 15, 12]) == [10, 12, 16, 15, 17, 13]"], "category": "Array"}, {"author": "Calvin", "UUID": "9e45b73f-583d-40ab-b387-e0d1624af07b", "question": "Given two arrays return an array with the set intersection of their common elements", "examples": "Input: arr1 = [1, 2, 3, 4], arr2 = [2, 3]\nOutput: [2, 3]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def array_intersection(arr1: list, arr2: list) -> set:\n  set1 = set(arr1)\n  ret = set([x for x in arr2 if x in set1])\n  return list(ret)\n", "asserts": ["assert set(array_intersection([1,0,2,0,2,0,2,1,1,1], [2,1,0,2,0,2,2,2,1,0])) == {0,1,2}", "assert set(array_intersection([5, 6, 7, 8], [8, 9, 10, 11])) == {8}", "assert set(array_intersection([10, 20, 30], [40, 50, 60])) == set()", "assert set(array_intersection([], [1, 2, 3])) == set()", "assert set(array_intersection([-1, -2, -3], [-3, -4, -5, -6])) == {-3}", "assert set(array_intersection([9, 8, 7], [7, 8, 9, 10, 11, 12])) == {7, 8, 9}", "assert set(array_intersection(['a', 'b', 'c'], ['a', 'd', 'e', 'c'])) == {'a', 'c'}", "assert set(array_intersection(['apple', 'banana'], ['banana', 'cherry'])) == {'banana'}", "assert set(array_intersection([1.1, 2.2, 3.3], [2.2, 4.4])) == {2.2}", "assert set(array_intersection([False, True, False], [True, False, True])) == {True, False}", "assert set(array_intersection([(1, 2), (3, 4)], [(3, 4), (5, 6)])) == {(3, 4)}"], "category": "Array"}, {"author": "Calvin", "UUID": "f795bda7-9822-4bc5-9c7e-b9c0f2752085", "question": "You are given two 0-indexed integer permutations A and B of length n.\n\nA prefix common array of A and B is an array C such that C[i] is equal to the count of numbers that are present at or before the index i in both A and B.\n\nReturn the prefix common array of A and B.\n\nA sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once.", "examples": "Input: A = [1,3,2,4], B = [3,1,2,4]\nOutput: [0,2,3,4]", "link": "https://leetcode.com/problems/find-the-prefix-common-array-of-two-arrays/", "difficulty": null, "categories": ["Array"], "code": "def findThePrefixCommonArray(arr1: list, arr2: list) -> list:\n  max = len(arr1) if len(arr1) > len(arr2) else len(arr2)\n  seen = set()\n  curCount = 0\n  ret = []\n  for i in range(max):\n    cur1 = arr1[i]\n    cur2 = arr2[i]\n    if cur1 in seen:\n      curCount += 1\n    else:\n      seen.add(cur1)\n    if cur2 in seen:\n      curCount += 1\n    else:\n      seen.add(cur2)\n    ret.append(curCount)\n  return ret\n", "asserts": ["assert findThePrefixCommonArray([1,3,2,4], [3,1,2,4]) == [0,2,3,4]", "assert findThePrefixCommonArray([1], [1]) == [1]", "assert findThePrefixCommonArray([2,3,1], [3,1,2]) == [0,1,3]"], "category": "Array"}, {"author": "Calvin", "UUID": "fb94082f-4627-4f5a-b280-08d869823d70", "question": "You are given an array of people, people, which are the attributes of some people in a queue (not necessarily in order). Each people[i] = [hi, ki] represents the ith person of height hi with exactly ki other people in front who have a height greater than or equal to hi.\n\nReconstruct and return the queue that is represented by the input array people. The returned queue should be formatted as an array queue, where queue[j] = [hj, kj] is the attributes of the jth person in the queue (queue[0] is the person at the front of the queue).\n", "examples": "Input:  [[7, 0], [4, 4], [7, 1], [5, 0], [6, 1], [5, 2]]\nOutput: [[5, 0], [4, 1], [7, 0], [5, 2], [6, 1], [7, 1]]\n\nInput:  [[6, 0], [5, 0], [4, 0], [3, 2], [2, 2], [1, 4]]\nOutput: [[4, 0], [5, 0], [2, 2], [3, 2], [1, 4], [6, 0]]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "\ndef reconstructQueue(people: list) -> list:\n    output=[] \n    people.sort(key=lambda x: (-x[0], x[1]))                \n    for a in people:\n        output.insert(a[1], a)\n    \n    return output\n", "asserts": ["assert reconstructQueue([[8,1],[5,0],[6,1],[5,2],[4,4],[7,1]]) == [[5, 0], [8, 1], [5, 2], [6, 1], [4, 4], [7, 1]]", "assert reconstructQueue([[12,0], [6,3], [4,4], [9,2], [7,1]]) == [[12, 0], [7, 1], [9, 2], [6, 3], [4, 4]]", "assert reconstructQueue([[2,0], [1,1]]) == [[2, 0], [1, 1]]", "assert reconstructQueue([[3,0], [3,2], [3,1]]) == [[3, 0], [3, 1], [3, 2]]"], "category": "Array"}, {"author": "Calvin", "UUID": "48c6aa37-e00d-4b55-9afc-6b1cf2a1aff2", "question": "There are N Mice and N holes are placed in a straight line. Each hole can accommodate only 1 mouse. A mouse can stay at his position, move one step right from x to x + 1, or move one step left from x to x -1. Any of these moves consumes 1 minute. Assign mice to holes so that the time when the last mouse gets inside a hole is minimized.\nYou are given a list of mice and hole positions as integer scalers.\n", "examples": "Input: Mices = [0, 10, 2, 3], Holes = [3, 2, 23, 0]\nOutput: 13", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def assignHole(mices: list, holes: list) -> int:\n    for i,j in zip(mices,holes):\n        if i<0 or j<0:\n            return -1\n    if (len(mices) != len(holes)):\n        return -1\n    mices.sort()\n    holes.sort()\n    Max = 0\n     \n    for i in range(len(holes)):\n        if (Max < abs(mices[i] - holes[i])):\n            Max = abs(mices[i] - holes[i])\n     \n    return Max\n", "asserts": ["assert assignHole([1, 2, 3, 4], [4, 3, 2, 1]) == 0", "assert assignHole([10, 20, 30, 40], [15, 25, 35, 45]) == 5", "assert assignHole([1, 4, 9, 15], [10, 13, 7, 20]) == 6", "assert assignHole([0], [0]) == 0", "assert assignHole([1, 2], [3]) == -1  # Edge case with non-equal amount of mice and holes", "assert assignHole([5, 5, 5], [5, 5, 5]) == 0  # Edge case with all mice and holes at the same position", "assert assignHole([10, 10, 10, 10], [10, 9, 8, 7]) == 3  # Edge case with multiple mice starting at the same position", "assert assignHole([1,1 ,1, 1, 1, 1, 1, 1, 1, 1], [2,2,2,2,2,2 ,2, 2, 2, 2]) == 1 # Edge case with multiple mice and holes at the same positions", "assert assignHole([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == 1 # Edge case with incremental positions"], "category": "Array"}, {"author": "Calvin", "UUID": "1aeb3246-4c22-4d34-a48c-db7be8ba1b94", "question": "You are given n activities with their start and finish times. Select the maximum number of activities that can be performed by a single person and return their indexes. Assume that a person can only work on a single activity at a time. \n", "examples": "Input: start  =  {10, 12, 20}, finish =  {20, 25, 30}\nOutput: [0, 2]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "import numpy as np\ndef MaxActivities(s: list, f: list) -> list:\n    indices = np.argsort(f)\n    [s[i] for i in indices]\n    [f[i] for i in indices]\n    result = []\n    n = len(f)\n    i = 0\n    result.append(i)\n    for j in range(1, n):\n        if s[j] >= f[i]:\n            result.append(j)\n            i = j\n    return result\n", "asserts": ["assert MaxActivities([2, 4, 5, 6, 7, 8], [3, 5, 6, 7, 9, 10]) == [0, 1, 2, 3, 4]", "assert MaxActivities([1, 3, 0, 5, 8, 5], [2, 4, 6, 7, 9, 9]) == [0, 1, 3, 4]", "assert MaxActivities([1], [2]) == [0]"], "category": "Array"}]}