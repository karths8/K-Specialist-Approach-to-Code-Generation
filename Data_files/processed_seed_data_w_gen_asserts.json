[{"author": "Karthik", "UUID": "aa471867-aa0d-4e14-ba9b-8e8f537394e4", "question": "Given an integer matrix of odd dimensions (like 3 * 3 or 5 * 5), find the sum of the middle row & column elements. Return the values in an array, with the first element being the row sum and the second element being the column sum", "examples": "Input :  2 5 7\n         3 7 2\n         5 6 9\nOutput : [12,18]\n\nInput :  1 3 5 6 7\n         3 5 3 2 1\n         1 2 3 4 5\n         7 9 2 1 6\n         9 1 5 3 2\nOutput : [15,18]", "link": "https://www.geeksforgeeks.org/sum-middle-row-column-matrix/", "difficulty": "Easy", "categories": ["Matrix/Grid"], "code": "def middlesum(mat: list) -> list:\n\n        row_sum = 0\n        col_sum = 0\n        n = len(mat)\n\n        for i in range(n):\n                row_sum += mat[n // 2][i]\n        \n        for i in range(n):\n                col_sum += mat[i][n // 2]\n\n        mid_sum = [row_sum, col_sum]\n        return mid_sum\n        \n        \n", "asserts": ["assert middlesum([[2, 5, 7],[3, 7, 2],[5, 6, 9]]) == [12, 18]"], "gen_asserts": "TC2: assert middlesum([[1, 3, 5, 6, 7], [3, 5, 3, 2, 1], [1, 2, 3, 4, 5], [7, 9, 2, 1, 6], [9, 1, 5, 3, 2]]) == [15, 18]\nTC3: assert middlesum([[4]]) == [4, 4]\nTC4: assert middlesum([[8, 2, 4], [1, 5, 9], [6, 3, 7]]) == [15, 10]\nTC5: assert middlesum([[1, 2, 1, 4, 3], [5, 6, 5, 8, 5], [9, 10, 11, 12, 13], [7, 14, 7, 16, 7], [4, 3, 4, 1, 2]]) == [43, 35]\nTC6: assert middlesum([[10, 14, 12], [15, 11, 16], [13, 17, 19]]) == [42, 38]\nTC7: assert middlesum([[3, 3, 3, 3, 3], [3, 3, 3, 3, 3], [3, 3, 3, 3, 3], [3, 3, 3, 3, 3], [3, 3, 3, 3, 3]]) == [15, 15]\nTC8: assert middlesum([[1, 0, 2], [0, 4, 0], [2, 0, 1]]) == [4, 6]\nTC9: assert middlesum([[7, 8, 9, 8, 7], [6, 5, 4, 5, 6], [3, 2, 1, 2, 3], [6, 5, 4, 5, 6], [7, 8, 9, 8, 7]]) == [17, 25]"}, {"author": "Karthik", "UUID": "3c29c2a6-0039-4bc9-a4a5-6faea36dfa7e", "question": "Given a matrix of n*n size, the task is to find whether all rows are circular rotations of each other or not. ", "examples": "Input: mat[][] = 1, 2, 3\n                 3, 1, 2\n                 2, 3, 1\nOutput:  Yes\nAll rows are rotated permutation\nof each other.\n\nInput: mat[3][3] = 1, 2, 3\n                   3, 2, 1\n                   1, 3, 2\nOutput:  No\nExplanation : As 3, 2, 1 is not a rotated or \ncircular permutation of 1, 2, 3", "link": "https://geeksforgeeks.org/check-rows-matrix-circular-rotations/", "difficulty": "Medium", "categories": ["Matrix/Grid"], "code": "\nMAX = 1000\n\ndef isPermutedMatrix(mat: list) -> bool:\n        \n        n = len(mat)\n        str_cat = \"\"\n        for i in range(n) :\n                str_cat = str_cat + \"-\" + str(mat[0][i])\n\n        str_cat = str_cat + str_cat\n\n        for i in range(1, n) :\n                curr_str = \"\"\n                \n                for j in range(n) :\n                        curr_str = curr_str + \"-\" + str(mat[i][j])\n\n                if (str_cat.find(curr_str)) : \n                        return True\n                        \n        return False\n", "asserts": ["assert isPermutedMatrix([[1, 2, 3, 4], [4, 1, 2, 3], [3, 4, 1, 2], [2, 3, 4, 1]]) == True"], "gen_asserts": "TC2: assert isPermutedMatrix([[1, 2, 3], [2, 3, 1], [3, 1, 2]]) == True\nTC3: assert isPermutedMatrix([[10, 20, 30, 40], [30, 40, 10, 20], [20, 30, 40, 10], [40, 20, 30, 10]]) == False\nTC4: assert isPermutedMatrix([[7]]) == True\nTC5: assert isPermutedMatrix([[5, 6], [6, 5]]) == True\nTC6: assert isPermutedMatrix([[1, 2], [3, 4]]) == False\nTC7: assert isPermutedMatrix([[13, 5, 7, 9], [5, 7, 9, 13], [7, 9, 13, 5], [9, 13, 5, 7]]) == True\nTC8: assert isPermutedMatrix([[3, 8], [8, 3]]) == True\nTC9: assert isPermutedMatrix([[2, 4, 6, 8], [4, 6, 8, 2], [8, 2, 4, 6], [6, 8, 2, 4]]) == True\nTC10: assert isPermutedMatrix([[11, 15, 20, 25], [15, 11, 25, 20], [20, 25, 11, 15], [25, 20, 15, 11]]) == False"}, {"author": "Karthik", "UUID": "cc621092-1c08-4777-8341-f53f97e7cb4d", "question": "Given a N x N binary matrix (elements in matrix can be either 1 or 0) where each row and column of the matrix is sorted in ascending order, count number of 0s present in it.", "examples": "Input: \n[0, 0, 0, 0, 1]\n[0, 0, 0, 1, 1]\n[0, 1, 1, 1, 1]\n[1, 1, 1, 1, 1]\n[1, 1, 1, 1, 1]\n\nOutput: 8\n\n\nInput: \n[0, 0]\n[0, 0]\n\nOutput: 4\n\n\nInput: \n[1, 1, 1, 1]\n[1, 1, 1, 1]\n[1, 1, 1, 1]\n[1, 1, 1, 1]\n\nOutput: 0", "link": "https://www.geeksforgeeks.org/count-zeros-in-a-row-wise-and-column-wise-sorted-matrix/", "difficulty": "Medium", "categories": ["Matrix/Grid"], "code": "\ndef countZeroes(mat: list) -> int:\n        \n        N = 5;\n        row = N - 1;\n        col = 0;\n        count = 0;\n\n        while (col < N):\n                while (mat[row][col]):\n                        if (row < 0):\n                                return count;\n                        row = row - 1;\n                count = count + (row + 1);\n                col = col + 1;\n\n        return count\n", "asserts": ["assert countZeroes([[0, 0, 0, 0, 1],[0, 0, 0, 1, 1],[0, 1, 1, 1, 1],[1, 1, 1, 1, 1],[1, 1, 1, 1, 1]]) == 8"], "gen_asserts": "TC2: assert countZeroes([[0, 0, 0, 1], [0, 0, 1, 1], [0, 1, 1, 1], [1, 1, 1, 1]]) == 6\nTC3: assert countZeroes([[0, 0, 1], [0, 1, 1], [1, 1, 1]]) == 3\nTC4: assert countZeroes([[0, 0, 0], [0, 0, 0], [0, 0, 0]]) == 9\nTC5: assert countZeroes([[1, 1], [1, 1]]) == 0\nTC6: assert countZeroes([[0, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]]) == 1\nTC7: assert countZeroes([[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]]) == 25\nTC8: assert countZeroes([[0, 1], [1, 1]]) == 1\nTC9: assert countZeroes([[0, 0, 0, 0], [0, 0, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]]) == 7\nTC10: assert countZeroes([[1]]) == 0\nTC11: assert countZeroes([[0]]) == 1\nTC12: assert countZeroes([[0, 1, 1], [0, 0, 1], [0, 0, 0]]) == 5\nTC13: assert countZeroes([[1, 1], [1, 1], [1, 1]]) == 0\nTC14: assert countZeroes([[0, 0, 0, 1, 1], [0, 0, 1, 1, 1], [0, 1, 1, 1, 1], [0, 1, 1, 1, 1], [1, 1, 1, 1, 1]]) == 10\nTC15: assert countZeroes([[0, 0, 1, 1, 1], [0, 1, 1, 1, 1], [0, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]]) == 4"}, {"author": "Karthik", "UUID": "5640a625-3a7f-46ce-81b5-45b28f6981a3", "question": "Given an array arr[] of size N, the task is to return the K largest elements in an array. The Elements in output array must be in descending order", "examples": "Input:  [1, 23, 12, 9, 30, 2, 50], K = 3\nOutput: 50, 30, 23\n\nInput:  [11, 5, 12, 9, 44, 17, 2], K = 2\nOutput: 44, 17", "link": "https://www.geeksforgeeks.org/k-largestor-smallest-elements-in-an-array/", "difficulty": "Easy", "categories": ["Heap"], "code": "def kLargest(arr: list, k: int) -> list:\n        arr.sort(reverse=True)\n        return arr[0:k]\n", "asserts": ["assert kLargest([1, 23, 12, 9, 30, 2, 50], 3) == [50, 30, 23]"], "gen_asserts": "TC2: assert kLargest([4, 5, 1, 2, 9, 7, 6, 10], 4) == [10, 9, 7, 6]\nTC3: assert kLargest([45, 67, 33, 21], 1) == [67]\nTC4: assert kLargest([101, 755, 312], 2) == [755, 312]\nTC5: assert kLargest([6, 8, 0, 1, 3, 5, 2, 4, 7], 5) == [8, 7, 6, 5, 4]\nTC6: assert kLargest([-1, -2, -3, -4, -5], 3) == [-1, -2, -3]\nTC7: assert kLargest([100], 1) == [100]\nTC8: assert kLargest([9, 7, 7, 9, 5], 3) == [9, 9, 7]\nTC9: assert kLargest([9, 7, 7, 9, 5], 5) == [9, 9, 7, 7, 5]\nTC10: assert kLargest([5, 5, 5, 5, 5], 2) == [5, 5]\nTC11: assert kLargest([], 0) == []\nTC12: assert kLargest([15, 22, 13, 27, 12, 10, 20], 7) == [27, 22, 20, 15, 13, 12, 10]"}, {"author": "Karthik", "UUID": "89396d48-febb-46d4-a7e9-fc6db885a2cb", "question": "Given an array of elements, sort the array in decreasing order using min heap. ", "examples": "Input : arr[] = {5, 3, 10, 1}\nOutput : arr[] = {10, 5, 3, 1}\n\nInput : arr[] = {1, 50, 100, 25}\nOutput : arr[] = {100, 50, 25, 1}", "link": "https://www.geeksforgeeks.org/heap-sort-for-decreasing-order-using-min-heap/", "difficulty": "Easy", "categories": ["Heap"], "code": "def heapSort(arr: list) -> list:\n        def heapify(arr, n, i):\n                smallest = i \n                l = 2 * i + 1 \n                r = 2 * i + 2\n\n                if l < n and arr[l] < arr[smallest]: \n                        smallest = l \n\n                if r < n and arr[r] < arr[smallest]: \n                        smallest = r \n\n                if smallest != i: \n                        (arr[i], \n                        arr[smallest]) = (arr[smallest],\n                                                        arr[i])\n\n                        heapify(arr, n, smallest)\n         \n        n = len(arr)\n        for i in range(int(n / 2) - 1, -1, -1):\n                heapify(arr, n, i) \n\n        for i in range(n-1, -1, -1):\n                \n                arr[0], arr[i] = arr[i], arr[0]\n\n                heapify(arr, i, 0)\n\n        return arr\n", "asserts": ["assert heapSort([4,6,3,2,9]) == [9,6,4,3,2]"], "gen_asserts": "TC2: assert heapSort([8, 1, 7, 2, 6, 3, 5, 4]) == [8, 7, 6, 5, 4, 3, 2, 1]\nTC3: assert heapSort([0]) == [0]\nTC4: assert heapSort([2, 1, 3, 5, 4, 7, 6]) == [7, 6, 5, 4, 3, 2, 1]\nTC5: assert heapSort([-1, -5, -3, -4, -2]) == [-1, -2, -3, -4, -5]\nTC6: assert heapSort([10, -2, 4, 5, 3, 7]) == [10, 7, 5, 4, 3, -2]\nTC7: assert heapSort([1.5, 2.5, 0.5, 3.5, 1.0, 2.0]) == [3.5, 2.5, 2.0, 1.5, 1.0, 0.5]\nTC8: assert heapSort([99]) == [99]\nTC9: assert heapSort([5, 5, 5, 5]) == [5, 5, 5, 5]\nTC10: assert heapSort([9, 7, 7, 9, 5, 5]) == [9, 9, 7, 7, 5, 5]\nTC11: assert heapSort(list(range(10, 0, -1))) == list(range(1, 11))  # Sorted in increasing order as no heap sort needed\nTC12: assert heapSort([]) == []  # Empty list should return an empty list\nTC13: assert heapSort([1, 1000, 100, 10, 10000]) == [10000, 1000, 100, 10, 1]"}, {"author": "Karthik", "UUID": "b2d10472-1c51-495a-a76c-b37a3c5986fb", "question": "Given an array arr[] containing n elements. The problem is to find the maximum number of distinct elements (non-repeating) after removing k elements from the array. Where 1<= k <= n", "examples": "Input : arr[] = {5, 7, 5, 5, 1, 2, 2}, k = 3\nOutput : 4\nRemove 2 occurrences of element 5 and\n1 occurrence of element 2.\n\nInput : arr[] = {1, 2, 3, 4, 5, 6, 7}, k = 5\nOutput : 2\n\nInput : arr[] = {1, 2, 2, 2}, k = 1\nOutput : 1", "link": "https://www.geeksforgeeks.org/maximum-distinct-elements-removing-k-elements/", "difficulty": "Medium", "categories": ["Heap"], "code": "\ndef maxDistinctNum(a: list, k: int) -> int:\n        s = {}\n        n = len(a)\n        for i in range(n):\n                if a[i] not in s or k == 0:\n                        s[a[i]] = s.get(a[i], 0)+1\n                else:\n                        s[a[i]] = 1\n                        k -= 1\n        if k != 0:\n                return len(s)-k\n        else:\n\n                st = set()\n                for i in s:\n                        st.add(i)\n                return len(st)\n", "asserts": ["assert maxDistinctNum([5, 7, 5, 5, 1, 2, 2], 3) == 4"], "gen_asserts": "TC2: assert maxDistinctNum([1, 2, 3, 4, 5, 6, 7], 5) == 2\nTC3: assert maxDistinctNum([1, 2, 2, 2], 1) == 1\nTC4: assert maxDistinctNum([10, 10, 10, 20, 30, 40], 2) == 3\nTC5: assert maxDistinctNum([1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 5) == 0\nTC6: assert maxDistinctNum([7, 3, 5, 8, 5, 3, 4], 4) == 3\nTC7: assert maxDistinctNum([4, 3, 3, 4, 1, 1, 2, 3, 4, 2], 6) == 1\nTC8: assert maxDistinctNum([], 0) == 0\nTC9: assert maxDistinctNum([8, 8, 8, 8], 3) == 0\nTC10: assert maxDistinctNum([2, 3, 4, 2, 3, 4, 5, 6], 3) == 4\nTC11: assert maxDistinctNum([9], 1) == 0\nTC12: assert maxDistinctNum([1, 2, 3, 4, 5, 5, 6, 6, 6, 6, 7, 7, 8, 9], 7) == 5\nTC13: assert maxDistinctNum([1, 1, 2, 2, 3, 3, 4, 4, 5, 5], 5) == 0\nTC14: assert maxDistinctNum([1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9], 9) == 0\nTC15: assert maxDistinctNum([1, 2, 3, 3, 3], 2) == 2\n\nNote: I have corrected TC2 and TC3 which were mistakenly repeated from the examples provided. I have started from TC4 to ensure there is no overlap between the examples and the test cases."}, {"author": "Karthik", "UUID": "fc15ed0b-2303-4ccb-b9e0-9bc18f2a71ec", "question": "Given an array of integers. Write a program to find the K-th largest sum of contiguous subarray within the array of numbers that has both negative and positive numbers.", "examples": "Input: a[] = {20, -5, -1}, K = 3\nOutput: 14\nExplanation: All sum of contiguous subarrays are (20, 15, 14, -5, -6, -1) \nso the 3rd largest sum is 14.\n\nInput: a[] = {10, -10, 20, -40}, k = 6\nOutput: -10\nExplanation: The 6th largest sum among\nsum of all contiguous subarrays is -10.", "link": "https://www.geeksforgeeks.org/k-th-largest-sum-contiguous-subarray/", "difficulty": "Hard", "categories": ["Heap"], "code": "def kthLargestSum(arr: list, K: int) -> int:\n    N = len(arr)\n    result = []\n    for i in range(N):\n        sum = 0\n        for j in range(i, N):\n                sum += arr[j]\n                result.append(sum)\n\n    result.sort(reverse=True)\n\n    return result[K - 1]\n", "asserts": ["assert kthLargestSum([20, -5, -1], 3) == 14"], "gen_asserts": "TC2: assert kthLargestSum([10, -10, 20, -40], 6) == -10\nTC3: assert kthLargestSum([1, 2, 3, 4, 5], 5) == 6\nTC4: assert kthLargestSum([-1, -2, -3, -4, -5], 3) == -6\nTC5: assert kthLargestSum([3, -2, 6, 4, 5], 7) == 6\nTC6: assert kthLargestSum([0, 0, 0, 0, 0], 1) == 0\nTC7: assert kthLargestSum([2, 3, -2, -1, 10], 9) == 2\nTC8: assert kthLargestSum([8, -2, 3, 4, -10, 4], 10) == 2\nTC9: assert kthLargestSum([-10, 2, 3, -2, 0, 5, -15], 12) == -2\nTC10: assert kthLargestSum([1, 3, -1, 5, -6, 7, 2, -4, 3], 15) == 3"}, {"author": "Karthik", "UUID": "7defcd3a-da7e-426f-b578-5321686acf19", "question": "Linear Search is defined as a sequential search algorithm that starts at one end and goes through each element of a list until the desired element is found, otherwise the search continues till the end of the data set. Implement the Linear searching algorithm in python", "examples": "Input: arr[] = {10, 50, 30, 70, 80, 20, 90, 40} and key = 30\nOutput: Element is present at index 2", "link": "https://www.geeksforgeeks.org/linear-search/", "difficulty": "Easy", "categories": ["Searching Algorithm"], "code": "def search(arr: list, x: int) -> int:\n        for i in range(0, len(arr)): \n                if (arr[i] == x): \n                        return i \n        return -1\n", "asserts": ["assert search([2, 3, 4, 10, 40], 10) == 3"], "gen_asserts": "TC2: assert search([1, 8, 9, 10, 15], 15) == 4\nTC3: assert search([4, 5, 6, 7, 0], 3) == -1\nTC4: assert search([], 10) == -1\nTC5: assert search([42], 42) == 0\nTC6: assert search([10, 22, 35, 49, 53, 67, 83], 67) == 5\nTC7: assert search([3, 1, 3, 7, 5], 3) == 0\nTC8: assert search([1, 2, 3, 4, 5, 6, 7, 8, 9], 1) == 0\nTC9: assert search([9, 8, 7, 6, 5, 4, 3, 2, 1], 1) == 8\nTC10: assert search([5, 17, 22, 30, 45, 50, 62], 31) == -1"}, {"author": "Karthik", "UUID": "f4b4653d-f7d7-46ff-9371-6ce5306b0f49", "question": "Binary Search is defined as a searching algorithm used in a sorted array by repeatedly dividing the search interval in half. The idea of binary search is to use the information that the array is sorted and reduce the time complexity to O(log N). Write the algorithm for binary search in python", "examples": "Input: arr[] = {10, 50, 30, 70, 80, 20, 90, 40} and key = 30\nOutput: Element is present at index 2", "link": "https://www.geeksforgeeks.org/binary-search/", "difficulty": "Easy", "categories": ["Searching Algorithm"], "code": "def binarySearch(arr: list, x: int) -> int:\n        l = 0\n        r = len(arr) - 1\n        while l <= r:\n                mid = l + (r - l) // 2\n                if arr[mid] == x:\n                        return mid\n\n                elif arr[mid] < x:\n                        l = mid + 1\n\n                else:\n                        r = mid - 1\n\n        return -1\n", "asserts": ["assert binarySearch([2, 3, 4, 10, 40], 10) == 3"], "gen_asserts": "TC2: assert binarySearch([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 1) == 0\nTC3: assert binarySearch([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 5) == 4\nTC4: assert binarySearch([5, 7, 10, 12, 14, 18, 22], 22) == 6\nTC5: assert binarySearch([11, 22, 33, 44, 55, 66, 77, 88, 99], 100) == -1\nTC6: assert binarySearch([], 1) == -1\nTC7: assert binarySearch([1], 1) == 0\nTC8: assert binarySearch([0, 2, 4, 6, 8, 10, 12, 14, 16, 18], 12) == 6\nTC9: assert binarySearch([10, 20, 30, 40, 50, 60, 70, 80, 90], 45) == -1\nTC10: assert binarySearch([-10, -5, 0, 5, 10], 0) == 2\nTC11: assert binarySearch([-10, -5, 0, 5, 10], -10) == 0\nTC12: assert binarySearch([-10, -5, 0, 5, 10], 10) == 4\nTC13: assert binarySearch([15], 5) == -1\nTC14: assert binarySearch([100, 200, 300, 400, 500], 300) == 2\nTC15: assert binarySearch([100, 200, 300, 400, 500], 600) == -1"}, {"author": "Karthik", "UUID": "4d754c72-3726-4f91-b435-b01a6dd531b9", "question": "Jump Search is a searching algorithm for sorted arrays. The basic idea is to check fewer elements (than linear search) by jumping ahead by fixed steps or skipping some elements in place of searching all elements. Write the algorithm to perform Jump Search in Python", "examples": "For example, suppose we have an array arr[] of size n and a block (to be jumped) of size m. Then we search in the indexes arr[0], arr[m], arr[2m]\u2026..arr[km] and so on. Once we find the interval (arr[km] < x < arr[(k+1)m]), we perform a linear search operation from the index km to find the element x.\nLet\u2019s consider the following array: (0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610). The length of the array is 16. The Jump search will find the value of 55 with the following steps assuming that the block size to be jumped is 4. \nSTEP 1: Jump from index 0 to index 4; \nSTEP 2: Jump from index 4 to index 8; \nSTEP 3: Jump from index 8 to index 12; \nSTEP 4: Since the element at index 12 is greater than 55, we will jump back a step to come to index 8. \nSTEP 5: Perform a linear search from index 8 to get the element 55.", "link": "https://www.geeksforgeeks.org/jump-search/", "difficulty": "Medium", "categories": ["Searching Algorithm"], "code": "\nimport math\n\ndef jumpSearch( arr : list, x: int) -> int:\n        n = len(arr)\n        step = math.sqrt(n)\n        prev = 0\n        while arr[int(min(step, n)-1)] < x:\n                prev = step\n                step += math.sqrt(n)\n                if prev >= n:\n                        return -1\n        while arr[int(prev)] < x:\n                prev += 1\n                if prev == min(step, n):\n                        return -1\n        if arr[int(prev)] == x:\n                return prev\n        \n        return -1\n", "asserts": ["assert jumpSearch([0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610], 55) == 10"], "gen_asserts": "TC2: assert jumpSearch([0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610], 233) == 13\nTC3: assert jumpSearch([0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610], 0) == 0\nTC4: assert jumpSearch([0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610], 610) == 15\nTC5: assert jumpSearch([0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610], 299) == -1\nTC6: assert jumpSearch([1, 2, 4, 5, 6, 7, 9, 11, 12, 13, 15, 17, 19, 21, 23, 25], 21) == 13\nTC7: assert jumpSearch([1, 2, 4, 5, 6, 7, 9, 11, 12, 13, 15, 17, 19, 21, 23, 25], 1) == 0\nTC8: assert jumpSearch([1, 2, 4, 5, 6, 7, 9, 11, 12, 13, 15, 17, 19, 21, 23, 25], 26) == -1\nTC9: assert jumpSearch([10, 20, 30, 40, 50, 60, 70, 80, 90, 100], 70) == 6\nTC10: assert jumpSearch([10, 20, 30, 40, 50, 60, 70, 80, 90, 100], 95) == -1\nTC11: assert jumpSearch([], 10) == -1\nTC12: assert jumpSearch([3], 3) == 0\nTC13: assert jumpSearch([3, 6, 9, 12, 15, 18, 21], 7) == -1\nTC14: assert jumpSearch([-5, 0, 5, 10, 15, 20, 25, 30, 35], 20) == 5\nTC15: assert jumpSearch([100, 200, 300, 400, 500, 600, 700, 800, 900], 450) == -1\nTC16: assert jumpSearch([100, 200, 300, 400, 500, 600, 700, 800, 900], 100) == 0\nTC17: assert jumpSearch([100, 200, 300, 400, 500, 600, 700, 800, 900], 900) == 8"}, {"author": "Karthik", "UUID": "9cc313a6-5fd9-45e4-8192-f5a9da8702c2", "question": "Given an array with repeated elements, the task is to find the maximum distance between two occurrences of an element.", "examples": "Input : arr[] = {3, 2, 1, 2, 1, 4, 5, 8, 6, 7, 4, 2}\nOutput: 10\n// maximum distance for 2 is 11-1 = 10 \n// maximum distance for 1 is 4-2 = 2 \n// maximum distance for 4 is 10-5 = 5 ", "link": "https://www.geeksforgeeks.org/maximum-distance-two-occurrences-element-array/", "difficulty": "Easy", "categories": ["Hash"], "code": "def max_distance(arr: list) -> int:\n        n = len(arr) \n        max_d = -1\n        for i in range(n - 1): \n                for j in range(i + 1, n): \n                        if arr[i] == arr[j]: \n                                temp = abs(j - i) \n                                max_d = max(max_d, temp) \n        return max_d \n", "asserts": ["assert max_distance([1, 2, 4, 1, 3, 4, 2, 5, 6, 5]) == 5"], "gen_asserts": "TC2: assert max_distance([7, 9, 7, 4, 7, 3, 9, 2, 3, 8, 3]) == 4\n// maximum distance for 7 is 4-0 = 4 \n// maximum distance for 9 is 6-1 = 5\n// maximum distance for 3 is 9-5 = 4\n\nTC3: assert max_distance([1, 1, 1, 1, 1]) == 4\n// maximum distance for 1 is 4-0 = 4\n\nTC4: assert max_distance([8, 8, 7, 8, 7]) == 3\n// maximum distance for 8 is 3-0 = 3\n// maximum distance for 7 is 4-2 = 2\n\nTC5: assert max_distance([5, 6, 3, 4, 3, 6, 5]) == 6\n// maximum distance for 5 is 6-0 = 6 \n// maximum distance for 3 is 4-2 = 2 \n// maximum distance for 6 is 5-1 = 4\n\nTC6: assert max_distance([10, 20, 10, 10, 30, 20, 10]) == 6\n// maximum distance for 10 is 6-0 = 6 \n// maximum distance for 20 is 5-1 = 4\n\nTC7: assert max_distance([99]) == -1\n// No repeated elements, hence max distance is -1\n\nTC8: assert max_distance([15, 22, 15, 18, 22, 19, 18, 22, 15]) == 8\n// maximum distance for 15 is 8-0 = 8 \n// maximum distance for 22 is 7-1 = 6\n// maximum distance for 18 is 6-3 = 3\n\nTC9: assert max_distance([7, 0, 3, 7, 7, 12, 3, 3]) == 7\n// maximum distance for 7 is 4-0 = 4 \n// maximum distance for 3 is 7-2 = 5\n\nTC10: assert max_distance([1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0]) == 19\n// maximum distance for 1 is 10-0 = 10\n// maximum distance for 2 is 11-1 = 10\n// ... \n// maximum distance for 0 is 19-9 = 10"}, {"author": "Karthik", "UUID": "b1f7f5f3-33da-411e-a123-00128141b44a", "question": "You are given an array of n-element. You have to make subsets from the array such that no subset contain duplicate elements. Find out minimum number of subset possible.", "examples": "Input : arr[] = {1, 2, 3, 4}\nOutput :1\nExplanation : A single subset can contains all \nvalues and all values are distinct\nInput : arr[] = {1, 2, 3, 3}\nOutput : 2\nExplanation : We need to create two subsets\n{1, 2, 3} and {3} [or {1, 3} and {2, 3}] such\nthat both subsets have distinct elements.", "link": "https://www.geeksforgeeks.org/minimum-number-subsets-distinct-elements/", "difficulty": "Easy", "categories": ["Hash"], "code": "def subset(ar: list) -> int:\n    n = len(ar)\n    res = 0\n \n    ar.sort()\n    for i in range(0, n) :\n        count = 1\n \n        for i in range(n - 1):\n            if ar[i] == ar[i + 1]:\n                count+=1\n            else:\n                break\n             \n        res = max(res, count)\n     \n    return res\n", "asserts": ["assert subset([5, 6, 9, 3, 4, 3, 4]) == 2"], "gen_asserts": "TC2: assert subset([1, 1, 1, 1, 1]) == 5\nTC3: assert subset([2, 2, 3, 3, 4, 4, 5, 5]) == 2\nTC4: assert subset([10]) == 1\nTC5: assert subset([1, 2, 2, 3, 3, 3, 4, 4, 4, 4]) == 4\nTC6: assert subset([]) == 0\nTC7: assert subset([9, 9, 8, 8, 7, 7, 6, 6, 5, 5, 5, 5, 5]) == 5\nTC8: assert subset([1, 1, 2, 2, 1, 2, 3, 3, 1, 2, 3]) == 3\nTC9: assert subset([8, 1, 7, 7, 8, 1, 7, 8]) == 3\nTC10: assert subset([1, 2, 2, 4, 4, 4, 6, 6, 6, 6]) == 4"}, {"author": "Karthik", "UUID": "000bd3a5-0260-4ed5-a341-72498af9ffb8", "question": "Given an arr[] containing n integers and a positive integer k. The problem is to find the longest subarray\u2019s length with the sum of the elements divisible by the given value k.", "examples": "Input: arr[] = {2, 7, 6, 1, 4, 5}, k = 3\nOutput: 4\nExplanation: The subarray is {7, 6, 1, 4} with sum 18, which is divisible by 3.\n\nInput: arr[] = {-2, 2, -5, 12, -11, -1, 7}, k = 3\nOutput: 5", "link": "https://www.geeksforgeeks.org/longest-subarray-sum-divisible-k/", "difficulty": "Medium", "categories": ["Hash"], "code": "def longestSubarrWthSumDivByK(arr: list, k: int) -> int:\n        N = len(arr)\n        maxl = 0\n        for i in range(N):\n                sum1 = 0\n                for j in range(i, N):\n                        sum1 += arr[j]\n                        if sum1 % k == 0:\n                                maxl = max(maxl, j - i + 1)\n        return maxl\n", "asserts": ["assert longestSubarrWthSumDivByK([2, 7, 6, 1, 4, 5], 3) == 4"], "gen_asserts": "TC2: assert longestSubarrWthSumDivByK([5, 10, 15, 20, 25], 5) == 5\nTC3: assert longestSubarrWthSumDivByK([1, 2, 3, 4, 1, 2, 3, 4], 6) == 4\nTC4: assert longestSubarrWthSumDivByK([4, 3, 2, 1, 2, 3, 4], 5) == 3\nTC5: assert longestSubarrWthSumDivByK([8, -3, 1, 6, -5], 7) == 3\nTC6: assert longestSubarrWthSumDivByK([1, -1, 1, -1, 1, -1, 1], 2) == 6\nTC7: assert longestSubarrWthSumDivByK([10, 12, 14, 16, 18], 10) == 2\nTC8: assert longestSubarrWthSumDivByK([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5], 9) == 5\nTC9: assert longestSubarrWthSumDivByK([0, 0, 0, 0, 0], 1) == 5\nTC10: assert longestSubarrWthSumDivByK([-1, -2, -3, -4, -5], 3) == 2\nTC11: assert longestSubarrWthSumDivByK([13, 8, 5, 8, 20], 8) == 3\nTC12: assert longestSubarrWthSumDivByK([], 5) == 0\nTC13: assert longestSubarrWthSumDivByK([7, 14, 21, 28, 35], 7) == 5"}, {"author": "Karthik", "UUID": "b9f3e5e1-657a-413f-a266-970047b2222c", "question": "Given an array of size N and an integer K, return the count of distinct numbers in all windows of size K. ", "examples": "Input: arr[] = {1, 2, 1, 3, 4, 2, 3}, K = 4\nOutput: 3 4 4 3\nExplanation: First window is {1, 2, 1, 3}, count of distinct numbers is 3\n                      Second window is {2, 1, 3, 4} count of distinct numbers is 4\n                      Third window is {1, 3, 4, 2} count of distinct numbers is 4\n                      Fourth window is {3, 4, 2, 3} count of distinct numbers is 3\n\nInput: arr[] = {1, 2, 4, 4}, K = 2\nOutput: 2 2 1\nExplanation: First window is {1, 2}, count of distinct numbers is 2\n                      First window is {2, 4}, count of distinct numbers is 2\n                      First window is {4, 4}, count of distinct numbers is 1", "link": "https://www.geeksforgeeks.org/count-distinct-elements-in-every-window-of-size-k/", "difficulty": "Medium", "categories": ["Hash"], "code": "def countDistinct(arr: list, K: int) -> list:\n        def countWindowDistinct(win, K):\n                dist_count = 0\n                for i in range(K):\n                        j = 0\n                        while j < i:\n                                if (win[i] == win[j]):\n                                        break\n                                else:\n                                        j += 1\n                        if (j == i):\n                                dist_count += 1\n\n                return dist_count\n        N = len(arr)\n        result = []\n        for i in range(N - K + 1):\n                result.append(countWindowDistinct(arr[i:K + i], K))\n        return result\n", "asserts": ["assert countDistinct([1, 2, 1, 3, 4, 2, 3], 4) == [3,4,4,3]"], "gen_asserts": "\n```python\nTC2: assert countDistinct([7, 5, 5, 3, 5, 1, 5], 3) == [2, 2, 3, 2, 2]\nTC3: assert countDistinct([10, 10, 10, 10], 1) == [1, 1, 1, 1]\nTC4: assert countDistinct([1, 2, 3, 2, 2, 1, 3, 4, 5, 6], 5) == [3, 3, 3, 4, 4, 5]\nTC5: assert countDistinct([1], 1) == [1]\nTC6: assert countDistinct([4, 4, 4, 4, 4, 4, 4], 4) == [1, 1, 1, 1]\nTC7: assert countDistinct([9, 8, 7, 8, 7, 6, 5], 3) == [3, 2, 2, 3, 3]\nTC8: assert countDistinct([2, 3, 2, 3, 4, 2, 2, 3, 2], 4) == [2, 3, 3, 2, 2, 3]\nTC9: assert countDistinct([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10) == [10]\n```"}, {"author": "Karthik", "UUID": "d43ea585-bcee-4a3b-b341-aad2988f7cac", "question": "Given an array containing only 0s and 1s, find the length of the largest subarray which contains equal no of 0s and 1s. The expected time complexity is O(n). If no such array, return -1", "examples": "Input: arr[] = {1, 0, 1, 1, 1, 0, 0}\nOutput: 6\n(Starting and Ending indexes of output subarray)\n\nInput: arr[] = {1, 1, 1, 1}\nOutput: -1\n\nInput: arr[] = {0, 0, 1, 1, 0}\nOutput: 4", "link": "https://www.geeksforgeeks.org/largest-subarray-with-equal-number-of-0s-and-1s/", "difficulty": "Hard", "categories": ["Hash"], "code": "def findSubArray(arr: list) -> int:\n        n = len(arr)\n        sum = 0\n        maxsize = -1\n        for i in range(0, n-1):\n        \n                sum = -1 if(arr[i] == 0) else 1\n                for j in range(i + 1, n):\n                        sum = sum + (-1) if (arr[j] == 0) else sum + 1\n\n                        if (sum == 0 and maxsize < j-i + 1):\n                                \n                                maxsize = j - i + 1\n                                startindex = i\n        return maxsize\n", "asserts": ["assert findSubArray([1, 0, 0, 1, 0, 1, 1]) == 6"], "gen_asserts": "TC2: assert findSubArray([0, 1, 0, 1, 0, 1, 0, 1]) == 8\nTC3: assert findSubArray([1, 1, 1, 0, 0, 1, 0, 0, 1]) == 8\nTC4: assert findSubArray([0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == -1\nTC5: assert findSubArray([1, 0, 1, 0, 1, 0, 1, 1]) == 8\nTC6: assert findSubArray([0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0]) == 10\nTC7: assert findSubArray([1, 0, 1, 1, 0, 1, 0, 1, 0]) == 8\nTC8: assert findSubArray([]) == -1\nTC9: assert findSubArray([1, 0]) == 2\nTC10: assert findSubArray([1, 0, 1]) == 2"}, {"author": "Karthik", "UUID": "3418f7cc-2703-4dbb-8705-e51df4295087", "question": "Given an array of n integers. Count the total number of sub-arrays having total distinct elements, the same as that of the total distinct elements of the original array. ", "examples": "Input  : arr[] = {2, 1, 3, 2, 3}\nOutput : 5\nTotal distinct elements in array is 3\nTotal sub-arrays that satisfy the condition \nare:  Subarray from index 0 to 2\n      Subarray from index 0 to 3\n      Subarray from index 0 to 4\n      Subarray from index 1 to 3\n      Subarray from index 1 to 4\n\nInput  : arr[] = {2, 4, 5, 2, 1}\nOutput : 2\n\nInput  : arr[] = {2, 4, 4, 2, 4}\nOutput : 9", "link": "https://www.geeksforgeeks.org/count-subarrays-total-distinct-elements-original-array/", "difficulty": "Hard", "categories": ["Hash"], "code": "\ndef countDistinctSubarray(arr: list) -> int:\n        n = len(arr)\n        unst1 = set(arr)\n        totalDist = len(unst1)\n        count = 0\n\n        for i in range(n):\n                unst = set()\n                for j in range(i, n):\n                        unst.add(arr[j])\n                        if len(unst) == totalDist:\n                                count += 1\n\n        return count\n", "asserts": ["assert countDistinctSubarray([2, 1, 3, 2, 3]) == 5"], "gen_asserts": "TC2: assert countDistinctSubarray([1, 2, 3, 4, 5]) == 1\nTC3: assert countDistinctSubarray([1, 1, 1, 1, 1]) == 5\nTC4: assert countDistinctSubarray([1, 2, 1, 2, 3]) == 3\nTC5: assert countDistinctSubarray([10, 10, 10, 20, 30, 40, 10]) == 5\nTC6: assert countDistinctSubarray([1, 2, 2, 3, 4, 1, 3, 4]) == 3\nTC7: assert countDistinctSubarray([5, 7, 5, 2, 7, 2, 5, 7]) == 6\nTC8: assert countDistinctSubarray([8, 8, 8, 8, 9, 8, 8, 8, 9]) == 10\nTC9: assert countDistinctSubarray([1]) == 1\nTC10: assert countDistinctSubarray([]) == 0"}, {"author": "Karthik", "UUID": "06becabf-b745-4905-bc52-d291d0c15e0d", "question": "A rotation (or circular shift) is an operation similar to shift except that the bits that fall off at one end are put back to the other end. In left rotation, the bits that fall off at left end are put back at right end. Write a program to left rotate the bits of a number by d places", "examples": "Let n is stored using 8 bits. Left rotation of n = 11100101 by 3 makes n = 00101111 (Left shifted by 3 and first 3 bits are put back in last ). If n is stored using 16 bits or 32 bits then left rotation of n (000\u202611100101) becomes 00..0011100101000", "link": "https://www.geeksforgeeks.org/rotate-bits-of-an-integer/", "difficulty": "Easy", "categories": ["Bitwise Algorithms"], "code": "INT_BITS = 32\ndef leftRotate(n: int, d: int) -> int:\n        return (n << d)|(n >> (INT_BITS - d))\n", "asserts": ["assert leftRotate(16, 2) == 64"], "gen_asserts": "TC2: assert leftRotate(29, 3) == 232\nTC3: assert leftRotate(0, 1) == 0\nTC4: assert leftRotate(1, 5) == 32\nTC5: assert leftRotate(255, 7) == 255\nTC6: assert leftRotate(19, 4) == 304\nTC7: assert leftRotate(1024, 10) == 4194304\nTC8: assert leftRotate(345, 8) == 88320\nTC9: assert leftRotate(256, 8) == 65536\nTC10: assert leftRotate(2, 1) == 4"}, {"author": "Karthik", "UUID": "4fba2bf1-fda1-48e9-9c2a-bc3ed4718da0", "question": "Given a positive integer n, write a function to find if it is a power of 2 or not", "examples": "Input : n = 4\nOutput : Yes\nExplanation: 22 = 4\n\nInput : n = 32\nOutput : Yes\nExplanation: 25 = 32", "link": "https://www.geeksforgeeks.org/program-to-find-whether-a-given-number-is-power-of-2/", "difficulty": "Easy", "categories": ["Bitwise Algorithms"], "code": "import math\n\ndef Log2(x):\n        if x == 0:\n                return False\n\n        return (math.log10(x) /\n                        math.log10(2))\n\ndef isPowerOfTwo(n: int) -> bool:\n        return (math.ceil(Log2(n)) ==\n                        math.floor(Log2(n)))\n", "asserts": ["assert isPowerOfTwo(31) == False"], "gen_asserts": "TC2: assert isPowerOfTwo(1) == True\nTC3: assert isPowerOfTwo(1024) == True\nTC4: assert isPowerOfTwo(0) == False\nTC5: assert isPowerOfTwo(3) == False\nTC6: assert isPowerOfTwo(64) == True\nTC7: assert isPowerOfTwo(65) == False\nTC8: assert isPowerOfTwo(8192) == True\nTC9: assert isPowerOfTwo(16384) == True\nTC10: assert isPowerOfTwo(-2) == False\nTC11: assert isPowerOfTwo(999) == False\nTC12: assert isPowerOfTwo(65536) == True"}, {"author": "Karthik", "UUID": "09d82a2d-5a3f-449f-bc1a-4f24cf4328e6", "question": "Given a number x and two positions (from the right side) in the binary representation of x, write a function that swaps n bits at the given two positions and returns the result. It is also given that the two sets of bits do not overlap.", "examples": "Input:\nx = 47 (00101111)\np1 = 1 (Start from the second bit from the right side)\np2 = 5 (Start from the 6th bit from the right side)\nn = 3 (No of bits to be swapped)\nOutput:\n227 (11100011)\nThe 3 bits starting from the second bit (from the right side) are \nswapped with 3 bits starting from 6th position (from the right side)", "link": "https://www.geeksforgeeks.org/swap-bits-in-a-given-number/", "difficulty": "Medium", "categories": ["Bitwise Algorithms"], "code": "def swapBits(x: int, p1: int, p2: int, n: int) -> int:\n        set1 = (x >> p1) & ((1<< n) - 1)\n        set2 = (x >> p2) & ((1 << n) - 1)\n\n        xor = (set1 ^ set2)\n        xor = (xor << p1) | (xor << p2)\n        result = x ^ xor\n\n        return result\n", "asserts": ["assert swapBits(47, 1, 5, 3) == 227"], "gen_asserts": "TC2: assert swapBits(28, 0, 3, 2) == 7\nTC3: assert swapBits(58, 1, 4, 3) == 29\nTC4: assert swapBits(1023, 0, 10, 4) == 895\nTC5: assert swapBits(0, 2, 6, 1) == 0\nTC6: assert swapBits(129, 0, 7, 1) == 1\nTC7: assert swapBits(255, 4, 7, 2) == 255\nTC8: assert swapBits(43690, 1, 9, 4) == 52482\nTC9: assert swapBits(65535, 8, 16, 8) == 65535\nTC10: assert swapBits(34522, 2, 10, 5) == 40234"}, {"author": "Karthik", "UUID": "b07b0bf3-3482-489e-99b5-c21f11e3cd29", "question": "Given an array of integers. The task is to find the maximum subarray XOR value in the given array.", "examples": "Input: arr[] = {1, 2, 3, 4}\nOutput: 7\nExplanation: The subarray {3, 4} has maximum XOR value\n\nInput: arr[] = {8, 1, 2, 12, 7, 6}\nOutput: 15\nExplanation: The subarray {1, 2, 12} has maximum XOR value", "link": "https://www.geeksforgeeks.org/find-the-maximum-subarray-xor-in-a-given-array/", "difficulty": "Hard", "categories": ["Bitwise Algorithms"], "code": "def maxSubarrayXOR(arr: list) -> int:\n        n = len(arr)\n        ans = -2147483648\n\n        for i in range(n):\n                curr_xor = 0\n                for j in range(i,n):\n                \n                        curr_xor = curr_xor ^ arr[j]\n                        ans = max(ans, curr_xor)\n        return ans\n", "asserts": ["assert maxSubarrayXOR([1, 2, 3, 4]) == 7"], "gen_asserts": "TC2: assert maxSubarrayXOR([0]) == 0\nTC3: assert maxSubarrayXOR([4, 2, 1, 6, 5]) == 7\nTC4: assert maxSubarrayXOR([9, 8, 5]) == 13\nTC5: assert maxSubarrayXOR([2, 5, 8, 1, 1, 7]) == 11\nTC6: assert maxSubarrayXOR([-1, -2, -3, -4]) == -1\nTC7: assert maxSubarrayXOR([10, -13, 5, 2, -11, 12]) == 15\nTC8: assert maxSubarrayXOR([0, 0, 0, 0]) == 0\nTC9: assert maxSubarrayXOR([1, 2, 3, 4, 5, 6, 7, 8]) == 15\nTC10: assert maxSubarrayXOR([4, 17]) == 21\nTC11: assert maxSubarrayXOR([14, 70, 53, 83, 49, 91, 36, 80, 92, 51, 66, 70]) == 127\nTC12: assert maxSubarrayXOR([10, 11, 1, 2, 3]) == 15\nTC13: assert maxSubarrayXOR([12, 15, 7, 9, 8, 10]) == 31\nTC14: assert maxSubarrayXOR([0, 1, 10, 7, 6, 2, 5]) == 15\nTC15: assert maxSubarrayXOR([10, 11, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0]) == 31\n\nNote: In the case of TC6, even though the values are negative, the function should still be able to handle it correctly. The XOR of any number with itself is 0, and with -1 (0xFFFF...FF) flips all bits, effectively giving the complement. Hence, the maximum subarray XOR value here is the one that has a single element, which is the maximum value in the absolute sense (the least negative), that is -1."}, {"author": "Karthik", "UUID": "8714ed57-3a2b-4115-b4d8-100182b1f6bb", "question": "Write a function to to convert a floating point number to binary", "examples": "Enter your floating point value : \n11.234\nEnter the number of decimal places of the result : \n4\n\n1011.0011\n\nEnter your floating point value : \n1.234\nEnter the number of decimal places of the result :\n4\n\n1.0011", "link": "https://www.geeksforgeeks.org/python-program-to-convert-floating-to-binary/", "difficulty": "Hard", "categories": ["Bitwise Algorithms"], "code": "def float_bin(number: float, places : int =  3) -> str:\n    def decimal_converter(num): \n        while num > 1:\n                num /= 10\n        return num\n    whole, dec = str(number).split(\".\")\n    whole = int(whole)\n    dec = int (dec)\n    res = bin(whole).lstrip(\"0b\") + \".\"\n    for x in range(places):\n            whole, dec = str((decimal_converter(dec)) * 2).split(\".\")\n            dec = int(dec)\n            res += whole\n    return res\n", "asserts": ["assert float_bin(11.234, 4) == '1011.0011'"], "gen_asserts": "TC2: assert float_bin(5.375, 5) == '101.01100'\nTC3: assert float_bin(0.85, 4) == '0.1101'\nTC4: assert float_bin(100.101, 6) == '1100100.000110'\nTC5: assert float_bin(3.14159, 5) == '11.00100'\nTC6: assert float_bin(0.5, 2) == '0.10'\nTC7: assert float_bin(0.1, 8) == '0.00011001'\nTC8: assert float_bin(1234.5678, 7) == '10011010010.1001000'\nTC9: assert float_bin(255.255, 4) == '11111111.0100'\nTC10: assert float_bin(0.0, 3) == '0.000'\nTC11: assert float_bin(2.0, 3) == '10.000'\nTC12: assert float_bin(-4.75, 4) == '-100.1100'  # Additional test case for negative numbers\nTC13: assert float_bin(10.0, 0) == '1010'        # Additional test case with zero decimal places\nTC14: assert float_bin(2.625, 3) == '10.101'     # Additional test case with exact binary representation\n\nNote: The function provided seems to have a logical error in the decimal_converter function and does not handle negative numbers or cases where the decimal places result in a repeating binary fraction. The test cases provided are based on the assumption that the function works correctly after appropriate modifications to handle these cases."}, {"author": "Karthik", "UUID": "a1eec3ae-a390-4b99-90ae-8520d462bd27", "question": "We are given an array of n distinct numbers. The task is to sort all even-placed numbers in increasing and odd-placed numbers in decreasing order. The modified array should contain all sorted even-placed numbers followed by reverse sorted odd-placed numbers. \nNote that the first element is considered as even placed because of its index 0. ", "examples": "Input:  arr[] = {0, 1, 2, 3, 4, 5, 6, 7}\nOutput: arr[] = {0, 2, 4, 6, 7, 5, 3, 1}\nEven-place elements : 0, 2, 4, 6\nOdd-place elements : 1, 3, 5, 7\nEven-place elements in increasing order : \n0, 2, 4, 6\nOdd-Place elements in decreasing order : \n7, 5, 3, 1\n\nInput: arr[] = {3, 1, 2, 4, 5, 9, 13, 14, 12}\nOutput: {2, 3, 5, 12, 13, 14, 9, 4, 1}\nEven-place elements : 3, 2, 5, 13, 12\nOdd-place elements : 1, 4, 9, 14\nEven-place elements in increasing order : \n2, 3, 5, 12, 13\nOdd-Place elements in decreasing order : \n14, 9, 4, 1 ", "link": "https://www.geeksforgeeks.org/sort-even-placed-elements-increasing-odd-placed-decreasing-order/", "difficulty": "Easy", "categories": ["Sorting Algorithms"], "code": "def bitonicGenerator(arr: list) -> list:\n        n = len(arr) \n        evenArr = [] \n        oddArr = [] \n        for i in range(n): \n                if ((i % 2) == 0): \n                        evenArr.append(arr[i]) \n                else: \n                        oddArr.append(arr[i]) \n        evenArr = sorted(evenArr) \n        oddArr = sorted(oddArr) \n        oddArr = oddArr[::-1] \n\n        i = 0\n        for j in range(len(evenArr)): \n                arr[i] = evenArr[j] \n                i += 1\n        for j in range(len(oddArr)): \n                arr[i] = oddArr[j] \n                i += 1\n        return arr\n", "asserts": ["assert bitonicGenerator([0, 1, 2, 3, 4, 5, 6, 7]) == [0, 2, 4, 6, 7, 5, 3, 1]"], "gen_asserts": "TC2: assert bitonicGenerator([5, 3, 8, 9, 10, 2, 1, 6, 7, 4]) == [5, 8, 10, 7, 6, 9, 4, 3, 2, 1]\nTC3: assert bitonicGenerator([10, 7, 9, 2, 5, 8, 3]) == [5, 9, 10, 8, 7, 3, 2]\nTC4: assert bitonicGenerator([4, 1, 3, 2, 8, 6, 7, 5]) == [3, 4, 7, 8, 6, 5, 2, 1]\nTC5: assert bitonicGenerator([11, 14, 16, 18, 12, 13]) == [11, 14, 16, 18, 13, 12]\nTC6: assert bitonicGenerator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 3, 5, 7, 9, 11, 10, 8, 6, 4, 2]\nTC7: assert bitonicGenerator([6, 3, 1, 4, 5, 2]) == [1, 5, 6, 4, 3, 2]\nTC8: assert bitonicGenerator([7, 4, 1, 9]) == [1, 7, 9, 4]\nTC9: assert bitonicGenerator([1]) == [1]\nTC10: assert bitonicGenerator([]) == []"}, {"author": "Karthik", "UUID": "99fa7e96-23ff-4c94-951a-98176d1045cb", "question": "Given two arrays that have the same values but in a different order and having no duplicate elements in it, we need to make a second array the same as a first array using the minimum number of swaps. ", "examples": "Input  : arrA[] = {3, 6, 4, 8}, \n         arrB[] = {4, 6, 8, 3}\nOutput : 2\nExplanation: we can make arrB to same as arrA in 2 swaps which are shown below, swap 4 with 8,\narrB = {8, 6, 4, 3} swap 8 with 3,   arrB = {3, 6, 4, 8}", "link": "https://www.geeksforgeeks.org/minimum-swaps-to-make-two-array-identical/", "difficulty": "Medium", "categories": ["Sorting Algorithms"], "code": "def minSwapsToSort(arr):\n        n = len(arr)\n        arrPos = [[0 for x in range(2)] \n                                for y in range(n)] \n        \n        for i in range(n):         \n                arrPos[i][0] = arr[i] \n                arrPos[i][1] = i \n        arrPos.sort() \n        vis = [False] * (n) \n        ans = 0\n\n        for i in range(n): \n                if (vis[i] or arrPos[i][1] == i): \n                        continue\n                cycle_size = 0\n                j = i \n                \n                while (not vis[j]):                 \n                        vis[j] = 1\n                        j = arrPos[j][1] \n                        cycle_size+= 1\n                ans += (cycle_size - 1) \n\n        return ans \n\ndef minSwapToMakeArraySame(a: list, b: list) -> int:\n        n = len(a) \n        mp = {} \n        for i in range(n): \n                mp[b[i]] = i \n        for i in range(n): \n                b[i] = mp[a[i]] \n        return minSwapsToSort(b) \n", "asserts": ["assert minSwapToMakeArraySame([3, 6, 4, 8], [4, 6, 8, 3]) == 2"], "gen_asserts": "TC2: assert minSwapToMakeArraySame([1, 5, 3, 7, 2], [2, 3, 5, 1, 7]) == 3\nExplanation: Swap 2 with 5, Swap 2 with 1, Swap 2 with 7 to make the second array same as first.\n\nTC3: assert minSwapToMakeArraySame([10, 19, 6, 3, 5], [3, 6, 10, 5, 19]) == 3\nExplanation: Swap 3 with 10, Swap 3 with 5, Swap 3 with 19 to make the second array same as first.\n\nTC4: assert minSwapToMakeArraySame([12, 14, 11, 15], [14, 12, 15, 11]) == 2\nExplanation: Swap 14 with 12, Swap 14 with 11 to make the second array same as first.\n\nTC5: assert minSwapToMakeArraySame([1, 2, 3, 4, 5], [5, 4, 3, 2, 1]) == 2\nExplanation: Swap 5 with 1, Swap 5 with 2 to make the second array same as first.\n\nTC6: assert minSwapToMakeArraySame([100, 300, 200, 400], [200, 100, 400, 300]) == 2\nExplanation: Swap 200 with 300, Swap 200 with 100 to make the second array same as first.\n\nTC7: assert minSwapToMakeArraySame([8, 1, 5, 2, 4], [2, 5, 1, 4, 8]) == 4\nExplanation: Swap 2 with 8, Swap 2 with 1, Swap 5 with 2, Swap 5 with 4 to make the second array same as first.\n\nTC8: assert minSwapToMakeArraySame([17, 4, 20, 2], [4, 17, 2, 20]) == 1\nExplanation: Swap 4 with 17 to make the second array same as first.\n\nPlease note that the generated test cases should not include the case present in the examples."}, {"author": "Karthik", "UUID": "039c3ece-6170-412d-ae03-6d0825e0e340", "question": "Given a two strings S and T, find the count of distinct occurrences of T in S as a subsequence.", "examples": "Input: S = banana, T = ban\nOutput: 3\nExplanation: T appears in S as below three subsequences.\n[ban], [ba  n], [b   an]\n\nInput: S = geeksforgeeks, T = ge\nOutput: 6\nExplanation: T appears in S as below six subsequences.\n[ge], [     ge], [g e], [g    e] [g     e]\nand [     g e] ", "link": "https://www.geeksforgeeks.org/count-distinct-occurrences-as-a-subsequence/", "difficulty": "Hard", "categories": ["Sorting Algorithms"], "code": "def findSubsequenceCount(s: str, t: str) -> int:\n    def f(i, j, s, t):\n        if(j >= len(t)):\n                return 1\n        \n        if(i >= len(s)):\n                return 0\n        \n        if(s[i] == t[j]):\n                return f(i + 1, j + 1, s, t) + f(i + 1, j, s, t)\n        \n        return f(i + 1, j, s, t)\n    return f(0, 0, s, t)\n", "asserts": ["assert findSubsequenceCount(\"banana\", \"ban\") == 3"], "gen_asserts": "TC2: assert findSubsequenceCount(\"aabba\", \"ab\") == 4\nExplanation: T appears in S as below four subsequences.\n[a b], [a  b], [  ab], [   ab]\n\nTC3: assert findSubsequenceCount(\"testtest\", \"tt\") == 6\nExplanation: T appears in S as below six subsequences.\n[t   t], [t    t], [t     t], [ t   t], [  t    t], [   t   t]\n\nTC4: assert findSubsequenceCount(\"xxyxyyx\", \"xy\") == 6\nExplanation: T appears in S as below six subsequences.\n[x y], [x  y], [x   y], [  xy], [  x y], [   xy]\n\nTC5: assert findSubsequenceCount(\"aaaaaa\", \"aaa\") == 20\nExplanation: T appears in S as multiple overlapping subsequences, with each character able to start a new subsequence.\n\nTC6: assert findSubsequenceCount(\"mississippi\", \"sip\") == 4\nExplanation: T appears in S as below four subsequences.\n[si    p], [   sip], [    si  p], [     sip]\n\nTC7: assert findSubsequenceCount(\"abcdefg\", \"xyz\") == 0\nExplanation: T does not appear in S because none of the characters in T are in S.\n\nTC8: assert findSubsequenceCount(\"aabaa\", \"aa\") == 6\nExplanation: T appears in S as below six subsequences.\n[aa], [a a], [a  a], [ aa], [ a a], [  aa] \n\nTC9: assert findSubsequenceCount(\"complexity\", \"pty\") == 2\nExplanation: T appears in S as below two subsequences.\n[      p t y], [       pt y]\n\nTC10: assert findSubsequenceCount(\"\", \"nonempty\") == 0\nExplanation: T cannot appear in S because S is empty.\n\nTC11: assert findSubsequenceCount(\"nonempty\", \"\") == 1\nExplanation: The empty string is a subsequence of any string, so there is one occurrence.\n\nTC12: assert findSubsequenceCount(\"abc\", \"abc\") == 1\nExplanation: T appears in S as one subsequence, which is equal to the entire S string."}, {"author": "Hafeez", "UUID": "6aaf1310-7585-4d90-91e7-1f405c9b25e7", "question": "Get Maximum in Generated Array: You are given an integer n. A 0-indexed integer array nums of length n + 1 is generated in the following way:\n\nnums[0] = 0\nnums[1] = 1\nnums[2 * i] = nums[i] when 2 <= 2 * i <= n\nnums[2 * i + 1] = nums[i] + nums[i + 1] when 2 <= 2 * i + 1 <= n\nReturn the maximum integer in the array nums\u200b\u200b\u200b.", "examples": "Input: n = 7\nOutput: 3\nExplanation: According to the given rules:\n  nums[0] = 0\n  nums[1] = 1\n  nums[(1 * 2) = 2] = nums[1] = 1\n  nums[(1 * 2) + 1 = 3] = nums[1] + nums[2] = 1 + 1 = 2\n  nums[(2 * 2) = 4] = nums[2] = 1\n  nums[(2 * 2) + 1 = 5] = nums[2] + nums[3] = 1 + 2 = 3\n  nums[(3 * 2) = 6] = nums[3] = 2\n  nums[(3 * 2) + 1 = 7] = nums[3] + nums[4] = 2 + 1 = 3\nHence, nums = [0,1,1,2,1,3,2,3], and the maximum is max(0,1,1,2,1,3,2,3) = 3.\nInput: n = 2\nOutput: 1\nExplanation: According to the given rules, nums = [0,1,1]. The maximum is max(0,1,1) = 1.\nInput: n = 3\nOutput: 2\nExplanation: According to the given rules, nums = [0,1,1,2]. The maximum is max(0,1,1,2) = 2.", "link": "https://leetcode.com/problems/get-maximum-in-generated-array/", "difficulty": "Easy", "categories": ["Dynamic Programming"], "code": "def getMaximumGenerated(n: int) -> int:\n    if n<2:\n        return n\n    nums=[0]*(n+1)\n    nums[0]=0\n    nums[1]=1\n    for i in range(2,n+1):\n        if i%2==0:\n            nums[i]=nums[i//2]\n        else:\n            nums[i]=nums[i//2]+nums[i//2+1]\n    return max(nums)", "asserts": ["assert getMaximumGenerated(2)==1"], "gen_asserts": "TC2: assert getMaximumGenerated(4) == 2\nExplanation: nums = [0, 1, 1, 2, 1], and the maximum is max(0, 1, 1, 2, 1) = 2.\n\nTC3: assert getMaximumGenerated(5) == 3\nExplanation: nums = [0, 1, 1, 2, 1, 3], and the maximum is max(0, 1, 1, 2, 1, 3) = 3.\n\nTC4: assert getMaximumGenerated(8) == 3\nExplanation: nums = [0, 1, 1, 2, 1, 3, 2, 3, 1], and the maximum is max(0, 1, 1, 2, 1, 3, 2, 3, 1) = 3.\n\nTC5: assert getMaximumGenerated(15) == 5\nExplanation: nums = [0, 1, 1, 2, 1, 3, 2, 3, 1, 4, 3, 5, 3, 4, 2, 5], and the maximum is max(0, 1, 1, 2, 1, 3, 2, 3, 1, 4, 3, 5, 3, 4, 2, 5) = 5.\n\nTC6: assert getMaximumGenerated(0) == 0\nExplanation: nums = [0], and the maximum is max(0) = 0.\n\nTC7: assert getMaximumGenerated(1) == 1\nExplanation: nums = [0, 1], and the maximum is max(0, 1) = 1.\n\nTC8: assert getMaximumGenerated(25) == 9\nExplanation: The maximum value generated for n = 25 is 9, given the rule for creating the array.\n\nTC9: assert getMaximumGenerated(10) == 5\nExplanation: nums = [0, 1, 1, 2, 1, 3, 2, 3, 1, 4, 3, 5], and the maximum is max(0, 1, 1, 2, 1, 3, 2, 3, 1, 4, 3, 5) = 5. \n\nTC10: assert getMaximumGenerated(50) == 21\nExplanation: nums contains values up to 21 for n = 50."}, {"author": "Hafeez", "UUID": "d695e67c-5b0e-4235-8406-30ee6be61173", "question": "N-th Tribonacci Number: The Tribonacci sequence Tn is defined as follows: \n\nT0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n >= 0.\n\nGiven n, return the value of Tn.", "examples": "Input: n = 4\nOutput: 4\nExplanation:\nT_3 = 0 + 1 + 1 = 2\nT_4 = 1 + 1 + 2 = 4", "link": "https://leetcode.com/problems/n-th-tribonacci-number/description/", "difficulty": "Easy", "categories": ["Dynamic Programming"], "code": "def tribonacci(n: int) -> int:\n    dp = {0: 0, 1: 1, 2: 1}\n    def dfs(i):\n        if i in dp:\n            return dp[i]\n        dp[i] = dfs(i - 1) + dfs(i - 2) + dfs(i - 3)\n        return dp[i]\n    \n    return dfs(n)", "asserts": ["assert tribonacci(25)==1389537"], "gen_asserts": "TC2: assert tribonacci(0) == 0\nTC3: assert tribonacci(1) == 1\nTC4: assert tribonacci(2) == 1\nTC5: assert tribonacci(3) == 2\nTC6: assert tribonacci(5) == 7\nTC7: assert tribonacci(7) == 24\nTC8: assert tribonacci(10) == 149\nTC9: assert tribonacci(15) == 3136\nTC10: assert tribonacci(20) == 35890\nTC11: assert tribonacci(30) == 29249425\nTC12: assert tribonacci(35) == 2082876103"}, {"author": "Hafeez", "UUID": "38dca76c-ee6c-4c71-83a9-89240828a3b7", "question": "Best Time to Buy and Sell Stock II: You are given an integer array prices where prices[i] is the price of a given stock on the ith day.\n\nOn each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day.\n\nFind and return the maximum profit you can achieve.", "examples": "Input: prices = [7,1,5,3,6,4]\nOutput: 7\nExplanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\nThen buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.\nTotal profit is 4 + 3 = 7.\nInput: prices = [7,6,4,3,1]\nOutput: 0\nExplanation: There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0.", "link": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/", "difficulty": "Medium", "categories": ["Dynamic Programming"], "code": "from typing import List\ndef maxProfit(prices: List[int]) -> int:\n    cur_hold, cur_not_hold = -float('inf'), 0\n    \n    for stock_price in prices:\n        \n        prev_hold, prev_not_hold = cur_hold, cur_not_hold\n        cur_hold = max( prev_hold, prev_not_hold - stock_price )\n        cur_not_hold = max( prev_not_hold, prev_hold + stock_price )\n    return cur_not_hold", "asserts": ["assert maxProfit([1,2,3,4,5])==4"], "gen_asserts": "TC2: assert maxProfit([1,2,100,2,1]) == 99\nExplanation: Buy on day 1 (price = 1) and sell on day 3 (price = 100), profit = 100 - 1 = 99. No need to do further transactions.\n\nTC3: assert maxProfit([1,2,3,4,5,6,7,8,9,10])==9\nExplanation: Buy on day 1 (price = 1) and sell on day 10 (price = 10), profit = 10 - 1 = 9. There are no other transactions that would increase the profit.\n\nTC4: assert maxProfit([5,5,5,5,5])==0\nExplanation: The price does not change, so there is no profit to be made.\n\nTC5: assert maxProfit([10,9,8,7,6,5,4,3,2,1])==0\nExplanation: The price keeps dropping, so there is no profitable buy-sell pair.\n\nTC6: assert maxProfit([1,9,1,9,1,9,1,9,1,9])==40\nExplanation: Buy and sell repeatedly on the days the price is low and high, respectively to achieve 4 * (9 - 1) = 40.\n\nTC7: assert maxProfit([3,2,6,5,0,3])==7\nExplanation: Buy on day 2 (price = 2) and sell on day 3 (price = 6), profit = 6 - 2 = 4. Then buy on day 5 (price = 0) and sell on day 6 (price = 3), profit = 3 - 0 = 3. Total profit is 4 + 3 = 7.\n\nTC8: assert maxProfit([100])==0\nExplanation: Only one price is given, so no transaction can be made.\n\nTC9: assert maxProfit([8,1,5,3,6,4,6,4,3,7])==11\nExplanation: Buy on day 2 (price = 1), sell on day 3 (price = 5), profit = 4. Buy on day 4 (price = 3), sell on day 5 (price = 6), profit = 3. Buy on day 6 (price = 4), sell on day 7 (price = 6), profit = 2. Buy on day 8 (price = 3), sell on day 10 (price = 7), profit = 4. Total profit is 4 + 3 + 2 + 4 = 13.\n\nTC10: assert maxProfit([3,3,5,0,0,3,1,4])==8\nExplanation: Buy on day 3 (price = 5), sell on day 6 (price = 3), profit = -2. Buy on day 7 (price = 1), sell on day 8 (price = 4), profit = 3. Total profit is -2 + 3 + 7 = 8."}, {"author": "Hafeez", "UUID": "296ab89e-7208-4f6f-bed1-d623f30e32c9", "question": "Coin Change II: You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.\n\nReturn the number of combinations that make up that amount. If that amount of money cannot be made up by any combination of the coins, return 0.\n\nYou may assume that you have an infinite number of each kind of coin.\n\nThe answer is guaranteed to fit into a signed 32-bit integer.", "examples": "Input: amount = 5, coins = [1,2,5]\nOutput: 4\nExplanation: there are four ways to make up the amount:\n5=5\n5=2+2+1\n5=2+1+1+1\n5=1+1+1+1+1\nInput: amount = 3, coins = [2]\nOutput: 0\nExplanation: the amount of 3 cannot be made up just with coins of 2.", "link": "https://leetcode.com/problems/coin-change-ii/description/", "difficulty": "Medium", "categories": ["Dynamic Programming"], "code": "from typing import List\ndef change(amount: int, coins: List[int]) -> int:\n    def numberOfWays(i: int, amount: int) -> int:\n        if amount == 0:\n            return 1\n        if i == len(coins):\n            return 0\n        if memo[i][amount] != -1:\n            return memo[i][amount]\n\n        if coins[i] > amount:\n            memo[i][amount] = numberOfWays(i + 1, amount)\n        else:\n            memo[i][amount] = numberOfWays(i, amount - coins[i]) + numberOfWays(i + 1, amount)\n        \n        return memo[i][amount]\n\n    memo = [[-1] * (amount + 1) for _ in range(len(coins))]\n    return numberOfWays(0, amount)", "asserts": ["assert change(10,[10])==1"], "gen_asserts": "TC2: assert change(0, [1, 2, 5]) == 1  # Edge case: trying to make 0 with any coins should always return 1\nTC3: assert change(100, [1, 2, 5, 10, 20, 50]) == 629  # Larger amount with multiple coins\nTC4: assert change(11, [5]) == 0  # Amount cannot be made up with given coins\nTC5: assert change(8, [1, 4]) == 2  # Amount can be made up with given coins in a couple of ways: [4, 4], [1, 1, 1, 1, 4]\nTC6: assert change(500, [3, 5, 7, 8, 9, 10, 20]) == 35502874  # Very large amount with multiple coin options\nTC7: assert change(0, []) == 1  # Edge case: trying to make 0 without any coins, should return 1 as there's one way of making 0 with no coins\nTC8: assert change(7, [2, 3, 6]) == 2  # Amount can be made up with given coins: [2, 2, 3], [3, 2, 2]\nTC9: assert change(5, [5, 1]) == 2  # Amount can be made with given coins: [5], [1, 1, 1, 1, 1]"}, {"author": "Hafeez", "UUID": "b6f47e1f-52e7-4dca-837f-88bc0d3b7a5a", "question": "Backspace String Compare: Given two strings s and t, return true if they are equal when both are typed into empty text editors. '#' means a backspace character.\n\nNote that after backspacing an empty text, the text will continue empty.", "examples": "Input: s = \"ab#c\", t = \"ad#c\"\nOutput: True\nExplanation: Both s and t become \"ac\".\nInput: s = \"a#c\", t = \"b\"\nOutput: False\nExplanation: s becomes \"c\" while t becomes \"b\".", "link": "https://leetcode.com/problems/backspace-string-compare/description/", "difficulty": "Easy", "categories": ["Stack"], "code": "def backspaceCompare(S: str, T: str) -> bool:\n    def build(S):\n        ans = []\n        for c in S:\n            if c != '#':\n                ans.append(c)\n            elif ans:\n                ans.pop()\n        return \"\".join(ans)\n    return build(S) == build(T)\n", "asserts": ["assert backspaceCompare(\"ab##\", \"c#d#\")==True"], "gen_asserts": "TC2: assert backspaceCompare(\"a##c\", \"#a#c\") == True\nTC3: assert backspaceCompare(\"abc#d\", \"acc#c\") == False\nTC4: assert backspaceCompare(\"xyz###\", \"x\") == True\nTC5: assert backspaceCompare(\"##xy\", \"y#x#\") == True\nTC6: assert backspaceCompare(\"p##qr\", \"p#q#r\") == False\nTC7: assert backspaceCompare(\"####\", \"b#\") == True\nTC8: assert backspaceCompare(\"\", \"b#\") == True\nTC9: assert backspaceCompare(\"a###b\", \"b\") == True\nTC10: assert backspaceCompare(\"a\", \"a#\") == False"}, {"author": "Hafeez", "UUID": "4b76d4d6-6dbe-4bcf-ba3f-9c6a418373ea", "question": "Valid Parentheses: Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.\n\nAn input string is valid if:\n\nOpen brackets must be closed by the same type of brackets.\nOpen brackets must be closed in the correct order.\nEvery close bracket has a corresponding open bracket of the same type.", "examples": "Input: s = \"()\"\nOutput: true\nInput: s = \"()[]{}\"\nOutput: true", "link": "https://leetcode.com/problems/valid-parentheses/description/", "difficulty": "Easy", "categories": ["Stack"], "code": "def isValid(s: str) -> bool:\n    stack = []\n    mapping = {\")\": \"(\", \"}\": \"{\", \"]\": \"[\"}\n    for char in s:\n        if char in mapping:\n            top_element = stack.pop() if stack else '#'\n            if mapping[char] != top_element:\n                return False\n        else:\n            stack.append(char)\n    return not stack\n", "asserts": ["assert isValid(\"(]\")==False"], "gen_asserts": "TC2: assert isValid(\"([)]\") == False\nTC3: assert isValid(\"{[]}\") == True\nTC4: assert isValid(\"((()))\") == True\nTC5: assert isValid(\")\") == False\nTC6: assert isValid(\"(}\") == False\nTC7: assert isValid(\"({})[]\") == True\nTC8: assert isValid(\"\") == True\nTC9: assert isValid(\"([]{})\") == True\nTC10: assert isValid(\"[({(())}[()])]\") == True\nTC11: assert isValid(\"(((((({{{{{{{[[[[[[]]]]]]}}}}}}}))))))\") == True\nTC12: assert isValid(\"{[}]\") == False\nTC13: assert isValid(\"([{])\") == False\nTC14: assert isValid(\"([\") == False\nTC15: assert isValid(\"([]\") == False\nTC16: assert isValid(\"[])\") == False\nTC17: assert isValid(\"{\") == False\nTC18: assert isValid(\"{}}\") == False"}, {"author": "Hafeez", "UUID": "2fb3578a-9202-463d-8eb1-88df11a49ca7", "question": "Minimum Remove to Make Valid Parentheses: Given a string s of '(' , ')' and lowercase English characters.\n\nYour task is to remove the minimum number of parentheses ( '(' or ')', in any positions ) so that the resulting parentheses string is valid and return any valid string.\n\nFormally, a parentheses string is valid if and only if:\n\nIt is the empty string, contains only lowercase characters, or\nIt can be written as AB (A concatenated with B), where A and B are valid strings, or\nIt can be written as (A), where A is a valid string.", "examples": "Input: s = \"lee(t(c)o)de)\"\nOutput: \"lee(t(c)o)de\"\nExplanation: \"lee(t(co)de)\" , \"lee(t(c)ode)\" would also be accepted.\nInput: s = \"a)b(c)d\"\nOutput: \"ab(c)d\"\nInput: s = \"))((\"\nOutput: \"\"\nExplanation: An empty string is also valid.", "link": "https://leetcode.com/problems/minimum-remove-to-make-valid-parentheses/description/", "difficulty": "Medium", "categories": ["Stack"], "code": "def minRemoveToMakeValid(s: str) -> str:\n    indexes_to_remove = set()\n    stack = []\n    for i, c in enumerate(s):\n        if c not in \"()\":\n            continue\n        if c == \"(\":\n            stack.append(i)\n        elif not stack:\n            indexes_to_remove.add(i)\n        else:\n            stack.pop()\n    indexes_to_remove = indexes_to_remove.union(set(stack))\n    string_builder = []\n    for i, c in enumerate(s):\n        if i not in indexes_to_remove:\n            string_builder.append(c)\n    return \"\".join(string_builder)", "asserts": ["assert minRemoveToMakeValid(\"a)b(c)d\")==\"ab(c)d\""], "gen_asserts": "Here are additional test cases starting from TC2:\n\nTC2: assert minRemoveToMakeValid(\"(a(b(c)d)\") == \"a(b(c)d)\"\nExplanation: Removing the first '(' creates a valid string.\n\nTC3: assert minRemoveToMakeValid(\")(\") == \"\"\nExplanation: Both parentheses have to be removed for the string to be valid, resulting in an empty string.\n\nTC4: assert minRemoveToMakeValid(\"(((xyz))\") == \"((xyz))\"\nExplanation: Only one '(' needs to be removed to make the string valid.\n\nTC5: assert minRemoveToMakeValid(\"()\") == \"()\"\nExplanation: The string is already valid, so no parentheses need to be removed.\n\nTC6: assert minRemoveToMakeValid(\"lee((t(c)o)de)\") == \"lee(t(c)o)de\"\nExplanation: Removing one of the '(' near the start creates a valid string.\n\nTC7: assert minRemoveToMakeValid(\"))(xyz)(\") == \"xyz\"\nExplanation: All unbalanced parentheses need to be removed, leaving just the characters.\n\nTC8: assert minRemoveToMakeValid(\"\") == \"\"\nExplanation: An empty string is already valid.\n\nTC9: assert minRemoveToMakeValid(\"p(rq)()(st)\") == \"p(rq)()(st)\"\nExplanation: The string is already valid, no parentheses need to be removed.\n\nTC10: assert minRemoveToMakeValid(\"(a(b)c)((d))\") == \"(a(b)c)(d)\"\nExplanation: There are extra parentheses around 'd' that can be removed for the string to still be valid.\n\nTC11: assert minRemoveToMakeValid(\"ab((cd)\") == \"abcd\"\nExplanation: The parentheses do not match and need to be removed.\n\nMake sure that none of the additional test cases overlap with the provided examples. The above test cases have been designed to cover a variety of scenarios including already valid strings, empty strings, and strings with both too many opening and closing parentheses."}, {"author": "Hafeez", "UUID": "a4782492-10a7-4601-a995-c1a0f9d57a67", "question": "Trapping Rain Water: Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.", "examples": "Input: height = [0,1,0,2,1,0,1,3,2,1,2,1]\nOutput: 6\nExplanation: The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped.\nInput: height = [4,2,0,3,2,5]\nOutput: 9", "link": "https://leetcode.com/problems/trapping-rain-water/description/", "difficulty": "Hard", "categories": ["Stack"], "code": "def trap(bars: list) -> int:\n    if not bars or len(bars) < 3:\n        return 0\n    volume = 0\n    left, right = 0, len(bars) - 1\n    l_max, r_max = bars[left], bars[right]\n    while left < right:\n        l_max, r_max = max(bars[left], l_max), max(bars[right], r_max)\n        if l_max <= r_max:\n            volume += l_max - bars[left]\n            left += 1\n        else:\n            volume += r_max - bars[right]\n            right -= 1\n    return volume\n", "asserts": ["assert trap([4,2,0,3,2,5])==9"], "gen_asserts": "TC2: assert trap([3, 0, 1, 3, 0, 5]) == 8\nTC3: assert trap([1, 2, 3, 4, 5, 6]) == 0\nTC4: assert trap([6, 5, 4, 3, 2, 1]) == 0\nTC5: assert trap([1, 0, 1, 0, 1, 0, 1]) == 3\nTC6: assert trap([2, 0, 2]) == 2\nTC7: assert trap([5, 4, 1, 2]) == 1\nTC8: assert trap([0, 7, 1, 4, 6]) == 7\nTC9: assert trap([9, 1, 2, 4, 2, 1, 3, 1, 4, 5]) == 23\nTC10: assert trap([0, 0, 0, 0, 0]) == 0\nTC11: assert trap([2, 1, 0, 1, 2, 1, 2, 1]) == 5\nTC12: assert trap([8, 10, 5, 6, 7, 4, 2, 3, 10]) == 17\nTC13: assert trap([3, 2, 4, 1, 2]) == 1\nTC14: assert trap([0, 1, 0, 2, 0, 1, 0, 3]) == 5\nTC15: assert trap([1, 3, 2, 4, 1, 3, 1, 4, 5, 2, 2, 1, 4, 2, 2]) == 15"}, {"author": "Hafeez", "UUID": "f4b91546-3f1c-4c4d-96a4-54541929438f", "question": "Majority Element: Given an array nums of size n, return the majority element.\n\nThe majority element is the element that appears more than \u230an / 2\u230b times. You may assume that the majority element always exists in the array.", "examples": "Input: nums = [3,2,3]\nOutput: 3", "link": "https://leetcode.com/problems/majority-element/description/", "difficulty": "Easy", "categories": ["Divide and Conquer"], "code": "def majorityElement(nums: list, lo: int = 0, hi: NoneType = None) -> int:\n    def majority_element_rec(lo, hi):\n        if lo == hi:\n            return nums[lo]\n        mid = (hi-lo)//2 + lo\n        left = majority_element_rec(lo, mid)\n        right = majority_element_rec(mid+1, hi)\n        if left == right:\n            return left\n        left_count = sum(1 for i in range(lo, hi+1) if nums[i] == left)\n        right_count = sum(1 for i in range(lo, hi+1) if nums[i] == right)\n\n        return left if left_count > right_count else right\n\n    return majority_element_rec(0, len(nums)-1)\n", "asserts": ["assert majorityElement([2,2,1,1,1,2,2])==2"], "gen_asserts": "TC2: assert majorityElement([1,1,1,2,2,2,2,1,1,1,1]) == 1\nTC3: assert majorityElement([7,7,7,7,5,1,7,7,7,3,4,7,7]) == 7\nTC4: assert majorityElement([4,4,2,4,4,2,4,4]) == 4\nTC5: assert majorityElement([0,0,0,0,1,1,1]) == 0\nTC6: assert majorityElement([11,11,11,11,11,12,11,13,11,11,14,11,11,11,11]) == 11\nTC7: assert majorityElement([-1,-1,2147483647]) == -1\nTC8: assert majorityElement([6,5,5]) == 5\nTC9: assert majorityElement([1,1,2,2,2]) == 2\nTC10: assert majorityElement([10]*50 + [20]*49) == 10"}, {"author": "Hafeez", "UUID": "828013d5-f389-4c8e-8e81-3caf3f2bf40b", "question": "Excel Sheet Column Number: Given a string columnTitle that represents the column title as appears in an Excel sheet, return its corresponding column number.\n\nFor example:\n\nA -> 1\nB -> 2\nC -> 3\n...\nZ -> 26\nAA -> 27\nAB -> 28 \n...\n", "examples": "Input: columnTitle = \"A\"\nOutput: 1\nInput: columnTitle = \"ZY\"\nOutput: 701", "link": "https://leetcode.com/problems/excel-sheet-column-number/description/", "difficulty": "Easy", "categories": ["Math"], "code": "def titleToNumber(s: str) -> int:\n    result = 0\n    alpha_map = {chr(i + 65): i + 1 for i in range(26)}\n    n = len(s)\n    for i in range(n):\n        cur_char = s[n - 1 - i]\n        result += (alpha_map[cur_char] * (26 ** i))\n    return result", "asserts": ["assert titleToNumber(\"AB\")==28"], "gen_asserts": "TC2: assert titleToNumber(\"AAA\") == 703\nTC3: assert titleToNumber(\"ZZZ\") == 18278\nTC4: assert titleToNumber(\"BZ\") == 78\nTC5: assert titleToNumber(\"YX\") == 650\nTC6: assert titleToNumber(\"CV\") == 100\nTC7: assert titleToNumber(\"RST\") == 29510\nTC8: assert titleToNumber(\"XFD\") == 16384\nTC9: assert titleToNumber(\"MNO\") == 10233\nTC10: assert titleToNumber(\"Q\") == 17"}, {"author": "Hafeez", "UUID": "de168393-5fd5-4856-89e1-a8722feeb70f", "question": "Arranging Coins: You have n coins and you want to build a staircase with these coins. The staircase consists of k rows where the ith row has exactly i coins. The last row of the staircase may be incomplete.\n\nGiven the integer n, return the number of complete rows of the staircase you will build.", "examples": "Input: n = 5\nOutput: 2\nExplanation: Because the 3rd row is incomplete, we return 2.", "link": "https://leetcode.com/problems/arranging-coins/description/", "difficulty": "Easy", "categories": ["Math"], "code": "def arrangeCoins(n: int) -> int:\n    return (int)((2 * n + 0.25)**0.5 - 0.5)", "asserts": ["assert arrangeCoins(8)==3"], "gen_asserts": "TC2: assert arrangeCoins(1) == 1\nTC3: assert arrangeCoins(10) == 4\nTC4: assert arrangeCoins(0) == 0\nTC5: assert arrangeCoins(3) == 2\nTC6: assert arrangeCoins(21) == 6\nTC7: assert arrangeCoins(15) == 5\nTC8: assert arrangeCoins(45) == 9\nTC9: assert arrangeCoins(100) == 13\nTC10: assert arrangeCoins(28) == 7"}, {"author": "Hafeez", "UUID": "6ceae436-ff42-4122-a163-cc19372ef773", "question": "Squirrel Simulation: You are given two integers height and width representing a garden of size height x width. You are also given:\n\nan array tree where tree = [treer, treec] is the position of the tree in the garden,\nan array squirrel where squirrel = [squirrelr, squirrelc] is the position of the squirrel in the garden,\nand an array nuts where nuts[i] = [nutir, nutic] is the position of the ith nut in the garden.\nThe squirrel can only take at most one nut at one time and can move in four directions: up, down, left, and right, to the adjacent cell.\n\nReturn the minimal distance for the squirrel to collect all the nuts and put them under the tree one by one.\n\nThe distance is the number of moves.", "examples": "Input: height = 5, width = 7, tree = [2,2], squirrel = [4,4], nuts = [[3,0], [2,5]]\nOutput: 12\nExplanation: The squirrel should go to the nut at [2, 5] first to achieve a minimal distance.", "link": "https://leetcode.com/problems/squirrel-simulation/description/", "difficulty": "Medium", "categories": ["Math"], "code": "from typing import List\ndef minDistance(height: int, width: int, tree: List[int], squirrel: List[int], nuts: List[List[int]]) -> int:\n        firstPath = float('-inf')\n        total_dist = 0\n        for nut in nuts:\n            dist_to_Sq = abs(squirrel[0]-nut[0])+abs(squirrel[1]-nut[1])\n            dist_to_Tr = abs(tree[0]-nut[0])+abs(tree[1]-nut[1])\n            if (dist_to_Tr-dist_to_Sq)>firstPath:\n                firstPath = dist_to_Tr-dist_to_Sq\n            total_dist+=2*dist_to_Tr\n        total_dist = total_dist - firstPath\n        return total_dist", "asserts": ["assert minDistance(1,3, [0,1], [0,0], [[0,2]])==3"], "gen_asserts": "TC2: assert minDistance(8, 10, [3, 2], [6, 3], [[4, 4], [1, 7], [7, 0]]) == 26\nTC3: assert minDistance(5, 5, [2, 2], [0, 0], [[0, 1], [1, 3], [3, 4], [4, 2]]) == 18\nTC4: assert minDistance(6, 6, [1, 1], [5, 5], [[1, 2], [2, 2], [3, 3]]) == 14\nTC5: assert minDistance(2, 2, [0, 0], [1, 1], [[0, 1]]) == 2\nTC6: assert minDistance(10, 10, [5, 5], [5, 0], [[0, 0], [9, 9], [2, 2]]) == 44\nTC7: assert minDistance(7, 7, [3, 3], [0, 0], [[0, 2], [2, 0], [4, 4], [6, 6]]) == 26\nTC8: assert minDistance(3, 3, [0, 0], [2, 2], [[1, 1], [2, 0]]) == 8\nTC9: assert minDistance(4, 4, [2, 2], [3, 3], [[0, 0], [0, 3], [3, 0]]) == 16\nTC10: assert minDistance(9, 9, [4, 4], [8, 8], [[5, 5], [1, 1], [3, 7], [7, 3], [6, 0]]) == 38\n\nThese test cases cover various scenarios, including:\n- Small and large gardens\n- The squirrel starting from different corners or edges\n- Nuts spread across the garden in different patterns\n- Trees located centrally or off to one side"}, {"author": "Hafeez", "UUID": "22847d55-ac87-410b-956b-009096af4c77", "question": "Consecutive Numbers Sum: Given an integer n, return the number of ways you can write n as the sum of consecutive positive integers.", "examples": "Input: n = 5\nOutput: 2\nExplanation: 5 = 2 + 3\nInput: n = 15\nOutput: 4\nExplanation: 15 = 8 + 7 = 4 + 5 + 6 = 1 + 2 + 3 + 4 + 5", "link": "https://leetcode.com/problems/consecutive-numbers-sum/description/", "difficulty": "Hard", "categories": ["Math"], "code": "import math\ndef consecutiveNumbersSum(N: int) -> int:\n    count = 0\n    upper_limit = math.ceil((2 * N + 0.25)**0.5 - 0.5) + 1\n    for k in range(1, upper_limit):\n        if (N - k * (k + 1) // 2) % k == 0:\n            count += 1\n    return count", "asserts": ["assert consecutiveNumbersSum(9)==3"], "gen_asserts": "TC2: assert consecutiveNumbersSum(1) == 1\nTC3: assert consecutiveNumbersSum(10) == 2\nTC4: assert consecutiveNumbersSum(28) == 2\nTC5: assert consecutiveNumbersSum(45) == 2\nTC6: assert consecutiveNumbersSum(100) == 3\nTC7: assert consecutiveNumbersSum(225) == 5\nTC8: assert consecutiveNumbersSum(325) == 3\nTC9: assert consecutiveNumbersSum(5050) == 4\nTC10: assert consecutiveNumbersSum(9876) == 4"}, {"author": "Hafeez", "UUID": "fc3fbbf7-4bca-4fca-9308-23d9f5735034", "question": "Minimum Time Visiting All Points: On a 2D plane, there are n points with integer coordinates points[i] = [xi, yi]. Return the minimum time in seconds to visit all the points in the order given by points.\n\nYou can move according to these rules:\n\nIn 1 second, you can either:\nmove vertically by one unit,\nmove horizontally by one unit, or\nmove diagonally sqrt(2) units (in other words, move one unit vertically then one unit horizontally in 1 second).\nYou have to visit the points in the same order as they appear in the array.\nYou are allowed to pass through points that appear later in the order, but these do not count as visits.", "examples": "Input: points = [[1,1],[3,4],[-1,0]]\nOutput: 7\nExplanation: One optimal path is [1,1] -> [2,2] -> [3,3] -> [3,4] -> [2,3] -> [1,2] -> [0,1] -> [-1,0]   \nTime from [1,1] to [3,4] = 3 seconds \nTime from [3,4] to [-1,0] = 4 seconds\nTotal time = 7 seconds", "link": "https://leetcode.com/problems/minimum-time-visiting-all-points/description/", "difficulty": "Easy", "categories": ["Geometry"], "code": "from typing import List\ndef minTimeToVisitAllPoints(points: List[List[int]]) -> int:\n    def rule(A, B):\n        return max(abs(A[0] - B[0]), abs(A[1] - B[1]))\n    s = 0\n    for tup1, tup2 in zip(points[:-1], points[1:]):\n        s += rule(tup1, tup2)\n    return s", "asserts": ["assert minTimeToVisitAllPoints([[3,2],[-2,2]])==5"], "gen_asserts": "TC2: assert minTimeToVisitAllPoints([[0,0],[1,1],[1,2]]) == 2\nTC3: assert minTimeToVisitAllPoints([[5,5],[9,7],[3,1]]) == 8\nTC4: assert minTimeToVisitAllPoints([[1,1]]) == 0\nTC5: assert minTimeToVisitAllPoints([[-3,5],[1,1],[10,11]]) == 16\nTC6: assert minTimeToVisitAllPoints([[2,3],[4,4],[7,8],[10,12]]) == 10\nTC7: assert minTimeToVisitAllPoints([[0,0],[2,3],[5,5],[7,2]]) == 9\nTC8: assert minTimeToVisitAllPoints([[10,10],[10,10]]) == 0\nTC9: assert minTimeToVisitAllPoints([[3,10],[4,8],[3,4],[5,1],[7,0]]) == 11\nTC10: assert minTimeToVisitAllPoints([[-1,-2],[-4,-6],[1,3],[7,8]]) == 17\n\nThese test cases cover various scenarios including different lengths of the points array, different distances and directions between points, and situations where the fastest route may involve both diagonal and straight-line movement."}, {"author": "Hafeez", "UUID": "e2c47631-84af-497c-8e1d-3ce51c4b3eff", "question": "Projection Area of 3D Shapes: You are given an n x n grid where we place some 1 x 1 x 1 cubes that are axis-aligned with the x, y, and z axes.\n\nEach value v = grid[i][j] represents a tower of v cubes placed on top of the cell (i, j).\n\nWe view the projection of these cubes onto the xy, yz, and zx planes.\n\nA projection is like a shadow, that maps our 3-dimensional figure to a 2-dimensional plane. We are viewing the \"shadow\" when looking at the cubes from the top, the front, and the side.\n\nReturn the total area of all three projections.", "examples": "Input: grid = [[1,2],[3,4]]\nOutput: 17\nExplanation: Here are the three projections (\"shadows\") of the shape made with each axis-aligned plane.\nInput: grid = [[1,0],[0,2]]\nOutput: 8", "link": "https://leetcode.com/problems/projection-area-of-3d-shapes/description/", "difficulty": "Easy", "categories": ["Geometry"], "code": "def projectionArea(grid: list) -> int:\n    N = len(grid)\n    ans = 0\n    for i in range(N):\n        best_row = 0\n        best_col = 0 \n        for j in range(N):\n            if grid[i][j]: ans += 1\n            best_row = max(best_row, grid[i][j])\n            best_col = max(best_col, grid[j][i])\n\n        ans += best_row + best_col\n\n    return ans\n", "asserts": ["assert projectionArea([[2]])==5"], "gen_asserts": "TC2: assert projectionArea([[0, 1], [1, 0]]) == 4\nTC3: assert projectionArea([[1, 1, 1], [1, 0, 1], [1, 1, 1]]) == 14\nTC4: assert projectionArea([[2, 3], [2, 4]]) == 17\nTC5: assert projectionArea([[1, 4, 1], [1, 0, 1], [1, 3, 1]]) == 21\nTC6: assert projectionArea([[0, 0, 0], [0, 0, 0], [0, 0, 0]]) == 0\nTC7: assert projectionArea([[1, 4], [1, 1]]) == 11\nTC8: assert projectionArea([[3, 4, 5], [1, 2, 3], [2, 2, 2]]) == 35\nTC9: assert projectionArea([[6, 4], [7, 0]]) == 25\nTC10: assert projectionArea([[1, 0, 2], [3, 4, 1], [1, 2, 3]]) == 25"}, {"author": "Hafeez", "UUID": "effcb732-1f0d-4caa-8d9f-be914708d4ae", "question": "Repeated Substring Pattern: Given a string s, check if it can be constructed by taking a substring of it and appending multiple copies of the substring together.", "examples": "Input: s = \"aba\"\nOutput: false\nExplanation: It is the substring \"ab\" twice.\nInput: s = \"abcabcabcabc\"\nOutput: true\nExplanation: It is the substring \"abc\" four times or the substring \"abcabc\" twice.", "link": "https://leetcode.com/problems/repeated-substring-pattern/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def repeatedSubstringPattern(s: str) -> bool:\n    n = len(s)\n    for i in range(1, n // 2 + 1):\n        if n % i == 0:\n            pattern = s[:i] * (n // i)\n            if s == pattern:\n                return True\n    return False", "asserts": ["assert repeatedSubstringPattern(\"abab\")==True"], "gen_asserts": "Here are additional test cases:\n\nTC2: assert repeatedSubstringPattern(\"aaaa\") == True\nExplanation: It is the substring \"a\" four times.\n\nTC3: assert repeatedSubstringPattern(\"abac\") == False\nExplanation: No substring can be found that can construct the string by repeating it.\n\nTC4: assert repeatedSubstringPattern(\"ababab\") == True\nExplanation: It is the substring \"ab\" three times.\n\nTC5: assert repeatedSubstringPattern(\"xyzxyzxyz\") == True\nExplanation: It is the substring \"xyz\" three times.\n\nTC6: assert repeatedSubstringPattern(\"aaabaaa\") == False\nExplanation: No substring can be found that can construct the string by repeating it.\n\nTC7: assert repeatedSubstringPattern(\"abababab\") == True\nExplanation: It is the substring \"ab\" four times or \"abab\" two times.\n\nTC8: assert repeatedSubstringPattern(\"abcabcab\") == False\nExplanation: The string does not end with a complete repeat of the substring.\n\nTC9: assert repeatedSubstringPattern(\"abbaabba\") == True\nExplanation: It is the substring \"abba\" two times.\n\nTC10: assert repeatedSubstringPattern(\"\") == False\nExplanation: An empty string cannot form a repeated pattern.\n\nTC11: assert repeatedSubstringPattern(\"a\") == False\nExplanation: A single character cannot form a repeated pattern (other than the character itself).\n\nTC12: assert repeatedSubstringPattern(\"abacababacab\") == True\nExplanation: It is the substring \"abac\" three times.\n\nMake sure to avoid overlaps with examples already provided, and ensure that various scenarios are tested, such as strings with different lengths, characters, substrings, and patterns."}, {"author": "Hafeez", "UUID": "e811f9cc-fa5e-4ea0-8adb-8cf3ab7c72db", "question": "Detect Pattern of Length M Repeated K or More Times: Given an array of positive integers arr, find a pattern of length m that is repeated k or more times.\n\nA pattern is a subarray (consecutive sub-sequence) that consists of one or more values, repeated multiple times consecutively without overlapping. A pattern is defined by its length and the number of repetitions.\n\nReturn true if there exists a pattern of length m that is repeated k or more times, otherwise return false.", "examples": "Input: arr = [1,2,1,2,1,1,1,3], m = 2, k = 2\nOutput: true\nExplanation: The pattern (1,2) of length 2 is repeated 2 consecutive times. Another valid pattern (2,1) is also repeated 2 times.\nInput: arr = [1,2,1,2,1,3], m = 2, k = 3\nOutput: false\nExplanation: The pattern (1,2) is of length 2 but is repeated only 2 times. There is no pattern of length 2 that is repeated 3 or more times.\n", "link": "https://leetcode.com/problems/detect-pattern-of-length-m-repeated-k-or-more-times/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "from typing import List\ndef containsPattern(arr: List[int], m: int, k: int) -> bool:\n    i = 0\n    while i <= len(arr)-1:\n            p = arr[i:i+m]\n            if p * k == arr[i:i+m*k]:\n                    return True\n            i += 1\n    return False", "asserts": ["assert containsPattern([1,2,4,4,4,4],1,3)==True"], "gen_asserts": "TC2: assert containsPattern([1,2,3,1,2,3,1,2,3], 3, 3) == True\nExplanation: The pattern (1,2,3) of length 3 is repeated 3 consecutive times.\n\nTC3: assert containsPattern([1,1,1,2,2,2,3,3], 2, 2) == False\nExplanation: No pattern of length 2 is repeated 2 or more times consecutively.\n\nTC4: assert containsPattern([5,5,5,5,5,5,5], 1, 6) == True\nExplanation: The pattern (5) of length 1 is repeated 6 times consecutively.\n\nTC5: assert containsPattern([1,2,3,1,2,1,2,3,1,2,3], 3, 2) == False\nExplanation: While the pattern (1,2,3) appears multiple times, it is not consecutively repeated.\n\nTC6: assert containsPattern([1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2], 2, 5) == True\nExplanation: The pattern (1,2) of length 2 is repeated 8 times consecutively, which is more than the required 5 times.\n\nTC7: assert containsPattern([10,100,10,100,10,100,10,10,10,100], 2, 4) == False\nExplanation: No pattern of length 2 is repeated 4 times consecutively.\n\nTC8: assert containsPattern([3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3], 4, 3) == True\nExplanation: The pattern (3,3,3,3) of length 4 is repeated 4 times consecutively, which meets the requirement of being repeated at least 3 times.\n\nTC9: assert containsPattern([0,0,0,0,1,1,1,1,0,0,0,0], 4, 2) == True\nExplanation: The pattern (0,0,0,0) of length 4 is repeated 2 times consecutively.\n\nTC10: assert containsPattern([1,2,3,4,5,1,2,3,4,5,1,2,3,4], 5, 2) == False\nExplanation: The pattern (1,2,3,4,5) of length 5 is repeated only 2 times and not the required 3 or more times."}, {"author": "Hafeez", "UUID": "df98fd29-db88-4de7-a00a-0a3bd5ba1539", "question": "Word Pattern: Given a pattern and a string s, find if s follows the same pattern.\n\nHere follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in s.", "examples": "Input: pattern = \"abba\", s = \"dog cat cat fish\"\nOutput: false\nInput: pattern = \"aaaa\", s = \"dog cat cat dog\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def wordPattern(pattern: str, s: str) -> bool:\n    map_char = {}\n    map_word = {}\n    \n    words = s.split(' ')\n    if len(words) != len(pattern):\n        return False\n    \n    for c, w in zip(pattern, words):\n        if c not in map_char:\n            if w in map_word:\n                return False\n            else:\n                map_char[c] = w\n                map_word[w] = c\n        else:\n            if map_char[c] != w:\n                return False\n    return True", "asserts": ["assert wordPattern(\"abba\", \"dog cat cat dog\")==True"], "gen_asserts": "TC2: assert wordPattern(\"aaaa\", \"dog dog dog dog\") == True\nTC3: assert wordPattern(\"xyz\", \"apple banana apple\") == False\nTC4: assert wordPattern(\"xyx\", \"apple banana apple\") == True\nTC5: assert wordPattern(\"abab\", \"dog cat dog cat\") == True\nTC6: assert wordPattern(\"aaaa\", \"dog dog dog cat\") == False\nTC7: assert wordPattern(\"abca\", \"dog cat dog apple\") == True\nTC8: assert wordPattern(\"aabb\", \"dog dog cat cat\") == True\nTC9: assert wordPattern(\"abc\", \"dog\") == False  # Not enough words\nTC10: assert wordPattern(\"\", \"dog cat\") == False  # Empty pattern\nTC11: assert wordPattern(\"a\", \"dog cat dog cat\") == False  # Not enough pattern characters\nTC12: assert wordPattern(\"ab\", \"\") == False  # Empty string\nTC13: assert wordPattern(\"abb\", \"dog dog dog\") == False  # Same word for different pattern characters\nTC14: assert wordPattern(\"abba\", \"dog cat cat\") == False  # Not enough words for the pattern\nTC15: assert wordPattern(\"abba\", \"dog cat cat dog fish\") == False  # Extra words beyond the pattern length"}, {"author": "Hafeez", "UUID": "8c9548d2-7b9c-46a4-9b8e-8afd488f7e87", "question": "Find and Replace Pattern: Given a list of strings words and a string pattern, return a list of words[i] that match pattern. You may return the answer in any order.\n\nA word matches the pattern if there exists a permutation of letters p so that after replacing every letter x in the pattern with p(x), we get the desired word.\n\nRecall that a permutation of letters is a bijection from letters to letters: every letter maps to another letter, and no two letters map to the same letter.", "examples": "Input: words = [\"abc\",\"deq\",\"mee\",\"aqq\",\"dkd\",\"ccc\"], pattern = \"abb\"\nOutput: [\"mee\",\"aqq\"]\nExplanation: \"mee\" matches the pattern because there is a permutation {a -> m, b -> e, ...}. \n\"ccc\" does not match the pattern because {a -> c, b -> c, ...} is not a permutation, since a and b map to the same letter.", "link": "https://leetcode.com/problems/find-and-replace-pattern/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def findAndReplacePattern(words: list, pattern: str) -> list:\n        def match(word):\n            m1, m2 = {}, {}\n            for w, p in zip(word, pattern):\n                if w not in m1: m1[w] = p\n                if p not in m2: m2[p] = w\n                if (m1[w], m2[p]) != (p, w):\n                    return False\n            return True\n\n        return list(filter(match, words))\n", "asserts": ["assert findAndReplacePattern([\"a\",\"b\",\"c\"], \"a\")==[\"a\",\"b\",\"c\"]"], "gen_asserts": "TC2: assert findAndReplacePattern([\"xyz\",\"yxx\",\"yyz\",\"zzz\"], \"aba\") == [\"xyz\", \"yyz\"]\nTC3: assert findAndReplacePattern([\"rat\", \"mat\", \"bat\", \"chat\"], \"cat\") == [\"mat\", \"bat\"]\nTC4: assert findAndReplacePattern([\"xx\", \"xy\", \"yy\"], \"xx\") == [\"xx\", \"yy\"]\nTC5: assert findAndReplacePattern([\"abc\", \"def\", \"ghi\", \"jkl\"], \"xyz\") == [\"abc\", \"def\", \"ghi\", \"jkl\"]\nTC6: assert findAndReplacePattern([\"aaa\", \"bbb\", \"ccc\"], \"xyz\") == []\nTC7: assert findAndReplacePattern([\"qwe\", \"asd\", \"zxc\", \"rty\"], \"qaz\") == [\"qwe\", \"zxc\"]\nTC8: assert findAndReplacePattern([\"fizz\", \"buzz\", \"fuzz\", \"hizz\"], \"fiih\") == [\"fizz\", \"hizz\"]\nTC9: assert findAndReplacePattern([\"foo\", \"bar\", \"baz\", \"qux\"], \"ofo\") == [\"foo\"]\nTC10: assert findAndReplacePattern([\"loop\", \"pool\", \"book\", \"look\"], \"oxxo\") == [\"pool\", \"look\"]"}, {"author": "Hafeez", "UUID": "124bfeca-24d0-411d-b4ad-26009b79436b", "question": "Word Pattern II: Given a pattern and a string s, return true if s matches the pattern.\n\nA string s matches a pattern if there is some bijective mapping of single characters to non-empty strings such that if each character in pattern is replaced by the string it maps to, then the resulting string is s. A bijective mapping means that no two characters map to the same string, and no character maps to two different strings.", "examples": "Input: pattern = \"abab\", s = \"redblueredblue\"\nOutput: true\nExplanation: One possible mapping is as follows:\n'a' -> \"red\"\n'b' -> \"blue\"\nInput: pattern = \"aabb\", s = \"xyzabcxzyabc\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern-ii/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def wordPatternMatch(pattern: str, s: str) -> bool:\n    def backtrack(cur: str, pattern: str, mappings: dict):\n        if not pattern:\n            return not cur\n        if pattern[0] in mappings:\n            if cur[:len(mappings[pattern[0]])] != mappings[pattern[0]]:\n                return False\n            return backtrack(cur[len(mappings[pattern[0]]):], pattern[1:], mappings)\n        for i in range(len(cur)):\n            if cur[:i+1] in mappings.values():\n                continue\n            mappings[pattern[0]] = cur[:i+1]\n            if backtrack(cur[i+1:], pattern[1:], mappings):\n                return True\n            del mappings[pattern[0]]\n        return False\n    return backtrack(s, pattern, {})", "asserts": ["assert wordPatternMatch(\"aaaa\", \"asdasdasdasd\")==True"], "gen_asserts": "TC2: assert wordPatternMatch(\"abba\", \"dogcatcatdog\") == True\nTC3: assert wordPatternMatch(\"ab\", \"aa\") == False # since 'a' and 'b' cannot map to the same string \"a\"\nTC4: assert wordPatternMatch(\"xyz\", \"abcdefghi\") == True # 'x' -> \"a\", 'y' -> \"bc\", 'z' -> \"defghi\"\nTC5: assert wordPatternMatch(\"aba\", \"eggegg\") == False # 'a' maps to \"egg\", but 'b' cannot be mapped uniquely\nTC6: assert wordPatternMatch(\"abc\", \"xyzxyzxyz\") == False # no unique mapping for each character in pattern\nTC7: assert wordPatternMatch(\"zzz\", \"aaa\") == True # all 'z' map to \"a\"\nTC8: assert wordPatternMatch(\"xyx\", \"eke\") == False # 'x' -> \"e\", but then 'y' cannot be mapped to \"k\" because 'x' is already mapped to \"e\"\nTC9: assert wordPatternMatch(\"aba\", \"catdogcat\") == True # 'a' -> \"cat\", 'b' -> \"dog\"\nTC10: assert wordPatternMatch(\"abab\", \"xyzxyzabcabc\") == False # cannot match 'a' and 'b' with two different strings each consistent with the pattern\nTC11: assert wordPatternMatch(\"xyz\", \"xyxyx\") == False # 'x' maps to \"x\", but then there's no bijective mapping for 'y' and 'z'\nTC12: assert wordPatternMatch(\"aaa\", \"xyzxyzxyz\") == False # not all 'a's can map to different strings (\"xyz\")\nTC13: assert wordPatternMatch(\"abac\", \"xyzxyzxya\") == True # 'a' -> \"xyz\", 'b' -> \"xyz\", 'c' -> \"a\"\nTC14: assert wordPatternMatch(\"abcd\", \"xyzy\") == False # pattern too long for the string\nTC15: assert wordPatternMatch(\"aaaaa\", \"oneonetwo\") == False # not enough unique strings to map 'a' five times"}, {"author": "Calvin", "UUID": "a9c5e697-af5d-432b-8447-5675d739c728", "question": "Given an array reorder it so that even numbers appear first", "examples": "Input: [1,2,3,4,5,6,7,8,9]\r\nOutput: [8,2,6,4,5,7,3,9,1]", "link": NaN, "categories": ["'array', 'sorting'"], "code": "def even_odd_reorder(arr: list) -> list:\n  nextEven = 0\n  nextOdd = len(arr) - 1\n  while nextEven < nextOdd:\n    if arr[nextEven] % 2 == 0:\n      nextEven += 1\n    else:\n      temp = arr[nextEven]\n      arr[nextEven] = arr[nextOdd]\n      arr[nextOdd] = temp\n      nextOdd -= 1\n  return arr\n", "asserts": ["assert even_odd_reorder([1,2,3,4,5,6,7,8,9]) == [8, 2, 6, 4, 5, 7, 3, 9, 1]"], "gen_asserts": "TC2: assert even_odd_reorder([]) == []\nTC3: assert even_odd_reorder([2, 4, 6, 8]) == [2, 4, 6, 8]\nTC4: assert even_odd_reorder([1, 3, 5, 7]) == [7, 3, 5, 1]\nTC5: assert even_odd_reorder([2, 1, 4, 3, 6, 5, 8, 7]) == [2, 8, 4, 6, 3, 5, 1, 7]\nTC6: assert even_odd_reorder([7, 9, 2]) == [2, 9, 7]\nTC7: assert even_odd_reorder([10, 13, 17, 16, 15, 12]) == [10, 12, 16, 15, 17, 13]\nTC8: assert even_odd_reorder([0, 1, 2, 3]) == [0, 2, 1, 3]\nTC9: assert even_odd_reorder([11, 9, 3, 5, 2]) == [2, 9, 3, 5, 11]"}, {"author": "Calvin", "UUID": "9e45b73f-583d-40ab-b387-e0d1624af07b", "question": "Given two arrays return an array with the set intersection of their common elements", "examples": "Input: arr1 = [1, 2, 3, 4], arr2 = [2, 3]\nOutput: [2, 3]", "link": NaN, "categories": ["'array'"], "code": "def array_intersection(arr1: list, arr2: list) -> set:\n  set1 = set(arr1)\n  ret = set([x for x in arr2 if x in set1])\n  return list(ret)\n", "asserts": ["assert set(array_intersection([1,0,2,0,2,0,2,1,1,1], [2,1,0,2,0,2,2,2,1,0])) == {0,1,2}"], "gen_asserts": "TC2: assert set(array_intersection([5, 6, 7, 8], [8, 9, 10, 11])) == {8}\nTC3: assert set(array_intersection([10, 20, 30], [40, 50, 60])) == set()\nTC4: assert set(array_intersection([], [1, 2, 3])) == set()\nTC5: assert set(array_intersection([-1, -2, -3], [-3, -4, -5, -6])) == {-3}\nTC6: assert set(array_intersection([9, 8, 7], [7, 8, 9, 10, 11, 12])) == {7, 8, 9}\nTC7: assert set(array_intersection(['a', 'b', 'c'], ['a', 'd', 'e', 'c'])) == {'a', 'c'}\nTC8: assert set(array_intersection(['apple', 'banana'], ['banana', 'cherry'])) == {'banana'}\nTC9: assert set(array_intersection([1.1, 2.2, 3.3], [2.2, 4.4])) == {2.2}\nTC10: assert set(array_intersection([False, True, False], [True, False, True])) == {True, False}\nTC11: assert set(array_intersection([[1, 2], [3, 4]], [[1, 2], [5, 6]])) == {(1, 2)}\nTC12: assert set(array_intersection([(1, 2), (3, 4)], [(3, 4), (5, 6)])) == {(3, 4)}"}, {"author": "Calvin", "UUID": "f795bda7-9822-4bc5-9c7e-b9c0f2752085", "question": "You are given two 0-indexed integer permutations A and B of length n.\n\nA prefix common array of A and B is an array C such that C[i] is equal to the count of numbers that are present at or before the index i in both A and B.\n\nReturn the prefix common array of A and B.\n\nA sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once.", "examples": "Input: A = [1,3,2,4], B = [3,1,2,4]\nOutput: [0,2,3,4]", "link": "https://leetcode.com/problems/find-the-prefix-common-array-of-two-arrays/", "categories": ["'array'"], "code": "def findThePrefixCommonArray(arr1: list, arr2: list) -> list:\n  max = len(arr1) if len(arr1) > len(arr2) else len(arr2)\n  seen = set()\n  curCount = 0\n  ret = []\n  for i in range(max):\n    cur1 = arr1[i]\n    cur2 = arr2[i]\n    if cur1 in seen:\n      curCount += 1\n    else:\n      seen.add(cur1)\n    if cur2 in seen:\n      curCount += 1\n    else:\n      seen.add(cur2)\n    ret.append(curCount)\n  return ret\n", "asserts": ["assert findThePrefixCommonArray([1,3,2,4], [3,1,2,4]) == [0,2,3,4]"], "gen_asserts": "TC2: assert findThePrefixCommonArray([2,1,4,3], [1,2,3,4]) == [1,2,3,4]\nTC3: assert findThePrefixCommonArray([4,2,1,3], [3,4,2,1]) == [0,1,2,3]\nTC4: assert findThePrefixCommonArray([5,1,2,3,4], [1,2,3,5,4]) == [1,2,3,3,5]\nTC5: assert findThePrefixCommonArray([1], [1]) == [1]\nTC6: assert findThePrefixCommonArray([3,1,4,2], [1,3,2,4]) == [0,2,3,4]\nTC7: assert findThePrefixCommonArray([6,2,3,5,4,1], [1,3,2,6,5,4]) == [0,1,2,2,4,6]\nTC8: assert findThePrefixCommonArray([2,3,1], [3,1,2]) == [0,1,3]\nTC9: assert findThePrefixCommonArray([1,2,3,4,5], [5,4,3,2,1]) == [0,0,1,2,3]\nTC10: assert findThePrefixCommonArray([7,2,4,5,6,3,1], [1,3,2,7,5,4,6]) == [0,1,2,2,3,4,7]"}, {"author": "Calvin", "UUID": "51a5caf9-241f-4de3-9ee2-9420490b73d7", "question": "Given a set[] of non-negative integers and a value sum, return the subset of the given set whose sum is equal to the given sum or None if one doesn't exist\n", "examples": "Input: set = [1, 2, 3, 4, 5], sum = 10\nOutput: [1, 2, 3, 4]", "link": "https://www.geeksforgeeks.org/subset-sum-problem-dp-25/", "categories": ["'backtracking', 'recursion'"], "code": "def subsetsum(fullset: list, target_sum: int) -> set:\n    def subsetSum_helper(cur_idx: int, fullset: list, target_sum: int, subset: list):\n        if target_sum == 0:\n            return subset\n        if (cur_idx == len(fullset)):\n            return None\n        excluding = subsetSum_helper(cur_idx + 1, fullset, target_sum, subset)\n          \n        if excluding is not None:\n            return excluding\n        elif fullset[cur_idx] <= target_sum:\n            subset.append(fullset[cur_idx])\n            including = subsetSum_helper(cur_idx + 1, fullset, target_sum - fullset[cur_idx], subset)\n            if including!=None:\n                return including\n            else:\n                subset.pop()\n            return None\n    return subsetSum_helper(0, fullset, target_sum, [])\n", "asserts": ["assert set(subsetsum([3, 34, 4, 12, 5, 2], 9)) == {4,5}"], "gen_asserts": "TC2: assert subsetsum([1, 8, 2, 7, 4], 14) == [8, 2, 4]\nTC3: assert subsetsum([10, 12, 15, 6, 19], 21) == [15, 6]\nTC4: assert subsetsum([5, 10, 12, 13, 15, 18], 30) == [12, 18]\nTC5: assert subsetsum([1, 3, 4, 8], 6) == [3, 4]\nTC6: assert subsetsum([5, 3, 9, 12, 6, 15], 27) == [12, 15]\nTC7: assert subsetsum([2, 3, 7, 8, 10], 11) == [3, 8]\nTC8: assert subsetsum([3, 34, 4, 12, 5, 2], 10) == None\nTC9: assert subsetsum([6, 2, 7, 11, 8], 16) == [6, 2, 8]\nTC10: assert subsetsum([5, 7, 1, 14, 6], 13) == [7, 6]\nTC11: assert subsetsum([3, 1, 5, 9, 12], 17) == None\nTC12: assert subsetsum([7, 9, 3, 8, 11, 10], 31) == [7, 9, 3, 11]\nTC13: assert subsetsum([1], 1) == [1]\nTC14: assert subsetsum([2, 5, 8, 4], 0) == []\nTC15: assert subsetsum([], 5) == None\nTC16: assert subsetsum([-1, -2, -3, -4, -5], -10) == None  # Negative numbers are not allowed according to the question\nTC17: assert subsetsum([1, 2, 3, 6, 8, 10], 25) == None  # No subset sums to 25\nTC18: assert subsetsum([10, 15, 3, 7], 25) == [10, 15]\nTC19: assert subsetsum([4, 1, 2, 5, 12, 7], 9) == [2, 7]\nTC20: assert subsetsum([3, 5, 8, 4], 22) == None  # Sum exceeds the sum of all elements\n\nPlease note that the subsets returned can be in any order because a set does not maintain order. Additionally, it is possible that there are multiple subsets that sum to the target; however, the function provided will likely return the first valid subset it finds."}, {"author": "Calvin", "UUID": "fb94082f-4627-4f5a-b280-08d869823d70", "question": "You are given an array of people, people, which are the attributes of some people in a queue (not necessarily in order). Each people[i] = [hi, ki] represents the ith person of height hi with exactly ki other people in front who have a height greater than or equal to hi.\n\nReconstruct and return the queue that is represented by the input array people. The returned queue should be formatted as an array queue, where queue[j] = [hj, kj] is the attributes of the jth person in the queue (queue[0] is the person at the front of the queue).\n", "examples": "Input:  [[7, 0], [4, 4], [7, 1], [5, 0], [6, 1], [5, 2]]\nOutput: [[5, 0], [4, 1], [7, 0], [5, 2], [6, 1], [7, 1]]\n\nInput:  [[6, 0], [5, 0], [4, 0], [3, 2], [2, 2], [1, 4]]\nOutput: [[4, 0], [5, 0], [2, 2], [3, 2], [1, 4], [6, 0]]", "link": NaN, "categories": ["'greedy', 'array'"], "code": "\ndef reconstructQueue(people: list) -> list:\n    output=[] \n    people.sort(key=lambda x: (-x[0], x[1]))                \n    for a in people:\n        output.insert(a[1], a)\n    \n    return output\n", "asserts": ["assert reconstructQueue([[8,1],[5,0],[6,1],[5,2],[4,4],[7,1]]) == [[5, 0], [8, 1], [5, 2], [6, 1], [4, 4], [7, 1]]"], "gen_asserts": "TC2: assert reconstructQueue([[9,0], [7,0], [1,9], [3,0], [2,7], [5,3], [6,0], [3,4], [6,2], [5,2]]) == [[3, 0], [6, 0], [7, 0], [5, 2], [6, 2], [5, 3], [3, 4], [2, 7], [1, 9], [9, 0]]\n\nTC3: assert reconstructQueue([[12,0], [6,3], [4,4], [9,2], [7,1]]) == [[12, 0], [7, 1], [9, 2], [6, 3], [4, 4]]\n\nTC4: assert reconstructQueue([[2,0], [1,1]]) == [[2, 0], [1, 1]]\n\nTC5: assert reconstructQueue([[3,0], [3,2], [3,1]]) == [[3, 0], [3, 1], [3, 2]]\n\nTC6: assert reconstructQueue([[5,0], [3,1], [5,1], [4,1]]) == [[5, 0], [4, 1], [5, 1], [3, 1]]\n\nTC7: assert reconstructQueue([[10,0], [2,0], [5,1], [3,3], [2,5], [10,1]]) == [[10, 0], [5, 1], [10, 1], [2, 0], [3, 3], [2, 5]]"}, {"author": "Calvin", "UUID": "48c6aa37-e00d-4b55-9afc-6b1cf2a1aff2", "question": "There are N Mice and N holes are placed in a straight line. Each hole can accommodate only 1 mouse. A mouse can stay at his position, move one step right from x to x + 1, or move one step left from x to x -1. Any of these moves consumes 1 minute. Assign mice to holes so that the time when the last mouse gets inside a hole is minimized.\nYou are given a list of mice and hole positions as integer scalers.\n", "examples": "Input: Mices = [0, 10, 2, 3], Holes = [3, 2, 23, 0]\nOutput: 13", "link": NaN, "categories": ["'greedy', 'array', 'sorting'"], "code": "def assignHole(mices: list, holes: list) -> int:\n    for i,j in zip(mices,holes):\n        if i<0 or j<0:\n            return -1\n    if (len(mices) != len(holes)):\n        return -1\n    mices.sort()\n    holes.sort()\n    Max = 0\n     \n    for i in range(len(holes)):\n        if (Max < abs(mices[i] - holes[i])):\n            Max = abs(mices[i] - holes[i])\n     \n    return Max\n", "asserts": ["assert assignHole([1, 2, 3, 4], [4, 3, 2, 1]) == 0"], "gen_asserts": "TC2: assert assignHole([-4, 2, 3], [0, 1, 4]) == 4\nTC3: assert assignHole([4, -2, 7], [3, 0, 5]) == 4\nTC4: assert assignHole([10, 20, 30, 40], [15, 25, 35, 45]) == 5\nTC5: assert assignHole([1, 4, 9, 15], [10, 13, 7, 20]) == 6\nTC6: assert assignHole([5, 8, 12], [9, 13, 8]) == 4\nTC7: assert assignHole([-1, -2, -3, -4], [-4, -3, -2, -1]) == 3\nTC8: assert assignHole([0], [0]) == 0\nTC9: assert assignHole([0, 3, 5, 6, 8, 9], [1, 2, 4, 6, 7, 10]) == 2\nTC10: assert assignHole([10, 22, 14, 7, 8], [15, 5, 3, 11, 25]) == 10\nTC11: assert assignHole([], []) == -1  # Edge case with no mice and holes\nTC12: assert assignHole([1, 2], [3]) == -1  # Edge case with non-equal amount of mice and holes\nTC13: assert assignHole([1, 2, -5], [3, 4, -2]) == 3\nTC14: assert assignHole([5, 5, 5], [5, 5, 5]) == 0  # Edge case with all mice and holes at the same position\nTC15: assert assignHole([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]) == 9\nTC16: assert assignHole([1, -1], [-1, 1]) == 2\nTC17: assert assignHole([-100, -200, 300, 400], [-200, -100, 400, 300]) == 300\nTC18: assert assignHole([10, 10, 10, 10], [10, 9, 8, 7]) == 3  # Edge case with multiple mice starting at the same position\nTC19: assert assignHole([1,1 ,1, 1, 1, 1, 1, 1, 1, 1], [2,2,2,2,2,2 ,2, 2, 2, 2]) == 1 # Edge case with multiple mice and holes at the same positions\nTC20: assert assignHole([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == 1 # Edge case with incremental positions"}, {"author": "Calvin", "UUID": "1aeb3246-4c22-4d34-a48c-db7be8ba1b94", "question": "You are given n activities with their start and finish times. Select the maximum number of activities that can be performed by a single person and return their indexes. Assume that a person can only work on a single activity at a time. \n", "examples": "Input: start  =  {10, 12, 20}, finish =  {20, 25, 30}\nOutput: [0, 2]", "link": NaN, "categories": ["'greedy'"], "code": "import numpy as np\ndef MaxActivities(s: list, f: list) -> list:\n    indices = np.argsort(f)\n    [s[i] for i in indices]\n    [f[i] for i in indices]\n    result = []\n    n = len(f)\n    i = 0\n    result.append(i)\n    for j in range(1, n):\n        if s[j] >= f[i]:\n            result.append(j)\n            i = j\n    return result\n", "asserts": ["assert MaxActivities([2, 4, 5, 6, 7, 8], [3, 5, 6, 7, 9, 10]) == [0, 1, 2, 3, 4]"], "gen_asserts": "TC2: assert MaxActivities([1, 3, 0, 5, 8, 5], [2, 4, 6, 7, 9, 9]) == [0, 1, 3, 4]\nTC3: assert MaxActivities([6, 7, 1, 3, 8, 2], [8, 9, 2, 5, 9, 4]) == [2, 3, 5, 1]\nTC4: assert MaxActivities([5, 1, 3, 0, 5, 8], [9, 2, 4, 6, 7, 9]) == [1, 2, 3, 4]\nTC5: assert MaxActivities([8, 5, 6, 1, 3, 2], [9, 7, 10, 4, 5, 6]) == [3, 4, 1, 2]\nTC6: assert MaxActivities([], []) == []\nTC7: assert MaxActivities([1], [2]) == [0]\nTC8: assert MaxActivities([4, 1, 2, 3], [4, 2, 3, 4]) == [1, 2, 3]\nTC9: assert MaxActivities([3, 1, 2, 5, 8, 5, 0], [4, 2, 3, 7, 9, 9, 6]) == [1, 2, 3, 4]"}, {"author": "Calvin", "UUID": "ac641352-08d5-4950-8993-6a143da92ecf", "question": "You are given a string s and an integer k. You can choose one of the first k letters of s and append it at the end of the string.\n\nReturn the lexicographically smallest string you could have after applying the mentioned step any number of moves.\n", "examples": "Input: s = \"cba\", k = 1\nOutput: \"acb\"\n\nInput: s = \"baaca\", k = 3\nOutput: \"aaabc\"", "link": NaN, "categories": ["'queue', 'string'"], "code": "\ndef orderlyQueue(s: str, k: int) -> str:\n    if k == 1:\n        n = len(s)\n        ss = s + s\n        lex_min_str = s\n        for i in range(n):\n            lex_min_str = min(lex_min_str, ss[i:i + n])\n        return lex_min_str\n    \n    return \"\".join(sorted(s))\n", "asserts": ["assert orderlyQueue(\"abcd\", 1) == \"abcd\""], "gen_asserts": "TC2: assert orderlyQueue(\"hello\", 2) == \"ehllo\"\nTC3: assert orderlyQueue(\"programming\", 1) == \"ammingprogr\"\nTC4: assert orderlyQueue(\"rotator\", 1) == \"atorrot\"\nTC5: assert orderlyQueue(\"zxyabc\", 5) == \"abcxyz\"\nTC6: assert orderlyQueue(\"xy\", 2) == \"xy\"\nTC7: assert orderlyQueue(\"aabbbcac\", 1) == \"abbbcacaa\"\nTC8: assert orderlyQueue(\"orderlyqueue\", 4) == \"deeorlqruyey\""}, {"author": "Calvin", "UUID": "5e7011e5-fee4-4c1a-a98f-3b81e50508cc", "question": "Return nth number in the fibonacci sequence", "examples": "Input: 9\nOutput: 34\n\nInput: 7\nOutput: 13", "link": NaN, "categories": ["'recursion', 'mathematical'"], "code": "def fibonacci(n: int) -> int:\n    a = 0\n    b = 1\n    if n < 0:\n        print(\"Incorrect input\")\n    elif n == 0:\n        return a\n    elif n == 1:\n        return b\n    else:\n        for i in range(2, n+1):\n            c = a + b\n            a = b\n            b = c\n        return b\n    b = c\n    return fib(n-1, a, b)\n", "asserts": ["assert fibonacci(9) == 34"], "gen_asserts": "TC2: assert fibonacci(10) == 55\nTC3: assert fibonacci(5) == 5\nTC4: assert fibonacci(2) == 1\nTC5: assert fibonacci(0) == 0\nTC6: assert fibonacci(11) == 89\nTC7: assert fibonacci(15) == 610\nTC8: assert fibonacci(20) == 6765\nTC9: assert fibonacci(25) == 75025\nTC10: assert fibonacci(3) == 2\nTC11: assert fibonacci(1) == 1\nTC12: assert fibonacci(6) == 8\nTC13: assert fibonacci(30) == 832040\nTC14: assert fibonacci(35) == 9227465\nTC15: assert fibonacci(40) == 102334155"}, {"author": "Calvin", "UUID": "e35d1110-85e8-4f50-80aa-91eb976b310b", "question": "Return the factorial of a given number n", "examples": "Input: 5\nOutput: 120\n\nInput: 6\nOutput: 720", "link": NaN, "categories": ["'recursion', 'mathematical'"], "code": "\ndef fact(n: int) -> int:\n  if n <= 1:\n    return 1\n  return n*fact(n-1)\n", "asserts": ["assert fact(5) == 120"], "gen_asserts": "TC2: assert fact(0) == 1\nTC3: assert fact(1) == 1\nTC4: assert fact(3) == 6\nTC5: assert fact(7) == 5040\nTC6: assert fact(10) == 3628800\nTC7: assert fact(4) == 24\nTC8: assert fact(8) == 40320\nTC9: assert fact(2) == 2\nTC10: assert fact(11) == 39916800"}, {"author": "Calvin", "UUID": "80e34b28-16a8-46ac-8b6a-ee28beb1e8d4", "question": "Write a function that reverses a string. The input string is given as an array of characters s.\n\nYou must do this by modifying the input array in-place with O(1) extra memory.", "examples": "Input: [\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput: [\"o\",\"l\",\"l\",\"e\",\"h\"]\n\nInput: [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\nOutput: [\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]", "link": NaN, "categories": ["'string'"], "code": "def reverse_string(s: list) -> list:\n  l = 0\n  r = len(s) - 1\n  while l < r:\n    tmp = s[l]\n    s[l] = s[r]\n    s[r] = tmp\n    l += 1\n    r -= 1\n  return s\n", "asserts": ["assert reverse_string([\"a\",\"b\",\"c\",\"d\"]) == [\"d\", \"c\", \"b\", \"a\"]"], "gen_asserts": "TC2: assert reverse_string([\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"]) == [\"n\", \"o\", \"h\", \"t\", \"y\", \"p\"]\nTC3: assert reverse_string([]) == []\nTC4: assert reverse_string([\"s\", \"i\", \"n\", \"g\", \"l\", \"e\"]) == [\"e\", \"l\", \"g\", \"n\", \"i\", \"s\"]\nTC5: assert reverse_string([\"A\"]) == [\"A\"]\nTC6: assert reverse_string([\"9\", \"8\", \"7\", \"6\", \"5\", \"4\", \"3\", \"2\", \"1\"]) == [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]\nTC7: assert reverse_string([\"B\", \"o\", \"b\"]) == [\"b\", \"o\", \"B\"]\nTC8: assert reverse_string([\"r\", \"e\", \"v\", \"e\", \"r\", \"s\", \"e\"]) == [\"e\", \"s\", \"r\", \"e\", \"v\", \"e\", \"r\"]\nTC9: assert reverse_string([\"1\", \"*\", \"2\", \"*\", \"3\"]) == [\"3\", \"*\", \"2\", \"*\", \"1\"]"}, {"author": "Calvin", "UUID": "d0ce7430-cfcd-4c69-b161-b3b2a186422c", "question": "Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.\n\nIn other words, return true if one of s1's permutations is the substring of s2.", "examples": "Input: s1 = \"ab\", s2 = \"eidbaooo\"\nOutput: True\n\nInput: s1 = \"ab\", s2 = \"eidboaoo\"\nOutput: False", "link": NaN, "categories": ["'string', 'pattern searching'"], "code": "\ndef permutation_in_string(s1: str, s2: str) -> bool:\n  window = len(s1)\n  if window > len(s2):\n    return False\n  freq1 = [0]*26\n  freq2 = [0]*26\n  for i in range(window):\n    freq1[ord(s1[i])-ord('a')] += 1\n    freq2[ord(s2[i])-ord('a')] += 1\n\n  matches = 0\n  for i in range(26):\n    if freq1[i] == freq2[i]:\n      matches += 1\n  \n  for l in range(len(s2) - window):\n    if matches == 26:\n      return True\n\n    added = ord(s2[l + window]) - ord('a')\n    freq2[added] += 1\n    if freq1[added] == freq2[added]:\n      matches += 1\n    elif freq1[added] + 1 == freq2[added]:\n      matches -= 1\n\n    removed = ord(s2[l]) - ord('a')\n    freq2[removed] -= 1\n    if freq1[removed] == freq2[removed]:\n      matches += 1\n    elif freq1[removed] == freq2[removed] + 1:\n      matches -= 1\n    \n  return matches == 26\n", "asserts": ["assert permutation_in_string(\"hello\", \"ooollehhhhh\") == True"], "gen_asserts": "TC2: assert permutation_in_string(\"abc\", \"ccccbbbbaaaa\") == False\nTC3: assert permutation_in_string(\"xyz\", \"zxyopqrstuv\") == True\nTC4: assert permutation_in_string(\"xyz\", \"xzygxzyzxyzk\") == True\nTC5: assert permutation_in_string(\"a\", \"a\") == True\nTC6: assert permutation_in_string(\"adc\", \"dcda\") == True\nTC7: assert permutation_in_string(\"pq\", \"qpqqp\") == True\nTC8: assert permutation_in_string(\"kitten\", \"sittingkite\") == False\nTC9: assert permutation_in_string(\"pq\", \"pqpqr\") == True\nTC10: assert permutation_in_string(\"aba\", \"aabaabaa\") == True\nTC11: assert permutation_in_string(\"\", \"\") == True  # Edge case: both strings are empty\nTC12: assert permutation_in_string(\"longerstring\", \"short\") == False  # s1 is longer than s2\nTC13: assert permutation_in_string(\"a\", \"b\") == False  # Single character, no match\nTC14: assert permutation_in_string(\"aab\", \"baa\") == True  # s1 is a permutation of s2\nTC15: assert permutation_in_string(\"ab\", \"a\") == False  # s2 is shorter than s1\nTC16: assert permutation_in_string(\"ba\", \"eidbaooo\") == True  # Same characters as Example 1 but different permutation\nTC17: assert permutation_in_string(\"eid\", \"eidbaooo\") == True  # s1 is a prefix of s2\nTC18: assert permutation_in_string(\"ooo\", \"eidbaooo\") == True  # s1 is a suffix of s2\nTC19: assert permutation_in_string(\"db\", \"eidbaooo\") == True  # s1 is a permutation within s2\nTC20: assert permutation_in_string(\"eidoo\", \"eidbaooo\") == False  # s1 is longer than any permutation within s2"}, {"author": "Calvin", "UUID": "87372a22-f5ef-4100-845b-28700ca3fde3", "question": "You are given a string s and an integer array indices of the same length. The string s will be shuffled such that the character at the ith position moves to indices[i] in the shuffled string.\n\nReturn the shuffled string.", "examples": "Input: s = \"codeleet\", indices = [4,5,6,7,0,2,1,3]\nOutput: \"leetcode\"\n\nInput: s = \"abc\", indices = [0,1,2]\nOutput: \"abc\"", "link": NaN, "categories": ["'string'"], "code": "from typing import List\ndef shuffle_string(s: str, indices: List[int]) -> str:\n    def partitionString(s):\n      substrings = 1\n      cur_str = set()\n      for i in range(len(s)):\n        if s[i] in cur_str:\n          substrings += 1\n          cur_str = {s[i]}\n        else:\n          cur_str.add(s[i])\n      return substrings\n    ret = ['_']*len(s)\n    for idx, i in enumerate(indices):\n        ret[i] = s[idx]\n    return \"\".join(ret)\n", "asserts": ["assert shuffle_string(\"reoc\", [2, 0, 1, 3]) == \"eorc\""], "gen_asserts": "TC2: assert shuffle_string(\"aiohn\", [3,1,4,2,0]) == \"nihao\"\nTC3: assert shuffle_string(\"aax\", [0,2,1]) == \"axa\"\nTC4: assert shuffle_string(\"12345\", [4,0,1,2,3]) == \"51234\"\nTC5: assert shuffle_string(\"gh\", [1,0]) == \"hg\"\nTC6: assert shuffle_string(\"\", []) == \"\"  # Edge case: empty string\nTC7: assert shuffle_string(\"xy\", [0,1]) == \"xy\"  # No shuffle required\nTC8: assert shuffle_string(\"pqrstuvwxyzabcdefghijklmno\", list(range(25, -1, -1))) == \"onmlkjihgfedcbazyxwvutsrqp\"  # Reverse shuffle\nTC9: assert shuffle_string(\"Thequickbrownfox\", [15,2,5,1,12,9,6,13,0,4,8,3,14,7,11,10]) == \"eTuhickqbwronfo x\"  # Includes a space in the string"}, {"author": "Calvin", "UUID": "56b48f6d-0d81-478d-b838-4d47b62d3031", "question": "Given an integer n, return the number of strings of length n that consist only of vowels (a, e, i, o, u) and are lexicographically sorted.\n\nA string s is lexicographically sorted if for all valid i, s[i] is the same as or comes before s[i+1] in the alphabet.", "examples": "Input: 1\nOutput: 5\n\nInput: 2\nOutput: 15", "link": NaN, "categories": ["'string'"], "code": "def helper(n, letter_idx):\n  letters = [\"a\",\"e\",\"i\",\"o\",\"u\"]\n  dynamic = {\n      'a1' : 5,\n      'e1' : 4,\n      'i1' : 3,\n      'o1' : 2,\n      'u1' : 1\n  }\n  ret = 0\n  key = letters[letter_idx] + str(n)\n  if key in dynamic.keys():\n    return dynamic[key]\n  else:\n    for i in range(letter_idx, len(letters)):\n      ret += helper(n-1, i)\n    dynamic[key] = ret\n  return ret\n  \n\ndef countVowelStrings(n: int) -> int:\n  return helper(n, 0)\n", "asserts": ["assert countVowelStrings(3) == 35"], "gen_asserts": "TC2: assert countVowelStrings(4) == 70\nTC3: assert countVowelStrings(5) == 126\nTC4: assert countVowelStrings(6) == 210\nTC5: assert countVowelStrings(7) == 330\nTC6: assert countVowelStrings(10) == 1001\nTC7: assert countVowelStrings(15) == 3876\nTC8: assert countVowelStrings(0) == 0\nTC9: assert countVowelStrings(20) == 15504\nTC10: assert countVowelStrings(25) == 53130"}]