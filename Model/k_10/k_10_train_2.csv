question,prompt,code,asserts
"Find and Replace Pattern: Given a list of strings words and a string pattern, return a list of words[i] that match pattern. You may return the answer in any order.

A word matches the pattern if there exists a permutation of letters p so that after replacing every letter x in the pattern with p(x), we get the desired word.

Recall that a permutation of letters is a bijection from letters to letters: every letter maps to another letter, and no two letters map to the same letter.","<s>[INST] <<SYS>>
You are an assistant tasked with generating code given a question and some Examples / Explanations along with the question. The question will be given under the heading ""Question:"" and the examples or explanations will be given under ""Example / Explanation:"". Your job is to generate the code and complete the content under the heading title ""Code:"". 
<</SYS>>


[Question]
        
Find and Replace Pattern: Given a list of strings words and a string pattern, return a list of words[i] that match pattern. You may return the answer in any order.

A word matches the pattern if there exists a permutation of letters p so that after replacing every letter x in the pattern with p(x), we get the desired word.

Recall that a permutation of letters is a bijection from letters to letters: every letter maps to another letter, and no two letters map to the same letter.

assert findAndReplacePattern([""xx"", ""xy"", ""yy""], ""xx"") == [""xx"", ""yy""]

[/Question] [/INST] [Code]

def findAndReplacePattern(words: list, pattern: str) -> list:
        def match(word):
            m1, m2 = {}, {}
            for w, p in zip(word, pattern):
                if w not in m1: m1[w] = p
                if p not in m2: m2[p] = w
                if (m1[w], m2[p]) != (p, w):
                    return False
            return True

        return list(filter(match, words))
 

[/Code]
[/STOP] </s>","def findAndReplacePattern(words: list, pattern: str) -> list:
        def match(word):
            m1, m2 = {}, {}
            for w, p in zip(word, pattern):
                if w not in m1: m1[w] = p
                if p not in m2: m2[p] = w
                if (m1[w], m2[p]) != (p, w):
                    return False
            return True

        return list(filter(match, words))
","assert findAndReplacePattern([""a"",""b"",""c""], ""a"")==[""a"",""b"",""c""]
assert findAndReplacePattern([""xx"", ""xy"", ""yy""], ""xx"") == [""xx"", ""yy""]
assert findAndReplacePattern([""abc"", ""def"", ""ghi"", ""jkl""], ""xyz"") == [""abc"", ""def"", ""ghi"", ""jkl""]
assert findAndReplacePattern([""aaa"", ""bbb"", ""ccc""], ""xyz"") == []"
"Given an array of elements, sort the array in decreasing order using min heap. ","<s>[INST] <<SYS>>
You are an assistant tasked with generating code given a question and some Examples / Explanations along with the question. The question will be given under the heading ""Question:"" and the examples or explanations will be given under ""Example / Explanation:"". Your job is to generate the code and complete the content under the heading title ""Code:"". 
<</SYS>>


[Question]
        
Given an array of elements, sort the array in decreasing order using min heap. 



[/Question] [/INST] [Code]

def heapSort(arr: list) -> list:
        def heapify(arr, n, i):
                smallest = i 
                l = 2 * i + 1 
                r = 2 * i + 2

                if l < n and arr[l] < arr[smallest]: 
                        smallest = l 

                if r < n and arr[r] < arr[smallest]: 
                        smallest = r 

                if smallest != i: 
                        (arr[i], 
                        arr[smallest]) = (arr[smallest],
                                                        arr[i])

                        heapify(arr, n, smallest)
         
        n = len(arr)
        for i in range(int(n / 2) - 1, -1, -1):
                heapify(arr, n, i) 

        for i in range(n-1, -1, -1):
                
                arr[0], arr[i] = arr[i], arr[0]

                heapify(arr, i, 0)

        return arr
 

[/Code]
[/STOP] </s>","def heapSort(arr: list) -> list:
        def heapify(arr, n, i):
                smallest = i 
                l = 2 * i + 1 
                r = 2 * i + 2

                if l < n and arr[l] < arr[smallest]: 
                        smallest = l 

                if r < n and arr[r] < arr[smallest]: 
                        smallest = r 

                if smallest != i: 
                        (arr[i], 
                        arr[smallest]) = (arr[smallest],
                                                        arr[i])

                        heapify(arr, n, smallest)
         
        n = len(arr)
        for i in range(int(n / 2) - 1, -1, -1):
                heapify(arr, n, i) 

        for i in range(n-1, -1, -1):
                
                arr[0], arr[i] = arr[i], arr[0]

                heapify(arr, i, 0)

        return arr
","assert heapSort([4,6,3,2,9]) == [9,6,4,3,2]
assert heapSort([8, 1, 7, 2, 6, 3, 5, 4]) == [8, 7, 6, 5, 4, 3, 2, 1]
assert heapSort([0]) == [0]
assert heapSort([2, 1, 3, 5, 4, 7, 6]) == [7, 6, 5, 4, 3, 2, 1]
assert heapSort([-1, -5, -3, -4, -2]) == [-1, -2, -3, -4, -5]
assert heapSort([10, -2, 4, 5, 3, 7]) == [10, 7, 5, 4, 3, -2]
assert heapSort([1.5, 2.5, 0.5, 3.5, 1.0, 2.0]) == [3.5, 2.5, 2.0, 1.5, 1.0, 0.5]
assert heapSort([99]) == [99]
assert heapSort([5, 5, 5, 5]) == [5, 5, 5, 5]
assert heapSort([9, 7, 7, 9, 5, 5]) == [9, 9, 7, 7, 5, 5]
assert heapSort([]) == []  # Empty list should return an empty list
assert heapSort([1, 1000, 100, 10, 10000]) == [10000, 1000, 100, 10, 1]"
"You are given two 0-indexed integer permutations A and B of length n.

A prefix common array of A and B is an array C such that C[i] is equal to the count of numbers that are present at or before the index i in both A and B.

Return the prefix common array of A and B.

A sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once.","<s>[INST] <<SYS>>
You are an assistant tasked with generating code given a question and some Examples / Explanations along with the question. The question will be given under the heading ""Question:"" and the examples or explanations will be given under ""Example / Explanation:"". Your job is to generate the code and complete the content under the heading title ""Code:"". 
<</SYS>>


[Question]
        
You are given two 0-indexed integer permutations A and B of length n.

A prefix common array of A and B is an array C such that C[i] is equal to the count of numbers that are present at or before the index i in both A and B.

Return the prefix common array of A and B.

A sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once.

assert findThePrefixCommonArray([1,3,2,4], [3,1,2,4]) == [0,2,3,4]
assert findThePrefixCommonArray([1], [1]) == [1]
assert findThePrefixCommonArray([2,3,1], [3,1,2]) == [0,1,3]

[/Question] [/INST] [Code]

def findThePrefixCommonArray(arr1: list, arr2: list) -> list:
  max = len(arr1) if len(arr1) > len(arr2) else len(arr2)
  seen = set()
  curCount = 0
  ret = []
  for i in range(max):
    cur1 = arr1[i]
    cur2 = arr2[i]
    if cur1 in seen:
      curCount += 1
    else:
      seen.add(cur1)
    if cur2 in seen:
      curCount += 1
    else:
      seen.add(cur2)
    ret.append(curCount)
  return ret
 

[/Code]
[/STOP] </s>","def findThePrefixCommonArray(arr1: list, arr2: list) -> list:
  max = len(arr1) if len(arr1) > len(arr2) else len(arr2)
  seen = set()
  curCount = 0
  ret = []
  for i in range(max):
    cur1 = arr1[i]
    cur2 = arr2[i]
    if cur1 in seen:
      curCount += 1
    else:
      seen.add(cur1)
    if cur2 in seen:
      curCount += 1
    else:
      seen.add(cur2)
    ret.append(curCount)
  return ret
","assert findThePrefixCommonArray([1,3,2,4], [3,1,2,4]) == [0,2,3,4]
assert findThePrefixCommonArray([1], [1]) == [1]
assert findThePrefixCommonArray([2,3,1], [3,1,2]) == [0,1,3]"
"Linear Search is defined as a sequential search algorithm that starts at one end and goes through each element of a list until the desired element is found, otherwise the search continues till the end of the data set. Implement the Linear searching algorithm in python","<s>[INST] <<SYS>>
You are an assistant tasked with generating code given a question and some Examples / Explanations along with the question. The question will be given under the heading ""Question:"" and the examples or explanations will be given under ""Example / Explanation:"". Your job is to generate the code and complete the content under the heading title ""Code:"". 
<</SYS>>


[Question]
        
Linear Search is defined as a sequential search algorithm that starts at one end and goes through each element of a list until the desired element is found, otherwise the search continues till the end of the data set. Implement the Linear searching algorithm in python



[/Question] [/INST] [Code]

def search(arr: list, x: int) -> int:
        for i in range(0, len(arr)): 
                if (arr[i] == x): 
                        return i 
        return -1
 

[/Code]
[/STOP] </s>","def search(arr: list, x: int) -> int:
        for i in range(0, len(arr)): 
                if (arr[i] == x): 
                        return i 
        return -1
","assert search([2, 3, 4, 10, 40], 10) == 3
assert search([1, 8, 9, 10, 15], 15) == 4
assert search([4, 5, 6, 7, 0], 3) == -1
assert search([], 10) == -1
assert search([42], 42) == 0
assert search([10, 22, 35, 49, 53, 67, 83], 67) == 5
assert search([3, 1, 3, 7, 5], 3) == 0
assert search([1, 2, 3, 4, 5, 6, 7, 8, 9], 1) == 0
assert search([9, 8, 7, 6, 5, 4, 3, 2, 1], 1) == 8
assert search([5, 17, 22, 30, 45, 50, 62], 31) == -1"
"Projection Area of 3D Shapes: You are given an n x n grid where we place some 1 x 1 x 1 cubes that are axis-aligned with the x, y, and z axes.

Each value v = grid[i][j] represents a tower of v cubes placed on top of the cell (i, j).

We view the projection of these cubes onto the xy, yz, and zx planes.

A projection is like a shadow, that maps our 3-dimensional figure to a 2-dimensional plane. We are viewing the ""shadow"" when looking at the cubes from the top, the front, and the side.

Return the total area of all three projections.","<s>[INST] <<SYS>>
You are an assistant tasked with generating code given a question and some Examples / Explanations along with the question. The question will be given under the heading ""Question:"" and the examples or explanations will be given under ""Example / Explanation:"". Your job is to generate the code and complete the content under the heading title ""Code:"". 
<</SYS>>


[Question]
        
Projection Area of 3D Shapes: You are given an n x n grid where we place some 1 x 1 x 1 cubes that are axis-aligned with the x, y, and z axes.

Each value v = grid[i][j] represents a tower of v cubes placed on top of the cell (i, j).

We view the projection of these cubes onto the xy, yz, and zx planes.

A projection is like a shadow, that maps our 3-dimensional figure to a 2-dimensional plane. We are viewing the ""shadow"" when looking at the cubes from the top, the front, and the side.

Return the total area of all three projections.



[/Question] [/INST] [Code]

def projectionArea(grid: list) -> int:
    N = len(grid)
    ans = 0
    for i in range(N):
        best_row = 0
        best_col = 0 
        for j in range(N):
            if grid[i][j]: ans += 1
            best_row = max(best_row, grid[i][j])
            best_col = max(best_col, grid[j][i])

        ans += best_row + best_col

    return ans
 

[/Code]
[/STOP] </s>","def projectionArea(grid: list) -> int:
    N = len(grid)
    ans = 0
    for i in range(N):
        best_row = 0
        best_col = 0 
        for j in range(N):
            if grid[i][j]: ans += 1
            best_row = max(best_row, grid[i][j])
            best_col = max(best_col, grid[j][i])

        ans += best_row + best_col

    return ans
","assert projectionArea([[2]])==5
assert projectionArea([[1, 1, 1], [1, 0, 1], [1, 1, 1]]) == 14
assert projectionArea([[2, 3], [2, 4]]) == 17
assert projectionArea([[0, 0, 0], [0, 0, 0], [0, 0, 0]]) == 0"
