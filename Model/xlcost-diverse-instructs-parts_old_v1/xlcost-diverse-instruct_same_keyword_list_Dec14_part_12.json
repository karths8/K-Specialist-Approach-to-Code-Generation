[{"few_shot_keywords": "['string', 'outside', 'digits', 'dictionary', 'sort', 'query', 'lexicographically', 'smallest', 'character', 'append', 'longest', 'iteration']", "test_keywords": "['subsequence', 'lexicographically', 'lambda', 'smallest', 'iteration', 'points', 'string', 'sort', 'character', 'append']", "prompt_tokens": 540, "total_tokens": 773, "completion_tokens": 233, "completion": "[Question 2]\n\nWrite a Python program that takes a list of strings and returns the lexicographically smallest subsequence of the list, where a subsequence is formed by appending characters from the strings in the list. The subsequence should be formed by iterating through each string in the list and considering the smallest lexicographical character at each iteration.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\ndef lexicographicallySmallestSubsequence(strings: List[str]) -> str:\n    return ''.join(sorted(set(''.join(strings))))\n\n[/Code 2]\n\n[Asserts 2]\n\nassert lexicographicallySmallestSubsequence([\"abc\", \"acb\", \"bca\"])==\"abc\"\nassert lexicographicallySmallestSubsequence([\"cba\", \"acb\", \"bca\"])==\"abc\"\nassert lexicographicallySmallestSubsequence([\"aaa\", \"aab\", \"aac\"])==\"abc\"\nassert lexicographicallySmallestSubsequence([\"xyz\", \"xy\", \"x\"])==\"xyz\"\nassert lexicographicallySmallestSubsequence([\"pqr\", \"pq\", \"p\"])==\"pqr\"\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.904}, {"few_shot_keywords": "['nodes', 'binary', 'tree', 'longest path', 'recursive', 'initial', 'remove', 'sub-trees', 'half']", "test_keywords": "['recursive', 'half', 'tree', 'nodes', 'left pointer', 'sub-trees', 'time complexity', 'remove', 'middle column', 'binary']", "prompt_tokens": 571, "total_tokens": 981, "completion_tokens": 410, "completion": "[Question 2]\n\nGiven a binary tree, write a function to remove the nodes in the middle column of the tree. The middle column is defined as the column containing nodes that lie at the maximum depth of the tree.\n\n[/Question 2]\n\n[Code 2]\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef removeMiddleColumn(root: TreeNode) -> TreeNode:\n    depth = getDepth(root)\n    target_column = (depth + 1) // 2  # Middle column index (1-indexed)\n    return removeMiddleColumnUtil(root, 1, target_column)\n\ndef removeMiddleColumnUtil(node, current_column, target_column):\n    if not node:\n        return None\n    if current_column == target_column:\n        return None\n    node.left = removeMiddleColumnUtil(node.left, current_column + 1, target_column)\n    node.right = removeMiddleColumnUtil(node.right, current_column + 1, target_column)\n    return node\n\ndef getDepth(node):\n    if not node:\n        return 0\n    else:\n        left_depth = getDepth(node.left)\n        right_depth = getDepth(node.right)\n        return max(left_depth, right_depth) + 1\n\n[/Code 2]\n\n[Asserts 2]\n\ntree1 = TreeNode(1, TreeNode(2, TreeNode(4, None, None), TreeNode(5, None, None)), TreeNode(3, TreeNode(6, None, None), TreeNode(7, None, None)))\ntree2 = TreeNode(1, TreeNode(2, TreeNode(4, None, None), None), TreeNode(3, None, None))\nassert removeMiddleColumn(tree1)==TreeNode(1, TreeNode(2, None, None), TreeNode(3, None, None))\nassert removeMiddleColumn(tree2)==TreeNode(1, None, None)\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.752}, {"few_shot_keywords": "['boolean', 'character', 'frequency', 'BST', 'condition', 'obstacle', 'rearrange', 'string', 'swap', 'palindrome', 'iteration']", "test_keywords": "['iteration', 'grid', 'geometry', 'condition', 'boolean', 'swap', 'string', 'maximum value', 'cells', 'palindrome', 'character']", "prompt_tokens": 652, "total_tokens": 1070, "completion_tokens": 418, "completion": "[Question 2]\n\nYou are given a grid of characters representing a board game. Each cell in the grid contains a lowercase letter. Write a Python function to find the maximum value of a palindrome that can be obtained by swapping two letters in the grid. You can only swap two letters if they are in the same row or column. Return the maximum possible value of a palindrome.\n\nFor example, given the grid:\n\ngrid = [\n    [\"a\", \"b\", \"c\"],\n    [\"d\", \"e\", \"f\"],\n    [\"g\", \"h\", \"i\"]\n]\n\nThe maximum value of a palindrome that can be obtained by swapping two letters is 10, which can be achieved by swapping the letters \"a\" and \"i\" to form the palindrome \"abcbadcba\".\n\n[/Question 2]\n\n[Code 2]\n\ndef maxValuePalindrome(grid: List[List[str]]) -> int:\n    row, col = len(grid), len(grid[0])\n    max_val = 0\n    for r in range(row):\n        for c in range(col):\n            for i in range(row):\n                if i != r:\n                    max_val = max(max_val, ord(grid[r][c]) + ord(grid[i][c]))\n            for j in range(col):\n                if j != c:\n                    max_val = max(max_val, ord(grid[r][c]) + ord(grid[r][j]))\n    return max_val\n\n[/Code 2]\n\n[Asserts 2]\n\ngrid1 = [\n    [\"a\", \"b\", \"c\"],\n    [\"d\", \"e\", \"f\"],\n    [\"g\", \"h\", \"i\"]\n]\nassert maxValuePalindrome(grid1) == 10\n\ngrid2 = [\n    [\"z\", \"y\", \"x\"],\n    [\"w\", \"v\", \"u\"],\n    [\"t\", \"s\", \"r\"]\n]\nassert maxValuePalindrome(grid2) == 219\n\ngrid3 = [\n    [\"a\", \"b\"],\n    [\"c\", \"d\"]\n]\nassert maxValuePalindrome(grid3) == 196", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.723}, {"few_shot_keywords": "['string', 'reachable', 'sorting', 'algorithm', 'permutations', 'distinct', 'circumference', 'set', 'recursive', 'backtracking', 'combinations']", "test_keywords": "['combinations', 'algorithm', 'path', 'root to leaf path', 'string', 'power', 'sorting', 'distinct', 'stack', 'recursive', 'permutations', 'backtracking']", "prompt_tokens": 697, "total_tokens": 979, "completion_tokens": 282, "completion": "[Question 2]\n\nGiven a binary tree, write a program to find all distinct paths from the root to the leaf nodes. Each path should be represented as a string with the nodes' values separated by \"->\" and the paths should be sorted in lexicographical order.\n\n[/Question 2]\n\n[Code 2]\n\nclass TreeNode:\n    def __init__(self, value=0, left=None, right=None):\n        self.value = value\n        self.left = left\n        self.right = right\n\ndef binaryTreePaths(root: TreeNode) -> List[str]:\n    paths = []\n    if not root:\n        return paths\n\n    def backtrack(node, path):\n        if not node.left and not node.right:\n            paths.append(path)\n        if node.left:\n            backtrack(node.left, path + \"->\" + str(node.left.value))\n        if node.right:\n            backtrack(node.right, path + \"->\" + str(node.right.value))\n\n    backtrack(root, str(root.value))\n    return sorted(paths)\n\n[/Code 2]\n\n[Asserts 2]\n\n# Create a binary tree\ntree = TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(5)), TreeNode(3))\n\n# Test the binaryTreePaths function\nassert binaryTreePaths(tree) == ['1->2->4', '1->2->5', '1->3']\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.931}, {"few_shot_keywords": "['swap', 'increment', 'left child', 'list of lists', 'right child', 'index', 'multiples', 'binary tree', 'optimization', 'level', 'children', 'node']", "test_keywords": "['max', 'swap', 'ascending order', 'binary tree', 'list of lists', 'right child', 'children', 'left child', 'increase', 'node', 'index', 'level', 'multiples']", "prompt_tokens": 1009, "total_tokens": 1647, "completion_tokens": 638, "completion": "[Question 2]\n\nGiven a binary tree represented as a list of lists, write a function to swap the values of nodes at multiples of K level to achieve ascending order within each level. Return the modified tree.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\nclass TreeNode:\n    def __init__(self, value: int, left_child_index: int, right_child_index: int):\n        self.value = value\n        self.left = None\n        self.right = None\n        self.left_child_index = left_child_index\n        self.right_child_index = right_child_index\n\ndef swapNodesForAscending(tree: List[List[int]], K: int) -> List[List[int]]:\n    nodes = {}\n    for i in range(len(tree)):\n        nodes[i+1] = TreeNode(tree[i][0], tree[i][1], tree[i][2])\n\n    result = []\n    queue = [(nodes[1], 1)]\n    level = 1\n    while queue:\n        level_nodes = []\n        for i in range(len(queue)):\n            current, depth = queue.pop(0)\n            if current.left_child_index != -1:\n                queue.append((nodes[current.left_child_index], depth+1))\n            if current.right_child_index != -1:\n                queue.append((nodes[current.right_child_index], depth+1))\n            if depth % K == 0:\n                level_values = [nodes[idx].value for idx in range(1, len(tree)+1) if depth % K == 0]\n                level_values.sort()\n                idx = 0\n                for idx in range(len(level_values)):\n                    nodes[idx+1].value = level_values[idx]\n            level_nodes.append(current.value)\n        result.append(level_nodes)\n        level += 1\n\n    return result\n\n[/Code 2]\n\n[Asserts 2]\n\nassert swapNodesForAscending([[1, 2, 3], [2, 4, 5], [3, 6, 7], [4, -1, -1], [5, -1, -1], [6, -1, -1], [7, -1, -1]], 2) == [[1, 2, 3], [4, 5, 6, 7]]\nassert swapNodesForAscending([[1, 2, 3], [2, -1, 4], [3, -1, 5], [4, -1, -1], [5, -1, -1]], 1) == [[1], [2, 3], [4, 5]]\nassert swapNodesForAscending([[1, 2, 3], [2, 4, 5], [3, 6, 7], [4, -1, -1], [5, -1, -1], [6, -1, -1], [7, -1, -1]], 3) == [[1, 2, 3], [4, 5, 6, 7]]\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.805}, {"few_shot_keywords": "['sentence', 'input', 'alphabet', 'float', 'numeric', 'sequence', 'mapping', 'keypad', 'pair', 'deletions', 'value', 'phone']", "test_keywords": "['mapping', 'keypad', 'distinct', 'sequence', 'input', 'sufficient subset', 'BST', 'alphabet', 'phone', 'sentence', 'numeric', 'empty']", "prompt_tokens": 725, "total_tokens": 1168, "completion_tokens": 443, "completion": "[Question 2]\n\nYou are given a binary search tree (BST) where each node contains a distinct numeric value. You are also given a sentence as input. Write a function in Python to determine if the sentence can be formed using the numeric keypad sequence by considering the distinct numeric values in the BST as the mapping for each alphabet.\n\n[/Question 2]\n\n[Code 2]\n\nclass TreeNode:\n    def __init__(self, key):\n        self.left = None\n        self.right = None\n        self.val = key\n\ndef insert(root, key):\n    if root is None:\n        return TreeNode(key)\n    else:\n        if root.val < key:\n            root.right = insert(root.right, key)\n        else:\n            root.left = insert(root.left, key)\n    return root\n\ndef inOrderTraversal(root, result):\n    if root:\n        inOrderTraversal(root.left, result)\n        result.append(root.val)\n        inOrderTraversal(root.right, result)\n\ndef canFormSentenceWithBSTMapping(root, sentence):\n    keypadMapping = {2: 'abc', 3: 'def', 4: 'ghi', 5: 'jkl', 6: 'mno', 7: 'pqrs', 8: 'tuv', 9: 'wxyz'}\n    result = []\n    inOrderTraversal(root, result)\n    distinctValues = list(set(result))\n    distinctValues.sort()\n    keypadCharacters = ''.join([keypadMapping[val] for val in distinctValues])\n    for char in sentence:\n        if char.lower() not in keypadCharacters:\n            return False\n    return True\n\n[/Code 2]\n\n[Asserts 2]\n\n# Create a BST\nroot = None\nkeys = [5, 3, 8, 2, 4, 6, 9]\nfor key in keys:\n    root = insert(root, key)\n\nassert canFormSentenceWithBSTMapping(root, \"Hello World\") == True\nassert canFormSentenceWithBSTMapping(root, \"Python Programming\") == False\nassert canFormSentenceWithBSTMapping(root, \"I love coding\") == True\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.716}, {"few_shot_keywords": "['nearest', 'nested loops', 'combinatorics', 'math', 'integer', 'multiple', 'rounding']", "test_keywords": "['dimensions', 'nearest', 'math', 'rounding', 'extend', 'multiple', 'previous', 'integer']", "prompt_tokens": 480, "total_tokens": 918, "completion_tokens": 438, "completion": "[Question 2]\n\nYou are given a two-dimensional array representing a grid of integer values. Write a function to extend the grid by adding a new row and a new column, where the values in the new row and new column are the nearest multiples of 5 to the previous values in the grid. For example, if the previous grid had values [12, 16; 23, 29] then the extended grid would have values [12, 16, 15; 23, 29, 30; 20, 25, 25]. Write a function that takes in the previous grid and returns the extended grid.\n\n[/Question 2]\n\n[Code 2]\n\ndef extendGridWithNearestMultiples(grid: List[List[int]]) -> List[List[int]]:\n    extended_grid = []\n    for row in grid:\n        extended_row = []\n        for value in row:\n            nearest_multiple_of_5 = (value + 2) // 5 * 5\n            extended_row.append(nearest_multiple_of_5)\n        extended_grid.append(extended_row)\n    extended_column = [row[-1] for row in extended_grid]\n    extended_column = [(value + 2) // 5 * 5 for value in extended_column]\n    extended_grid.append(extended_column)\n    return extended_grid\n\n[/Code 2]\n\n[Asserts 2]\n\nassert extendGridWithNearestMultiples([[12, 16], [23, 29]]) == [[12, 16, 15], [23, 29, 30], [20, 25, 25]]\nassert extendGridWithNearestMultiples([[7, 8, 9], [10, 11, 12]]) == [[5, 10, 10], [10, 15, 15], [10, 15, 15]]\nassert extendGridWithNearestMultiples([[32, 37, 41], [46, 51, 56]]) == [[30, 35, 40], [45, 50, 55], [45, 50, 55]]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.756}, {"few_shot_keywords": "['diagonals', 'boolean', 'tree nodes', 'winner', 'float', 'remainder', 'even', 'odd', 'missing']", "test_keywords": "['leaves', 'odd', 'even', 'XOR', 'float', 'boolean', 'bottom-right', 'numbers', 'remainder']", "prompt_tokens": 425, "total_tokens": 823, "completion_tokens": 398, "completion": "[Question 2]\n\nGiven a binary tree, write a program to find the XOR of the values of all the bottom-right leaves. Return True if the XOR result is even, and False if it is odd.\n\n[/Question 2]\n\n[Code 2]\n\nclass TreeNode:\n    def __init__(self, value=0, left=None, right=None):\n        self.value = value\n        self.left = left\n        self.right = right\n\ndef findXORofBottomRightLeaves(root: TreeNode) -> bool:\n    def isLeaf(node: TreeNode) -> bool:\n        return not node.left and not node.right\n    \n    def xorOfLeaves(node: TreeNode, xorSoFar: int) -> int:\n        if not node:\n            return 0\n        if isLeaf(node) and node.right:\n            return xorSoFar ^ node.value\n        return xorOfLeaves(node.left, xorSoFar) ^ xorOfLeaves(node.right, xorSoFar)\n    \n    xorResult = xorOfLeaves(root, 0)\n    return xorResult % 2 == 0\n\n[/Code 2]\n\n[Asserts 2]\n\n# Create the binary tree\n#        1\n#       / \\\n#      2   3\n#     / \\\n#    4   5\ntree = TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(5)), TreeNode(3))\n\nassert findXORofBottomRightLeaves(tree) == True\n\n# Create another binary tree\n#        1\n#       / \\\n#      2   3\n#     / \\   \\\n#    4   5   6\ntree2 = TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(5)), TreeNode(3, None, TreeNode(6)))\n\nassert findXORofBottomRightLeaves(tree2) == False\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.863}, {"few_shot_keywords": "['tree', 'count', 'bipartite', 'depth', 'root', 'coordinates', 'path', 'leaf', 'binary', 'boolean']", "test_keywords": "['root', 'valid', 'count', 'unsafe', 'depth', 'tree', 'path', 'bipartite', 'binary', 'leaf']", "prompt_tokens": 701, "total_tokens": 1060, "completion_tokens": 359, "completion": "[Question 2]\n\nYou are given a binary tree and you need to determine if it is a valid binary tree with respect to its depths. A binary tree is considered valid if the difference in depth between any two leaf nodes is at most 1. Return a boolean value indicating whether the given binary tree is a valid binary tree based on the above criteria.\n\n[/Question 2]\n\n[Code 2]\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef isValidBinaryTree(root: TreeNode) -> bool:\n    def isBalanced(node):\n        if not node:\n            return 0\n        leftDepth = isBalanced(node.left)\n        if leftDepth == -1:\n            return -1\n        rightDepth = isBalanced(node.right)\n        if rightDepth == -1:\n            return -1\n        if abs(leftDepth - rightDepth) > 1:\n            return -1\n        return max(leftDepth, rightDepth) + 1\n\n    return isBalanced(root) != -1\n\n[/Code 2]\n\n[Asserts 2]\n\n# Create a binary tree\nroot = TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(5)), TreeNode(3, TreeNode(6)))\n# Check if the binary tree is a valid binary tree\nassert isValidBinaryTree(root) == True\n# Create a binary tree\nroot = TreeNode(1, TreeNode(2, TreeNode(3, TreeNode(4), TreeNode(5)), TreeNode(6))\n# Check if the binary tree is a valid binary tree\nassert isValidBinaryTree(root) == False\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.904}, {"few_shot_keywords": "['string', 'simplify', 'split', 'path', 'stack', 'empty', 'directory', 'median', 'bipartite', 'odd', 'join', 'multiply']", "test_keywords": "['path', 'recursive', 'directory', 'simplify', 'string', 'join', 'stack', 'insert', 'split', 'equation']", "prompt_tokens": 504, "total_tokens": 757, "completion_tokens": 253, "completion": "[Question 2]\n\nGiven a directory path as a string, write a recursive function to simplify the path and return it. You need to handle cases like \".\", \"..\", and consecutive slashes. For example, given \"/a/./b/../../c/\", you should return \"/c\".\n\n[/Question 2]\n\n[Code 2]\n\ndef simplify_directory_path(path: str) -> str:\n    parts = path.split('/')\n    stack = []\n    for part in parts:\n        if part in ['..', '..', '']:\n            if part == '..' and stack:\n                stack.pop()\n            elif part == '':\n                pass\n            else:\n                stack.append(part)\n    return '/' + '/'.join(stack)\n\n[/Code 2]\n\n[Asserts 2]\n\nassert simplify_directory_path(\"/home/\") == \"/home\"\nassert simplify_directory_path(\"/a/./b/../../c/\") == \"/c\"\nassert simplify_directory_path(\"/a//b////c/d//././/..\") == \"/a/b/c\"\nassert simplify_directory_path(\"/a/../../b/../c//.//\") == \"/c\"\nassert simplify_directory_path(\"/a/b/c\") == \"/a/b/c\"\nassert simplify_directory_path(\"/a/b/c/\") == \"/a/b/c\"", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.934}, {"few_shot_keywords": "['int', 'Or', 'path sum', 'evaluation', 'boolean', 'pop', 'priority queue', 'boolean values', 'bool', 'expression', 'Exclusive Or', 'And', 'string', 'stack']", "test_keywords": "['items', 'Exclusive Or', 'boolean', 'Or', 'expression', 'pair', 'evaluation', 'string', 'pop', 'stack', 'largest', 'And', 'bool', 'boolean values', 'int']", "prompt_tokens": 627, "total_tokens": 1048, "completion_tokens": 421, "completion": "[Question 2]\n\nWrite a Python function to find the largest pair of items in a stack based on a given boolean expression. The boolean expression will consist of the symbols 'T', 'F', '|', '&' and '^' representing the boolean values, Or, And and Exclusive Or operations respectively. The stack initially contains pairs of integers and the function should return the largest pair of items based on the evaluation of the boolean expression.\n\n[/Question 2]\n\n[Code 2]\n\ndef largestPair(stack: List[Tuple[int, int]], expression: str) -> Tuple[int, int]:\n    def evalBoolExpr(bool1: bool, bool2: bool, op: str) -> bool:\n        if op == '|':\n            return bool1 or bool2\n        elif op == '&':\n            return bool1 and bool2\n        elif op == '^':\n            return bool1 ^ bool2\n\n    max_result = float('-inf')\n    result_pair = None\n    \n    for pair in stack:\n        bool_values = {'T': True, 'F': False}\n        operands = [bool_values[expression[i]] if i % 2 == 0 else expression[i] for i in range(len(expression))]\n        for i in range(len(operands)):\n            if operands[i] in {'|', '&', '^'}:\n                operands[i-1:i+2] = [evalBoolExpr(operands[i-1], operands[i+1], operands[i])]\n        if operands[0] and pair[0] + pair[1] > max_result:\n            max_result = pair[0] + pair[1]\n            result_pair = pair\n            \n    return result_pair\n\n[/Code 2]\n\n[Asserts 2]\n\nstack = [(1, 2), (3, 4), (5, 6)]\nassert largestPair(stack, \"T^T\") == (5, 6)\nassert largestPair(stack, \"T|F\") == (5, 6)\nassert largestPair(stack, \"T&T\") == (5, 6)", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.802}, {"few_shot_keywords": "['traversal', 'repeated', 'math', 'sqrt', 'priority queue', 'traverse', 'algorithm', 'character', 'graph', 'string']", "test_keywords": "['algorithm', 'traversal', 'donate', 'string', 'root to leaf path', 'dimensions', 'heap', 'character', 'repeated', 'input']", "prompt_tokens": 480, "total_tokens": 787, "completion_tokens": 307, "completion": "[Question 2]\n\nWrite a function to find the path from the root to the leaf node in a binary tree that sums up to a given input value. If multiple paths exist, return the one with the maximum number of dimensions (i.e., the longest path).\n\n[/Question 2]\n\n[Code 2]\n\nclass TreeNode:\n    def __init__(self, value=0, left=None, right=None):\n        self.value = value\n        self.left = left\n        self.right = right\n\ndef maxPathSum(root, target):\n    def dfs(node, path, cur_sum):\n        if not node:\n            return\n        cur_sum += node.value\n        path.append(node.value)\n        if not node.left and not node.right and cur_sum == target:\n            if len(path) > len(max_path):\n                max_path.clear()\n                max_path.extend(path)\n        dfs(node.left, path, cur_sum)\n        dfs(node.right, path, cur_sum)\n        path.pop()\n\n    max_path = []\n    dfs(root, [], 0)\n    return max_path\n\n[/Code 2]\n\n[Asserts 2]\n\n# Create a binary tree\nroot = TreeNode(1)\nroot.left = TreeNode(2)\nroot.right = TreeNode(3)\nroot.left.left = TreeNode(4)\nroot.left.right = TreeNode(5)\n\nassert maxPathSum(root, 8) == [1, 2, 5]\nassert maxPathSum(root, 10) == [1, 3]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.94}, {"few_shot_keywords": "['boolean', 'paths', 'expression', 'check', 'string', 'alphabet', 'logic', 'remove', 'character', 'recursion']", "test_keywords": "['string', 'logic', 'check', 'boolean', 'sorting', 'alphabet', 'level', 'character']", "prompt_tokens": 541, "total_tokens": 744, "completion_tokens": 203, "completion": "[Question 2]\n\nWrite a Python function to check if a given string is a palindrome and contains all the letters of the alphabet at least once.\n\n[/Question 2]\n\n[Code 2]\n\ndef isPalindromeWithAlphabet(string: str) -> bool:\n    alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    string = ''.join(e for e in string if e.isalpha()).lower() # Remove non-alphabetic characters and convert to lowercase\n    return string == string[::-1] and all(char in string for char in alphabet)\n\n[/Code 2]\n\n[Asserts 2]\n\nassert isPalindromeWithAlphabet(\"A man, a plan, a canal, Panama.\")==True\nassert isPalindromeWithAlphabet(\"Was it a car or a cat I saw?\")==True\nassert isPalindromeWithAlphabet(\"No lemon, no melon\")==False\nassert isPalindromeWithAlphabet(\"Racecar\")==True\nassert isPalindromeWithAlphabet(\"Palindrome\")==False\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.927}, {"few_shot_keywords": "['bit manipulation', 'indexing', 'sorted', 'condition', 'concatenated', 'substring', 'set', 'string', 'iteration']", "test_keywords": "['sorted', 'set', 'iteration', 'indexing', 'concatenated', 'modulo', 'max', 'prime factors', 'string', 'substring', 'width', 'adjacency list']", "prompt_tokens": 574, "total_tokens": 916, "completion_tokens": 342, "completion": "[Question 2]\n\nGiven a list of strings, find the maximum width of a concatenated substring that is a prime number when represented as an integer in base 10. For example, given the list [\"12\", \"34\", \"56\", \"78\", \"910\"], the maximum width of a concatenated substring that forms a prime number is 5 from the concatenation \"34567\".\n\n[/Question 2]\n\n[Code 2]\n\ndef is_prime(n: int) -> bool:\n    if n < 2:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef prime_concat_width(strings: List[str]) -> int:\n    max_width = 0\n    for s in strings:\n        for i in range(len(s)):\n            for j in range(i, len(s)):\n                substr = s[i:j+1]\n                if is_prime(int(substr)):\n                    max_width = max(max_width, j - i + 1)\n    return max_width\n\n[/Code 2]\n\n[Asserts 2]\n\nassert prime_concat_width([\"12\", \"34\", \"56\", \"78\", \"910\"]) == 5\nassert prime_concat_width([\"123\", \"456\", \"789\"]) == 3\nassert prime_concat_width([\"123\", \"456\", \"789\", \"101112\"]) == 6\nassert prime_concat_width([\"11\", \"22\", \"33\", \"44\"]) == 0\nassert prime_concat_width([\"3\", \"5\", \"7\", \"11\"]) == 2\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.921}, {"few_shot_keywords": "['reverse', 'digits', 'segments', 'substrings', 'modulus', 'count', 'string', 'even', 'iteration']", "test_keywords": "['even', 'angles', 'string', 'count', 'median', 'formula', 'substrings', 'elements', 'iteration', 'modulus', 'digits', 'indexing']", "prompt_tokens": 468, "total_tokens": 731, "completion_tokens": 263, "completion": "[Question 2]\n\nWrite a function to find the median of even length substrings of a given string, where each substring is represented as a sequence of digits and the median is the middle value when the digits are sorted in ascending order.\n\n[/Question 2]\n\n[Code 2]\n\ndef medianOfEvenSubstrings(s: str) -> float:\n    even_substrings = [s[i:j] for i in range(len(s)) for j in range(i+2, len(s)+1) if (j-i)%2 == 0]\n    even_substrings = [int(substring) for substring in even_substrings]\n    even_substrings.sort()\n    n = len(even_substrings)\n    if n % 2 == 0:\n        return (even_substrings[n//2 - 1] + even_substrings[n//2]) / 2\n    else:\n        return even_substrings[n//2]\n\n[/Code 2]\n\n[Asserts 2]\n\nassert medianOfEvenSubstrings(\"1234\") == 25.0\nassert medianOfEvenSubstrings(\"2468\") == 5.0\nassert medianOfEvenSubstrings(\"135791\") == 7\nassert medianOfEvenSubstrings(\"24680246\") == 24.5", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.879}, {"few_shot_keywords": "['tree traversal', 'parent-child', 'recursion', 'depth-first search', 'consecutive sequence', 'dimensions', 'longest path', 'class', 'conditional', 'binary tree', 'priority queue', 'node', 'length', 'string']", "test_keywords": "['frequency', 'pizza', 'angle', 'parent-child', 'QuickSort', 'depth-first search', 'binary tree', 'consecutive sequence', 'length', 'node', 'input', 'recursion', 'longest path', 'tree traversal']", "prompt_tokens": 770, "total_tokens": 1137, "completion_tokens": 367, "completion": "[Question 2]\n\nYou are working in a pizzeria and want to create a system to organize the pizza orders based on their frequency and the angles of slicing. Write a recursive algorithm to sort the list of pizza orders based on the frequency of each order and then, within each frequency group, sort them based on the angle of slicing for the pizza.\n\n[/Question 2]\n\n[Code 2]\n\ndef pizzaOrderSort(pizza_orders):\n    freq_map = {}\n    for order in pizza_orders:\n        if order in freq_map:\n            freq_map[order] += 1\n        else:\n            freq_map[order] = 1\n            \n    def qsort(arr):\n        if len(arr) <= 1:\n            return arr\n        pivot = arr[len(arr) // 2]\n        left = [x for x in arr if freq_map[x] < freq_map[pivot]]\n        middle = [x for x in arr if freq_map[x] == freq_map[pivot]]\n        right = [x for x in arr if freq_map[x] > freq_map[pivot]]\n        return qsort(left) + middle + qsort(right)\n    \n    return qsort(pizza_orders)\n\n[/Code 2]\n\n[Asserts 2]\n\nassert pizzaOrderSort([45, 90, 180, 270, 180, 90, 45, 45, 90]) == [270, 180, 180, 45, 45, 45, 90, 90, 90]\nassert pizzaOrderSort([45, 45, 90, 180, 270, 270, 45, 180]) == [270, 270, 180, 180, 45, 45, 45, 90]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.91}, {"few_shot_keywords": "['permutation', 'sorted', 'escape', 'two pointers', 'LCA', 'lexicographically', 'order', 'halves', 'string', 'previous']", "test_keywords": "['permutation', 'lexicographically', 'sorted', 'BST', 'candies', 'loop', 'arrays', 'order', 'previous']", "prompt_tokens": 566, "total_tokens": 871, "completion_tokens": 305, "completion": "[Question 2]\n\nYou are given an array representing the number of candies that each child has. The array is sorted lexicographically. Write a function to find the previous lexicographically sorted permutation of the given array. If no such permutation exists, return the array in its sorted order.\n\n[/Question 2]\n\n[Code 2]\n\ndef prevLexicoPermutation(arr):\n    n = len(arr)\n    i = n - 2\n    while i >= 0 and arr[i] <= arr[i + 1]:\n        i -= 1\n    if i >= 0:\n        j = n - 1\n        while arr[j] >= arr[i]:\n            j -= 1\n        arr[i], arr[j] = arr[j], arr[i]\n    arr[i + 1:] = arr[i + 1:][::-1]\n    return arr\n\n[/Code 2]\n\n[Asserts 2]\n\nassert prevLexicoPermutation([1, 2, 3])==[1, 3, 2]\nassert prevLexicoPermutation([3, 2, 1])==[3, 2, 1]\nassert prevLexicoPermutation([1, 1, 5])==[1, 1, 5]\nassert prevLexicoPermutation([1, 9, 4, 6, 7])==[1, 7, 6, 4, 9]\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.94}, {"few_shot_keywords": "['integer', 'longest', 'total', 'same value', 'path', 'depth-first search', 'value', 'leaf', 'node', 'binary tree', 'recursive', 'even numbers']", "test_keywords": "['depth-first search', 'longest', 'relative', 'binary tree', 'path', 'node', 'queries', 'value', 'missing', 'integer', 'same value', 'recursive']", "prompt_tokens": 660, "total_tokens": 1189, "completion_tokens": 529, "completion": "[Question 2]\n\nYou are given a binary tree and a list of queries consisting of integer values. For each query value, find the length of the longest path in the binary tree such that the nodes have the same value as the query value, considering only the relative depth between nodes. Implement a depth-first search based solution to efficiently handle the queries.\n\n[/Question 2]\n\n[Code 2]\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef longestPath(root: TreeNode, value: int) -> int:\n    longest = [0]\n\n    def dfs(node, depth):\n        if not node:\n            return 0\n        left = dfs(node.left, depth + 1) if node.left else 0\n        right = dfs(node.right, depth + 1) if node.right else 0\n\n        leftArrow = left + 1 if node.left and node.left.val == value else 0\n        rightArrow = right + 1 if node.right and node.right.val == value else 0\n\n        longest[0] = max(longest[0], leftArrow + rightArrow)\n\n        return max(leftArrow, rightArrow)\n\n    dfs(root, 0)\n    return longest[0]\n\ndef longestPathForQueries(root: TreeNode, queries: List[int]) -> List[int]:\n    result = []\n    for query in queries:\n        result.append(longestPath(root, query))\n    return result\n\n[/Code 2]\n\n[Asserts 2]\n\n# Example binary tree\n#        1\n#       / \\\n#      4   5\n#     / \\   \\\n#    4   4   5\n# Query values: [4, 5]\nroot = TreeNode(1, TreeNode(4, TreeNode(4), TreeNode(4)), TreeNode(5, None, TreeNode(5)))\nassert longestPathForQueries(root, [4, 5]) == [2, 2]\n\n# Example binary tree\n#        0\n#       / \\\n#      0   0\n#     / \\   \\\n#    0   0   0\n# Query values: [0, 1]\nroot = TreeNode(0, TreeNode(0, TreeNode(0), TreeNode(0)), TreeNode(0, None, TreeNode(0)))\nassert longestPathForQueries(root, [0, 1]) == [3, 0]\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.933}, {"few_shot_keywords": "['traversal', 'substitutions', 'edit distance', 'indices', 'string', 'insertions', 'deletions']", "test_keywords": "['deletions', 'string', 'substitutions', 'top-left', 'check', 'edit distance', 'insertions', 'parent pointers']", "prompt_tokens": 596, "total_tokens": 1138, "completion_tokens": 542, "completion": "[Question 2]\n\nWrite a function to calculate the minimum number of deletions and insertions required to convert one string into another. Additionally, the function should return the sequence of operations (deletions and insertions) to transform one string into the other.\n\n[/Question 2]\n\n[Code 2]\n\ndef minEditDistance(s1: str, s2: str) -> (int, list):\n    m = len(s1)\n    n = len(s2)\n    \n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    \n    for i in range(m + 1):\n        for j in range(n + 1):\n            if i == 0:\n                dp[i][j] = j\n            elif j == 0:\n                dp[i][j] = i\n            elif s1[i-1] == s2[j-1]:\n                dp[i][j] = dp[i-1][j-1]\n            else:\n                dp[i][j] = 1 + min(dp[i-1][j], dp[i][j-1])\n    \n    operations = []\n    i, j = m, n\n    while i > 0 and j > 0:\n        if s1[i-1] == s2[j-1]:\n            i -= 1\n            j -= 1\n        elif dp[i-1][j] < dp[i][j-1]:\n            operations.append(f\"Delete {s1[i-1]} at index {i-1}\")\n            i -= 1\n        else:\n            operations.append(f\"Insert {s2[j-1]} at index {i}\")\n            j -= 1\n    \n    while i > 0:\n        operations.append(f\"Delete {s1[i-1]} at index {i-1}\")\n        i -= 1\n    \n    while j > 0:\n        operations.append(f\"Insert {s2[j-1]} at index {i}\")\n        j -= 1\n    \n    operations.reverse()\n    return dp[m][n], operations\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minEditDistance(\"kitten\", \"sitting\") == (3, ['Delete k at index 0', 'Substitute s at index 0', 'Substitute g at index 4'])\nassert minEditDistance(\"intention\", \"execution\") == (5, ['Substitute e at index 3', 'Substitute c at index 6', 'Insert u at index 7', 'Insert t at index 8', 'Insert i at index 9'])", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.731}, {"few_shot_keywords": "['color', 'middle row', 'range', 'flips', 'digits', 'integer', 'counting', 'subtract', 'sum']", "test_keywords": "['counting', 'range', 'integer', 'covered', 'sum', 'grid', 'digits']", "prompt_tokens": 513, "total_tokens": 827, "completion_tokens": 314, "completion": "[Question 2]\n\nGiven a square grid of integers, where each cell contains a single digit, the task is to find the count of integers covered by the sum of digits in the given range.\n\n[/Question 2]\n\n[Code 2]\n\ndef sumOfDigits(num: int) -> int:\n\tsum = 0\n\twhile num > 0:\n\t\tsum += num % 10\n\t\tnum = num // 10\n\treturn sum\n\ndef countCoveredIntegers(grid: List[List[int]], L: int, R: int) -> int:\n\tcount = 0\n\tfor row in grid:\n\t\tfor cell in row:\n\t\t\tif L <= sumOfDigits(cell) <= R:\n\t\t\t\tcount += 1\n\treturn count\n\n[/Code 2]\n\n[Asserts 2]\n\ngrid1 = [\n    [1, 2, 3],\n    [4, 5, 6],\n    [7, 8, 9]\n]\n\ngrid2 = [\n    [11, 22, 33],\n    [44, 55, 66],\n    [77, 88, 99]\n]\n\nassert countCoveredIntegers(grid1, 5, 8) == 4\nassert countCoveredIntegers(grid1, 10, 15) == 0\nassert countCoveredIntegers(grid2, 5, 10) == 9\nassert countCoveredIntegers(grid2, 15, 20) == 0\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.867}, {"few_shot_keywords": "['substring', 'counting', 'binary', 'string', 'coordinates', 'set', 'leaf', 'math', 'combinations']", "test_keywords": "['number', 'bitwise operations', 'time complexity', 'counting', 'combinations', 'string', 'binary', 'weight', 'substring', 'level', 'math']", "prompt_tokens": 480, "total_tokens": 685, "completion_tokens": 205, "completion": "[Question 2]\n\nGiven a positive integer n, write a function to return the count of substrings of the binary representation of n that have an odd number of 1s.\n\n[/Question 2]\n\n[Code 2]\n\ndef countOddBinarySubstrings(n: int) -> int:\n    binary_str = bin(n)[2:]\n    count = 0\n    for i in range(len(binary_str)):\n        for j in range(i, len(binary_str)):\n            if bin(int(binary_str[i:j+1], 2)).count('1') % 2 != 0:\n                count += 1\n    return count\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countOddBinarySubstrings(10) == 3\nassert countOddBinarySubstrings(7) == 5\nassert countOddBinarySubstrings(6) == 2\nassert countOddBinarySubstrings(15) == 8\nassert countOddBinarySubstrings(3) == 3", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.827}, {"few_shot_keywords": "['length', 'successor', 'nodes', 'input', 'top-left', 'root to leaf path', 'sufficient subset', 'rearrange', 'binary tree', 'complexity', 'remove', 'limit', 'path sum']", "test_keywords": "['binary tree', 'limit', 'remove', 'root to leaf path', 'path sum', 'sufficient subset', 'element', 'isosceles', 'length', 'directed acyclic', 'nodes']", "prompt_tokens": 694, "total_tokens": 1077, "completion_tokens": 383, "completion": "[Question 2]\n\nGiven a directed acyclic graph (DAG) represented as a binary tree, and an integer K, the task is to remove all nodes which lie on a root to leaf path of length less than K.\n\n[/Question 2]\n\n[Code 2]\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef removeNodes(root, limit):\n    def checkPathSum(root, summation, length):\n        if not root:\n            return\n        if not root.left and not root.right:\n            if summation + root.val < limit:\n                return True\n            return False\n        left = checkPathSum(root.left, summation + root.val, length + 1)\n        right = checkPathSum(root.right, summation + root.val, length + 1)\n        if left:\n            root.left = None\n        if right:\n            root.right = None\n        return left or right\n    checkPathSum(root, 0, 1)\n    return root\n\n[/Code 2]\n\n[Asserts 2]\n\n# The tree is shown below, and nodes with the value of 6 and 2 should be removed.\n#      1\n#     / \\\n#    2   -3\n#   / \\   / \n#  4   5 -6\nassert(removeNodes(root, 3))==[1, 2, null, 4]\nassert(removeNodes(root, 3)) == [1, 2, null, 4]\nassert(removeNodes(root, 5))==[1, 2, null, 4]\nassert(removeNodes(root, 5)) == [1, 2, null, 4]\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.789}, {"few_shot_keywords": "['original numbers', 'destination', 'queue', 'matrix', 'graph', 'valid', '2D', 'BFS', 'safe', 'source', 'reachable', 'binary', 'shortest path']", "test_keywords": "['flips', 'destination', 'safe', 'pop', 'matrix', 'shortest path', 'reachable', 'graph', 'BFS', 'queue', 'source', 'valid', 'negative numbers', 'game', 'binary']", "prompt_tokens": 988, "total_tokens": 1713, "completion_tokens": 725, "completion": "[Question 2]\n\nYou are playing a game on a 2D binary matrix where each cell contains a value of either 0 or 1. You can perform flips on any cell, changing the value from 0 to 1 or from 1 to 0. Your goal is to reach the destination cell from a given source cell by making the minimum number of flips. Write a function to determine the minimum number of flips required to reach the destination cell, or return -1 if the destination is not reachable.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List, Tuple\nfrom collections import deque\n\ndef isValid(x: int, y: int, n: int, m: int) -> bool:\n\treturn x >= 0 and x < n and y >= 0 and y < m\n\ndef isSafe(i: int, j: int, n: int, m: int, mat: List[List[int]], vis: List[List[bool]]) -> bool:\n\treturn (isValid(i, j, n, m) and not vis[i][j])\n\ndef minFlipsToReachDestination(mat: List[List[int]], source: Tuple[int, int], destination: Tuple[int, int]) -> int:\n\tn = len(mat)\n\tm = len(mat[0])\n\tif mat[source[0]][source[1]] == 0 or mat[destination[0]][destination[1]] == 0:\n\t\treturn -1\n\tdx = [-1, 0, 1, 0]\n\tdy = [0, 1, 0, -1]\n\tvis = [[False for i in range(m)] for j in range(n)]\n\tvis[source[0]][source[1]] = True\n\tq = deque()\n\tq.append(source + (0,))  # (x, y, flips)\n\twhile q:\n\t\tx, y, flips = q.popleft()\n\t\tif (x, y) == destination:\n\t\t\treturn flips\n\t\tfor k in range(4):\n\t\t\tnewx, newy = x + dx[k], y + dy[k]\n\t\t\tif isSafe(newx, newy, n, m, mat, vis):\n\t\t\t\tvis[newx][newy] = True\n\t\t\t\tif mat[newx][newy] != mat[x][y]:\n\t\t\t\t\tq.append((newx, newy, flips + 1))\n\t\t\t\telse:\n\t\t\t\t\tq.appendleft((newx, newy, flips))\n\treturn -1\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minFlipsToReachDestination([[1, 0, 1], [0, 1, 0], [1, 0, 1]], (0, 0), (2, 2)) == 2\nassert minFlipsToReachDestination([[1, 0, 1], [0, 1, 0], [1, 0, 1]], (0, 0), (1, 2)) == -1\nassert minFlipsToReachDestination([[1, 1, 0], [0, 0, 1], [1, 1, 1]], (0, 0), (2, 2)) == 5\nassert minFlipsToReachDestination([[1, 1, 1], [1, 1, 1], [1, 1, 1]], (0, 0), (2, 2)) == 5\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.89}, {"few_shot_keywords": "['column', 'rules', 'source', 'king', 'chessboard', 'diagonal', 'unsafe', 'nested loops', 'attack', 'row', 'list of nodes', 'boolean', 'division']", "test_keywords": "['boolean', 'insert', 'column', 'unsafe', 'diagonal', 'nested loops', 'consecutive', 'row', 'chessboard', 'king', 'attack']", "prompt_tokens": 715, "total_tokens": 1184, "completion_tokens": 469, "completion": "[Question 2]\n\nYou are given a chessboard of size n x n, initially filled with zeros. You need to insert kings represented by 'K' into the chessboard such that no king is in an unsafe position. A king is considered unsafe if it is under attack by another king on the same row, column, or diagonally. Write a function to insert the kings in such a way that no king is unsafe and return True, if it is possible, otherwise return False.\n\n[/Question 2]\n\n[Code 2]\n\ndef isKingSafe(board, row, col):\n    for i in range(row):\n        if board[i][col] == 'K':\n            return False\n    for i, j in zip(range(row, -1, -1), range(col, -1, -1)):\n        if board[i][j] == 'K':\n            return False\n    for i, j in zip(range(row, -1, -1), range(col, len(board))):\n        if board[i][j] == 'K':\n            return False\n    return True\n\ndef insertKings(n):\n    board = [['.' for _ in range(n)] for _ in range(n)]\n    if insertKingsUtil(board, 0, n):\n        return board\n    else:\n        return []\n\ndef insertKingsUtil(board, row, n):\n    if row == n:\n        return True\n    for col in range(n):\n        if isKingSafe(board, row, col):\n            board[row][col] = 'K'\n            if insertKingsUtil(board, row + 1, n):\n                return True\n            board[row][col] = '.'\n    return False\n\n[/Code 2]\n\n[Asserts 2]\n\nassert insertKings(4)==[['.', 'K', '.', '.'],\n                        ['.', '.', '.', 'K'],\n                        ['K', '.', '.', '.'],\n                        ['.', '.', 'K', '.']]\nassert insertKings(3)==[]\nassert insertKings(5)==[['K', '.', '.', '.', '.'],\n                        ['.', '.', 'K', '.', '.'],\n                        ['.', '.', '.', '.', 'K'],\n                        ['.', 'K', '.', '.', '.'],\n                        ['.', '.', '.', 'K', '.']]\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.723}, {"few_shot_keywords": "['boolean', 'set', 'min value', 'pair', 'array', 'sum', 'AND operation', 'search', 'BST']", "test_keywords": "['max', 'game', 'matchsticks', 'pair', 'sum', 'boolean', 'set', 'array', 'search', 'limited range']", "prompt_tokens": 534, "total_tokens": 773, "completion_tokens": 239, "completion": "[Question 2]\n\nYou are given an array of matchsticks representing the numbers from 1 to n. You and your friend take turns to pick matchsticks from the array. On each turn, a player can pick any number of matchsticks from 1 to m (inclusive) where m is a positive integer less than or equal to the maximum of the array. The player who picks the last matchstick loses the game. Given the array of matchsticks, write a function to determine if you can win the game if you move first, assuming both you and your friend play optimally. Return True if you can win and False if you cannot.\n\n[/Question 2]\n\n[Code 2]\n\ndef canWinMatchsticks(n: int, maxPick: int) -> bool:\n    return n % (maxPick + 1) != 0\n\n[/Code 2]\n\n[Asserts 2]\n\nassert canWinMatchsticks(5, 3) == False\nassert canWinMatchsticks(12, 4) == True\nassert canWinMatchsticks(10, 4) == False\nassert canWinMatchsticks(20, 3) == True", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.723}, {"few_shot_keywords": "['on', 'depth first search', 'consecutive', 'items', 'node', 'length', 'pair', 'DFS', 'flips', 'binary tree', 'parent', 'max', 'sequence']", "test_keywords": "['node', 'length', 'donate', 'parent', 'DFS', 'consecutive', 'max', 'angle', 'even level', 'depth first search', 'inclusive', 'sequence', 'binary tree']", "prompt_tokens": 609, "total_tokens": 943, "completion_tokens": 334, "completion": "[Question 2]\n\nGiven a binary tree, write a function to calculate the maximum angle formed between two consecutive even level nodes.\n\n[/Question 2]\n\n[Code 2]\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef maxConsecutiveAngle(root: TreeNode) -> float:\n    def dfs(node, level, parent_val):\n        if not node:\n            return 0.0, 0\n            \n        if level % 2 == 0:\n            return max(abs(node.val - parent_val), dfs(node.left, level + 1, node.val), dfs(node.right, level + 1, node.val))\n        else:\n            return max(dfs(node.left, level + 1, parent_val), dfs(node.right, level + 1, parent_val))\n\n    return dfs(root, 0, root.val)[0]\n\n[/Code 2]\n\n[Asserts 2]\n\n# Create binary tree nodes\nn1 = TreeNode(1)\nn3 = TreeNode(3)\nn2 = TreeNode(2, n1, n3)\nn4 = TreeNode(4)\nn5 = TreeNode(5, n3, n4)\nroot = TreeNode(1, n2, n5)\n# Test cases\nassert maxConsecutiveAngle(root)==2\nassert maxConsecutiveAngle(n5)==2\nassert maxConsecutiveAngle(n3)==0\nassert maxConsecutiveAngle(n4)==0\nassert maxConsecutiveAngle(TreeNode())==0\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.741}, {"few_shot_keywords": "['division', 'remainder', 'modulus', 'append', 'integer', 'power', 'dimensions', 'concatenated', 'level', 'factorial']", "test_keywords": "['modulus', 'power', 'bitwise', 'division', 'remainder', 'integer', 'limit', 'factorial']", "prompt_tokens": 576, "total_tokens": 945, "completion_tokens": 369, "completion": "[Question 2]\n\nGiven an integer N, find the sum of all integers from 1 to N where each number is powered to the factorial of its own digit sum, and the result is taken modulo M.\n\n[/Question 2]\n\n[Code 2]\n\ndef factorial(n): \n    res = 1\n    for i in range(1, n+1): \n        res = (res * i)\n    return res \n\ndef digitSum(n): \n    s = 0\n    while n: \n        s += n % 10\n        n //= 10\n    return s\n\ndef power(x, y, p): \n    res = 1\n    x = x % p \n    while (y > 0): \n        if (y & 1): \n            res = (res * x) % p \n        y = y >> 1\n        x = (x * x) % p \n    return res \n\ndef sumPoweredFactorials(N: int, M: int) -> int:\n    total_sum = 0\n    for i in range(1, N+1):\n        digit_sum = digitSum(i)\n        fact = factorial(digit_sum)\n        powered = power(i, fact, M)\n        total_sum = (total_sum + powered) % M\n    return total_sum\n\n[/Code 2]\n\n[Asserts 2]\n\nassert sumPoweredFactorials(5, 10) == 5\nassert sumPoweredFactorials(10, 13) == 9\nassert sumPoweredFactorials(15, 17) == 4\nassert sumPoweredFactorials(20, 25) == 23\nassert sumPoweredFactorials(25, 30) == 17\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.863}, {"few_shot_keywords": "['trimming', 'inorder traversal', 'frequency', 'weight', 'ascending order', 'array', 'tree', 'elements']", "test_keywords": "['set', 'ascending order', 'elements', 'concatenated', 'array', 'frequency']", "prompt_tokens": 721, "total_tokens": 870, "completion_tokens": 149, "completion": "[Question 2]\n\nYou are given an array of strings. Write a function to concatenate all elements of the array and return the concatenated string in ascending order.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef concatenateAndSort(arr: List[str]) -> str:\n    concatenated_string = ''.join(arr)\n    return ''.join(sorted(concatenated_string))\n\n[/Code 2]\n\n[Asserts 2]\n\nassert concatenateAndSort([\"hello\", \"world\"]) == \"dehllloorw\"\nassert concatenateAndSort([\"a\", \"aa\", \"aaa\"]) == \"aaaaaaa\"\nassert concatenateAndSort([\"ab\", \"ba\", \"abc\"]) == \"aabbabc\"\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.879}, {"few_shot_keywords": "['frequency', 'connected', 'element', 'integer', 'traversal', 'limited range', 'attack', 'dictionary', 'products', 'LCA', 'time complexity']", "test_keywords": "['directrix', 'element', 'integer', 'permutation', 'time complexity', 'tail', 'frequency', 'max length', 'dictionary', 'limited range', 'distribute']", "prompt_tokens": 550, "total_tokens": 826, "completion_tokens": 276, "completion": "[Question 2]\n\nGiven a list of integers, find the maximum length of a subarray with a limited range of elements and having each element's frequency distributed as a permutation of its occurrences, all in less than O(n^2) time complexity.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef maxSubarrayLength(arr: List[int]) -> int:\n    max_length = 0\n    for i in range(len(arr)):\n        freq = {}\n        distinct_elements = 0\n        for j in range(i, len(arr)):\n            if arr[j] not in freq:\n                distinct_elements += 1\n            freq[arr[j]] = freq.get(arr[j], 0) + 1\n            if distinct_elements == j - i + 1:\n                max_length = max(max_length, j - i + 1)\n    return max_length\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maxSubarrayLength([2, 1, 2, 2, 1]) == 2\nassert maxSubarrayLength([3, 1, 2, 3, 2, 2]) == 3\nassert maxSubarrayLength([2, 2, 1, 3, 3, 1]) == 3\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.922}, {"few_shot_keywords": "['exponentiation', 'modulus', 'integers', 'substring', 'math', 'insert', 'sub-trees', 'odd level', 'bitwise']", "test_keywords": "['exponentiation', 'math', 'modulus', 'bitwise', 'check', 'king']", "prompt_tokens": 506, "total_tokens": 730, "completion_tokens": 224, "completion": "[Question 2]\n\nGiven a chessboard represented as an 8x8 grid and the positions of a white king and a black king, write a function to check if the black king is in check by the white king.\n\n[/Question 2]\n\n[Code 2]\n\ndef isBlackKingInCheck(whiteKing: tuple, blackKing: tuple) -> bool:\n    if abs(whiteKing[0] - blackKing[0]) <= 1 and abs(whiteKing[1] - blackKing[1]) <= 1:\n        return True\n    else:\n        return False\n\n[/Code 2]\n\n[Asserts 2]\n\nassert isBlackKingInCheck((3, 3), (4, 4)) == True\nassert isBlackKingInCheck((5, 5), (7, 7)) == False\nassert isBlackKingInCheck((2, 2), (1, 4)) == False\nassert isBlackKingInCheck((7, 0), (6, 1)) == True\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.828}, {"few_shot_keywords": "['modification', 'path', 'bends', 'max length', 'change', 'append', 'grid', 'direction', 'matrix']", "test_keywords": "['direction', 'max length', 'matrix', 'sides', 'binary search', 'path', 'change', 'bends', 'grid']", "prompt_tokens": 747, "total_tokens": 1484, "completion_tokens": 737, "completion": "[Question 2]\n\nGiven a binary matrix representing a grid with blocked and open cells, find the length of the longest path from the top-left corner to the bottom-right corner of the grid, where you can only move in four cardinal directions (up, down, left, or right). The path should have the maximum number of bends.\n\n[/Question 2]\n\n[Code 2]\n\ndef findMaxLengthWithBends(grid: List[List[int]]) -> int:\n    n = len(grid)\n    dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    def isValid(x, y):\n        return x >= 0 and y >= 0 and x < n and y < n\n    \n    def hasBend(x1, y1, x2, y2, x3, y3):\n        return (x2 - x1) * (y3 - y2) != (y2 - y1) * (x3 - x2)\n    \n    def dfs(x, y, prevX, prevY, prevDir, visited):\n        if x == n - 1 and y == n - 1:\n            return 0\n        maxLen = 0\n        for dir in range(4):\n            newX = x + dirs[dir][0]\n            newY = y + dirs[dir][1]\n            if isValid(newX, newY) and grid[newX][newY] == 0 and not visited[newX][newY]:\n                if (x, y) == (0, 0) or hasBend(prevX, prevY, x, y, newX, newY):\n                    visited[newX][newY] = True\n                    maxLen = max(maxLen, 1 + dfs(newX, newY, x, y, dir, visited))\n                    visited[newX][newY] = False\n        return maxLen\n    \n    visited = [[False for _ in range(n)] for _ in range(n)]\n    visited[0][0] = True\n    return 1 + dfs(0, 0, 0, 0, -1, visited)\n\n[/Code 2]\n\n[Asserts 2]\n\nassert findMaxLengthWithBends([[0, 1, 0, 0, 0, 0], [0, 1, 0, 1, 1, 0], [0, 0, 0, 1, 0, 1], [1, 1, 0, 0, 0, 1], [0, 0, 0, 1, 1, 0], [0, 1, 0, 0, 0, 0]]) == 11\nassert findMaxLengthWithBends([[0, 1, 0, 0, 0, 0], [0, 1, 0, 1, 1, 0], [0, 0, 0, 1, 0, 1], [1, 1, 0, 0, 1, 1], [0, 0, 0, 1, 1, 0], [0, 1, 0, 0, 0, 0]]) == 10\nassert findMaxLengthWithBends([[0, 0, 0], [0, 0, 0], [0, 0, 0]]) == 4\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.715}, {"few_shot_keywords": "['swaps', 'sum', 'child', 'remove', 'smallest', 'sides', 'coloring', 'largest', 'eccentricity', 'polygon', 'form', 'inside', 'node']", "test_keywords": "['plane', 'hexagon', 'rectangle', 'sides', 'sum', 'polygon', 'smallest', 'form', 'largest', 'child', 'remove']", "prompt_tokens": 463, "total_tokens": 735, "completion_tokens": 272, "completion": "[Question 2]\n\nYou are given a plane with several polygons on it, including rectangles and hexagons. Write a function to find the sum of the sides of the smallest and largest polygons on the plane.\n\n[/Question 2]\n\n[Code 2]\n\ndef sumSidesOfSmallestAndLargestPolygons(polygons):\n    sides = [len(polygon) for polygon in polygons]\n    return sum(sides), max(sides) + min(sides)\n\n[/Code 2]\n\n[Asserts 2]\n\nassert sumSidesOfSmallestAndLargestPolygons([[4, 4, 4, 4], [6, 6, 6, 6, 6, 6], [3, 3, 3]]) == (17, 12)\nassert sumSidesOfSmallestAndLargestPolygons([[3, 3, 3, 3], [4, 4, 4, 4, 4, 4]]) == (14, 6)\nassert sumSidesOfSmallestAndLargestPolygons([[5, 5, 5, 5, 5], [6, 6, 6, 6, 6, 6]]) == (16, 11)\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.867}, {"few_shot_keywords": "['area', 'circumcircle', 'median', 'math', 'ellipse', 'equilateral', 'constant', 'conditional', 'free', 'triangle', 'addition', 'update', 'formula']", "test_keywords": "['math', 'area', 'concatenated', 'equilateral', 'circumcircle', 'palindromic', 'constant', 'successor', 'median', 'volume', 'closest', 'triangle', 'formula']", "prompt_tokens": 514, "total_tokens": 868, "completion_tokens": 354, "completion": "[Question 2]\n\nWrite a program to find the closest palindromic number to the volume of the circumcircle of an equilateral triangle given its median. The formula to calculate the volume of the circumcircle of an equilateral triangle using its median is given by the formula (\u03c0 * median^3) / 6, where \u03c0 is a constant and median is the length of the median of the equilateral triangle. You need to find the closest palindromic number to the calculated volume.\n\n[/Question 2]\n\n[Code 2]\n\nimport math\n\ndef is_palindromic(num: int) -> bool:\n    return str(num) == str(num)[::-1]\n\ndef closestPalindromicVolume(median: float) -> int:\n\tvolume = (math.pi * median**3) / 6\n\tclosest_palindromic = None\n\tdiff = float('inf')\n\t\n\tfor i in range(int(volume), 0, -1):\n\t\tif is_palindromic(i):\n\t\t\tif abs(volume - i) < diff:\n\t\t\t\tclosest_palindromic = i\n\t\t\t\tdiff = abs(volume - i)\n\t\t\t\tbreak\n\t\t\t\n\tfor i in range(int(volume), int(volume) * 2):\n\t\tif is_palindromic(i):\n\t\t\tif abs(volume - i) < diff:\n\t\t\t\tclosest_palindromic = i\n\t\t\t\tdiff = abs(volume - i)\n\t\t\t\tbreak\n\t\n\treturn closest_palindromic\n\n[/Code 2]\n\n[Asserts 2]\n\nassert closestPalindromicVolume(2) == 33\nassert closestPalindromicVolume(3.5) == 154\nassert closestPalindromicVolume(5) == 477", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.804}, {"few_shot_keywords": "['maximize', 'traversal', 'integer', 'node', 'least common ancestor', 'recursive', 'level', 'distance', 'swap', 'turns', 'LCA', 'pizza', 'binary tree', 'attack']", "test_keywords": "['node', 'circumference', 'turns', 'least common ancestor', 'binary tree', 'level', 'distance', 'traversal', 'LCA', 'equality', 'recursive', 'bool']", "prompt_tokens": 840, "total_tokens": 1357, "completion_tokens": 517, "completion": "[Question 2]\n\nYou are given a binary tree and two nodes. Write a program to determine if the nodes are at the same level and have the same parent in the binary tree. The solution to this problem involves finding the least common ancestor (LCA) of both nodes and checking if they are at the same level and not equal to their LCA.\n\nWrite a program to check if two nodes in a binary tree are at the same level and have the same parent.\n\n[/Question 2]\n\n[Code 2]\n\nclass Node:\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n\ndef LCA(root, n1, n2):\n    if root is None:\n        return None\n    if root.key == n1 or root.key == n2:\n        return root\n    left = LCA(root.left, n1, n2)\n    right = LCA(root.right, n1, n2)\n    if left and right:\n        return root\n    return left if left is not None else right\n\ndef getLevel(root, key, level):\n    if root is None:\n        return 0\n    if root.key == key:\n        return level\n    downlevel = getLevel(root.left, key, level+1)\n    if downlevel != 0:\n        return downlevel\n    return getLevel(root.right, key, level+1)\n\ndef isSameLevelAndParent(root, n1, n2):\n    lca = LCA(root, n1, n2)\n    level1 = getLevel(root, n1, 1)\n    level2 = getLevel(root, n2, 1)\n    return level1 == level2 and lca is not None and lca.key != n1 and lca.key != n2\n\n[/Code 2]\n\n[Asserts 2]\n\nroot = Node(1)\nroot.left = Node(2)\nroot.right = Node(3)\nroot.left.left = Node(4)\nroot.left.right = Node(5)\nroot.right.left = Node(6)\nroot.right.right = Node(7)\nassert isSameLevelAndParent(root, 4, 5) == True\nassert isSameLevelAndParent(root, 2, 3) == False\nassert isSameLevelAndParent(root, 4, 6) == False\nassert isSameLevelAndParent(root, 2, 4) == False\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.916}, {"few_shot_keywords": "['equilateral', 'triangle', 'isosceles', 'scalene', 'math', 'geometry', 'tetrahedron', 'accessible', 'arrangement', 'sides']", "test_keywords": "['triangle', 'equilateral', 'math', 'isosceles', 'simplify', 'sides', 'diagonal', 'scalene', 'geometry']", "prompt_tokens": 572, "total_tokens": 837, "completion_tokens": 265, "completion": "[Question 2]\n\nYou are given the lengths of the three sides of a triangle. Write a function to determine if the triangle is equilateral, isosceles, or scalene. Additionally, simplify the function to return \"Invalid\" if the given sides cannot form a triangle.\n\n[/Question 2]\n\n[Code 2]\n\ndef triangleType(s1: int, s2: int, s3: int) -> str:\n    if s1 + s2 <= s3 or s1 + s3 <= s2 or s2 + s3 <= s1:\n        return \"Invalid\"\n    elif s1 == s2 == s3:\n        return \"Equilateral\"\n    elif s1 == s2 or s1 == s3 or s2 == s3:\n        return \"Isosceles\"\n    else:\n        return \"Scalene\"\n\n[/Code 2]\n\n[Asserts 2]\n\nassert triangleType(5, 5, 5) == \"Equilateral\"\nassert triangleType(3, 4, 3) == \"Isosceles\"\nassert triangleType(7, 4, 3) == \"Scalene\"\nassert triangleType(1, 1, 3) == \"Invalid\"\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.907}, {"few_shot_keywords": "['connected', 'closest', 'validity', 'decrease', 'sum', 'angles', 'triangle', 'geometry', 'sorting', 'divide']", "test_keywords": "['modulus', 'validity', 'combinations', 'angles', 'total', 'geometry', 'triangle', 'sum']", "prompt_tokens": 520, "total_tokens": 781, "completion_tokens": 261, "completion": "[Question 2]\n\nYou are given the lengths of three sides of a triangle. Write a function to determine whether the triangle is valid or not based on the triangle inequality theorem. If the triangle is valid, return True, else return False. According to the triangle inequality theorem, the sum of the lengths of any two sides of a triangle must be greater than or equal to the length of the third side.\n\n[/Question 2]\n\n[Code 2]\n\ndef is_valid_triangle(side1: int, side2: int, side3: int) -> bool:\n    if side1 + side2 > side3 and side2 + side3 > side1 and side1 + side3 > side2:\n        return True\n    else:\n        return False\n\n[/Code 2]\n\n[Asserts 2]\n\nassert is_valid_triangle(3, 4, 5)==True\nassert is_valid_triangle(5, 12, 13)==True\nassert is_valid_triangle(8, 15, 7)==True\nassert is_valid_triangle(1, 1, 3)==False\nassert is_valid_triangle(10, 20, 5)==True\nassert is_valid_triangle(6, 6, 12)==False\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.937}, {"few_shot_keywords": "['diagonal', 'equilateral triangle', 'geometry', 'concatenate', 'area', 'inscribed', 'calculation', 'math', 'multiple', 'BFS', 'loop', 'hexagon']", "test_keywords": "['inscribed', 'division', 'math', 'accessible', 'union', 'calculation', 'geometry', 'equilateral triangle', 'area', 'hexagon']", "prompt_tokens": 489, "total_tokens": 728, "completion_tokens": 239, "completion": "[Question 2]\n\nGiven a hexagon inscribed within a circle, write a function to calculate the area of the portion accessible within the hexagon, but outside the inscribed equilateral triangle of side length s.\n\n[/Question 2]\n\n[Code 2]\n\nimport math\n\ndef areaAccessiblePortion(hexagon_side: float, triangle_side: float) -> float:\n    area_hexagon = (3 * math.sqrt(3) * hexagon_side ** 2) / 2\n    area_triangle = (math.sqrt(3) * triangle_side ** 2) / 4\n    area_accessible = area_hexagon - area_triangle\n    return area_accessible\n\n[/Code 2]\n\n[Asserts 2]\n\nassert areaAccessiblePortion(6, 3) == 93.53074360871938\nassert areaAccessiblePortion(8, 4) == 138.5640646055104\nassert areaAccessiblePortion(10, 5) == 217.48679085304232\nassert areaAccessiblePortion(12, 6) == 313.0790172362576\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.933}, {"few_shot_keywords": "['vertex', 'sqrt', 'parallel', 'center', 'semi-major axis', 'ellipse', 'formation', 'pointer manipulation', 'inorder traversal', 'focus', 'semi-minor axis', 'numbers', 'class', 'distance', 'equation', 'tuple', 'directrix', 'math', 'eccentricity']", "test_keywords": "['distance', 'center', 'semi-minor axis', 'buying', 'cost', 'eccentricity', 'math', 'ellipse', 'class', 'semi-major axis', 'sqrt', 'tuple', 'focus', 'directrix', 'tree', 'vertex', 'elements', 'equation']", "prompt_tokens": 798, "total_tokens": 1234, "completion_tokens": 436, "completion": "[Question 2]\n\nCreate a program that models a buying decision tree for purchasing products based on cost and distance from the center. Each decision node in the tree represents a product, and the edges leading from each node represent the cost and distance to the next potential product. The tree should be implemented using a class structure and should allow for the calculation of the total cost and distance for a given path through the tree.\n\n[/Question 2]\n\n[Code 2]\n\nclass BuyingDecisionTree:\n    def __init__(self, product: str, cost: float, distance: float, left: 'BuyingDecisionTree' = None, right: 'BuyingDecisionTree' = None):\n        self.product = product\n        self.cost = cost\n        self.distance = distance\n        self.left = left\n        self.right = right\n\n    def total_cost(self) -> float:\n        if self.left is None and self.right is None:\n            return self.cost\n        left_cost = self.left.total_cost() if self.left else 0\n        right_cost = self.right.total_cost() if self.right else 0\n        return self.cost + max(left_cost, right_cost)\n\n    def total_distance(self) -> float:\n        if self.left is None and self.right is None:\n            return self.distance\n        left_distance = self.left.total_distance() if self.left else 0\n        right_distance = self.right.total_distance() if self.right else 0\n        return self.distance + max(left_distance, right_distance)\n\n[/Code 2]\n\n[Asserts 2]\n\ntree = BuyingDecisionTree('A', 100, 50, BuyingDecisionTree('B', 50, 30), BuyingDecisionTree('C', 70, 40))\nassert tree.total_cost() == 170\nassert tree.total_distance() == 90\n\ntree = BuyingDecisionTree('X', 200, 80, BuyingDecisionTree('Y', 120, 60, BuyingDecisionTree('Z', 80, 40)))\nassert tree.total_cost() == 280\nassert tree.total_distance() == 180\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.893}, {"few_shot_keywords": "['arrays', 'vertex', 'even level', 'traversal', 'float', 'node', 'list', 'impossible', 'level', 'queue', 'binary tree', 'odd level']", "test_keywords": "['leaf', 'even level', 'traversal', 'binary tree', 'queue', 'node', 'odd level', 'row', 'level', 'list', 'loop']", "prompt_tokens": 678, "total_tokens": 1043, "completion_tokens": 365, "completion": "[Question 2]\n\nWrite a function to find the number of leaf nodes at each level of a given binary tree. Output the result as a list of lists where each list corresponds to a level and contains the number of leaf nodes at that level.\n\n[/Question 2]\n\n[Code 2]\n\nclass TreeNode:\n    def __init__(self, value=0, left=None, right=None):\n        self.value = value\n        self.left = left\n        self.right = right\n\ndef countLeafNodesAtEachLevel(root: TreeNode) -> List[int]:\n    result = []\n    if not root:\n        return result\n    \n    queue = [root]\n    \n    while queue:\n        level_leaf_count = 0\n        size = len(queue)\n        for _ in range(size):\n            node = queue.pop(0)\n            if not node.left and not node.right:\n                level_leaf_count += 1\n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n        result.append(level_leaf_count)\n    \n    return result\n\n[/Code 2]\n\n[Asserts 2]\n\ntree1 = TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(5)), TreeNode(3, TreeNode(6), TreeNode(7)))\nassert countLeafNodesAtEachLevel(tree1) == [0, 2, 4]\n\ntree2 = TreeNode(1, TreeNode(2, TreeNode(4, TreeNode(8), TreeNode(9)), TreeNode(5, TreeNode(10), TreeNode(11))), TreeNode(3, TreeNode(6, TreeNode(12), TreeNode(13)), TreeNode(7)))\nassert countLeafNodesAtEachLevel(tree2) == [0, 2, 4, 4] \n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.9}, {"few_shot_keywords": "['maximize', 'bitwise', 'calculation', 'geometry', 'max', 'trimming', 'math', 'radius', 'inscribed', 'equilateral triangle', 'area', 'circle']", "test_keywords": "['inscribed', 'math', 'circle', 'radius', 'triplets', 'coordinates', 'paths', 'area', 'equilateral triangle', 'geometry', 'largest']", "prompt_tokens": 545, "total_tokens": 982, "completion_tokens": 437, "completion": "[Question 2]\n\nYou are given a list of coordinates representing points in the 2D plane. Write a program to find the largest equilateral triangle that can be inscribed in the given set of coordinates. The program should return the coordinates of the three vertices of the equilateral triangle.\n\n[/Question 2]\n\n[Code 2]\n\ndef distance(p1, p2):\n    return ((p2[0]-p1[0])**2 + (p2[1]-p1[1])**2) ** 0.5\n\ndef findLargestEquilateralTriangle(coordinates):\n    maxArea = 0\n    result = [(0,0), (0,0), (0,0)]\n    for i in range(len(coordinates)):\n        for j in range(i+1, len(coordinates)):\n            sideLength = distance(coordinates[i], coordinates[j])\n            if sideLength * (3**0.5) <= maxArea**0.5:\n                continue\n            for k in range(j+1, len(coordinates)):\n                sideLength2 = distance(coordinates[i], coordinates[k])\n                if sideLength == sideLength2:\n                    sideLength3 = distance(coordinates[j], coordinates[k])\n                    if sideLength3 == sideLength and sideLength3 == sideLength2:\n                        area = (3**0.5) / 4 * sideLength**2\n                        if area > maxArea:\n                            maxArea = area\n                            result = [coordinates[i], coordinates[j], coordinates[k]]\n    return result\n\n[/Code 2]\n\n[Asserts 2]\n\nassert findLargestEquilateralTriangle([(0,0), (1,0), (0.5,0.5*(3**0.5))]) == [(0, 0), (1, 0), (0.5, 0.8660254037844386)]\nassert findLargestEquilateralTriangle([(0,0), (1,0), (1,1), (0,1)]) == [(0, 0), (1, 0), (0.5, 0.8660254037844386)]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.81}, {"few_shot_keywords": "['calculation', 'matrix', 'edges', 'formula', 'volume', 'tetrahedron', 'irregular', 'steps', 'sorting', 'determinant']", "test_keywords": "['tetrahedron', 'volume', 'children', 'determinant', 'outside', 'permutation', 'formula', 'irregular', 'calculation', 'edges', 'matrix']", "prompt_tokens": 983, "total_tokens": 1709, "completion_tokens": 726, "completion": "[Question 2]\n\nYou are organizing a math competition for school children, where you want to challenge them with a problem related to calculating the volume of an irregular tetrahedron. Write a program to generate all possible permutations of the edges of a tetrahedron and then calculate the volume of the irregular tetrahedron for each permutation using the determinant formula: \\(\\frac{1}{6} \\times \\sqrt{\\text{det}(A)}\\), where det is the determinant of the corresponding 3x3 matrix A. Finally, find and print the maximum volume of the irregular tetrahedron that can be formed with the given edge lengths.\n\n[/Question 2]\n\n[Code 2]\n\nimport itertools\n\ndef calculateTetrahedronVolume(a, b, c, d):\n    A = [[0, a**2, b**2, c**2, d**2],\n         [a**2, 0, (a**2 + c**2 - b**2), (a**2 + d**2 - b**2), (d**2 - c**2)],\n         [b**2, (a**2 + c**2 - b**2), 0, (b**2 + d**2 - c**2), (c**2 - d**2)],\n         [c**2, (a**2 + d**2 - b**2), (b**2 + d**2 - c**2), 0, (b**2 - a**2)],\n         [d**2, (d**2 - c**2), (c**2 - d**2), (b**2 - a**2), 0],\n        ]\n    det = (A[0][1] * (A[1][2]*A[2][3] - A[2][2]*A[1][3])) - (A[0][2] * (A[1][1]*A[2][3] - A[2][1]*A[1][3])) + (A[0][3] * (A[1][1]*A[2][2] - A[2][1]*A[1][2]))\n    return (1/6) * (det ** 0.5)\n\ndef findMaxTetrahedronVolume(edges):\n    permutations = itertools.permutations(edges)\n    max_volume = 0\n    for perm in permutations:\n        volume = calculateTetrahedronVolume(perm[0], perm[1], perm[2], perm[3])\n        max_volume = max(max_volume, volume)\n    return max_volume\n\n[/Code 2]\n\n[Asserts 2]\n\nassert abs(findMaxTetrahedronVolume([3, 4, 5, 6]) - 41.21252519925037) < 1e-10\nassert abs(findMaxTetrahedronVolume([5, 12, 13, 14]) - 510.6877921853867) < 1e-10\nassert abs(findMaxTetrahedronVolume([7, 8, 10, 15]) - 339.65280707035055) < 1e-10\nassert abs(findMaxTetrahedronVolume([9, 12, 15, 20]) - 660.9451130836996) < 1e-10\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.935}, {"few_shot_keywords": "['angle', 'geometry', 'different', 'modulo', 'possibility', 'conditional', 'math', 'polygon', 'prime', 'arrays']", "test_keywords": "['missing', 'math', 'conditional', 'chessboard', 'values', 'possibility', 'even level', 'geometry', 'polygon', 'angle']", "prompt_tokens": 464, "total_tokens": 725, "completion_tokens": 261, "completion": "[Question 2]\n\nYou are given a list of n-1 unique integers from 1 to n. The list represents the values of a polygon's angles in an n-sided polygon. The task is to find the missing angle in the polygon. Return the missing angle if it is possible to form a polygon with the given angles, else return -1.\n\n[/Question 2]\n\n[Code 2]\n\ndef find_missing_angle(angles: List[int]) -> int:\n    n = len(angles) + 1\n    total_sum = sum(angles)\n    expected_sum = (n - 2) * 180\n    missing_angle = expected_sum - total_sum\n    if missing_angle > 0 and missing_angle < 180:\n        return missing_angle\n    else:\n        return -1\n\n[/Code 2]\n\n[Asserts 2]\n\nassert find_missing_angle([60, 90, 120])==150\nassert find_missing_angle([45, 45, 90, 90])==90\nassert find_missing_angle([30, 60, 90, 120])==180\nassert find_missing_angle([30, 60, 100, 120])== -1\nassert find_missing_angle([45, 90, 135])== -1", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.802}, {"few_shot_keywords": "['circle', 'radius', 'plane', 'decrease', 'coordinate', 'gcd', 'division', 'extra', 'quadrant', 'distinct', 'power', 'center']", "test_keywords": "['division', 'strings', 'round', 'center', 'coordinate', 'even level', 'circle', 'plane', 'quadrant', 'radius']", "prompt_tokens": 596, "total_tokens": 865, "completion_tokens": 269, "completion": "[Question 2]\n\nYou are given a list of strings. Write a function to find the strings whose length is an even number and round the string to the nearest center point based on the length of the string. For strings with even length, the center point is the midpoint between the two middle characters. For odd-length strings, the center point is the middle character itself. Return the modified list of strings after rounding them to the nearest center point.\n\n[/Question 2]\n\n[Code 2]\n\ndef roundToCenter(strings: list) -> list:\n    result = []\n    for string in strings:\n        if len(string) % 2 == 0:\n            mid = len(string) // 2\n            rounded_string = string[:mid-1] + string[mid] + string[mid+1:]\n            result.append(rounded_string)\n        else:\n            mid = len(string) // 2\n            rounded_string = string[:mid] + string[mid] + string[mid+1:]\n            result.append(rounded_string)\n    return result\n\n[/Code 2]\n\n[Asserts 2]\n\nassert roundToCenter(['abcd', 'xyz', 'pqrst']) == ['abcd', 'xyz', 'pqrst']\nassert roundToCenter(['abcde', 'wxyz']) == ['abde', 'wxz']", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.927}, {"few_shot_keywords": "['matching', 'stack', 'minimize', 'inorder', 'binary tree', 'node', 'leaves', 'non-matching', 'last element']", "test_keywords": "['leaves', 'node', 'stack', 'binary tree', 'graph traversal', 'pop', 'inorder', 'matching', 'deletions', 'non-matching']", "prompt_tokens": 816, "total_tokens": 1333, "completion_tokens": 517, "completion": "[Question 2]\n\nGiven a binary tree, write a function to perform deletions on the tree. The function should take a node to delete and perform the deletion. After the deletion, perform an inorder traversal and return the resulting list of leaves.\n\n[/Question 2]\n\n[Code 2]\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\ndef deleteNodeAndTraverse(root: TreeNode, node_val: int) -> list:\n    def inorder(node, leaves):\n        if not node:\n            return\n        inorder(node.left, leaves)\n        if not node.left and not node.right:\n            leaves.append(node.val)\n        inorder(node.right, leaves)\n    \n    def deleteNode(root, key):\n        if not root:\n            return root\n        if key < root.val:\n            root.left = deleteNode(root.left, key)\n        elif key > root.val:\n            root.right = deleteNode(root.right, key)\n        else:\n            if not root.left:\n                temp = root.right\n                root = None\n                return temp\n            elif not root.right:\n                temp = root.left\n                root = None\n                return temp\n            temp = minValueNode(root.right)\n            root.val = temp.val\n            root.right = deleteNode(root.right, temp.val)\n        return root\n    \n    def minValueNode(node):\n        current = node\n        while current.left:\n            current = current.left\n        return current\n    \n    leaves = []\n    deleteNode(root, node_val)\n    inorder(root, leaves)\n    return leaves\n\n[/Code 2]\n\n[Asserts 2]\n\n# Create tree nodes\nroot = TreeNode(5)\nroot.left = TreeNode(3)\nroot.right = TreeNode(7)\nroot.left.left = TreeNode(2)\nroot.left.right = TreeNode(4)\nroot.right.left = TreeNode(6)\nroot.right.right = TreeNode(8)\nassert deleteNodeAndTraverse(root, 3) == [2, 4, 5, 6, 7, 8]\nroot = TreeNode(5)\nroot.left = TreeNode(3)\nroot.right = TreeNode(7)\nroot.left.left = TreeNode(2)\nroot.left.right = TreeNode(4)\nroot.right.left = TreeNode(6)\nroot.right.right = TreeNode(8)\nassert deleteNodeAndTraverse(root, 5) == [2, 3, 4, 6, 7, 8]\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.815}, {"few_shot_keywords": "['transformation', 'geometry', 'union', 'combinations', '2D', 'coordinates', 'parallelogram', 'bottom-right']", "test_keywords": "['transformation', 'combinations', 'class', 'geometry', 'coordinates', 'parallelogram', 'median']", "prompt_tokens": 667, "total_tokens": 982, "completion_tokens": 315, "completion": "[Question 2]\n\nCreate a class representing a 2D parallelogram. Implement a method to calculate and return the coordinates of the median of the parallelogram.\n\n[/Question 2]\n\n[Code 2]\n\nclass Parallelogram:\n    def __init__(self, coordinates):\n        self.coordinates = coordinates\n\n    def calculateMedian(self):\n        x_values = [point[0] for point in self.coordinates]\n        y_values = [point[1] for point in self.coordinates]\n        median_x = (max(x_values) + min(x_values)) / 2\n        median_y = (max(y_values) + min(y_values)) / 2\n        return [median_x, median_y]\n\n[/Code 2]\n\n[Asserts 2]\n\nparallelogram = Parallelogram([[0, 0], [1, 1], [1, 0], [2, 1]])\nassert parallelogram.calculateMedian() == [1.0, 0.5]\n\nparallelogram = Parallelogram([[2, 3], [5, 7], [7, 4], [4, 0]])\nassert parallelogram.calculateMedian() == [3.5, 3.5]\n\nparallelogram = Parallelogram([[-1, -1], [1, 1], [2, 0], [0, -2]])\nassert parallelogram.calculateMedian() == [0.5, 0.0]\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.786}, {"few_shot_keywords": "['rectangle', 'inside', 'coordinates', 'point', 'even level', 'form', 'non-decreasing', 'power', 'geometry']", "test_keywords": "['reachable', 'rectangle', 'root', 'promotion', 'point', 'geometry', 'inside', 'coordinates', 'vertices', 'boolean values']", "prompt_tokens": 576, "total_tokens": 894, "completion_tokens": 318, "completion": "[Question 2]\n\nGiven a rectangle represented by its bottom-left and top-right coordinates, and a point with coordinates (x, y), write a function to determine if the point is reachable from the root of the rectangle. The root of the rectangle is defined as the bottom-left vertex. The function should return a boolean value: True if the point is reachable, and False if it is not reachable from the root of the rectangle.\n\n[/Question 2]\n\n[Code 2]\n\ndef isPointReachableFromRoot(x1: int, y1: int, x2: int, y2: int, x: int, y: int) -> bool:\n    if (x >= x1 and x <= x2 and y >= y1 and y <= y2):\n        return True\n    else:\n        return False\n\n[/Code 2]\n\n[Asserts 2]\n\nassert isPointReachableFromRoot(1,1,10,8,5,5)==True\nassert isPointReachableFromRoot(1,1,10,8,0,0)==True\nassert isPointReachableFromRoot(1,1,10,8,10,8)==False\nassert isPointReachableFromRoot(1,1,10,8,1,1)==True\nassert isPointReachableFromRoot(1,1,10,8,10,10)==False\nassert isPointReachableFromRoot(-5,-5,5,5,0,0)==True\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.736}, {"few_shot_keywords": "['divide', 'elements', 'straight lines', 'pieces', 'pizza', 'cuts', 'center', 'function', 'obstacle', 'OR', 'radius', 'circumference', 'QuickSort', 'maximum']", "test_keywords": "['diagonals', 'cuts', 'function', 'pieces', 'center', 'pizza', 'arrays', 'straight lines', 'maximum', 'radius', 'divide', 'free', 'pop', 'circumference', 'top-left']", "prompt_tokens": 539, "total_tokens": 701, "completion_tokens": 162, "completion": "[Question 2]\n\nYou are given a square pizza of radius r. Write a function `maxPizzaDiagonals` to find the maximum number of diagonals that can be drawn in the pizza. The diagonals should start from the center and end at the circumference. \n\n[/Question 2]\n\n[Code 2]\n\ndef maxPizzaDiagonals(radius: int) -> int:\n    return radius * (radius - 1) // 2\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maxPizzaDiagonals(3) == 3\nassert maxPizzaDiagonals(4) == 6\nassert maxPizzaDiagonals(5) == 10\nassert maxPizzaDiagonals(6) == 15\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.806}, {"few_shot_keywords": "['dfs', 'point', 'distance', 'tree traversal', 'inscribed', 'minimize', '2D plane', 'median', 'coordinates']", "test_keywords": "['median', 'minimize', 'distance', '2D plane', 'point', 'coordinates', 'recursive', 'cells']", "prompt_tokens": 572, "total_tokens": 1003, "completion_tokens": 431, "completion": "[Question 2]\n\nGiven a 2D grid representing cells with different values, write a recursive function to find the point at which the sum of distances to all other points is minimized. The point should be the median of all the points in the grid.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\ndef minTotalDistance(grid: List[List[int]]) -> float:\n    points = []\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:  # assuming 1 represents a point\n                points.append((i, j))\n\n    xcoords = [p[0] for p in points]\n    xcoords.sort()\n    median_x = xcoords[len(xcoords) // 2]\n    ycoords = [p[1] for p in points]\n    ycoords.sort()\n    median_y = ycoords[len(ycoords) // 2]\n\n    total_distance = 0\n    for p in points:\n        total_distance += abs(p[0] - median_x) + abs(p[1] - median_y)\n\n    return float(total_distance)\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minTotalDistance([[1,0,0],[0,0,0],[0,0,1]])==2.0\nassert minTotalDistance([[1,0,0,0,0],[0,0,0,0,0],[0,0,0,0,1]])==4.0\nassert minTotalDistance([[1,0,0],[0,0,0],[0,0,0],[0,0,0],[0,0,0],[0,0,0],[0,0,0],[0,0,1]])==6.0\nassert minTotalDistance([[1,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,1]])==4.0\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.94}, {"few_shot_keywords": "['segments', 'array', 'covered', 'open', 'directed acyclic', 'gcd', 'buying', 'sort', 'point', 'length', 'union', 'prev']", "test_keywords": "['sort', 'prev', 'union', 'covered', 'array', 'segments', 'length', 'difference', 'open', 'average']", "prompt_tokens": 575, "total_tokens": 879, "completion_tokens": 304, "completion": "[Question 2]\n\nYou are given an array of segments. Find the average length covered by the union of the segments.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\ndef averageLengthOfSegmentsUnion(segments: List[List[int]]) -> float:\n    points = []\n    for s in segments:\n        points.append((s[0], 'l'))\n        points.append((s[1], 'r'))\n    points.sort(key=lambda x: (x[0], x[1]))\n    open_segments = 0\n    total_length = 0\n    prev = -1\n    for point, event in points:\n        if open_segments and prev != -1:\n            total_length += point - prev\n        if event == 'l':\n            open_segments += 1\n        else:\n            open_segments -= 1\n        prev = point\n    union_length = total_length / 2\n    return union_length\n\n[/Code 2]\n\n[Asserts 2]\n\nassert averageLengthOfSegmentsUnion([[1, 3], [2, 5], [6,7]]) == 5.0\nassert averageLengthOfSegmentsUnion([[1, 3], [3, 4], [5, 7]]) == 3.0\nassert averageLengthOfSegmentsUnion([[1, 3], [3, 4], [5, 7],[2,7]]) == 3.0\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.871}, {"few_shot_keywords": "['permutation', 'negative numbers', 'iteration', 'non-matching', 'diagonal pattern', 'search', 'array', 'missing', 'numbers', 'vowels', 'conditions', 'duplicate', 'sentence']", "test_keywords": "['search', 'missing', 'permutation', 'power', 'duplicate', 'product', 'array', 'negative numbers', 'left pointer', 'numbers', 'inorder', 'iteration']", "prompt_tokens": 602, "total_tokens": 846, "completion_tokens": 244, "completion": "[Question 2]\n\nYou are given an array of integers and a target number. Write a function to find if there are two numbers in the array whose product is equal to the target number. If such a pair is found, return True; otherwise, return False.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\ndef findProductPair(arr: List[int], target: int) -> bool:\n    seen = set()\n    for num in arr:\n        if num == 0 and target == 0:\n            continue\n        if target % num == 0 and target // num in seen:\n            return True\n        seen.add(num)\n    return False\n\n[/Code 2]\n\n[Asserts 2]\n\nassert findProductPair([10, 2, 4, 6], 24) == True\nassert findProductPair([3, 5, 7, 9], 15) == True\nassert findProductPair([4, 8, 12, 16], 100) == False\nassert findProductPair([2, 0, 4, 6], 0) == True\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.714}, {"few_shot_keywords": "['sort', 'frequency', 'coordinates', 'integer', 'flips', 'top-left', 'constant', 'modulo', 'rearrange', 'array', 'validity']", "test_keywords": "['array', 'integer', 'validity', 'modulo', 'sufficient subset', 'frequency', 'constant', 'function', 'calculation', 'rearrange', 'outside', 'difference']", "prompt_tokens": 613, "total_tokens": 926, "completion_tokens": 313, "completion": "[Question 2]\n\nYou are given an array of integers. Write a function to find if there exists a subset of the array such that the absolute difference between the sum of the subset and a given integer K is more than a constant value C. If such a subset exists, return True, otherwise return False.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\ndef existsSubsetWithDifference(arr: List[int], K: int, C: int) -> bool:\n    n = len(arr)\n    freq = {}\n    freq[0] = 1\n    prefix_sum = 0\n    \n    for num in arr:\n        prefix_sum = (prefix_sum + num) % K\n        required_prefix = (prefix_sum - C + K) % K\n        if required_prefix in freq:\n            return True\n        freq[prefix_sum] = 1\n        \n    return False\n\n[/Code 2]\n\n[Asserts 2]\n\nassert existsSubsetWithDifference([3, 7, 2, 1, 4], 6, 3)==True\nassert existsSubsetWithDifference([1, 2, 3, 4, 5], 10, 2)==True\nassert existsSubsetWithDifference([2, 4, 6, 8, 10], 9, 4)==False\nassert existsSubsetWithDifference([5, 8, 11, 3, 6], 12, 2)==True\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.944}, {"few_shot_keywords": "['range', 'array', 'indices', 'value', 'pieces', 'count', 'vowels', 'update', 'inclusive', 'partition', 'query', 'parent', 'deletions']", "test_keywords": "['array', 'count', 'line', 'bottom-right', 'range', 'angles', 'update', 'value', 'indices', 'sufficient subset', 'inclusive', 'query']", "prompt_tokens": 686, "total_tokens": 1042, "completion_tokens": 356, "completion": "[Question 2]\n\nYou are given a 2D array representing a grid of values. Each cell in the grid contains a value. You need to write a function that can efficiently answer Q queries of the form: \"Given a line with a bottom-right angle, find the count of values within the range of angles that form a sufficient subset of the given array\".\n\nWrite a function that takes the 2D array and a list of queries, and returns the count of values within the range of angles for each query.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef countValuesInAngles(grid: List[List[int]], queries: List[List[int]]) -> List[int]:\n    def isSufficientSubset(subset: List[int]) -> bool:\n        # Check if the subset meets the criteria for sufficiency\n        # For example, the sum of the subset is greater than a certain value\n        pass\n    \n    def valuesInAngle(grid: List[List[int]], bottomRight: List[int]) -> List[int]:\n        # Calculate the count of values within the range of angles from the bottomRight point\n        pass\n    \n    result = []\n    for query in queries:\n        result.append(valuesInAngle(grid, query))\n    return result\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countValuesInAngles([[1, 2, 3], [4, 5, 6], [7, 8, 9]], [[1, 1]]) == [4]\nassert countValuesInAngles([[1, 2, 3], [4, 5, 6], [7, 8, 9]], [[0, 0]]) == [1]\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.775}, {"few_shot_keywords": "['boolean', 'parent', 'logic', 'sum', 'candies', 'bags', 'empty', 'triplets', 'left child', 'select', 'max', 'function', 'integers']", "test_keywords": "['logic', 'bags', 'parent', 'candies', 'boolean', 'function', 'stack', 'empty', 'comparison', 'game', 'select', 'integers', 'max', 'source', 'sum']", "prompt_tokens": 601, "total_tokens": 991, "completion_tokens": 390, "completion": "[Question 2]\n\nYou are working on a game involving candies and bags. The game consists of a stack of bags, each containing a certain number of candies. Your task is to write a function `maxCandiesInStack` that takes in a list of integers representing the number of candies in each bag and returns the maximum number of candies that can be obtained by selecting and emptying bags according to the following logic: you can select two candies from any of the bags, and one candy from each of the remaining bags. \n\nWrite a function `maxCandiesInStack` to return the maximum number of candies that can be obtained by following the given logic.\n\n[/Question 2]\n\n[Code 2]\n\ndef maxCandiesInStack(bags: List[int]) -> int:\n    bags.sort()\n    n = len(bags)\n    return sum(bags[:n//3])\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maxCandiesInStack([1, 2, 3, 4, 5, 6, 7, 8, 9]) == 18\nassert maxCandiesInStack([5, 2, 7, 4, 6, 9, 8, 3, 1]) == 18\nassert maxCandiesInStack([1, 1, 1, 2, 2, 2, 3, 3, 3]) == 6\nassert maxCandiesInStack([3, 3, 3, 3, 3, 3, 3, 3, 3]) == 9\nassert maxCandiesInStack([6, 6, 6, 6, 6, 6, 6, 6, 6]) == 18\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.808}, {"few_shot_keywords": "['iteration', 'maximum', 'array', 'comparison', 'possibility', 'right', 'left', 'intersect', 'divisors', 'range', 'indices', 'class', 'matchsticks']", "test_keywords": "['left', 'maximum', 'cost', 'range', 'comparison', 'array', 'indices', 'right', 'two pointers', 'iteration']", "prompt_tokens": 766, "total_tokens": 1154, "completion_tokens": 388, "completion": "[Question 2]\n\nYou are given an array of integers representing the cost of each item in a store. You are also given a maximum cost. The task is to find the maximum range of items (indices) such that the sum of the costs of these items does not exceed the maximum cost.\n\nWrite a function to find the maximum range of items that can be purchased within the given maximum cost.\n\n[/Question 2]\n\n[Code 2]\n\ndef maximumRangeItems(costs: list, maxCost: int) -> tuple:\n    left = 0\n    right = 0\n    maxRange = 0\n    curCost = 0\n    n = len(costs)\n    while right < n:\n        curCost += costs[right]\n        while curCost > maxCost:\n            curCost -= costs[left]\n            left += 1\n        if right - left > maxRange:\n            maxRange = right - left\n            rangeIndices = (left, right)\n        right += 1\n    return rangeIndices\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maximumRangeItems([2, 5, 8, 4, 3, 9, 6], 15) == (0, 3)\nassert maximumRangeItems([1, 2, 3, 4, 5], 11) == (0, 4)\nassert maximumRangeItems([7, 8, 3, 2, 6, 1, 4, 5], 18) == (0, 5)\nassert maximumRangeItems([5, 4, 3, 2, 1], 6) == (0, 2)\nassert maximumRangeItems([1, 1, 1, 1, 1], 4) == (0, 3)\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.838}, {"few_shot_keywords": "['count', 'divisors', 'limited range', 'math', 'source', 'number', 'bitwise', 'odd level', 'longest', 'integer']", "test_keywords": "['divisors', 'longest path', 'math', 'count', 'integer', 'product', 'number']", "prompt_tokens": 536, "total_tokens": 909, "completion_tokens": 373, "completion": "[Question 2]\n\nYou are given an array of integers. You need to find the longest path in the array such that the product of all the elements in the path is a perfect square.\n\nWrite a function to find the length of the longest path satisfying this condition.\n\n```python\ndef longestPathWithPerfectSquareProduct(arr: List[int]) -> int:\n    # Your code here\n```\n\n[/Question 2]\n\n[Code 2]\n\nfrom math import sqrt\n\ndef isPerfectSquare(n):\n    return (int(sqrt(n)) ** 2 == n)\n\ndef longestPathWithPerfectSquareProduct(arr: List[int]) -> int:\n    length = 0\n    for i in range(len(arr)):\n        product = 1\n        for j in range(i, len(arr)):\n            product *= arr[j]\n            if isPerfectSquare(product):\n                length = max(length, j - i + 1)\n    return length\n\n[/Code 2]\n\n[Asserts 2]\n\nassert longestPathWithPerfectSquareProduct([2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31]) == 3\nassert longestPathWithPerfectSquareProduct([4, 6, 8, 10, 12, 14, 16, 18, 20]) == 9\nassert longestPathWithPerfectSquareProduct([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == 2\nassert longestPathWithPerfectSquareProduct([1, 4, 9, 6, 8, 2, 3, 5, 12, 7, 15]) == 6\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.842}, {"few_shot_keywords": "['string', 'maximum', 'pizza', 'sort', 'source', 'integer', 'digits', 'formation', 'appending', 'concatenate']", "test_keywords": "['digits', 'Exclusive Or', 'maximum', 'sort', 'integer', 'house', 'string', 'bitwise operations', 'concatenate']", "prompt_tokens": 518, "total_tokens": 753, "completion_tokens": 235, "completion": "[Question 2]\n\nGiven a list of non-negative integers, the task is to sort the list in such a way that the numbers are arranged to form the largest number. Using bitwise operations, create a function to find the maximum number that can be formed by concatenating the integers in the list.\n\n[/Question 2]\n\n[Code 2]\n\ndef bitwiseMaxNumber(nums: List[int]) -> int:\n    nums = map(str, nums)\n    nums.sort(key=lambda x: x*3, reverse=True)\n    res = int(''.join(nums))\n    return res\n\n[/Code 2]\n\n[Asserts 2]\n\nassert(bitwiseMaxNumber([3, 30, 34, 5, 9])) == 9534330\nassert(bitwiseMaxNumber([10, 2])) == 210\nassert(bitwiseMaxNumber([0, 0, 0, 0])) == 0\nassert(bitwiseMaxNumber([5, 50, 56])) == 56550\nassert(bitwiseMaxNumber([420, 42, 423])) == 42423420\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.816}, {"few_shot_keywords": "['diagonal pattern', 'numbers', 'join', 'queue', 'binary tree', 'bitwise operations', 'substitutions', 'conditions', 'bends', 'compression']", "test_keywords": "['queue', 'power', 'diagonal pattern', 'angle', 'multiples', 'bitwise operations', 'valid', 'compression', 'binary tree']", "prompt_tokens": 555, "total_tokens": 916, "completion_tokens": 361, "completion": "[Question 2]\n\nGiven a binary tree, write a function to determine if the tree has a valid diagonal pattern. A valid diagonal pattern is one where the difference in power of the left and right subtrees at each level is a multiple of a given angle.\n\n[/Question 2]\n\n[Code 2]\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef isValidDiagonalPattern(root: TreeNode, angle: int) -> bool:\n    queue = [root]\n    level = 0\n    left_power = 0\n    right_power = 0\n    while queue:\n        size = len(queue)\n        for _ in range(size):\n            node = queue.pop(0)\n            if level % 2 == 0:\n                left_power += node.val ** level\n            else:\n                right_power += node.val ** level\n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n        if level % 2 != 0 and (abs(left_power - right_power) % angle != 0):\n            return False\n        level += 1\n    return True\n\n[/Code 2]\n\n[Asserts 2]\n\n# Create a sample binary tree\n#        1\n#       / \\\n#      2   3\n#     / \\ / \\\n#    4  5 6  7\nroot = TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(5)), TreeNode(3, TreeNode(6), TreeNode(7)))\nassert isValidDiagonalPattern(root, 2)==True\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.72}, {"few_shot_keywords": "['sum', 'radius', 'brute force', 'arrays', 'coordinate', 'nested loops', 'XOR', 'bitwise', 'consecutive sequence', 'middle row']", "test_keywords": "['bitwise', 'sum', 'XOR', 'brute force', 'semi-major axis', 'iteration', 'arrays', 'nested loops']", "prompt_tokens": 491, "total_tokens": 686, "completion_tokens": 195, "completion": "[Question 2]\n\nYou are given an array of integers representing the semi-major axis of elliptical orbits. Write a function to calculate the bitwise XOR sum of all possible pairs of semi-major axis values.\n\n[/Question 2]\n\n[Code 2]\n\ndef bitwiseXORSumSemiMajorAxis(arr):\n    result = 0\n    n = len(arr)\n    for i in range(n):\n        for j in range(i+1, n):\n            result += arr[i] ^ arr[j]\n    return result\n\n[/Code 2]\n\n[Asserts 2]\n\nassert bitwiseXORSumSemiMajorAxis([3, 6, 9, 12]) == 42\nassert bitwiseXORSumSemiMajorAxis([5, 10, 15]) == 40\nassert bitwiseXORSumSemiMajorAxis([7, 14, 21, 28]) == 98\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.743}, {"few_shot_keywords": "['heap', 'minimize', 'array', 'schedule', 'path sum', 'priority queue', 'cuts', 'time', 'process', 'efficient', 'odd', 'exponentiation']", "test_keywords": "['inscribed', 'minimize', 'array', 'schedule', 'time', 'sentence', 'priority queue', 'process', 'tetrahedron', 'efficient', 'strings', 'AND operation', 'heap']", "prompt_tokens": 625, "total_tokens": 936, "completion_tokens": 311, "completion": "[Question 2]\n\nYou are given a list of sentences, each containing a string of words. Your task is to schedule these sentences on a priority queue such that the total time required to process the sentences is minimized. The priority is based on the number of words in each sentence, with the sentence containing the minimum number of words having the highest priority. Return the scheduled order of sentences based on the priority queue.\n\n[/Question 2]\n\n[Code 2]\n\nimport heapq\ndef scheduleSentences(sentences: List[str]) -> List[str]:\n    pq = []\n    for sentence in sentences:\n        heapq.heappush(pq, (len(sentence.split()), sentence))\n    scheduled_order = []\n    while pq:\n        scheduled_order.append(heapq.heappop(pq)[1])\n    return scheduled_order\n\n[/Code 2]\n\n[Asserts 2]\n\nassert scheduleSentences([\"The sky is blue\", \"An apple a day keeps the doctor away\", \"Keep it simple\"]) == [\"Keep it simple\", \"The sky is blue\", \"An apple a day keeps the doctor away\"]\nassert scheduleSentences([\"A stitch in time saves nine\", \"Beauty is in the eyes of the beholder\", \"Practice makes perfect\"]) == [\"A stitch in time saves nine\", \"Beauty is in the eyes of the beholder\", \"Practice makes perfect\"]\nassert scheduleSentences([\"Look before you leap\", \"Actions speak louder than words\"]) == [\"Look before you leap\", \"Actions speak louder than words\"]\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.817}, {"few_shot_keywords": "['frequency', 'minimum value', 'circumference', 'average', 'binary search tree', 'values', 'BST', 'median', 'even', 'inorder traversal', 'nodes', 'sorting', 'range']", "test_keywords": "['inorder traversal', 'median', 'even', 'BST', 'sorting', 'range', 'increase', 'longest path', 'nodes', 'values', 'binary search tree', 'depth first search', 'condition', 'average']", "prompt_tokens": 723, "total_tokens": 1298, "completion_tokens": 575, "completion": "[Question 2]\n\nYou are given a Binary Search Tree (BST) and you need to find the longest path in the tree such that the values of the nodes in the path are in increasing order. If the length of the path is even, you are required to find the median value of the nodes in the path.\n\n[/Question 2]\n\n[Code 2]\n\n# Node definition for the BST\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef longestIncreasingPath(root: TreeNode) -> float:\n    def dfs(node, prev_val, length):\n        nonlocal max_length\n        if not node:\n            return\n        if node.val > prev_val:\n            length += 1\n        else:\n            length = 1\n        max_length = max(max_length, length)\n        dfs(node.left, node.val, length)\n        dfs(node.right, node.val, length)\n\n    max_length = 0\n    dfs(root, float('-inf'), 0)\n    return max_length\n\ndef medianOfValues(values: list) -> float:\n    values.sort()\n    n = len(values)\n    if n % 2 == 0:\n        return (values[n // 2 - 1] + values[n // 2]) / 2\n    else:\n        return values[n // 2]\n\ndef longestIncreasingPathMedian(root: TreeNode) -> float:\n    def dfs(node, path_values):\n        nonlocal max_median\n        if not node:\n            return\n        path_values.append(node.val)\n        if node.left and node.left.val > path_values[-1]:\n            dfs(node.left, path_values[:])\n        if node.right and node.right.val > path_values[-1]:\n            dfs(node.right, path_values[:])\n        if len(path_values) % 2 == 0:\n            path_median = medianOfValues(path_values)\n            max_median = max(max_median, path_median)\n\n    max_median = float('-inf')\n    dfs(root, [])\n    return max_median\n\n[/Code 2]\n\n[Asserts 2]\n\n# Test cases\ntree1 = TreeNode(5, TreeNode(3, TreeNode(2), TreeNode(4)), TreeNode(7, right=TreeNode(8)))\ntree2 = TreeNode(10, TreeNode(5), TreeNode(15, TreeNode(13), TreeNode(20)))\ntree3 = TreeNode(50, TreeNode(30, TreeNode(20), TreeNode(40)), TreeNode(70, TreeNode(60), TreeNode(80)))\nassert longestIncreasingPath(tree1) == 3\nassert longestIncreasingPathMedian(tree2) == 10.5\nassert longestIncreasingPath(tree3) == 4\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.729}, {"few_shot_keywords": "['pairs', 'math', 'integer', 'insert', 'array', 'conditional', 'loop', 'count', 'valid', 'range', 'matrix', 'iteration', 'divisible']", "test_keywords": "['value', 'math', 'iteration', 'range', 'integer', 'keypad', 'count', 'pairs', 'divisible', 'adjacent', 'loop']", "prompt_tokens": 502, "total_tokens": 731, "completion_tokens": 229, "completion": "[Question 2]\n\nYou are given a keypad with digits 0-9. Given an integer n, find the count of all pairs of adjacent digits in the range of [1, n] such that the sum of the pair is divisible by 3.\n\nWrite a function to find the count of such pairs.\n\n[/Question 2]\n\n[Code 2]\n\ndef countDivisiblePairs(n):\n    keypad = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n    count = 0\n    for i in range(1, n):\n        pair_sum = keypad[i] + keypad[i+1]\n        if pair_sum % 3 == 0:\n            count += 1\n    return count\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countDivisiblePairs(5) == 1\nassert countDivisiblePairs(10) == 3\nassert countDivisiblePairs(20) == 6\nassert countDivisiblePairs(15) == 4\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.78}, {"few_shot_keywords": "['greedy', 'boxes', 'arrays', 'remainder', 'closest', 'sorting', 'two pointers', 'sum', 'integer', 'brute force']", "test_keywords": "['arrays', 'matrix', 'sorting', 'profit', 'two pointers', 'sum', 'integer', 'closest', 'greedy', 'input', 'removal', 'largest']", "prompt_tokens": 679, "total_tokens": 966, "completion_tokens": 287, "completion": "[Question 2]\n\nGiven an array of integers representing the prices of a stock on different days, write a function to find the maximum profit that can be obtained by performing at most one transaction, where a transaction consists of buying the stock on one day and selling it on a later day.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef maxProfit(prices: List[int]) -> int:\n    if not prices:\n        return 0\n    max_profit = 0\n    min_price = prices[0]\n    for i in range(1, len(prices)):\n        if prices[i] < min_price:\n            min_price = prices[i]\n        else:\n            max_profit = max(max_profit, prices[i] - min_price)\n    return max_profit\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maxProfit([7,1,5,3,6,4])==5\nassert maxProfit([7,6,4,3,1])==0\nassert maxProfit([3, 2, 6, 5, 0, 3])==4\nassert maxProfit([2, 4, 1])==2\nassert maxProfit([3, 9, 3, 1, 7, 5, 3, 6, 8, 4, 8])==7\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.71}, {"few_shot_keywords": "['visible', 'graph', 'DFS', 'accessible', 'tree', 'nodes', 'undirected', 'closest', 'operations']", "test_keywords": "['sides', 'graph', 'relative', 'nodes', 'operations', 'undirected', 'tree', 'DFS', 'accessible', 'QuickSort']", "prompt_tokens": 599, "total_tokens": 1052, "completion_tokens": 453, "completion": "[Question 2]\n\nYou are given an undirected graph with N nodes and M edges. Each node represents a city and each edge represents a road between two cities. The cost of each road is the absolute difference between the populations of the two cities it connects. You are also given a city and you need to find the relative order of all other cities in terms of their populations, from closest to farthest, from the given city.\n\n[/Question 2]\n\n[Code 2]\n\nclass Graph:\n\n\tdef __init__(self, V: int) -> None:\n\t\tself.V = V\n\t\tself.adj = [[] for i in range(self.V)]\n\t\t\n\tdef addEdge(self, u: int, v: int, w: int) -> None:\n\t\tself.adj[u].append((v, w))\n\t\tself.adj[v].append((u, w))\n\t\t\n\tdef relativeOrder(N: int, city: int) -> List[int]:\n\t\tdist = [float('inf') for i in range(N)]\n\t\tdist[city] = 0\n\t\tvisited = [False for i in range(N)]\n\t\tq = []\n\t\tq.append(city)\n\t\tvisited[city] = True\n\t\twhile q:\n\t\t\tu = q.pop(0)\n\t\t\tfor v, w in self.adj[u]:\n\t\t\t\tif not visited[v]:\n\t\t\t\t\tdist[v] = dist[u] + w\n\t\t\t\t\tvisited[v] = True\n\t\t\t\t\tq.append(v)\n\t\tdist.pop(city)\n\t\tdist.sort()\n\t\treturn dist\n\n[/Code 2]\n\n[Asserts 2]\n\ng = Graph(4)\ng.addEdge(0, 1, 10)\ng.addEdge(1, 2, 5)\ng.addEdge(2, 3, 8)\nassert g.relativeOrder(4, 0)==[5, 8, 10]\ng2 = Graph(5)\ng2.addEdge(0, 1, 20)\ng2.addEdge(1, 2, 15)\ng2.addEdge(2, 3, 12)\ng2.addEdge(3, 4, 25)\nassert g2.relativeOrder(5, 3)==[15, 20, 25]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.797}, {"few_shot_keywords": "['binary', 'bitwise', 'diagonals', 'AND operation', 'middle row', 'middle column', 'concatenation', 'matrix', 'factorial', 'list', 'nodes', 'power', 'divide']", "test_keywords": "['diagonals', 'middle row', 'matrix', 'product', 'concatenation', 'bitwise', 'area', 'AND operation', 'palindromic', 'middle column', 'binary']", "prompt_tokens": 830, "total_tokens": 1330, "completion_tokens": 500, "completion": "[Question 2]\n\nYou are given a binary matrix of size N * N. Write a function to calculate the product of the elements on the diagonals, middle row, and middle column of the matrix. The function should then check if the bitwise AND of these products is a palindromic number.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef isBitwiseAndPalindromic(matrix: List[List[int]]) -> bool:\n    N = len(matrix)\n    middle = N // 2\n    diagProduct = 1\n    middleRowProduct = 1\n    middleColProduct = 1\n    for i in range(N):\n        for j in range(N):\n            if i == j or i+j == N-1:\n                diagProduct *= matrix[i][j]\n            if i == middle:\n                middleRowProduct *= matrix[i][j]\n            if j == middle:\n                middleColProduct *= matrix[i][j]\n    bitwiseAnd = diagProduct & middleRowProduct & middleColProduct\n    return str(bitwiseAnd) == str(bitwiseAnd)[::-1]\n\n[/Code 2]\n\n[Asserts 2]\n\nassert isBitwiseAndPalindromic([[1, 0, 1], [0, 1, 0], [1, 0, 1]]) == True\nassert isBitwiseAndPalindromic([[1, 1, 1], [1, 1, 1], [1, 1, 1]]) == False\nassert isBitwiseAndPalindromic([[1, 0, 0, 1, 1], [0, 1, 1, 0, 1], [1, 0, 1, 1, 0], [1, 1, 0, 1, 0], [0, 1, 1, 1, 1]]) == False\nassert isBitwiseAndPalindromic([[1, 0, 0, 1, 0], [0, 1, 0, 0, 0], [0, 0, 1, 0, 0], [1, 0, 0, 1, 1], [0, 0, 0, 1, 1]]) == True\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.775}, {"few_shot_keywords": "['non-matching', 'boolean', 'divisible', 'recursion', 'tree', 'subsequence', 'root', 'join', 'chessboard', 'sum', 'node', 'leaf', 'construct', 'path']", "test_keywords": "['algorithm', 'path', 'recursive', 'recursion', 'And', 'divisible', 'leaf', 'sum', 'update', 'node', 'tree', 'boolean', 'construct', 'root']", "prompt_tokens": 686, "total_tokens": 1078, "completion_tokens": 392, "completion": "[Question 2]\n\nYou are given a binary tree and a target sum. Write a recursive algorithm to find if there exists a root to leaf path such that the sum of values along the path is equal to the given target sum. Return true if such a path exists, otherwise return false.\n\n[/Question 2]\n\n[Code 2]\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\ndef hasPathSum(root: TreeNode, targetSum: int) -> bool:\n    if not root:\n        return False\n    if not root.left and not root.right and root.val == targetSum:\n        return True\n    targetSum -= root.val\n    return hasPathSum(root.left, targetSum) or hasPathSum(root.right, targetSum)\n\n[/Code 2]\n\n[Asserts 2]\n\n# Test Case 1\n# Construct the tree\n#     5\n#    / \\\n#   4   8\n#  /   / \\\n# 11  13  4\n# /  \\      \\\n# 7   2      1\nroot = TreeNode(5)\nroot.left = TreeNode(4)\nroot.right = TreeNode(8)\nroot.left.left = TreeNode(11)\nroot.left.left.left = TreeNode(7)\nroot.left.left.right = TreeNode(2)\nroot.right.left = TreeNode(13)\nroot.right.right = TreeNode(4)\nroot.right.right.right = TreeNode(1)\nassert hasPathSum(root, 22) == True\n\n# Test Case 2\n# Construct the tree\n#     1\n#    / \\\n#   2   3\nroot = TreeNode(1)\nroot.left = TreeNode(2)\nroot.right = TreeNode(3)\nassert hasPathSum(root, 5) == False\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.72}, {"few_shot_keywords": "['product', 'number', 'node', 'recursive', 'full binary trees', 'nodes', 'combinatorics', 'count', 'factorial', 'math', 'irregular']", "test_keywords": "['full binary trees', 'nodes', 'product', 'ellipse', 'count', 'right child', 'recursive', 'math', 'remainder', 'number', 'preserving order', 'factorial', 'combinatorics']", "prompt_tokens": 550, "total_tokens": 761, "completion_tokens": 211, "completion": "[Question 2]\n\nGiven a number n, representing the count of nodes in a full binary tree, find the number of ways to arrange the nodes such that the product of the values in the right child of each node is a multiple of the number of nodes in a full binary tree and preserving the order of the nodes in the tree.\n\n[/Question 2]\n\n[Code 2]\n\ndef factorial(n: int) -> int:\n    if n == 0:\n        return 1\n    return n * factorial(n-1)\n\ndef countArrangements(n: int) -> int:\n    return factorial(2 * n - 1) % (10**9 + 7)\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countArrangements(3) == 720\nassert countArrangements(4) == 130767425\nassert countArrangements(5) == 222304642\nassert countArrangements(6) == 113208256\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.944}, {"few_shot_keywords": "['diagonal', 'value', 'substring', 'matrix', 'array', 'equal', 'integers', 'minimum', 'prime', 'height', 'positive', 'subtract']", "test_keywords": "['integers', 'sub-trees', 'subtract', 'array', 'minimum', 'prime', 'tetrahedron', 'positive', 'numbers', 'form', 'equal']", "prompt_tokens": 739, "total_tokens": 1296, "completion_tokens": 557, "completion": "[Question 2]\n\nGiven a positive integer array, the task is to find the minimum number of prime numbers that need to be subtracted from the array to form equal sub-arrays. A sub-array is a contiguous part of the original array.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef minPrimeSubtractionForSubArrays(arr: List[int]) -> int:\n    def isPrime(n):\n        if (n <= 1):\n            return False\n        for i in range(2, n):\n            if (n % i) == 0:\n                return False\n        return True\n\n    def countEqualSubArraysWithMinPrime(arr, x):\n        res = 0\n        curr_xor = 0\n        mp = {}\n        for i in range(len(arr)):\n            curr_xor ^= arr[i]\n            if (curr_xor == x):\n                res += 1\n            if ((curr_xor ^ x) in mp):\n                res += mp[(curr_xor ^ x)]\n            mp[curr_xor] = mp.get(curr_xor, 0) + 1\n        return res\n\n    Max = max(arr)\n    Min = min(arr)\n    b = Max - Min + 1\n    primes = []\n    prime = []\n    for i in range(b):\n        primes.append(True)\n    p = 2\n    while (p * p <= b):\n        if (primes[p] == True):\n            for i in range(p * p, b, p):\n                primes[i] = False\n        p += 1\n    for p in range(2, b):\n        if (primes[p] == True):\n            prime.append(p)\n\n    res = float('inf')\n    for i in range(len(prime)):\n        res = min(res, len(arr) - countEqualSubArraysWithMinPrime(arr, prime[i]))\n    return res\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minPrimeSubtractionForSubArrays([1, 2, 3, 4, 5, 6]) == 1\nassert minPrimeSubtractionForSubArrays([5, 7, 9, 11, 13]) == 0\nassert minPrimeSubtractionForSubArrays([10, 20, 30, 40, 50, 60]) == 2\nassert minPrimeSubtractionForSubArrays([3, 5, 8, 13, 21, 34]) == 1\nassert minPrimeSubtractionForSubArrays([1, 3, 5, 6, 8, 10, 12]) == 2\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.918}, {"few_shot_keywords": "['order', 'node', 'occurrence', 'unique', 'concatenation', 'even numbers', 'array', 'numeric', 'digits']", "test_keywords": "['angle', 'occurrence', 'axis', 'order', 'unique', 'concatenation', 'digits', 'even level', 'array']", "prompt_tokens": 584, "total_tokens": 792, "completion_tokens": 208, "completion": "[Question 2]\n\nGiven a tree represented as an array, where each element represents the angle of rotation at that node, the task is to determine the unique angles occurring at even levels of the tree.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef uniqueAnglesAtEvenLevels(tree: List[int]) -> List[int]:\n    level = 0\n    unique_angles = set()\n    for angle in tree:\n        if level % 2 == 0:\n            unique_angles.add(angle)\n        level += 1\n    return list(unique_angles)\n\n[/Code 2]\n\n[Asserts 2]\n\nassert uniqueAnglesAtEvenLevels([90, 180, 270, 360, 45, 30, 15, 60, 120]) == [90, 270, 45, 15]\nassert uniqueAnglesAtEvenLevels([90, 180, 90, 270, 180, 360]) == [90, 270, 360]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.827}, {"few_shot_keywords": "['count', 'set bits', 'DFS', 'bit manipulation', 'parent-child', 'array', 'source', 'sum']", "test_keywords": "['array', 'node', 'construct', 'set bits', 'sum', 'bit manipulation', 'count', 'divisible', 'nearest']", "prompt_tokens": 561, "total_tokens": 1044, "completion_tokens": 483, "completion": "[Question 2]\n\nYou are given an array of integers. You need to construct a binary tree where each node contains the sum of the set bits count of its corresponding element in the array. Given a target value, find the node in the constructed binary tree whose value is nearest to the target and is also divisible by the target. If no such node exists, return None.\n\n[/Question 2]\n\n[Code 2]\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef countSetBits(num: int) -> int:\n    count = 0\n    while num:\n        count += num & 1\n        num >>= 1\n    return count\n\ndef constructBinaryTree(arr: List[int]) -> TreeNode:\n    def helper(arr, start, end):\n        if start > end:\n            return None\n        mid = (start + end) // 2\n        node = TreeNode(countSetBits(arr[mid]))\n        node.left = helper(arr, start, mid - 1)\n        node.right = helper(arr, mid + 1, end)\n        return node\n    \n    arr.sort()\n    return helper(arr, 0, len(arr) - 1)\n\ndef findNearestDivisibleNode(root: TreeNode, target: int) -> TreeNode:\n    def dfs(node):\n        if not node:\n            return None\n        if node.val % target == 0:\n            return node\n        left_res = dfs(node.left)\n        right_res = dfs(node.right)\n        if left_res and right_res:\n            return left_res if abs(left_res.val - target) < abs(right_res.val - target) else right_res\n        return left_res or right_res\n    \n    return dfs(root)\n\n[/Code 2]\n\n[Asserts 2]\n\narr = [3, 5, 6, 7, 9, 10, 12, 15]\nroot = constructBinaryTree(arr)\nassert findNearestDivisibleNode(root, 4).val == 6\nassert findNearestDivisibleNode(root, 8) is None\nassert findNearestDivisibleNode(root, 2).val == 6\nassert findNearestDivisibleNode(root, 3).val == 7", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.74}, {"few_shot_keywords": "['recursion', 'extend', 'depth-first search', 'straight lines', 'even numbers', 'graph', 'permutations', 'adjacency list', 'count', 'tree', 'subtrees']", "test_keywords": "['count', 'binary tree', 'even numbers', 'depth-first search', 'exponentiation', 'subtrees', 'graph', 'adjacency list', 'tree', 'recursion', 'closest', 'sqrt']", "prompt_tokens": 684, "total_tokens": 1070, "completion_tokens": 386, "completion": "[Question 2]\n\nGiven a binary tree with N nodes and an array of N integers, each representing the value of a node in the binary tree, the task is to find the count of subtrees in the given binary tree with an even sum of all node values.\n\n[/Question 2]\n\n[Code 2]\n\nclass Node:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef countSubtreesWithEvenSum(root: Node) -> int:\n    def dfs(node, count):\n        if node is None:\n            return 0\n        left_sum = dfs(node.left, count)\n        right_sum = dfs(node.right, count)\n        current_sum = node.value + left_sum + right_sum\n        count[0] += current_sum % 2 == 0\n        return current_sum\n    \n    count = [0]\n    dfs(root, count)\n    return count[0]\n\n[/Code 2]\n\n[Asserts 2]\n\nroot = Node(1)\nroot.left = Node(2)\nroot.right = Node(3)\nroot.left.left = Node(4)\nroot.left.right = Node(5)\nassert countSubtreesWithEvenSum(root) == 3\n\nroot = Node(2)\nroot.left = Node(3)\nroot.right = Node(4)\nroot.left.left = Node(6)\nroot.left.right = Node(8)\nroot.right.left = Node(5)\nassert countSubtreesWithEvenSum(root) == 4\n\nroot = Node(5)\nroot.left = Node(2)\nroot.right = Node(7)\nroot.left.left = Node(3)\nroot.left.right = Node(6)\nroot.right.left = Node(4)\nroot.right.right = Node(9)\nassert countSubtreesWithEvenSum(root) == 5\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.938}, {"few_shot_keywords": "['visible', 'inorder', 'insert', 'min value', 'binary tree', 'tree', 'node', 'traversal', 'successor', 'search', 'pair']", "test_keywords": "['min value', 'arrangement', 'traversal', 'insert', 'ord', 'product', 'binary tree', 'node', 'inorder', 'successor', 'tree', 'search', 'hexagon']", "prompt_tokens": 696, "total_tokens": 1027, "completion_tokens": 331, "completion": "[Question 2]\n\nGiven a binary tree, write a function to find the product of the minimum value in the tree and the number of nodes in the tree. Consider that the arrangement of the nodes in the tree can affect the min value and the number of nodes.\n\n[/Question 2]\n\n[Code 2]\n\nclass TreeNode:\n    def __init__(self, key):\n        self.left = None\n        self.right = None\n        self.val = key\n    \ndef insert(root, key):\n    if root is None:\n        return TreeNode(key)\n    else:\n        if root.val < key:\n            root.right = insert(root.right, key)\n        else:\n            root.left = insert(root.left, key)\n    return root\n\ndef minValueNode(node):\n    current = node\n    while current.left is not None:\n        current = current.left\n    return current.val\n\ndef countNodes(root):\n    if root is None:\n        return 0\n    return 1 + countNodes(root.left) + countNodes(root.right)\n\ndef minValAndNodeCountProduct(root):\n    if root is None:\n        return 0\n    minimum_val = minValueNode(root)\n    node_count = countNodes(root)\n    return minimum_val * node_count\n\n[/Code 2]\n\n[Asserts 2]\n\nroot = None\nroot = insert(root, 5)\ninsert(root, 3)\ninsert(root, 8)\ninsert(root, 1)\ninsert(root, 4)\ninsert(root, 7)\ninsert(root, 9)\nassert minValAndNodeCountProduct(root) == 28\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.937}, {"few_shot_keywords": "['house', 'min value', 'order', 'root', 'value', 'distance', 'index', 'node', 'edges', 'binary tree', 'game']", "test_keywords": "['value', 'edges', 'binary tree', 'root', 'node', 'index', 'maximum', 'angles', 'distance']", "prompt_tokens": 661, "total_tokens": 943, "completion_tokens": 282, "completion": "[Question 2]\n\nWrite a function to find the maximum distance between any two nodes in a binary tree. The distance between two nodes is the number of edges on the path between them. Your task is to return the maximum distance between any two nodes in the given binary tree.\n\n[/Question 2]\n\n[Code 2]\n\n# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def diameterOfBinaryTree(self, root: TreeNode) -> int:\n        self.max_distance = 0\n        \n        def depth(node):\n            if not node:\n                return 0\n            left_depth = depth(node.left)\n            right_depth = depth(node.right)\n            self.max_distance = max(self.max_distance, left_depth + right_depth)\n            return 1 + max(left_depth, right_depth)\n        \n        depth(root)\n        return self.max_distance\n\n[/Code 2]\n\n[Asserts 2]\n\n# Creating the binary tree\nroot = TreeNode(1)\nroot.left = TreeNode(2)\nroot.right =  TreeNode(3)\nroot.left.left = TreeNode(4)\nroot.left.right = TreeNode(5)\nassert Solution().diameterOfBinaryTree(root) == 3\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.884}, {"few_shot_keywords": "['input', 'triangle', 'schedule', 'phone', 'compression', 'node', 'left pointer', 'binary tree', 'tree nodes', 'parent pointers', 'right sibling', 'list of nodes']", "test_keywords": "['update', 'tree nodes', 'list of nodes', 'binary tree', 'node', 'subset', 'left pointer', 'tree', 'right sibling', 'parent pointers', 'mapping']", "prompt_tokens": 697, "total_tokens": 1247, "completion_tokens": 550, "completion": "[Question 2]\n\nYou are given a binary tree with parent pointers and a list of nodes. The task is to update the nodes in the tree with a mapping from the given list of nodes.\n\nEach node in the binary tree has a value, a left pointer, a right pointer, and a parent pointer. The mapping is a subset of nodes in the list of nodes.\n\nWrite a function to update the binary tree nodes based on the given mapping.\n\n[/Question 2]\n\n[Code 2]\n\nclass TreeNode:\n    def __init__(self, x: int):\n        self.value = x\n        self.left = None\n        self.right = None\n        self.parent = None\n\ndef updateNodes(root: TreeNode, mapping: list):\n    if not root or not mapping:\n        return\n    \n    queue = [root]\n    while queue:\n        node = queue.pop(0)\n        if node.value in mapping:\n            mapping.remove(node.value)\n        if node.left:\n            queue.append(node.left)\n        if node.right:\n            queue.append(node.right)\n\n    for value in mapping:\n        new_node = TreeNode(value)\n        # Assign the new node to the first available position in the tree\n        assignNode(root, new_node)\n\ndef assignNode(root, new_node):\n    if not root:\n        return\n    if not root.left:\n        root.left = new_node\n        new_node.parent = root\n    elif not root.right:\n        root.right = new_node\n        new_node.parent = root\n    else:\n        assignNode(root.left, new_node)\n\n[/Code 2]\n\n[Asserts 2]\n\n# Create tree nodes\nnode1 = TreeNode(1)\nnode2 = TreeNode(2)\nnode3 = TreeNode(3)\nnode4 = TreeNode(4)\nnode5 = TreeNode(5)\nnode6 = TreeNode(6)\n# Link nodes together\nnode1.left = node2\nnode1.right = node3\nnode2.parent = node1\nnode3.parent = node1\nnode2.left = node4\nnode2.right = node5\nnode4.parent = node2\nnode5.parent = node2\nnode3.right = node6\nnode6.parent = node3\n# Given list of nodes\nmapping = [7, 8, 9]\nupdateNodes(node1, mapping)\nassert node5.right.value == 7  # Node 7 is mapped to the right of node 5\nassert node6.left.value == 8  # Node 8 is mapped to the left of node 6\nassert node4.left.value == 9  # Node 9 is mapped to the left of node 4\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.795}, {"few_shot_keywords": "['comparison', 'distinct', 'binary tree', 'ranges', 'minimum value', 'right', 'maximum value', 'left', 'node', 'recursion']", "test_keywords": "['angle', 'minimum value', 'node', 'binary tree', 'appending', 'maximum value', 'comparison', 'recursion', 'left', 'limited range', 'right', 'profit']", "prompt_tokens": 663, "total_tokens": 1009, "completion_tokens": 346, "completion": "[Question 2]\n\nYou are given a binary tree where each node represents the price of a stock on a particular day. Write a Python function to find the maximum profit that can be made by buying and selling the stock. The buying and selling should be done within a limited range of days represented by the nodes.\n\n[/Question 2]\n\n[Code 2]\n\nclass Node:\n    def __init__(self, key):\n        self.data = key\n        self.left = None\n        self.right = None\n\ndef maxProfitInRange(root, start, end) -> int:\n    if root is None:\n        return 0\n    if start <= root.data <= end:\n        return max(root.data - start, 0) + maxProfitInRange(root.left, start, root.data) + maxProfitInRange(root.right, root.data, end)\n    elif root.data < start:\n        return maxProfitInRange(root.right, start, end)\n    else:\n        return maxProfitInRange(root.left, start, end)\n\n[/Code 2]\n\n[Asserts 2]\n\n# Test case for finding maximum profit within a limited range\nroot = Node(5)\nroot.left = Node(3)\nroot.right = Node(8)\nroot.left.left = Node(1)\nroot.left.right = Node(4)\nroot.right.left = Node(6)\nroot.right.right = Node(10)\nassert maxProfitInRange(root, 3, 9) == 7  # Buy at 3, sell at 10 for max profit\nassert maxProfitInRange(root, 1, 5) == 2  # Buy at 3, sell at 5 for max profit\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.8}, {"few_shot_keywords": "['parent pointers', 'obstacle', 'leaves', 'recursion', 'doubly linked list', 'preserving order', 'binary tree', 'pointer manipulation', 'steps', '2D', 'game']", "test_keywords": "['inclusive', 'recursion', 'preserving order', 'binary tree', 'pointer manipulation', 'nearest', 'time', 'depth', 'leaves', 'consecutive', 'doubly linked list']", "prompt_tokens": 757, "total_tokens": 1214, "completion_tokens": 457, "completion": "[Question 2]\n\nGiven a binary tree, write a function to find the nearest consecutive leaves at the same depth and return the time taken to reach from the given node to the nearest consecutive leaf, preserving the order.\n\n[/Question 2]\n\n[Code 2]\n\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.left = None\n        self.right = None\n\ndef timeToNearestConsecutiveLeaf(root, node):\n    def findConsecutiveLeaf(node, depth):\n        if not node:\n            return float('inf'), None, 0\n        if not node.left and not node.right:\n            return depth, node, 0\n        leftDepth, leftLeaf, leftTime = findConsecutiveLeaf(node.left, depth + 1)\n        rightDepth, rightLeaf, rightTime = findConsecutiveLeaf(node.right, depth + 1)\n        \n        if leftDepth == rightDepth:\n            return leftDepth, node, min(leftTime, rightTime)\n        \n        if leftDepth < rightDepth:\n            return leftDepth, leftLeaf, leftTime + 1\n        else:\n            return rightDepth, rightLeaf, rightTime + 1\n\n    return findConsecutiveLeaf(root, 0)\n\n[/Code 2]\n\n[Asserts 2]\n\n# Sample Test Case 1\nroot = Node(1)\nroot.left = Node(2)\nroot.right = Node(3)\nroot.left.left = Node(4)\nroot.left.right = Node(5)\nroot.right.right = Node(6)\nassert timeToNearestConsecutiveLeaf(root, root.left.right) == (2, root.left.right, 0)\n# Sample Test Case 2\nroot = Node(8)\nroot.left = Node(3)\nroot.right = Node(10)\nroot.left.left = Node(1)\nroot.left.right = Node(6)\nroot.left.right.left = Node(4)\nroot.left.right.right = Node(7)\nroot.right.right = Node(14)\nroot.right.right.left = Node(13)\nassert timeToNearestConsecutiveLeaf(root, root.left.right.left) == (2, root.left.right.left, 1)\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.759}, {"few_shot_keywords": "['Exclusive Or', 'traverse', 'maximum value', 'boolean', 'reachable', 'vertices', 'matrix', 'neighboring', 'conditions', 'cells', 'initial']", "test_keywords": "['arrangement', 'representation', 'vertices', 'conditions', 'boolean', 'traverse', 'matrix', 'initial', 'neighboring', 'prime factors', 'subset', 'cells']", "prompt_tokens": 683, "total_tokens": 1169, "completion_tokens": 486, "completion": "[Question 2]\n\nGiven a boolean 2D matrix representing the arrangement of cells, write a function to find all subsets of neighboring cells that satisfy the conditions:\n\n- The subset should contain at least two cells.\n- The product of the values in the subset should be equal to the sum of the prime factors of the initial value.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef findSubsets(matrix: List[List[bool]]) -> List[List[List[int]]]:\n    def prime_factors(n):\n        factors = []\n        divisor = 2\n        while divisor <= n:\n            if n % divisor == 0:\n                factors.append(divisor)\n                n = n // divisor\n            else:\n                divisor += 1\n        return factors\n    \n    subsets = []\n    rows, cols = len(matrix), len(matrix[0])\n    for i in range(rows):\n        for j in range(cols):\n            if matrix[i][j]:\n                neighbors = []\n                if i > 0 and matrix[i-1][j]:\n                    neighbors.append((i-1, j))\n                if j > 0 and matrix[i][j-1]:\n                    neighbors.append((i, j-1))\n                if neighbors:\n                    subsets.append(neighbors)\n    return subsets\n\n[/Code 2]\n\n[Asserts 2]\n\nassert findSubsets([[True, False, True], [False, True, False], [True, False, True]]) == [[[(0, 0), (0, 2)], [(0, 0), (2, 0)], [(2, 0), (2, 2)], [(0, 2), (2, 2)]]]\nassert findSubsets([[False, True, False], [True, False, True], [False, True, False]]) == []\nassert findSubsets([[True, True, True], [True, True, True], [True, True, True]]) == []\nassert findSubsets([[True, False, True], [True, False, True], [True, False, True]]) == [[[(0, 0), (0, 2)], [(0, 0), (2, 0)], [(2, 0), (2, 2)], [(0, 2), (2, 2)]]]\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.724}, {"few_shot_keywords": "['source node', 'tree', 'depth first search', 'modulo', 'graph traversal', 'BFS', 'level', 'comparison', 'breadth first search', 'circumcircle', 'nodes', 'odd level']", "test_keywords": "['level', 'root', 'source node', 'coordinates', 'graph traversal', 'input', 'BFS', 'nodes', 'breadth first search', 'tree', 'operations', 'plane']", "prompt_tokens": 711, "total_tokens": 1140, "completion_tokens": 429, "completion": "[Question 2]\n\nYou are given a tree with N nodes, each node representing a point in a 2D plane with coordinates (x, y). The root of the tree is the source node. Implement a function to perform breadth-first search (BFS) traversal on the tree and return the coordinates of each node at each level starting from the root node.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List, Tuple, Optional\nfrom collections import deque\n\nclass TreeNode:\n    def __init__(self, val: Tuple[int, int], children: List['TreeNode'] = None):\n        self.val = val\n        self.children = children if children is not None else []\n\ndef coordinatesOfNodesAtEachLevel(root: Optional[TreeNode]) -> List[List[Tuple[int, int]]]:\n    result = []\n    if not root:\n        return result\n    queue = deque([root])\n\n    while queue:\n        level_coordinates = []\n        for _ in range(len(queue)):\n            node = queue.popleft()\n            level_coordinates.append(node.val)\n            for child in node.children:\n                queue.append(child)\n        result.append(level_coordinates)\n    return result\n\n[/Code 2]\n\n[Asserts 2]\n\n# Example 1\ntree1 = TreeNode((0, 0), [TreeNode((1, 1)), TreeNode((2, 2))])\nassert coordinatesOfNodesAtEachLevel(tree1) == [[(0, 0)], [(1, 1), (2, 2)]]\n\n# Example 2\ntree2 = TreeNode((1, 1), [TreeNode((2, 2), [TreeNode((3, 3)), TreeNode((4, 4)]), TreeNode((5, 5)])])\nassert coordinatesOfNodesAtEachLevel(tree2) == [[(1, 1)], [(2, 2), (5, 5)], [(3, 3), (4, 4)]]\n\n# Example 3\ntree3 = None\nassert coordinatesOfNodesAtEachLevel(tree3) == []\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.884}, {"few_shot_keywords": "['trimming', 'volume', 'reverse', 'string', 'length', 'appending', 'binary', 'palindrome', 'line', 'query']", "test_keywords": "['reverse', 'binary', 'maximum', 'string', 'palindrome', 'trimming', 'length', 'appending', 'child']", "prompt_tokens": 541, "total_tokens": 738, "completion_tokens": 197, "completion": "[Question 2]\n\nGiven a string S, your task is to find the maximum length of a binary string which can be formed by appending the reverse of S to itself while maintaining the palindrome property.\n\nWrite a function to solve this problem.\n\nFor example:\nS = \"101\"\nThe maximum length of the binary string formed by appending the reverse of S to itself is 6 (\"101011\")\n\n[/Question 2]\n\n[Code 2]\n\ndef maxBinaryPalindromeLength(s: str) -> int:\n    rev_s = s[::-1]\n    palindromic_str = s + rev_s\n    return len(palindromic_str)\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maxBinaryPalindromeLength(\"101\") == 6\nassert maxBinaryPalindromeLength(\"1101\") == 8\nassert maxBinaryPalindromeLength(\"111\") == 6\nassert maxBinaryPalindromeLength(\"10\") == 4\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.844}, {"few_shot_keywords": "['graph', 'tree', 'undirected', 'bipartite', 'edges', 'node', 'neighbor', 'change', 'coloring', 'edit distance', 'dfs', 'addition']", "test_keywords": "['bipartite', 'dfs', 'arrays', 'graph', 'coloring', 'parent', 'node', 'neighbor', 'edges', 'undirected', 'addition', 'sides', 'tree']", "prompt_tokens": 735, "total_tokens": 1094, "completion_tokens": 359, "completion": "[Question 2]\n\nGiven an undirected graph, write a function to determine if it is Bipartite, and if so, color the nodes in such a way that no two adjacent nodes have the same color using Depth First Search (DFS).\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\ndef isBipartiteAndColor(graph: List[List[int]]) -> List[int]:\n        n = len(graph)\n        color = [-1] * n\n\n        def bipartite_dfs(node, c):\n            color[node] = c\n            for neighbor in graph[node]:\n                if color[neighbor] == -1:\n                    if not bipartite_dfs(neighbor, 1 - c):\n                        return False\n                elif color[neighbor] == c:\n                    return False\n            return True\n\n        for node in range(n):\n            if color[node] == -1:\n                if not bipartite_dfs(node, 0):\n                    return []\n\n        return color\n\n[/Code 2]\n\n[Asserts 2]\n\nassert isBipartiteAndColor([[1, 3], [0, 2], [1, 3], [0, 2]]) == [0, 1, 0, 1]\nassert isBipartiteAndColor([[1, 2, 3], [0, 2], [0, 1, 3], [0, 2]]) == []\nassert isBipartiteAndColor([[1, 3], [0, 2, 3], [1, 3], [0, 1, 2]]) == [0, 1, 0, 1]\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.829}, {"few_shot_keywords": "['swap', 'counter', 'indexing', 'array', 'sum', 'count', 'empty', 'pair', 'sort', 'steps', 'priority queue', 'remove']", "test_keywords": "['pairs', 'steps', 'pair', 'phone', 'empty', 'sort', 'remove', 'order', 'count', 'length', 'array', 'sum']", "prompt_tokens": 643, "total_tokens": 1033, "completion_tokens": 390, "completion": "[Question 2]\n\nYou are given an array of integers and a target sum. Write a function to find all unique pairs of integers in the array that sum up to the target sum. Return the pairs of numbers in sorted order.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List, Tuple\ndef findPairsWithSum(nums: List[int], target: int) -> List[Tuple[int, int]]:\n    pairs = set()\n    nums.sort()\n    left, right = 0, len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            pairs.add((nums[left], nums[right]))\n            left += 1\n            right -= 1\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return sorted(list(pairs))\n\n[/Code 2]\n\n[Asserts 2]\n\nassert findPairsWithSum([1, 2, 3, 4, 5], 5) == [(1, 4), (2, 3)]\nassert findPairsWithSum([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5], 10) == [(1, 9), (2, 8), (3, 7), (4, 6), (5, 5)]\nassert findPairsWithSum([-1, 0, 1, 2, -1, -4], 0) == [(-1, 1), (-1, 1), (-1, 1), (-1, 1)]\nassert findPairsWithSum([2, 7, 11, 15], 9) == [(2, 7)] \n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.836}, {"few_shot_keywords": "['maximize', 'representation', 'sort', 'matchsticks', 'string', 'array', 'numbers', 'missing', 'sorting', 'indexing']", "test_keywords": "['string', 'sort', 'representation', 'sorting', 'bags', 'numbers', 'transformation', 'array', 'queue', 'matchsticks', 'permutation']", "prompt_tokens": 565, "total_tokens": 870, "completion_tokens": 305, "completion": "[Question 2]\n\nYou are given an array of strings representing numbers. Each number is represented by a string of digits using matchsticks. Now, you need to sort the array based on the number of matchsticks required to represent each number. If two numbers require the same number of matchsticks, then sort them as per their lexicographical order.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\ndef sortMatchstickNumbers(arr: List[str]) -> List[str]:\n    matchsticks = {\n        '0': 6, '1': 2, '2': 5, '3': 5, '4': 4, '5': 5, '6': 6, '7': 3, '8': 7, '9': 6\n    }\n    arr.sort(key=lambda x: (sum(matchsticks[ch] for ch in x), x))\n    return arr\n\n[/Code 2]\n\n[Asserts 2]\n\nassert sortMatchstickNumbers([\"7\", \"3\", \"2\", \"9\", \"10\"]) == [\"2\", \"3\", \"9\", \"7\", \"10\"]\nassert sortMatchstickNumbers([\"23\", \"12\", \"89\", \"45\"]) == [\"12\", \"45\", \"23\", \"89\"]\nassert sortMatchstickNumbers([\"111\", \"777\", \"555\", \"999\"]) == [\"111\", \"555\", \"777\", \"999\"]\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.82}, {"few_shot_keywords": "['sum', 'array', 'pairs', 'form', 'conditional', 'integers', 'set', 'count', 'positive']", "test_keywords": "['integers', 'count', 'directrix', 'sum', 'pairs', 'non-decreasing', 'array', 'bags', 'positive']", "prompt_tokens": 495, "total_tokens": 759, "completion_tokens": 264, "completion": "[Question 2]\n\nYou are given an array of integers. Write a function to count the number of pairs of integers in the array such that their sum is positive and the integers are in non-decreasing order.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef countPositiveSumNonDecreasingPairs(arr: List[int]) -> int:\n    n = len(arr)\n    count = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if arr[i] <= arr[j] and arr[i] + arr[j] > 0:\n                count += 1\n    return count\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countPositiveSumNonDecreasingPairs([-1, 1, 3, 5, 7])==8\nassert countPositiveSumNonDecreasingPairs([-5, -3, -1, 0, 2, 4, 6])==9\nassert countPositiveSumNonDecreasingPairs([2, 2, 2, 2, 2])==10\nassert countPositiveSumNonDecreasingPairs([-3, -2, -1, 0, 1, 2, 3])==12\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.746}, {"few_shot_keywords": "['sort', 'path sum', 'segments', 'direction', 'intersect', 'irregular', 'boolean', 'formula', 'ranges', 'array']", "test_keywords": "['array', 'ranges', 'direction', 'paths', 'tree nodes', 'sort', 'circumference', 'intersect', 'boolean', 'non-matching', 'bottom-right']", "prompt_tokens": 722, "total_tokens": 1123, "completion_tokens": 401, "completion": "[Question 2]\n\nYou are given a binary tree with each node containing an integer value. Your task is to write a function to find the sum of all the non-matching bottom-right tree nodes, i.e., the nodes which are not at the bottom-right position of their respective levels. Return the sum of the values of these non-matching nodes.\n\n[/Question 2]\n\n[Code 2]\n\nclass TreeNode:\n    def __init__(self, value=0, left=None, right=None):\n        self.value = value\n        self.left = left\n        self.right = right\n\ndef findNonMatchingSum(root: TreeNode) -> int:\n    queue = [root]\n    nonMatchingSum = 0\n    while queue:\n        levelSize = len(queue)\n        for i in range(levelSize):\n            node = queue.pop(0)\n            if i != levelSize - 1:  # Check if the node is not at the bottom-right position\n                nonMatchingSum += node.value\n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n    return nonMatchingSum\n\n[/Code 2]\n\n[Asserts 2]\n\n# Constructing the binary tree\n#        1\n#       / \\\n#      2   3\n#     / \\   \\\n#    4   5   6\nroot = TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(5)), TreeNode(3, None, TreeNode(6)))\n\nassert findNonMatchingSum(root) == 7  # Non-matching nodes: 1, 2, 3\nassert findNonMatchingSum(TreeNode(1, TreeNode(2), TreeNode(3))) == 1  # Non-matching nodes: 1\nassert findNonMatchingSum(TreeNode(1)) == 0  # No non-matching nodes, so sum is 0\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.859}, {"few_shot_keywords": "['digits', 'sum', 'number', 'impossible', 'integers', 'integer', 'bit manipulation', 'smallest', 'iteration']", "test_keywords": "['digits', 'sum', 'iteration', 'smallest', 'bitwise operations', 'number', 'bags', 'integer', 'efficient', 'coordinate plane', 'bipartite']", "prompt_tokens": 648, "total_tokens": 907, "completion_tokens": 259, "completion": "[Question 2]\n\nYou are given a list of integers representing the weights of items and the task is to determine the smallest sum of digits of the product of two numbers such that the product is as close as possible to a given target sum.\n\n[/Question 2]\n\n[Code 2]\n\ndef smallestSumOfProductDigits(weights, target_sum):\n    min_diff = float('inf')\n    result = float('inf')\n    for i in range(len(weights)):\n        for j in range(i+1, len(weights)):\n            product = weights[i] * weights[j]\n            digits_sum = sum(int(digit) for digit in str(product))\n            diff = abs(target_sum - digits_sum)\n            if diff < min_diff or (diff == min_diff and product < result):\n                min_diff = diff\n                result = product\n    return result\n\n[/Code 2]\n\n[Asserts 2]\n\nweights = [2, 3, 4, 5, 6]\nassert smallestSumOfProductDigits(weights, 10) == 6\nassert smallestSumOfProductDigits(weights, 15) == 12\nassert smallestSumOfProductDigits(weights, 20) == 20\nassert smallestSumOfProductDigits(weights, 25) == 20", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.745}, {"few_shot_keywords": "['integers', 'on', 'optimization', 'maximum value', 'greedy', 'array', 'minimum', 'constant', 'triplets', 'removal', 'circle', 'sorting']", "test_keywords": "['minimum', 'array', 'rectangle', 'promotion', 'minimize', 'negative numbers', 'removal', 'integers', 'optimization', 'greedy', 'sorting', 'non-decreasing']", "prompt_tokens": 607, "total_tokens": 950, "completion_tokens": 343, "completion": "[Question 2]\n\nGiven an array of integers, the task is to find the minimum number of elements to be removed in order to minimize the difference between the maximum and minimum value in a subarray of non-decreasing integers.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef minElementsToRemoveRectangle(arr: List[int]) -> int:\n    n = len(arr)\n    left = [0] * n\n    right = [0] * n\n    for i in range(n):\n        left[i] = max(0, arr[i] - i)\n        right[i] = max(0, arr[i] - (n - 1 - i))\n\n    right_max = [0] * n\n    right_max[n - 1] = right[n - 1]\n    for i in range(n - 2, -1, -1):\n        right_max[i] = max(right[i], right_max[i + 1])\n\n    res = n - 1\n    for i in range(n - 1):\n        res = min(res, left[i] + right_max[i + 1])\n\n    return res\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minElementsToRemoveRectangle([3, 2, 1, 2, 3])==2\nassert minElementsToRemoveRectangle([5, 3, 6, 2, 5])==3\nassert minElementsToRemoveRectangle([1, 2, 3, 4, 5])==0\nassert minElementsToRemoveRectangle([5, 4, 3, 2, 1])==4\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.943}, {"few_shot_keywords": "['lambda', 'even', 'extend', 'modulo', 'value', 'sort', 'dictionary', 'character', 'ASCII', 'coordinate', 'nodes', 'top-left', 'array']", "test_keywords": "['value', 'modulo', 'keypad', 'palindrome', 'ASCII', 'sort', 'dictionary', 'vertex', 'deletions', 'extend', 'character', 'array']", "prompt_tokens": 656, "total_tokens": 959, "completion_tokens": 303, "completion": "[Question 2]\n\nGiven a dictionary with vertex coordinates as keys and their corresponding values as characters, write a function to delete the palindromic values from the dictionary.\n\n[/Question 2]\n\n[Code 2]\n\ndef deletePalindromicValues(d: Dict[Tuple[int, int], str]) -> Dict[Tuple[int, int], str]:\n    result = {k:v for k,v in d.items() if v != v[::-1]}\n    return result\n\n[/Code 2]\n\n[Asserts 2]\n\nassert deletePalindromicValues({(1,1):'level', (2,2):'hello', (3,3):'noon', (4,4):'world'}) == {(2, 2): 'hello', (4, 4): 'world'}\nassert deletePalindromicValues({(0,0):'madam', (1,1):'bye', (2,2):'civic'}) == {(1, 1): 'bye'}\nassert deletePalindromicValues({(4,4):'wow', (5,5):'radar', (6,6):'code'}) == {(6, 6): 'code'}\nassert deletePalindromicValues({(1,1):'racecar', (2,2):'python', (3,3):'deified'}) == {(2,2):'python'}\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.779}, {"few_shot_keywords": "['prime', 'sorting', 'array', 'division', 'set', 'directrix', 'original numbers', 'math', 'volume', 'middle row', 'preserving order', 'gcd', 'prev']", "test_keywords": "['original numbers', 'set', 'directrix', 'math', 'limit', 'division', 'gcd', 'sorting', 'left child', 'prime', 'array']", "prompt_tokens": 617, "total_tokens": 848, "completion_tokens": 231, "completion": "[Question 2]\n\nGiven an array of integers, write a function to find the largest prime number that can be formed by concatenating the original numbers and preserving the order.\n\n[/Question 2]\n\n[Code 2]\n\ndef is_prime(n):\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef largestPrime(arr):\n    original_numbers = set(arr)\n    original_numbers = sorted(original_numbers)\n    max_prime = -1\n    for num in original_numbers:\n        if is_prime(num) and num > max_prime:\n            max_prime = num\n    return max_prime\n\n[/Code 2]\n\n[Asserts 2]\n\nassert largestPrime([2, 4, 8, 5])==5\nassert largestPrime([10, 15, 7, 60, 45, 9])==7\nassert largestPrime([7, 14, 21, 56, 77])==7\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.783}, {"few_shot_keywords": "['arrangement', 'bipartite', 'paths', 'graph', 'traversal', 'parallelogram', 'conditions', 'BFS', 'adjacency list']", "test_keywords": "['adjacency list', 'traversal', 'tree traversal', 'graph', 'right child', 'paths', 'BFS']", "prompt_tokens": 629, "total_tokens": 1024, "completion_tokens": 395, "completion": "[Question 2]\n\nWrite a Python program to determine whether a given binary tree is a complete binary tree or not. You can represent the binary tree as an adjacency list, and you should use Breadth First Search (BFS) traversal to check the condition.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\nfrom collections import deque\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef isCompleteBinaryTree(graph: List[List[int]], root: TreeNode) -> bool:\n    queue = deque()\n    queue.append(root)\n    while queue:\n        node = queue.popleft()\n        if not node:\n            break\n        queue.append(node.left)\n        queue.append(node.right)\n    while queue and not queue[-1]:\n        queue.pop()\n    return not any(queue)\n\n[/Code 2]\n\n[Asserts 2]\n\n# Construct the binary tree as an adjacency list\ntree = [ [1, 2], [3, 4], [5, 6], [7, None], [None, None], [None, None], [None, None] ]\nroot = TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(5)), TreeNode(3, TreeNode(6)))\nassert isCompleteBinaryTree(tree, root) == True\n\n# Construct an incomplete binary tree as an adjacency list\ntree_incomplete = [ [1, 2], [3, 4], [5, 6], [None, None], [7, None], [None, None], [None, None] ]\nroot_incomplete = TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(5)), TreeNode(3, TreeNode(6)))\nassert isCompleteBinaryTree(tree_incomplete, root_incomplete) == False\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.949}, {"few_shot_keywords": "['rearrange', 'elements', 'heap', 'directrix', 'sort', 'Python', 'even', 'extra', 'array', 'odd', 'ascending']", "test_keywords": "['even', 'odd', 'elements', 'extra', 'construct', 'sort', 'ascending', 'iteration', 'quadrant', 'rearrange', 'steps', 'array', 'nested loops']", "prompt_tokens": 718, "total_tokens": 1070, "completion_tokens": 352, "completion": "[Question 2]\n\nGiven an array of integers, write a Python function to construct a new array where the even elements are arranged in ascending order in the first quadrant and the odd elements are arranged in ascending order in the second quadrant. If there are extra elements, they should be placed in the third quadrant.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\ndef rearrangeQuadrants(arr: List[int]) -> List[int]:\n    even_elements = sorted([x for x in arr if x % 2 == 0])\n    odd_elements = sorted([x for x in arr if x % 2 != 0])\n    result = []\n    for even in even_elements:\n        result.append(even)\n    for odd in odd_elements:\n        result.insert(0, odd)\n    for _ in range(len(even_elements) - len(odd_elements)):\n        result.append(0)  # Placeholder for extra elements\n    return result\n\n[/Code 2]\n\n[Asserts 2]\n\nassert rearrangeQuadrants([2, 5, 3, 8, 7, 4])==[3, 5, 7, 2, 4, 8]\nassert rearrangeQuadrants([11, 4, 6, 9, 2, 1, 8])==[1, 9, 11, 2, 4, 6, 8]\nassert rearrangeQuadrants([10, 6, 7, 3, 5, 2, 12, 9])==[3, 5, 7, 9, 10, 2, 6, 12]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.762}, {"few_shot_keywords": "['decrease', 'operations', 'array', 'graph traversal', 'integer', 'minimum', 'arithmetic progression', 'merging', 'compute', 'increase']", "test_keywords": "['minimum', 'And', 'operations', 'increase', 'tuple', 'array', 'arithmetic progression', 'complexity', 'decrease', 'compute', 'integer']", "prompt_tokens": 654, "total_tokens": 910, "completion_tokens": 256, "completion": "[Question 2]\n\nGiven an array of integers, write a function to compute the minimum number of operations required to increase each element of the array such that it forms an arithmetic progression with a given common difference.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef minIncreaseOperations(arr: List[int], difference: int) -> int:\n    operations = 0\n    for i in range(1, len(arr)):\n        diff = arr[i] - arr[i-1]\n        if diff < difference:\n            operations += difference - diff\n            arr[i] += difference - diff\n    return operations\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minIncreaseOperations([1, 3, 5, 7, 9], 2)==0\nassert minIncreaseOperations([1, 5, 3, 1], 2)==3\nassert minIncreaseOperations([1, 2, 3, 4, 5], 1)==0\nassert minIncreaseOperations([5, 5, 5, 5], 2)==6\nassert minIncreaseOperations([2, 4, 6, 8], 3)==2\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.87}, {"few_shot_keywords": "['average', 'path', 'grid', 'connected', 'distance', 'directrix', '2D', 'cells', 'minimum']", "test_keywords": "['tuple', '2D', 'cells', 'grid', 'OR', 'minimum', 'connected', 'left pointer', 'distance', 'reachable', 'equilateral', 'path']", "prompt_tokens": 800, "total_tokens": 1366, "completion_tokens": 566, "completion": "[Question 2]\n\nYou are given a 2D grid representing a map. Each cell in the grid contains a tuple with two values - the first value represents the distance to the nearest reachable equilateral path on the left, and the second value represents the distance to the nearest reachable equilateral path on the right. Write a function to determine the minimum distance to reach the equilateral path from a given cell.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List, Tuple\n\ndef minDistanceToEquilateralPath(grid: List[List[Tuple[int, int]]], cell: Tuple[int, int]) -> int:\n    n = len(grid)\n    m = len(grid[0])\n    dx = [1,-1,0,0]\n    dy = [0,0,1,-1]\n    q = []\n    dist = [[-1]*m for _ in range(n)]\n\n    q.append((cell[0], cell[1]))\n    dist[cell[0]][cell[1]] = 0\n\n    while q:\n        x, y = q.pop(0)\n        for i in range(4):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < n and 0 <= ny < m and dist[nx][ny] == -1:\n                q.append((nx, ny))\n                dist[nx][ny] = dist[x][y] + 1\n\n    return dist\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minDistanceToEquilateralPath([[(0, 2), (1, 1), (2, 0)], [(1, 0), (0, 1), (1, 2)], [(2, 1), (1, 2), (0, 1)]], (1, 1)) == [[1, 0, 1], [0, 0, 0], [1, 0, 1]]\nassert minDistanceToEquilateralPath([[(0, 2), (1, 1), (2, 0)], [(1, 0), (0, 1), (1, 2)], [(2, 1), (1, 2), (0, 1)]], (2, 2)) == [[2, 1, 0], [1, 0, 1], [0, 1, 2]]\nassert minDistanceToEquilateralPath([[(0, 1), (1, 0)], [(1, 0), (0, 1)]], (0, 0)) == [[0, 1], [1, 2]]\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.728}, {"few_shot_keywords": "['sort', 'cost', 'counter', 'sufficient subset', 'total', 'rules', 'free', 'product', 'prime', 'promotion', 'items', 'maximum']", "test_keywords": "['recursive', 'total', 'sort', 'free', 'promotion', 'items', 'counting', 'rules', 'maximum', 'cost', 'modification', 'counter']", "prompt_tokens": 675, "total_tokens": 1110, "completion_tokens": 435, "completion": "[Question 2]\n\nYou are given a list of items with their prices. Each item has a promotion such that if the total cost of all other items of the same price or lower than the current item is greater than or equal to the current item's cost, the current item is given for free. You need to write a recursive function to calculate the maximum number of items one can obtain for free based on the given promotion rules.\n\nWrite a function maxItemsWithPromotionRecursive(prices: List[int], index: int = 0, total: int = 0) -> int that uses a recursive approach to determine the maximum number of items that can be obtained for free based on the given promotion rules.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\ndef maxItemsWithPromotionRecursive(prices: List[int], index: int = 0, total: int = 0) -> int:\n    if index >= len(prices):\n        return 0\n    without_current_item = maxItemsWithPromotionRecursive(prices, index + 1, total)\n    with_current_item = 0\n    if total >= prices[index]:\n        with_current_item = 1 + maxItemsWithPromotionRecursive(prices, index + 1, total - prices[index])\n    return max(without_current_item, with_current_item)\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maxItemsWithPromotionRecursive([2, 3, 1, 2, 4, 3]) == 5\nassert maxItemsWithPromotionRecursive([1, 1, 1, 1, 1, 1]) == 3\nassert maxItemsWithPromotionRecursive([5, 5, 5, 5, 5]) == 1\nassert maxItemsWithPromotionRecursive([4, 4, 4, 2, 2, 2]) == 4\nassert maxItemsWithPromotionRecursive([3, 2, 1, 3, 2, 1]) == 6\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.822}, {"few_shot_keywords": "['sorting', 'binary representation', 'sort', 'condition', 'lambda', 'counting', 'indices', 'non-decreasing', 'array', 'set bits', 'integer', 'bitwise']", "test_keywords": "['bitwise', 'consecutive sequence', 'sort', 'counting', 'sorting', 'lambda', 'set bits', 'vowels', 'binary representation', 'integer', 'array', 'arrangement', 'divisible', 'non-decreasing']", "prompt_tokens": 794, "total_tokens": 1201, "completion_tokens": 407, "completion": "[Question 2]\n\nGiven an array of strings arr, the task is to sort the elements of the array based on the count of set bits in the binary representation of the length of consecutive sequence of vowels in each string. If two strings have the same number of set bits, then they should be sorted in non-decreasing order of their lengths.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\ndef sortByVowelSequenceLength(arr: List[str]) -> List[str]:\n    # Function to count set bits in x\n    def countSetBits(x):\n        count = 0\n        while x:\n            x &= (x-1)\n            count += 1\n        return count\n\n    # Function to count the length of consecutive sequence of vowels\n    def countVowelSequenceLength(s):\n        vowels = \"aeiou\"\n        max_length = 0\n        curr_length = 0\n        for char in s:\n            if char in vowels:\n                curr_length += 1\n                max_length = max(max_length, curr_length)\n            else:\n                curr_length = 0\n        return max_length\n\n    # Sort the input array based on set bit count and length of vowel sequence\n    arr.sort(key=lambda x: (countSetBits(countVowelSequenceLength(x)), len(x)))\n\n    return arr\n\n[/Code 2]\n\n[Asserts 2]\n\nassert sortByVowelSequenceLength([\"hello\", \"world\", \"programming\", \"is\", \"awesome\"]) == ['is', 'hello', 'world', 'awesome', 'programming']\nassert sortByVowelSequenceLength([\"a\", \"aa\", \"aaa\", \"aaaa\", \"aaaaa\"]) == ['a', 'aa', 'aaa', 'aaaa', 'aaaaa']\nassert sortByVowelSequenceLength([\"alphabet\", \"aeiou\", \"beautiful\", \"sequences\", \"binary\"]) == ['binary', 'alphabet', 'aeiou', 'beautiful', 'sequences']\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.709}, {"few_shot_keywords": "['preserving order', 'doubly linked list', 'count', 'top-left', 'product', 'distance', 'triplets']", "test_keywords": "['subsequence', 'minimize', 'class', 'doubly linked list', 'count', 'segments', 'triplets', 'product', 'full binary trees']", "prompt_tokens": 667, "total_tokens": 1051, "completion_tokens": 384, "completion": "[Question 2]\n\nYou are given a doubly linked list with positive integers. Write a Python class to find and return the minimum number of segments required to form a subsequence of the given list such that the product of each segment forms a full binary tree.\n\n[/Question 2]\n\n[Code 2]\n\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n        self.prev = None\n\nclass DoublyLinkedList:\n    def __init__(self):\n        self.head = None\n        self.tail = None\n\n    def append(self, data):\n        new_node = Node(data)\n        if not self.head:\n            self.head = new_node\n            self.tail = new_node\n        else:\n            new_node.prev = self.tail\n            self.tail.next = new_node\n            self.tail = new_node\n\ndef countSegmentsForFullBinaryTree(dll):\n    current = dll.head\n    segments = 0\n    while current:\n        product = 1\n        while current and product * current.data < 16:  # assuming a full binary tree with maximum value 15\n            product *= current.data\n            current = current.next\n        segments += 1\n    return segments\n\n[/Code 2]\n\n[Asserts 2]\n\ndll = DoublyLinkedList()\ndll.append(2)\ndll.append(3)\ndll.append(2)\ndll.append(4)\ndll.append(4)\ndll.append(5)\ndll.append(1)\ndll.append(3)\nassert countSegmentsForFullBinaryTree(dll) == 4\n\ndll2 = DoublyLinkedList()\ndll2.append(2)\ndll2.append(2)\ndll2.append(2)\ndll2.append(2)\ndll2.append(2)\nassert countSegmentsForFullBinaryTree(dll2) == 1\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.931}, {"few_shot_keywords": "['safe', 'integer', 'operation', 'rearrange', 'array', 'largest number', 'undirected']", "test_keywords": "['integer', 'largest number', 'array', 'rearrange', 'phone', 'full binary trees']", "prompt_tokens": 478, "total_tokens": 723, "completion_tokens": 245, "completion": "[Question 2]\n\nYou are given an array of integers that represent the phone numbers of people. You need to rearrange the array in such a way that the largest number formed by concatenating the phone numbers is obtained.\n\nWrite a function to rearrange the array of phone numbers to obtain the largest possible concatenated number.\n\n[/Question 2]\n\n[Code 2]\n\nfrom functools import cmp_to_key\n\ndef largestNumber(nums):\n    compare = lambda a, b: 1 if a + b < b + a else -1 if a + b > b + a else 0\n    nums = list(map(str, nums))\n    nums.sort(key=cmp_to_key(compare))\n    return str(int(''.join(nums)))\n\n[/Code 2]\n\n[Asserts 2]\n\nassert largestNumber([3, 30, 34, 5, 9])==9534330\nassert largestNumber([3, 30, 34, 5, 9])==9534330\nassert largestNumber([10, 2])==210\nassert largestNumber([2, 100])==2100\nassert largestNumber([0, 0, 0])==0\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.77}, {"few_shot_keywords": "['size', 'boolean values', 'minimum', 'removal', 'sum', 'substrings', 'original numbers', 'count', 'partition', 'limit', 'sides', 'array', 'integer']", "test_keywords": "['left pointer', 'size', 'sum', 'integer', 'count', 'partition', 'minimum', 'array', 'dictionary', 'plane', 'limit']", "prompt_tokens": 644, "total_tokens": 958, "completion_tokens": 314, "completion": "[Question 2]\n\nYou are given an array of integers and a target sum. Write a function to find the minimum size of a contiguous subarray such that the sum is greater than or equal to the target sum. If no such subarray exists, return 0.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef minSubArrayLen(nums: List[int], target: int) -> int:\n    left = 0\n    min_size = float('inf')\n    current_sum = 0\n    for right in range(len(nums)):\n        current_sum += nums[right]\n        while current_sum >= target:\n            min_size = min(min_size, right - left + 1)\n            current_sum -= nums[left]\n            left += 1\n    return min_size if min_size != float('inf') else 0\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minSubArrayLen([2, 3, 1, 2, 4, 3], 7) == 2\nassert minSubArrayLen([1, 4, 4], 4) == 1\nassert minSubArrayLen([1, 1, 1, 1, 1, 1, 1, 1], 11) == 0\nassert minSubArrayLen([1, 1, 1, 1, 1, 1, 1, 1], 7) == 3\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.701}, {"few_shot_keywords": "['center', 'paths', 'sum', 'algorithm', 'source', 'weight', 'destination', 'vertices', 'directed acyclic', 'possible', 'edges', 'graph']", "test_keywords": "['graph', 'longest path', 'bipartite', 'destination', 'dfs', 'suppliers', 'directed acyclic', 'travel', 'source', 'algorithm', 'weight', 'paths', 'edges', 'vertices']", "prompt_tokens": 691, "total_tokens": 1398, "completion_tokens": 707, "completion": "[Question 2]\n\nYou are given a directed acyclic graph (DAG) representing a supply chain network. The vertices represent suppliers, and the edges represent the ability to supply goods from one supplier to another. Each edge has a weight associated with it, representing the distance or cost of transportation. Write a program to find the longest path in the graph that a product can travel from a given source supplier to a destination supplier. Additionally, determine if the graph is bipartite.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List, Tuple\n\ndef longestPathAndBipartite(n: int, edges: List[Tuple[int, int, int]], source: int, destination: int) -> Tuple[int, bool]:\n\tgraph = {i: [] for i in range(n)}\n\t\n\tfor edge in edges:\n\t\tgraph[edge[0]].append((edge[1], edge[2]))\n\t\t\n\tvisited = [False]*n\n\ttopo_order = []\n\t\n\tdef dfs(node):\n\t\tvisited[node] = True\n\t\tfor nbr, wt in graph[node]:\n\t\t\tif not visited[nbr]:\n\t\t\t\tdfs(nbr)\n\t\ttopo_order.append(node)\n\t\n\tfor i in range(n):\n\t\tif not visited[i]:\n\t\t\tdfs(i)\n\t\t\t\n\tdist = [-float('inf')]*n\n\tdist[source] = 0\n\t\n\tfor node in reversed(topo_order):\n\t\tif dist[node] != -float('inf'):\n\t\t\tfor nbr, wt in graph[node]:\n\t\t\t\tdist[nbr] = max(dist[nbr], dist[node] + wt)\n\t\n\tlongest_path = dist[destination]\n\t\n\t# Checking if the graph is bipartite\n\tcolors = [-1]*n\n\tdef bipartiteDFS(node, color):\n\t\tcolors[node] = color\n\t\tfor nbr, wt in graph[node]:\n\t\t\tif colors[nbr] == -1:\n\t\t\t\tif not bipartiteDFS(nbr, 1-color):\n\t\t\t\t\treturn False\n\t\t\telif colors[nbr] == color:\n\t\t\t\treturn False\n\t\treturn True\n\t\n\tbipartite = True\n\tfor i in range(n):\n\t\tif colors[i] == -1:\n\t\t\tbipartite = bipartite and bipartiteDFS(i, 0)\n\t\n\treturn longest_path, bipartite\n\n[/Code 2]\n\n[Asserts 2]\n\nassert longestPathAndBipartite(4, [(0, 1, 1), (0, 2, 2), (1, 3, 3), (2, 3, 4)], 0, 3) == (6, True)\nassert longestPathAndBipartite(3, [(0, 1, 1), (1, 2, 2)], 0, 2) == (3, True)\nassert longestPathAndBipartite(4, [(0, 1, 1), (0, 2, 2), (1, 3, 3), (2, 3, 4)], 0, 1) == (1, True)\nassert longestPathAndBipartite(4, [(0, 1, 1), (1, 2, 2), (2, 3, 3), (3, 0, 4)], 0, 1) == (float('-inf'), False)\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.861}, {"few_shot_keywords": "['array', 'diagonal pattern', 'integers', 'element', 'negative', 'update', 'pairs', 'positive', 'occurrence', 'dictionary', 'cells', 'abs']", "test_keywords": "['integers', 'positive', 'occurrence', 'abs', 'element', 'array', 'pairs', 'dictionary', 'join', 'root to leaf path', 'negative']", "prompt_tokens": 587, "total_tokens": 1021, "completion_tokens": 434, "completion": "[Question 2]\n\nGiven a binary tree, the task is to find all root to leaf paths where the sum of positive integers in each path is equal to the absolute value of the sum of negative integers in that path. Return the paths as a list of strings, where each string represents a path with positive and negative integers joined by a dash.\n\n[/Question 2]\n\n[Code 2]\n\nclass TreeNode:\n    def __init__(self, value=0, left=None, right=None):\n        self.value = value\n        self.left = left\n        self.right = right\n\ndef rootToLeafPaths(node: TreeNode) -> List[str]:\n    def findPaths(node, path, paths):\n        if not node:\n            return\n        path.append(str(node.value))\n        if not node.left and not node.right:\n            pos_sum = sum(int(val) for val in path if int(val) > 0)\n            neg_sum = abs(sum(int(val) for val in path if int(val) < 0))\n            if pos_sum == neg_sum:\n                paths.append('-'.join(path))\n        else:\n            findPaths(node.left, path, paths)\n            findPaths(node.right, path, paths)\n        path.pop()\n\n    if not node:\n        return []\n    paths = []\n    findPaths(node, [], paths)\n    return paths\n\n[/Code 2]\n\n[Asserts 2]\n\nnode = TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(5)), TreeNode(3, TreeNode(-2), TreeNode(-3)))\nassert rootToLeafPaths(node) == ['1-2-4', '1-3--2']\nnode = TreeNode(10, TreeNode(8, TreeNode(3), TreeNode(-5)), TreeNode(2, TreeNode(-2), TreeNode(7)))\nassert rootToLeafPaths(node) == ['10-8-3', '10-8--5']\nnode = TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(-5)), TreeNode(3, TreeNode(-2), TreeNode(-3)))\nassert rootToLeafPaths(node) == ['1-2-4']", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.729}, {"few_shot_keywords": "['edges', 'breadth-first search', 'binary search', 'minimum', 'vertices', 'algorithm', 'divide', 'profit', 'rearrange', 'distance', 'graph']", "test_keywords": "['distance', 'edges', 'isosceles', 'breadth-first search', 'last element', 'vertices', 'graph', 'algorithm', 'minimum']", "prompt_tokens": 696, "total_tokens": 1146, "completion_tokens": 450, "completion": "[Question 2]\n\nGiven a graph with N vertices and M edges, write an algorithm to find the minimum distance from a given vertex to the last element in the graph using breadth-first search (BFS) algorithm. Additionally, identify the vertices that form isosceles triangles with the given vertex.\n\n[/Question 2]\n\n[Code 2]\n\nfrom collections import defaultdict, deque\n\ndef addEdge(adj, u, v):\n    adj[u].append(v)\n    adj[v].append(u)\n\ndef minDistanceToLastBFS(edges, start, n):\n    distance = [-1] * (n + 1)\n    q = deque()\n    q.append(start)\n    distance[start] = 0\n    while q:\n        node = q.popleft()\n        for neighbor in edges[node]:\n            if distance[neighbor] == -1:\n                distance[neighbor] = distance[node] + 1\n                q.append(neighbor)\n    min_distance = distance[-1]\n    return min_distance\n\ndef findIsoscelesTriangles(adj, n, source):\n    isosceles_triangles = []\n    for u in range(1, n + 1):\n        for v in adj[u]:\n            for w in adj[v]:\n                if w in adj[u] and u != v and v != w and u != w:\n                    isosceles_triangles.append((u, v, w))\n    return isosceles_triangles\n\n[/Code 2]\n\n[Asserts 2]\n\nadj = defaultdict(list)\naddEdge(adj, 1, 2)\naddEdge(adj, 2, 3)\naddEdge(adj, 2, 4)\naddEdge(adj, 3, 5)\naddEdge(adj, 4, 5)\naddEdge(adj, 5, 6)\nn = 6\nedges = {}\nfor i in range(1, n + 1):\n    edges[i] = adj[i]\nassert minDistanceToLastBFS(edges, 1, n) == 2\nassert findIsoscelesTriangles(adj, n, 2) == [(3, 4, 5)]\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.943}, {"few_shot_keywords": "['enumerate', 'decrement', 'array', 'cycle', 'binary search', 'half', 'select', 'sort', 'swap', 'integer', 'decrease']", "test_keywords": "['cycle', 'largest', 'array', 'sort', 'binary search', 'integer', 'enumerate', 'swap', 'phone']", "prompt_tokens": 601, "total_tokens": 894, "completion_tokens": 293, "completion": "[Question 2]\n\nWrite a function to find the largest integer in a given array. If the array is not sorted, then sort it using a binary search algorithm. Return the largest integer after sorting the array.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef findLargestAfterSort(arr: List[int]) -> int:\n    def binarySearch(arr, l, r, x):\n        if r >= l:\n            mid = l + (r - l) // 2\n            if arr[mid] == x:\n                return mid\n            elif arr[mid] > x:\n                return binarySearch(arr, l, mid - 1, x)\n            else:\n                return binarySearch(arr, mid + 1, r, x)\n        else:\n            return -1\n    \n    sorted_arr = sorted(arr)\n    largest = sorted_arr[-1]\n    return largest\n\n[/Code 2]\n\n[Asserts 2]\n\nassert findLargestAfterSort([5, 3, 9, 1, 7])==9\nassert findLargestAfterSort([11, 2, 8, 4, 9])==11\nassert findLargestAfterSort([6, 3, 5, 1, 4])==6\nassert findLargestAfterSort([10, 7, 3, 5, 8])==10\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.807}, {"few_shot_keywords": "['halves', 'concatenated', 'different', 'character', 'comparison', 'count', 'prime factors', 'string', 'binary search tree', 'path sum', 'vowels']", "test_keywords": "['round', 'vowels', 'coloring', 'character', 'string', 'different', 'halves', 'update', 'count', 'comparison']", "prompt_tokens": 532, "total_tokens": 795, "completion_tokens": 263, "completion": "[Question 2]\n\nGiven a string s, the task is to update the string by coloring the vowels in the first half of the string. The coloring of vowels can be achieved by rounding each vowel to the nearest vowel in the alphabet. Return the updated string.\n\n[/Question 2]\n\n[Code 2]\n\ndef roundVowels(s: str) -> str:\n    vowels = \"aeiouAEIOU\"\n    first_half = s[:len(s)//2]\n    updated_first_half = \"\"\n    \n    for char in first_half:\n        if char in vowels:\n            if char.lower() in \"aeiou\":\n                updated_first_half += \"a\" if char.islower() else \"A\"\n            else:\n                updated_first_half += \"e\" if char.islower() else \"E\"\n        else:\n            updated_first_half += char\n    \n    return updated_first_half + s[len(s)//2:]\n\n[/Code 2]\n\n[Asserts 2]\n\nassert roundVowels(\"book\")==\"baok\"\nassert roundVowels(\"textbook\")==\"taxtbook\"\nassert roundVowels(\"apple\")==\"apple\"\nassert roundVowels(\"banana\")==\"banana\"\nassert roundVowels(\"AbCdEfGh\")==\"AbCdEfGh\"", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.853}, {"few_shot_keywords": "['counting', 'ascending', 'sorting', 'sequence', 'array', 'accessible', 'non-matching', 'order']", "test_keywords": "['safe', 'sorting', 'counting', 'merging', 'ascending', 'order', 'replacement', 'array', 'concatenated', 'And']", "prompt_tokens": 699, "total_tokens": 1188, "completion_tokens": 489, "completion": "[Question 2]\n\nGiven two sorted arrays arr1 and arr2, write a function to merge them into a single sorted array in ascending order. If there are any non-matching elements in the arrays, replace them with a specific value.\n\n[/Question 2]\n\n[Code 2]\n\ndef mergeArrays(arr1, arr2, replacement_value):\n    merged_arr = []\n    i = 0\n    j = 0\n\n    while i < len(arr1) and j < len(arr2):\n        if arr1[i] < arr2[j]:\n            merged_arr.append(arr1[i])\n            i += 1\n        elif arr1[i] > arr2[j]:\n            merged_arr.append(arr2[j])\n            j += 1\n        else:\n            merged_arr.append(arr1[i])\n            merged_arr.append(arr2[j])\n            i += 1\n            j += 1\n\n    while i < len(arr1):\n        merged_arr.append(arr1[i])\n        i += 1\n\n    while j < len(arr2):\n        merged_arr.append(arr2[j])\n        j += 1\n\n    merged_arr = [replacement_value if x is None else x for x in merged_arr]\n\n    return merged_arr\n\n[/Code 2]\n\n[Asserts 2]\n\nassert mergeArrays([1, 3, 5, 7], [2, 4, 6, 8], 0) == [1, 2, 3, 4, 5, 6, 7, 8]\nassert mergeArrays([1, 3, 5, 7], [3, 4, 6, 8], 0) == [1, 3, 3, 4, 5, 6, 7, 8]\nassert mergeArrays([1, 3, 5, 7], [2, 4, 6, 8], -1) == [1, 2, 3, 4, 5, 6, 7, 8]\nassert mergeArrays([3, 4, 6, 8], [1, 3, 5, 7], -1) == [1, 3, 3, 4, 5, 6, 7, 8]\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.728}, {"few_shot_keywords": "['sort', 'total', 'visible', 'boxes', 'dimensions', 'width', 'maximum', 'height', 'arrangement', 'depth', 'OR']", "test_keywords": "['polygon', 'breadth first search', 'depth', 'boxes', 'sort', 'visible', 'maximum', 'width', 'height', 'arrangement', 'dimensions']", "prompt_tokens": 751, "total_tokens": 1149, "completion_tokens": 398, "completion": "[Question 2]\n\nYou are given a list of polygons' dimensions in the form of (width, height), where each polygon is represented by a unique ID. You need to arrange the polygons in such a way that the maximum number of polygons are visible from the top, where a polygon is visible if no other polygons are covering it.\nWrite a program to sort the polygons based on their dimensions and find the maximum number of visible polygons in the resulting arrangement.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List, Tuple\n\ndef maxVisiblePolygons(polygons: List[Tuple[int, int]]) -> int:\n    polygons.sort(key=lambda x: (x[0], x[1]))\n    n = len(polygons)\n    dp = [1] * n\n    for i in range(n):\n        for j in range(i):\n            if polygons[j][1] < polygons[i][1]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maxVisiblePolygons([(4, 4), (6, 6), (1, 2), (4, 5), (6, 7), (2, 3)]) == 4\nassert maxVisiblePolygons([(1, 1), (2, 3), (6, 5), (7, 6), (6, 7), (4, 4)]) == 6\nassert maxVisiblePolygons([(1, 1), (2, 2), (3, 3), (4, 4), (5, 5)]) == 1\nassert maxVisiblePolygons([(5, 3), (2, 1), (3, 2), (6, 7), (4, 5), (8, 8)]) == 4\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.784}, {"few_shot_keywords": "['array', 'buying', 'cost', 'set bits', 'candy', 'integer', 'maximum', 'same value', 'minimum', 'triplets']", "test_keywords": "['cost', 'list of lists', 'candy', 'array', 'buying', 'integer', 'alphabet', 'prime factors', 'minimum', 'non-matching', 'maximum', 'conditional']", "prompt_tokens": 496, "total_tokens": 708, "completion_tokens": 212, "completion": "[Question 2]\n\nYou are given a list of lists where each inner list represents the cost of candies at different shops. The task is to find the shop with the minimum and maximum cost for buying candies.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List, Tuple\n\ndef findMinMaxCost(candy_shops: List[List[int]]) -> Tuple[int, int]:\n    min_cost = min(min(shop) for shop in candy_shops)\n    max_cost = max(max(shop) for shop in candy_shops)\n    return (min_cost, max_cost)\n\n[/Code 2]\n\n[Asserts 2]\n\nassert findMinMaxCost([[3, 2, 1], [4, 5, 6], [10, 8, 9]]) == (1, 10)\nassert findMinMaxCost([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == (1, 9)\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.895}, {"few_shot_keywords": "['constant', 'consecutive', 'ellipse', 'adjacent', 'integer', 'sorting', 'swaps', 'array', 'path sum']", "test_keywords": "['array', 'swaps', 'integer', 'adjacent', 'polygon', 'consecutive', 'sorting', 'circle']", "prompt_tokens": 561, "total_tokens": 890, "completion_tokens": 329, "completion": "[Question 2]\n\nGiven an array of integers, the task is to find the minimum number of adjacent swaps required to bring all the even integers together in the array. A single swap is allowed to swap two adjacent elements in the array. Write a function to return the minimum number of swaps required.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef minAdjSwaps(arr: List[int]) -> int:\n    even_count = 0\n    for num in arr:\n        if num % 2 == 0:\n            even_count += 1\n    \n    if even_count == 0 or even_count == len(arr):\n        return 0\n    \n    window_sum = sum(arr[:even_count])\n    max_sum = window_sum\n    for i in range(1, len(arr) - even_count + 1):\n        window_sum = window_sum - arr[i - 1] + arr[i + even_count - 1]\n        max_sum = max(max_sum, window_sum)\n    \n    return even_count - max_sum\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minAdjSwaps([3, 7, 6, 9, 5, 11, 3])==1\nassert minAdjSwaps([2, 1, 6, 5, 3, 4])==1\nassert minAdjSwaps([9, 6, 10, 15, 2, 20])==1\nassert minAdjSwaps([5, 17, 100, 11])==0\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.826}, {"few_shot_keywords": "['relative', 'sorting', 'strings', 'half', 'order', 'length', 'graph', 'promotion']", "test_keywords": "['strings', 'size', 'numeric', 'points', 'order', 'relative', 'length', 'sorting']", "prompt_tokens": 459, "total_tokens": 656, "completion_tokens": 197, "completion": "[Question 2]\n\nYou are given a list of strings and each string contains numeric points represented as a string. Write a function to sort the strings based on the numeric points in non-decreasing order. If two strings have the same numeric points, their relative order should remain the same as in the initial list.\n\n[/Question 2]\n\n[Code 2]\n\ndef sortStringsByNumericPoints(strings):\n    return sorted(strings, key=lambda x: int(x))\n\n[/Code 2]\n\n[Asserts 2]\n\nassert sortStringsByNumericPoints([\"10\", \"5\", \"20\", \"15\"]) == [\"5\", \"10\", \"15\", \"20\"]\nassert sortStringsByNumericPoints([\"100\", \"20\", \"300\", \"50\"]) == [\"20\", \"50\", \"100\", \"300\"]\nassert sortStringsByNumericPoints([\"3\", \"2\", \"1\"]) == [\"1\", \"2\", \"3\"]\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.872}, {"few_shot_keywords": "['boolean', 'modulus', 'lexicographically', 'rearrange', 'integer', 'condition', 'even', 'odd', 'list']", "test_keywords": "['even', 'boolean', 'condition', 'size', 'source', 'modulus', 'straight lines', 'integer', 'matrix', 'odd']", "prompt_tokens": 427, "total_tokens": 659, "completion_tokens": 232, "completion": "[Question 2]\n\nGiven a matrix of integers, write a function to rearrange the matrix such that all the even numbers are placed before the odd numbers in each row. The rearranged matrix should maintain the lexicographical order of the elements in each row.\n\n[/Question 2]\n\n[Code 2]\n\ndef rearrangeMatrix(matrix: List[List[int]]) -> List[List[int]]:\n    for row in matrix:\n        row.sort(key=lambda x: (x % 2, x))\n    return matrix\n\n[/Code 2]\n\n[Asserts 2]\n\nassert rearrangeMatrix([[3, 2, 6], [1, 5, 4], [7, 8, 9]]) == [[2, 6, 3], [4, 1, 5], [8, 7, 9]]\nassert rearrangeMatrix([[12, 15, 18], [21, 24, 27], [30, 33, 36]]) == [[12, 18, 15], [24, 21, 27], [30, 36, 33]]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.889}, {"few_shot_keywords": "['ord', 'string', 'update', 'inorder traversal', 'dynamic programming', 'array', 'count', 'distinct', 'subsequence', 'occurrences', 'modulus']", "test_keywords": "['subsequence', 'modulus', 'array', 'circle', 'ord', 'occurrences', 'extra', 'string', 'dynamic programming', 'count', 'distinct']", "prompt_tokens": 553, "total_tokens": 787, "completion_tokens": 234, "completion": "[Question 2]\n\nYou are given an array of non-negative integers nums and a target value k. You need to find the total number of continuous subarrays whose sum equals to k, where the sum of the subarray should be computed modulo k.\n\n[/Question 2]\n\n[Code 2]\n\ndef subarraySum(nums, k):\n\tcount = 0\n\tsums = {0: 1}\n\ttotal_sum = 0\n\tfor num in nums:\n\t\ttotal_sum += num\n\t\tmodulus = total_sum % k\n\t\tif modulus in sums:\n\t\t\tcount += sums[modulus]\n\t\tsums[modulus] = sums.get(modulus, 0) + 1\n\treturn count\n\n[/Code 2]\n\n[Asserts 2]\n\nassert subarraySum([4,5,0,-2,-3,1], 5) == 7\nassert subarraySum([1,2,3], 3) == 2\nassert subarraySum([1,1,1], 2) == 2\nassert subarraySum([2,-4,6], 6) == 1", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.862}, {"few_shot_keywords": "['cost', 'brute force', 'pairs', 'QuickSort', 'partition', 'array', 'sorting', 'optimization', 'complexity', 'leaf', 'tail', 'space', 'recursion', 'call', 'algorithm']", "test_keywords": "['partition', 'stack', 'sorting', 'maximize', 'optimization', 'largest', 'tail', 'schedule', 'call', 'recursion', 'complexity', 'space', 'array', 'QuickSort', 'algorithm', 'circumference']", "prompt_tokens": 755, "total_tokens": 1275, "completion_tokens": 520, "completion": "[Question 2]\n\nYou are given an array of integers representing tasks that need to be scheduled. Implement a function to maximize the task scheduling using QuickSort with Tail Call Optimization and a stack-based partitioning technique to reduce the space complexity. The goal is to find the largest possible number of tasks that can be scheduled without any of them overlapping in execution time.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List, Tuple\n\ndef stack_partition(arr: List[int], low: int, high: int) -> int:\n    pivot = arr[high]\n    i = low-1\n    stack = []\n    stack.append((low, high))\n\n    while stack:\n        low, high = stack.pop()\n        pivot = arr[high]\n        i = low-1\n        for j in range(low, high):\n            if arr[j] < pivot:\n                i += 1\n                arr[i], arr[j] = arr[j], arr[i]\n        arr[i+1], arr[high] = arr[high], arr[i+1]\n        pi = i+1\n\n        if pi-low < high-pi:\n            if low < pi - 1:\n                stack.append((low,pi-1))\n            low = pi+1\n        else:\n            if pi + 1 < high:\n                stack.append((pi+1,high))\n            high = pi - 1\n    \n    return i+1\n\ndef quickSort_maximize(arr: List[int], low: int, high: int) -> int:\n    if low < high:\n        pi = stack_partition(arr,low,high)\n        return max(1 + quickSort_maximize(arr, low, pi-1) + quickSort_maximize(arr, pi+1, high))\n    return 0\n\ndef maximize_task_scheduling(tasks: List[int]) -> int:\n    return quickSort_maximize(tasks, 0, len(tasks)-1)\n\n[/Code 2]\n\n[Asserts 2]\n\ntasks1 = [3, 2, 6, 8, 7, 5]\nassert maximize_task_scheduling(tasks1) == 4\ntasks2 = [1, 4, 2, 5, 8, 7, 6]\nassert maximize_task_scheduling(tasks2) == 5\ntasks3 = [9, 2, 7, 3, 6, 1, 8]\nassert maximize_task_scheduling(tasks3) == 4\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.922}, {"few_shot_keywords": "['compression', 'parallel', 'union', 'unique', 'points', 'coordinate plane', 'directed acyclic', 'axis', 'pair', 'squares']", "test_keywords": "['coordinate plane', 'leaf', 'direction', 'unique', 'axis', 'round', 'binary tree', 'points', 'squares', 'tetrahedron', 'parallel']", "prompt_tokens": 650, "total_tokens": 961, "completion_tokens": 311, "completion": "[Question 2]\n\nGiven a binary tree, write a function to find the number of unique paths from the root to the leaves that form squares in the coordinate plane. Each path should form a square whose sides are parallel to the coordinate axes.\n\nWrite a program to solve the given problem.\n\n[/Question 2]\n\n[Code 2]\n\nclass TreeNode:\n    def __init__(self, value=0, left=None, right=None):\n        self.value = value\n        self.left = left\n        self.right = right\n\ndef countSquarePaths(root: TreeNode) -> int:\n    def countUniquePaths(node, currentPath):\n        if not node:\n            return 0\n        currentPath = currentPath + str(node.value)\n        count = 0\n        if node.left is None and node.right is None:\n            if isSquarePath(currentPath):\n                count += 1\n        count += countUniquePaths(node.left, currentPath)\n        count += countUniquePaths(node.right, currentPath)\n        return count\n    \n    def isSquarePath(path):\n        return len(path) > 1 and int(path)**0.5 == int(int(path)**0.5)\n    \n    return countUniquePaths(root, \"\")\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countSquarePaths(TreeNode(4, TreeNode(16), TreeNode(25)))==2\nassert countSquarePaths(TreeNode(1, TreeNode(4, TreeNode(16), TreeNode(25)), TreeNode(9)))==3\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.742}, {"few_shot_keywords": "['directrix', 'lexicographically', 'subsequence', 'update', 'formation', 'index', 'permutation', 'smallest']", "test_keywords": "['subsequence', 'index', 'lexicographically', 'center', 'circle', 'row', 'permutation', 'formation', 'smallest', 'depth-first search', 'height']", "prompt_tokens": 548, "total_tokens": 964, "completion_tokens": 416, "completion": "[Question 2]\n\nGiven a matrix representing a circle formed by '*' and '.' where '*' represents the boundary and '.' represents the inside of the circle. The task is to find the lexicographically smallest subsequence of the indices (i, j) that form a circle with the center at (x, y) and having the smallest height.\n\n[/Question 2]\n\n[Code 2]\n\ndef isValid(i, j, n, m):\n    return 0 <= i < n and 0 <= j < m\n\ndef dfs(i, j, n, m, mat, visited, circle):\n    visited[i][j] = True\n    circle.append((i, j))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    for dx, dy in directions:\n        x, y = i + dx, j + dy\n        if isValid(x, y, n, m) and not visited[x][y] and mat[x][y] == '*':\n            dfs(x, y, n, m, mat, visited, circle)\n\ndef findSmallestCircle(mat, x, y):\n    n, m = len(mat), len(mat[0])\n    visited = [[False for _ in range(m)] for _ in range(n)]\n    circle = []\n    dfs(x, y, n, m, mat, visited, circle)\n    circle.sort()\n    return circle[0]\n\n[/Code 2]\n\n[Asserts 2]\n\nassert findSmallestCircle([\"*****\",\"*...*\",\"*...*\",\"*...*\",\"*****\"], 2, 2) == (2, 2)\nassert findSmallestCircle([\"*****\",\"*...*\",\"*...*\",\"*...*\",\"*****\"], 1, 1) == (1, 1)\nassert findSmallestCircle([\"*****\",\"*...*\",\"*...*\",\"*...*\",\"*****\"], 3, 3) == (3, 3)", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.777}, {"few_shot_keywords": "['semi-major axis', 'last element', 'array', 'rearrange', 'preserving order', 'remove', 'perfect square', 'iteration']", "test_keywords": "['last element', 'array', 'chessboard', 'remove', 'points', 'perfect square', 'iteration']", "prompt_tokens": 555, "total_tokens": 843, "completion_tokens": 288, "completion": "[Question 2]\n\nYou are given a chessboard represented as an array of arrays where each element represents a point on the board. The task is to remove the points at perfect square indices and return the last element remaining after performing the operations iteratively.\n\n[/Question 2]\n\n[Code 2]\n\ndef lastRemainingChessboard(board):\n    while(len(board)>1):\n        board = [row for idx, row in enumerate(board) if (idx+1)**0.5 % 1 != 0]\n    return board[0][0]\n\n[/Code 2]\n\n[Asserts 2]\n\nchessboard1 = [\n    [1, 2, 3, 4],\n    [5, 6, 7, 8],\n    [9, 10, 11, 12],\n    [13, 14, 15, 16]\n]\nassert lastRemainingChessboard(chessboard1) == 6\n\nchessboard2 = [\n    [1, 2, 3],\n    [4, 5, 6],\n    [7, 8, 9]\n]\nassert lastRemainingChessboard(chessboard2) == 2\n\nchessboard3 = [\n    [1, 2],\n    [3, 4]\n]\nassert lastRemainingChessboard(chessboard3) == 1\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.735}, {"few_shot_keywords": "['line', 'power', 'dynamic programming', 'array', 'color', 'occurrences', 'time', 'impossible', 'minimum', 'node', 'sum', 'travel', 'list of nodes']", "test_keywords": "['pop', 'dynamic programming', 'color', 'time', 'maximize', 'impossible', 'array', 'number', 'node', 'minimum', 'travel', 'line']", "prompt_tokens": 655, "total_tokens": 901, "completion_tokens": 246, "completion": "[Question 2]\n\nYou are given an array of numbers representing the time it takes to pop balloons of a particular color. You have to find the minimum time to pop all the balloons and maximize the total sum of numbers obtained from popping the balloons. If it is impossible to pop all the balloons, return -1.\n\n[/Question 2]\n\n[Code 2]\n\ndef maxCoins(nums):\n\tnums = [1] + nums + [1]\n\tn = len(nums)\n\tdp = [[0]*n for _ in range(n)]\n\tfor k in range(2, n):\n\t\tfor left in range(0, n - k):\n\t\t\tright = left + k\n\t\t\tfor i in range(left+1,right):\n\t\t\t\tdp[left][right] = max(dp[left][right],nums[left]*nums[i]*nums[right]+dp[left][i]+dp[i][right])\n\treturn dp[0][n - 1]\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maxCoins([3,1,5,8])==167\nassert maxCoins([7,8,9,1,2,3])==108\nassert maxCoins([1,3,1,5,8])==70", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.94}, {"few_shot_keywords": "['ascending', 'sorted', 'prime', 'depth first search', 'binary', 'extra', 'unique', 'product', 'subset', 'integer', 'straight lines', 'multiple', 'count', 'safe']", "test_keywords": "['count', 'multiple', 'relative', 'unique', 'sorted', 'product', 'odd level', 'ascending', 'subset', 'integer', 'prime']", "prompt_tokens": 583, "total_tokens": 881, "completion_tokens": 298, "completion": "[Question 2]\n\nGiven a sorted list of unique integers, we need to count the number of subsets whose product is a multiple of a prime number and the subset is at an odd level in the subset tree.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef countOddLevelSubsets(prime: int, arr: List[int]) -> int:\n    def subsetProduct(arr, n, product, index, level, prime):\n        if index == n:\n            if level % 2 != 0 and product % prime == 0:\n                return 1\n            else:\n                return 0\n        return (subsetProduct(arr, n, product * arr[index], index + 1, level + 1, prime) +\n                subsetProduct(arr, n, product, index + 1, level, prime))\n\n    return subsetProduct(arr, len(arr), 1, 0, 0, prime)\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countOddLevelSubsets(2, [1, 2, 3, 4]) == 7\nassert countOddLevelSubsets(3, [1, 2, 3, 4, 5]) == 11\nassert countOddLevelSubsets(5, [1, 2, 3, 4, 5, 6, 7]) == 31\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.751}, {"few_shot_keywords": "['comparison', 'largest', '2D', 'merging', 'width', 'strings', 'quadrant', 'lexicographically', 'products', 'sorting', 'set']", "test_keywords": "['merging', 'strings', 'median', 'sorting', 'prime factors', 'comparison', 'lexicographically', 'largest']", "prompt_tokens": 647, "total_tokens": 1009, "completion_tokens": 362, "completion": "[Question 2]\n\nYou are given an array of strings. Your task is to merge all the strings into a single string and then find the lexicographically largest median string from the merged string array. If the merged string has an even length, the median string is defined as the larger of the two middle strings.\n\n[/Question 2]\n\n[Code 2]\n\ndef mergeAndFindLargestMedianString(stringArray):\n    mergedString = ''.join(stringArray)\n    n = len(mergedString)\n    mergedStringArray = [mergedString[i:j] for i in range(n) for j in range(i+1, n+1)]\n    mergedStringArray.sort()\n    medianIndex = len(mergedStringArray) // 2\n    if len(mergedStringArray) % 2 == 0:\n        medianString1 = mergedStringArray[medianIndex-1]\n        medianString2 = mergedStringArray[medianIndex]\n        return max(medianString1, medianString2)\n    else:\n        return mergedStringArray[medianIndex]\n\n[/Code 2]\n\n[Asserts 2]\n\nassert mergeAndFindLargestMedianString([\"abc\", \"def\", \"ghi\"]) == \"ifghedcba\"\nassert mergeAndFindLargestMedianString([\"abc\", \"def\", \"jkl\", \"mno\"]) == \"onmkljihgfedcba\"\nassert mergeAndFindLargestMedianString([\"aaa\", \"bbb\", \"ccc\"]) == \"cccbbaaa\"\nassert mergeAndFindLargestMedianString([\"abc\", \"acb\", \"bac\", \"cab\"]) == \"cbacbacabc\"\nassert mergeAndFindLargestMedianString([\"a\", \"b\", \"c\", \"d\", \"e\"]) == \"e\"", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.918}, {"few_shot_keywords": "['phone', 'children', 'right sibling', 'conditions', 'space', 'positive', 'distribute', 'division', 'minimum', 'candies']", "test_keywords": "['positive', 'distribute', 'candies', 'minimum', 'conditions', 'children', 'division', 'backtracking', 'split']", "prompt_tokens": 489, "total_tokens": 1071, "completion_tokens": 582, "completion": "[Question 2]\n\nYou have n candies that need to be distributed among k children. Each child must receive at least one candy. Write a function to find the minimum number of ways to distribute the candies among the children, considering the given conditions.\n\nAdditionally, implement a backtracking algorithm to split the candies in all possible ways.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\ndef distributeCandies(n: int, k: int) -> int:\n    if n <= 0 or k <= 0:\n        return 0\n    if k == 1:\n        return 1\n    dp = [[0] * (n + 1) for _ in range(k + 1)]\n    for i in range(1, k + 1):\n        for j in range(1, n + 1):\n            if i == 1:\n                dp[i][j] = 1\n            else:\n                for x in range(0, j + 1):\n                    dp[i][j] += dp[i - 1][j - x]\n    return dp[k][n]\n\ndef splitCandies(n: int, k: int) -> List[List[int]]:\n    result = []\n    def backtrack(remaining, current):\n        if remaining == 0 and len(current) == k:\n            result.append(list(current))\n            return\n        for i in range(1, remaining + 1):\n            if not current or i >= current[-1]:\n                current.append(i)\n                backtrack(remaining - i, current)\n                current.pop()\n    backtrack(n, [])\n    return result\n\n[/Code 2]\n\n[Asserts 2]\n\nassert distributeCandies(7, 3) == 4\nassert distributeCandies(10, 4) == 10\nassert distributeCandies(5, 2) == 6\n\nassert splitCandies(7, 3) == [[1, 1, 5], [1, 2, 4], [1, 3, 3], [2, 2, 3]]\nassert splitCandies(10, 4) == [[1, 1, 1, 7], [1, 1, 2, 6], [1, 1, 3, 5], [1, 1, 4, 4], [1, 2, 2, 5], [1, 2, 3, 4], [1, 3, 3, 3], [2, 2, 2, 4], [2, 2, 3, 3]]\nassert splitCandies(5, 2) == [[1, 4], [2, 3]]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.705}, {"few_shot_keywords": "['selling', 'maximum', 'operations', 'left', 'products', 'subset', 'quantity', 'profit', 'suppliers', 'time complexity']", "test_keywords": "['products', 'quantity', 'repeated', 'selling', 'candy', 'suppliers', 'profit', 'maximum']", "prompt_tokens": 563, "total_tokens": 921, "completion_tokens": 358, "completion": "[Question 2]\n\nYou have been given an array of N (N <= 10^3) integers where each integer represents the quantity of candies of a certain type. You want to sell these candies to K suppliers, and each supplier agrees to buy a certain quantity of a specific type of candy. The suppliers can buy the candies in any order, and they can buy the same type of candy multiple times. Write a function to find the maximum profit you can make by selling the candies to the suppliers.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef maxProfit(candies: List[int], suppliers: List[int]) -> int :\n    candies.sort(reverse=True)\n    suppliers.sort(reverse=True)\n    maxProfit = 0\n    i = 0\n    for supplier in suppliers:\n        if i < len(candies):\n            maxProfit += candies[i] * supplier\n            i += 1\n    return maxProfit\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maxProfit([3, 2, 1, 4, 5], [7, 4, 3])==49\nassert maxProfit([1, 1, 1, 1, 1], [2, 3, 1])==7\nassert maxProfit([5, 5, 5, 5, 5], [1, 2, 3])==35\nassert maxProfit([6, 6, 6, 6, 6], [10, 5, 3])==90\nassert maxProfit([10, 7, 5, 3, 1], [4, 2, 1])==76\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.745}, {"few_shot_keywords": "['characters', 'obstacle', 'edges', 'escape', 'coordinates', 'grid', 'bottom-right', 'OR', 'doubly linked list', 'top-left']", "test_keywords": "['round', 'divisors', 'grid', 'subsequence', 'obstacle', 'indexing', 'escape', 'edges', 'original numbers', 'coordinates', 'bottom-right', 'characters', 'top-left']", "prompt_tokens": 735, "total_tokens": 1266, "completion_tokens": 531, "completion": "[Question 2]\n\nYou are given an n x n grid of positive integers. An \"obstacle\" is represented by the value 0, and other positive integers represent the \"original numbers\". The task is to find the maximum possible round subsequence from any of the top-left to bottom-right corners of the grid. A round subsequence is a subsequence in which each element has at least 3 divisors. The output should be the maximum sum of the elements in the round subsequence.\n\n[/Question 2]\n\n[Code 2]\n\ndef isPrime(n):\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef numDivisors(n):\n    count = 0\n    for i in range(1, n+1):\n        if n % i == 0:\n            count += 1\n    return count\n\ndef maxRoundSubsequence(grid):\n    n = len(grid)\n    dp = [[-1] * n for _ in range(n)]\n    result = 0\n    for i in range(n):\n        for j in range(n):\n            if i==0 and j==0:\n                if grid[i][j] != 0 and isPrime(numDivisors(grid[i][j])):\n                    dp[i][j] = grid[i][j]\n            if i>0:\n                dp[i][j] = max(dp[i][j], dp[i-1][j])\n            if j>0:\n                dp[i][j] = max(dp[i][j], dp[i][j-1])\n            if i>0 and j>0:\n                if grid[i][j] != 0 and isPrime(numDivisors(grid[i][j])):\n                    dp[i][j] = max(dp[i][j], dp[i-1][j-1] + grid[i][j])\n            if i==n-1 and j==n-1:\n                result = dp[i][j]\n    return result\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maxRoundSubsequence([\n  [3, 7, 9],\n  [2, 0, 5],\n  [8, 4, 12]\n])== 35\n\nassert maxRoundSubsequence([\n  [1, 2, 3],\n  [4, 5, 6],\n  [7, 8, 9]\n])== 23\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.893}, {"few_shot_keywords": "['conditions', 'integer', 'array', 'maximize', 'remove', 'frequency', 'compute', 'concatenation', 'multiple', 'non-decreasing', 'sum']", "test_keywords": "['subsequence', 'integer', 'frequency', 'array', 'multiple', 'sum', 'remove', 'maximize', 'process', 'concatenation']", "prompt_tokens": 630, "total_tokens": 939, "completion_tokens": 309, "completion": "[Question 2]\n\nGiven an array of integers, find the maximum sum of a non-decreasing subsequence after removing elements such that the concatenation of the remaining elements is not a multiple of 3.\n\n[/Question 2]\n\n[Code 2]\n\ndef maximizeNonDecreasingSum(arr):\n    n = len(arr)\n    dp = [0] * n\n    dp[0] = arr[0]\n    \n    for i in range(1, n):\n        dp[i] = arr[i]\n        for j in range(i):\n            if arr[i] >= arr[j] and (arr[i] + arr[j]) % 3 != 0:\n                dp[i] = max(dp[i], arr[i] + dp[j])\n    \n    return max(dp)\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maximizeNonDecreasingSum([1, 2, 3, 4, 5, 6]) == 15\nassert maximizeNonDecreasingSum([5, 10, 15, 20, 25, 30]) == 75\nassert maximizeNonDecreasingSum([3, 6, 9, 12]) == 21\nassert maximizeNonDecreasingSum([2, 3, 11, 10, 18, 12]) == 41\nassert maximizeNonDecreasingSum([10, 15, 13, 12, 16, 18]) == 54\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.858}, {"few_shot_keywords": "['recursive', 'picked', 'calculation', 'loop', 'integers', 'array', 'pairs', 'socks', 'logic', 'keypad', 'minimum', 'color', 'frequency', 'count']", "test_keywords": "['picked', 'leaves', 'integers', 'frequency', 'calculation', 'children', 'count', 'pairs', 'minimum', 'directed acyclic', 'color', 'undirected', 'substring', 'socks', 'array']", "prompt_tokens": 659, "total_tokens": 1013, "completion_tokens": 354, "completion": "[Question 2]\n\nGiven a directed acyclic graph that represents a family tree, where each node represents a person and the edges represent the relationship between parent and child, the task is to find the minimum number of leaves that can be picked such that each child has at least K direct ancestors.\n\n[/Question 2]\n\n[Code 2]\n\nfrom collections import defaultdict\n\ndef minLeavesForAncestors(graph: Dict[int, List[int]], K: int) -> int:\n    frequencies = defaultdict(int)\n\n    def dfs(node):\n        if node not in graph:\n            return 1\n        total = sum(dfs(child) for child in graph[node])\n        frequencies[total] += 1\n        return total\n\n    dfs(0)\n\n    sum_leaves = 0\n    for leaves, freq in frequencies.items():\n        sum_leaves += freq\n        K -= freq\n        if K <= 0:\n            return sum_leaves\n    return -1\n\n[/Code 2]\n\n[Asserts 2]\n\ngraph = {0: [1, 2], 1: [3, 4], 2: [5, 6]}\nassert minLeavesForAncestors(graph, 2) == 2\nassert minLeavesForAncestors(graph, 3) == 3\n\ngraph2 = {0: [1, 2], 1: [3, 4], 2: [5, 6], 3: [7, 8]}\nassert minLeavesForAncestors(graph2, 2) == 4\nassert minLeavesForAncestors(graph2, 3) == 4\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.91}, {"few_shot_keywords": "['OR', 'vertex', 'minimum', 'bitwise', 'binary', 'even numbers', 'leaf', 'integer', 'accessible', 'flips']", "test_keywords": "['bitwise', 'OR', 'turns', 'substrings', 'binary', 'minimum', 'integer', 'inorder traversal', 'flips', 'bitwise operations']", "prompt_tokens": 599, "total_tokens": 806, "completion_tokens": 207, "completion": "[Question 2]\n\nGiven a binary string S, the task is to find the minimum number of flips required to convert the given string into a string where every substring of length 2 contains '01' or '10' by performing bitwise OR operations.\n\n[/Question 2]\n\n[Code 2]\n\ndef minFlipsToMakeSubstrGood(S: str) -> int:\n    count = 0\n    for i in range(len(S)-1):\n        if S[i:i+2] != '01' and S[i:i+2] != '10':\n            count += 1\n    return count\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minFlipsToMakeSubstrGood('0101010')==0\nassert minFlipsToMakeSubstrGood('00110011')==2\nassert minFlipsToMakeSubstrGood('111000')==3\nassert minFlipsToMakeSubstrGood('1010101010')==0\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.786}, {"few_shot_keywords": "['bitwise AND', 'array', 'queries', 'factorial', 'tuple', 'list', 'update', 'function', 'calculation', 'steps']", "test_keywords": "['list', 'function', 'ranges', 'tuple', 'calculation', 'multiply', 'bitwise AND', 'elements', 'rearrange', 'queries', 'update', 'array']", "prompt_tokens": 732, "total_tokens": 1384, "completion_tokens": 652, "completion": "[Question 2]\n\nYou are given a list of tuples, each representing a range of elements and a value. Your task is to rearrange the elements of the list based on the calculation of the product of the values within the ranges. Additionally, whenever there are multiple tuples with overlapping ranges, you need to update the value to be the bitwise AND of all the values within the overlapping ranges.\n\nWrite a function that takes the initial list of tuples, rearranges the elements based on the product of values, and updates the values for the overlapping ranges to be their bitwise AND.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List, Tuple\ndef rearrangeAndBitwiseAND(arr: List[Tuple[Tuple[int, int], int]]) -> List[Tuple[Tuple[int, int], int]]:\n    result = []\n    for tup in arr:\n        result.append((tup[0], calculateProduct(tup[0]) if not hasOverlap(arr, tup[0]) else calculateBitwiseAND(arr, tup[0])))\n    result.sort(key=lambda x: x[1])\n    return result\n\ndef calculateProduct(range_tup: Tuple[int, int]) -> int:\n    result = 1\n    for i in range(range_tup[0], range_tup[1]+1):\n        result *= i\n    return result\n\ndef calculateBitwiseAND(arr: List[Tuple[Tuple[int, int], int]], range_tup: Tuple[int, int]) -> int:\n    start, end = range_tup\n    result = arr[0][1]\n    for tup in arr[1:]:\n        if start <= tup[0][1] and end >= tup[0][0]:\n            result = result & tup[1]\n    return result\n\ndef hasOverlap(arr: List[Tuple[Tuple[int, int], int]], range_tup: Tuple[int, int]) -> bool:\n    for tup in arr:\n        if range_tup[0] <= tup[0][1] and range_tup[1] >= tup[0][0]:\n            return True\n    return False\n\n[/Code 2]\n\n[Asserts 2]\n\nassert rearrangeAndBitwiseAND([((2, 4), 3), ((1, 3), 2), ((3, 5), 4)]) == [((1, 3), 2), ((2, 4), 3), ((3, 5), 4)]\nassert rearrangeAndBitwiseAND([((2, 4), 3), ((1, 3), 2), ((3, 5), 4), ((2, 4), 5)]) == [((1, 3), 2), ((3, 5), 4), ((2, 4), 1)]\nassert rearrangeAndBitwiseAND([((1, 2), 3), ((3, 4), 4), ((2, 3), 5)]) == [((1, 2), 3), ((3, 4), 4), ((2, 3), 5)]\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.868}, {"few_shot_keywords": "['process', 'game', 'ranges', 'bitwise', 'distinct', 'candies', 'power', 'permutation', 'binary', 'donate', 'winner', 'round']", "test_keywords": "['binary', 'round', 'game', 'QuickSort', 'condition', 'candies', 'bitwise', 'winner', 'polygon', 'donate', 'power', 'least common ancestor']", "prompt_tokens": 513, "total_tokens": 1022, "completion_tokens": 509, "completion": "[Question 2]\n\nYou are given an array of integers and you need to implement QuickSort to sort the array in non-decreasing order. Additionally, you need to find the least common ancestor of two given nodes in a binary tree.\n\n[/Question 2]\n\n[Code 2]\n\n# QuickSort Implementation\ndef partition(arr, low, high):\n    pivot = arr[high]\n    i = low - 1\n    for j in range(low, high):\n        if arr[j] <= pivot:\n            i = i + 1\n            arr[i], arr[j] = arr[j], arr[i]\n    arr[i + 1], arr[high] = arr[high], arr[i + 1]\n    return i + 1\n\ndef quickSort(arr, low, high):\n    if low < high:\n        pi = partition(arr, low, high)\n        quickSort(arr, low, pi - 1)\n        quickSort(arr, pi + 1, high)\n\n# Least Common Ancestor Implementation\nclass TreeNode:\n    def __init__(self, key):\n        self.left = None\n        self.right = None\n        self.val = key\n\ndef findLCA(root, n1, n2):\n    if root is None:\n        return None\n    if root.val == n1 or root.val == n2:\n        return root\n    left_lca = findLCA(root.left, n1, n2)\n    right_lca = findLCA(root.right, n1, n2)\n    if left_lca and right_lca:\n        return root\n    return left_lca if left_lca is not None else right_lca\n\n[/Code 2]\n\n[Asserts 2]\n\narr = [64, 34, 25, 12, 22, 11, 90]\nquickSort(arr, 0, len(arr) - 1)\nassert arr == [11, 12, 22, 25, 34, 64, 90]\n\nroot = TreeNode(1)\nroot.left = TreeNode(2)\nroot.right = TreeNode(3)\nroot.left.left = TreeNode(4)\nroot.left.right = TreeNode(5)\nroot.right.left = TreeNode(6)\nroot.right.right = TreeNode(7)\nassert findLCA(root, 4, 5).val == 2\nassert findLCA(root, 4, 6).val == 1\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.776}, {"few_shot_keywords": "['bitwise', 'position', 'outside', 'on', 'inside', 'point', 'geometry', 'largest number', 'equation', 'hyperbola', 'level']", "test_keywords": "['outside', 'axis', 'geometry', 'equation', 'point', 'inside', 'position', 'hyperbola', 'graph traversal', 'BST', 'on']", "prompt_tokens": 632, "total_tokens": 962, "completion_tokens": 330, "completion": "[Question 2]\n\nYou are given the equation of a Hyperbola : x^2 - 4y^2 = 16 and a point (x, y). Your task is to determine the position of the given point with respect to the hyperbola. A point (x, y) is said to be:\n1. Inside the Hyperbola if the value of (x^2 - 4y^2) is less than 16.\n2. Outside the Hyperbola if the value of (x^2 - 4y^2) is greater than 16.\n3. On the Hyperbola if the value of (x^2 - 4y^2) is equal to 16.\n\nWrite a function to determine the relative position of the given point with respect to the hyperbola.\n\n[/Question 2]\n\n[Code 2]\n\ndef pointPosition(x: float, y: float) -> str:\n    if (x*x - 4*y*y < 16):\n        return \"Inside\"\n    elif (x*x - 4*y*y == 16):\n        return \"On\"\n    else:\n        return \"Outside\"\n\n[/Code 2]\n\n[Asserts 2]\n\nassert pointPosition(4, 0)==\"On\"\nassert pointPosition(5, 0)==\"Outside\"\nassert pointPosition(3, 0)==\"Inside\"\nassert pointPosition(0, 2)==\"Inside\"\nassert pointPosition(0, 5)==\"Outside\"\nassert pointPosition(2, 2)==\"On\"\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.907}, {"few_shot_keywords": "['algorithm', 'dictionary', 'index', 'modification', 'pair', 'inscribed', 'binary', 'source node', 'adjacent', 'string', 'accessible', 'consecutive']", "test_keywords": "['modification', 'conditional', 'king', 'adjacent', 'index', 'neighbor', 'breadth first search', 'algorithm', 'binary', 'consecutive', 'pair', 'string', 'concatenated']", "prompt_tokens": 518, "total_tokens": 716, "completion_tokens": 198, "completion": "[Question 2]\n\nGiven a binary string, implement an algorithm to modify the string such that any pair of adjacent 1s are replaced with 0s, and return the concatenated modified string.\n\n[/Question 2]\n\n[Code 2]\n\ndef modifyAdjacentPairs(s: str) -> str:\n    modified = ''\n    i = 0\n    while i < len(s):\n        if s[i] == '1' and i+1 < len(s) and s[i+1] == '1':\n            modified += '0'\n            i += 2\n        else:\n            modified += s[i]\n            i += 1\n    return modified\n\n[/Code 2]\n\n[Asserts 2]\n\nassert modifyAdjacentPairs(\"1001101101\") == \"1001001\"\nassert modifyAdjacentPairs(\"1010101010\") == \"1010101010\"\nassert modifyAdjacentPairs(\"1111\") == \"00\"\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.743}, {"few_shot_keywords": "['volume', 'Python', 'split', 'cells', 'vowels', 'equality', 'check', 'string', 'count', 'substring']", "test_keywords": "['Python', 'string', 'repeated', 'count', 'max', 'path sum', 'substring', 'split', 'sum', 'vowels', 'equality', 'merging', 'check']", "prompt_tokens": 516, "total_tokens": 687, "completion_tokens": 171, "completion": "[Question 2]\n\nWrite a Python program to find the maximum count of repeated vowels in a given string.\n\n[/Question 2]\n\n[Code 2]\n\ndef maxRepeatedVowels(s: str) -> int:\n    vowels = 'AEIOUaeiou'\n    max_count = 0\n    count = 0\n    for char in s:\n        if char in vowels:\n            count += 1\n            max_count = max(max_count, count)\n        else:\n            count = 0\n    return max_count\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maxRepeatedVowels(\"apple\")==1\nassert maxRepeatedVowels(\"strength\")==1\nassert maxRepeatedVowels(\"programming\")==3\nassert maxRepeatedVowels(\"algorithm\")==2\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.799}, {"few_shot_keywords": "['check', 'coordinates', 'maximize', 'negative', 'matrix', 'adjacent', 'sum', 'candies', 'operation', 'lexicographically', 'count', 'pair', 'multiply', 'sentence']", "test_keywords": "['dfs', 'maximize', 'matrix', 'multiply', 'pair', 'sum', 'negative', 'traversal', 'adjacent', 'operation', 'count']", "prompt_tokens": 711, "total_tokens": 1240, "completion_tokens": 529, "completion": "[Question 2]\n\nGiven a matrix mat[][] of size N x M, the task is to maximize the sum of the matrix by performing a DFS traversal and multiplying any two adjacent elements (either horizontally or vertically) by -1 exactly once. \n\nWrite a function to find the maximum sum of the matrix after performing the operation using Depth-First Search (DFS) traversal.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\ndef dfsMaximizeMatrixSum(mat: List[List[int]]) -> int:\n    def dfs(row, col, visited, mat):\n        if row < 0 or row >= len(mat) or col < 0 or col >= len(mat[0]) or visited[row][col]:\n            return 0\n        visited[row][col] = True\n        original_val = mat[row][col]\n        max_sum = original_val\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            new_row, new_col = row + dr, col + dc\n            if 0 <= new_row < len(mat) and 0 <= new_col < len(mat[0]):\n                original_val *= -1\n                max_sum = max(max_sum, dfs(new_row, new_col, visited, mat))\n                original_val *= -1\n        visited[row][col] = False\n        return max_sum\n    \n    max_sum = 0\n    visited = [[False for _ in range(len(mat[0]))] for _ in range(len(mat))]\n    for i in range(len(mat)):\n        for j in range(len(mat[0])):\n            max_sum = max(max_sum, dfs(i, j, visited, mat))\n    return max_sum\n\n[/Code 2]\n\n[Asserts 2]\n\nassert dfsMaximizeMatrixSum([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 45\nassert dfsMaximizeMatrixSum([[-1, 2, 3], [4, 5, -6], [7, 8, 9]]) == 55\nassert dfsMaximizeMatrixSum([[1, -2, -3], [4, 5, 6], [7, 8, 9]]) == 44\nassert dfsMaximizeMatrixSum([[-1, -2, -3], [-4, -5, -6], [-7, -8, -9]]) == 23\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.792}, {"few_shot_keywords": "['optimization', 'QuickSort', 'house', 'matrix', 'minimum', 'combinatorics', 'dynamic programming', 'color', 'cost', 'painting', 'grid']", "test_keywords": "['matrix', 'minimum', 'modulo', 'cost', 'dynamic programming', 'largest number', 'house', 'height', 'painting', 'int', 'color', 'optimization', 'sorted']", "prompt_tokens": 598, "total_tokens": 923, "completion_tokens": 325, "completion": "[Question 2]\n\nYou are given a matrix of integers representing the height of each house. You want to paint the houses in such a way that the difference in height between adjacent houses is minimized. You can paint each house with one of the three colors: red, blue, or green. Additionally, you can also choose to maximize the difference in height between the first and the last house. Write a function to calculate the minimum cost of painting all the houses while satisfying the given conditions.\n\n[/Question 2]\n\n[Code 2]\n\ndef minCost(matrix):\n    n = len(matrix)\n    if n == 0:\n        return 0\n    if len(matrix[0]) == 0:\n        return 0\n    \n    dp = [[0] * 3 for _ in range(n)]\n    dp[0] = matrix[0]\n    \n    for i in range(1, n):\n        dp[i][0] = matrix[i][0] + min(dp[i-1][1], dp[i-1][2])\n        dp[i][1] = matrix[i][1] + min(dp[i-1][0], dp[i-1][2])\n        dp[i][2] = matrix[i][2] + min(dp[i-1][0], dp[i-1][1])\n    \n    return min(dp[-1])\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minCost([[17,2,17],[16,16,5],[14,3,19]]) == 10\nassert minCost([[7,6,2]]) == 2", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.785}, {"few_shot_keywords": "['different', 'inscribed', 'sum', 'maximize', 'distinct', 'integer', 'counting', 'array', 'prime factors', 'buying', 'swaps', 'middle column']", "test_keywords": "['consecutive sequence', 'array', 'sum', 'distinct', 'closest', 'prime factors', 'maximize', 'preserving order', 'counting', 'integer']", "prompt_tokens": 654, "total_tokens": 1032, "completion_tokens": 378, "completion": "[Question 2]\n\nGiven an array of integers, find the maximum sum of a subsequence with the property that the sum of prime factors of each element in the subsequence is distinct and closest to a given integer K.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\nimport math\n\ndef isPrime(n):\n    if n <= 1:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef maxPrimeSum(arr: List[int], K: int) -> int:\n    def prime_factors_sum(n):\n        if n < 2:\n            return 0\n        total = 0\n        for i in range(2, n+1):\n            while n % i == 0 and isPrime(i):\n                total += i\n                n //= i\n        return total\n\n    n = len(arr)\n    maxSum = 0\n    for i in range(n):\n        tempSum = arr[i]\n        for j in range(i+1, n):\n            tempSum += arr[j]\n            if prime_factors_sum(tempSum) == K:\n                maxSum = max(maxSum, tempSum)\n    return maxSum\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maxPrimeSum([3, 4, 8, 10, 21, 18, 22], 10) == 21\nassert maxPrimeSum([2, 3, 5, 7, 11, 13, 17, 19], 30) == 29\nassert maxPrimeSum([15, 21, 32, 42, 56, 72], 20) == 15\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.818}, {"few_shot_keywords": "['palindromic', 'occurrences', 'algorithm', 'coordinate plane', 'representation', 'sorted', 'subtract', 'substring', 'count', 'LCA', 'string', 'replacement']", "test_keywords": "['occurrences', 'palindromic', 'division', 'replacement', 'algorithm', 'preserving order', 'substring', 'outside', 'string', 'count', 'bool']", "prompt_tokens": 577, "total_tokens": 835, "completion_tokens": 258, "completion": "[Question 2]\n\nWrite a function to count the occurrences of a palindromic substring that appears exactly once in a given string. The function should return a boolean indicating whether the order of the characters in the substring should be preserved while counting the occurrences.\n\n[/Question 2]\n\n[Code 2]\n\ndef countUniquePalindromicSubstrings(s: str, preserve_order: bool) -> int:\n    count = 0\n    n = len(s)\n    for i in range(n):\n        for j in range(i, n):\n            substr = s[i:j+1]\n            if substr == substr[::-1]:\n                if s.count(substr) == 1:\n                    if preserve_order and s.find(substr) == i:\n                        count += 1\n                    elif not preserve_order:\n                        count += 1\n    return count\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countUniquePalindromicSubstrings(\"abba\", True) == 2\nassert countUniquePalindromicSubstrings(\"aba\", False) == 1\nassert countUniquePalindromicSubstrings(\"racecar\", True) == 1\nassert countUniquePalindromicSubstrings(\"aabbaa\", False) == 3", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.93}, {"few_shot_keywords": "['path sum', 'array', 'positive', 'modification', 'decrement', 'sorting', 'difference', 'increment', '2D', 'open', 'smallest', 'integer', 'equal']", "test_keywords": "['equal', 'positive', 'check', 'queries', 'even numbers', 'game', 'array', 'sorting', 'difference', 'integer', 'increment', 'neighbor', 'smallest', 'decrement']", "prompt_tokens": 579, "total_tokens": 903, "completion_tokens": 324, "completion": "[Question 2]\n\nYou are given an array of integers arr[]. You need to answer Q queries where each query consists of two integers L and R. For each query, you need to check if it's possible to make all the elements between indices L and R (inclusive) equal by incrementing or decrementing by at most 1 in each operation. Return a list of boolean values indicating whether it's possible for each query.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\ndef canMakeEqual(arr: List[int], queries: List[List[int]]) -> List[bool]:\n    n = len(arr)\n    arr.sort()\n    result = []\n    for query in queries:\n        L, R = query\n        diff = abs(arr[L] - arr[R])\n        result.append(diff <= 1)\n    return result\n\n[/Code 2]\n\n[Asserts 2]\n\nassert canMakeEqual([1, 2, 3, 4, 5], [[0, 2], [1, 3], [2, 4]]) == [True, True, False]\nassert canMakeEqual([4, 5, 6, 7, 8], [[0, 3], [1, 2], [2, 4]]) == [True, True, True]\nassert canMakeEqual([10, 20, 30, 40, 50], [[0, 4], [1, 3], [2, 3]]) == [True, False, True]\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.869}, {"few_shot_keywords": "['priority queue', 'substring', 'strings', 'form', 'concatenation', 'promotion', 'maximum', 'possible']", "test_keywords": "['trimming', 'maximum', 'possible', 'form', 'binary', 'concatenation', 'strings', 'substring', 'irregular']", "prompt_tokens": 560, "total_tokens": 885, "completion_tokens": 325, "completion": "[Question 2]\n\nGiven a list of binary strings, the task is to find the maximum irregular substring that can be formed by concatenating the given strings. An irregular substring is defined as a substring that does not contain the same number of 0s and 1s. If no irregular substring can be formed, return an empty string.\n\n[/Question 2]\n\n[Code 2]\n\ndef maxIrregularSubstring(strings: List[str]) -> str:\n    max_substring = \"\"\n    for i in range(len(strings)):\n        for j in range(i+1, len(strings) + 1):\n            substring = \"\".join(strings[i:j])\n            zeros = substring.count('0')\n            ones = substring.count('1')\n            if zeros != ones and len(substring) > len(max_substring):\n                max_substring = substring\n    return max_substring\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maxIrregularSubstring([\"101\", \"110\", \"1010\"]) == \"101110\"\nassert maxIrregularSubstring([\"110\", \"101\", \"1010\"]) == \"1011010\"\nassert maxIrregularSubstring([\"111\", \"000\", \"110\"]) == \"111000110\"\nassert maxIrregularSubstring([\"111\", \"000\", \"110\", \"1010\"]) == \"111000110\"\nassert maxIrregularSubstring([\"000\", \"000\", \"000\"]) == \"\"\nassert maxIrregularSubstring([\"1111\", \"000\"]) == \"1111000\"\nassert maxIrregularSubstring([\"1010\", \"1010\", \"1010\"]) == \"\"", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.777}, {"few_shot_keywords": "['permutation', 'combinatorics', 'list of lists', 'cost', 'string', 'round', 'recursion', 'count', 'center']", "test_keywords": "['permutation', 'string', 'steps', 'combinatorics', 'count', 'sides', 'recursion']", "prompt_tokens": 533, "total_tokens": 756, "completion_tokens": 223, "completion": "[Question 2]\n\nGiven a string of steps, the task is to find the number of permutations where the person ends up at the same position after taking all the steps. Each step can be in four directions: up, down, left, or right.\n\n[/Question 2]\n\n[Code 2]\n\ndef countPermutations(s: str) -> int:\n    x = 0\n    y = 0\n    \n    for step in s:\n        if step == 'U':\n            y += 1\n        elif step == 'D':\n            y -= 1\n        elif step == 'L':\n            x -= 1\n        elif step == 'R':\n            x += 1\n            \n    return 1 if x==0 and y==0 else 0\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countPermutations(\"UDLR\")==1\nassert countPermutations(\"UUDLRL\")==0\nassert countPermutations(\"ULDRDU\")==1\nassert countPermutations(\"UUUDDDLLRRR\")==1\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.742}]