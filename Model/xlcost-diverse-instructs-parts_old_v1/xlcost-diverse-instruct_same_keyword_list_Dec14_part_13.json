[{"few_shot_keywords": "['minimum', 'dynamic programming', 'backtrack', 'game', 'scoring', 'eligibility', 'dictionary', 'moves', 'integer']", "test_keywords": "['construct', 'integer', 'minimum', 'game', 'bracket', 'range', 'round', 'moves', 'scoring', 'dynamic programming', 'prime']", "prompt_tokens": 571, "total_tokens": 933, "completion_tokens": 362, "completion": "[Question 2]\n\nYou are playing a game where you need to construct a sequence of integers from 1 to N. In each move, you can either add a prime number or a power of 2 to the sequence. The game ends when the sequence contains all integers from 1 to N. The score for each move is the minimum prime or power of 2 that can be added to the sequence. Write a function `minScore` to determine the minimum total score required to construct the sequence containing all integers from 1 to N.\n\n[/Question 2]\n\n[Code 2]\n\ndef minScore(N: int) -> int:\n    primes = [2]\n    for num in range(3, N + 1):\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                break\n        else:\n            primes.append(num)\n\n    dp = [0] * (N + 1)\n    for i in range(2, N + 1):\n        dp[i] = float('inf')\n        for prime in primes:\n            if prime > i:\n                break\n            dp[i] = min(dp[i], 1 + dp[i - prime])\n        power = 1\n        while 2 ** power <= i:\n            dp[i] = min(dp[i], 1 + dp[i - 2 ** power])\n            power += 1\n    return dp[N]\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minScore(5) == 4\nassert minScore(10) == 5\nassert minScore(15) == 6\nassert minScore(20) == 7\nassert minScore(25) == 8", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.766}, {"few_shot_keywords": "['array', 'consecutive', 'sum', 'turns', 'element', 'minimum', 'replacement', 'heapq', 'remaining', 'absolute value', 'absolute difference', 'number', 'half']", "test_keywords": "['sum', 'increment', 'consecutive', 'remaining', 'replacement', 'costs', 'half', 'array', 'minimum', 'element', 'heapq']", "prompt_tokens": 551, "total_tokens": 805, "completion_tokens": 254, "completion": "[Question 2]\n\nGiven an array of integers Arr[], the task is to find the minimum cost required to make all elements of the array equal by incrementing any element by the sum of all the remaining consecutive elements to its right.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\nimport heapq\ndef minCostToMakeArrayEqual(Arr: List[int]) -> int:\n    n = len(Arr)\n    total_sum = sum(Arr)\n    min_cost = float('inf')\n    prefix_sum = 0\n    for i in range(n-1):\n        prefix_sum += Arr[i]\n        remaining_sum = total_sum - prefix_sum\n        cost = remaining_sum * (i+1)\n        min_cost = min(min_cost, cost)\n    return min_cost\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minCostToMakeArrayEqual([1, 2, 3, 4, 5]) == 10\nassert minCostToMakeArrayEqual([5, 4, 3, 2, 1]) == 10\nassert minCostToMakeArrayEqual([3, 1, 2, 4, 6, 5]) == 12", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.848}, {"few_shot_keywords": "['sorting', 'scale', 'list', 'balance', 'square', 'moves', 'neighbours', 'max distance', 'weight']", "test_keywords": "['multiple times', 'binary', 'max distance', 'scale', 'balance', 'expression', 'weight', 'moves', 'sorting']", "prompt_tokens": 596, "total_tokens": 934, "completion_tokens": 338, "completion": "[Question 2]\n\nYou are given a list of binary expressions, and you need to find the maximum distance between two expressions such that one is a multiple of the other. Write a function to calculate the maximum distance.\n\n[/Question 2]\n\n[Code 2]\n\ndef maxDistanceBinary(expressions: list) -> int:\n    expressions.sort()\n    n = len(expressions)\n    max_dist = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if int(expressions[j], 2) % int(expressions[i], 2) == 0:\n                max_dist = max(max_dist, j-i)\n    return max_dist\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maxDistanceBinary(['101', '110', '111', '100', '1001', '1010']) == 3\nassert maxDistanceBinary(['101', '110', '111', '100', '1001', '1010', '1111']) == 3\nassert maxDistanceBinary(['101', '110', '111', '100', '1001', '1010', '1100', '1111']) == 3\nassert maxDistanceBinary(['101', '110', '111', '100', '1001', '1010', '1100', '1111', '10000']) == 4\nassert maxDistanceBinary(['101', '110', '111', '100', '1001', '1010', '1100', '1111', '10000', '11000']) == 4\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.862}, {"few_shot_keywords": "['modulo', 'memoization', 'integer', 'prime', '0', 'removal', 'shortest distance', 'dynamic programming', 'sum', 'array']", "test_keywords": "['modulo', 'removal', 'integer', 'sum', 'dynamic programming', 'grid', 'memoization', 'pairwise coprime', 'expression', 'array']", "prompt_tokens": 750, "total_tokens": 1130, "completion_tokens": 380, "completion": "[Question 2]\n\nGiven a grid of integers, the task is to find the sum of all possible pairwise coprime pairs in the grid modulo a given integer M.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\ndef gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef countPairsWithGCD1(arr: List[List[int]], n: int, m: int) -> int:\n    dp = [[0 for i in range(101)] for j in range(101)]\n    for i in range(n):\n        for j in range(m):\n            for x in range(1, 101):\n                if arr[i][j] % x == 0:\n                    dp[i][j] += 1\n    total = 0\n    for i in range(n):\n        for j in range(m):\n            for k in range(i, n):\n                for l in range(m):\n                    if (i != k or j != l):\n                        if (gcd(arr[i][j], arr[k][l]) == 1):\n                            total += dp[i][j] * dp[k][l]\n    return total % 1000000007\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countPairsWithGCD1([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3, 3) == 89\nassert countPairsWithGCD1([[2, 3, 5], [7, 11, 13]], 2, 3) == 38\nassert countPairsWithGCD1([[6, 8, 10], [15, 21, 25]], 2, 3) == 102", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.727}, {"few_shot_keywords": "['integer', 'rope', 'minimum', 'conditional', 'max sum', 'count', 'character', 'exit', 'alphabet', 'replace', 'string', 'occurrence', 'frequency']", "test_keywords": "['integer', 'frequency', 'count', 'occurrence', 'alphabet', 'string', 'minimum', 'replace', 'character', 'queries', 'max']", "prompt_tokens": 534, "total_tokens": 840, "completion_tokens": 306, "completion": "[Question 2]\n\nYou are given a string S and Q queries. Each query consists of an integer K. For each query, you need to find the maximum frequency of any character in the string after replacing exactly K characters. Return the minimum value of the maximum frequency for each query.\n\n[/Question 2]\n\n[Code 2]\n\ndef minMaxFrequency(s: str, queries: List[int]) -> List[int]:\n    result = []\n    for k in queries:\n        char_count = {}\n        max_freq = 0\n        for char in s:\n            if char in char_count:\n                char_count[char] += 1\n            else:\n                char_count[char] = 1\n            max_freq = max(max_freq, char_count[char])\n        if k >= max_freq:\n            result.append(1)\n        else:\n            result.append(max_freq - k)\n    return result\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minMaxFrequency(\"abccc\", [2, 3, 4])==[2, 2, 1]\nassert minMaxFrequency(\"aabbcc\", [1, 2, 3])==[2, 2, 2]\nassert minMaxFrequency(\"aaabbcc\", [2, 3, 4])==[2, 2, 1]\nassert minMaxFrequency(\"aaaaabbbbcccc\", [4, 5, 6])==[2, 1, 1]\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.709}, {"few_shot_keywords": "['string', 'index', 'odd', 'rearrange', 'palindrome', 'character', 'adjacent digits', 'frequency', 'even', 'task', 'array']", "test_keywords": "['palindrome', 'substring', 'character', 'even', 'index', 'odd', 'string', 'array', 'frequency', 'rearrange', 'impossible']", "prompt_tokens": 627, "total_tokens": 848, "completion_tokens": 221, "completion": "[Question 2]\n\nGiven a string s, determine if it is possible to rearrange the characters of s to form a palindrome where every character appears an even number of times, except for at most one character which can appear an odd number of times. Return True if it is possible, and False otherwise.\n\n[/Question 2]\n\n[Code 2]\n\ndef canRearrangeToPalindrome(s: str) -> bool:\n    n = len(s)\n    freq = [0]*26\n    for i in s:\n        freq[ord(i)-ord('a')] += 1\n    odd_char_count = 0\n    for i in range(26):\n        if freq[i] % 2 != 0:\n            odd_char_count += 1\n    return odd_char_count <= 1\n\n[/Code 2]\n\n[Asserts 2]\n\nassert canRearrangeToPalindrome(\"aabbcc\")==True\nassert canRearrangeToPalindrome(\"aabbc\")==True\nassert canRearrangeToPalindrome(\"abc\")==False\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.868}, {"few_shot_keywords": "['cell', 'length', 'sort', 'elements', 'array', 'modulo', 'maximize', 'count', 'subsequences']", "test_keywords": "['count', 'subsequences', 'array', 'smallest', 'maximize', 'sort', 'composite', 'length', 'elements']", "prompt_tokens": 588, "total_tokens": 938, "completion_tokens": 350, "completion": "[Question 2]\n\nGiven an array of integers, write a function to find the smallest composite number possible by concatenating elements from the array. The function should maximize the count of such composite numbers.\n\nFor example, if the array is [1, 2, 3, 4, 5], the smallest composite number formed by concatenating the elements is 143, and the count will be 1.\n\nWrite a function that takes in the array and returns the count of such composite numbers formed.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\nimport math\n\ndef isComposite(n: int) -> bool:\n    if n <= 1:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            return True\n    return False\n\ndef countCompositeNumbers(arr: List[int]) -> int:\n    count = 0\n    for i in range(len(arr)):\n        for j in range(len(arr)):\n            if i != j:\n                num = int(str(arr[i]) + str(arr[j]))\n                if isComposite(num):\n                    count += 1\n    return count\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countCompositeNumbers([1, 2, 3, 4, 5]) == 1\nassert countCompositeNumbers([2, 3, 4, 6, 8]) == 8\nassert countCompositeNumbers([1, 4, 6, 7, 9]) == 7\nassert countCompositeNumbers([5, 7, 11, 13]) == 0\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.87}, {"few_shot_keywords": "['permutation', 'target', 'array', 'concatenation', 'Bellman-Ford algorithm', 'boolean', 'memoization', 'determination', 'consecutive elements', 'mapping', 'construct']", "test_keywords": "['determination', 'algorithm', 'permutation', 'mapping', 'array', 'concatenation', 'boolean', 'weights', 'target', 'multiplying']", "prompt_tokens": 583, "total_tokens": 821, "completion_tokens": 238, "completion": "[Question 2]\n\nYou are given an array of boolean values representing weights of items, and a target boolean value. Write a function to determine if it is possible to find a permutation of the array such that the concatenation of the permutation results in the target boolean value after multiplying all the elements.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\ndef canConcatenateToTarget(arr: List[bool], target: bool) -> bool:\n    n = len(arr)\n    fact = 1 << n\n    \n    for mask in range(fact):\n        cur = 1\n        for i in range(n):\n            if (mask >> i) & 1:\n                cur *= arr[i]\n        if cur == target:\n            return True\n    \n    return False\n\n[/Code 2]\n\n[Asserts 2]\n\nassert canConcatenateToTarget([True, False, True], True)==False\nassert canConcatenateToTarget([True, False, True], False)==True\nassert canConcatenateToTarget([True, True, True], True)==True\nassert canConcatenateToTarget([False, False, False], False)==True", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.85}, {"few_shot_keywords": "['even', 'odd', 'integer', 'element', 'array', 'adjacent digits', 'sum', 'subsets', 'index', 'modification']", "test_keywords": "['array', 'memoization', 'even', 'count', 'index', 'modification', 'odd', 'integer', 'sum', 'feasible']", "prompt_tokens": 608, "total_tokens": 917, "completion_tokens": 309, "completion": "[Question 2]\n\nYou are given an array of integers. Write a function to check if the sum of even integers in the array is feasible to be modified to make it equal to the sum of odd integers by modifying only one element using memoization.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\ndef feasibleModification(arr: List[int]) -> bool:\n    even_sum = sum(num for num in arr if num % 2 == 0)\n    odd_sum = sum(num for num in arr if num % 2 != 0)\n    \n    if even_sum == odd_sum:\n        return True\n    elif abs(even_sum - odd_sum) % 2 != 0:\n        return False\n    else:\n        target = abs(even_sum - odd_sum) // 2\n        if (even_sum > odd_sum and target in arr) or (even_sum < odd_sum and target * -1 in arr):\n            return True\n        else:\n            return False\n\n[/Code 2]\n\n[Asserts 2]\n\nassert feasibleModification([2, 4, 6, 8, 10])==True\nassert feasibleModification([1, 2, 3, 4, 5])==False\nassert feasibleModification([1, 2, 3, 4, 6])==True\nassert feasibleModification([1, 2, 3, 4, 5, 7, 8])==True\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.878}, {"few_shot_keywords": "['pairs', 'division', 'replacements', 'iteration', 'count', 'array', 'math', 'equality', 'LCM', 'mapping', 'subarray']", "test_keywords": "['count', 'iteration', 'LCM', 'array', 'pairs', 'string', 'substring', 'replacements', 'math', 'division', 'equality']", "prompt_tokens": 581, "total_tokens": 866, "completion_tokens": 285, "completion": "[Question 2]\n\nGiven a string str, the task is to find the count of pairs of substrings such that after replacing the substrings by their LCM, we get a string where all the characters are equal to the LCM of the string.\n\n[/Question 2]\n\n[Code 2]\n\ndef findSubstringPairsCount(s: str) -> int:\n    n = len(s)\n    ans = 0\n\n    for i in range(n):\n        for j in range(i+1, n):\n            if s[i:j+1] != '':\n                lcm = findLcmOfString(s[i:j+1])\n                if all(char == lcm for char in s[i:j+1]):\n                    ans += 1\n    return ans\n\ndef findLcmOfString(s: str) -> int:\n    ascii_sum = sum(ord(c) for c in s)\n    lcm = 1\n    for num in range(2, ascii_sum + 1):\n        if all(num % i == 0 for i in range(2, ascii_sum + 1)):\n            lcm = num\n            break\n    return lcm\n\n[/Code 2]\n\n[Asserts 2]\n\nassert findSubstringPairsCount(\"abab\") == 4\nassert findSubstringPairsCount(\"xyz\") == 0\nassert findSubstringPairsCount(\"aaaa\") == 6\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.762}, {"few_shot_keywords": "['piles', 'connectivity', 'stones', 'winner', 'half', 'turn', 'integers', 'player', 'game', 'rope']", "test_keywords": "['winner', 'player', 'distinct', 'stones', 'game', 'turn', 'piles', 'inclusive']", "prompt_tokens": 525, "total_tokens": 774, "completion_tokens": 249, "completion": "[Question 2]\n\nYou are playing a game with n piles of stones. On each turn, a player can select any number of stones from a single pile or from several piles in an inclusive manner, meaning all the piles between the chosen piles are also included.\n\nThe winner is the player who takes the last stone, and the players take turns.\n\nWrite a function `stoneGame` to determine the winner of the game based on the given piles.\n\n[/Question 2]\n\n[Code 2]\n\ndef stoneGame(piles) -> str:\n    if sum(piles) % 2 == 0:\n        return \"First player\"\n    else:\n        return \"Second player\"\n\n[/Code 2]\n\n[Asserts 2]\n\nassert stoneGame([5, 3, 4, 5]) == \"Second player\"\nassert stoneGame([1, 2, 3, 4, 5]) == \"First player\"\nassert stoneGame([10, 10, 10, 10]) == \"First player\"\nassert stoneGame([1, 1, 1, 1, 1, 1, 1, 1]) == \"Second player\"\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.814}, {"few_shot_keywords": "['integer', 'voting', 'binary', 'source', 'reachability', 'coordinates', 'move', 'destination', 'possible', 'boolean', 'tree']", "test_keywords": "['integer', 'reachability', 'permutation', 'even', 'coordinates', 'increasing order', 'move', 'boolean', 'source', 'destination']", "prompt_tokens": 596, "total_tokens": 910, "completion_tokens": 314, "completion": "[Question 2]\n\nYou are given a source integer array of size n containing distinct integers in increasing order, and a destination integer array of size n containing distinct integers in increasing order. Write a program to determine if the destination array can be obtained by performing a series of moves on the source array. In each move, you can take an element from any position in the source array and place it at the end. The order of the other elements should not change. Return True if the destination array can be obtained, otherwise return False.\n\n[/Question 2]\n\n[Code 2]\n\ndef canObtainDestination(source: List[int], destination: List[int]) -> bool:\n    if len(source) != len(destination):\n        return False\n    for i in range(len(source)):\n        if source[i] != destination[i]:\n            return False\n    return True\n\n[/Code 2]\n\n[Asserts 2]\n\nassert canObtainDestination([1, 2, 3, 4], [3, 4, 1, 2])==True\nassert canObtainDestination([4, 3, 2, 1], [1, 2, 3, 4])==False\nassert canObtainDestination([5, 7, 9, 11], [7, 5, 11, 9])==False\nassert canObtainDestination([1, 3, 5, 7], [1, 3, 5, 7])==True\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.912}, {"few_shot_keywords": "['win', 'round', 'cities', 'bitwise', 'power', 'counting', 'modulo', 'last card', 'binary', 'flip', 'player', 'game', 'math']", "test_keywords": "['binary', 'math', 'win', 'last card', 'lexicographically', 'player', 'modulo', 'game', 'bitwise', 'counting', 'round', 'zeros']", "prompt_tokens": 600, "total_tokens": 845, "completion_tokens": 245, "completion": "[Question 2]\n\nIn a game, players take turns to pick a number from 1 to N, inclusive. The game follows a round-robin style, where each player takes a turn in sequence. The game ends when there are no more numbers left to pick. The player who picks the last number wins the game. Write a function to determine the player who wins the game.\n\nThe function should have the following signature:\n```\ndef findWinningPlayer(N: int) -> int:\n    pass\n```\n\nwhere N is the maximum number to be picked and the return value is the player number who wins the game.\n\n[/Question 2]\n\n[Code 2]\n\ndef findWinningPlayer(N: int) -> int:\n    return N % 2\n\n[/Code 2]\n\n[Asserts 2]\n\nassert findWinningPlayer(4) == 0\nassert findWinningPlayer(7) == 1\nassert findWinningPlayer(12) == 0\nassert findWinningPlayer(5) == 1\nassert findWinningPlayer(10) == 0\nassert findWinningPlayer(8) == 0\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.917}, {"few_shot_keywords": "['comparison', 'array', 'range', 'prime numbers', 'resultant', 'counting', 'integer', 'subarray', 'distinct', 'combinations']", "test_keywords": "['subtree', 'subarray', 'counting', 'integer', 'traversal', 'range', 'array', 'distinct', 'prime numbers', 'scale']", "prompt_tokens": 755, "total_tokens": 1115, "completion_tokens": 360, "completion": "[Question 2]\n\nGiven a binary tree, write a function to count the number of distinct prime numbers that appear in the values of the nodes within the subtree rooted at a given node.\n\n[/Question 2]\n\n[Code 2]\n\nclass TreeNode:\n    def __init__(self, value=0, left=None, right=None):\n        self.value = value\n        self.left = left\n        self.right = right\n\ndef is_prime(n: int) -> bool: \n    if (n <= 1): \n        return False\n    for i in range(2, int(n**0.5) + 1): \n        if (n % i == 0): \n            return False\n    return True\n\ndef countDistinctPrimes(root: TreeNode) -> int:\n    distinct_primes = set()\n    \n    def dfs(node):\n        if node:\n            if is_prime(node.value):\n                distinct_primes.add(node.value)\n            dfs(node.left)\n            dfs(node.right)\n    \n    dfs(root)\n    return len(distinct_primes)\n\n[/Code 2]\n\n[Asserts 2]\n\ntree = TreeNode(1, TreeNode(2, TreeNode(3), TreeNode(4)), TreeNode(5, TreeNode(6), TreeNode(7)))\nassert countDistinctPrimes(tree) == 4\n\ntree2 = TreeNode(11, TreeNode(13, TreeNode(17), TreeNode(19)), TreeNode(23, TreeNode(29), TreeNode(31)))\nassert countDistinctPrimes(tree2) == 6\n\ntree3 = TreeNode(4, TreeNode(6, TreeNode(8), TreeNode(9)), TreeNode(10, TreeNode(12), TreeNode(14)))\nassert countDistinctPrimes(tree3) == 0\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.945}, {"few_shot_keywords": "['divisible', 'math', 'number', 'minimize', 'prime', 'left', 'composite']", "test_keywords": "['divisible', 'composite', 'math', 'terrain', 'obstacle', 'prime', 'number']", "prompt_tokens": 572, "total_tokens": 943, "completion_tokens": 371, "completion": "[Question 2]\n\nYou are given a terrain consisting of obstacles represented by numbers. Write a function to find the first composite number encountered while traversing the terrain, where each number represents an obstacle, and determine if the number is divisible by any prime number less than or equal to N.\n\n[/Question 2]\n\n[Code 2]\n\ndef isPrime(n: int) -> bool: \n\tif n <= 1: \n\t\treturn False\n\tif n <= 3: \n\t\treturn True\n\tif n % 2 == 0 or n % 3 == 0: \n\t\treturn False\n\t\n\ti = 5\n\twhile i * i <= n: \n\t\tif n % i == 0 or n %(i + 2) == 0: \n\t\t\treturn False\n\t\ti = i + 6\n\treturn True\n\ndef firstCompositeTerrain(obstacles: List[int], N: int) -> int:\n    for obstacle in obstacles:\n        if obstacle < 4:\n            continue\n        if all(obstacle % i != 0 for i in range(2, N+1) if isPrime(i)):\n            continue\n        return obstacle\n    return -1\n\n[/Code 2]\n\n[Asserts 2]\n\nassert firstCompositeTerrain([3, 5, 7, 8, 12, 13, 15], 3) == 8\nassert firstCompositeTerrain([2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31], 5) == -1\nassert firstCompositeTerrain([4, 6, 9, 10, 14, 21, 25, 28], 4) == 4\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.795}, {"few_shot_keywords": "['target amount', 'integer', 'increasing order', 'sequence', 'power', 'order of operations', 'sum', 'difference', 'moves', 'subset', 'positive', 'Fibonacci']", "test_keywords": "['subtree', 'integer', 'positive', 'replacement', 'data structure', 'sequence', 'tree', 'increasing order', 'subset', 'sum', 'power']", "prompt_tokens": 493, "total_tokens": 736, "completion_tokens": 243, "completion": "[Question 2]\n\nGiven a positive integer N and a binary tree, write a function to replace each node value in the Nth subtree of the tree with the sum of the powers of 2 in increasing order.\n\n[/Question 2]\n\n[Code 2]\n\nclass TreeNode:\n    def __init__(self, value=0, left=None, right=None):\n        self.value = value\n        self.left = left\n        self.right = right\n\ndef replaceSubtreeWithPowerSum(root: TreeNode, N: int) -> TreeNode:\n    def replaceSubtree(node, level):\n        if not node:\n            return 0\n        if level == N:\n            return 2**level\n        node.value = replaceSubtree(node.left, level+1) + replaceSubtree(node.right, level+1)\n        return node.value\n    \n    replaceSubtree(root, 1)\n    return root\n\n[/Code 2]\n\n[Asserts 2]\n\ntree = TreeNode(1, TreeNode(2), TreeNode(3))\nreplaceSubtreeWithPowerSum(tree, 2)\nassert tree.value == 8\nassert tree.left.value == 4\nassert tree.right.value == 4", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.939}, {"few_shot_keywords": "['impossible', 'integer', 'pair', 'inclusive', 'range', 'count', 'comparison', 'total', 'algorithm', 'set bits', 'binary']", "test_keywords": "['count', 'total', 'half', 'inclusive', 'range', 'bitwise OR', 'optimum', 'integer', 'set bits', 'market', 'binary']", "prompt_tokens": 455, "total_tokens": 706, "completion_tokens": 251, "completion": "[Question 2]\n\nYou are given an array of integers. Write an efficient algorithm to find the total count of pairs (i, j) such that 1 \u2264 i < j \u2264 n and (arr[i] | arr[j]) is greater than or equal to half of the maximum integer value in the array.\n\n[/Question 2]\n\n[Code 2]\n\ndef countPairs(arr: List[int]) -> int:\n    max_val = max(arr)\n    half_max = max_val // 2\n    pair_count = 0\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            if arr[i] | arr[j] >= half_max:\n                pair_count += 1\n    return pair_count\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countPairs([2, 3, 4, 5, 6])==6\nassert countPairs([10, 20, 30, 40, 50])==10\nassert countPairs([15, 23, 30, 42, 57])==7\nassert countPairs([8, 12, 18, 28, 35])==10\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.846}, {"few_shot_keywords": "['product', 'permutation', 'natural numbers', 'cut', 'even', 'array', 'repeatedly', 'odd']", "test_keywords": "['odd', 'directional movement', 'subsequence', 'even', 'array', 'product', 'permutation', 'subsequences', 'eligibility']", "prompt_tokens": 611, "total_tokens": 919, "completion_tokens": 308, "completion": "[Question 2]\n\nGiven an array of natural numbers, find the count of all subsequences where the product of all elements is even, and the subsequences are eligible for directional movement (i.e., elements in the subsequence are arranged in non-decreasing order).\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef count_even_product_subsequences(arr: List[int]) -> int:\n    even_count = 0\n    for num in arr:\n        if num % 2 == 0:\n            even_count += 1\n    odd_count = len(arr) - even_count\n    total_count = 2 ** even_count - 1  # Total count of subsequences with even product\n    total_count *= 2 ** max(odd_count - 1, 0) - 1  # Additional count for subsequences with at least one odd element\n    return total_count\n\n[/Code 2]\n\n[Asserts 2]\n\nassert count_even_product_subsequences([1, 2, 3, 4, 5])==15\nassert count_even_product_subsequences([2, 4, 6, 8, 10])==31\nassert count_even_product_subsequences([1, 3, 5, 7, 9])==0\nassert count_even_product_subsequences([1, 2, 3, 4, 5, 6, 7, 8, 9])==255\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.864}, {"few_shot_keywords": "['depth-first search', 'divisor', 'lexicographical', 'maximum', 'pair', 'GCD', 'integer', 'accessible', 'math']", "test_keywords": "['odd', 'integer', 'strings', 'GCD', 'divisor', 'rearrange', 'math', 'vertical', 'maximum', 'accessible', 'pair']", "prompt_tokens": 481, "total_tokens": 873, "completion_tokens": 392, "completion": "[Question 2]\n\nYou are given a list of strings. Your task is to rearrange the strings in such a way that the GCD (Greatest Common Divisor) of their lengths is maximized. If multiple arrangements result in the same maximum GCD, return the lexicographically smallest rearrangement.\n\n[/Question 2]\n\n[Code 2]\n\ndef gcd(a: int, b: int) -> int:\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef rearrangeStrings(strings: List[str]) -> List[str]:\n    def calculateGCD(a: int, b: int) -> int:\n        if b == 0:\n            return a\n        return calculateGCD(b, a % b)\n\n    strings.sort(key=len)\n    max_gcd = 1\n    max_gcd_pair = ('', '')\n\n    for i in range(len(strings)):\n        for j in range(i+1, len(strings)):\n            current_gcd = calculateGCD(len(strings[i]), len(strings[j]))\n            if current_gcd > max_gcd:\n                max_gcd = current_gcd\n                max_gcd_pair = (strings[i], strings[j])\n\n    return [max_gcd_pair[0], max_gcd_pair[1]] if max_gcd_pair[0] <= max_gcd_pair[1] else [max_gcd_pair[1], max_gcd_pair[0]]\n\n[/Code 2]\n\n[Asserts 2]\n\nassert rearrangeStrings(['abc', 'de', 'fghi', 'jklmno']) == ['de', 'fghi']\nassert rearrangeStrings(['apple', 'banana', 'orange', 'pear', 'grape']) == ['banana', 'apple']\nassert rearrangeStrings(['cat', 'dog', 'bird', 'fish']) == ['dog', 'bird']\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.85}, {"few_shot_keywords": "['concatenation', 'divisible', 'sort', 'integer', 'array', 'absolute differences']", "test_keywords": "['divisible', 'array', 'adjacent digits', 'concatenation', 'integer', 'copy', 'empty', 'visited']", "prompt_tokens": 515, "total_tokens": 857, "completion_tokens": 342, "completion": "[Question 2]\n\nGiven an array of integers, write a function to find the maximum number that can be formed by concatenating the array elements, such that the number is divisible by a given integer k.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\ndef maxConcatenatedDivisible(arr: List[int], k: int) -> int:\n    max_number = -1\n    def isDivisible(num, k):\n        return num % k == 0\n    \n    def dfs(visited, path):\n        nonlocal max_number\n        if len(path) == len(arr):\n            num = int(\"\".join(map(str, path)))\n            if isDivisible(num, k):\n                max_number = max(max_number, num)\n            return\n        for i in range(len(arr)):\n            if not visited[i]:\n                visited[i] = True\n                dfs(visited, path + [arr[i]])\n                visited[i] = False\n    \n    visited = [False] * len(arr)\n    dfs(visited, [])\n    return max_number\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maxConcatenatedDivisible([10, 15, 25, 35, 45], 10) == 543215\nassert maxConcatenatedDivisible([12, 23, 34, 45, 56], 100) == 563412\nassert maxConcatenatedDivisible([1, 2, 3, 4, 5], 3) == 54\nassert maxConcatenatedDivisible([123, 456, 789], 10) == 567891234", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.72}, {"few_shot_keywords": "['forming', 'array', 'task', 'coordinates', 'addition', 'size', 'absolute differences', 'sum', 'total', 'query', 'elements', 'integers', 'cube']", "test_keywords": "['elements', 'sum', 'total', 'integers', '2D', 'array', 'size', 'odd occurrences', 'task', 'beginning', 'absolute differences']", "prompt_tokens": 632, "total_tokens": 1035, "completion_tokens": 403, "completion": "[Question 2]\n\nYou are given a 2D array of integers of size MxN. Your task is to find the total sum of all elements that occur an odd number of times in the array. \n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef sumOfOddOccurences(arr: List[List[int]]) -> int:\n    elements_count = {}\n    for row in arr:\n        for elem in row:\n            if elem in elements_count:\n                elements_count[elem] += 1\n            else:\n                elements_count[elem] = 1\n    total_sum = 0\n    for elem, count in elements_count.items():\n        if count % 2 != 0:\n            total_sum += elem\n    return total_sum\n\n[/Code 2]\n\n[Asserts 2]\n\nassert sumOfOddOccurences([[1, 2, 3], [4, 5, 6], [1, 2, 3]]) == 12\nassert sumOfOddOccurences([[1, 2, 3], [4, 5, 6], [1, 2, 3], [5, 5, 6]]) == 12\nassert sumOfOddOccurences([[1, 2, 3], [4, 5, 6], [1, 2, 3], [5, 5, 6], [2, 2, 3]]) == 12\nassert sumOfOddOccurences([[1, 1, 1], [2, 2, 2], [3, 3, 3]]) == 6\nassert sumOfOddOccurences([[1, 1, 1], [2, 2, 2], [3, 3, 3], [4, 4, 4]]) == 6\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.773}, {"few_shot_keywords": "['directional movement', 'count', 'pairs', 'nested loop', 'matrix', 'size', 'connected', 'cell', 'condition', 'accessible', 'concatenation']", "test_keywords": "['size', 'placement', 'empty', 'pairs', 'nested loop', 'count', 'than', 'cell', 'condition', 'set bits', 'matrix', 'accessible']", "prompt_tokens": 757, "total_tokens": 1170, "completion_tokens": 413, "completion": "[Question 2]\n\nGiven a matrix of size N * N, write a function to count the number of pairs of cells (i, j) and (p, q) such that the absolute difference in the number of set bits in the binary representation of the values in the cells is less than a given threshold k.\n\n[/Question 2]\n\n[Code 2]\n\ndef countPairsWithSetBitsThreshold(matrix: List[List[int]], N: int, k: int) -> int:\n\t# Function to count the number of set bits in a number\n\tdef countSetBits(num):\n\t\tcount = 0\n\t\twhile num:\n\t\t\tcount += num & 1\n\t\t\tnum >>= 1\n\t\treturn count\n\tcount = 0\n\tfor i in range(N):\n\t\tfor j in range(N):\n\t\t\tfor p in range(N):\n\t\t\t\tfor q in range(N):\n\t\t\t\t\tif (i, j) != (p, q):\n\t\t\t\t\t\tdiff = abs(countSetBits(matrix[i][j]) - countSetBits(matrix[p][q]))\n\t\t\t\t\t\tif diff < k:\n\t\t\t\t\t\t\tcount += 1\n\treturn count\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countPairsWithSetBitsThreshold([[5, 6, 7], [8, 9, 10], [11, 12, 13]], 3, 2)==6\nassert countPairsWithSetBitsThreshold([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3, 1)==12\nassert countPairsWithSetBitsThreshold([[15, 16, 17], [18, 19, 20], [21, 22, 23]], 3, 3)==6\nassert countPairsWithSetBitsThreshold([[3, 5, 7], [9, 10, 12], [13, 14, 15]], 3, 2)==8\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.881}, {"few_shot_keywords": "['binary', 'powers', 'bit', 'minimum', 'number', 'distinct', 'distance', 'bisect', 'weights', 'remaining', 'string', 'expression', 'count']", "test_keywords": "['boundary', 'expression', 'number', 'binary', 'mountain', 'distinct', 'string', 'subset', 'count', 'changes', 'powers', 'minimum', 'bit']", "prompt_tokens": 476, "total_tokens": 761, "completion_tokens": 285, "completion": "[Question 2]\n\nYou are given a binary string representing a mountain, where 0 indicates a descent and 1 indicates an ascent. Write a function to count the minimum number of changes required to make the mountain a strict mountain. A strict mountain is defined as a mountain where there is only one peak, and all other numbers strictly decrease on either side of the peak.\n\n[/Question 2]\n\n[Code 2]\n\ndef minChangesToStrictMountain(s: str) -> int:\n    peakIndex = s.index('1')\n    changes = 0\n    # Count changes required on the left side of the peak\n    for i in range(peakIndex-1, -1, -1):\n        if s[i] >= s[i+1]:\n            changes += 1\n        else:\n            break\n    # Count changes required on the right side of the peak\n    for i in range(peakIndex+1, len(s)):\n        if s[i] >= s[i-1]:\n            changes += 1\n        else:\n            break\n    return changes\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minChangesToStrictMountain(\"001\") == 0\nassert minChangesToStrictMountain(\"100001\") == 1\nassert minChangesToStrictMountain(\"100100\") == 2\nassert minChangesToStrictMountain(\"11110\") == 1", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.846}, {"few_shot_keywords": "['backtrack', 'subset', 'iteration', 'validation', 'set bits', 'sequence', 'positive integers', 'maximize', 'list', 'Fibonacci', 'string', 'copy', 'numeric']", "test_keywords": "['Fibonacci', 'list', 'backtrack', 'numeric', 'iteration', 'sequence', 'validation', 'string', 'coins']", "prompt_tokens": 650, "total_tokens": 935, "completion_tokens": 285, "completion": "[Question 2]\n\nWrite a Python function to find the maximum value that can be obtained by adding up the numeric values in a given list of strings, considering each string as a sequence of numeric values. The function should return -1 if no valid sequence can be formed.\n\n[/Question 2]\n\n[Code 2]\n\ndef findMaxValue(coins: List[str]) -> int:\n    def backtrack(start, value):\n        if start == len(s):\n            return value\n        maxx = -1\n        num = 0\n        for i in range(start, len(s)):\n            num = num * 10 + int(s[i])\n            if num > 2**31 - 1:\n                break\n            if num >= value:\n                break\n            maxx = max(maxx, backtrack(i + 1, num))\n        return maxx\n    return backtrack(0, 0)\n\n[/Code 2]\n\n[Asserts 2]\n\nassert findMaxValue([\"1\",\"2\",\"3\"]) == 6\nassert findMaxValue([\"1\",\"2\",\"3\",\"4\"]) == 7\nassert findMaxValue([\"1\",\"2\",\"3\",\"4\",\"5\"]) == 9\nassert findMaxValue([\"100\",\"200\",\"300\",\"400\",\"500\"]) == -1\nassert findMaxValue([\"10\",\"000\",\"000\",\"000\",\"000\",\"000\",\"000\"]) == 10", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.907}, {"few_shot_keywords": "['vowels', 'string', 'pairs', 'concatenation', 'swap', 'same', 'count']", "test_keywords": "['count', 'concatenation', 'distinct', 'vowels', 'rope', 'top', 'string', 'powers', 'pairs', 'increase']", "prompt_tokens": 568, "total_tokens": 885, "completion_tokens": 317, "completion": "[Question 2]\n\nGiven a string, write a function to count the distinct pairs of substrings whose concatenation forms a string with all the vowels in it and whose lengths are in increasing powers of 2.\n\n[/Question 2]\n\n[Code 2]\n\ndef countDistinctPairsWithVowelConcatenation(s: str) -> int:\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    n = len(s)\n    pairs = set()\n    for i in range(n):\n        for j in range(i+1, n):\n            substr1 = s[i:j]\n            substr2 = s[j:]\n            \n            if len(substr1) > 0 and len(substr2) > 0:\n                if all(v in substr1+substr2 for v in vowels):\n                    if (len(substr1) & (len(substr1) - 1)) == 0 and (len(substr2) & (len(substr2) - 1)) == 0:\n                        pairs.add((substr1, substr2))\n    return len(pairs)\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countDistinctPairsWithVowelConcatenation(\"aetopicisfun\") == 4\nassert countDistinctPairsWithVowelConcatenation(\"ienjoyalgorithm\") == 5\nassert countDistinctPairsWithVowelConcatenation(\"pythonrocks\") == 0\nassert countDistinctPairsWithVowelConcatenation(\"aerobic\") == 1\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.935}, {"few_shot_keywords": "['possible', 'connectivity', 'indices', 'color', 'if statement', 'integer', 'empty', 'substring', 'grid', 'longest', 'costs', 'list', 'maximum']", "test_keywords": "['subtrees', 'list', 'choose', 'grid', 'maximum', 'color', 'connectivity', 'possible', 'empty', 'integer']", "prompt_tokens": 948, "total_tokens": 1462, "completion_tokens": 514, "completion": "[Question 2]\n\nYou are given a binary tree and an integer k. Your task is to write a function `countSubtrees` to find the maximum number of subtrees in the binary tree in which the sum of all nodes is less than or equal to k. The function should return the list of nodes for each subtree that satisfies the condition.\n\nThe binary tree is represented as a list of lists, where each list contains the value of the node and its left and right children. If a child is empty, it is represented as None.\n\nWrite a function `countSubtrees` to solve the problem. This function should take in the following parameters:\n- `tree`: a list of lists representing the binary tree.\n- `k`: an integer representing the threshold sum.\n\nThe function should return a list of lists, where each inner list contains the nodes of a subtree that satisfies the condition.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\ndef countSubtrees(tree: List[List[int]], k: int) -> List[List[int]]:\n    def subtreeSum(node):\n        if not node:\n            return 0\n        left_sum = subtreeSum(tree[node][1])\n        right_sum = subtreeSum(tree[node][2])\n        total_sum = left_sum + right_sum + tree[node][0]\n        if total_sum <= k:\n            result.append([tree[node][0], left_sum, right_sum])\n        return total_sum\n    \n    result = []\n    subtreeSum(0)\n    return result\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countSubtrees([[1, [2, [4, None, None], [5, None, None]], [3, [6, None, None], None]], 5) == [[4], [5], [2, 4, 5]]\nassert countSubtrees([[1, [2, [4, None, None], [5, None, None]], [3, [6, None, None], None]], 10) == [[4], [5], [2, 4, 5], [3, 6]]\nassert countSubtrees([[1, [2, [4, None, None], [5, None, None]], [3, [6, None, None], None]], 15) == [[4], [5], [2, 4, 5], [3, 6], [1, 2, 3, 4, 5, 6]]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.718}, {"few_shot_keywords": "['adjacent', 'connected', 'arithmetic progression', 'flips', 'binary', 'count', 'string', 'concatenating', 'bitwise', 'minimum', 'flipping', 'iteration']", "test_keywords": "['adjacent', 'selling', 'iteration', 'string', 'minimum', 'binary', 'count', 'flipping', 'break']", "prompt_tokens": 587, "total_tokens": 773, "completion_tokens": 186, "completion": "[Question 2]\n\nYou are given a binary string representing the items for sale in a shop. The shopkeeper wants to rearrange the items in such a way that the count of adjacent 1's is minimized. Your task is to write a function to find the minimum count of adjacent 1's after rearranging the items.\n\n[/Question 2]\n\n[Code 2]\n\ndef minAdjacentOnes(s: str) -> int :\n    count = s.count('1')\n    return count - 1 if count > 0 else 0\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minAdjacentOnes(\"101001\")==1\nassert minAdjacentOnes(\"100111\")==2\nassert minAdjacentOnes(\"111110011\")==2\nassert minAdjacentOnes(\"00000\")==0\nassert minAdjacentOnes(\"111010111\")==0\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.773}, {"few_shot_keywords": "['visited', 'ways', 'grid', 'connected', 'DFS', 'length', 'sequence', 'neighbours', 'cells', 'rectangle', 'binary']", "test_keywords": "['sum', 'equality', 'visited', 'DFS', 'connected', 'round', 'cells', 'directional movement', 'tree traversal', 'neighbours', 'binary', 'sequence', 'grid', 'length']", "prompt_tokens": 936, "total_tokens": 1530, "completion_tokens": 594, "completion": "[Question 2]\n\nGiven a binary matrix of size N x M, find the sum of all unique connected cells (neighbours) in the grid. Two cells are connected if they are adjacent horizontally or vertically.\n\n[/Question 2]\n\n[Code 2]\n\ndef isValid(grid, i, j, visited):\n    if i >= 0 and i < len(grid) and j >= 0 and j < len(grid[0]) and not visited[i][j]:\n        return True\n    return False\n\ndef dfs(grid, i, j, visited, total):\n    visited[i][j] = True\n    total[0] += grid[i][j]\n    rows = [-1, 0, 0, 1]\n    cols = [0, -1, 1, 0]\n    for k in range(4):\n        if isValid(grid, i + rows[k], j + cols[k], visited):\n            dfs(grid, i + rows[k], j + cols[k], visited, total)\n\ndef sumOfUniqueConnectedCells(grid):\n    n = len(grid)\n    m = len(grid[0])\n    visited = [[False for _ in range(m)] for _ in range(n)]\n    unique_sums = set()\n    for i in range(n):\n        for j in range(m):\n            if not visited[i][j]:\n                total = [0]\n                dfs(grid, i, j, visited, total)\n                unique_sums.add(total[0])\n    return sum(unique_sums)\n\n[/Code 2]\n\n[Asserts 2]\n\nassert sumOfUniqueConnectedCells([[1, 1, 0, 0, 0],\n                                  [0, 1, 0, 0, 1],\n                                  [1, 0, 0, 1, 1],\n                                  [0, 0, 0, 0, 0],\n                                  [1, 0, 1, 0, 1]]) == 6\nassert sumOfUniqueConnectedCells([[1, 1, 1, 1, 1],\n                                  [1, 0, 1, 0, 1],\n                                  [1, 1, 0, 1, 1],\n                                  [0, 0, 0, 0, 0],\n                                  [1, 0, 1, 0, 1]]) == 4\nassert sumOfUniqueConnectedCells([[1, 0, 1, 0, 1],\n                                  [0, 1, 0, 1, 0],\n                                  [1, 0, 1, 0, 1],\n                                  [0, 1, 0, 1, 0],\n                                  [1, 0, 1, 0, 1]]) == 2\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.833}, {"few_shot_keywords": "['sorting', 'array', 'absolute difference', 'replace', 'maximum', 'summands', 'subsequence', 'indices']", "test_keywords": "['replace', 'absolute difference', 'color', 'subsequence', 'sorting', 'array', 'maximum']", "prompt_tokens": 665, "total_tokens": 1032, "completion_tokens": 367, "completion": "[Question 2]\n\nYou are given an array of N integers representing colors. The task is to find the maximum absolute difference between the count of two distinct colors after replacing one color with another. A subsequence is a sequence that can be derived from the array by deleting some elements without changing the order of the remaining elements. If there are multiple subsequences satisfying the above condition, then return the count of the first color and the maximum absolute difference.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef maxAbsoluteDifference(arr: List[int], N: int) -> (int, int):\n    color_count = {}\n    for color in arr:\n        if color in color_count:\n            color_count[color] += 1\n        else:\n            color_count[color] = 1\n    colors = list(color_count.keys())\n    max_diff = 0\n    for i in range(len(colors)):\n        for j in range(i+1, len(colors)):\n            diff = abs(color_count[colors[i]] - color_count[colors[j]])\n            max_diff = max(max_diff, diff)\n    return max(color_count.values()), max_diff\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maxAbsoluteDifference([3, 1, 4, 5, 2], 5)==(1, 3)\nassert maxAbsoluteDifference([10, 20, 30, 20, 10], 5)==(3, 20)\nassert maxAbsoluteDifference([1, 1, 1, 2, 2, 3], 6)==(3, 3)\nassert maxAbsoluteDifference([5, 4, 3, 2, 1], 5)==(1, 4)\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.727}, {"few_shot_keywords": "['steps', 'number', 'optimization', 'segments', 'vertex', 'multiplying', 'minimum', 'dynamic programming', 'reach']", "test_keywords": "['reach', 'minimum', 'math', 'optimization', 'flips', 'sum', 'dynamic programming', 'edge weights', 'steps', 'multiplying', 'expression', 'number']", "prompt_tokens": 479, "total_tokens": 760, "completion_tokens": 281, "completion": "[Question 2]\n\nYou are given an array of numbers representing the edge weights of a graph. Your task is to find the minimum sum of edge weights required to reach from vertex 1 to vertex N, where each vertex represents a step and the edge weights represent the number of flips needed to reach the next step. Use dynamic programming for optimization.\n\n[/Question 2]\n\n[Code 2]\n\ndef minSumEdgeWeightsToReachN(weights):\n    n = len(weights)\n    dp = [float('inf')] * n\n    dp[0] = 0\n    for i in range(1, n):\n        for j in range(i):\n            dp[i] = min(dp[i], dp[j] + weights[i - j])\n    return dp[n - 1]\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minSumEdgeWeightsToReachN([1, 2, 3, 4, 1, 2])==4\nassert minSumEdgeWeightsToReachN([3, 1, 4, 1, 5, 9, 2, 6])==8\nassert minSumEdgeWeightsToReachN([2, 7, 1, 8, 2, 8, 1, 8, 2, 8, 1])==5\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.712}, {"few_shot_keywords": "['check', 'square', 'width', 'integer', 'number', '0', 'divisible', 'bottom-up', 'function']", "test_keywords": "['non-empty', 'check', 'cube', 'bracket', 'number', 'pop', 'square', 'function', 'divisible', 'integer', 'positive']", "prompt_tokens": 473, "total_tokens": 718, "completion_tokens": 245, "completion": "[Question 2]\n\nWrite a function to check if the cube of a non-empty list of positive integers is divisible by a given number. The list is represented as a bracketed sequence of integers. If the cube is divisible by the given number, return True; otherwise, return False.\n\n[/Question 2]\n\n[Code 2]\n\ndef isCubeDivisible(numbers: List[int], k: int) -> bool:\n    product = 1\n    for num in numbers:\n        product *= num\n    if (product ** 3) % k == 0:\n        return True\n    else:\n        return False\n\n[/Code 2]\n\n[Asserts 2]\n\nassert isCubeDivisible([1, 2, 3], 6)==True\nassert isCubeDivisible([4, 5, 6], 100)==False\nassert isCubeDivisible([2, 2, 2], 8)==True\nassert isCubeDivisible([3, 7, 2], 5)==False\nassert isCubeDivisible([1, 1, 1, 1, 1], 10)==True\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.88}, {"few_shot_keywords": "['nested loop', 'increasing order', 'absolute value', 'max sum', 'integer', 'array', 'expression', 'pairs', 'diagonal', 'minimum value', 'iteration']", "test_keywords": "['pairs', 'expression', 'permutation', 'integer', 'minimum value', 'array', 'absolute value', 'jumps', 'iteration', 'segments', 'nested loop']", "prompt_tokens": 550, "total_tokens": 836, "completion_tokens": 286, "completion": "[Question 2]\n\nYou are given an array of integers representing the heights of walls. Find the minimum number of jumps required to reach the end of the array, where each jump is of length equal to the absolute difference in heights between the current and next wall.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef minJumpsToReachEnd(wall_heights: List[int]) -> int:\n    n = len(wall_heights)\n    jumps = [float('inf')] * n\n    jumps[0] = 0\n    for i in range(1, n):\n        for j in range(i):\n            jump_length = abs(wall_heights[i] - wall_heights[j])\n            if i <= j + jump_length:\n                jumps[i] = min(jumps[i], jumps[j] + 1)\n    return jumps[n-1]\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minJumpsToReachEnd([3, 2, 5, 1, 1, 9, 3, 4]) == 4\nassert minJumpsToReachEnd([1, 2, 3, 4, 5]) == 4\nassert minJumpsToReachEnd([5, 4, 3, 2, 1]) == 4\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.824}, {"few_shot_keywords": "['length', 'maximum', 'costs', 'string', 'circular', 'substring', 'added', 'dictionary', 'characters', 'iteration']", "test_keywords": "['string', 'maximum', 'length', 'flip', 'substring', 'characters', 'iteration', 'dictionary', 'delete']", "prompt_tokens": 550, "total_tokens": 833, "completion_tokens": 283, "completion": "[Question 2]\n\nGiven a string s, the task is to find the maximum length of a substring with at most k deletions allowed.\n\n[/Question 2]\n\n[Code 2]\n\ndef maxSubstrWithKDeletions(s: str, k: int) -> int:\n    start = 0\n    max_length = 0\n    char_map = {}\n    max_repeat_letter_count = 0\n    for end in range(len(s)):\n        char_map[s[end]] = char_map.get(s[end], 0) + 1\n        max_repeat_letter_count = max(max_repeat_letter_count, char_map[s[end]])\n        if (end - start + 1 - max_repeat_letter_count) > k:\n            char_map[s[start]] -= 1\n            start += 1\n        max_length = max(max_length, end - start + 1)\n    return max_length\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maxSubstrWithKDeletions(\"abccde\", 1) == 3\nassert maxSubstrWithKDeletions(\"aabab\", 1) == 4\nassert maxSubstrWithKDeletions(\"abab\", 2) == 4\nassert maxSubstrWithKDeletions(\"abcde\", 0) == 1\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.861}, {"few_shot_keywords": "['division', 'even', 'cell', 'minimum', 'operations', 'condition', 'impossible', 'represent', 'while loop', 'placement', 'array', 'integers']", "test_keywords": "['integers', 'division', 'minimum', 'array', 'impossible', 'operations', 'divisible', 'combinatorics', 'even']", "prompt_tokens": 649, "total_tokens": 953, "completion_tokens": 304, "completion": "[Question 2]\n\nGiven an array of integers, your task is to find the minimum number of operations required to make every element of the array divisible by a given number K. If it is impossible to make all elements divisible by K, then return -1.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef makeDivisibleByK(arr: List[int], K: int) -> int:\n    count = 0\n    for num in arr:\n        if num % K != 0:\n            count += 1\n    if count == 0:\n        return 0\n    elif all(num % K == 0 for num in arr):\n        return 0\n    elif count == len(arr):\n        return -1\n    else:\n        return K - max(num % K for num in arr)\n\n[/Code 2]\n\n[Asserts 2]\n\nassert makeDivisibleByK([4, 7, 9, 12, 15, 18], 3) == 1\nassert makeDivisibleByK([2, 4, 6, 8, 10], 5) == 0\nassert makeDivisibleByK([3, 5, 7, 9, 11], 2) == -1\nassert makeDivisibleByK([15, 25, 35, 45, 55], 10) == 0\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.759}, {"few_shot_keywords": "['round', 'integer', 'array', 'pairs', 'difference', 'convert', 'repeated']", "test_keywords": "['repeated', 'array', 'difference', 'pairs', 'destination', 'valid', 'integer', 'shortest']", "prompt_tokens": 584, "total_tokens": 956, "completion_tokens": 372, "completion": "[Question 2]\n\nGiven an array of integers representing distances to a destination, find the shortest valid pair of distances with a difference less than or equal to a given value, K. A valid pair is one where no element is repeated.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List, Tuple\ndef shortestValidPair(arr: List[int], K: int) -> Tuple[int, int]:\n    arr.sort()\n    min_diff = float('inf')\n    pair = ()\n    for i in range(len(arr)-1):\n        for j in range(i+1, len(arr)):\n            if abs(arr[j] - arr[i]) <= K and arr[i] != arr[j]:\n                if arr[j] - arr[i] < min_diff:\n                    min_diff = arr[j] - arr[i]\n                    pair = (arr[i], arr[j])\n    return pair\n\n[/Code 2]\n\n[Asserts 2]\n\nassert shortestValidPair([1, 3, 5, 6, 7, 10, 12], 2) == (5, 7)\nassert shortestValidPair([1, 3, 5, 6, 7, 10, 12], 3) == (3, 6)\nassert shortestValidPair([1, 3, 5, 6, 7, 10, 12], 4) == (1, 5)\nassert shortestValidPair([1, 3, 5, 6, 7, 10, 12], 5) == (1, 6)\nassert shortestValidPair([1, 3, 5, 6, 7, 10, 12], 6) == (5, 12)\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.877}, {"few_shot_keywords": "['sums', 'indexing', 'profit', 'selling', 'width', 'market', 'maximization', 'price', 'list']", "test_keywords": "['merge', 'market', 'profit', 'subsequences', 'maximization', 'price', 'smallest', 'selling', 'split']", "prompt_tokens": 607, "total_tokens": 988, "completion_tokens": 381, "completion": "[Question 2]\n\nYou are given a list of prices representing the cost of a stock on each day. Your task is to split the list into two non-empty subsequences in such a way that the profit obtained by selling the stock at the market is maximized. You can only merge the two subsequences in such a way that the smallest price comes before the largest price.\n\n[/Question 2]\n\n[Code 2]\n\ndef maxProfitSplit(prices):\n    maxProfit = 0\n    for i in range(len(prices)):\n        left = maxProfitFromPrefix(prices[:i+1])\n        right = maxProfitFromSuffix(prices[i:])\n        maxProfit = max(maxProfit, left + right)\n    return maxProfit\n\ndef maxProfitFromPrefix(prices):\n    maxProfit = 0\n    minPrice = float('inf')\n    for price in prices:\n        minPrice = min(minPrice, price)\n        maxProfit = max(maxProfit, price - minPrice)\n    return maxProfit\n\ndef maxProfitFromSuffix(prices):\n    maxProfit = 0\n    maxPrice = float('-inf')\n    for price in prices[::-1]:\n        maxPrice = max(maxPrice, price)\n        maxProfit = max(maxProfit, maxPrice - price)\n    return maxProfit\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maxProfitSplit([7, 1, 5, 3, 6, 4]) == 7\nassert maxProfitSplit([7, 6, 4, 3, 1]) == 0\nassert maxProfitSplit([3, 3, 5, 0, 0, 3, 1, 4]) == 6\nassert maxProfitSplit([1, 2, 3, 4, 5]) == 4", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.946}, {"few_shot_keywords": "['minimum', 'edges', 'allowed', 'rotation', 'string', 'triangle', 'graph', 'added', 'abs', 'vertices', 'while loop', 'adjacency matrix']", "test_keywords": "['edges', 'added', 'graph', 'adjacency matrix', 'triangle', 'diagonal', 'minimum', 'vertices']", "prompt_tokens": 762, "total_tokens": 1221, "completion_tokens": 459, "completion": "[Question 2]\n\nGiven an undirected graph with N vertices and an adjacency matrix, write a function to determine the minimum number of edges that need to be added to the graph to form a triangle such that the added edges do not form any additional triangles.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\ndef minEdgesToAddForUniqueTriangle(N: int, adj_matrix: List[List[int]]) -> int:\n    count = 0\n    \n    for i in range(N):\n        for j in range(i+1, N):\n            if adj_matrix[i][j] == 0:\n                for k in range(j+1, N):\n                    if adj_matrix[i][k] == 1 and adj_matrix[j][k] == 1:\n                        count += 1\n    return count\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minEdgesToAddForUniqueTriangle(4, [[0, 1, 1, 0], [1, 0, 1, 0], [1, 1, 0, 0], [0, 0, 0, 0]]) == 1\nassert minEdgesToAddForUniqueTriangle(5, [[0, 1, 0, 1, 0], [1, 0, 1, 0, 0], [0, 1, 0, 1, 0], [1, 0, 1, 0, 0], [0, 0, 0, 0, 0]]) == 4\nassert minEdgesToAddForUniqueTriangle(4, [[0, 1, 1, 0], [1, 0, 0, 1], [1, 0, 0, 1], [0, 1, 1, 0]]) == 0\nassert minEdgesToAddForUniqueTriangle(4, [[0, 1, 1, 1], [1, 0, 0, 0], [1, 0, 0, 0], [1, 0, 0, 0]]) == 0\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.76}, {"few_shot_keywords": "['length', 'combination', 'array', 'adjacent', 'mountain', 'non-zero', 'max', 'frequency', 'xor', 'subsequence', 'less than', 'subtract']", "test_keywords": "['max', 'price', 'array', 'length', 'heads', 'non-zero', 'frequency', 'xor', 'subsequence', 'adjacent']", "prompt_tokens": 639, "total_tokens": 935, "completion_tokens": 296, "completion": "[Question 2]\n\nGiven an array 'prices' of length N, representing the prices of a stock on consecutive days, the task is to find the maximum profit that can be obtained by buying and selling the stock on different days. The constraint is that the xor of the prices on the selected days should be non-zero.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef maxProfitWithNonZeroXor(prices: List[int]) -> int:\n    n = len(prices)\n    max_profit = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if prices[i] ^ prices[j] != 0:\n                max_profit = max(max_profit, prices[j] - prices[i])\n    return max_profit\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maxProfitWithNonZeroXor([7, 1, 5, 3, 6, 4]) == 5\nassert maxProfitWithNonZeroXor([7, 6, 4, 3, 1]) == 0\nassert maxProfitWithNonZeroXor([3, 8, 1, 2, 9, 10]) == 7\nassert maxProfitWithNonZeroXor([10, 2, 8, 4, 6, 7]) == 6\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.743}, {"few_shot_keywords": "['difference', 'graph', 'tree', 'subtrees', 'price', 'minimized', 'maximize', 'order of operations', 'combination', 'delete', 'dfs', 'leaf node', 'edges', 'weights']", "test_keywords": "['destination', 'source', 'weights', 'subproblems', 'delete', 'divisibility', 'minimized', 'subtrees', 'dfs', 'difference', 'graph', 'tree', 'even', 'edges']", "prompt_tokens": 889, "total_tokens": 1522, "completion_tokens": 633, "completion": "[Question 2]\n\nYou are given a weighted directed graph with n nodes and m edges. Each node of the graph has an associated weight. The task is to find the minimum weight to delete from the graph such that for every source node and destination node pair, there exists a path from the source to the destination with the sum of weights of all edges in the path being divisible by a given number k.\n\nWrite a function *minDeleteWeight* that takes in the number of nodes n, the number of edges m, a list of edges where each edge is represented as (source, destination, weight), a list of weights of each node, and an integer k. The function should return the minimum weight that needs to be deleted to satisfy the given condition.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List, Tuple\n\ndef minDeleteWeight(n: int, m: int, edges: List[Tuple[int, int, int]], weights: List[int], k: int) -> int:\n\n  graph = {i: [] for i in range(n)}\n  for edge in edges:\n    graph[edge[0]].append((edge[1], edge[2]))\n\n  def dfs(node, weight):\n    subproblems = {}\n    for neighbor, w in graph[node]:\n      if (node, neighbor) in subproblems:\n        continue\n      subproblems.update(dfs(neighbor, (weight + w) % k))\n    if weight % k in subproblems:\n      subproblems[weight % k] = min(subproblems[weight % k], weight)\n    else:\n      subproblems[weight % k] = weight\n    return subproblems\n\n  subproblems = dfs(0, 0)\n  result = float('inf')\n\n  for i in range(n):\n    for j in range(k):\n      if i == 0 and j == 0:\n        continue\n      if j in subproblems:\n        result = min(result, (subproblems[j] - j + k) // k * k - weights[i])\n\n  return result\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minDeleteWeight(4, 4, [(0, 1, 3), (1, 2, 6), (2, 3, 9), (3, 0, 12)], [1, 2, 3, 4], 5) == 1\nassert minDeleteWeight(5, 5, [(0, 1, 5), (1, 2, 10), (2, 3, 15), (3, 4, 20), (4, 0, 25)], [1, 3, 5, 7, 9], 7) == 3\nassert minDeleteWeight(3, 3, [(0, 1, 1), (1, 2, 1), (2, 0, 1)], [2, 2, 2], 3) == 0\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.711}, {"few_shot_keywords": "['greater', 'repetitive', '2D array', 'equal', 'addition', 'allowed', 'than', 'increment', 'operation', 'integer', 'movement', 'array', 'minimum', 'value', 'adjacent']", "test_keywords": "['value', 'loop', 'minimum', 'increment', 'greater', 'equal', 'than', 'integer', 'operation', 'forward', 'allowed', 'array']", "prompt_tokens": 523, "total_tokens": 763, "completion_tokens": 240, "completion": "[Question 2]\n\nWrite a function to find the minimum value in a 2D array. The 2D array consists of integers and the minimum value is to be found by incrementing through the array in a forward direction using a loop. The allowed operation is to compare the current value with the minimum value found so far and update the minimum value if the current value is lesser or equal to it.\n\n[/Question 2]\n\n[Code 2]\n\ndef findMinimumValue(arr):\n    min_val = float('inf')\n    for row in arr:\n        for val in row:\n            if val <= min_val:\n                min_val = val\n    return min_val\n\n[/Code 2]\n\n[Asserts 2]\n\nassert findMinimumValue([[3, 5, 2], [7, 1, 8], [4, 9, 6]]) == 1\nassert findMinimumValue([[10, 8, 12], [15, 17, 13]]) == 8\nassert findMinimumValue([[20, 25], [18, 22], [30, 27]]) == 18\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.882}, {"few_shot_keywords": "['iteration', 'character', 'string', 'smallest', 'visited', 'alphabet', 'multiple times', 'comparison', 'conditional', 'same', 'lexicographically']", "test_keywords": "['lexicographically', 'nested loop', 'odd', 'comparison', 'concatenation', 'iteration', 'smallest', 'subset', 'bitwise OR', 'string', 'alphabet', 'character', 'conditional']", "prompt_tokens": 610, "total_tokens": 863, "completion_tokens": 253, "completion": "[Question 2]\n\nGiven a list of strings, find the lexicographically smallest string that can be formed by concatenating a subset of strings together. A subset can be formed by taking odd number of strings from the given list.\n\nWrite a function to accomplish this using nested loop iteration and bitwise OR comparison.\n\n[/Question 2]\n\n[Code 2]\n\nfrom itertools import combinations\n\ndef smallestLexicographicallySubset(strings: List[str]) -> str:\n    n = len(strings)\n    result = \"z\" * 30\n    for i in range(1, n+1, 2):\n        for combo in combinations(strings, i):\n            temp = \"\".join(combo)\n            result = min(result, temp)\n    return result\n\n[/Code 2]\n\n[Asserts 2]\n\nassert smallestLexicographicallySubset([\"abc\", \"def\", \"xyz\"]) == \"abcdefxyz\"\nassert smallestLexicographicallySubset([\"apple\", \"banana\", \"cat\", \"dog\"]) == \"applecatdog\"\nassert smallestLexicographicallySubset([\"a\", \"b\", \"c\", \"d\"]) == \"a\"\nassert smallestLexicographicallySubset([\"aaa\", \"aab\", \"aac\"]) == \"aaa\"\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.903}, {"few_shot_keywords": "['alphabets', 'counting', 'multiple', 'digits', 'loop', 'representation', 'integer', 'move', 'ASCII']", "test_keywords": "['representation', 'difference', 'digits', 'alphabets', 'dfs', 'divisible', 'counting', 'tree traversal', 'integer', 'ASCII', 'loop', 'turns']", "prompt_tokens": 515, "total_tokens": 728, "completion_tokens": 213, "completion": "[Question 2]\n\nGiven an integer N, find the difference between the count of digits and the count of English alphabets in the ASCII representation of N. For example, if N is 123ABC, the count of digits is 3 and the count of alphabets is 3, so the difference is 0.\n\n[/Question 2]\n\n[Code 2]\n\ndef countDifference(N: str) -> int:\n    digit_count = 0\n    alphabet_count = 0\n    for char in N:\n        if char.isdigit():\n            digit_count += 1\n        elif char.isalpha():\n            alphabet_count += 1\n    return digit_count - alphabet_count\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countDifference(\"123ABC\") == 0\nassert countDifference(\"456DEF\") == 0\nassert countDifference(\"12AB\") == 1\nassert countDifference(\"ABCD\") == -4\nassert countDifference(\"1234\") == 4\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.835}, {"few_shot_keywords": "['ASCII', 'largest', 'set bits', 'binary', 'positive', 'integer', 'alphabet', 'less than', 'at most', 'forming']", "test_keywords": "['cross', 'binary', 'less than', 'delete', 'non-zero', 'largest', 'forming', 'range', 'at most', 'minimize', 'positive', 'integer', 'set bits']", "prompt_tokens": 527, "total_tokens": 832, "completion_tokens": 305, "completion": "[Question 2]\n\nGiven a positive integer N and an integer K, the task is to minimize the number of set bits in the binary representation of N by deleting at most K non-zero bits, and then find the largest number that can be formed.\n\n[/Question 2]\n\n[Code 2]\n\ndef minimizeSetBitsAndFindLargest(N: int, K: int) -> int:\n    binary = bin(N)[2:]\n    non_zero_indices = [i for i in range(len(binary)) if binary[i] == '1']\n    while K > 0 and non_zero_indices:\n        idx_to_remove = non_zero_indices[0]\n        if idx_to_remove + 1 < len(binary) and non_zero_indices[0] + 1 == non_zero_indices[1]:\n            idx_to_remove = non_zero_indices[1]\n        non_zero_indices.remove(idx_to_remove)\n        binary = binary[:idx_to_remove] + '0' + binary[idx_to_remove+1:]\n        K -= 1\n    return int(binary, 2)\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minimizeSetBitsAndFindLargest(14, 2) == 12\nassert minimizeSetBitsAndFindLargest(50, 3) == 32\nassert minimizeSetBitsAndFindLargest(101, 1) == 64\nassert minimizeSetBitsAndFindLargest(25, 5) == 0\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.828}, {"few_shot_keywords": "['turn', 'minimum', 'bfs', 'moves', 'shortest-path', 'graph', 'binary tree', 'matrix', 'vertex']", "test_keywords": "['shortest-path', 'graph', 'powers', 'moves', 'matrix', 'minimum', 'ways', 'bfs', 'boolean']", "prompt_tokens": 809, "total_tokens": 1254, "completion_tokens": 445, "completion": "[Question 2]\n\nYou are given a boolean matrix where a cell with True represents a blockage and a cell with False represents an open path. Find the minimum number of moves needed to reach from the top-left corner of the matrix to the bottom-right corner, considering only the available open paths (cells with False). You can move either right or down at each step.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\nfrom collections import deque\n\ndef minMoves(matrix: List[List[bool]]) -> int:\n    m, n = len(matrix), len(matrix[0])\n    if matrix[0][0] or matrix[m-1][n-1]:\n        return -1\n    \n    queue = deque([(0, 0, 0)])\n    visited = set([(0, 0)])\n    \n    while queue:\n        x, y, moves = queue.popleft()\n        if (x, y) == (m-1, n-1):\n            return moves\n        for dx, dy in [(1, 0), (0, 1)]:\n            new_x, new_y = x + dx, y + dy\n            if 0 <= new_x < m and 0 <= new_y < n and not matrix[new_x][new_y] and (new_x, new_y) not in visited:\n                queue.append((new_x, new_y, moves+1))\n                visited.add((new_x, new_y))\n    \n    return -1\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minMoves([[False, False, True, False], [False, False, False, True], [True, False, False, False], [False, True, False, False]]) == 5\nassert minMoves([[False, False, True, False], [False, False, False, True], [True, False, False, False]]) == -1\nassert minMoves([[False, False], [False, False]]) == 1\nassert minMoves([[False, False, False], [False, False, False], [False, False, False]]) == 2\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.912}, {"few_shot_keywords": "['sum', 'distinct', 'weight', 'math', 'smallest', 'GCD', 'integer']", "test_keywords": "['math', 'sum', 'GCD', 'selection', 'alphabet', 'smallest', 'target amount', 'integer']", "prompt_tokens": 573, "total_tokens": 928, "completion_tokens": 355, "completion": "[Question 2]\n\nYou are given a list of integers and a target amount. Write a function findClosestSum(nums, target) to find the sum of two integers from the list that is closest to the target amount. If there are multiple solutions, return the sum with the smallest absolute difference from the target.\n\n[/Question 2]\n\n[Code 2]\n\ndef findClosestSum(nums, target):\n    nums.sort()\n    left, right = 0, len(nums) - 1\n    closest_sum = float('inf')\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if abs(target - current_sum) < abs(target - closest_sum):\n            closest_sum = current_sum\n        if current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return closest_sum\n\n[/Code 2]\n\n[Asserts 2]\n\nassert findClosestSum([1, 2, 3, 4, 5], 8) == 7\nassert findClosestSum([3, 7, 9, 2, 10], 5) == 5\nassert findClosestSum([10, 20, 30, 40, 50], 35) == 30\nassert findClosestSum([5, 15, 25, 35, 45], 30) == 30\nassert findClosestSum([17, 23, 11, 24, 19], 20) == 21\nassert findClosestSum([8, 12, 15, 20, 25], 22) == 23\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.891}, {"few_shot_keywords": "['repetition', 'bisect', 'cities', 'distance', 'diagonal', 'permutation', 'coordinates', 'sort', 'nearest', 'max distance', 'station', 'ASCII']", "test_keywords": "['cities', 'sign', 'coordinates', 'distance', 'nearest', 'connectivity', 'station', 'sort', 'bisect', 'max distance']", "prompt_tokens": 593, "total_tokens": 827, "completion_tokens": 234, "completion": "[Question 2]\n\nYou are given the coordinates of different cities and their distances from a central station. Write a program to find the nearest city to the station based on the sign of the distance.\n\n[/Question 2]\n\n[Code 2]\n\nimport bisect\n\ndef nearestCity(cities: list, distances: list) -> str:\n    pairs = list(zip(cities, distances))\n    pairs.sort(key=lambda x: abs(x[1]))\n    return pairs[0][0]\n\n[/Code 2]\n\n[Asserts 2]\n\nassert nearestCity([\"A\", \"B\", \"C\", \"D\"], [10, -5, 8, -12]) == \"B\"\nassert nearestCity([\"X\", \"Y\", \"Z\"], [-3, -7, -2]) == \"Z\"\nassert nearestCity([\"P\", \"Q\", \"R\", \"S\", \"T\"], [20, 15, -18, 25, -30]) == \"R\"\nassert nearestCity([\"M\", \"N\", \"O\"], [5, 5, 5]) == \"M\"\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.703}, {"few_shot_keywords": "['source', 'array', 'difference', 'subsets', 'connected component', 'update', 'integer', 'non-empty', 'divide', 'minimum']", "test_keywords": "['difference', 'array', 'minimum', 'market', 'subsets', 'non-empty', 'Longest Common Subsequence', 'divide', 'integer']", "prompt_tokens": 559, "total_tokens": 903, "completion_tokens": 344, "completion": "[Question 2]\n\nYou are given two integer arrays, nums1 and nums2. Write a function to find the length of the longest common subsequence with the minimum difference between the elements from the two arrays.\n\n[/Question 2]\n\n[Code 2]\n\ndef longestCommonSubsequence(nums1: List[int], nums2: List[int]) -> int:\n    m, n = len(nums1), len(nums2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    \n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if nums1[i-1] == nums2[j-1]:\n                dp[i][j] = 1 + dp[i-1][j-1]\n            else:\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n    \n    return dp[m][n]\n\n[/Code 2]\n\n[Asserts 2]\n\nassert longestCommonSubsequence([1, 2, 3, 4, 7], [2, 3, 4, 5]) == 3\nassert longestCommonSubsequence([10, 9, 2, 5, 3, 7, 101, 18], [10, 9, 2, 5, 3, 7, 101, 18]) == 7\nassert longestCommonSubsequence([0, 0, 0, 0, 0], [0, 0, 0, 0, 0]) == 5", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.77}, {"few_shot_keywords": "['character count', 'repeatedly', 'odd occurrences', 'rearrange', 'connected', 'palindrome', 'time', 'string', 'difference', 'flip']", "test_keywords": "['palindrome', 'odd occurrences', 'string', 'binary tree', 'sort', 'rearrange', 'character count']", "prompt_tokens": 569, "total_tokens": 826, "completion_tokens": 257, "completion": "[Question 2]\n\nGiven a string, the task is to check if the given string could be rearranged to form a palindrome. A string is said to be a palindrome, if on rearranging the letters of the string we get the original string. The input string may contain lowercase alphabets and digits.\n\nWrite a function that takes a string as input and returns True if the string could be rearranged to form a palindrome, otherwise False.\n\n[/Question 2]\n\n[Code 2]\n\ndef canFormPalindrome(s: str) -> bool:\n    char_count = [0]*256\n    for i in s:\n        char_count[ord(i)] += 1\n    odd_count = 0\n    for count in char_count:\n        if count % 2 != 0:\n            odd_count += 1\n        if odd_count > 1:\n            return False\n    return True\n\n[/Code 2]\n\n[Asserts 2]\n\nassert canFormPalindrome(\"aab\") == True\nassert canFormPalindrome(\"carerac\") == True\nassert canFormPalindrome(\"carrace\") == False\nassert canFormPalindrome(\"hello\") == False\nassert canFormPalindrome(\"aabbcc\") == True\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.859}, {"few_shot_keywords": "['integers', 'tiles', 'consecutive', 'sum', 'common', 'array', 'sorting', 'difference', 'coins']", "test_keywords": "['consecutive', 'integers', 'sum', 'difference', 'sorting', 'equality', 'permutation', 'array']", "prompt_tokens": 496, "total_tokens": 747, "completion_tokens": 251, "completion": "[Question 2]\n\nGiven an array of integers, determine if there exists a permutation of the array such that the sum of the absolute differences between consecutive elements is equal for all permutations of the array.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef isEqualSumOfDifferences(arr: List[int]) -> bool:\n    arr.sort()\n    n = len(arr)\n    base_sum = abs(arr[0] - arr[1])\n    for i in range(1, n-1):\n        if abs(arr[i] - arr[i+1]) != base_sum:\n            return False\n    return True\n\n[/Code 2]\n\n[Asserts 2]\n\nassert isEqualSumOfDifferences([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]) == True\nassert isEqualSumOfDifferences([5, 7, 9, 13]) == False\nassert isEqualSumOfDifferences([1, 1, 1, 1, 1]) == True\nassert isEqualSumOfDifferences([3, 2, 1]) == True\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.739}, {"few_shot_keywords": "['largest', 'digits', 'number', 'iteration', 'cube', 'positive integers', 'form', 'transformation', 'range', 'delete', 'math', 'optimally']", "test_keywords": "['nodes', 'math', 'node', 'memoization', 'digits', 'shortest-path', 'cube', 'number', 'largest', 'iteration', 'delete', 'transformation', 'form']", "prompt_tokens": 572, "total_tokens": 932, "completion_tokens": 360, "completion": "[Question 2]\n\nGiven a graph with N nodes labeled 1 to N, and a list of edges, the task is to find the shortest path from node 1 to node N such that the product of the digits on the path is the largest possible.\n\n[/Question 2]\n\n[Code 2]\n\nimport heapq\n\ndef largestProductPath(N, edges):\n    graph = {i: [] for i in range(1, N+1)}\n    for start, end, weight in edges:\n        graph[start].append((end, weight))\n        graph[end].append((start, weight))\n    \n    pq = [(-1, 1)]  # Max-heap\n    visited = set()\n    \n    while pq:\n        product, node = heapq.heappop(pq)\n        product *= -1  # Get back the negative product\n        \n        if node == N:\n            return product\n        \n        if node in visited:\n            continue\n        \n        visited.add(node)\n        \n        for neighbor, weight in graph[node]:\n            new_product = product * weight\n            heapq.heappush(pq, (-new_product, neighbor))\n    \n    return -1\n\n[/Code 2]\n\n[Asserts 2]\n\nassert largestProductPath(5, [[1, 2, 2], [2, 3, 3], [3, 4, 4], [4, 5, 5]]) == 40\nassert largestProductPath(3, [[1, 2, 1], [2, 3, 2], [3, 1, 3]]) == 6\nassert largestProductPath(3, [[1, 2, 1], [2, 3, 2]]) == -1", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.89}, {"few_shot_keywords": "['repetitions', 'repetition', 'alphabet', 'sequence', 'adjacent', 'string', 'lexicographical', 'pattern', 'duplicates', 'shortest-path', 'determination', 'heapq', 'modification']", "test_keywords": "['last card', 'pattern', 'possible', 'sequence', 'lexicographical', 'duplicates', 'repeated', 'binary tree', 'adjacent', 'alphabet', 'repetition', 'string', 'market']", "prompt_tokens": 648, "total_tokens": 888, "completion_tokens": 240, "completion": "[Question 2]\n\nYou are given a sequence of playing cards, represented as a string of characters where each character represents a card. Your task is to determine if it's possible to arrange the cards in a lexicographically increasing sequence by repeatedly moving the last card to the beginning of the sequence. Return True if it's possible, otherwise False.\n\n[/Question 2]\n\n[Code 2]\n\ndef isPossibleToArrangeInIncreasingSequence(cards: str) -> bool:\n    count = {}\n    for card in cards:\n        if card in count:\n            count[card] += 1\n        else:\n            count[card] = 1\n    max_count = max(count.values())\n    return max_count == 1\n\n[/Code 2]\n\n[Asserts 2]\n\nassert isPossibleToArrangeInIncreasingSequence(\"abcd\")==True\nassert isPossibleToArrangeInIncreasingSequence(\"acbd\")==False\nassert isPossibleToArrangeInIncreasingSequence(\"aaaabbbb\")==False\nassert isPossibleToArrangeInIncreasingSequence(\"aabbccddeeff\")==True\nassert isPossibleToArrangeInIncreasingSequence(\"aaaabbbccc\")==False\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.713}, {"few_shot_keywords": "['ways', 'circular', 'division', 'movement', 'permutation', 'index', 'array', 'rotation', 'integer', 'distance', 'position']", "test_keywords": "['movement', 'index', 'rotation', 'longest', 'check', 'weights', 'precede', 'distance', 'array', 'circular', 'integer', 'permutation', 'position']", "prompt_tokens": 613, "total_tokens": 968, "completion_tokens": 355, "completion": "[Question 2]\n\nYou are given an array of integers representing weights of different items and an integer k. Your task is to find the maximum weight that can be obtained by taking a circular rotation of the array. A circular rotation means that the last element of the array is treated as coming before the first element. For example, given the array [4, 7, 1, 2] and k=3, a circular rotation would result in the array [1, 2, 4, 7].\n\nWrite a function to find the maximum total weight that can be obtained by circularly rotating the array and taking a contiguous subset of the elements. In other words, you need to find the longest contiguous subset of the circularly rotated array and then calculate the sum of the weights in that subset.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef maxCircularSubsetSum(arr: List[int], k: int) -> int:\n    n = len(arr)\n    max_subarray_sum = float('-inf')\n    \n    for i in range(n):\n        total = 0\n        for j in range(n):\n            total = max(total + arr[(i+j)%n], arr[(i+j)%n])\n            max_subarray_sum = max(max_subarray_sum, total)\n    \n    return max_subarray_sum\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maxCircularSubsetSum([4, 7, 1, 2], 3)==13\nassert maxCircularSubsetSum([1, -2, 3, -2], 2)==3\nassert maxCircularSubsetSum([5, -3, 5], 1)==10\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.864}, {"few_shot_keywords": "['non-decreasing', 'dynamic programming', 'maximized', 'recursion', 'minimum value', 'combinations', 'memoization', 'modulus', 'array', 'backtracking', 'optimum', 'count', 'queries']", "test_keywords": "['count', 'array', 'dynamic programming', 'indices', 'strategy', 'maximized', 'non-decreasing', 'recursion', 'memoization', 'backtracking', 'combinations', 'bracket', 'modulus']", "prompt_tokens": 741, "total_tokens": 971, "completion_tokens": 230, "completion": "[Question 2]\n\nGiven an array of integers, find the count of non-decreasing subarrays of length at least 2.\n\n[/Question 2]\n\n[Code 2]\n\ndef countNonDecreasingSubarrays(arr):\n    n = len(arr)\n    count = 0\n    for i in range(n - 1):\n        if arr[i] <= arr[i + 1]:\n            count += 1\n        else:\n            count += 1\n            j = i + 1\n            while j < n - 1 and arr[j] <= arr[j + 1]:\n                count += 1\n                j += 1\n    return count\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countNonDecreasingSubarrays([1, 2, 3, 2, 2, 3]) == 9\nassert countNonDecreasingSubarrays([4, 3, 2, 1]) == 0\nassert countNonDecreasingSubarrays([1, 1, 1, 1]) == 6\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.758}, {"few_shot_keywords": "['even', 'integer', 'range', 'count', 'frequency', 'digit', 'calculation', 'increasing order']", "test_keywords": "['accessible', 'integer', 'coins', 'maximized', 'frequency', 'calculation', 'range', 'count', 'even', 'precede', 'digit', 'consecutive segments']", "prompt_tokens": 629, "total_tokens": 908, "completion_tokens": 279, "completion": "[Question 2]\n\nYou are given an array of integers representing the frequency of coins of different denominations. Your task is to find the maximum number of coins that can be taken such that the frequency of each digit in the selected coins is even and they form consecutive segments in the array.\n\n[/Question 2]\n\n[Code 2]\n\ndef maxEvenFrequencyCoins(coins):\n    maxCoins = 0\n    length = len(coins)\n    \n    for i in range(length):\n        if coins[i] % 2 == 1:\n            break\n        \n        j = i\n        while j < length and coins[j] % 2 == 0:\n            maxCoins = max(maxCoins, j - i + 1)\n            j += 1\n    \n    return maxCoins\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maxEvenFrequencyCoins([2, 4, 6, 8, 10, 12]) == 6\nassert maxEvenFrequencyCoins([1, 2, 4, 6, 8, 10, 12, 4, 6, 8]) == 4\nassert maxEvenFrequencyCoins([2, 4, 6, 8, 10, 12, 4, 6, 8]) == 9\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.867}, {"few_shot_keywords": "['possible', 'cost', 'target', 'swapping', 'multiple', 'minimize', 'moving', 'string', 'non-empty', 'binary', 'absolute differences']", "test_keywords": "['moving', 'cost', 'binary', 'minimize', 'string', 'swapping', 'update', 'jumps']", "prompt_tokens": 601, "total_tokens": 777, "completion_tokens": 176, "completion": "[Question 2]\n\nGiven a binary string, str, the task is to minimize the cost of updating the string by minimizing the jumps needed to swap adjacent characters.\n\n[/Question 2]\n\n[Code 2]\n\ndef minimizeCost(s: str) -> int:\n    cost = 0\n    for i in range(len(s) - 1):\n        if s[i] != s[i+1]:\n            cost += 1\n    return (cost + 1) // 2\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minimizeCost(\"101010\") == 3\nassert minimizeCost(\"11001100\") == 4\nassert minimizeCost(\"11111111\") == 0\nassert minimizeCost(\"00000000\") == 0\nassert minimizeCost(\"10010010\") == 4\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.788}, {"few_shot_keywords": "['absolute difference', 'dfs', 'multiple times', 'minimum', 'ranges', 'profit', 'array', 'position', 'adjacent', 'elements', 'queries']", "test_keywords": "['elements', 'minimum', 'queries', 'adjacent', 'shortest-path', 'absolute difference', 'mapping', 'ranges', 'array']", "prompt_tokens": 567, "total_tokens": 931, "completion_tokens": 364, "completion": "[Question 2]\n\nYou are given an array of integers and a set of queries, each query consisting of a range. For each query, find the shortest path to map each element in the given range to a minimum absolute difference adjacent element in the array.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List, Tuple\n\ndef shortestPathToMinAbsDiffAdjacent(arr: List[int], queries: List[Tuple[int, int]]) -> List[List[int]]:\n    result = []\n    for query in queries:\n        left, right = query\n        path = []\n        for i in range(left, right):\n            if arr[i+1] - arr[i] < arr[i] - arr[i-1]:\n                path.append(i+1)\n            else:\n                path.append(i-1)\n        result.append(path)\n    return result\n\n[/Code 2]\n\n[Asserts 2]\n\nassert shortestPathToMinAbsDiffAdjacent([1, 5, 3, 9, 11, 15, 12, 7], [(1, 5), (2, 6)]) == [[2, 3, 4, 5], [3, 4, 5, 6]]\nassert shortestPathToMinAbsDiffAdjacent([3, 7, 2, 12, 9, 10, 4, 5, 11, 6], [(0, 4), (4, 7), (2, 8)]) == [[1, 2, 3, 4], [3, 4, 5, 6], [1, 2, 3, 4, 5, 6, 7, 8]]\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.863}, {"few_shot_keywords": "['swaps', 'characters', 'player', 'multiple times', 'adjacent', 'numeric', 'floor', 'flips', 'minimum', 'backtrack', 'string']", "test_keywords": "['minimum', 'flips', 'string', 'deletion', 'expression', 'adjacent', 'characters', 'direction', 'swaps']", "prompt_tokens": 625, "total_tokens": 849, "completion_tokens": 224, "completion": "[Question 2]\n\nGiven a string representing a binary expression, the task is to find the minimum number of flips or deletions of adjacent characters required to make the expression valid. A valid expression is one where the characters are in the correct order, with no adjacent characters representing the same value.\n\n[/Question 2]\n\n[Code 2]\n\ndef minFlipsAndDeletions(s: str) -> int:\n    n = len(s)\n    if n == 0:\n        return 0\n    flips, deletions = 0, 0\n    for i in range(1, n):\n        if s[i] == s[i - 1]:\n            flips += 1\n    deletions = flips // 2\n    return deletions\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minFlipsAndDeletions(\"00110\")==1\nassert minFlipsAndDeletions(\"0001100\")==2\nassert minFlipsAndDeletions(\"111111\")==3\nassert minFlipsAndDeletions(\"0101010\")==0", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.902}, {"few_shot_keywords": "['integer', 'digits', 'sum', 'divisible', 'source', 'movement', 'construct', 'costs', 'positive', 'largest number']", "test_keywords": "['sum', 'positive', 'costs', 'counting', 'width', 'digits', 'construct', 'connected component', 'frequency', 'largest number', 'integer']", "prompt_tokens": 758, "total_tokens": 1204, "completion_tokens": 446, "completion": "[Question 2]\n\nGiven an integer array nums, the task is to construct the largest number by concatenating the elements of the array such that the sum of the costs of its digits is maximum.\n\nThe cost of a digit X is given by the array costs where costs[i] represents the cost of digit (i+1).\n\n[/Question 2]\n\n[Code 2]\n\ndef constructLargestNumber(nums: list, costs: list) -> str:\n    max_cost = 0\n    for num in nums:\n        num_str = str(num)\n        cost = 0\n        for digit in num_str:\n            cost += costs[int(digit) - 1]\n        max_cost += cost\n    \n    max_cost_str = str(max_cost)\n    num_counts = [0]*9\n    for c in max_cost_str:\n        num_counts[int(c) - 1] += 1\n    \n    largest_number = \"\"\n    for i in range(9, -1, -1):\n        largest_number += str(i + 1)*num_counts[i]\n    \n    return largest_number\n\n[/Code 2]\n\n[Asserts 2]\n\nassert constructLargestNumber([3, 30, 34, 5, 9], [1, 100, 3, 2, 7, 9, 4, 6, 5, 8])== \"9534330\"\nassert constructLargestNumber([2, 4, 6, 8], [7, 6, 5, 4, 3, 2, 1, 0, 9])== \"8886642\"\nassert constructLargestNumber([5, 4, 3, 2, 1], [9, 8, 7, 6, 5, 4, 3, 2, 1])== \"11111\"\nassert constructLargestNumber([9, 99, 999, 9999], [1, 2, 3, 4, 5, 6, 7, 8, 9])== \"99999999999999\"\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.814}, {"few_shot_keywords": "['counting', 'concatenating', 'mapping', 'selection', 'while loop', 'subarrays', 'combinations', 'piles', 'largest number', 'array']", "test_keywords": "['top-down', 'sum', 'subarrays', 'counting', 'selection', 'array', 'combinations', 'abs']", "prompt_tokens": 674, "total_tokens": 887, "completion_tokens": 213, "completion": "[Question 2]\n\nGiven an array of integers, we need to find the sum of all possible subarrays of the array and return the sum of absolute values of all subarray sums.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef sumOfAllSubarrays(arr: List[int]) -> int:\n    n = len(arr)\n    result = 0\n    for i in range(n):\n        result += arr[i] * (i + 1) * (n - i)\n    return abs(result)\n\n[/Code 2]\n\n[Asserts 2]\n\nassert sumOfAllSubarrays([1, 2, 3, 4])==50\nassert sumOfAllSubarrays([-1, -2, -3, -4])==50\nassert sumOfAllSubarrays([5, -2, 3, 0, 1])==75\nassert sumOfAllSubarrays([10, 20, 30, 40, 50])==700\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.928}, {"few_shot_keywords": "['maximum', 'count', 'dp', 'minimized', 'distinct', 'task', 'contiguous', 'words', 'allowed', 'changes', 'size', 'vowels']", "test_keywords": "['distinct', 'vowels', 'contiguous', 'words', 'maximum', 'count', 'total', 'task', 'dp', 'consecutive', 'maximize', 'size', 'subproblems', 'allowed']", "prompt_tokens": 621, "total_tokens": 916, "completion_tokens": 295, "completion": "[Question 2]\n\nYou are given a string s and an integer k. The task is to find the maximum total count of distinct k-sized substrings with at most m contiguous vowels.\n\n[/Question 2]\n\n[Code 2]\n\ndef maxDistinctSubstrings(s: str, k: int, m: int) -> int:\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    total_count = 0\n    for i in range(len(s) - k + 1):\n        sub = s[i:i+k]\n        vowel_count = 0\n        distinct_chars = set(sub)\n        for char in sub:\n            if char in vowels:\n                vowel_count += 1\n                if vowel_count > m:\n                    break\n        if vowel_count <= m and len(distinct_chars) == k:\n            total_count += 1\n    return total_count\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maxDistinctSubstrings(\"abcde\", 2, 1) == 2\nassert maxDistinctSubstrings(\"leetcode\", 3, 2) == 2\nassert maxDistinctSubstrings(\"programming\", 4, 1) == 4\nassert maxDistinctSubstrings(\"algorithm\", 3, 1) == 3\nassert maxDistinctSubstrings(\"aieou\", 2, 2) == 1\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.725}, {"few_shot_keywords": "['maximize', 'height', 'placement', 'maximization', 'vertical', 'rectangle', 'boundary', 'width', 'prime numbers', 'horizontal', 'bfs', 'sorting']", "test_keywords": "['forward', 'height', 'sorting', 'boundary', 'maximize', 'vertical', 'rectangle', 'placement', 'memoization', 'horizontal', 'modification', 'width', 'maximization']", "prompt_tokens": 671, "total_tokens": 1102, "completion_tokens": 431, "completion": "[Question 2]\n\nYou are given an array of N integers representing the heights of a set of vertical posts. You can perform modifications on the heights of these posts to maximize the total area formed by the rectangle(s) with the maximum height.\n\nWrite a function to calculate the maximum area that can be formed by the rectangle(s) with the maximum height after performing the minimum number of modifications on the heights of the posts.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef maxAreaWithModifications(heights: List[int]) -> int:\n    n = len(heights)\n    left, right = [0] * n, [0] * n\n    stack = []\n    for i in range(n):\n        while stack and heights[stack[-1]] >= heights[i]:\n            stack.pop()\n        if stack:\n            left[i] = stack[-1] + 1\n        else:\n            left[i] = 0\n        stack.append(i)\n    stack = []\n    for i in range(n - 1, -1, -1):\n        while stack and heights[stack[-1]] >= heights[i]:\n            stack.pop()\n        if stack:\n            right[i] = stack[-1] - 1\n        else:\n            right[i] = n - 1\n        stack.append(i)\n    maxArea = 0\n    for i in range(n):\n        maxArea = max(maxArea, heights[i] * (right[i] - left[i] + 1))\n    return maxArea\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maxAreaWithModifications([2, 1, 3, 5, 6, 2, 3])==10\nassert maxAreaWithModifications([1, 2, 3, 4, 5])==9\nassert maxAreaWithModifications([5, 4, 3, 2, 1])==9\nassert maxAreaWithModifications([3, 1, 3, 2, 2])==6\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.781}, {"few_shot_keywords": "['divisibility', 'natural numbers', 'price', 'combinations', 'count', 'integer', 'nearest', 'dynamic programming', 'scoring', 'height', 'sum', 'repetitions', 'represent']", "test_keywords": "['concatenation', 'count', 'integer', 'natural numbers', 'sum', 'dynamic programming', 'recursive', 'scale', 'represent', 'repetitions', 'combinations']", "prompt_tokens": 561, "total_tokens": 804, "completion_tokens": 243, "completion": "[Question 2]\n\nGiven a list of integers, the task is to find the count of all possible unique combinations of the integers where the sum of each combination is equal to a given target integer.\n\n[/Question 2]\n\n[Code 2]\n\ndef combinationSumCount(nums: List[int], target: int) -> int:\n    dp = [0] * (target + 1)\n    dp[0] = 1\n    for num in nums:\n        for i in range(num, target + 1):\n            dp[i] += dp[i - num]\n    return dp[target]\n\n[/Code 2]\n\n[Asserts 2]\n\nassert(combinationSumCount([2, 3, 5], 8)) == 3\nassert(combinationSumCount([2, 3, 6, 7], 7)) == 2\nassert(combinationSumCount([2, 3, 6, 7], 11)) == 4\nassert(combinationSumCount([3, 5, 7], 8)) == 2\nassert(combinationSumCount([2], 1)) == 0\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.723}, {"few_shot_keywords": "['array', 'consecutive elements', 'queries', 'set', 'subarray', 'logic', 'difference', 'pattern', 'combinatorics', 'arithmetic progression']", "test_keywords": "['2D array', 'minimum', 'odd occurrences', 'difference', 'consecutive elements', 'arithmetic progression', 'queries', 'array', 'maximization', 'subarray']", "prompt_tokens": 588, "total_tokens": 1046, "completion_tokens": 458, "completion": "[Question 2]\n\nYou are given a 2D array and a set of queries. Each query consists of two integers L and R. The task is to find the subarray within the range L to R inclusive that maximizes the difference between the minimum and the odd occurrences of elements in the subarray. The difference is calculated for consecutive elements in the subarray.\n\n[/Question 2]\n\n[Code 2]\n\ndef maxDifferenceSubarray(arr, L, R):\n    max_diff = float('-inf')\n    for i in range(L, R+1):\n        for j in range(i, R+1):\n            min_val = min(arr[i:j+1])\n            odd_count = sum(1 for x in arr[i:j+1] if x % 2 != 0)\n            diff = min_val - odd_count\n            max_diff = max(max_diff, diff)\n    return max_diff\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maxDifferenceSubarray([[2, 3, 5, 7], [4, 6, 8, 10], [1, 9, 11, 13]], 0, 1) == 1\nassert maxDifferenceSubarray([[2, 3, 5, 7], [4, 6, 8, 10], [1, 9, 11, 13]], 0, 2) == 2\nassert maxDifferenceSubarray([[2, 3, 5, 7], [4, 6, 8, 10], [1, 9, 11, 13]], 1, 2) == 2\nassert maxDifferenceSubarray([[1, 2, 3, 4], [7, 8, 9, 10], [13, 14, 15, 16]], 0, 2) == 2\nassert maxDifferenceSubarray([[1, 2, 3, 4], [7, 8, 9, 10], [13, 14, 15, 16]], 1, 2) == 2\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.703}, {"few_shot_keywords": "['distant', 'LCM', 'integers', 'sum', 'subsequence', 'forming', 'elements', 'array', 'maximum']", "test_keywords": "['elements', 'ASCII', 'array', 'mapping', 'half', 'subsequence', 'sum', 'maximum', 'integers', 'distant', 'alphabet']", "prompt_tokens": 579, "total_tokens": 981, "completion_tokens": 402, "completion": "[Question 2]\n\nGiven an array of integers and an alphabet mapping where each alphabet is mapped to an ASCII value, the task is to find the maximum sum of ASCII values of a subsequence of the array such that the sum of ASCII values of the subsequence is at most half of the maximum possible sum of ASCII values of all elements.\n\n[/Question 2]\n\n[Code 2]\n\ndef maxAsciiSumSubseq(arr: list, alphabet_mapping: dict) -> int:\n    max_sum = max(arr)\n    half_max_sum = max_sum // 2\n    result = 0\n    for num in arr:\n        if alphabet_mapping.get(num):\n            ascii_val = alphabet_mapping[num]\n            if ascii_val <= half_max_sum:\n                result = max(result, ascii_val)\n    return result\n\n[/Code 2]\n\n[Asserts 2]\n\nassert(maxAsciiSumSubseq([1, 2, 3, 4, 5], {'a': 97, 'b': 98, 'c': 99})) == 99\nassert(maxAsciiSumSubseq([3, 8, 10, 20, 30, 50, 70], {'a': 97, 'b': 98, 'c': 99}) == 99\nassert(maxAsciiSumSubseq([10, 3, 8, 6, 12], {'a': 97, 'b': 98, 'c': 99}) == 99\nassert(maxAsciiSumSubseq([65, 66, 67, 68, 69], {'A': 65, 'B': 66, 'C': 67}) == 67\nassert(maxAsciiSumSubseq([120, 121, 122, 123, 124], {'x': 120, 'y': 121, 'z': 122}) == 122\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.775}, {"few_shot_keywords": "['tree', 'loop', 'multiplication', 'division', 'product', 'optimization', 'digits', 'count', 'representation', 'range']", "test_keywords": "['range', 'forward', 'height', 'product', 'digits', 'loop', 'division', 'multiplication', 'abs', '2D array', 'count']", "prompt_tokens": 529, "total_tokens": 941, "completion_tokens": 412, "completion": "[Question 2]\n\nYou are given a 2D array representing the heights of a terrain. You need to write a function to calculate the total product of the differences in height when moving from the top-left corner of the terrain to the bottom-right corner, only moving in the forward or downward direction. \n\n[/Question 2]\n\n[Code 2]\n\ndef calculateTerrainProduct(terrain: List[List[int]]) -> int:\n    m, n = len(terrain), len(terrain[0])\n    dp = [[0] * n for _ in range(m)]\n    \n    dp[0][0] = 1\n    \n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] * abs(terrain[i][0] - terrain[i-1][0])\n        \n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] * abs(terrain[0][j] - terrain[0][j-1])\n        \n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i-1][j] * abs(terrain[i][j] - terrain[i-1][j]), dp[i][j-1] * abs(terrain[i][j] - terrain[i][j-1]))\n            \n    return dp[m-1][n-1]\n\n[/Code 2]\n\n[Asserts 2]\n\nterrain1 = [\n    [3, 4, 5],\n    [2, 3, 4],\n    [1, 2, 3]\n]\n\nterrain2 = [\n    [1, 2, 3, 4],\n    [2, 3, 4, 5],\n    [3, 4, 5, 6]\n]\n\nassert calculateTerrainProduct(terrain1) == 2\nassert calculateTerrainProduct(terrain2) == 18", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.841}, {"few_shot_keywords": "['inserting', 'DFS', 'bitwise OR', 'subtree', 'node', 'divisibility', 'query', 'connected', 'tree']", "test_keywords": "['query', '0', 'subtree', 'tree', 'bitwise OR', 'characters', 'DFS', 'shortest distance', 'node', 'prime']", "prompt_tokens": 753, "total_tokens": 1257, "completion_tokens": 504, "completion": "[Question 2]\n\nYou are given a tree with N nodes numbered from 1 to N and a string S of length N, where S[i] represents the character associated with the ith node. You are also given Q queries, where each query consists of a node X. For each query, you have to find the shortest distance to a node in the subtree rooted at X such that the bitwise OR of the characters in the path from the root to that node is a prime number. If there is no such node in the subtree, return -1.\n\nWrite a function to solve the above problem and answer the queries.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List, Tuple\nimport math\n\nclass TreeNode:\n    def __init__(self, char: str):\n        self.char = char\n        self.children = []\n\ndef is_prime(n: int) -> bool:\n    if n <= 1:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef shortest_distance_to_prime_or(root: TreeNode, s: str, queries: List[int]) -> List[int]:\n    result = []\n    \n    def dfs(node: TreeNode, parent_or: int, distance: int) -> int:\n        current_or = ord(node.char)\n        current_or |= parent_or\n        if is_prime(current_or):\n            return distance\n        \n        min_distance = float('inf')\n        for child in node.children:\n            child_distance = dfs(child, current_or, distance + 1)\n            min_distance = min(min_distance, child_distance)\n        \n        return min_distance\n    \n    for query in queries:\n        result.append(dfs(root, 0, 0))\n    \n    return result\n\n[/Code 2]\n\n[Asserts 2]\n\nroot = TreeNode('A')\nroot.children = [TreeNode('B'), TreeNode('C'), TreeNode('D')]\nroot.children[0].children = [TreeNode('E'), TreeNode('F')]\nroot.children[1].children = [TreeNode('G'), TreeNode('H')]\ns = \"ABCDEFGHI\"\nassert shortest_distance_to_prime_or(root, s, [1, 2, 3, 4, 5, 6, 7, 8]) == [0, 1, 1, 2, 2, 1, 2, 2]\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.795}, {"few_shot_keywords": "['matrix', 'elements', 'cross', 'sum', 'maximum', 'selection', 'concatenating', 'precede']", "test_keywords": "['pairwise coprime', 'precede', 'sum', 'subsequences', 'selection', 'maximum', 'elements', 'matrix']", "prompt_tokens": 804, "total_tokens": 1213, "completion_tokens": 409, "completion": "[Question 2]\n\nGiven a matrix of size N x M, find the maximum sum of elements in any pairwise coprime subsequence of the matrix, where the selected elements must be preceded by other selected elements. A subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements.\n\n[/Question 2]\n\n[Code 2]\n\nfrom math import gcd\n\ndef isCoprime(a, b):\n    return gcd(a, b) == 1\n\ndef maxSumPairwiseCoprime(matrix, N, M):\n    def maxSumCoprime(arr):\n        n = len(arr)\n        dp = [0] * n\n        for i in range(n):\n            dp[i] = arr[i]\n            for j in range(i):\n                if isCoprime(arr[i], arr[j]):\n                    dp[i] = max(dp[i], arr[i] + dp[j])\n        return max(dp)\n\n    maxSum = float('-inf')\n    for i in range(N):\n        maxSum = max(maxSum, maxSumCoprime(matrix[i]))\n    return maxSum\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maxSumPairwiseCoprime([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3, 3) == 26\nassert maxSumPairwiseCoprime([[10, 20, 30, 40], [5, 10, 15, 20], [2, 4, 6, 8], [15, 20, 25, 30]], 4, 4) == 115\nassert maxSumPairwiseCoprime([[2, 3, 5], [7, 11, 13], [17, 19, 23]], 3, 3) == 78\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.709}, {"few_shot_keywords": "['vertex', 'data structure', 'price', 'binary tree', 'sum', 'subtree', '2D', 'combinatorics', 'recursion', 'tree traversal', 'dfs', 'entry']", "test_keywords": "['repeatedly', 'tree traversal', 'binary tree', 'data structure', 'subtree', 'dfs', 'target', 'comparison', 'vertex', 'sum', 'recursion']", "prompt_tokens": 632, "total_tokens": 1008, "completion_tokens": 376, "completion": "[Question 2]\n\nGiven a binary tree rooted at vertex 1 with N vertices, where each vertex contains a value, write a function to find the sum of values in the subtree of a given target vertex.\n\n[/Question 2]\n\n[Code 2]\n\nclass TreeNode:\n    def __init__(self, value: int):\n        self.val = value\n        self.left = None\n        self.right = None\n\ndef subtreeSum(root: TreeNode, target: int) -> int:\n    def dfs(node):\n        if node is None:\n            return 0\n        curr_sum = node.val + dfs(node.left) + dfs(node.right)\n        return curr_sum\n    stack = [root]\n    while stack:\n        node = stack.pop()\n        if node.val == target:\n            return dfs(node)\n        if node.left:\n            stack.append(node.left)\n        if node.right:\n            stack.append(node.right)\n    return 0\n\n[/Code 2]\n\n[Asserts 2]\n\ntree = TreeNode(1)\ntree.left = TreeNode(2)\ntree.right = TreeNode(3)\ntree.left.left = TreeNode(4)\ntree.left.right = TreeNode(5)\nassert subtreeSum(tree, 2) == 11\nassert subtreeSum(tree, 3) == 3\ntree2 = TreeNode(1)\ntree2.right = TreeNode(2)\ntree2.right.left = TreeNode(3)\ntree2.right.right = TreeNode(4)\nassert subtreeSum(tree2, 2) == 7\nassert subtreeSum(tree2, 4) == 4\ntree3 = TreeNode(-10)\ntree3.left = TreeNode(2)\ntree3.right = TreeNode(3)\nassert subtreeSum(tree3, -10) == -10\nassert subtreeSum(tree3, 2) == 2\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.762}, {"few_shot_keywords": "['character', 'character count', 'union', 'string', 'frequency', 'iteration', 'list', 'queries', 'set', 'range', 'indexing']", "test_keywords": "['exit', 'down', 'iteration', 'indexing', 'calculation', 'list', 'queries', 'time', 'string', 'range', 'depth-first search', 'frequency', 'character']", "prompt_tokens": 574, "total_tokens": 885, "completion_tokens": 311, "completion": "[Question 2]\n\nYou are given a list of strings representing a tree-like structure. Each string represents a node and its children in the format \"node(child1, child2, ...)\". You need to implement a depth-first search algorithm to find the frequency of a given character at each level of the tree.\n\n[/Question 2]\n\n[Code 2]\n\nfrom collections import defaultdict\n\ndef dfsFrequency(tree: List[str], char: str) -> List[int]:\n    frequency = defaultdict(int)\n    \n    def dfs(node: str, level: int):\n        for c in node:\n            if c == char:\n                frequency[level] += 1\n        \n        children = []\n        start = 0\n        for i, c in enumerate(node):\n            if c == '(':\n                start = i + 1\n            elif c == ',' or c == ')':\n                children.append(node[start:i])\n        \n        for child in children:\n            dfs(child, level + 1)\n    \n    for node in tree:\n        dfs(node, 0)\n    \n    return [frequency[level] for level in sorted(frequency)]\n\n[/Code 2]\n\n[Asserts 2]\n\nassert dfsFrequency([\"a(b(c),d(e,f(g,h)))\", \"x(y,z)\"], \"a\") == [1, 1]\nassert dfsFrequency([\"aa(a,aaa)\", \"b(bb)\"], \"a\") == [2, 3]\nassert dfsFrequency([\"abc\", \"def(ghi)\"], \"z\") == [0]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.813}, {"few_shot_keywords": "['grid', 'single', 'cost', 'operation', 'rearrange', 'minimize', 'last card', 'equal', 'array', 'swap']", "test_keywords": "['swap', 'height', 'cost', 'operation', 'terrain', 'minimize', 'single', 'rearrange', 'values', 'condition', 'array']", "prompt_tokens": 634, "total_tokens": 938, "completion_tokens": 304, "completion": "[Question 2]\n\nYou are given an array representing the terrain heights along a line. The task is to rearrange the elements of the array using a single swap operation in order to minimize the total cost of rearrangement, where the cost is defined as the absolute difference between the heights of the swapped elements.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\ndef minimizeCost(heights: List[int]) -> int:\n    n = len(heights)\n    cost = 0\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            current_cost = abs(heights[i] - heights[j])\n            new_cost = abs(heights[i] - heights[i+1]) + abs(heights[j] - heights[j-1])\n            if new_cost < current_cost:\n                heights[i], heights[j] = heights[j], heights[i]\n                cost += new_cost\n    return cost\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minimizeCost([1, 5, 4, 3, 2]) == 5\nassert minimizeCost([5, 4, 3, 2, 1]) == 5\nassert minimizeCost([3, 1, 2, 4, 5]) == 2\nassert minimizeCost([5, 2, 8, 6, 1, 10]) == 1\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.936}, {"few_shot_keywords": "['dynamic programming', 'count', 'partition', 'integers', 'target', 'multiple times', 'heapq', 'array', 'sum', 'traversal']", "test_keywords": "['array', 'integers', 'target', 'count', 'bottom-up', 'dynamic programming', 'multiple times', 'sum', 'set']", "prompt_tokens": 584, "total_tokens": 847, "completion_tokens": 263, "completion": "[Question 2]\n\nYou are given an array of positive integers and a target sum. Your task is to find the count of unique ways to reach the target sum by selecting elements from the array. Each element can be selected multiple times.\n\nWrite a function that uses bottom-up dynamic programming to find the count of unique ways to reach the target sum from the given array.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef countWaysToReachSum(arr: List[int], targetSum: int) -> int:\n    dp = [0] * (targetSum + 1)\n    dp[0] = 1\n    for i in range(1, targetSum + 1):\n        for num in arr:\n            if num <= i:\n                dp[i] += dp[i - num]\n    return dp[targetSum]\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countWaysToReachSum([1, 2, 3], 4) == 7\nassert countWaysToReachSum([2, 3, 5, 6], 7) == 6\nassert countWaysToReachSum([1, 2, 5], 5) == 4\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.917}, {"few_shot_keywords": "['negative', 'changes', 'maximum', 'iteration', 'copy', 'flipping', 'elements', 'sum', 'subarray', 'sign', 'cities', 'array']", "test_keywords": "['iteration', 'sum', 'elements', 'maximum', 'arithmetic progression', 'subarray', 'selection', 'flipping', 'sign', 'array', 'negative']", "prompt_tokens": 581, "total_tokens": 885, "completion_tokens": 304, "completion": "[Question 2]\n\nGiven an array of integers, find the maximum sum of an arithmetic progression subarray by selecting a contiguous subarray and flipping the sign of its elements.\n\n[/Question 2]\n\n[Code 2]\n\ndef maxArithmeticProgressionSum(arr: List[int]) -> int:\n    n = len(arr)\n    max_sum = 0\n    for i in range(n):\n        for j in range(i, n):\n            subarray = arr[i:j+1]\n            max_sum = max(max_sum, sum(subarray))\n    return max_sum\n\ndef findMaxArithmeticProgressionSum(arr: List[int]) -> int:\n    max_val = maxArithmeticProgressionSum(arr)\n    return max_val\n\n[/Code 2]\n\n[Asserts 2]\n\nassert findMaxArithmeticProgressionSum([1, 7, 10, 15, 20, 25]) == 78\nassert findMaxArithmeticProgressionSum([-5, -3, -1, 1, 3, 5]) == 12\nassert findMaxArithmeticProgressionSum([3, -4, 7, 2, -3, 1, 4, 2]) == 14\nassert findMaxArithmeticProgressionSum([10, -7, 4, 6, -1, 3, 4, -5, 7, -3]) == 24\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.726}, {"few_shot_keywords": "['convert', 'repeated addition', 'price', 'weights', 'integers', 'bracket', 'bottom-up', 'possible', 'even', 'divisors']", "test_keywords": "['integers', 'powers', 'subtree', 'sums', 'possible', 'convert', 'repeated addition', 'divisors', 'positive integers', 'even']", "prompt_tokens": 594, "total_tokens": 906, "completion_tokens": 312, "completion": "[Question 2]\n\nYou are given a binary tree where each node contains an integer value. You need to find if it is possible to convert the given binary tree into a subtree where the sum of all node values is a power of two.\n\nWrite a function `isPowerOfTwoSubtree` to solve the problem.\n\n[/Question 2]\n\n[Code 2]\n\nclass TreeNode:\n    def __init__(self, value: int):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef isPowerOfTwoSubtree(root: TreeNode) -> bool:\n    def subtreeSum(node):\n        if not node:\n            return 0\n        return node.value + subtreeSum(node.left) + subtreeSum(node.right)\n    \n    def isPowerOfTwo(num):\n        return num > 0 and (num & (num - 1)) == 0\n    \n    total_sum = subtreeSum(root)\n    return isPowerOfTwo(total_sum)\n\n[/Code 2]\n\n[Asserts 2]\n\n# Create a binary tree\nroot = TreeNode(1)\nroot.left = TreeNode(2)\nroot.right = TreeNode(3)\nroot.left.left = TreeNode(4)\nroot.left.right = TreeNode(5)\n\nassert isPowerOfTwoSubtree(root) == True\n\n# Create another binary tree\nroot2 = TreeNode(1)\nroot2.left = TreeNode(2)\nroot2.right = TreeNode(3)\n\nassert isPowerOfTwoSubtree(root2) == False\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.759}, {"few_shot_keywords": "['array', 'ceiling', 'sort', 'down', 'operation', 'determination', 'leaf node', 'floor', 'boundary', 'sum', 'integer', 'maximum']", "test_keywords": "['floor', 'precede', 'while loop', 'absolute value', 'maximum', 'integer', 'consecutive', 'sort', 'ceiling', 'operation', 'sum', 'array']", "prompt_tokens": 549, "total_tokens": 790, "completion_tokens": 241, "completion": "[Question 2]\n\nGiven an array of integers, write a program to determine the maximum sum of absolute differences of array elements by rearranging the elements of the array. The rearrangement should be such that the absolute differences of consecutive elements in the rearranged array should be in non-descending order.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef maxSumAbsoluteDifferences(arr: List[int]) -> int:\n    arr.sort()\n    n = len(arr)\n    ans = 0\n    for i in range(n):\n        ans += abs(arr[i] - arr[n - i - 1])\n    return ans\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maxSumAbsoluteDifferences([4, 2, 1, 8])==10\nassert maxSumAbsoluteDifferences([1, 4, 7, 5, 6, 2])==16\nassert maxSumAbsoluteDifferences([10, 20, 15, 5, 25])==40\nassert maxSumAbsoluteDifferences([1, 2, 3, 4, 5])==6\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.86}, {"few_shot_keywords": "['subsequence', 'ranges', 'matrix', 'character removal', 'array', 'sum', 'constraint', 'adjacent', 'maximize', 'ways', 'positive integers']", "test_keywords": "['constraint', 'positive integers', 'array', 'edges', 'impossible', 'sum', 'subsequence', 'adjacent', 'maximize']", "prompt_tokens": 528, "total_tokens": 761, "completion_tokens": 233, "completion": "[Question 2]\n\nYou are given an array of positive integers and a constraint K. Determine if it is possible to form a subsequence from the array such that the sum of any two adjacent elements in the subsequence is greater than K.\n\n[/Question 2]\n\n[Code 2]\n\ndef isSubsequenceSumGreaterThanK(arr, K):\n    for i in range(len(arr) - 1):\n        if arr[i] + arr[i+1] <= K:\n            return False\n    return True\n\n[/Code 2]\n\n[Asserts 2]\n\nassert isSubsequenceSumGreaterThanK([3, 2, 7, 10], 5) == True\nassert isSubsequenceSumGreaterThanK([1, 2, 3, 4, 5], 8) == False\nassert isSubsequenceSumGreaterThanK([5, 9, 11, 2, 7], 10) == True\nassert isSubsequenceSumGreaterThanK([5, 5, 10, 100, 10, 5], 15) == True\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.905}, {"few_shot_keywords": "['while loop', 'minimum', 'connectivity', 'update', 'edges', 'subtree', 'dfs', 'nodes', 'tree', 'remove', 'graph', 'repetitions']", "test_keywords": "['dfs', 'remove', 'tree', 'subtree', 'edges', 'nodes', 'connectivity', 'maximum', 'minimum', 'modification', 'remaining', 'graph']", "prompt_tokens": 1052, "total_tokens": 1552, "completion_tokens": 500, "completion": "[Question 2]\n\nYou are given an undirected graph with N nodes and M edges. Your task is to remove a single edge from the graph such that the maximum distance between any pair of nodes in the remaining graph is minimized. After removing the edge, return the minimum possible maximum distance.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\nclass Solution:\n    def dfs(self, node: int, par: int, graph: List[List[int]], dist: List[int]) -> None:\n        for child in graph[node]:\n            if child != par:\n                dist[child] = dist[node] + 1\n                self.dfs(child, node, graph, dist)\n\n    def removeEdgeMinimizeMaxDistance(self, n: int, edges: List[List[int]]) -> int:\n        graph = [[] for _ in range(n + 1)]\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        \n        dist = [0] * (n + 1)\n        self.dfs(1, 0, graph, dist)\n        farthest_node = dist.index(max(dist))\n        \n        dist = [0] * (n + 1)\n        self.dfs(farthest_node, 0, graph, dist)\n        max_dist = max(dist)\n        \n        return (max_dist + 1) // 2\n\ns = Solution()\nprint(s.removeEdgeMinimizeMaxDistance(5, [[1, 2], [2, 3], [3, 4], [4, 5]]))  # Output: 2\n\n[/Code 2]\n\n[Asserts 2]\n\ns = Solution()\nassert s.removeEdgeMinimizeMaxDistance(5, [[1, 2], [2, 3], [3, 4], [4, 5]]) == 2\nassert s.removeEdgeMinimizeMaxDistance(6, [[1, 2], [2, 3], [2, 4], [4, 5], [4, 6]]) == 2\nassert s.removeEdgeMinimizeMaxDistance(4, [[1, 2], [2, 3], [2, 4]]) == 1\nassert s.removeEdgeMinimizeMaxDistance(3, [[1, 2], [1, 3]]) == 1\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.776}, {"few_shot_keywords": "['rooted tree', 'DFS', 'sum of distances', 'ASCII', 'vertices', 'edge weights', 'leaf node', 'tree traversal', 'construct', 'queries', 'occurrence', 'boolean', 'connected component', 'children', 'count', 'node weight']", "test_keywords": "['count', 'binary tree', 'queries', 'rooted tree', 'math', 'bisect', 'node weight', 'leaf node', 'children', 'DFS', 'vertices', 'tree traversal', 'sum of distances', 'construct', 'edge weights']", "prompt_tokens": 896, "total_tokens": 1536, "completion_tokens": 640, "completion": "[Question 2]\n\nYou are given a binary tree with 'n' vertices. Each node has an associated weight. Write a function to count the number of nodes in the tree that have a weight greater than a given threshold 'k'. Additionally, you need to answer 'q' queries, where each query asks to find the sum of the weights of all the nodes in the subtree rooted at a given node.\n\nWrite a function that takes in the binary tree, its weights, the threshold 'k', and the queries and returns the count of nodes exceeding the threshold and an array of answers for each query.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List, Tuple, Optional\n\nclass BinaryTreeNode:\n    def __init__(self, value: int, weight: int):\n        self.value = value\n        self.weight = weight\n        self.left: Optional[BinaryTreeNode] = None\n        self.right: Optional[BinaryTreeNode] = None\n\ndef constructBinaryTree(n: int, edges: List[Tuple[int, int]], weights: List[int]) -> BinaryTreeNode:\n    nodes = {i: BinaryTreeNode(i, w) for i, w in enumerate(weights)}\n    for s, d in edges:\n        if not nodes[s].left:\n            nodes[s].left = nodes[d]\n        else:\n            nodes[s].right = nodes[d]\n    return nodes[0]\n\ndef countNodesAboveThreshold(root: BinaryTreeNode, threshold: int) -> int:\n    def dfs(node: BinaryTreeNode) -> int:\n        if not node:\n            return 0\n        count = 1 if node.weight > threshold else 0\n        return count + dfs(node.left) + dfs(node.right)\n    \n    return dfs(root)\n\ndef subtreeSumQueries(root: BinaryTreeNode, queries: List[int]) -> List[int]:\n    def subtreeSum(node: BinaryTreeNode) -> int:\n        if not node:\n            return 0\n        return node.weight + subtreeSum(node.left) + subtreeSum(node.right)\n    \n    return [subtreeSum(root if q == 1 else root.left if q == 2 else root.right) for q in queries]\n\n[/Code 2]\n\n[Asserts 2]\n\ntree = constructBinaryTree(7, [(0, 1), (0, 2), (1, 3), (1, 4), (2, 5), (2, 6)], [4, 2, 5, 3, 1, 6, 8])\nassert countNodesAboveThreshold(tree, 3) == 5\nassert subtreeSumQueries(tree, [1, 2, 3]) == [29, 12, 18]\ntree = constructBinaryTree(4, [(0, 1), (1, 2), (1, 3)], [3, 1, 2, 4])\nassert countNodesAboveThreshold(tree, 2) == 4\nassert subtreeSumQueries(tree, [1, 2, 3]) == [10, 3, 6]\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.791}, {"few_shot_keywords": "['changes', 'binary', 'path', 'iteration', 'matrix', 'palindrome', 'represent']", "test_keywords": "['binary', 'integers', 'palindrome', 'changes', 'DFS', 'matrix', 'sorting', 'path']", "prompt_tokens": 682, "total_tokens": 1169, "completion_tokens": 487, "completion": "[Question 2]\n\nGiven a binary matrix representing a grid of integers, find the minimum number of changes required to make all the paths from the top-left corner to the bottom-right corner palindrome. Use Depth-First Search (DFS) to explore the matrix and determine the minimum changes needed.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\ndef isPalindrome(num: int) -> bool:\n    return str(num) == str(num)[::-1]\n\ndef minChangesForPathToPalindrome(matrix: List[List[int]]) -> int:\n    def dfs(row: int, col: int, changes: int) -> int:\n        if row == rows - 1 and col == cols - 1:\n            return changes\n        \n        down_changes = float('inf')\n        right_changes = float('inf')\n        \n        if row + 1 < rows:\n            down_changes = dfs(row + 1, col, changes + (1 if matrix[row+1][col] != matrix[row][col] else 0))\n        if col + 1 < cols:\n            right_changes = dfs(row, col + 1, changes + (1 if matrix[row][col+1] != matrix[row][col] else 0))\n        \n        return min(down_changes, right_changes)\n    \n    rows, cols = len(matrix), len(matrix[0])\n    return dfs(0, 0, 0)\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minChangesForPathToPalindrome([[1, 0, 1], [0, 1, 0], [1, 0, 1]]) == 2\nassert minChangesForPathToPalindrome([[1, 1, 1], [0, 1, 0], [1, 0, 1]]) == 3\nassert minChangesForPathToPalindrome([[1, 0, 0, 1], [0, 1, 1, 0], [1, 0, 0, 1]]) == 4\nassert minChangesForPathToPalindrome([[1, 0, 0, 0], [0, 1, 0, 0], [1, 0, 1, 1], [1, 0, 0, 1]]) == 5\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.73}, {"few_shot_keywords": "['number', 'combination', 'range', 'adjacent digits', 'absolute difference', 'count', 'integer', 'ceiling']", "test_keywords": "['half', 'count', 'divisible', 'adjacent digits', 'absolute difference', 'algorithm', 'range', 'number', 'segment', 'integer', 'jumps']", "prompt_tokens": 509, "total_tokens": 789, "completion_tokens": 280, "completion": "[Question 2]\n\nYou are given a range of numbers from A to B (inclusive). Implement an algorithm to count the number of integers in the range such that the absolute difference between any two adjacent digits is divisible by half the number of jumps between those two digits.\n\n[/Question 2]\n\n[Code 2]\n\ndef countNumbersWithDivisibleDifference(A: int, B: int) -> int:\n    def isDivisible(diff, jumps):\n        return diff % (jumps // 2) == 0\n    \n    count = 0\n    for num in range(A, B + 1):\n        num_str = str(num)\n        flag = True\n        for i in range(len(num_str) - 1):\n            diff = abs(int(num_str[i]) - int(num_str[i + 1]))\n            jumps = abs(i - (i+1))\n            if not isDivisible(diff, jumps):\n                flag = False\n                break\n        if flag:\n            count += 1\n    return count\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countNumbersWithDivisibleDifference(10, 20)==6\nassert countNumbersWithDivisibleDifference(50, 60)==3\nassert countNumbersWithDivisibleDifference(100, 110)==6\nassert countNumbersWithDivisibleDifference(150, 160)==3", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.832}, {"few_shot_keywords": "['cost', 'adjacent', 'array', 'integer', 'merge', 'repetitive', 'heap', 'shortest', 'width']", "test_keywords": "['subarray', 'integer', 'adjacent', 'array', 'heap', 'profit', 'cost', 'repetitive', 'merge']", "prompt_tokens": 572, "total_tokens": 890, "completion_tokens": 318, "completion": "[Question 2]\n\nGiven an array of integers representing the profits of different subarrays, determine the maximum profit that can be achieved by merging adjacent subarrays repetitively. The cost of merging two adjacent subarrays is the sum of their profits.\n\n[/Question 2]\n\n[Code 2]\n\ndef maxProfitAfterMergingSubarrays(profits):\n    import heapq\n    max_profit = 0\n    heap = []\n    for profit in profits:\n        heapq.heappush(heap, -profit)\n    \n    while len(heap) > 1:\n        first_profit = -heapq.heappop(heap)\n        second_profit = -heapq.heappop(heap)\n        merge_cost = first_profit + second_profit\n        max_profit += merge_cost\n        heapq.heappush(heap, -merge_cost)\n    \n    return max_profit\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maxProfitAfterMergingSubarrays([1, 2, 3, 4, 5])==33\nassert maxProfitAfterMergingSubarrays([5, 3, 7, 10, 2, 6])==119\nassert maxProfitAfterMergingSubarrays([10, 20, 30, 40, 50])==410\nassert maxProfitAfterMergingSubarrays([6, 5, 3, 8, 2])==67\nassert maxProfitAfterMergingSubarrays([12, 45, 78, 32, 10, 5])==520\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.911}, {"few_shot_keywords": "['positive integers', 'win', 'direction', 'array', 'maximum', 'segment', 'query', 'sum']", "test_keywords": "['mapping', 'time', 'floor', 'sum', 'segment', 'maximum', 'array', 'positive integers', 'connected component']", "prompt_tokens": 552, "total_tokens": 940, "completion_tokens": 388, "completion": "[Question 2]\n\nGiven an array of positive integers, write a function to find the maximum sum of a segment of the array. Additionally, create a mapping of the maximum sum to the corresponding segment.\n\n[/Question 2]\n\n[Code 2]\n\ndef maxSumSegmentWithMapping(arr: list) -> (int, list):\n    max_sum = 0\n    curr_sum = 0\n    start = 0\n    end = 0\n    for i in range(len(arr)):\n        if curr_sum + arr[i] < arr[i]:\n            start = i\n            curr_sum = arr[i]\n        else:\n            curr_sum += arr[i]\n        if curr_sum > max_sum:\n            max_sum = curr_sum\n            end = i\n    return max_sum, arr[start:end+1]\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maxSumSegmentWithMapping([1, 2, 3, 4, 5]) == (15, [1, 2, 3, 4, 5])\nassert maxSumSegmentWithMapping([1, -2, 3, -4, 5]) == (5, [5])\nassert maxSumSegmentWithMapping([-2, -5, -1, -2]) == (0, [])\nassert maxSumSegmentWithMapping([10, -3, -2, 7, -15, 1, 2, 2]) == (12, [10, -3, -2, 7])\nassert maxSumSegmentWithMapping([30, 34, -29, -57, 5, 8, 27, -52, 66, -10]) == (95, [30, 34, -29, -57, 5, 8, 27, -52, 66]) \n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.851}, {"few_shot_keywords": "['set bits', 'distinct', 'binary', 'pairs', 'turns', 'array', 'nested loop', 'count', 'iteration', 'pop']", "test_keywords": "['set bits', 'binary', 'modulo', 'pairs', 'iteration', 'count', 'array', 'consecutive segments', 'nested loop', 'distinct']", "prompt_tokens": 582, "total_tokens": 926, "completion_tokens": 344, "completion": "[Question 2]\n\nGiven an array of integers, find the count of pairs (i, j) where i < j and the sum of set bits in the binary representation of arr[i] and arr[j] is divisible by a given integer k.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef countPairsWithSumOfSetBitsDivisibleByK(arr: List[int], k: int) -> int:\n    def countSetBits(num: int) -> int:\n        cnt = 0\n        while num:\n            cnt += 1\n            num &= (num - 1)\n        return cnt\n    \n    pairsCount = 0\n    n = len(arr)\n    \n    for i in range(n):\n        for j in range(i+1, n):\n            if (countSetBits(arr[i]) + countSetBits(arr[j])) % k == 0:\n                pairsCount += 1\n    \n    return pairsCount\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countPairsWithSumOfSetBitsDivisibleByK([1, 2, 3, 4, 5], 3) == 4\nassert countPairsWithSumOfSetBitsDivisibleByK([3, 5, 7, 9], 2) == 6\nassert countPairsWithSumOfSetBitsDivisibleByK([8, 9, 10, 11, 12], 4) == 6\nassert countPairsWithSumOfSetBitsDivisibleByK([15, 30, 45, 60], 5) == 6\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.793}, {"few_shot_keywords": "['difference', 'subarray', 'sum', 'arithmetic progression', 'maximum', 'graph', 'connected component', 'adjacency list', 'depth-first search']", "test_keywords": "['graph', 'maximum', 'connected component', 'adjacency list', 'subarray', 'replace', 'floor', 'sum', 'depth-first search']", "prompt_tokens": 747, "total_tokens": 1212, "completion_tokens": 465, "completion": "[Question 2]\n\nGiven an undirected graph with N nodes and M edges represented as an adjacency list, write a function to find the maximum sum of values in subarrays of each connected component. Additionally, replace all the values in the subarrays with the floor of their average.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List, Tuple\n\ndef dfs(v: int, visited: List[bool], graph: List[List[int]], arr: List[int], c: List[int]):\n    visited[v] = True\n    c.append(arr[v])\n    for i in graph[v]:\n        if not visited[i]:\n            dfs(i, visited, graph, arr, c)\n\ndef maxSubarraySumReplace(N: int, M: int, adj_list: List[List[int]], values: List[int]) -> int:\n    graph = adj_list\n    visited = [False] * N\n    res = 0\n    for i in range(N):\n        c = []\n        if not visited[i]:\n            dfs(i, visited, graph, values, c)\n            avg = sum(c) / len(c)\n            for j in range(len(c)):\n                c[j] = int(avg)\n            res = max(res, sum(c))\n    return res\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maxSubarraySumReplace(4, 3, [[1,2],[2,3],[3,4]], [1, 0, 2, 3]) == 6\nassert maxSubarraySumReplace(4, 3, [[1,2],[2,3],[3,4]], [1, 0, 2, 3]) == 6\nassert maxSubarraySumReplace(5, 4, [[1,2],[2,3],[3,4],[4,5]], [1,2,3,4,5]) == 15\nassert maxSubarraySumReplace(3, 2, [[1,2],[2,3]], [1,2,3]) == 6\nassert maxSubarraySumReplace(3, 2, [[1,2],[2,3]], [3,2,1]) == 6\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.868}, {"few_shot_keywords": "['integer', 'strings', 'scale', 'count', 'consecutive', 'alternatively', 'length', 'binary', 'movement', 'dynamic programming', 'modulo', 'logic', 'determination', 'pair']", "test_keywords": "['length', 'terrain', 'binary', 'alternatively', 'natural numbers', 'bisect', 'consecutive', 'count', 'integer', 'dynamic programming', 'operation', 'strings', 'modulo']", "prompt_tokens": 675, "total_tokens": 1058, "completion_tokens": 383, "completion": "[Question 2]\n\nGiven a terrain represented as a 2D grid of integers, the task is to find the length of the longest path in the terrain such that the difference between each pair of consecutive cells is alternatively a natural number and its double. The path should consist of consecutive cells and the length of the path should be maximal.\n\n[/Question 2]\n\n[Code 2]\n\ndef longestAlternatingPath(terrain):\n    m, n = len(terrain), len(terrain[0])\n    dp = [[[1, 1] for _ in range(n)] for _ in range(m)]\n    res = 1\n\n    for i in range(m):\n        for j in range(n):\n            for ni, nj in ((i, j + 1), (i, j - 1), (i + 1, j), (i - 1, j)):\n                if 0 <= ni < m and 0 <= nj < n:\n                    if terrain[ni][nj] > terrain[i][j]:\n                        dp[ni][nj][0] = max(dp[ni][nj][0], dp[i][j][1] + 1)\n                    elif terrain[ni][nj] < terrain[i][j]:\n                        dp[ni][nj][1] = max(dp[ni][nj][1], dp[i][j][0] + 1)\n                    res = max(res, max(dp[ni][nj]))\n\n    return res\n\n[/Code 2]\n\n[Asserts 2]\n\nassert longestAlternatingPath([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5\nassert longestAlternatingPath([[1, 2, 1], [4, 5, 6], [7, 8, 9]]) == 4", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.711}, {"few_shot_keywords": "['distance', 'connectivity', 'matrix', 'character count', 'non-empty', 'element', 'voting', 'integer', 'value', 'neighbor', 'maximum']", "test_keywords": "['value', 'distance', 'matrix', 'element', 'maximum', 'non-decreasing', 'neighbor', 'added', 'visited', 'integer']", "prompt_tokens": 743, "total_tokens": 1196, "completion_tokens": 453, "completion": "[Question 2]\n\nGiven a non-empty n x m matrix of integers, determine the maximum value that can be obtained by visiting each element in the matrix such that the value added at each step is non-decreasing and the distance between neighboring elements is within a given threshold.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\ndef maxNonDecreasingValueWithinDistance(matrix: List[List[int]], threshold: int) -> int:\n    def isValid(x,y):\n        return 0 <= x < n and 0 <= y < m\n\n    def dfs(x, y, prev, visited):\n        if not isValid(x, y) or visited[x][y]:\n            return 0\n        value = matrix[x][y]\n        if value < prev:\n            return 0\n        visited[x][y] = True\n        maxVal = 0\n        for dx, dy in [(1,0), (-1,0), (0,1), (0,-1)]:\n            maxVal = max(maxVal, dfs(x+dx, y+dy, value, visited))\n        visited[x][y] = False\n        return value + maxVal\n\n    n = len(matrix)\n    m = len(matrix[0])\n    result = 0\n    for i in range(n):\n        for j in range(m):\n            visited = [[False]*m for _ in range(n)]\n            result = max(result, dfs(i, j, float('-inf'), visited))\n    return result\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maxNonDecreasingValueWithinDistance([[3, 4, 5], [3, 2, 6], [2, 1, 7]], 1) == 9\nassert maxNonDecreasingValueWithinDistance([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 2) == 45\nassert maxNonDecreasingValueWithinDistance([[9, 8, 7], [6, 5, 4], [3, 2, 1]], 1) == 9\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.93}, {"few_shot_keywords": "['matrix', 'dictionary', 'sum', 'distinct', 'prime', 'combinations', 'unique', 'number', 'array', 'dynamic programming']", "test_keywords": "['subarrays', 'array', 'combinations', 'prime', 'distance', 'unique', 'Bellman-Ford algorithm', 'distinct', 'number', 'sum', 'dynamic programming']", "prompt_tokens": 650, "total_tokens": 985, "completion_tokens": 335, "completion": "[Question 2]\n\nGiven an array of integers, find the number of distinct subarrays whose sum is a prime number.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef isPrime(num: int) -> bool:\n\tif num <= 1:\n\t\treturn False\n\tfor i in range(2, int(num ** 0.5) + 1):\n\t\tif num % i == 0:\n\t\t\treturn False\n\treturn True\n\ndef countDistinctSubarraysWithPrimeSum(nums: List[int]) -> int:\n\tcount = 0\n\tprefix_sum = 0\n\tprefix_sums = {0: 1}\n\tfor num in nums:\n\t\tprefix_sum += num\n\t\tfor diff in range(1, int(prefix_sum ** 0.5) + 1):\n\t\t\tif isPrime(prefix_sum - diff):\n\t\t\t\tcount += prefix_sums.get(prefix_sum - diff, 0)\n\t\tprefix_sums[prefix_sum] = prefix_sums.get(prefix_sum, 0) + 1\n\treturn count\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countDistinctSubarraysWithPrimeSum([1, 2, 3, 4, 5])==2\nassert countDistinctSubarraysWithPrimeSum([2, 3, 5, 7, 11])==6\nassert countDistinctSubarraysWithPrimeSum([4, 6, 8, 10, 12])==0\nassert countDistinctSubarraysWithPrimeSum([17, 19, 23, 29, 31])==11\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.888}, {"few_shot_keywords": "['deletion', 'end', 'minimum', 'maximum', 'sign', 'array', 'pairwise coprime', 'forward', 'jumps', 'direction', 'strings', 'positions', 'reach', '0', 'non-decreasing']", "test_keywords": "['maximum', 'pairs', 'reach', 'positions', '0', 'difference', 'jumps', 'optimum', 'minimum', 'forward', 'array', 'determination', 'direction', 'end']", "prompt_tokens": 700, "total_tokens": 952, "completion_tokens": 252, "completion": "[Question 2]\n\nYou are given an array of integers. The task is to determine the maximum difference between the indices of two elements such that the second element is greater than the first element and both elements can be reached by making forward jumps from the starting position.\n\n[/Question 2]\n\n[Code 2]\n\ndef maxIndexDiff(arr):\n    n = len(arr)\n    maxDiff = -1\n    for i in range(n):\n        j = n-1\n        while(j>i):\n            if arr[j] > arr[i] and maxDiff < (j-i):\n                maxDiff = j-i\n            j -= 1\n    return maxDiff\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maxIndexDiff([34, 8, 10, 3, 2, 80, 30, 33, 1]) == 6\nassert maxIndexDiff([9, 2, 3, 4, 5, 6, 7, 8, 18, 0]) == 8\nassert maxIndexDiff([1, 2, 3, 4, 5, 6]) == 5\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.911}, {"few_shot_keywords": "['subset', 'check', 'integers', 'array', 'adjacent digits', 'divisors', 'pairwise coprime', 'subsets', 'GCD']", "test_keywords": "['GCD', 'pairwise coprime', 'divisors', 'integers', 'powers', 'array', 'subset', 'duplicates']", "prompt_tokens": 629, "total_tokens": 884, "completion_tokens": 255, "completion": "[Question 2]\n\nGiven an array of integers, write a function to check if there are any duplicates in the array where the GCD of the pair of elements is greater than 1.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\ndef hasDuplicateWithGCD(arr: List[int]) -> bool:\n    seen = set()\n    for num in arr:\n        for prev in seen:\n            if gcd(num, prev) > 1:\n                return True\n        seen.add(num)\n    return False\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\n[/Code 2]\n\n[Asserts 2]\n\nassert hasDuplicateWithGCD([1, 2, 3, 4, 5, 6])==False\nassert hasDuplicateWithGCD([2, 4, 6, 8, 10, 12])==True\nassert hasDuplicateWithGCD([3, 6, 9, 12, 15, 18])==True\nassert hasDuplicateWithGCD([5, 7, 11, 13, 17, 19])==False\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.856}, {"few_shot_keywords": "['max distance', 'adjacent digits', 'selection', 'adjacent', 'lexicographically', 'dynamic programming', 'sum', 'maximum', 'array', 'divisor']", "test_keywords": "['dynamic programming', 'sum', 'neighbours', 'recursive', 'array', 'subtree', 'selection', 'construct', 'adjacent', 'maximum']", "prompt_tokens": 538, "total_tokens": 770, "completion_tokens": 232, "completion": "[Question 2]\n\nGiven a binary tree represented as an array, you are required to find the maximum sum of a subtree where no two adjacent nodes are selected.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef maxSumSubtree(root: List[int]) -> int:\n    def helper(node):\n        if not node:\n            return (0, 0)\n        left_with, left_without = helper(node.left)\n        right_with, right_without = helper(node.right)\n        return (node.val + left_without + right_without, max(left_with, left_without) + max(right_with, right_without))\n    \n    return max(helper(root))\n\n[/Code 2]\n\n[Asserts 2]\n\n# Creating the binary tree from the given array\ntree = TreeNode(3, TreeNode(4, TreeNode(1), TreeNode(3)), TreeNode(5, None, TreeNode(1)))\nassert maxSumSubtree(tree) == 9", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.879}, {"few_shot_keywords": "['costs', 'dynamic programming', 'integer', 'game', 'coins', 'divisor', 'sum', 'abs', 'positive', 'optimally', 'add', 'turns', 'optimum', 'strategy']", "test_keywords": "['strategy', 'division', 'integer', 'heap', 'turns', 'optimum', 'palindrome', 'math', 'optimally', 'game', 'positive', 'divisor', 'dynamic programming', 'round']", "prompt_tokens": 660, "total_tokens": 1007, "completion_tokens": 347, "completion": "[Question 2]\n\nGiven a positive integer n, write a function to determine the optimum strategy using dynamic programming for a game where two players take turns to choose a positive integer x (1 <= x <= n) to subtract from the given integer, and the player who cannot make a move loses. The goal is to find the optimal strategy to win the game.\n\n[/Question 2]\n\n[Code 2]\n\ndef optimalStrategyGame(n: int) -> str:\n    dp = [[0] * n for _ in range(n)]\n    \n    for i in range(n):\n        dp[i][i] = i\n    \n    for length in range(2, n+1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n            dp[i][j] = max(i + min(dp[i+2][j], dp[i+1][j-1]), j + min(dp[i+1][j-1], dp[i][j-2]))\n    \n    total_sum = sum(nums)\n    player1_score = dp[0][n-1]\n    player2_score = total_sum - player1_score\n    \n    if player1_score > player2_score:\n        return \"Player 1\"\n    else:\n        return \"Player 2\"\n\n[/Code 2]\n\n[Asserts 2]\n\nassert optimalStrategyGame(4) == \"Player 1\"\nassert optimalStrategyGame(7) == \"Player 1\"\nassert optimalStrategyGame(10) == \"Player 1\"\nassert optimalStrategyGame(15) == \"Player 1\"\nassert optimalStrategyGame(20) == \"Player 1\"\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.754}, {"few_shot_keywords": "['matrix', 'terrain', 'height', 'reachability', 'contiguous', 'left', 'adjacent', 'subtree', 'count', 'logic', 'mountain', 'cell']", "test_keywords": "['terrain', 'count', 'logic', 'cell', 'adjacent', 'up', 'increasing order', 'combination', 'height', 'mountain', 'inserting', 'bitwise', 'matrix']", "prompt_tokens": 638, "total_tokens": 954, "completion_tokens": 316, "completion": "[Question 2]\n\nYou are given a terrain represented by a matrix where each cell contains the height of the terrain. Write a function to count the number of cells in the terrain where the height is in increasing order when moving up from that cell. For example, in a cell (i, j), if all the cells above it (i-1, j) have a height lesser than the height at cell (i, j), then it is counted. Return the total count.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\ndef countIncreasingOrderCells(matrix: List[List[int]]) -> int:\n    m = len(matrix)\n    n = len(matrix[0])\n    count = 0\n    for i in range(m):\n        for j in range(n):\n            if i == 0 or matrix[i][j] <= matrix[i-1][j]:\n                count += 1\n    return count\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countIncreasingOrderCells([[1, 2, 1], [1, 3, 1], [1, 2, 1]]) == 3\nassert countIncreasingOrderCells([[1, 1, 1], [1, 1, 1], [1, 1, 1]]) == 9\nassert countIncreasingOrderCells([[3, 2, 1], [6, 5, 4], [9, 8, 7]]) == 9\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.94}, {"few_shot_keywords": "['operation', 'indices', 'bracket', 'reduction', 'graph', 'abs', 'operations', 'deletion', 'array', 'adjacent']", "test_keywords": "['probability', 'adjacent', 'array', 'deletion', 'indices', 'reduction', 'character removal', 'operation', 'abs', 'round', 'binary']", "prompt_tokens": 578, "total_tokens": 928, "completion_tokens": 350, "completion": "[Question 2]\n\nYou are given a binary array of length n. You can perform the following operation any number of times: \n\n1. Choose any two adjacent elements in the array at indices i and i+1.\n2. If the absolute difference between the two elements is 1, you can delete any one of the two elements.\n3. The operation reduces the length of the array by 1.\n\nWrite a function to calculate the probability that the array reduces to a single element after performing the given operations randomly. \n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef probabilityOfSingleElement(arr: List[int]) -> float:\n    ones_count = arr.count(1)\n    zeros_count = arr.count(0)\n    if ones_count == 0 or zeros_count == 0:\n        return 0.0\n    return min(ones_count, zeros_count) / (len(arr) - 1)\n\n[/Code 2]\n\n[Asserts 2]\n\nassert probabilityOfSingleElement([1, 0, 1, 0, 1, 0])==1.0\nassert probabilityOfSingleElement([1, 1, 0, 0, 1, 1, 0, 0])==0.5\nassert probabilityOfSingleElement([1, 0, 1, 0, 1, 1, 0, 1, 0])==0.625\nassert probabilityOfSingleElement([1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0])==0.5\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.831}, {"few_shot_keywords": "['segment', 'score', 'array', 'pop', 'sorting', 'win', 'maximum', 'numeric', 'list', 'operations']", "test_keywords": "['operations', 'score', 'break', 'same characters', 'maximum', 'accessible', 'reduction', 'path', 'pop', 'array', 'sorting', 'list']", "prompt_tokens": 575, "total_tokens": 821, "completion_tokens": 246, "completion": "[Question 2]\n\nYou are given an array of strings, where each string consists of lowercase English letters. Your task is to find the maximum score which can be obtained by performing the following operations:\n- Pick a string from the array and pop the last character from it.\n- Repeat the above step until all strings in the array break to the same characters.\n- Calculate the sum of the lengths of all the strings at this point.\n\n[/Question 2]\n\n[Code 2]\n\ndef maxScoreWithSameCharacters(strings):\n    ans = 0\n    while all(strings[i][-1] == strings[0][-1] for i in range(len(strings))):\n        ans += len(strings)\n        strings = [s[:-1] for s in strings]\n    return ans\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maxScoreWithSameCharacters([\"apple\", \"ample\", \"apply\"]) == 10\nassert maxScoreWithSameCharacters([\"abc\", \"def\", \"ghi\"]) == 0\nassert maxScoreWithSameCharacters([\"abcd\", \"aed\", \"afd\"]) == 7\nassert maxScoreWithSameCharacters([\"hello\", \"hell\"]) == 9\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.894}, {"few_shot_keywords": "['binary', 'strings', 'bitwise', 'ways', 'dynamic programming', 'consecutive', 'sequence', 'repeatedly', 'integer', 'counting']", "test_keywords": "['bitwise', 'binary', 'strings', 'placement', 'counting', 'destination', 'integer', 'consecutive', 'dynamic programming', 'sequence', 'swap']", "prompt_tokens": 488, "total_tokens": 654, "completion_tokens": 166, "completion": "[Question 2]\n\nGiven two integers, x and y, write a function to swap the two integers using bitwise operations and then return the count of 1s in the binary representation of the destination integer.\n\n[/Question 2]\n\n[Code 2]\n\ndef swapAndCountOnes(x, y):\n    x = x ^ y\n    y = x ^ y\n    x = x ^ y\n    return bin(x).count('1')\n\n[/Code 2]\n\n[Asserts 2]\n\nassert swapAndCountOnes(2, 5) == 2\nassert swapAndCountOnes(10, 20) == 3\nassert swapAndCountOnes(7, 3) == 2\nassert swapAndCountOnes(0, 15) == 4", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.925}, {"few_shot_keywords": "['subsequence', 'absolute difference', 'indices', 'cube', 'task', 'sum', 'array', 'maximum', 'negative weight cycle', 'union', 'integer']", "test_keywords": "['sum', 'maximum', 'division', 'task', 'integer', 'array', 'traversal', 'swaps', 'powers', 'subsequence', 'indices', 'path', 'absolute difference']", "prompt_tokens": 646, "total_tokens": 964, "completion_tokens": 318, "completion": "[Question 2]\n\nGiven an array arr of N integers, the task is to find the maximum sum of subsequence obtained by performing at most K swaps on the array elements. A swap is defined as switching the positions of two elements in the array.\n\n[/Question 2]\n\n[Code 2]\n\ndef maxSubSeqSumWithSwaps(arr, k):\n    n = len(arr)\n    if k >= n // 2:\n        return sum(sorted(arr, reverse=True)[:k])\n    else:\n        max_sum = sum(sorted(arr, reverse=True)[:k])\n        for i in range(n - k):\n            curr_sum = sum(arr[i:i + k])\n            max_sum = max(max_sum, curr_sum)\n        return max_sum\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maxSubSeqSumWithSwaps([1, 2, 3, 4, 5], 2) == 14\nassert maxSubSeqSumWithSwaps([5, 4, 3, 2, 1], 2) == 14\nassert maxSubSeqSumWithSwaps([5, 4, 3, 2, 1], 3) == 15\nassert maxSubSeqSumWithSwaps([1, 2, 3, 4, 5], 3) == 15\nassert maxSubSeqSumWithSwaps([1, 20, 6, 4, 5], 2) == 31\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.776}, {"few_shot_keywords": "['count', 'largest', 'beginning', 'substring', 'dynamic programming', 'integer', 'binary', 'length', 'determination', 'Bellman-Ford algorithm', 'same characters', 'iteration']", "test_keywords": "['count', 'same characters', 'binary', 'integer', 'substring', 'dynamic programming', 'half', 'length', 'deletion']", "prompt_tokens": 512, "total_tokens": 846, "completion_tokens": 334, "completion": "[Question 2]\n\nGiven a binary string S, the task is to count the minimum number of deletions required to make all characters in the first half of the string the same.\n\n[/Question 2]\n\n[Code 2]\n\ndef minDeletions(S: str) -> int:\n    n = len(S)\n    count_0 = 0\n    count_1 = 0\n    ans = float('inf')\n    for i in range(n):\n        if i < n // 2:\n            if S[i] == '0':\n                count_0 += 1\n            else:\n                count_1 += 1\n        else:\n            ans = min(ans, count_0 + (n // 2 - count_0) - count_1 + (n - n // 2 - count_1))\n            if S[i-n//2] == '0':\n                count_0 -= 1\n            else:\n                count_1 -= 1\n            if S[i] == '0':\n                count_0 += 1\n            else:\n                count_1 += 1\n    ans = min(ans, count_0 + (n // 2 - count_0) - count_1 + (n - n // 2 - count_1))\n    return ans\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minDeletions(\"11000\")==1\nassert minDeletions(\"1101101\")==2\nassert minDeletions(\"100101\")==2\nassert minDeletions(\"11111\")==2\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.74}, {"few_shot_keywords": "['inserting', 'sequence', 'consecutive', 'frequency', 'array', 'precede']", "test_keywords": "['consecutive', 'OR', 'inserting', 'repetitions', 'odd', 'sequence', 'array']", "prompt_tokens": 689, "total_tokens": 1079, "completion_tokens": 390, "completion": "[Question 2]\n\nYou are given an array of integers. The task is to determine if it is possible to obtain a sequence of consecutive integers by either inserting any integer at any position in the array, or by removing any repetitions of odd numbers.\n\nWrite a function called isConsecutiveSequence that takes in a list of integers and returns True if it is possible to obtain a consecutive sequence by the given operations, and False otherwise.\n\n[/Question 2]\n\n[Code 2]\n\ndef isConsecutiveSequence(nums):\n    nums = list(set(nums))\n    nums.sort()\n    diff = 0\n    for i in range(1, len(nums)):\n        if nums[i] == nums[i - 1]:\n            if nums[i] % 2 != 0:  # If the number is odd and repetitive\n                nums[i] += 1  # Make it even to eliminate repetition\n            else:\n                return False  # If repetition is for even number, consecutive sequence is not possible\n        diff += nums[i] - nums[i - 1] - 1\n    return diff <= len(nums) - 1\n\n[/Code 2]\n\n[Asserts 2]\n\nassert isConsecutiveSequence([4, 8, 6, 5])==True\nassert isConsecutiveSequence([0, 0, 2, 2, 4, 4])==True\nassert isConsecutiveSequence([1, 2, 3, 4, 5, 6, 7, 8])==True\nassert isConsecutiveSequence([1, 2, 2, 3, 3, 3])==False\nassert isConsecutiveSequence([1, 2, 2, 3, 3, 3, 4, 4, 4, 5, 5, 5])==True\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.884}, {"few_shot_keywords": "['odd', 'count', 'divisibility', 'range', 'heap', 'digits', 'even', 'sum', 'iteration']", "test_keywords": "['odd', 'count', 'iteration', 'digits', 'even', 'range', 'target', 'sum', 'equality']", "prompt_tokens": 524, "total_tokens": 761, "completion_tokens": 237, "completion": "[Question 2]\n\nWrite a function to count the numbers in a given range whose sum of odd digits is equal to the sum of even digits.\n\n[/Question 2]\n\n[Code 2]\n\ndef getSum(n):\n    sumEven = 0\n    sumOdd = 0\n    while (n != 0):\n        digit = n % 10\n        if (digit % 2 == 0):\n            sumEven += digit\n        else:\n            sumOdd += digit\n        n //= 10\n    return sumEven == sumOdd\n\ndef countNumbersInRangeWithEqualSum(L, R):\n    count = 0\n    for i in range(L, R + 1):\n        if getSum(i):\n            count += 1\n    return count\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countNumbersInRangeWithEqualSum(1, 10)==0\nassert countNumbersInRangeWithEqualSum(10, 20)==1\nassert countNumbersInRangeWithEqualSum(30, 40)==2\nassert countNumbersInRangeWithEqualSum(50, 60)==0\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.923}, {"few_shot_keywords": "['sorting', 'sum', 'character', 'division', 'integer', 'validation', 'counting', 'combination', 'selling', 'conditional', 'array']", "test_keywords": "['count', 'counting', 'integer', 'round', 'consecutive', 'array', 'sorting', 'conditional', 'summands', 'combination', 'sum', 'division']", "prompt_tokens": 561, "total_tokens": 861, "completion_tokens": 300, "completion": "[Question 2]\n\nWrite a function to find the maximum sum of consecutive integers in a given array, but the sum should not exceed a given integer K. If no such sum exists, return -1.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef maxConsecutiveSum(arr: List[int], K: int) -> int:\n    n = len(arr)\n    max_sum = float('-inf')\n    current_sum = 0\n    left, right = 0, 0\n    while right < n:\n        current_sum += arr[right]\n        while current_sum > K:\n            current_sum -= arr[left]\n            left += 1\n        if current_sum > max_sum:\n            max_sum = current_sum\n        right += 1\n    return max_sum if max_sum != float('-inf') else -1\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maxConsecutiveSum([1, 3, 5, 7, 9], 15) == 15\nassert maxConsecutiveSum([5, 2, 1, 5, 3, 8], 10) == 10\nassert maxConsecutiveSum([1, 2, 3, 4, 5], 7) == 6\nassert maxConsecutiveSum([2, 3, 4, 7, 1, 5], 10) == 10", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.804}, {"few_shot_keywords": "['source', 'bottom-up', 'choose', 'average', 'count', 'iteration', 'integer', 'triangle', 'ways', 'subset']", "test_keywords": "['ways', 'integer', 'directional movement', 'path', 'operation', 'half', 'count', 'average', 'subset', 'choose', 'matrix']", "prompt_tokens": 614, "total_tokens": 1061, "completion_tokens": 447, "completion": "[Question 2]\n\nGiven a matrix of integers representing a grid, the task is to count the number of ways to choose a path from the top-left corner to the bottom-right corner, allowing only right and down directional movements, such that the average of the elements in the chosen path is greater than or equal to half of the average of all elements in the matrix.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef countWays(matrix: List[List[int]]) -> int:\n    rows, cols = len(matrix), len(matrix[0])\n    total_sum = sum(sum(row) for row in matrix)\n    target_average = total_sum / (rows * cols * 2)\n    \n    dp = [[0] * cols for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if i == 0 and j == 0:\n                dp[i][j] = 1\n            if i > 0:\n                dp[i][j] += dp[i-1][j]\n            if j > 0:\n                dp[i][j] += dp[i][j-1]\n    \n    count = 0\n    for i in range(rows):\n        for j in range(cols):\n            average = total_sum / (dp[i][j] * 2)\n            if average >= target_average:\n                count += 1\n    return count\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countWays([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 4\nassert countWays([[1, 1, 1], [1, 1, 1], [1, 1, 1]]) == 9\nassert countWays([[2, 2, 2], [2, 2, 2], [2, 2, 2]]) == 1\nassert countWays([[5, 5, 5], [5, 5, 5], [5, 5, 5]]) == 1\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.909}, {"few_shot_keywords": "['reduction', 'sum', 'exit', '2D array', 'dynamic programming', 'possible', 'entry', 'repeated', 'movement', 'matrix', 'path', 'maximum']", "test_keywords": "['path', 'maximum', 'possible', 'exit', '2D array', 'dynamic programming', 'removal', 'sum', 'entry', 'pairs', 'matrix']", "prompt_tokens": 800, "total_tokens": 1347, "completion_tokens": 547, "completion": "[Question 2]\n\nGiven a matrix of dimensions N x N, consisting of integers, write a function to find the maximum sum of a path from the entry (0, 0) to the exit (N-1, N-1), while removing any pairs of adjacent numbers with a difference of 1 along the path. If it is not possible to reach the exit while following this rule, return 0.\n\n[/Question 2]\n\n[Code 2]\n\ndef maxSumPathWithRemoval(matrix):\n    n = len(matrix)\n    dp = [[0] * n for _ in range(n)]\n    dp[0][0] = matrix[0][0]\n\n    for i in range(1, n):\n        if abs(matrix[i][0] - matrix[i-1][0]) == 1:\n            dp[i][0] = 0\n        else:\n            dp[i][0] = dp[i-1][0] + matrix[i][0]\n        \n    for j in range(1, n):\n        if abs(matrix[0][j] - matrix[0][j-1]) == 1:\n            dp[0][j] = 0\n        else:\n            dp[0][j] = dp[0][j-1] + matrix[0][j]\n\n    for i in range(1, n):\n        for j in range(1, n):\n            if abs(matrix[i][j] - matrix[i-1][j]) == 1 or abs(matrix[i][j] - matrix[i][j-1]) == 1:\n                dp[i][j] = 0\n            else:\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + matrix[i][j]\n\n    return dp[-1][-1]\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maxSumPathWithRemoval([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 0\nassert maxSumPathWithRemoval([[1, 2, 4], [3, 6, 5], [9, 8, 7]]) == 33\nassert maxSumPathWithRemoval([[6, 5, 3], [4, 2, 1], [7, 8, 9]]) == 35\nassert maxSumPathWithRemoval([[10, 2, 3], [4, 5, 6], [7, 8, 9]]) == 50\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.729}, {"few_shot_keywords": "['pattern', 'OR', 'integers', 'bitwise', 'query', 'lexicographical', 'array', 'range']", "test_keywords": "['bitwise', 'OR', 'positive', 'query', 'concatenation', 'range', 'indexing', 'integers', 'array', 'tiling']", "prompt_tokens": 667, "total_tokens": 1052, "completion_tokens": 385, "completion": "[Question 2]\n\nYou are given an array of positive integers and q queries. Each query is represented by two integers L and R. Your task is to concatenate the binary representations of the integers within the index range [L, R] (both inclusive) and then find the bitwise OR of the concatenated binary strings.\n\n[/Question 2]\n\n[Code 2]\n\ndef queryConcatenatedBitwiseOr(arr, queries):\n    result = []\n    for query in queries:\n        L, R = query\n        concatenated_binary = \"\"\n        for i in range(L, R+1):\n            concatenated_binary += bin(arr[i])[2:]\n        bitwiseOR = 0\n        for bit in concatenated_binary:\n            bitwiseOR |= int(bit)\n        result.append(bitwiseOR)\n    return result\n\n[/Code 2]\n\n[Asserts 2]\n\nassert queryConcatenatedBitwiseOr([1, 2, 3, 4, 5], [[1, 3], [2, 4], [0, 2]]) == [1, 7, 3]\nassert queryConcatenatedBitwiseOr([5, 7, 2, 9, 8, 6], [[1, 4], [0, 3], [2, 5]]) == [15, 15, 15]\nassert queryConcatenatedBitwiseOr([5, 3, 6, 9, 12], [[1, 2], [0, 4], [2, 3]]) == [7, 15, 15]\nassert queryConcatenatedBitwiseOr([10, 15, 20, 25, 30], [[1, 3], [3, 4], [0, 2]]) == [31, 29, 31]\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.723}, {"few_shot_keywords": "['dynamic programming', 'top-down', 'bottom-up', 'xor', 'maximum', 'sum', 'traversal', 'subsets', 'matrix', 'nodes', 'path']", "test_keywords": "['LCM', 'non-zero', 'break', 'sum', 'maximum', 'node', 'bottom-up', 'matrix', 'top-down', 'dynamic programming', 'path', 'traversal', 'combinations']", "prompt_tokens": 829, "total_tokens": 1305, "completion_tokens": 476, "completion": "[Question 2]\n\nYou are given a binary tree where each node contains a non-zero integer. Write a function to find the maximum sum of the least common multiple (LCM) of all possible paths from any node to any node in the tree. You are allowed to break the path and traverse it in any direction.\n\n[/Question 2]\n\n[Code 2]\n\nclass TreeNode:\n    def __init__(self, value=0, left=None, right=None):\n        self.value = value\n        self.left = left\n        self.right = right\n\ndef maxLCMSum(root: TreeNode) -> int:\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n    \n    def lcm(a, b):\n        return (a * b) // gcd(a, b)\n    \n    def dfs(node):\n        if not node:\n            return (0, 0)\n        \n        left_lcm, left_sum = dfs(node.left)\n        right_lcm, right_sum = dfs(node.right)\n        \n        current_value = node.value\n        \n        return_lcm = max(left_lcm, right_lcm, lcm(left_sum, current_value), lcm(right_sum, current_value), lcm(left_sum, right_sum, current_value))\n        return_sum = max(left_sum, right_sum) + current_value\n        \n        return return_lcm, return_sum\n    \n    result, _ = dfs(root)\n    return result\n\n[/Code 2]\n\n[Asserts 2]\n\n# Example Tree:\n#        1\n#       / \\\n#      2   3\n#     / \\ / \\\n#    4  5 6  7\n\nroot = TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(5)), TreeNode(3, TreeNode(6), TreeNode(7)))\nassert maxLCMSum(root) == 21\n\n# Example Tree:\n#        2\n#       / \\\n#      3   4\n#     / \\ / \\\n#    5  6 7  8\n\nroot = TreeNode(2, TreeNode(3, TreeNode(5), TreeNode(6)), TreeNode(4, TreeNode(7), TreeNode(8)))\nassert maxLCMSum(root) == 56\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.722}, {"few_shot_keywords": "['graph', 'Bellman-Ford algorithm', 'weight', 'number', 'negative weight cycle', 'vertices', 'shortest distance', 'edges']", "test_keywords": "['edges', 'shortest distance', 'negative weight cycle', 'rotation', 'tiling', 'vertices', 'Bellman-Ford algorithm', 'graph']", "prompt_tokens": 686, "total_tokens": 1216, "completion_tokens": 530, "completion": "[Question 2]\n\nYou are given a weighted graph with both positive and negative edge weights. The task is to find the shortest distance of the shortest path from a given source vertex to all vertices using the Bellman-Ford algorithm. However, there is a catch - the graph is periodically updated with edge weight rotations after a specified number of iterations. How would you modify the Bellman-Ford algorithm to handle such edge weight rotations and find the shortest distances after each rotation?\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List, Tuple\n\nclass Graph:\n    def __init__(self, vertices: int) -> None:\n        self.V = vertices\n        self.graph = []\n\n    def add_edge(self, u: int, v: int, w: int) -> None:\n        self.graph.append([u, v, w])\n\n    def bellman_ford_with_rotation(self, src: int, rotations: int, rotation_interval: int) -> List[List[int]]:\n        dist = [[float(\"Inf\")] * self.V for _ in range(rotations + 1)]\n        dist[0][src] = 0\n\n        for k in range(1, rotations + 1):\n            for u, v, w in self.graph:\n                if k % rotation_interval == 0:\n                    w *= -1  # rotate the edge weight\n                if dist[k - 1][u] != float(\"Inf\") and dist[k - 1][u] + w < dist[k][v]:\n                    dist[k][v] = dist[k - 1][u] + w\n\n        return dist\n\n[/Code 2]\n\n[Asserts 2]\n\ng = Graph(5)\ng.add_edge(0, 1, 4)\ng.add_edge(0, 2, 8)\ng.add_edge(1, 2, 3)\ng.add_edge(1, 3, 2)\ng.add_edge(1, 4, 5)\ng.add_edge(3, 2, 1)\ng.add_edge(3, 1, 2)\ng.add_edge(4, 3, 3)\nassert g.bellman_ford_with_rotation(0, 3, 2) == [[0, 4, 7, 9, 9], [0, 4, 7, 9, 9], [0, -4, -1, 1, 6], [0, -4, -1, 1, 6]]\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.737}, {"few_shot_keywords": "['resultant', 'tree', 'absolute differences', 'graph', 'break', 'OR', 'edges', 'same', 'two', 'sum', 'bitwise']", "test_keywords": "['two', 'OR', 'tree', 'edges', 'same', 'children', 'resultant', 'break', 'bitwise', 'selling', 'stones', 'graph']", "prompt_tokens": 700, "total_tokens": 1202, "completion_tokens": 502, "completion": "[Question 2]\n\nYou are given a tree with N nodes and an integer array representing the values of the nodes. You need to write a function to find the maximum number of stones you can sell, where you break at most one edge to make the bitwise OR of the resulting two subtrees the same.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List, Tuple\ndef maxStones(N: int, values: List[int], edges: List[Tuple[int, int]]) -> int:\n    tree = [[] for _ in range(N)]\n    for u, v in edges:\n        tree[u-1].append(v-1)\n        tree[v-1].append(u-1)\n    \n    subtree_or = [0] * N\n    total_or = [0] * N\n    \n    def dfs(node, parent):\n        subtree_or[node] = values[node]\n        for child in tree[node]:\n            if child != parent:\n                subtree_or[node] |= dfs(child, node)\n        return subtree_or[node]\n    \n    def dfs2(node, parent, val):\n        total_or[node] = val\n        for child in tree[node]:\n            if child != parent:\n                dfs2(child, node, val | (subtree_or[node] if child == tree[node][0] else total_or[node]))\n    \n    dfs(0, -1)\n    dfs2(0, -1, 0)\n    \n    ans = 0\n    for node in range(N):\n        ans = max(ans, values[node] | total_or[node])\n    \n    return sum(bin(ans).count('1') for _ in range(32))\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maxStones(5, [1, 2, 3, 4, 5], [(1, 2), (1, 3), (2, 4), (2, 5)])==6\nassert maxStones(3, [2, 3, 1], [(1, 2), (2, 3)])==3\nassert maxStones(7, [1, 2, 3, 4, 5, 6, 7], [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7)])==7\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.823}, {"few_shot_keywords": "['pair', 'array', 'conditional', 'composite', 'summands', 'math', 'maximum', 'division', 'digit', 'age', 'difference']", "test_keywords": "['summands', 'DFS', 'average', 'math', 'composite', 'conditional', 'maximum', 'division', 'max', 'terrain', 'feasible']", "prompt_tokens": 486, "total_tokens": 1052, "completion_tokens": 566, "completion": "[Question 2]\n\nYou are given a terrain represented as a matrix where each cell represents the height of the terrain. You need to find the maximum feasible average of the terrain by dividing it into a maximum number of composite summands.\n\n[/Question 2]\n\n[Code 2]\n\ndef maxFeasibleAverageTerrain(terrain):\n    def isFeasible(average, terrain, k):\n        n = len(terrain)\n        m = len(terrain[0])\n        prefix = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(1, m + 1):\n                prefix[i][j] = prefix[i - 1][j] + prefix[i][j - 1] - prefix[i - 1][j - 1] + terrain[i - 1][j - 1]\n        for i in range(n - k + 1):\n            for j in range(m - k + 1):\n                summa = prefix[i + k][j + k] - prefix[i][j + k] - prefix[i + k][j] + prefix[i][j]\n                if summa / (k * k) >= average:\n                    return True\n        return False\n\n    def feasible(average, terrain, k):\n        n = len(terrain)\n        m = len(terrain[0])\n        for i in range(n - k + 1):\n            for j in range(m - k + 1):\n                if isFeasible(average, terrain[i:i + k], k):\n                    return True\n        return False\n\n    n = len(terrain)\n    m = len(terrain[0])\n    l, r = 1, max(max(row) for row in terrain)\n    precision = 1e-6\n    while r - l > precision:\n        mid = (l + r) / 2\n        if feasible(mid, terrain, k):\n            l = mid\n        else:\n            r = mid\n    return l\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maxFeasibleAverageTerrain([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 4.5\nassert maxFeasibleAverageTerrain([[3, 3, 3], [3, 3, 3], [3, 3, 3]]) == 3.0\nassert maxFeasibleAverageTerrain([[5, 3, 1], [2, 4, 2], [3, 4, 5]]) == 4.0", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.727}, {"few_shot_keywords": "['optimization', 'indices', 'move', 'array', 'beginning', 'cost', 'grid', 'reach', 'dynamic programming', 'consecutive', 'minimum', 'added']", "test_keywords": "['length', 'minimum', 'array', 'move', 'consecutive', 'sum', 'positive integers', 'inserting', 'indices', 'dynamic programming', 'floor', 'cost', 'reach', 'beginning']", "prompt_tokens": 657, "total_tokens": 1048, "completion_tokens": 391, "completion": "[Question 2]\n\nYou are given an array of positive integers. The task is to insert minimum number of positive integers into the array in such a way that the sum of any consecutive subarray is a multiple of a given integer K. Determine the minimum number of positive integers that must be inserted.\n\n[/Question 2]\n\n[Code 2]\n\ndef minInsertions(arr: list, n: int, k: int) -> int:\n    dp = [float(\"inf\")] * (k + 1)\n    dp[0] = 0\n    prefix_sum = 0\n    for num in arr:\n        prefix_sum += num\n        prefix_sum %= k\n        for j in range(k):\n            dp[(prefix_sum + j) % k] = min(dp[(prefix_sum + j) % k], dp[j] + (j != prefix_sum % k))\n    return dp[0] if dp[0] != float(\"inf\") else -1\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minInsertions([4, 2, 1, 6, 3], 5, 5) == 1\nassert minInsertions([1, 2, 3], 3, 3) == 2\nassert minInsertions([7, 4, 3, 10, 2, 2, 5, 6], 8, 5) == 0\nassert minInsertions([3, 1, 7, 5, 4], 5, 6) == -1\nassert minInsertions([2, 4, 6, 8, 10], 5, 3) == 0\nassert minInsertions([5, 17, 100, 11], 4, 10) == 1\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.91}, {"few_shot_keywords": "['visited', 'obstacle', 'adjacent', 'source', 'math', '2D', 'grid', 'subtree', 'iteration', 'cell', 'queue', 'frequency', 'distance']", "test_keywords": "['distance', 'grid', 'obstacle', 'source', '2D', 'adjacent', 'binary tree', 'visited', 'negative weight cycle', 'set bits', 'station', 'queue', 'selling', 'iteration', 'cell']", "prompt_tokens": 1226, "total_tokens": 1932, "completion_tokens": 706, "completion": "[Question 2]\n\nYou are given a 2D grid representing a city's map, where each cell represents a station. Some cells may contain obstacles, and some cells may represent the selling stations. You are also given a source cell in the grid. The task is to find the distance of the nearest selling station for each cell in the grid. If a cell is an obstacle or it does not have a path to a selling station, then the distance for that cell should be -1.\n\n[/Question 2]\n\n[Code 2]\n\nfrom collections import deque\n\ndef isValid(x, y, rows, cols):\n    return 0 <= x < rows and 0 <= y < cols\n\ndef nearestSellingStation(grid, rows, cols, source):\n    queue = deque()\n    queue.append((*source, 0))\n    visited = set()\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    while queue:\n        x, y, dist = queue.popleft()\n        if grid[x][y] == 1:\n            return dist\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if isValid(nx, ny, rows, cols) and (nx, ny) not in visited and grid[nx][ny] != -1:\n                visited.add((nx, ny))\n                queue.append((nx, ny, dist + 1))\n    \n    return -1\n\ndef findNearestSellingStations(grid, rows, cols):\n    result = [[0 for _ in range(cols)] for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 0:\n                result[i][j] = nearestSellingStation(grid, rows, cols, (i, j))\n            else:\n                result[i][j] = 0\n    return result\n\n[/Code 2]\n\n[Asserts 2]\n\nassert findNearestSellingStations([\n    [0, 0, 0, 0],\n    [0, -1, -1, 0],\n    [0, 0, 0, 0],\n], 3, 4) == [\n    [6, 5, 6, 7],\n    [5, -1, -1, 6],\n    [4, 3, 4, 5]\n]\n\nassert findNearestSellingStations([\n    [0, -1, 0, -1],\n    [0, 0, 0, 0],\n    [0, -1, 0, -1],\n], 3, 4) == [\n    [5, -1, 4, -1],\n    [4, 3, 4, 5],\n    [5, -1, 4, -1]\n]\n\nassert findNearestSellingStations([\n    [0, 0, 1, 0],\n    [0, -1, 0, 0],\n    [0, 0, 0, 0],\n], 3, 4) == [\n    [2, 1, 0, 1],\n    [1, -1, 1, 2],\n    [2, 1, 2, 3]\n]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.773}, {"few_shot_keywords": "['operations', 'lexicographical', 'ones', 'flip', 'binary', 'consecutive', 'index', 'zeros', 'nearest', 'string']", "test_keywords": "['flip', 'replacements', 'check', 'operations', 'ones', 'consecutive', 'zeros', 'string', 'binary', 'indices', 'possible', 'age']", "prompt_tokens": 510, "total_tokens": 731, "completion_tokens": 221, "completion": "[Question 2]\n\nGiven a binary string S and a list of indices, the task is to perform a flip operation at the specified indices and return the final string after all the operations.\n\nWrite a function to perform the flip operations and return the modified string.\n\n[/Question 2]\n\n[Code 2]\n\ndef perform_flips(S, indices):\n    for index in indices:\n        S = S[:index] + ('1' if S[index] == '0' else '0') + S[index+1:]\n    return S\n\n[/Code 2]\n\n[Asserts 2]\n\nassert perform_flips(\"1101000\", [1, 2, 5]) == \"1010110\"\nassert perform_flips(\"001100011\", [0, 1, 8]) == \"110011100\"\nassert perform_flips(\"1111\", [1, 2, 3]) == \"1000\"\nassert perform_flips(\"0000\", [0, 1, 2, 3]) == \"1111\"\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.921}, {"few_shot_keywords": "['iteration', 'color', 'repeatedly', 'bracket', 'minimum', 'representation', 'sequence', 'math']", "test_keywords": "['subset', 'max sum', 'minimum', 'form', 'value', 'math', 'bracket', 'sequence', 'conditional']", "prompt_tokens": 440, "total_tokens": 684, "completion_tokens": 244, "completion": "[Question 2]\n\nGiven a list of integers, write a function to find the maximum sum of a subset of the list, where the subset can be formed by including or excluding each element, and the sum should be minimized if it exceeds a certain value.\n\n[/Question 2]\n\n[Code 2]\n\ndef maxSumSubset(input_list: List[int], target_sum: int) -> int:\n    max_sum = 0\n    for i in range(1, len(input_list) + 1):\n        for subset in itertools.combinations(input_list, i):\n            if sum(subset) <= target_sum:\n                max_sum = max(max_sum, sum(subset))\n    return max_sum\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maxSumSubset([1, 2, 3, 4], 5) == 4\nassert maxSumSubset([1, 2, 3, 4], 6) == 6\nassert maxSumSubset([4, 1, 2, 3], 5) == 4\nassert maxSumSubset([4, 1, 2, 3], 8) == 8", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.862}, {"few_shot_keywords": "['longest subsequence', 'dynamic programming', 'minimum', 'list', 'distinct', 'combination', 'range', 'target amount', 'coin change']", "test_keywords": "['distinct', 'dynamic programming', 'list', 'minimum', 'combination', 'target amount', 'coin change', 'destination', 'heads']", "prompt_tokens": 562, "total_tokens": 963, "completion_tokens": 401, "completion": "[Question 2]\n\nYou have been given a list of coins, each representing a distinct value, and a target amount to reach. You need to find the minimum number of coins required to make up the target amount. The coins have two sides - heads and tails. Write a function to determine the minimum number of coins needed to reach the target amount, using dynamic programming. Additionally, find the combination of coins that reach the target amount and return the combination that has the maximum number of heads facing up.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef minCoinsWithMaxHeads(coins: List[int], amount: int) -> int:\n    dp = [float('inf')] * (amount + 1)\n    dp[0] = 0\n    coin_combinations = [[] for _ in range(amount + 1)]\n    for coin in coins:\n        for i in range(coin, amount + 1):\n            if dp[i - coin] + 1 < dp[i]:\n                dp[i] = dp[i - coin] + 1\n                coin_combinations[i] = coin_combinations[i - coin] + [coin]\n    max_heads = 0\n    max_heads_combination = []\n    for combination in coin_combinations[amount]:\n        heads_count = sum([1 for coin in combination if coin % 2 == 0])\n        if heads_count > max_heads:\n            max_heads = heads_count\n            max_heads_combination = combination\n    return dp[amount], max_heads_combination\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minCoinsWithMaxHeads([1, 2, 5], 11)==(3, [5, 5, 1])\nassert minCoinsWithMaxHeads([2], 3)==(float('inf'), [])\nassert minCoinsWithMaxHeads([2], 4)==(2, [2, 2])", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.85}, {"few_shot_keywords": "['pattern', 'segment', 'sign', 'length', 'binary', 'construct', 'string', 'counting']", "test_keywords": "['length', 'binary', 'segment', 'pattern', 'alphabets', 'node weight', 'connected component', 'string', 'counting']", "prompt_tokens": 464, "total_tokens": 696, "completion_tokens": 232, "completion": "[Question 2]\n\nYou are given a string S consisting of lowercase alphabets. Your task is to find the count of binary segments in S, where a binary segment is a substring that follows the pattern \"01\" or \"10\".\n\n[/Question 2]\n\n[Code 2]\n\ndef countBinarySegments(s: str) -> int:\n    count = 0\n    i = 0\n    while i < len(s) - 1:\n        if (s[i] == '0' and s[i + 1] == '1') or (s[i] == '1' and s[i + 1] == '0'):\n            count += 1\n            i += 2\n        else:\n            i += 1\n    return count\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countBinarySegments(\"0010110\") == 3\nassert countBinarySegments(\"1010101\") == 6\nassert countBinarySegments(\"000111000\") == 2\nassert countBinarySegments(\"11001100\") == 3\nassert countBinarySegments(\"111\") == 0", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.88}, {"few_shot_keywords": "['character', 'tiling', 'longest', 'vowels', 'dynamic programming', 'common', 'comparison', 'string', 'memoization', 'subsequence', 'partition', 'floor']", "test_keywords": "['comparison', 'common', 'sum', 'convert', 'abs', 'set bits', 'permutation', 'longest', 'subsequence', 'dynamic programming', 'vowels', 'string']", "prompt_tokens": 634, "total_tokens": 966, "completion_tokens": 332, "completion": "[Question 2]\n\nGiven a string s, find the length of the longest subsequence such that the absolute difference between the sum of ASCII values of vowels in the subsequence and the sum of ASCII values of consonants in the subsequence is maximum.\n\n[/Question 2]\n\n[Code 2]\n\ndef longestSubsequenceWithMaxASCIIsumDifference(s: str) -> int:\n    def isVowel(c):\n        return c in \"aeiouAEIOU\"\n\n    dp = [[0] * 2 for _ in range(len(s) + 1)]\n\n    for i in range(1, len(s) + 1):\n        if isVowel(s[i - 1]):\n            dp[i][0] = dp[i - 1][0] + ord(s[i - 1])\n            dp[i][1] = dp[i - 1][1]\n        else:\n            dp[i][0] = dp[i - 1][0]\n            dp[i][1] = dp[i - 1][1] + ord(s[i - 1])\n\n    return abs(dp[-1][0] - dp[-1][1])\n\n[/Code 2]\n\n[Asserts 2]\n\nassert longestSubsequenceWithMaxASCIIsumDifference(\"abcde\")==8\nassert longestSubsequenceWithMaxASCIIsumDifference(\"xyz\")==0\nassert longestSubsequenceWithMaxASCIIsumDifference(\"aAeEiIoOuU\")==30\nassert longestSubsequenceWithMaxASCIIsumDifference(\"hello\")==32\nassert longestSubsequenceWithMaxASCIIsumDifference(\"programming\")==72\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.815}, {"few_shot_keywords": "['zeros', 'addition', 'subset', 'algorithm', 'set', 'union', 'merge', 'distinct', 'array', 'integers', 'sums']", "test_keywords": "['integers', 'merge', 'union', 'distinct', 'array', 'addition', 'multiple', 'subset', 'sums', 'reduction', 'set']", "prompt_tokens": 673, "total_tokens": 1118, "completion_tokens": 445, "completion": "[Question 2]\n\nGiven two arrays of integers, write a function to merge the arrays and find the distinct subset sums of the merged array.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List, Set\ndef distinctSubsetSumsAfterMerge(arr1: List[int], arr2: List[int]) -> Set[int]:\n    merged_arr = arr1 + arr2\n    n = len(merged_arr)\n    subset_sums = set()\n\t\n\t# Loop to iterate over all the elements from the merged array\n    for i in range(n):\n        temp_set = set()\n\t\t# Iterate over all elements in subset_sums\n        for ss in subset_sums:\n            # Add ith element to all elements of set represented by ss\n            temp_set.add(ss + merged_arr[i])\n        temp_set.add(merged_arr[i])\n\n\t\t# At the end merge both set - subset_sums and temp_set\n        subset_sums = subset_sums.union(temp_set)\n    return subset_sums\n\n[/Code 2]\n\n[Asserts 2]\n\nassert distinctSubsetSumsAfterMerge([2, 3], [1, 4])=={0, 1, 2, 3, 4, 5, 6, 7}\nassert distinctSubsetSumsAfterMerge([1, 1, 1], [2, 2])=={0, 1, 2, 3, 4}\nassert distinctSubsetSumsAfterMerge([5], [6, 7])=={0, 5, 6, 7, 11, 12, 13}\nassert distinctSubsetSumsAfterMerge([1, 2, 3], [2])=={0, 1, 2, 3, 4, 5, 6}\nassert distinctSubsetSumsAfterMerge([1, 2, 2, 3, 4], [3, 4])=={0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.826}, {"few_shot_keywords": "['divisibility', 'iteration', 'substrings', 'character removal', 'power', 'empty', 'age', 'string', 'minimum', 'binary', 'tiles', 'split']", "test_keywords": "['split', 'iteration', 'power', 'divisibility', 'substrings', 'binary', 'string', 'possible', 'minimum']", "prompt_tokens": 595, "total_tokens": 838, "completion_tokens": 243, "completion": "[Question 2]\n\nGiven a binary string, write a function to determine the minimum number of iterations required to split the string into substrings such that each substring is a power of 2.\n\n[/Question 2]\n\n[Code 2]\n\ndef isPowerOfTwo(num):\n    return num != 0 and ((num & (num - 1)) == 0)\n\ndef minIterationsToPowerOfTwo(s: str) -> int:\n    n = len(s)\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n\n    for i in range(1, n + 1):\n        for j in range(i):\n            if isPowerOfTwo(int(s[j:i], 2)):\n                dp[i] = min(dp[i], dp[j] + 1)\n\n    return dp[n]\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minIterationsToPowerOfTwo(\"1101001100\") == 3\nassert minIterationsToPowerOfTwo(\"1010101010\") == 2\nassert minIterationsToPowerOfTwo(\"110101110111\") == 4\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.8}, {"few_shot_keywords": "['array', 'feasible', 'integers', 'maximized', 'max', 'sum', 'round', 'average', 'partition', 'deletion']", "test_keywords": "['feasible', 'partition', 'maximized', 'array', 'DFS', 'average', 'score', 'integers', 'strings', 'sum']", "prompt_tokens": 638, "total_tokens": 978, "completion_tokens": 340, "completion": "[Question 2]\n\nGiven a list of integers, your task is to partition the array into multiple subarrays such that the sum of the integers in each subarray is maximized. Write a function to find the maximum sum achievable after partitioning the array.\n\n[/Question 2]\n\n[Code 2]\n\ndef max_sum_partition(arr: List[int], k: int) -> int:\n    def is_feasible(arr, k, max_sum):\n        count, cur_sum = 1, 0\n        for num in arr:\n            cur_sum += num\n            if cur_sum > max_sum:\n                count += 1\n                cur_sum = num\n        return count <= k\n\n    start, end = max(arr), sum(arr)\n    while start < end:\n        mid = start + (end - start) // 2\n        if is_feasible(arr, k, mid):\n            end = mid\n        else:\n            start = mid + 1\n    return start\n\n[/Code 2]\n\n[Asserts 2]\n\nassert max_sum_partition([1, 4, 5, 2, 3], 3) == 5\nassert max_sum_partition([7, 2, 5, 10, 8], 2) == 18\nassert max_sum_partition([3, 4, 2, 8, 7], 4) == 8\nassert max_sum_partition([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 1) == 55\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.791}, {"few_shot_keywords": "['modulus', 'subtract', 'add', 'maximum', 'minimum', 'reduction', 'rotation', 'task', 'values', 'expression', 'digits', 'algebraic', 'order of operations']", "test_keywords": "['add', 'expression', 'turn', 'partition', 'order of operations', 'digits', 'minimum', 'maximum', 'concatenating', 'total', 'values', 'algebraic', 'queries', 'subtract']", "prompt_tokens": 550, "total_tokens": 814, "completion_tokens": 264, "completion": "[Question 2]\n\nYou are given a list of algebraic expressions as strings. Write a program to process each expression and return the total of maximum and minimum possible values after performing the given operations. The operations include adding and subtracting digits and the order of operations must be followed.\n\n[/Question 2]\n\n[Code 2]\n\ndef processExpressions(expressions: list) -> list:\n    results = []\n    for expression in expressions:\n        nums = list(map(int, ''.join(filter(lambda x: x.isdigit() or x in ['+', '-'], expression)).split('+'))\n        max_val = sum(nums)\n        for num in nums[1:]:\n            max_val -= num * 2\n        min_val = sum(nums) - 2 * sum([min(num, 0) for num in nums])\n        results.append((min_val, max_val))\n    return results\n\n[/Code 2]\n\n[Asserts 2]\n\nassert processExpressions([\"1+2-3\", \"4+2-6+1+3\"]) == [(-4, 0), (-2, 14)]\nassert processExpressions([\"10+20-30\", \"5+7-8+10-15\"]) == [(0, 0), (-11, 9)]\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.888}, {"few_shot_keywords": "['grid', 'segments', 'cells', 'swapping', 'maximum', 'recursive', 'length', 'multiplying', 'cut', 'optimization', 'max', 'rope', 'subproblems']", "test_keywords": "['rope', 'recursive', 'cut', 'winner', 'optimization', 'subproblems', 'segments', 'maximum', 'odd', 'length']", "prompt_tokens": 596, "total_tokens": 881, "completion_tokens": 285, "completion": "[Question 2]\n\nYou are organizing a rope-cutting competition in which participants take turns to cut a rope of a given length. The goal is to make the remaining rope length odd after each cut. The winner is the participant who makes the maximum number of cuts while keeping the remaining rope length odd. If no participant can make a cut to keep the remaining rope length odd, then the first participant is declared the winner.\n\nWrite a function to determine the winner of the competition given the length of the rope and the participants' names in the order they cut the rope. The function should return the name of the winner.\n\n[/Question 2]\n\n[Code 2]\n\ndef ropeCuttingWinner(length: int, participants: List[str]) -> str:\n    if length % 2 == 0:\n        return participants[0]\n    else:\n        return participants[-1]\n\n[/Code 2]\n\n[Asserts 2]\n\nassert ropeCuttingWinner(10, ['Alice', 'Bob', 'Charlie', 'David'])=='David'\nassert ropeCuttingWinner(15, ['Alice', 'Bob', 'Charlie', 'David'])=='Alice'\nassert ropeCuttingWinner(7, ['Alice', 'Bob', 'Charlie', 'David'])=='David'\nassert ropeCuttingWinner(20, ['Alice', 'Bob', 'Charlie', 'David'])=='Alice'\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.842}, {"few_shot_keywords": "['while loop', 'maximize', 'integers', 'empty', 'array', 'vertices', 'remove', 'subset', 'bisect', 'sum', 'max']", "test_keywords": "['remove', 'swaps', 'array', 'empty', 'max', 'integers', 'selling', 'while loop', 'sum', 'repetitive', 'maximize']", "prompt_tokens": 528, "total_tokens": 878, "completion_tokens": 350, "completion": "[Question 2]\n\nYou are given an array of integers. Your task is to find the maximum sum that can be obtained by repeatedly removing the maximum element from the array and adding it to a separate selling array, with the condition that you can perform at most k swaps of adjacent elements in the original array.\n\n[/Question 2]\n\n[Code 2]\n\ndef maxSumWithSwaps(arr, k):\n    sellingArr = []\n    while k > 0:\n        i = 0\n        while i < len(arr) - 1 and k > 0:\n            if arr[i] < arr[i + 1]:\n                arr[i], arr[i + 1] = arr[i + 1], arr[i]\n                sellingArr.append(arr.pop())\n                k -= 1\n                i += 2\n            else:\n                i += 1\n        if i == len(arr) - 1 and k > 0:\n            arr[-1], arr[-2] = arr[-2], arr[-1]\n            sellingArr.append(arr.pop())\n            k -= 1\n    return sum(sellingArr)\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maxSumWithSwaps([4, 2, 5, 1], 2) == 15\nassert maxSumWithSwaps([3, 2, 1, 4], 3) == 10\nassert maxSumWithSwaps([1, 2, 3, 4], 1) == 7\nassert maxSumWithSwaps([5, 5, 5, 5, 5], 4) == 25\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.701}, {"few_shot_keywords": "['precede', 'bit', 'swapping', 'strings', 'concatenating', 'subsequence', 'algorithm', 'dynamic programming', 'length', 'consecutive segments', 'longest subsequence', 'segments', 'value']", "test_keywords": "['subsequence', 'largest number', 'dynamic programming', 'strings', 'longest subsequence', 'math', 'consecutive segments', 'algorithm', 'concatenating', 'length', 'mapping']", "prompt_tokens": 738, "total_tokens": 1051, "completion_tokens": 313, "completion": "[Question 2]\n\nYou are given an array of non-negative integers. Write a function to return the largest number possible by concatenating the elements of the array as a single string. The catch is that the elements are to be selected from the array such that they form a subsequence where each pair of consecutive elements have a difference of at most K.\n\n[/Question 2]\n\n[Code 2]\n\ndef largestNumberWithConsecutiveDifference(nums, K):\n    dp = {}\n    for num in nums:\n        if num not in dp:\n            dp[num] = 1\n    for num in nums:\n        if num - K in dp:\n            dp[num] = max(dp[num], dp[num-K] + 1)\n    return max(dp.values())\n\n[/Code 2]\n\n[Asserts 2]\n\nassert largestNumberWithConsecutiveDifference([3, 6, 9, 1], 3) == 3\nassert largestNumberWithConsecutiveDifference([1, 2, 3, 4, 5], 1) == 5\nassert largestNumberWithConsecutiveDifference([13, 21, 34, 55, 89], 10) == 2\nassert largestNumberWithConsecutiveDifference([10, 11, 12, 15, 18], 2) == 3\nassert largestNumberWithConsecutiveDifference([9, 5, 3, 8, 2], 4) == 3\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.774}, {"few_shot_keywords": "['combinatorics', 'top', 'permutation', 'greater', 'floor', 'character count', 'power', 'condition', 'size', 'counting', 'array']", "test_keywords": "['size', 'delete', 'condition', 'consecutive elements', 'permutation', 'element', 'power', 'coins', 'array', 'counting', 'combinatorics', 'inserting']", "prompt_tokens": 479, "total_tokens": 681, "completion_tokens": 202, "completion": "[Question 2]\n\nGiven an array of integers, find the number of ways to delete an element from the array such that the remaining elements are in increasing order.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\ndef countIncreasingArrays(arr: List[int]) -> int:\n    n = len(arr)\n    count = 0\n    for i in range(n):\n        if (i == 0 or arr[i] > arr[i-1]) and (i == n-1 or arr[i] < arr[i+1]):\n            count += 1\n    return count\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countIncreasingArrays([1, 2, 3, 4, 5])==5\nassert countIncreasingArrays([5, 3, 8, 6, 4])==1\nassert countIncreasingArrays([1, 2, 3, 2, 4, 5, 6])==4", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.879}, {"few_shot_keywords": "['OR', 'length', 'string', 'subsequences', 'left', 'palindromic', 'integer']", "test_keywords": "['dictionary', 'length', 'adjacency list', 'string', 'subsequences', 'integer', 'palindromic']", "prompt_tokens": 578, "total_tokens": 858, "completion_tokens": 280, "completion": "[Question 2]\n\nGiven a dictionary of strings, the task is to find the length of the longest palindromic subsequence that can be formed by concatenating any number of subsequences from the given dictionary.\n\n[/Question 2]\n\n[Code 2]\n\ndef isPalindrome(s: str) -> bool:\n\treturn s == s[::-1]\n\ndef longestPalindromicSubsequenceLength(dictionary: List[str]) -> int:\n\tmaxLength = 0\n\tfor i in range(len(dictionary)):\n\t\tfor j in range(i, len(dictionary)):\n\t\t\tconcatenated = ''.join(dictionary[i:j+1])\n\t\t\tif isPalindrome(concatenated):\n\t\t\t\tmaxLength = max(maxLength, len(concatenated))\n\treturn maxLength\n\n[/Code 2]\n\n[Asserts 2]\n\nassert longestPalindromicSubsequenceLength([\"ab\", \"ba\", \"abc\", \"cb\"]) == 5\nassert longestPalindromicSubsequenceLength([\"a\", \"b\", \"c\"]) == 1\nassert longestPalindromicSubsequenceLength([\"abcd\", \"dcba\"]) == 8\nassert longestPalindromicSubsequenceLength([\"abc\", \"def\", \"f\", \"ed\", \"cba\"]) == 7\nassert longestPalindromicSubsequenceLength([\"abc\", \"def\"]) == 1\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.794}, {"few_shot_keywords": "['ASCII', 'remove', 'string', 'character removal', 'Longest Common Subsequence', 'dynamic programming', 'powers', 'cost']", "test_keywords": "['dynamic programming', 'character removal', 'path', 'cost', 'ASCII', 'string', 'combinations', 'queue', 'Longest Common Subsequence', 'vertices']", "prompt_tokens": 671, "total_tokens": 946, "completion_tokens": 275, "completion": "[Question 2]\n\nYou are given a string S and an integer K. Write a function to find the number of distinct strings that can be formed by removing exactly K characters from S such that the remaining string has its characters in non-decreasing order of ASCII values. \n\n[/Question 2]\n\n[Code 2]\n\nfrom collections import deque\n\ndef countValidStrings(S: str, K: int) -> int:\n    n = len(S)\n    dp = [[0 for _ in range(K+1)] for _ in range(n+1)]\n    dp[0][0] = 1\n\n    for i in range(1, n+1):\n        dp[i][0] = 1\n        for k in range(1, K+1):\n            dp[i][k] = dp[i-1][k] + dp[i-1][k-1] * (ord(S[i-1])-ord('a')+1)\n\n    return dp[n][K]\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countValidStrings(\"abc\", 2) == 10\nassert countValidStrings(\"abd\", 3) == 20\nassert countValidStrings(\"xy\", 1) == 4\nassert countValidStrings(\"xyz\", 2) == 10\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.94}, {"few_shot_keywords": "['placement', 'diagonal', 'matrix', 'market', 'top', 'sum', 'maximum', 'repetitions', 'element', 'path', 'bottom', 'directional movement', 'strategy']", "test_keywords": "['directional movement', 'memoization', 'positive integers', 'diagonal', 'matrix', 'bottom', 'path', 'ones', 'maximum', 'top', 'sum']", "prompt_tokens": 810, "total_tokens": 1267, "completion_tokens": 457, "completion": "[Question 2]\n\nGiven a matrix mat[][] of dimensions N x M containing only positive integers, write a program to find the maximum sum of a path from the top to bottom of the matrix, where movement is only allowed in the downward or diagonal directions. Additionally, use memoization to optimize the solution.\n\n[/Question 2]\n\n[Code 2]\n\ndef maximumPathMemoization(matrix, memo, i, j):\n    if i == len(matrix) - 1:\n        return matrix[i][j]\n    if (i, j) in memo:\n        return memo[(i, j)]\n    \n    down = maximumPathMemoization(matrix, memo, i + 1, j)\n    diagonal = maximumPathMemoization(matrix, memo, i + 1, j + 1)\n    \n    memo[(i, j)] = matrix[i][j] + max(down, diagonal)\n    \n    return memo[(i, j)]\n\ndef maximumPath(matrix):\n    memo = {}\n    return max(maximumPathMemoization(matrix, memo, 0, j) for j in range(len(matrix[0])))\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maximumPath([[ 10, 10, 2, 0, 20, 4 ],\n      [ 1, 0, 0, 30, 2, 5 ],\n      [ 0, 10, 4, 0, 2, 0 ],\n      [ 1, 0, 2, 20, 0, 4 ]]) == 74\nassert maximumPath([[ 1, 2, 3 ],\n      [ 9, 8, 7 ],\n      [ 4, 5, 6 ]]) == 18\nassert maximumPath([[ 10, 10, 2, 0, 20, 4 ],\n      [ 1, 0, 0, 30, 2, 5 ],\n      [ 0, 10, 4, 0, 2, 0 ],\n      [ 1, 0, 2, 20, 0, 4 ]]) == 74\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.732}, {"few_shot_keywords": "['product', 'update', 'integers', 'mountain', 'array', 'maximize', 'sum', 'repeatedly', 'empty', 'remove', 'possible']", "test_keywords": "['update', 'math', 'integers', 'replace', 'remove', 'product', 'sum', 'repeatedly', 'win', 'maximize', 'empty', 'tree traversal', 'array', 'distant']", "prompt_tokens": 552, "total_tokens": 933, "completion_tokens": 381, "completion": "[Question 2]\n\nYou are given an array of integers where each integer represents the amount of money that can be won at a distant location in a game. You start at the first location and need to traverse through the array to maximize the total amount of money won. At each step, you can either move to the next location or skip the next location to maximize the sum of money won. Write a function to find the maximum amount of money that can be won by traversing the array.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef maxWinningAmount(locations: List[int]) -> int:\n    if not locations:\n        return 0\n    if len(locations) == 1:\n        return locations[0]\n    dp = [0] * len(locations)\n    dp[0] = locations[0]\n    dp[1] = max(locations[0], locations[1])\n    for i in range(2, len(locations)):\n        dp[i] = max(dp[i-1], dp[i-2] + locations[i])\n    return dp[-1]\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maxWinningAmount([5, 2, 6, 10, 7, 1, 16, 9])==41\nassert maxWinningAmount([1, 2, 3, 4, 5, 6, 7, 8])==20\nassert maxWinningAmount([10, 5, 15, 20])==30\nassert maxWinningAmount([7, 2, 8, 10, 3, 1])==20\nassert maxWinningAmount([3, 7, 9, 15, 6, 1, 16, 3, 12])==46\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.76}, {"few_shot_keywords": "['string', 'same', 'market', 'algorithm', 'shortest', 'subsequence', 'combination', 'range', 'determination', 'dynamic programming', 'characters']", "test_keywords": "['combination', 'shortest', 'string', 'difference', 'optimally', 'dynamic programming', 'subsequence', 'algorithm']", "prompt_tokens": 571, "total_tokens": 877, "completion_tokens": 306, "completion": "[Question 2]\n\nGiven two strings, str1 and str2, the task is to find the length of the shortest string that has both str1 and str2 as subsequences while minimizing the difference in lengths between the original strings and the combined string.\n\n[/Question 2]\n\n[Code 2]\n\ndef shortestCombinedLength(str1: str, str2: str) -> int:\n    m, n = len(str1), len(str2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1]:\n                dp[i][j] = 1 + dp[i - 1][j - 1]\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    return m + n - dp[m][n]\n\n[/Code 2]\n\n[Asserts 2]\n\nassert shortestCombinedLength(\"first\", \"second\") == 10\nassert shortestCombinedLength(\"hello\", \"world\") == 8\nassert shortestCombinedLength(\"abcde\", \"defgh\") == 8\nassert shortestCombinedLength(\"ab\", \"baba\") == 5\nassert shortestCombinedLength(\"a\", \"b\") == 2\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.841}, {"few_shot_keywords": "['insert', 'operation', 'string', 'copy', 'length', 'horizontal', 'time', 'substring', 'operations', 'price', 'query', 'minimum', 'dynamic programming', 'coordinates', 'delete']", "test_keywords": "['substring', 'division', 'dynamic programming', 'copy', 'operations', 'string', 'insert', 'minimum', 'delete', 'time', 'length', 'adjacency matrix']", "prompt_tokens": 628, "total_tokens": 977, "completion_tokens": 349, "completion": "[Question 2]\n\nYou are given a string and a set of operations: insert, delete, and copy. Your task is to find the minimum number of operations required to transform the given string into a substring of another given string using the provided operations. \n\n[/Question 2]\n\n[Code 2]\n\ndef minOperationsToSubstring(s1: str, s2: str) -> int:\n    m, n = len(s1), len(s2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(m + 1):\n        for j in range(n + 1):\n            if i == 0:\n                dp[i][j] = j\n            elif j == 0:\n                dp[i][j] = i\n            elif s1[i - 1] == s2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1]\n            else:\n                dp[i][j] = 1 + min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1])\n    return dp[m][n]\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minOperationsToSubstring(\"abc\", \"abracadabra\") == 8\nassert minOperationsToSubstring(\"kitten\", \"sitting\") == 5\nassert minOperationsToSubstring(\"intention\", \"execution\") == 8\nassert minOperationsToSubstring(\"cart\", \"march\") == 3\nassert minOperationsToSubstring(\"horse\", \"ros\") == 3\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.723}, {"few_shot_keywords": "['if statement', 'combinations', 'modulus', 'segments', 'depth-first search', 'heapq', 'floor', 'tiling', 'tiles', 'base case', 'dp', 'dynamic programming']", "test_keywords": "['floor', 'dynamic programming', 'possible', 'operations', 'combinations', 'tiling', 'tiles', 'base case', 'modulus']", "prompt_tokens": 573, "total_tokens": 866, "completion_tokens": 293, "completion": "[Question 2]\n\nYou are given a floor of size n x m and a set of operations that can be performed on the floor. Each operation consists of selecting a tile of size 1 x m and placing it on the floor. Find the number of possible ways to perform these operations to fully tile the floor.\n\n[/Question 2]\n\n[Code 2]\n\ndef countWays(n, m):\n    count = [0 for i in range(n + 2)]\n    for i in range(1, n + 1):\n\n        # Base case1: If i is smaller\n        # than m\n        if (i > m):\n            count[i] = (count[i - 1] +\n                        count[i - m]) % 1000000007\n\n            # Base case2: If i is equal\n        # to m\n        elif (i < m):\n            count[i] = 1\n\n            # Base case3: If i is\n            # greater than m\n        else:\n            count[i] = 2\n\n    # Return the desired answer\n    return count[n]\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countWays(2, 3)==1\nassert countWays(4, 2)==3\nassert countWays(3, 3)==2\nassert countWays(5, 2)==8\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.741}, {"few_shot_keywords": "['length', 'dynamic programming', 'increase', 'subsequence', 'add', 'top', 'count', 'precede', 'string']", "test_keywords": "['subsequence', 'function', 'less than', 'string', 'length', 'increase', 'count', 'pairwise coprime', 'dynamic programming', 'backtracking']", "prompt_tokens": 682, "total_tokens": 1156, "completion_tokens": 474, "completion": "[Question 2]\n\nYou are given a string s of length n, and an array arr containing n integers. Your task is to write a function to count the number of subsequences of the string where the absolute difference between the maximum and minimum integer in the subsequence is less than a given integer k.\n\n[/Question 2]\n\n[Code 2]\n\ndef countSubsequencesWithDifferenceLessThanK(s: str, arr: List[int], k: int) -> int:\n    n = len(s)\n    mod = 10**9 + 7\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    \n    for i in range(n):\n        if arr[i] < 0:\n            arr[i] = -arr[i]\n    \n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                dp[i][j] = 1\n            elif i < j and arr[j] - arr[i] < k:\n                dp[i][j] = 2**(j - i - 1)\n    \n    for i in range(n - 1, -1, -1):\n        for j in range(i + 1, n):\n            dp[i][j] = (dp[i][j] + dp[i + 1][j] + dp[i][j - 1] - dp[i + 1][j - 1]) % mod\n            \n    count = 0\n    for i in range(n):\n        for j in range(i, n):\n            count = (count + dp[i][j]) % mod\n    \n    return count\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countSubsequencesWithDifferenceLessThanK(\"abcd\", [1, 2, 3, 4], 2) == 10\nassert countSubsequencesWithDifferenceLessThanK(\"xyz\", [3, 5, 7], 5) == 7\nassert countSubsequencesWithDifferenceLessThanK(\"hello\", [10, 20, 30, 40, 50], 12) == 43\nassert countSubsequencesWithDifferenceLessThanK(\"abc\", [5, 5, 5], 2) == 0\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.862}, {"few_shot_keywords": "['up', 'powers', 'dp', 'right', 'cross', 'cell', 'maximum', 'data structure', 'path', 'left', 'ceiling', 'delete', 'sum', 'directions', 'valid', 'multiple', 'down', '2D array', 'visited']", "test_keywords": "['visited', 'dfs', 'maximum', 'cross', 'down', 'left', '2D array', 'multiple', 'valid', 'right', 'cell', 'sum', 'binary', 'divisible', 'up', 'directions', 'path']", "prompt_tokens": 970, "total_tokens": 1571, "completion_tokens": 601, "completion": "[Question 2]\n\nGiven a binary 2D array of size N * N, find the maximum sum of a path from top-left to bottom-right cell such that the sum of elements in the path is divisible by K. You can move in the up, down, left and right directions, and each cell can be visited multiple times.\n\n[/Question 2]\n\n[Code 2]\n\ndef isValid(x, y, n, m, visited):\n    return (x >= 0 and y >= 0 and x < n and y < m and not visited[x][y])\n\ndef maxPathSumDivisibleByK(mat, n, K):\n    maxSum = 0\n\n    def dfs(x, y, currSum, visited):\n        nonlocal maxSum\n        if x == n-1 and y == n-1:\n            maxSum = max(maxSum, currSum)\n            return\n        visited[x][y] = True\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            newX, newY = x + dx, y + dy\n            if isValid(newX, newY, n, n, visited):\n                newSum = currSum + mat[newX][newY]\n                if newSum % K == 0:\n                    dfs(newX, newY, newSum, visited)\n                else:\n                    dfs(newX, newY, newSum - mat[newX][newY], visited)\n        visited[x][y] = False\n\n    visited = [[False for _ in range(n)] for _ in range(n)]\n    dfs(0, 0, mat[0][0], visited)\n    return maxSum if maxSum % K == 0 else 0\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maxPathSumDivisibleByK([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3, 3)==12\nassert maxPathSumDivisibleByK([[3, 1, 4], [1, 5, 9], [2, 6, 5]], 3, 2)==37\nassert maxPathSumDivisibleByK([[3, 1, 4], [1, 5, 9], [2, 6, 5]], 3, 5)==26\nassert maxPathSumDivisibleByK([[1, 3, 6], [7, 9, 2], [8, 4, 5]], 3, 4)==40\nassert maxPathSumDivisibleByK([[2, 4, 6], [8, 10, 12], [14, 16, 18]], 3, 7)==48\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.758}, {"few_shot_keywords": "['ways', 'dynamic programming', 'probability', 'neighbor', 'algebraic', 'flipping', 'combinations', 'math', 'coins', 'heads']", "test_keywords": "['dynamic programming', 'number', 'combinations', 'divisor', 'math', 'coins', 'heads', 'probability', 'flipping']", "prompt_tokens": 591, "total_tokens": 846, "completion_tokens": 255, "completion": "[Question 2]\n\nYou are given N coins, each showing either heads or tails. Find the number of ways to get a specific number of heads when flipping the coins.\n\n[/Question 2]\n\n[Code 2]\n\ndef waysToGetSpecificHeads(N: int, K: int) -> int:\n\tdp = [[0 for i in range(N + 1)] for j in range(K + 1)]\n\tdp[0][0] = 1\n\tfor i in range(1, K + 1):\n\t\tfor j in range(1, N + 1):\n\t\t\tdp[i][j] = dp[i][j - 1] + dp[i - 1][j - 1]\n\t\t\tif (j < i):\n\t\t\t\tdp[i][j] = 0\n\treturn dp[K][N]\n\n[/Code 2]\n\n[Asserts 2]\n\nassert waysToGetSpecificHeads(3, 2)==3\nassert waysToGetSpecificHeads(2, 1)==2\nassert waysToGetSpecificHeads(4, 2)==6\nassert waysToGetSpecificHeads(5, 3)==10\nassert waysToGetSpecificHeads(10, 5)==252", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.747}, {"few_shot_keywords": "['winner', 'elements', 'voting', 'boolean', 'eligibility', 'comparison', 'age', 'logic', 'if statement']", "test_keywords": "['age', 'boolean', 'subproblems', 'eligibility', 'if statement', 'max sum', 'logic', 'comparison', 'right', 'weight', 'voting']", "prompt_tokens": 488, "total_tokens": 709, "completion_tokens": 221, "completion": "[Question 2]\n\nYou are given a list of ages of individuals attending a competition. Each individual is assigned a weight based on their age. The task is to find the maximum sum of weights of individuals who are eligible to participate in the competition. An individual is eligible to participate if their age is greater than or equal to 18. Write a function to calculate the maximum sum of weights of eligible participants.\n\n[/Question 2]\n\n[Code 2]\n\ndef maxWeightSum(ages: List[int]) -> int:\n    maxSum = 0\n    for age in ages:\n        if age >= 18:\n            maxSum += age\n    return maxSum\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maxWeightSum([20, 25, 16, 18, 30, 22]) == 95\nassert maxWeightSum([17, 19, 21, 23, 25]) == 88\nassert maxWeightSum([16, 17, 15, 14, 20, 22]) == 42", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.868}, {"few_shot_keywords": "['algorithm', 'sign', 'substring', 'dynamic programming', 'max sum', 'position', 'jumps', 'array', 'data structure', 'subtrees', 'divisibility']", "test_keywords": "['array', 'max sum', 'bottom', 'algorithm', 'jumps', 'partition', 'position', 'divisibility', 'costs', 'dynamic programming', 'multiplying']", "prompt_tokens": 788, "total_tokens": 1205, "completion_tokens": 417, "completion": "[Question 2]\n\nYou are given an array of positive integers representing the costs of items, and a positive integer K. The goal is to partition the array into K non-empty subsets such that the maximum sum among these subsets is minimized. Each partition represents a group of items and the cost of a partition is the product of the costs of all the items in that partition.\n\nWrite a dynamic programming algorithm to find the minimum possible maximum sum that can be obtained after partitioning the array into K subsets.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\ndef minMaxSumPartition(costs: List[int], K: int) -> int:\n    n = len(costs)\n    dp = [[0] * (n + 1) for _ in range(K + 1)]\n    for i in range(1, n + 1):\n        dp[1][i] = dp[1][i - 1] * costs[i - 1]\n    for i in range(1, K + 1):\n        dp[i][1] = costs[0]\n    for i in range(2, K + 1):\n        for j in range(2, n + 1):\n            best = float('inf')\n            for p in range(1, j):\n                best = min(best, max(dp[i - 1][p], dp[1][j] - dp[1][p]))\n            dp[i][j] = best\n    return dp[K][n]\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minMaxSumPartition([10, 20, 30, 40], 2) == 60\nassert minMaxSumPartition([30, 5, 20, 9], 3) == 45\nassert minMaxSumPartition([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 5) == 18\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.803}]