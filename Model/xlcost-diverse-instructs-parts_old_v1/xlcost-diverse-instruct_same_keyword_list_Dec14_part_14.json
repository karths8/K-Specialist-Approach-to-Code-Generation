[{"few_shot_keywords": "['even', 'array', 'subsequence', 'iteration', 'minimum', 'permutations', 'consecutive', 'helper function', 'sort', 'sum']", "test_keywords": "['subsequence', 'sum', 'array', 'iteration', 'consecutive', 'paths', 'natural numbers', 'sort', 'prefix', 'minimum', 'insert']", "prompt_tokens": 501, "total_tokens": 753, "completion_tokens": 252, "completion": "[Question 2]\n\nGiven an array of natural numbers, find the minimum sum of a subsequence such that the sum is a result of adding consecutive numbers in the array, and then inserting any number of integers in between to form the path.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef minSumConsecutiveSubsequence(arr: List[int]) -> int:\n    arr.sort()\n    prefix_sum = [0]\n    for num in arr:\n        prefix_sum.append(prefix_sum[-1] + num)\n    result = float('inf')\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            sub_sum = prefix_sum[j+1] - prefix_sum[i]\n            result = min(result, sub_sum)\n    return result\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minSumConsecutiveSubsequence([1, 2, 3, 4, 5])==1\nassert minSumConsecutiveSubsequence([5, 4, 3, 2, 1])==1\nassert minSumConsecutiveSubsequence([3, 4, 2, 5, 1])==5\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.888}, {"few_shot_keywords": "['visited', 'diagonal', 'largest', 'matrix', 'submatrix', 'DFS', 'square', '8-directional', 'boolean', 'enclosed', 'direction', 'vertical', 'binary search', 'region', 'connected', 'horizontal']", "test_keywords": "['visited', 'boolean', 'diagonal', 'region', \"Newton's method\", 'validation', 'direction', 'largest', 'horizontal', 'connected', '8-directional', 'matrix', 'DFS', 'vertical']", "prompt_tokens": 920, "total_tokens": 1235, "completion_tokens": 315, "completion": "[Question 2]\n\nGiven a boolean matrix, find the size of the largest square submatrix of 1s. A square submatrix is a set of 1s that are connected horizontally, vertically, or diagonally.\n\n[/Question 2]\n\n[Code 2]\n\ndef maximalSquare(matrix: List[List[str]]) -> int:\n    if not matrix:\n        return 0\n\n    rows = len(matrix)\n    cols = len(matrix[0])\n    dp = [[0] * (cols + 1) for _ in range(rows + 1)]\n    max_side = 0\n\n    for r in range(1, rows + 1):\n        for c in range(1, cols + 1):\n            if matrix[r - 1][c - 1] == '1':\n                dp[r][c] = min(dp[r-1][c], dp[r][c-1], dp[r-1][c-1]) + 1\n                max_side = max(max_side, dp[r][c])\n\n    return max_side * max_side\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maximalSquare([\n    [\"1\",\"0\",\"1\",\"0\",\"0\"],\n    [\"1\",\"0\",\"1\",\"1\",\"1\"],\n    [\"1\",\"1\",\"1\",\"1\",\"1\"],\n    [\"1\",\"0\",\"0\",\"1\",\"0\"]\n]) == 4\n\nassert maximalSquare([\n    [\"0\",\"1\"],\n    [\"1\",\"0\"]\n]) == 1\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.771}, {"few_shot_keywords": "['dynamic programming', 'memoization', 'maximum sum', 'graph', 'positive integer', 'vertical', 'consonants', 'recursion', 'model', 'partitioning']", "test_keywords": "['partition', 'submatrices', 'different', 'mean', 'dynamic programming', 'maximum sum', 'partitioning', 'conditions', 'recursion', 'positive integer', 'memoization']", "prompt_tokens": 519, "total_tokens": 949, "completion_tokens": 430, "completion": "[Question 2]\n\nGiven a matrix of positive integers, the task is to partition the matrix into submatrices such that the mean of each submatrix is different. Implement a dynamic programming approach using recursion and memoization to find the maximum sum of the elements in the submatrices that satisfy the given conditions.\n\n[/Question 2]\n\n[Code 2]\n\ndef maxSumSubmatrices(matrix: List[List[int]]) -> int:\n    memo = {}\n    \n    def mean(matrix, r1, c1, r2, c2):\n        return sum(matrix[i][j] for i in range(r1, r2) for j in range(c1, c2)) / ((r2 - r1) * (c2 - c1))\n    \n    def maxSum(r, c):\n        if r >= len(matrix) or c >= len(matrix[0]):\n            return 0\n        if (r, c) in memo:\n            return memo[(r, c)]\n        max_val = 0\n        for r1 in range(r, len(matrix)):\n            for c1 in range(c, len(matrix[0])):\n                for r2 in range(r1+1, len(matrix)+1):\n                    for c2 in range(c1+1, len(matrix[0])+1):\n                        if mean(matrix, r1, c1, r2, c2) not in memo:\n                            memo[mean(matrix, r1, c1, r2, c2)] = maxSum(r2, c2)\n                        max_val = max(max_val, matrix[r1][c1] + maxSum(r2, c2))\n        memo[(r, c)] = max_val\n        return max_val\n    \n    return maxSum(0, 0)\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maxSumSubmatrices([[1,2,3],[4,5,6],[7,8,9]])==33\nassert maxSumSubmatrices([[10,20,30],[40,50,60],[70,80,90]])==330", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.876}, {"few_shot_keywords": "['math', 'greedy', 'traversal', 'optimization', 'iteration', 'rolling', 'tree', 'dynamic programming', 'knapsack problem', 'minimum']", "test_keywords": "['iteration', 'optimization', 'greedy', 'dynamic programming', 'math', 'knapsack problem', 'minimum', 'graph', 'divide', 'parts', 'level']", "prompt_tokens": 620, "total_tokens": 1282, "completion_tokens": 662, "completion": "[Question 2]\n\nYou are given a weighted graph with N nodes and E edges. The task is to divide the graph into k parts such that the difference between the weights of the heaviest part and the lightest part is minimized. The weights of each part are defined as the sum of the weights of the nodes in the part.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\nimport sys\n\ndef dfs(node, adj_list, visited, part, weights):\n    visited[node] = True\n    weights[-1] += part[node]\n    for neighbor in adj_list[node]:\n        if not visited[neighbor]:\n            dfs(neighbor, adj_list, visited, part, weights)\n\ndef divideGraph(nodes: int, edges: List[List[int]], parts: List[int], k: int) -> int:\n    adj_list = [[] for _ in range(nodes + 1)]\n    for edge in edges:\n        adj_list[edge[0]].append(edge[1])\n        adj_list[edge[1]].append(edge[0])\n\n    total_weight = sum(parts)\n    optimal_part_weight = total_weight // k\n\n    min_diff = sys.maxsize\n    dp = [[-1] * (optimal_part_weight + 1) for _ in range(k + 1)]\n    dp[0][0] = 0\n\n    for i in range(1, nodes + 1):\n        weights = [-1]\n        weights.extend(parts)\n        if dp[k][0] == 0:\n            break\n        visited = [False] * (nodes + 1)\n        dfs(i, adj_list, visited, parts, weights)\n        \n        for j in range(k, 0, -1):\n            for w in range(1, optimal_part_weight + 1):\n                if dp[j - 1][w - weights[i]] != -1:\n                    dp[j][w] = max(dp[j][w], dp[j - 1][w - weights[i]] + weights[i])\n\n    for i in range(optimal_part_weight, -1, -1):\n        if dp[k][i] != -1:\n            min_diff = min(min_diff, total_weight - dp[k][i] - i)\n\n    return min_diff\n\n[/Code 2]\n\n[Asserts 2]\n\nassert divideGraph(4, [[1, 2], [2, 3], [3, 4]], [1, 2, 3, 4], 3) == 2\nassert divideGraph(5, [[1, 2], [2, 3], [3, 4], [4, 5]], [2, 3, 2, 3, 4], 2) == 1\nassert divideGraph(5, [[1, 2], [2, 3], [3, 4], [4, 5]], [2, 3, 2, 3, 4], 3) == 0\nassert divideGraph(3, [[1, 2], [2, 3]], [5, 1, 4], 2) == 1\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.925}, {"few_shot_keywords": "['subsequence', 'sum', 'dynamic programming', 'exist', 'increasing', 'salary', 'array', 'maximum']", "test_keywords": "['array', 'cycles', 'shorter', 'dynamic programming', 'subsequence', 'maximum', 'substrings', 'sum', 'movement']", "prompt_tokens": 542, "total_tokens": 750, "completion_tokens": 208, "completion": "[Question 2]\n\nGiven an array of integers, find the maximum sum of a subsequence with no adjacent elements.\n\n[/Question 2]\n\n[Code 2]\n\ndef maxSumNoAdjacent(arr):\n    incl = 0\n    excl = 0\n\n    for i in arr:\n        new_excl = max(incl, excl)\n        incl = excl + i\n        excl = new_excl\n\n    return max(incl, excl)\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maxSumNoAdjacent([5, 5, 10, 100, 10, 5]) == 110\nassert maxSumNoAdjacent([1, 2, 3, 4, 5, 6]) == 12\nassert maxSumNoAdjacent([5, 5, 10, 100, 10, 5]) == 110\nassert maxSumNoAdjacent([1, 20, 3]) == 20\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.903}]