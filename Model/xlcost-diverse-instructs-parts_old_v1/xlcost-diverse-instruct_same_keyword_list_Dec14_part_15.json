[{"few_shot_keywords": "['digit', 'itertools', 'isPrime', 'sqrt', 'factors', 'prime', 'DFS', 'print', 'integer', 'numbers', 'combinations', 'primeFactors', 'subset', 'set', 'isSubset', 'conditional']", "test_keywords": "['integer', 'primeFactors', 'removal', 'combinations', 'set', 'isPrime', 'itertools', 'prime', 'multiplication', 'divisibility', 'factors', 'isSubset', 'subset', 'numbers', 'binary tree', 'print', 'building']", "prompt_tokens": 769, "total_tokens": 1261, "completion_tokens": 492, "completion": "[Question 2]\n\nGiven an integer N, print all possible subsets of the set of prime factors of N after removing one prime factor from each subset and then building a binary tree of the remaining prime factors.\n\n[/Question 2]\n\n[Code 2]\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef primeFactors(n):\n\tfactors = set()\n\twhile n % 2 == 0:\n\t\tfactors.add(2)\n\t\tn = n // 2\n\tfor i in range(3, int(n**0.5)+1,2):\n\t\twhile n % i== 0:\n\t\t\tfactors.add(i)\n\t\t\tn = n / i\n\tif n > 2:\n\t\tfactors.add(n)\n\treturn factors\n\ndef generateSubsets(nums):\n    subsets = [[]]\n    for num in nums:\n        for i in range(len(subsets)):\n            currentSubset = subsets[i]\n            subsets.append(currentSubset + [num])\n    return subsets\n\ndef printSubsetsWithBinaryTree(N):\n    factors_N = list(primeFactors(N))\n    subsets = generateSubsets(factors_N)\n    result = []\n    for subset in subsets:\n        if len(subset) > 0:\n            temp = factors_N.copy()\n            for factor in subset:\n                temp.remove(factor)\n            root = TreeNode(val=temp[0])\n            for i in range(1, len(temp)):\n                current = root\n                while current:\n                    if temp[i] < current.val:\n                        if current.left is None:\n                            current.left = TreeNode(val=temp[i])\n                            break\n                        else:\n                            current = current.left\n                    else:\n                        if current.right is None:\n                            current.right = TreeNode(val=temp[i])\n                            break\n                        else:\n                            current = current.right\n            result.append(root)\n    return result\n\n[/Code 2]\n\n[Asserts 2]\n\nassert printSubsetsWithBinaryTree(30) == [TreeNode(2, TreeNode(3)), TreeNode(3, TreeNode(2))]\nassert printSubsetsWithBinaryTree(12) == [TreeNode(3, TreeNode(2))]\nassert printSubsetsWithBinaryTree(20) == [TreeNode(2, TreeNode(5)), TreeNode(5, TreeNode(2))]\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.868}, {"few_shot_keywords": "['submatrix', 'array', 'increase', 'GCD', 'station', 'bit manipulation', 'task', 'line', 'index', 'radiation', 'amount', 'final', '2D array']", "test_keywords": "['amount', 'task', 'radiation', '2D array', 'increase', 'station', 'depth', 'final', 'line', 'program', 'array', 'index']", "prompt_tokens": 668, "total_tokens": 919, "completion_tokens": 251, "completion": "[Question 2]\n\nYou are given a 2D array representing the radiation levels at various stations. The task is to find the final radiation level after applying a series of increases to specific stations. Each increase is represented by the station index and the amount by which the radiation at that station should increase. \n\n[/Question 2]\n\n[Code 2]\n\ndef finalRadiationLevel(arr: list, increases: list) -> list:\n    n = len(arr)\n    m = len(arr[0])\n    \n    for station, amount in increases:\n        row = station // m\n        col = station % m\n        arr[row][col] += amount\n    \n    return arr\n\n[/Code 2]\n\n[Asserts 2]\n\nassert finalRadiationLevel([[2, 3, 4], [5, 6, 7]], [[2, 3], [4, 1]]) == [[2, 6, 4], [6, 6, 8]]\nassert finalRadiationLevel([[1, 1], [1, 1]], [[0, 2], [3, 4]]) == [[3, 1], [1, 5]]\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.778}, {"few_shot_keywords": "['index', 'program', 'indices', 'integers', 'number theory', 'area', 'formation', 'maximum', 'difference', 'array', 'input', 'permutation', 'output']", "test_keywords": "['minimization', 'program', 'maximum', 'difference', 'input', 'angle', 'output', 'indices', 'standard deviation', 'positioning', 'array', 'integers']", "prompt_tokens": 565, "total_tokens": 802, "completion_tokens": 237, "completion": "[Question 2]\n\nWrite a program that takes an array of integers as input and returns the angle with the maximum difference in positioning between any two numbers in the array.\n\n[/Question 2]\n\n[Code 2]\n\nimport math\n\ndef maxAngleDifference(arr):\n    n = len(arr)\n    maxDiff = 0\n    resultAngle = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            angle = math.degrees(math.atan2(arr[j]-arr[i], j-i))\n            if angle > maxDiff:\n                maxDiff = angle\n                resultAngle = angle\n    return resultAngle\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maxAngleDifference([1, 3, 5, 7, 9]) == 63.43494882292201\nassert maxAngleDifference([2, 4, 6, 8, 10]) == 63.43494882292201\nassert maxAngleDifference([5, 10, 15, 20, 25]) == 63.43494882292201\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.873}, {"few_shot_keywords": "['factorial', 'natural numbers', 'condition', 'prime', 'divisible', 'recursive function']", "test_keywords": "['egg', 'divisible', 'factorial', 'natural numbers', 'recursive function', 'coloring']", "prompt_tokens": 466, "total_tokens": 841, "completion_tokens": 375, "completion": "[Question 2]\n\nYou are given a carton of N eggs, each of which is either colored red, blue, or green. You need to write a Python program to find the total number of ways to distribute the eggs among 3 children such that each child gets a non-zero number of eggs and the number of eggs of each color is divisible by the factorial of the child's assigned number. Return the total number of ways.\n\n[/Question 2]\n\n[Code 2]\n\nfrom collections import Counter\nfrom math import factorial\n\ndef distributeEggs(egg_colors: list) -> int:\n    counts = Counter(egg_colors)\n    total_ways = 0\n    for i in range(1, 4):\n        if counts['red'] % factorial(i) == 0 and counts['blue'] % factorial(i) == 0 and counts['green'] % factorial(i) == 0:\n            total_ways += 1\n    return total_ways\n\n[/Code 2]\n\n[Asserts 2]\n\nassert distributeEggs(['red', 'red', 'blue', 'green', 'green', 'green'])==2\nassert distributeEggs(['red', 'blue', 'green'])==0\nassert distributeEggs(['red', 'red', 'red', 'blue', 'blue', 'blue', 'green', 'green', 'green'])==3\nassert distributeEggs(['red', 'red', 'red', 'red', 'blue', 'blue', 'blue', 'green', 'green', 'green'])==3\nassert distributeEggs(['red', 'red', 'red', 'red', 'blue', 'blue', 'blue', 'blue', 'green', 'green', 'green'])==2\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.761}, {"few_shot_keywords": "['sum', 'exponentiation', 'constraints', 'integer', 'trailing', 'representation', 'math', 'bracket', 'difference', 'horizontal', 'array', 'subarray', 'iteration']", "test_keywords": "['percentage difference', 'subarray', 'array', 'representation', 'sum', 'math', 'integer', 'iteration', 'exponentiation', 'groups']", "prompt_tokens": 610, "total_tokens": 888, "completion_tokens": 278, "completion": "[Question 2]\n\nGiven an array of integers, the task is to find the percentage difference between the sum of elements in odd-length subarrays and even-length subarrays.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef percentageDifference(arr: List[int]) -> float:\n    odd_sum = 0\n    even_sum = 0\n    n = len(arr)\n    for i in range(n):\n        for j in range(i, n):\n            subarray_sum = sum(arr[i:j+1])\n            if (j-i+1) % 2 == 0:\n                even_sum += subarray_sum\n            else:\n                odd_sum += subarray_sum\n    percentage_diff = ((odd_sum - even_sum) / even_sum) * 100 if even_sum != 0 else 0\n    return percentage_diff\n\n[/Code 2]\n\n[Asserts 2]\n\nassert percentageDifference([1, 2, 3, 4, 5]) == 37.5\nassert percentageDifference([10, 20, 30, 40, 50, 60]) == 200.0\nassert percentageDifference([5, 10, 15, 20, 25, 30, 35]) == -28.57142857142857\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.757}, {"few_shot_keywords": "['binary', 'iteration', 'string', 'primes', 'balance', 'start', 'bit manipulation', 'largest', 'operation', 'decrement', 'loop']", "test_keywords": "['count', 'loop', 'operation', 'bit manipulation', 'string', 'decrement', 'binary', 'ratio', 'implementation', 'iteration']", "prompt_tokens": 579, "total_tokens": 804, "completion_tokens": 225, "completion": "[Question 2]\n\nImplement a function to count the number of iterations required to decrement a binary string `A` to 0 using the following operation: if the last bit of the binary string is '1', decrement the binary string by 1; if the last bit of the binary string is '0', shift the binary string to the right by one bit. Return the count of iterations needed to reach 0.\n\n[/Question 2]\n\n[Code 2]\n\ndef countIterations(A: str) -> int:\n    count = 0\n    while A != '0':\n        if A[-1] == '1':\n            A = bin(int(A, 2) - 1)[2:]\n        else:\n            A = A[:-1]\n        count += 1\n    return count\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countIterations(\"10101\") == 5\nassert countIterations(\"11011\") == 7\nassert countIterations(\"11111\") == 15\nassert countIterations(\"100001\") == 17\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.733}]