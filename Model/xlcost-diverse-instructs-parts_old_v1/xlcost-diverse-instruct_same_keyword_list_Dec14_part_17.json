[{"few_shot_keywords": "['appearance', 'integer', 'rounded value', 'floor', 'decimal', 'absolute difference', 'smallest difference', 'concatenation', 'BST', 'sequence', 'function', 'maximize', 'largest']", "test_keywords": "['binary-search', 'integer', 'internal node', 'sum', 'absolute difference', 'floor', 'rounded value', 'transpose', 'sequence', 'concatenation', 'decimal', 'function']", "prompt_tokens": 638, "total_tokens": 1114, "completion_tokens": 476, "completion": "[Question 2]\n\nYou are given a Binary Search Tree (BST) and you need to write a function to find the sum of absolute differences between the floor and rounded value of all the internal nodes in the BST.\n\nThe floor value of a number x is the largest integer that is less than or equal to x. The rounded value of a number x is the integer value closest to x.\n\nFor example, consider the BST:\n\n```\n    10\n   /  \\\n  5   15\n / \\  / \\\n2  7 12  20\n```\n\nThe absolute differences between the floor and rounded value of the internal nodes (10, 5, 15) are:\n\n|10 - round(10)| = |10 - 10| = 0\n|5 - round(5)| = |5 - 5| = 0\n|15 - round(15)| = |15 - 15| = 0\n\nThe sum of these absolute differences is 0.\n\nWrite a function that takes the root of the BST as input and returns the sum of absolute differences between the floor and rounded value of all the internal nodes in the BST.\n\n[/Question 2]\n\n[Code 2]\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef sumAbsoluteDifferences(root: TreeNode) -> int:\n    def dfs(node, floor_round_diffs):\n        if not node:\n            return\n        if node.left and node.right:\n            diff = abs(node.val - round(node.val))\n            floor_round_diffs.append(diff)\n        dfs(node.left, floor_round_diffs)\n        dfs(node.right, floor_round_diffs)\n\n    floor_round_diffs = []\n    dfs(root, floor_round_diffs)\n    return sum(floor_round_diffs)\n\n[/Code 2]\n\n[Asserts 2]\n\n# Construct the BST\nroot = TreeNode(10)\nroot.left = TreeNode(5)\nroot.right = TreeNode(15)\nroot.left.left = TreeNode(2)\nroot.left.right = TreeNode(7)\nroot.right.left = TreeNode(12)\nroot.right.right = TreeNode(20)\n\nassert sumAbsoluteDifferences(root)==0\n# Add more test cases if needed.", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.743}, {"few_shot_keywords": "['iteration', 'Boyer Moore', 'distribution', 'left', 'amount', 'box', 'money', 'division', 'pointers', 'equal']", "test_keywords": "['iteration', 'amount', 'division', 'money', 'box', 'insert', 'distribution', 'DFS', 'equal']", "prompt_tokens": 624, "total_tokens": 984, "completion_tokens": 360, "completion": "[Question 2]\n\nYou are given a list of integers representing the distribution of money in a set of boxes. Your task is to insert a new box in such a way that after the insertion, the amount of money in each box is equal. Write a function `insertBoxToEqualize` that takes in a list of integers representing the current distribution of money and returns the index where the new box should be inserted to equalize the amount of money in each box.\n\nFor example, if the input list is [3, 6, 9], the function should return 1 as the new box should be inserted after the first box to make the distribution [3, 3, 3, 3].\n\n[/Question 2]\n\n[Code 2]\n\ndef insertBoxToEqualize(distribution: List[int]) -> int:\n    total_amount = sum(distribution)\n    num_boxes = len(distribution)\n    target_amount = total_amount // num_boxes\n    \n    for i in range(num_boxes):\n        if distribution[i] < target_amount:\n            return i\n        elif distribution[i] == target_amount:\n            return i+1\n            \n    return num_boxes\n\n[/Code 2]\n\n[Asserts 2]\n\nassert insertBoxToEqualize([3, 6, 9]) == 1\nassert insertBoxToEqualize([2, 2, 2, 2, 2]) == 1\nassert insertBoxToEqualize([1, 2, 3, 4, 5, 6, 7, 8, 9]) == 4\nassert insertBoxToEqualize([10, 20, 30, 40, 50]) == 5\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.733}, {"few_shot_keywords": "['occurrences', 'sum', 'minimum cost', 'array', 'pre-order traversal', 'indices', 'distinct elements', 'absolute differences', 'vertex cover']", "test_keywords": "['STL', 'distinct elements', 'indices', 'top to bottom', 'C++', 'dead end', 'sum', 'occurrences', 'absolute differences', 'array']", "prompt_tokens": 512, "total_tokens": 1039, "completion_tokens": 527, "completion": "[Question 2]\n\nIn C++, write a program to perform pre-order traversal of a binary tree and return the sum of absolute differences between indices of occurrences of distinct elements from top to bottom.\n\n[/Question 2]\n\n[Code 2]\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nstruct Node {\n    int data;\n    Node *left, *right;\n    Node(int val) : data(val), left(nullptr), right(nullptr) {}\n};\n\nvoid preOrderTraversal(Node* root, unordered_map<int, vector<int>>& occurrences, int depth, int& sum) {\n    if (root == nullptr) return;\n\n    occurrences[root->data].push_back(depth);\n    for (auto it = occurrences.begin(); it != occurrences.end(); ++it) {\n        if (it->second.size() > 1) {\n            for (int i = 0; i < it->second.size(); i++) {\n                sum += abs(it->second[i] - it->second[(i + 1) % it->second.size()]);\n            }\n        }\n    }\n\n    preOrderTraversal(root->left, occurrences, depth + 1, sum);\n    preOrderTraversal(root->right, occurrences, depth + 1, sum);\n}\n\nint main() {\n    Node* root = new Node(8);\n    root->left = new Node(3);\n    root->right = new Node(10);\n    root->left->left = new Node(1);\n    root->left->right = new Node(6);\n    root->right->right = new Node(14);\n    root->left->right->left = new Node(4);\n    root->left->right->right = new Node(7);\n    root->right->right->left = new Node(13);\n\n    unordered_map<int, vector<int>> occurrences;\n    int sum = 0;\n    preOrderTraversal(root, occurrences, 0, sum);\n\n    cout << \"Sum of absolute differences in pre-order traversal: \" << sum << endl;\n    \n    return 0;\n}\n```\n\n[/Code 2]\n\n[Asserts 2]\n\nThis code doesn't have direct assert statements but you can verify the correctness by running the program with different input binary trees and comparing the output sum with manually calculated values.\n\n[Note]: The C++ code example uses the Standard Template Library (STL) for unordered_map and vector, and performs a pre-order traversal of a binary tree to find the sum of absolute differences between indices of occurrences of distinct elements from top to bottom.", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.92}, {"few_shot_keywords": "['subtree', 'integers', 'steps', 'convert', 'deque', 'minimum', 'internal node', 'visited', 'dividing', 'positive', 'divide and conquer', 'factors']", "test_keywords": "['convert', 'visited', 'factors', 'deque', 'positive', 'steps', 'minimum', 'dividing', 'integers', 'start', 'concatenation']", "prompt_tokens": 726, "total_tokens": 1134, "completion_tokens": 408, "completion": "[Question 2]\n\nGiven a positive integer `n`, find the minimum number of steps needed to convert the number `1` to `n`. At each step, you can either double the number or concatenate it with itself. Return -1 if it is not possible to reach the number `n` from 1.\n\nFor example, to convert 1 to 10: 1 -> 2 -> 4 -> 8 -> 16 -> 32 -> 64 -> 128 -> 256 -> 512 -> 1024 -> 10.\n\nWrite a function to find the minimum number of steps required to convert 1 to `n`.\n\n[/Question 2]\n\n[Code 2]\n\ndef minStepsToConvertToOne(n: int) -> int:\n    if n == 1:\n        return 0\n    que = deque()\n    visited = set()\n    que.append(1)\n    visited.add(1)\n    res = 0\n\n    while que:\n        size = len(que)\n        res += 1\n        for i in range(size):\n            curr = que.popleft()\n            if curr * 2 == n or int(str(curr) + str(curr)) == n:\n                return res\n            if curr * 2 not in visited and curr * 2 <= n:\n                que.append(curr * 2)\n                visited.add(curr * 2)\n            if int(str(curr) + str(curr)) not in visited and int(str(curr) + str(curr)) <= n:\n                que.append(int(str(curr) + str(curr)))\n                visited.add(int(str(curr) + str(curr)))\n    return -1\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minStepsToConvertToOne(10)==11\nassert minStepsToConvertToOne(20)==5\nassert minStepsToConvertToOne(50)==5\nassert minStepsToConvertToOne(7)==-1\nassert minStepsToConvertToOne(1)==0\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.795}, {"few_shot_keywords": "['positive integer', 'difference', 'triplets', 'ends', 'bitwise', 'prime', 'array', 'full', 'adjacency matrix', 'sqrt', 'math', 'count', 'range', 'divide and conquer']", "test_keywords": "['prime', 'directions', 'positive integer', 'triplets', 'step', 'find', 'count', 'swaps', 'range', 'array', 'math', 'sqrt', 'shapes', 'difference']", "prompt_tokens": 611, "total_tokens": 1084, "completion_tokens": 473, "completion": "[Question 2]\n\nGiven a positive integer N and an array of positive integers, the task is to find the count of triplets in the array such that the difference between any two elements in the triplet is a prime number, and the elements are in increasing order. Additionally, when the triplet is rearranged in ascending order, it forms a shape with N sides.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\nimport math\n\ndef isPrime(num: int) -> bool:\n\tif num <= 1:\n\t\treturn False\n\tfor i in range(2, int(math.sqrt(num)) + 1):\n\t\tif num % i == 0:\n\t\t\treturn False\n\treturn True\n\ndef countTripletsWithPrimeDifference(arr: List[int], N: int) -> int:\n\tcount = 0\n\tfor i in range(len(arr)):\n\t\tfor j in range(i + 1, len(arr)):\n\t\t\tdiff = abs(arr[j] - arr[i])\n\t\t\tif isPrime(diff):\n\t\t\t\tfor k in range(j + 1, len(arr)):\n\t\t\t\t\tdiff2 = abs(arr[k] - arr[j])\n\t\t\t\t\tif isPrime(diff2) and arr[k] > arr[j]:\n\t\t\t\t\t\tif sorted([arr[i], arr[j], arr[k]]) == list(range(N, N - 3, -1)):\n\t\t\t\t\t\t\tcount += 1\n\treturn count\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countTripletsWithPrimeDifference([2, 3, 5, 7, 11, 13, 17, 19, 23, 29], 4) == 4\nassert countTripletsWithPrimeDifference([3, 5, 8, 11, 14, 17, 20, 23, 26, 29], 3) == 7\nassert countTripletsWithPrimeDifference([1, 2, 3, 5, 7, 11, 13, 17, 19, 23], 5) == 0\nassert countTripletsWithPrimeDifference([2, 4, 6, 8, 10, 12, 14, 16, 18, 20], 6) == 11\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.77}, {"few_shot_keywords": "['coprime', 'smallest', 'vertices', 'array', 'gcd', 'integer', 'prime', 'function']", "test_keywords": "['odd', 'coprime', 'gcd', 'tree', 'integer', 'array', 'smallest', 'formed', 'cells', 'vertical', 'prime']", "prompt_tokens": 593, "total_tokens": 976, "completion_tokens": 383, "completion": "[Question 2]\n\nGiven a tree formed with cells containing integers, find the smallest odd number that is not coprime with any vertical array formed by the cells.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\ndef gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef findSmallestOddNotCoprime(tree: List[List[int]]) -> int:\n    def dfs(node, parent, vertical):\n        vset.add(vertical)\n        for neighbor, v in tree[node]:\n            if neighbor == parent:\n                continue\n            dfs(neighbor, node, vertical + [v])\n\n    n = len(tree)\n    vset = set()\n    for i in range(n):\n        dfs(i, -1, [])\n\n    ans = 1\n    while ans % 2 == 0 or any(gcd(ans, v) != 1 for v in vset):\n        ans += 2\n    return ans\n\n[/Code 2]\n\n[Asserts 2]\n\ntree1 = [[(1, 3)], [(0, 5), (2, 7)], [(1, 9)]]\nassert findSmallestOddNotCoprime(tree1) == 11\n\ntree2 = [[(1, 2)], [(0, 3), (2, 4), (3, 5)], [(1, 6)], [(1, 7)], [(1, 8)], [(1, 9)]]\nassert findSmallestOddNotCoprime(tree2) == 1\n\ntree3 = [[(1, 6)], [(0, 10), (2, 15)], [(1, 35)]]\nassert findSmallestOddNotCoprime(tree3) == 7\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.923}, {"few_shot_keywords": "['sum', 'power', 'count', 'minimum cost', 'digits', 'while loop', 'math', 'preorder', 'range']", "test_keywords": "['denominations', 'digits', 'range', 'math', 'sum', 'while loop', 'power', 'adjacency matrix', 'count']", "prompt_tokens": 560, "total_tokens": 842, "completion_tokens": 282, "completion": "[Question 2]\n\nYou are given an array of denominations and a target amount. Write a function to find the minimum number of denominations needed to make up the target amount using the given denominations. \n\n[/Question 2]\n\n[Code 2]\n\ndef minDenominations(coins, amount):\n    dp = [float('inf')] * (amount + 1)\n    dp[0] = 0\n    \n    for coin in coins:\n        for i in range(coin, amount + 1):\n            dp[i] = min(dp[i], dp[i - coin] + 1)\n    \n    return dp[amount] if dp[amount] != float('inf') else -1\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minDenominations([1, 2, 5], 11) == 3\nassert minDenominations([2, 5, 10, 20, 50], 88) == 4\nassert minDenominations([1, 3, 4], 6) == 2\nassert minDenominations([1, 5, 10, 20, 50, 100], 23) == 5\nassert minDenominations([1, 3, 4], 7) == 2\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.82}, {"few_shot_keywords": "['sum', 'criteria', 'triangle', 'binary tree', 'end', 'integer', 'path', 'dfs', 'binary', 'dictionary', 'root', 'element', 'vertex']", "test_keywords": "['root', 'binary tree', 'sorted', 'interchange', 'element', 'vertex', 'sum', 'subset', 'dfs', 'integer', 'consecutive', 'binary', 'path']", "prompt_tokens": 631, "total_tokens": 962, "completion_tokens": 331, "completion": "[Question 2]\n\nGiven the root of a binary tree and an integer `k`, write a function to determine if there exists a path from the root to a leaf whose sum of elements is equal to `k`.\n\n[/Question 2]\n\n[Code 2]\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef hasPathSum(root: TreeNode, k: int) -> bool:\n    if not root:\n        return False\n    if not root.left and not root.right and root.val == k:\n        return True\n    return hasPathSum(root.left, k - root.val) or hasPathSum(root.right, k - root.val)\n\n# Example Usage\n# Construct a sample binary tree\nroot = TreeNode(5)\nroot.left = TreeNode(4)\nroot.right = TreeNode(8)\nroot.left.left = TreeNode(11)\nroot.left.left.left = TreeNode(7)\nroot.left.left.right = TreeNode(2)\nroot.right.left = TreeNode(13)\nroot.right.right = TreeNode(4)\nroot.right.right.right = TreeNode(1)\n\nassert hasPathSum(root, 22) == True\nassert hasPathSum(root, 16) == True\nassert hasPathSum(root, 21) == False\n\n[/Code 2]\n\n[Asserts 2]\n\nassert hasPathSum(root, 22) == True\nassert hasPathSum(root, 16) == True\nassert hasPathSum(root, 21) == False\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.816}, {"few_shot_keywords": "['closed', 'counter', 'equal', 'frequency', 'removals', 'start', 'integers', 'array', 'collections']", "test_keywords": "['removals', 'collections', 'visited', 'combination', 'multiplication', 'array', 'counter', 'Binary Search Tree', 'integers', 'equal', 'frequency']", "prompt_tokens": 536, "total_tokens": 839, "completion_tokens": 303, "completion": "[Question 2]\n\nYou are given an array of integers. Write a function to find all unique combinations of integers that multiply to an equal value. Avoid duplicate combinations and only use each integer once.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\nimport collections\n\ndef findEqualProductCombinations(nums: List[int], target: int) -> List[List[int]]:\n    result = []\n    def backtrack(start, path, product):\n        if product == target and len(path) == len(set(path)):\n            result.append(path[:])\n            return\n        for i in range(start, len(nums)):\n            path.append(nums[i])\n            backtrack(i + 1, path, product * nums[i])\n            path.pop()\n    backtrack(0, [], 1)\n    return result\n\n[/Code 2]\n\n[Asserts 2]\n\nassert findEqualProductCombinations([2, 3, 4, 6, 8], 24) == [[2, 3, 4]]\nassert findEqualProductCombinations([1, 2, 3, 4, 5], 20) == [[1, 4, 5]]\nassert findEqualProductCombinations([2, 3, 5, 7, 11], 30) == [[2, 3, 5]]\nassert findEqualProductCombinations([2, 3, 4, 5, 6, 7], 100) == []", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.864}, {"few_shot_keywords": "['symmetric', 'vertex', 'index', 'in-degree', 'logic', 'set', 'graph', 'directed', 'universal sink', 'out-degree', 'coordinates', 'adjacency matrix', 'line']", "test_keywords": "['directed', 'out-degree', 'index', 'in-degree', 'graph', 'subtree', 'inserting', 'universal sink', 'indices', 'vertex', 'adjacency matrix']", "prompt_tokens": 685, "total_tokens": 1140, "completion_tokens": 455, "completion": "[Question 2]\n\nYou are given a directed graph represented by an adjacency matrix. Write a function to insert a new vertex into the graph and update the adjacency matrix accordingly. The new vertex will have no outgoing edges to any other vertex and all existing vertices will have no incoming edges from the new vertex.\n\n[/Question 2]\n\n[Code 2]\n\ndef insertVertex(graph: List[List[int]]) -> List[List[int]]:\n    n = len(graph)\n    for i in range(n):\n        graph[i].append(0)\n    graph.append([0] * (n+1))\n    return graph\n\n[/Code 2]\n\n[Asserts 2]\n\nassert insertVertex([[0, 1, 0], [0, 0, 0], [0, 1, 0]]) == [[0, 1, 0, 0], [0, 0, 0, 0], [0, 1, 0, 0], [0, 0, 0, 0]]\nassert insertVertex([[0, 1, 0], [0, 0, 1], [0, 0, 0]]) == [[0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 0], [0, 0, 0, 0]]\nassert insertVertex([[0, 1, 0], [0, 0, 1], [0, 1, 0]]) == [[0, 1, 0, 0], [0, 0, 1, 0], [0, 1, 0, 0], [0, 0, 0, 0]]\nassert insertVertex([[0, 0, 0], [0, 0, 0], [1, 1, 0]]) == [[0, 0, 0, 0], [0, 0, 0, 0], [1, 1, 0, 0], [0, 0, 0, 0]]\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.823}, {"few_shot_keywords": "['subset', 'count', 'colors', 'vertices', 'defaultdict', 'edges', 'binary tree node', 'largest', 'connected', 'subtraction', 'graph']", "test_keywords": "['largest', 'colors', 'edges', 'graph', 'division', 'defaultdict', 'count', 'connected', 'modify', 'subset', 'vertices']", "prompt_tokens": 695, "total_tokens": 1127, "completion_tokens": 432, "completion": "[Question 2]\n\nGiven a graph with N vertices and edges colored in different colors, modify the graph such that each vertex is connected to the largest subset of vertices with edges of different colors, and then count the number of divisions created in the graph.\n\n[/Question 2]\n\n[Code 2]\n\nfrom collections import defaultdict\n\ndef modifyAndCountDivisions(graph: dict) -> int:\n    if not graph:\n        return 0\n    \n    divisions = 0\n    for vertex, edges in graph.items():\n        colors = defaultdict(list)\n        for v, color in edges:\n            colors[color].append(v)\n        \n        largest_subset = max(colors.values(), key=len)\n        for v in largest_subset:\n            if vertex not in graph[v]:\n                graph[v].append((vertex, 'new_color'))\n                divisions += 1\n    \n    return divisions\n\n[/Code 2]\n\n[Asserts 2]\n\ntest_graph = {1: [(2, 'red'), (3, 'blue')], 2: [(1, 'red'), (3, 'green')], 3: [(1, 'blue'), (2, 'green')]}\nmodifyAndCountDivisions(test_graph)\nassert test_graph == {1: [(2, 'red'), (3, 'blue'), (2, 'new_color'), (3, 'new_color')], 2: [(1, 'red'), (3, 'green'), (1, 'new_color')], 3: [(1, 'blue'), (2, 'green'), (1, 'new_color'), (2, 'new_color')]}\nassert modifyAndCountDivisions(test_graph) == 4\nassert test_graph == {1: [(2, 'red'), (3, 'blue'), (2, 'new_color'), (3, 'new_color')], 2: [(1, 'red'), (3, 'green'), (1, 'new_color')], 3: [(1, 'blue'), (2, 'green'), (1, 'new_color'), (2, 'new_color')]}\n  ", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.817}, {"few_shot_keywords": "['closest sum', 'edges', 'tree construction', 'graph', 'nodes', 'undirected', 'count']", "test_keywords": "['tree', 'interchange', 'count', '180 degrees', 'undirected', 'graph', 'nodes', 'edges']", "prompt_tokens": 438, "total_tokens": 718, "completion_tokens": 280, "completion": "[Question 2]\n\nGiven an undirected graph with N nodes and M edges, write a function to count the total number of 180-degree edge interchanges that can be made in the graph.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List, Tuple\n\ndef countInterchanges(nodes: int, edges: List[Tuple[int, int]]) -> int:\n\tinterchanges = 0\n\tfor i in range(len(edges)):\n\t\tfor j in range(i+1, len(edges)):\n\t\t\tif (edges[i][0] == edges[j][1] and edges[i][1] == edges[j][0]) or (edges[i][0] == edges[j][0] and edges[i][1] == edges[j][1]):\n\t\t\t\tinterchanges += 1\n\treturn interchanges\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countInterchanges(4, [(1, 2), (2, 3), (3, 1)]) == 0\nassert countInterchanges(5, [(1, 2), (2, 3), (3, 4), (4, 5)]) == 0\nassert countInterchanges(4, [(1, 2), (2, 3), (3, 2), (3, 4)]) == 2\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.899}, {"few_shot_keywords": "['anagrams', 'subgraph', 'undirected', 'change key', 'horizontal', 'result', 'adjacent', 'clique', 'bipartite', 'graph']", "test_keywords": "['clique', 'undirected', 'graph', 'decrease key', 'zeros', 'adjacent', 'subgraph', 'bipartite']", "prompt_tokens": 964, "total_tokens": 1331, "completion_tokens": 367, "completion": "[Question 2]\n\nGiven an undirected graph G, the task is to find all the cliques in the graph. A clique is a subgraph of the given graph such that every two nodes in the subgraph are adjacent to each other. Write a function to find all the cliques in the given undirected graph.\n\n[/Question 2]\n\n[Code 2]\n\ndef findCliques(graph):\n    cliques = []\n    def __findCliques(subgraph, candidates):\n        if not any(candidates):\n            cliques.append(subgraph)\n            return\n        for candidate in candidates:\n            new_candidates = [node for node in candidates if graph[candidate][node] == 1]\n            new_subgraph = subgraph + [candidate]\n            __findCliques(new_subgraph, new_candidates)\n            candidates.remove(candidate)\n    __findCliques([], list(range(len(graph))))\n    return cliques\n\n[/Code 2]\n\n[Asserts 2]\n\ngraph = [\n    [0, 1, 1, 1],\n    [1, 0, 1, 1],\n    [1, 1, 0, 1],\n    [1, 1, 1, 0]\n]\nassert findCliques(graph) == [[0, 1, 2, 3]]\n\ngraph2 = [\n    [0, 1, 1, 0],\n    [1, 0, 1, 1],\n    [1, 1, 0, 1],\n    [0, 1, 1, 0]\n]\nassert findCliques(graph2) == [[0, 1], [0, 2], [1, 2], [1, 3], [2, 3]]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.749}, {"few_shot_keywords": "['cycle', 'degrees', 'graph', 'horizontal', 'edges', 'full', 'index', 'tree', 'symmetric', 'connected', 'clockwise', 'validation', 'vertices', 'sum']", "test_keywords": "['validation', 'degrees', 'increment', 'edges', 'program', 'criteria', 'connected', 'vertices', 'graph', 'singly', 'tree', 'dfs', 'cycle', 'sum']", "prompt_tokens": 595, "total_tokens": 958, "completion_tokens": 363, "completion": "[Question 2]\n\nYou are given a graph represented as an adjacency list and the degrees of its vertices. Write a program to validate if the given degrees match the graph criteria. The validation includes checking if the graph is connected and does not contain any cycle. Use Depth First Search (DFS) algorithm to perform the validation.\n\n[/Question 2]\n\n[Code 2]\n\ndef is_valid(degrees, graph):\n    n = len(graph)\n    if sum(degrees) % 2 != 0:\n        return False  # Sum of degrees must be even for a graph\n    visited = [False] * n\n    visited[0] = True\n    stack = [0]\n    while stack:\n        node = stack.pop()\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                visited[neighbor] = True\n                stack.append(neighbor)\n    if all(visited):\n        return True  # Graph is connected\n    return False  # Graph is not connected\n\n[/Code 2]\n\n[Asserts 2]\n\nassert is_valid([2, 2, 2, 3], {0: [1, 2], 1: [0, 2], 2: [0, 1, 3], 3: [2]}) == True\nassert is_valid([2, 2, 2, 3], {0: [1, 2], 1: [0, 2], 2: [0, 1]}) == False\nassert is_valid([1, 1, 1, 1], {0: [1], 1: [0, 2], 2: [1, 3], 3: [2]}) == True", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.87}, {"few_shot_keywords": "['edge', 'adjacency list', 'vertex cover', 'binary search', 'diagonal', 'matching', 'undirected', 'minimum cost', 'size', 'graph', 'connected', 'subset']", "test_keywords": "['element', 'vertex cover', 'adjacency list', 'connected', 'graph', 'binary search', 'size', 'edge', 'dictionary', 'subset', 'undirected', 'matching']", "prompt_tokens": 937, "total_tokens": 1526, "completion_tokens": 589, "completion": "[Question 2]\n\nGiven an undirected graph represented as an adjacency list and a dictionary of elements, the task is to find a subset of elements that forms a minimum vertex cover in the graph using binary search.\n\nWrite a function to determine the size of the minimum vertex cover using the binary search method and the given dictionary of elements.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List, Dict\n\ndef minimumVertexCover(graph: dict, elements: Dict) -> int:\n    def isCoverOfSizeK(k: int) -> bool:\n        vis = [False] * n\n        matching = [-1] * n\n        v = 0\n        for v in range(n):\n            if not vis[v]:\n                for u in graph[v]:\n                    if matching[u] == -1:  # No edge between u and v\n                        matching[v] = u\n                        matching[u] = v\n                        vis[v] = True\n                        vis[u] = True\n                        break\n        def dfs(v: int) -> bool:\n            vis[v] = True\n            for u in graph[v]:\n                if matching[u] == -1 or (not vis[matching[u]] and dfs(matching[u])):\n                    matching[v] = u\n                    matching[u] = v\n                    return True\n            return False\n\n        for v in range(n):\n            if not matching[v] == -1:\n                continue\n            vis = [False] * n\n            if dfs(v):\n                matching[v] = -1\n                k -= 1\n                if k == 0:\n                    return True\n        return False\n\n    n = len(graph)\n    lo, hi = 0, n\n    while lo < hi:\n        mid = lo + (hi - lo) // 2\n        if isCoverOfSizeK(mid):\n            hi = mid\n        else:\n            lo = mid + 1\n    return lo\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minimumVertexCover({0: [1, 2], 1: [0, 2], 2: [0, 1, 3], 3: [2, 4], 4: [3]}, {'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5}) == 2\nassert minimumVertexCover({0: [1, 2, 3], 1: [0, 2], 2: [0, 1, 3], 3: [0, 2, 4], 4: [3]}, {'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5}) == 3\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.948}, {"few_shot_keywords": "['singly', 'length', 'in-order traversal', 'iterative', 'recursive', 'linked list', 'findDistance', 'concatenation']", "test_keywords": "['diagonal', 'data structure', 'length', 'singly', 'iterative', 'max', 'left', 'recursive', 'graph', 'linked list']", "prompt_tokens": 587, "total_tokens": 902, "completion_tokens": 315, "completion": "[Question 2]\n\nYou are given a data structure representing a graph. Write a function to find the length of the longest diagonal in the graph, starting from a given node, using both iterative and recursive approaches.\n\n[/Question 2]\n\n[Code 2]\n\nclass Graph:\n    def __init__(self, vertices):\n        self.vertices = vertices\n        self.adjacency_list = {v: [] for v in vertices}\n\n    def add_edge(self, u, v):\n        self.adjacency_list[u].append(v)\n        self.adjacency_list[v].append(u)\n\n# Iterative Approach\ndef longestDiagonalIterative(graph: Graph, start_node) -> int:\n    # Implement iterative approach to find longest diagonal\n    pass  # Replace with your code\n\n# Recursive Approach\ndef longestDiagonalRecursive(graph: Graph, start_node) -> int:\n    # Implement recursive approach to find longest diagonal\n    pass  # Replace with your code\n\n[/Code 2]\n\n[Asserts 2]\n\n# Creating a graph with vertices 1, 2, 3, 4\ngraph = Graph([1, 2, 3, 4])\ngraph.add_edge(1, 2)\ngraph.add_edge(2, 3)\ngraph.add_edge(3, 4)\n# Testing longestDiagonalIterative\nassert longestDiagonalIterative(graph, 1) == 2\n# Testing longestDiagonalRecursive\nassert longestDiagonalRecursive(graph, 1) == 2\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.795}, {"few_shot_keywords": "['sqrt', 'in-order traversal', 'addition', 'count', 'data structure', 'linked list', 'lexicographically', 'DFS', 'search', 'node']", "test_keywords": "['count', 'counting-out game', 'node', 'sequence', 'swaps', 'search', 'linked list', 'data structure']", "prompt_tokens": 583, "total_tokens": 943, "completion_tokens": 360, "completion": "[Question 2]\n\nYou are given a circular singly linked list and an integer k. The task is to write a program to perform the counting-out game using the k value. The counting-out game is a children's game in which items in a sequence are counted out and removed in stages until only one remains. Your program should return the sequence of nodes that are removed in each step until only one node remains.\n\n[/Question 2]\n\n[Code 2]\n\n# Node class to represent a node in the linked list\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\n\ndef countingOutGame(head, k):\n    result = []\n    current = head\n    while current.next != current:\n        for _ in range(k - 1):\n            current = current.next\n        result.append(current.data)\n        current.next = current.next.next\n        current = current.next\n    result.append(current.data)\n    return result\n\n[/Code 2]\n\n[Asserts 2]\n\n# Create a circular linked list: 1 -> 2 -> 3 -> 4 -> 5\nn1 = Node(1)\nn2 = Node(2)\nn3 = Node(3)\nn4 = Node(4)\nn5 = Node(5)\nn1.next = n2\nn2.next = n3\nn3.next = n4\nn4.next = n5\nn5.next = n1\nassert countingOutGame(n1, 3) == [3, 1, 5, 2, 4]\nassert countingOutGame(n1, 2) == [2, 4, 1, 5, 3]\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.87}, {"few_shot_keywords": "['character', 'backward', 'sequence', 'linked list', 'forward', 'singly linked list', 'DFS', 'array', 'node', 'maximum', 'palindrome']", "test_keywords": "['forward', 'palindrome', 'sequence', 'vertical', 'node', 'linked list', 'singly linked list', 'child', 'linked structure', 'character', 'backward']", "prompt_tokens": 575, "total_tokens": 954, "completion_tokens": 379, "completion": "[Question 2]\n\nYou are given a binary tree data structure as below:\n\n```python\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n```\n\nWrite a function to check if the binary tree is a palindrome sequence when read vertically from top to bottom. Return True if the tree is a palindrome sequence, otherwise return False.\n\n[/Question 2]\n\n[Code 2]\n\ndef isVerticalPalindrome(root: TreeNode) -> bool:\n    def verticalTraversal(node, level, result):\n        if node:\n            if level in result:\n                result[level].append(node.val)\n            else:\n                result[level] = [node.val]\n            verticalTraversal(node.left, level - 1, result)\n            verticalTraversal(node.right, level + 1, result)\n\n    result = {}\n    verticalTraversal(root, 0, result)\n    for level, values in result.items():\n        if values != values[::-1]:\n            return False\n    return True\n\n[/Code 2]\n\n[Asserts 2]\n\n# Example 1\nroot1 = TreeNode(1, TreeNode(2, TreeNode(3), TreeNode(4)), TreeNode(2, TreeNode(4), TreeNode(3)))\nassert isVerticalPalindrome(root1) == True\n# Example 2\nroot2 = TreeNode(1, TreeNode(2, TreeNode(3), TreeNode(4)), TreeNode(2, TreeNode(4), TreeNode(3, TreeNode(5))))\nassert isVerticalPalindrome(root2) == False\n# Example 3\nroot3 = TreeNode(1, TreeNode(2, TreeNode(3), TreeNode(4)), TreeNode(2, TreeNode(4), TreeNode(3)))\nassert isVerticalPalindrome(root3) == False\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.813}, {"few_shot_keywords": "['linked list', 'pointers', 'nodes', 'data structure', 'loop', 'euclidean distance', 'swapping', 'closest', 'Josephus Circle']", "test_keywords": "['data structure', 'clockwise', 'linked list', 'pointers', 'nodes', 'inside', 'swapping']", "prompt_tokens": 750, "total_tokens": 1097, "completion_tokens": 347, "completion": "[Question 2]\n\nGiven a linked list, write a function to swap the nodes pairwise in a clockwise manner. For example, if the linked list is 1->2->3->4->5, then after swapping, it should become 2->1->4->3->5.\n\n[/Question 2]\n\n[Code 2]\n\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef swapPairs(head: ListNode) -> ListNode:\n    if head is None or head.next is None:\n        return head\n  \n    prev = head\n    current = head.next\n    head = current\n  \n    while True:\n        temp = current.next\n        current.next = prev\n  \n        if temp is None or temp.next is None:\n            prev.next = temp\n            break\n  \n        prev.next = temp.next\n        prev = temp\n        current = prev.next\n  \n    return head\n\n[/Code 2]\n\n[Asserts 2]\n\n# Sample Linked List: 1 -> 2 -> 3 -> 4 -> 5\nnode5 = ListNode(5)\nnode4 = ListNode(4, node5)\nnode3 = ListNode(3, node4)\nnode2 = ListNode(2, node3)\nnode1 = ListNode(1, node2)\nassert swapPairs(node1).val == 2\nassert swapPairs(node1).next.val == 1\nassert swapPairs(node1).next.next.val == 4\nassert swapPairs(node1).next.next.next.val == 3\nassert swapPairs(node1).next.next.next.next.val == 5\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.816}, {"few_shot_keywords": "['tree node', 'reverse', 'array', 'binary tree', 'occurrence', 'inserting', 'postorder traversal', 'direction', 'method', 'stack', 'recursion', 'dynamic programming']", "test_keywords": "['method', 'preorder', 'postorder traversal', 'recursion', 'tree node', 'change key', 'array', 'stack', 'set', 'binary tree', 'inserting', 'reverse']", "prompt_tokens": 651, "total_tokens": 1041, "completion_tokens": 390, "completion": "[Question 2]\n\nWrite a method to change the key of a specific node in a binary tree and perform a preorder traversal to verify the change.\n\n[/Question 2]\n\n[Code 2]\n\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\ndef changeKey(root, target, new_key):\n    if root is None:\n        return\n    \n    stack = [root]\n    \n    while stack:\n        current = stack.pop()\n        if current.val == target:\n            current.val = new_key\n        \n        if current.right:\n            stack.append(current.right)\n        \n        if current.left:\n            stack.append(current.left)\n\ndef preorderTraversal(root):\n    result = []\n    if root:\n        result.append(root.val)\n        result += preorderTraversal(root.left)\n        result += preorderTraversal(root.right)\n    return result\n\n[/Code 2]\n\n[Asserts 2]\n\n# Assuming a binary tree with values [1, 2, 3, 4, 5, 6, 7]\nroot = TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(5)), TreeNode(3, TreeNode(6), TreeNode(7)))\nchangeKey(root, 4, 8)\nassert preorderTraversal(root) == [1, 2, 8, 5, 3, 6, 7]\n\n# Assuming a binary tree with values [10, 20, 30, 40, 50]\nroot = TreeNode(10, TreeNode(20, TreeNode(40), TreeNode(50)), TreeNode(30))\nchangeKey(root, 30, 35)\nassert preorderTraversal(root) == [10, 20, 40, 50, 35]\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.751}, {"few_shot_keywords": "['list', 'Josephus Circle', 'STL', 'defaultdict', 'intersection', 'dfs', 'C++', 'counting-out game']", "test_keywords": "['C++', 'closest pair', 'doubly linked list', 'text', 'Josephus Circle', 'list', '2D list', 'STL', 'counting-out game', 'check']", "prompt_tokens": 603, "total_tokens": 1189, "completion_tokens": 586, "completion": "[Question 2]\n\nIn C++, implement a function to find the closest pair of points in a 2D list using a doubly linked list. Assume the points are represented as (x, y) coordinates in the 2D list and use the STL for efficient operations. This problem can be solved using the closest pair algorithm.\n\n[/Question 2]\n\n[Code 2]\n\n```cpp\n#include <iostream>\n#include <list>\n#include <cmath>\n#include <limits>\nusing namespace std;\n\nstruct Point {\n    int x, y;\n};\n\ndouble dist(Point p1, Point p2) {\n    return sqrt((p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y));\n}\n\npair<Point, Point> closestPair(list<Point>& points) {\n    list<Point>::iterator it1, it2;\n    pair<Point, Point> closest;\n    double minDist = numeric_limits<double>::max();\n    for (it1 = points.begin(); it1 != points.end(); ++it1) {\n        for (it2 = next(it1); it2 != points.end(); ++it2) {\n            double distance = dist(*it1, *it2);\n            if (distance < minDist) {\n                minDist = distance;\n                closest = make_pair(*it1, *it2);\n            }\n        }\n    }\n    return closest;\n}\n\nint main() {\n    list<Point> points = { {1, 2}, {3, 4}, {5, 6}, {7, 8} };\n    pair<Point, Point> closest = closestPair(points);\n    cout << \"Closest pair: (\" << closest.first.x << \", \" << closest.first.y << \") and (\" << closest.second.x << \", \" << closest.second.y << \")\" << endl;\n    return 0;\n}\n```\n\n[/Code 2]\n\n[Asserts 2]\n\n```cpp\nlist<Point> points1 = { {1, 2}, {3, 4}, {5, 6}, {7, 8} };\nassert(closestPair(points1) == make_pair(Point{1, 2}, Point{3, 4}));\n\nlist<Point> points2 = { {0, 0}, {10, 10}, {20, 20}, {30, 30} };\nassert(closestPair(points2) == make_pair(Point{0, 0}, Point{10, 10}));\n\nlist<Point> points3 = { {5, 5}, {10, 10}, {15, 15}, {20, 20} };\nassert(closestPair(points3) == make_pair(Point{5, 5}, Point{10, 10}));\n```\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.836}, {"few_shot_keywords": "['inserting', 'dynamic-programming', 'position', 'node', 'end', 'manipulation', 'threaded binary tree', 'singly linked list', 'array', 'swap', 'beginning']", "test_keywords": "['beginning', 'end', 'swap', 'position', 'manipulation', 'path', 'initial points', 'singly linked list', 'counter', 'binary tree', 'node', 'consecutive']", "prompt_tokens": 879, "total_tokens": 1275, "completion_tokens": 396, "completion": "[Question 2]\n\nGiven a binary tree, swap the nodes at consecutive levels starting from the beginning and ending at the specified position.\n\n[/Question 2]\n\n[Code 2]\n\nclass TreeNode:\n    def __init__(self, value=0, left=None, right=None):\n        self.value = value\n        self.left = left\n        self.right = right\n\ndef swapConsecutiveLevels(root: TreeNode, k: int) -> TreeNode:\n    def swapUtil(left, right, level, k):\n        if not left or not right or level < k:\n            return\n        if level % k == 0:\n            left.value, right.value = right.value, left.value\n        swapUtil(left.left, right.right, level+1, k)\n        swapUtil(left.right, right.left, level+1, k)\n\n    swapUtil(root.left, root.right, 1, k)\n    return root\n\n[/Code 2]\n\n[Asserts 2]\n\n# Creating binary tree\n#        1\n#       / \\\n#      3   5\n#     / \\ / \\\n#    7  9 11 13\nroot = TreeNode(1,\n                TreeNode(3, TreeNode(7), TreeNode(9)),\n                TreeNode(5, TreeNode(11), TreeNode(13)))\n# After swapping nodes at consecutive levels starting from level 2 and ending at level 3\nassert swapConsecutiveLevels(root, 2).left.value == 5\nassert swapConsecutiveLevels(root, 2).right.value == 3\nassert swapConsecutiveLevels(root, 2).left.left.value == 13\nassert swapConsecutiveLevels(root, 2).left.right.value == 11\nassert swapConsecutiveLevels(root, 2).right.left.value == 9\nassert swapConsecutiveLevels(root, 2).right.right.value == 7\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.757}, {"few_shot_keywords": "['left', 'start', 'nodes', 'lowercase', 'top to bottom', 'queue', 'diagonal', 'constant', 'binary tree', 'traversal', 'right']", "test_keywords": "['binary tree', 'ancestor', 'diagonal', 'right', 'traversal', 'binary-search-tree', 'nodes', 'sqrt', 'queue', 'left', 'top to bottom']", "prompt_tokens": 720, "total_tokens": 1118, "completion_tokens": 398, "completion": "[Question 2]\n\nWrite a function to find the lowest common ancestor (LCA) of two nodes in a binary search tree. The LCA of two nodes `p` and `q` in a binary search tree (BST) is the node that is the lowest ancestor of both `p` and `q`. \n\nImplement the function `lowestCommonAncestor` to find the lowest common ancestor of two given nodes in a binary search tree.\n\n[/Question 2]\n\n[Code 2]\n\nclass TreeNode:\n    def __init__(self, value=0, left=None, right=None):\n        self.value = value\n        self.left = left\n        self.right = right\n\ndef lowestCommonAncestor(root: TreeNode, p: TreeNode, q: TreeNode) -> TreeNode:\n    if not root:\n        return None\n    if p.value < root.value and q.value < root.value:\n        return lowestCommonAncestor(root.left, p, q)\n    elif p.value > root.value and q.value > root.value:\n        return lowestCommonAncestor(root.right, p, q)\n    else:\n        return root\n\n[/Code 2]\n\n[Asserts 2]\n\n# Example Binary Search Tree\n#     6\n#    / \\\n#   2   8\n#  / \\ / \\\n# 0  4 7 9\n#    / \\\n#   3   5\nnode9 = TreeNode(9)\nnode7 = TreeNode(7)\nnode8 = TreeNode(8, node7, node9)\nnode5 = TreeNode(5)\nnode3 = TreeNode(3)\nnode4 = TreeNode(4, node3, node5)\nnode2 = TreeNode(2, TreeNode(0), node4)\nnode6 = TreeNode(6, node2, node8)\nassert lowestCommonAncestor(node6, node2, node8).value == 6\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.71}, {"few_shot_keywords": "['optimization', 'counting', 'search', 'strip', 'binary', 'sum', 'doubly linked list', 'counting-out game', 'triplets']", "test_keywords": "['postorder traversal', 'search', 'decimal', 'sum', 'n digit numbers', 'triplets', 'doubly linked list', 'leaf nodes', 'counting']", "prompt_tokens": 749, "total_tokens": 1118, "completion_tokens": 369, "completion": "[Question 2]\n\nGiven a binary tree and a target sum, write a function to find the count of triplets of n-digit numbers in the decimal form that are derived from the leaf nodes of the tree when the numbers are formed by concatenating the node values in a postorder traversal. \n\n[/Question 2]\n\n[Code 2]\n\n```python\nclass Node:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef postorderTraversal(root, traversal):\n    if root:\n        postorderTraversal(root.left, traversal)\n        postorderTraversal(root.right, traversal)\n        traversal.append(root.value)\n\ndef countTripletsFromLeafNodes(root, target_sum, n):\n    traversal = []\n    postorderTraversal(root, traversal)\n    leaf_values = [int(''.join(map(str, traversal[i:i+n]))) for i in range(0, len(traversal)-n+1)]\n    count = 0\n    for i in range(len(leaf_values)):\n        for j in range(i+1, len(leaf_values)):\n            for k in range(j+1, len(leaf_values)):\n                if leaf_values[i] + leaf_values[j] + leaf_values[k] == target_sum:\n                    count += 1\n    return count\n```\n\n[/Code 2]\n\n[Asserts 2]\n\n```python\nroot = Node(1)\nroot.left = Node(2)\nroot.right = Node(3)\nroot.left.left = Node(4)\nroot.left.right = Node(5)\nassert countTripletsFromLeafNodes(root, 12, 3) == 1\nassert countTripletsFromLeafNodes(root, 15, 3) == 0\n```\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.858}, {"few_shot_keywords": "['duplicates', 'extra space', 'C', 'level', 'target', 'doubly linked list', 'remove']", "test_keywords": "['duplicates', 'doubly linked list', 'distance', 'factorial', 'extra space', 'remove']", "prompt_tokens": 536, "total_tokens": 859, "completion_tokens": 323, "completion": "[Question 2]\n\nYou are given a doubly linked list and you need to remove the nodes that are at a distance which is a factorial of a given number without using any extra space.\n\n[/Question 2]\n\n[Code 2]\n\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n        self.prev = None\n\ndef factorial(n):\n    if n == 0:\n        return 1\n    else:\n        return n * factorial(n-1)\n\ndef removeNodesAtFactorialDistance(head, num):\n    current = head\n    distance = 1\n    while current:\n        if distance == factorial(num):\n            temp = current\n            current.prev.next = current.next\n            current.next.prev = current.prev\n            current = current.next\n            distance = 1\n        else:\n            current = current.next\n            distance += 1\n    return head\n\n[/Code 2]\n\n[Asserts 2]\n\n# Create the doubly linked list\nnode1 = Node(1)\nnode2 = Node(2)\nnode3 = Node(3)\nnode4 = Node(4)\nnode5 = Node(5)\nnode1.next = node2\nnode2.prev = node1\nnode2.next = node3\nnode3.prev = node2\nnode3.next = node4\nnode4.prev = node3\nnode4.next = node5\nnode5.prev = node4\nassert removeNodesAtFactorialDistance(node1, 2) == node1\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.703}, {"few_shot_keywords": "['modify', 'level', 'maximize', 'inorder predecessor', 'binary tree', 'preorder traversal', 'pointer', 'number']", "test_keywords": "['inorder predecessor', 'insert', 'STL', 'binary tree', 'matching', 'preorder traversal', 'modify', 'pairs', 'pre-order traversal', 'pointer', 'level']", "prompt_tokens": 731, "total_tokens": 1102, "completion_tokens": 371, "completion": "[Question 2]\n\nGiven a binary tree and a list of pairs, write a function to insert each pair into the tree. For each pair, find the inorder predecessor of the first element and insert the second element as the left child of the inorder predecessor. Finally, return the modified binary tree.\n\n[/Question 2]\n\n[Code 2]\n\nclass TreeNode:\n    def __init__(self, key):\n        self.left = None\n        self.right = None\n        self.val = key\n\ndef insertInorderPredecessor(root, pair_list):\n    def insertInorder(root, key, val):\n        if not root:\n            return TreeNode(val)\n        if root.val == key:\n            temp = root.left\n            root.left = TreeNode(val)\n            root.left.left = temp\n        else:\n            root.left = insertInorder(root.left, key, val)\n        root.right = insertInorder(root.right, key, val)\n        return root\n\n    for pair in pair_list:\n        root = insertInorder(root, pair[0], pair[1])\n    return root\n\n[/Code 2]\n\n[Asserts 2]\n\n# Creating tree nodes as per the given example\nroot = TreeNode(5)\nroot.left = TreeNode(3)\nroot.right = TreeNode(8)\nroot.left.left = TreeNode(2)\nroot.left.right = TreeNode(4)\npair_list = [(3, 6), (4, 7)]\nnew_tree = insertInorderPredecessor(root, pair_list)\nassert new_tree.val == 5\nassert new_tree.left.val == 3\nassert new_tree.left.left.val == 2\nassert new_tree.left.right.val == 4\nassert new_tree.left.right.left.val == 7\nassert new_tree.right.val == 8\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.711}, {"few_shot_keywords": "['comparison', 'binary search tree', 'sorting', 'count', 'validation', 'BST', 'closest sum', 'sequence', 'max', 'min', 'array', 'value']", "test_keywords": "['array', 'binary tree node', 'largest', 'BST', '2D', 'min', 'sorting', 'binary search tree', 'validation', 'max', 'generate', 'comparison']", "prompt_tokens": 535, "total_tokens": 877, "completion_tokens": 342, "completion": "[Question 2]\n\nGiven a binary tree, find the largest value in each row of the tree and return the resulting array.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\nfrom collections import deque\n\nclass TreeNode:\n    def __init__(self, value=0, left=None, right=None):\n        self.value = value\n        self.left = left\n        self.right = right\n\ndef largestValues(root: TreeNode) -> List[int]:\n    if not root:\n        return []\n    result = []\n    queue = deque([root])\n    while queue:\n        level_max = float('-inf')\n        for _ in range(len(queue)):\n            node = queue.popleft()\n            level_max = max(level_max, node.value)\n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n        result.append(level_max)\n    return result\n\n[/Code 2]\n\n[Asserts 2]\n\n# Create the binary tree: [1, 3, 2, 5, 3, None, 9]\nroot = TreeNode(1, TreeNode(3, TreeNode(5), TreeNode(3)), TreeNode(2, right=TreeNode(9)))\nassert largestValues(root) == [1, 3, 9]\n\n# Create the binary tree: [1, 2, 3, 4, 5, 6, 7]\nroot = TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(5)), TreeNode(3, TreeNode(6), TreeNode(7)))\nassert largestValues(root) == [1, 3, 7]\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.949}, {"few_shot_keywords": "['traversal', 'right', 'Binary Search Tree', 'minimum value', 'conversion', 'tree', 'node']", "test_keywords": "['minimum value', 'node', 'input', 'tree', 'character array', 'distinct elements', 'Binary Search Tree', 'traversal']", "prompt_tokens": 501, "total_tokens": 772, "completion_tokens": 271, "completion": "[Question 2]\n\nWrite a function to build a Binary Search Tree from a character array containing distinct elements, and then find the node with the minimum value.\n\n[/Question 2]\n\n[Code 2]\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef buildBST(arr: list) -> TreeNode:\n    if not arr:\n        return None\n    mid = len(arr) // 2\n    root = TreeNode(arr[mid])\n    root.left = buildBST(arr[:mid])\n    root.right = buildBST(arr[mid+1:])\n    return root\n\ndef minValueNode(root: TreeNode) -> TreeNode:\n    current = root\n    while current.left is not None:\n        current = current.left\n    return current\n\n[/Code 2]\n\n[Asserts 2]\n\n# Create BST from character array\narr = ['a', 'b', 'c', 'd', 'e', 'f', 'g']\nroot = buildBST(arr)\nassert minValueNode(root).val == 'a'\n# Create BST from character array\narr = ['z', 'x', 'y']\nroot = buildBST(arr)\nassert minValueNode(root).val == 'x'\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.716}, {"few_shot_keywords": "['traversal', 'sorting algorithm', 'stack', 'array', 'level order', 'decrease key', 'binary search tree', 'value', 'program', 'BST', 'root', 'denominations']", "test_keywords": "['traversal', 'level order', 'root', 'array', 'successor', 'BST', 'algorithm', 'stack', 'binary search tree', 'value', 'pair', 'visited']", "prompt_tokens": 573, "total_tokens": 918, "completion_tokens": 345, "completion": "[Question 2]\n\nGiven a Binary Search Tree (BST), write a program to find the inorder successor of a given node in the tree.\n\n[/Question 2]\n\n[Code 2]\n\nclass TreeNode:\n    def __init__(self, key):\n        self.left = None\n        self.right = None\n        self.val = key\n\ndef inorderSuccessor(root, p):\n    succ = None\n    while root:\n        if p.val < root.val:\n            succ = root\n            root = root.left\n        else:\n            root = root.right\n    return succ\n\n# Example usage\n# Create a BST\nroot = TreeNode(8)\nroot.left = TreeNode(3)\nroot.right = TreeNode(10)\nroot.left.left = TreeNode(1)\nroot.left.right = TreeNode(6)\nroot.left.right.left = TreeNode(4)\nroot.left.right.right = TreeNode(7)\nroot.right.right = TreeNode(14)\nroot.right.right.left = TreeNode(13)\n\np = root.left.right\nprint(inorderSuccessor(root, p).val)  # Output will be 7\n\n[/Code 2]\n\n[Asserts 2]\n\n# Create a BST for testing\nroot = TreeNode(5)\nroot.left = TreeNode(3)\nroot.right = TreeNode(7)\nroot.left.left = TreeNode(2)\nroot.left.right = TreeNode(4)\nroot.right.left = TreeNode(6)\nroot.right.right = TreeNode(8)\n\n# Test cases\nassert inorderSuccessor(root, root.left).val == 4\nassert inorderSuccessor(root, root.right.left).val == 7\nassert inorderSuccessor(root, root.right.right) == None\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.916}, {"few_shot_keywords": "['construct', 'left subtree', 'binary tree', 'inorder predecessor', 'root node', 'undirected', 'preorder traversal', 'matrix', 'right subtree', 'inorder traversal', 'swapping']", "test_keywords": "['preorder traversal', 'horizontal', 'construct', 'inorder traversal', 'right subtree', 'binary tree', 'root node', 'closest value', 'left subtree']", "prompt_tokens": 734, "total_tokens": 1101, "completion_tokens": 367, "completion": "[Question 2]\n\nGiven a binary search tree, find the closest value to a given target value.\n\nWrite a function to find the value in the binary search tree that is closest to the target value.\n\nFor example, given the binary search tree:\n\n```plaintext\n    4\n   / \\\n  2   5\n / \\\n1   3\n```\n\nand the target value is 3.714286, then the closest value to the target is 4.\n\nWrite a function to find the closest value in the binary tree to the given target value.\n   \n[/Question 2]\n\n[Code 2]\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef closestValue(root: TreeNode, target: float) -> int:\n        closest = float('inf')\n        while root:\n            if abs(root.val - target) < abs(closest - target):\n                closest = root.val\n            root = root.left if target < root.val else root.right\n        return closest\n\n[/Code 2]\n\n[Asserts 2]\n\n# Example 1\nroot = TreeNode(4, TreeNode(2, TreeNode(1), TreeNode(3)), TreeNode(5))\ntarget = 3.714286\nexpected_result = 4\nassert closestValue(root, target) == expected_result\n# Example 2\nroot = TreeNode(8, TreeNode(3, TreeNode(1), TreeNode(6, TreeNode(4), TreeNode(7))), TreeNode(10, None, TreeNode(14, TreeNode(13))))\ntarget = 7.5\nexpected_result = 7\nassert closestValue(root, target) == expected_result\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.859}, {"few_shot_keywords": "['rectangle', 'list', 'ancestor', 'tree node', 'binary search tree', 'subset', 'LCA', 'BST', 'closest sum']", "test_keywords": "['distribution', 'tree node', 'binary search tree', 'top-left', 'BST', 'comparison', 'complete', 'LCA', 'binary-search-tree', 'ancestor']", "prompt_tokens": 595, "total_tokens": 838, "completion_tokens": 243, "completion": "[Question 2]\n\nGiven a Binary Search Tree (BST), write a function to find the top-left value in a complete binary tree.\n\n[/Question 2]\n\n[Code 2]\n\n# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef findTopLeftValue(root: TreeNode) -> int:\n    queue = [root]\n    result = root.val\n\n    while queue:\n        result = queue[0].val\n        queue = [child for node in queue for child in (node.left, node.right) if child]\n    \n    return result\n\n[/Code 2]\n\n[Asserts 2]\n\ntree = TreeNode(5, TreeNode(3, TreeNode(2), TreeNode(4)), TreeNode(6, TreeNode(7)))\nassert findTopLeftValue(tree) == 5\n\ntree = TreeNode(1, TreeNode(2, TreeNode(4)), TreeNode(3, TreeNode(5, TreeNode(7)), TreeNode(6)))\nassert findTopLeftValue(tree) == 4\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.778}, {"few_shot_keywords": "['check', 'right', 'node', 'validation', 'left', 'value', 'tree', 'binary tree', 'search', 'starting', 'leaf nodes', 'zeros', 'squares']", "test_keywords": "['value', 'Excel', 'validation', 'right', 'point', 'probability', 'check', 'tree', 'binary tree', 'left', 'node', 'search', 'pointer']", "prompt_tokens": 659, "total_tokens": 1021, "completion_tokens": 362, "completion": "[Question 2]\n\nYou are given a binary tree where each node has an associated value. Write a function to find the probability of reaching a node with a specific value starting from the root node. The probability is the likelihood of reaching a node with the given value by choosing the right or left child node at each point. \n\n[/Question 2]\n\n[Code 2]\n\nclass TreeNode:\n    def __init__(self, key):\n        self.left = None\n        self.right = None\n        self.val = key\n\ndef find_probability(root, target_value, current_value, probability):\n    if root is None:\n        return 0\n    if root.val == target_value:\n        return probability\n    return (find_probability(root.left, target_value, current_value + 1, probability / 2) +\n            find_probability(root.right, target_value, current_value + 1, probability / 2))\n\n[/Code 2]\n\n[Asserts 2]\n\n# Create a sample binary tree \nroot = TreeNode(4) \nroot.left = TreeNode(2) \nroot.right = TreeNode(5) \nroot.left.left = TreeNode(1) \nroot.left.right = TreeNode(3) \n# Find the probability of reaching the node with value 3\nassert find_probability(root, 3, 1, 1)==0.5\n# Create a binary tree with different values\nroot = TreeNode(3) \nroot.left = TreeNode(2) \nroot.right = TreeNode(5) \nroot.left.left = TreeNode(1) \nroot.left.right = TreeNode(4) \n# Find the probability of reaching the node with value 4\nassert find_probability(root, 4, 1, 1)==0.25\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.864}, {"few_shot_keywords": "['boolean', 'binary search tree', 'preorder traversal', 'child', 'divide and conquer', 'array', 'comparison', 'distribution', 'spiral order', 'internal node']", "test_keywords": "['preorder traversal', 'internal node', 'comparison', 'sorting', 'child', 'binary search tree', 'boolean', 'right', 'array', 'kth', 'search', 'indexing']", "prompt_tokens": 634, "total_tokens": 875, "completion_tokens": 241, "completion": "[Question 2]\n\nGiven a binary search tree (BST) represented by its preorder traversal array and an integer k, write a function to find the kth smallest element in the BST.\n\n[/Question 2]\n\n[Code 2]\n\nclass TreeNode:\n    def __init__(self, value=0, left=None, right=None):\n        self.value = value\n        self.left = left\n        self.right = right\n\ndef kthSmallest(root: TreeNode, k: int) -> int:\n    stack = []\n    while True:\n        while root:\n            stack.append(root)\n            root = root.left\n        root = stack.pop()\n        k -= 1\n        if k == 0:\n            return root.value\n        root = root.right\n\n[/Code 2]\n\n[Asserts 2]\n\n# Create the BST\nroot = TreeNode(5, TreeNode(3, TreeNode(2), TreeNode(4)), TreeNode(6))\nassert kthSmallest(root, 3) == 4\nassert kthSmallest(root, 5) == 6\nassert kthSmallest(root, 1) == 2\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.919}, {"few_shot_keywords": "['binary search tree', 'smallest', 'element', 'BST', 'integer', 'palindromic', 'zeros', 'transpose', 'kth', 'node', 'minimum value', 'tree']", "test_keywords": "['2D-array', 'smallest', 'element', 'mark', 'node', 'lowercase', 'integer', 'BST', 'inside', 'binary search tree', 'tree', 'kth']", "prompt_tokens": 695, "total_tokens": 997, "completion_tokens": 302, "completion": "[Question 2]\n\nYou are given a 2D array representing a binary search tree (BST) where each node is marked with a lowercase letter. You need to find the k'th smallest element in the BST.\n\n[/Question 2]\n\n[Code 2]\n\nclass Solution:\n    def kthSmallest(self, matrix: List[List[str]], k: int) -> str:\n        elements = []\n        for row in matrix:\n            for val in row:\n                elements.append(val)\n        elements.sort()\n        return elements[k-1]\n\n[/Code 2]\n\n[Asserts 2]\n\n# Example 2D array representing the BST\n# [\n#   ['a', 'b', 'c'],\n#   ['d', 'e', 'f'],\n#   ['g', 'h', 'i']\n# ]\nsol = Solution()\nassert sol.kthSmallest([['a', 'b', 'c'], ['d', 'e', 'f'], ['g', 'h', 'i']], 1) == 'a'\nassert sol.kthSmallest([['a', 'b', 'c'], ['d', 'e', 'f'], ['g', 'h', 'i']], 5) == 'e'\nassert sol.kthSmallest([['a', 'b', 'c'], ['d', 'e', 'f'], ['g', 'h', 'i']], 9) == 'i'\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.726}, {"few_shot_keywords": "['array', 'mirror', 'comparison', 'adjacency list', 'inorder traversal', 'efficient', 'boolean', 'conditional', 'zero', 'binary search tree', 'iteration', 'top-left']", "test_keywords": "['boolean', 'adjacent', 'character array', 'array', 'singly linked list', 'interior', 'iteration', 'comparison', 'binary search tree', 'LCA', 'inorder traversal', 'conditional']", "prompt_tokens": 519, "total_tokens": 839, "completion_tokens": 320, "completion": "[Question 2]\n\nGiven a binary search tree, write a function to find the lowest common ancestor (LCA) of two given nodes with values `p` and `q`. The nodes are guaranteed to exist in the tree.\n\n[/Question 2]\n\n[Code 2]\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef lowestCommonAncestor(root: TreeNode, p: TreeNode, q: TreeNode) -> TreeNode:\n    if root.val > p.val and root.val > q.val:\n        return lowestCommonAncestor(root.left, p, q)\n    elif root.val < p.val and root.val < q.val:\n        return lowestCommonAncestor(root.right, p, q)\n    else:\n        return root\n\n[/Code 2]\n\n[Asserts 2]\n\n# Create a binary search tree\nroot = TreeNode(6)\nroot.left = TreeNode(2)\nroot.right = TreeNode(8)\nroot.left.left = TreeNode(0)\nroot.left.right = TreeNode(4)\nroot.left.right.left = TreeNode(3)\nroot.left.right.right = TreeNode(5)\nroot.right.left = TreeNode(7)\nroot.right.right = TreeNode(9)\n\nassert lowestCommonAncestor(root, root.left, root.right) == root\nassert lowestCommonAncestor(root, root.left, root.left.right.right) == root.left\nassert lowestCommonAncestor(root, root.left.right.left, root.left.right.right) == root.left.right", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.831}, {"few_shot_keywords": "['Binary Search Tree', 'BST', 'equality', 'center', 'set', 'comparison', 'boolean', 'rectangle', 'floor', 'elements']", "test_keywords": "['equality', 'set', 'rounded value', 'islands', 'Binary Search Tree', 'minimum', 'BST', 'comparison', 'elements']", "prompt_tokens": 628, "total_tokens": 875, "completion_tokens": 247, "completion": "[Question 2]\n\nGiven a Binary Search Tree (BST), the task is to find the minimum rounded value of the elements in the BST.\n\n[/Question 2]\n\n[Code 2]\n\nclass Node:\n    def __init__(self, key):\n        self.data = key\n        self.left = None\n        self.right = None\n\ndef minRoundedValue(root):\n    # Helper function to perform inorder traversal and populate a set\n    def inorderTraversal(root, values):\n        if root:\n            inorderTraversal(root.left, values)\n            values.add(root.data)\n            inorderTraversal(root.right, values)\n\n    values = set()\n    inorderTraversal(root, values)\n    min_rounded = round(min(values))\n    return min_rounded\n\n[/Code 2]\n\n[Asserts 2]\n\n# Creating the BST\nroot = Node(15)\nroot.left = Node(10)\nroot.right = Node(20)\nroot.left.left = Node(5)\nroot.left.right = Node(12)\nroot.right.left = Node(17)\nroot.right.right = Node(25)\n# Assertion to check the minimum rounded value in the BST\nassert minRoundedValue(root) == 5\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.802}, {"few_shot_keywords": "['shortest distance', 'integers', 'sums', 'range', 'Binary Search Tree', 'LCA', 'real numbers', 'iterative', 'findDistance', 'nodes']", "test_keywords": "['nodes', 'shortest distance', 'LCA', 'Binary Search Tree', 'findDistance', 'maximum', 'unique', 'squares']", "prompt_tokens": 763, "total_tokens": 1306, "completion_tokens": 543, "completion": "[Question 2]\n\nWrite a program to find the shortest distance between two unique nodes in a Binary Search Tree (BST) such that the maximum of the squares of the values of the nodes along the path is minimized. You are given a BST and the task is to find the shortest distance such that the maximum of the squares of the values of the nodes along the path is minimized.\n\n[/Question 2]\n\n[Code 2]\n\nclass Node:\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n\ndef findLCA(root: Node, n1: int, n2: int) -> Node:\n    if root is None:\n        return None\n    if root.key > n1 and root.key > n2:\n        return findLCA(root.left, n1, n2)\n    if root.key < n1 and root.key < n2:\n        return findLCA(root.right, n1, n2)\n    return root\n\ndef distanceBetweenUniqueNodes(root: Node, n1: int, n2: int) -> int:\n    if root is None:\n        return 0\n    lca = findLCA(root, n1, n2)\n    d1 = findDistance(lca, n1, 0)\n    d2 = findDistance(lca, n2, 0)\n    return d1 + d2\n\ndef findDistance(root: Node, n: int, distance: int) -> int:\n    if root is None:\n        return 0\n    if root.key == n:\n        return distance\n    if root.key > n:\n        return findDistance(root.left, n, distance + 1)\n    return findDistance(root.right, n, distance + 1)\n    \ndef minimumMaxSquareAlongPath(root: Node, n1: int, n2: int) -> int:\n    distance = distanceBetweenUniqueNodes(root, n1, n2)\n    return (distance - 1) ** 2\n\n[/Code 2]\n\n[Asserts 2]\n\nroot = Node(10)\nroot.left = Node(5)\nroot.right = Node(20)\nroot.left.left = Node(3)\nroot.left.right = Node(7)\nroot.right.left = Node(15)\nroot.right.right = Node(25)\nassert minimumMaxSquareAlongPath(root, 3, 7) == 16\nassert minimumMaxSquareAlongPath(root, 15, 25) == 4\nassert minimumMaxSquareAlongPath(root, 5, 15) == 64\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.894}, {"few_shot_keywords": "['data structure', 'recursion', 'tree traversal', 'swaps', 'nodes', 'triplets', 'binary search tree', 'count', 'inorder traversal', 'comparison', 'subtree', 'range']", "test_keywords": "['nodes', 'binary search tree', 'comparison', 'dp', 'tree traversal', 'data structure', 'recursion', 'subtree', 'specific', 'count', 'range']", "prompt_tokens": 577, "total_tokens": 843, "completion_tokens": 266, "completion": "[Question 2]\n\nGiven a binary search tree, write a recursive function to count the number of nodes in the subtree rooted at a specific node that are within a given range [low, high].\n\n[/Question 2]\n\n[Code 2]\n\nclass Node:\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n\ndef countNodesInRange(root, low, high):\n    if root is None:\n        return 0\n    count = 0\n    if low <= root.key <= high:\n        count += 1\n    count += countNodesInRange(root.left, low, high)\n    count += countNodesInRange(root.right, low, high)\n    return count\n\n[/Code 2]\n\n[Asserts 2]\n\n# Create the BST\nroot = Node(10)\nroot.left = Node(5)\nroot.right = Node(50)\nroot.left.left = Node(1)\nroot.right.left = Node(40)\nroot.right.right = Node(100)\nassert countNodesInRange(root, 5, 45) == 4\nassert countNodesInRange(root, 5, 55) == 5\nassert countNodesInRange(root, 1, 100) == 7\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.807}, {"few_shot_keywords": "['center', 'binary', 'node', 'removal', 'leaf', 'validation', 'search', 'recursive', 'top to bottom', 'structure', 'tree']", "test_keywords": "['starting', 'inorder', 'validation', 'distance', 'leaf', 'recursive', 'swap', 'binary', 'search', 'node', 'tree', 'vertical', 'removal']", "prompt_tokens": 640, "total_tokens": 999, "completion_tokens": 359, "completion": "[Question 2]\n\nGiven a binary search tree, write a function to swap the left and right child of every node. Then, validate if the resulting tree is still a valid binary search tree.\n\n[/Question 2]\n\n[Code 2]\n\n# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef swapChildren(root: TreeNode) -> TreeNode:\n    if root:\n        root.left, root.right = root.right, root.left\n        swapChildren(root.left)\n        swapChildren(root.right)\n    return root\n\ndef isValidBST(root: TreeNode) -> bool:\n    def isBST(node, min_val, max_val):\n        if not node:\n            return True\n        if not min_val < node.val < max_val:\n            return False\n        return isBST(node.left, min_val, node.val) and isBST(node.right, node.val, max_val)\n    \n    return isBST(root, float('-inf'), float('inf'))\n\n# combining both operations\ndef swapAndValidateBST(root: TreeNode) -> bool:\n    swapChildren(root)\n    return isValidBST(root)\n\n[/Code 2]\n\n[Asserts 2]\n\n# test cases\n# create a valid BST\nroot = TreeNode(4, TreeNode(2, TreeNode(1), TreeNode(3)), TreeNode(7, TreeNode(6), TreeNode(9)))\nassert swapAndValidateBST(root) == True\n\n# create an invalid BST\nroot = TreeNode(3, TreeNode(2, TreeNode(1), TreeNode(4)), TreeNode(5))\nassert swapAndValidateBST(root) == False\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.797}, {"few_shot_keywords": "['Binary Search Tree', 'remove', 'value', 'BST', 'node', 'left', 'inorder', 'stack', 'start', 'sum', 'pairs', 'right']", "test_keywords": "['right', 'inorder', 'BST', 'node', 'stack', 'palindrome', 'array', 'mark', 'Binary Search Tree', 'left', 'value', 'reverse', 'pairs', 'sum']", "prompt_tokens": 815, "total_tokens": 1057, "completion_tokens": 242, "completion": "[Question 2]\n\nGiven an array of integers, determine whether there exists a pair of indices (i, j) such that i != j and the sum of the elements at those indices is a palindrome when represented in binary.\n\n[/Question 2]\n\n[Code 2]\n\ndef isPalindrome(num):\n    binary = bin(num)[2:]\n    return binary == binary[::-1]\n\ndef hasPalindromePair(nums):\n    seen = set()\n    for i, num in enumerate(nums):\n        if any(isPalindrome(num + n) for n in seen):\n            return True\n        seen.add(num)\n    return False\n\n[/Code 2]\n\n[Asserts 2]\n\nassert hasPalindromePair([1, 3, 5, 7]) == False\nassert hasPalindromePair([1, 2, 3, 4, 5, 6]) == True\nassert hasPalindromePair([4, 8, 16]) == True\nassert hasPalindromePair([1, 2, 4, 8, 16]) == False\nassert hasPalindromePair([3, 3, 3, 3]) == True\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.907}, {"few_shot_keywords": "['closest value', 'node', 'position', 'sqrt', 'comparison', 'integer', 'tree traversal', 'binary search tree']", "test_keywords": "['permutations', 'comparison', 'right', 'tree traversal', 'closest value', 'integer', 'node', 'binary search tree', 'weights', 'DFS']", "prompt_tokens": 560, "total_tokens": 908, "completion_tokens": 348, "completion": "[Question 2]\n\nGiven a binary search tree and a target integer, write a function to find the permutation of the node values in the BST that is closest to the target integer. The permutation should be a result of a depth-first search (DFS) traversal of the BST.\n\n[/Question 2]\n\n[Code 2]\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef closestPermutation(root: TreeNode, target: int) -> List[int]:\n    def dfs(node, values):\n        if not node:\n            return\n        values.append(node.val)\n        dfs(node.left, values)\n        dfs(node.right, values)\n\n    values = []\n    dfs(root, values)\n    values.sort(key=lambda x: abs(target - x))\n    return values\n\n[/Code 2]\n\n[Asserts 2]\n\ntree = TreeNode(9, TreeNode(4, TreeNode(3), TreeNode(6, TreeNode(5), TreeNode(7))), TreeNode(17, None, TreeNode(22, None, TreeNode(20))))\nassert closestPermutation(tree, 10)==[9, 6, 7, 4, 5, 3, 17, 22, 20]\nassert closestPermutation(tree, 15)==[17, 9, 7, 6, 5, 4, 3, 20, 22]\nassert closestPermutation(tree, 5)==[4, 3, 6, 5, 7, 9, 17, 20, 22]\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.706}, {"few_shot_keywords": "['preorder traversal', 'binary tree', 'recursion', 'coprime', 'list', 'columns', 'postorder traversal', 'root node', 'in-degree', 'tree construction', 'transpose']", "test_keywords": "['root node', 'inorder', 'postorder traversal', 'title', 'recursion', 'method', 'tree construction', 'counting-out game', 'list', 'preorder traversal', 'binary tree', 'trailing zeroes']", "prompt_tokens": 678, "total_tokens": 950, "completion_tokens": 272, "completion": "[Question 2]\n\nGiven the inorder and preorder traversal of a binary tree, write a method to construct the binary tree and return the root node.\n\n[/Question 2]\n\n[Code 2]\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef buildTree(preorder: List[int], inorder: List[int]) -> TreeNode:\n    if not preorder or not inorder:\n        return None\n    \n    root_val = preorder.pop(0)\n    root = TreeNode(root_val)\n    inorder_index = inorder.index(root_val)\n    \n    root.left = buildTree(preorder, inorder[:inorder_index])\n    root.right = buildTree(preorder, inorder[inorder_index+1:])\n    \n    return root\n\n[/Code 2]\n\n[Asserts 2]\n\ninorder = [9, 3, 15, 20, 7]\npreorder = [3, 9, 20, 15, 7]\ntree = buildTree(preorder, inorder)\nassert tree.val == 3\nassert tree.left.val == 9\nassert tree.right.val == 20\nassert tree.right.left.val == 15\nassert tree.right.right.val == 7\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.75}, {"few_shot_keywords": "['inorder traversal', 'threaded binary tree', 'parent', '2D array', 'convert', 'binary tree', 'perfect square', 'predecessor', 'successor', 'insert']", "test_keywords": "['successor', 'ends', 'threaded binary tree', 'convert', 'inorder traversal', 'predecessor', 'binary tree node', 'binary tree', 'insert']", "prompt_tokens": 710, "total_tokens": 1189, "completion_tokens": 479, "completion": "[Question 2]\n\nYou are given a binary tree and a node. Write a function to find the inorder successor of the given node in the threaded binary tree.\n\n[/Question 2]\n\n[Code 2]\n\nclass Node:\n    def __init__(self, data):\n        self.left = None\n        self.right = None\n        self.data = data\n        self.rightThreaded = False\n\ndef insert(root, key):\n    if not root:\n        return Node(key)\n    if key < root.data:\n        root.left = insert(root.left, key)\n    elif key > root.data:\n        root.right = insert(root.right, key)\n    return root\n\ndef createThreaded(root, prev):\n    if not root:\n        return\n    createThreaded(root.left, prev)\n    if not root.left:\n        root.left = prev\n        root.rightThreaded = True\n    prev = root\n    createThreaded(root.right, prev)\n\ndef convertToThreaded(root):\n    temp = Node(-1)\n    temp.right = temp\n    createThreaded(root, temp)\n\ndef inorderSuccessor(root, target):\n    successor = None\n    isTarget = False\n    ptr = root\n    while ptr:\n        if ptr.data == target:\n            isTarget = True\n            if ptr.rightThreaded:\n                successor = ptr.right\n                break\n        if ptr.rightThreaded and (not isTarget):\n            successor = ptr.right\n        ptr = ptr.right if ptr.rightThreaded else ptr.right\n    return successor.data if successor else None\n\n[/Code 2]\n\n[Asserts 2]\n\n# Create a sample binary tree\nroot = Node(5)\ninsert(root, 3)\ninsert(root, 8)\ninsert(root, 2)\ninsert(root, 4)\ninsert(root, 7)\ninsert(root, 9)\n# Convert the binary tree to threaded binary tree\nconvertToThreaded(root)\n# Find the inorder successor of the node with data 4\nassert inorderSuccessor(root, 4) == 5\n# Find the inorder successor of the node with data 7\nassert inorderSuccessor(root, 7) == 8\n# Find the inorder successor of the node with data 9\nassert inorderSuccessor(root, 9) == None\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.83}, {"few_shot_keywords": "['array', 'floor', 'decrease key', 'bipartite', 'stack', 'BST', 'binary-search', 'sorting', 'tree', 'traversal', 'closest']", "test_keywords": "['binary-search', 'numbers', 'occurrences', 'largest', 'BST', 'array', 'sorting', 'dictionary', 'tree', 'stack', 'traversal']", "prompt_tokens": 650, "total_tokens": 871, "completion_tokens": 221, "completion": "[Question 2]\n\nWrite a program to find the largest number and its occurrences in an array. If there are multiple numbers with the same largest value, return all of them.\n\n[/Question 2]\n\n[Code 2]\n\ndef findLargestAndOccurrences(arr):\n    max_num = float('-inf')\n    occurrences = {}\n    for num in arr:\n        if num > max_num:\n            max_num = num\n            occurrences[num] = 1\n        elif num == max_num:\n            occurrences[num] += 1\n    return max_num, occurrences[max_num]\n\n[/Code 2]\n\n[Asserts 2]\n\nassert findLargestAndOccurrences([3, 7, 2, 7, 7, 5, 2])== (7, 3)\nassert findLargestAndOccurrences([5, 5, 5, 5, 5])== (5, 5)\nassert findLargestAndOccurrences([1, 2, 3, 4, 5])== (5, 1)\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.923}, {"few_shot_keywords": "['singly', 'in-degree', 'node', 'construct', 'tree', 'binary', 'traversal', 'full', 'spiral', 'children', 'mirror', 'preorder']", "test_keywords": "['full', 'construct', 'mirror', 'tree', 'node', 'permutations', 'defaultdict', 'traversal', 'undirected', 'children', 'transpose', 'binary', 'preorder']", "prompt_tokens": 642, "total_tokens": 1099, "completion_tokens": 457, "completion": "[Question 2]\n\nGiven an undirected graph, construct a mirror tree where each node in the tree represents a unique permutation of the nodes in the graph, and the children of each node are the permutations obtained by swapping two adjacent nodes in the parent permutation.\n\n[/Question 2]\n\n[Code 2]\n\nfrom collections import defaultdict\n\nclass TreeNode:\n    def __init__(self, val=0, children=None):\n        self.val = val\n        self.children = children if children is not None else []\n\ndef constructMirrorTree(graph: List[List[int]]) -> TreeNode:\n    def permutations(nums):\n        result = [[]]\n        for num in nums:\n            new_perms = []\n            for perm in result:\n                for i in range(len(perm) + 1):\n                    new_perms.append(perm[:i] + [num] + perm[i:])\n            result = new_perms\n        return result\n\n    permutations_dict = defaultdict(list)\n    for idx, permutation in enumerate(permutations(range(len(graph)))):\n        permutations_dict[tuple(permutation)].append(idx)\n\n    root = TreeNode(tuple(range(len(graph))))\n\n    nodes = [(root, tuple(range(len(graph))))]\n    seen = set([tuple(range(len(graph)))])\n\n    while nodes:\n        node, perm = nodes.pop()\n        for i in range(len(perm)):\n            for j in range(i + 1, len(perm)):\n                nxt_perm = list(perm)\n                nxt_perm[i], nxt_perm[j] = nxt_perm[j], nxt_perm[i]\n                nxt_perm = tuple(nxt_perm)\n                if nxt_perm not in seen:\n                    seen.add(nxt_perm)\n                    child = TreeNode(nxt_perm)\n                    node.children.append(child)\n                    nodes.append((child, nxt_perm))\n    \n    return root\n\n[/Code 2]\n\n[Asserts 2]\n\ngraph = [[1, 2], [0, 2], [0, 1]]\nassert constructMirrorTree(graph) == [[0, 1, 2], [1, 0, 2], [1, 2, 0], [0, 2, 1], [2, 1, 0], [2, 0, 1]]\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.933}, {"few_shot_keywords": "['binary search tree', '2D list', 'distinct', 'node', 'operation', 'decrease key', 'Boyer Moore', 'change key', 'BST', 'insert', 'delete']", "test_keywords": "['node', 'binary search tree', 'intersect', 'diagonals', 'insert', 'vertex cover', 'change key', 'delete', 'BST', 'skew-symmetric', 'decrease key', 'linked list', 'operation']", "prompt_tokens": 840, "total_tokens": 1358, "completion_tokens": 518, "completion": "[Question 2]\n\nYou are given a binary search tree (BST) and a linked list. Write a Python function to find and return the intersection of the diagonals of the BST and the linked list, considering the vertices covered by the linked list as a vertex cover.\n\n[/Question 2]\n\n[Code 2]\n\nclass Node:\n    def __init__(self, key):\n        self.left = None\n        self.right = None\n        self.val = key\n\nclass BST:\n    def __init__(self):\n        self.root = None\n\n    def insert(self, root, key):\n        if root is None:\n            return Node(key)\n        else:\n            if root.val < key:\n                root.right = self.insert(root.right, key)\n            else:\n                root.left = self.insert(root.left, key)\n        return root\n\n    def deleteNode(self, root, key):\n        if root is None:\n            return root\n        \n        if key < root.val:\n            root.left = self.deleteNode(root.left, key)\n        elif key > root.val:\n            root.right = self.deleteNode(root.right, key)\n        else:\n            if root.left is None:\n                return root.right\n            elif root.right is None:\n                return root.left\n\n            min_node = self.minValueNode(root.right)\n            root.val = min_node.val\n            root.right = self.deleteNode(root.right, min_node.val)\n\n        return root\n\n    def minValueNode(self, node):\n        current = node\n        while current.left is not None:\n            current = current.left\n        return current\n\ndef findIntersection(bst, linked_list):\n    # Implementing the logic to find the intersection of diagonals\n    # and considering the vertices covered by the linked list as a vertex cover\n    pass\n\n[/Code 2]\n\n[Asserts 2]\n\nbst = BST()\nbst.insert(bst.root, 50)\nbst.insert(bst.root, 30)\nbst.insert(bst.root, 70)\nbst.insert(bst.root, 20)\nbst.insert(bst.root, 40)\nbst.insert(bst.root, 60)\nbst.insert(bst.root, 80)\n\n# Create a linked list\nclass ListNode:\n    def __init__(self, value=0, next=None):\n        self.value = value\n        self.next = next\n\nlinked_list = ListNode(30, ListNode(40, ListNode(60)))\n\nassert findIntersection(bst, linked_list) == [30, 40, 60]\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.711}, {"few_shot_keywords": "['backward', 'traversal', 'comparison', 'binary search tree', 'shared', 'nodes', 'insert', 'swapping', 'inorder', 'arrangement', 'common']", "test_keywords": "['insert', 'triangle', 'nodes', 'shared', 'binary search tree', 'common', 'traversal', 'start', 'inorder', 'comparison']", "prompt_tokens": 806, "total_tokens": 1338, "completion_tokens": 532, "completion": "[Question 2]\n\nGiven a Binary Search Tree (BST), the task is to insert nodes in such a way that the BST forms a triangle arrangement and then find and print the common nodes shared by the original and modified BST.\n\n[/Question 2]\n\n[Code 2]\n\nclass Node:\n    def __int__(self, key: int) -> None:\n        self.data = key\n        self.left = None\n        self.right = None\n\ndef insert(root: Node, key: int) -> Node:\n    if root is None:\n        return Node(key)\n    if key < root.data:\n        root.left = insert(root.left, key)\n    else:\n        root.right = insert(root.right, key)\n    return root\n\ndef inorder(root: Node, res: list) -> None:\n    if root:\n        inorder(root.left, res)\n        res.append(root.data)\n        inorder(root.right, res)\n\ndef insertToFormTriangle(root: Node, start: int) -> Node:\n    if start <= 0:\n        return root\n    root = insert(root, start)\n    insertToFormTriangle(root, start-1)\n    return root\n\ndef printCommon(root1: Node, root2: Node) -> list:\n    arr1, arr2 = [], []\n    inorder(root1, arr1)\n    inorder(root2, arr2)\n    i = j = 0\n    res = []\n    while i < len(arr1) and j < len(arr2):\n        if arr1[i] == arr2[j]:\n            res.append(arr1[i])\n            i += 1\n            j += 1\n        elif arr1[i] < arr2[j]:\n            i += 1\n        else:\n            j += 1\n    return res\n\n# Original BST\nroot = None\nroot = insert(root, 5)\nroot = insert(root, 3)\nroot = insert(root, 7)\nroot = insert(root, 2)\nroot = insert(root, 4)\nroot = insert(root, 6)\nroot = insert(root, 8)\n\n# Modified BST in triangle arrangement\nmodified_root = insertToFormTriangle(root, 5)\n\n# Find and print the common nodes shared by the original and modified BST\ncommon_nodes = printCommon(root, modified_root)\nprint(common_nodes)\n\n[/Code 2]\n\n[Asserts 2]\n\n# Example Asserts can be: \n# assert printCommon(root, modified_root) == [5, 4, 3, 2, 7, 6, 8]\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.879}, {"few_shot_keywords": "['binary search tree', 'largest', 'order', 'traversal', 'preorder', 'two pointers', 'leaf nodes', 'recursive', 'array']", "test_keywords": "['leaf nodes', 'removals', 'binary search tree', 'structure', 'preorder', 'array', 'traversal', 'order', 'tree structure']", "prompt_tokens": 552, "total_tokens": 901, "completion_tokens": 349, "completion": "[Question 2]\n\nGiven a binary search tree and an array of values representing the leaf nodes to be removed, write a function to remove the specified leaf nodes from the binary search tree and return the updated tree structure.\n\n[/Question 2]\n\n[Code 2]\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef removeLeafNodes(root: TreeNode, leafNodes: List[int]) -> TreeNode:\n    if not root:\n        return None\n    root.left = removeLeafNodes(root.left, leafNodes)\n    root.right = removeLeafNodes(root.right, leafNodes)\n    if root.val in leafNodes and not root.left and not root.right:\n        return None\n    return root\n\n[/Code 2]\n\n[Asserts 2]\n\n# Create the binary search tree\n#        10\n#       /  \\\n#      5    15\n#     / \\   / \\\n#    3   7 12  18\nroot = TreeNode(10, TreeNode(5, TreeNode(3), TreeNode(7)), TreeNode(15, TreeNode(12), TreeNode(18)))\n\n# Remove leaf nodes [3, 7, 12]\nresult = removeLeafNodes(root, [3, 7, 12])\n\n# Verify the structure after removal\nassert result.val == 10\nassert result.left.val == 5\nassert result.left.left == None\nassert result.left.right == None\nassert result.right.val == 15\nassert result.right.left == None\nassert result.right.right.val == 18\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.712}, {"few_shot_keywords": "['step', 'algorithm', 'children', 'BST', 'binary search tree', 'tree', 'preorder traversal', 'leaf nodes', 'node', 'recursion', 'position']", "test_keywords": "['2D grid', 'generation', 'recursion', 'node', 'swapping', 'leaf nodes', 'binary search tree', 'children', 'tree', 'preorder traversal', 'BST']", "prompt_tokens": 672, "total_tokens": 948, "completion_tokens": 276, "completion": "[Question 2]\n\nGiven a 2D grid representing a binary search tree (BST) where each cell contains a node, write a function to swap the left and right children of all non-leaf nodes in the BST using recursion. \n\n[/Question 2]\n\n[Code 2]\n\nclass TreeNode:\n    def __init__(self, key: int):\n        self.val = key\n        self.left = None\n        self.right = None\n\ndef swapChildren(grid: List[List[TreeNode]]) -> None:\n    def swap(node: TreeNode):\n        if node is None or (node.left is None and node.right is None):\n            return\n        node.left, node.right = node.right, node.left\n        swap(node.left)\n        swap(node.right)\n    for row in grid:\n        for node in row:\n            swap(node)\n\n[/Code 2]\n\n[Asserts 2]\n\nnode1 = TreeNode(1)\nnode2 = TreeNode(2)\nnode3 = TreeNode(3)\nnode1.left = node2\nnode1.right = node3\n\ngrid = [[node1, None, None], [None, None, None], [None, None, None]]\nswapChildren(grid)\nassert grid[0][0].left.val == 3\nassert grid[0][0].right.val == 2\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.843}, {"few_shot_keywords": "['node', 'structure', 'absolut difference', 'insertion', 'equal', 'parent-pointer', 'binary-search-tree']", "test_keywords": "['insertion', 'perimeter', 'top to bottom', 'parent-pointer', 'structure', 'binary-search-tree', 'node']", "prompt_tokens": 677, "total_tokens": 1095, "completion_tokens": 418, "completion": "[Question 2]\n\nYou are given a binary search tree with a parent pointer. Write a function to calculate the perimeter of the tree, which is defined as the sum of all the node values from the top to bottom and from left to right along the boundary of the tree. The Node structure is defined as follows:\n\n```python\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.left = None\n        self.right = None\n        self.parent = None\n```\n\nWrite a function `calculate_perimeter` that takes the root node of the tree and returns the sum of the perimeter values.\n\n[/Question 2]\n\n[Code 2]\n\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.left = None\n        self.right = None\n        self.parent = None\n\ndef calculate_perimeter(root: Node) -> int:\n    def left_boundary_sum(node):\n        if not node or (not node.left and not node.right):\n            return 0\n        return node.data + left_boundary_sum(node.left)\n\n    def right_boundary_sum(node):\n        if not node or (not node.left and not node.right):\n            return 0\n        return node.data + right_boundary_sum(node.right)\n\n    def leaf_sum(node):\n        if not node:\n            return 0\n        if not node.left and not node.right:\n            return node.data\n        return leaf_sum(node.left) + leaf_sum(node.right)\n\n    return root.data + left_boundary_sum(root.left) + right_boundary_sum(root.right) + leaf_sum(root.left) + leaf_sum(root.right)\n\n[/Code 2]\n\n[Asserts 2]\n\n# Create a BST and test the calculate_perimeter function\nroot = Node(10)\nroot.left = Node(5)\nroot.right = Node(15)\nroot.left.right = Node(8)\nroot.left.left = Node(3)\n# Assert the perimeter of the BST\nassert calculate_perimeter(root) == 41\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.735}, {"few_shot_keywords": "['alternating', 'array', 'pre-order traversal', 'node', 'leaf', 'tree structure', 'root', 'DFS', 'construction', 'binary tree', 'binary search tree', 'insert']", "test_keywords": "['leaf', 'binary search tree', 'connected cells', 'node', 'factors', 'array', 'construction', 'insert', 'permutations', 'tree structure', 'pre-order traversal', 'searching', 'binary tree', 'root']", "prompt_tokens": 641, "total_tokens": 1056, "completion_tokens": 415, "completion": "[Question 2]\n\nGiven a binary search tree, write a function to find all the leaf nodes and return the array of values of those leaf nodes. Additionally, for each leaf node, find the number of connected cells in the binary tree, where connected cells are the total number of nodes in the subtree rooted at the leaf node.\n\n[/Question 2]\n\n[Code 2]\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef findLeafNodes(root: TreeNode) -> List[int]:\n    leaf_values = []\n    def dfs(node):\n        if not node:\n            return 0\n        if not node.left and not node.right:\n            leaf_values.append(node.val)\n            return 1\n        return dfs(node.left) + dfs(node.right)\n    dfs(root)\n    return leaf_values\n\ndef findConnectedCells(root: TreeNode) -> List[int]:\n    connected_cells = []\n    def dfs(node):\n        if not node:\n            return 0\n        if not node.left and not node.right:\n            connected_cells.append(dfs(node)+1)\n            return 1\n        return dfs(node.left) + dfs(node.right) + 1\n    dfs(root)\n    return connected_cells\n\n[/Code 2]\n\n[Asserts 2]\n\ntree2 = TreeNode(10, TreeNode(5, TreeNode(3), TreeNode(7)), TreeNode(15, TreeNode(12), TreeNode(18)))\nassert findLeafNodes(tree2) == [3, 7, 12, 18]\nassert findConnectedCells(tree2) == [2, 2, 2, 2]\n\ntree3 = TreeNode(20, TreeNode(10, TreeNode(5), TreeNode(15)), TreeNode(30, None, TreeNode(40)))\nassert findLeafNodes(tree3) == [5, 15, 40]\nassert findConnectedCells(tree3) == [3, 3, 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.754}, {"few_shot_keywords": "['binary-search-tree', 'tree', 'nodes', 'counting', 'adjacent', 'start', 'digits', 'element', 'value']", "test_keywords": "['nodes', 'column', 'digits', 'tree', 'minimize', 'removals', 'subgraph', 'counting', 'distance', 'binary-search-tree']", "prompt_tokens": 584, "total_tokens": 945, "completion_tokens": 361, "completion": "[Question 2]\n\nYou are given a binary search tree with unique integer values. Write a function to minimize the number of node removals required to make the tree a valid binary search tree. Valid binary search tree means that for any node, all nodes in its right subtree have values greater than the node's value, and all nodes in its left subtree have values less than the node's value.\n\n[/Question 2]\n\n[Code 2]\n\nclass TreeNode:\n    def __init__(self, key):\n        self.left = None\n        self.right = None\n        self.val = key\n\ndef isBST(root: TreeNode, min_val=float('-inf'), max_val=float('inf')):\n    if root is None:\n        return True\n    if not min_val < root.val < max_val:\n        return False\n    return (isBST(root.left, min_val, root.val) and isBST(root.right, root.val, max_val))\n\ndef minNodeRemovals(root: TreeNode) -> int:\n    if isBST(root):\n        return 0\n    return min(minNodeRemovals(root.left), minNodeRemovals(root.right)) + 1\n\n[/Code 2]\n\n[Asserts 2]\n\n# Test cases\nnode1 = TreeNode(5)\nnode2 = TreeNode(3)\nnode3 = TreeNode(8)\nnode4 = TreeNode(2)\nnode5 = TreeNode(4)\nnode6 = TreeNode(7)\nnode7 = TreeNode(9)\nnode1.left = node2\nnode1.right = node3\nnode2.left = node4\nnode2.right = node5\nnode3.left = node6\nnode3.right = node7\nassert minNodeRemovals(node1)==1\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.906}, {"few_shot_keywords": "['root node', 'ancestor', 'Inorder traversal', 'change key', 'sums', 'unique', 'binary tree node', 'empty space', 'construct', 'binary tree']", "test_keywords": "['root node', 'convert', 'binary tree', 'findDistance', 'deque', 'coprime', 'clique', 'binary tree node', 'Inorder traversal', 'construct']", "prompt_tokens": 633, "total_tokens": 1114, "completion_tokens": 481, "completion": "[Question 2]\n\nYou are given the root node of a binary tree and two values a and b. Your task is to write a function to find the distance between nodes with values a and b in the binary tree.\n\nWrite a function to find the distance and return it.\n\n[/Question 2]\n\n[Code 2]\n\nfrom collections import deque\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef findDistance(root, a, b):\n    def findPath(node, target, path):\n        if not node:\n            return False\n        path.append(node.val)\n        if node.val == target:\n            return True\n        if (node.left and findPath(node.left, target, path)) or (node.right and findPath(node.right, target, path)):\n            return True\n        path.pop()\n        return False\n    \n    pathA, pathB = [], []\n    if not findPath(root, a, pathA) or not findPath(root, b, pathB):\n        return -1\n    \n    i = 0\n    while i < len(pathA) and i < len(pathB) and pathA[i] == pathB[i]:\n        i += 1\n    \n    return (len(pathA) - i) + (len(pathB) - i)\n\n[/Code 2]\n\n[Asserts 2]\n\n# Test Cases\n# Example 1\n# Binary Tree:\n#       3\n#      / \\\n#     5   1\n#    / \\ / \\\n#   6  2 0  8\n#     / \\\n#    7   4\nroot = TreeNode(3)\nroot.left = TreeNode(5)\nroot.right = TreeNode(1)\nroot.left.left = TreeNode(6)\nroot.left.right = TreeNode(2)\nroot.right.left = TreeNode(0)\nroot.right.right = TreeNode(8)\nroot.left.right.left = TreeNode(7)\nroot.left.right.right = TreeNode(4)\nassert findDistance(root, 5, 1) == 2\nassert findDistance(root, 6, 4) == 4\nassert findDistance(root, 7, 8) == 3\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.7}, {"few_shot_keywords": "['adjacency matrix', '2D-array', 'matrix', 'fill', 'islands', 'rows', 'list', 'interchange']", "test_keywords": "['target', 'C++', 'matrix', 'list', '2D-array', 'rows', 'interchange', 'permutations']", "prompt_tokens": 638, "total_tokens": 1361, "completion_tokens": 723, "completion": "[Question 2]\n\nYou are given a 2D array representing a matrix of integers. Write a C++ function to find all the unique permutations of the rows of the matrix that sum up to a given target value.\n\nThe function should take the matrix and the target value as input and return a list of all unique permutations of the rows that sum up to the target value.\n\n[/Question 2]\n\n[Code 2]\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nbool isSumEqualToTarget(std::vector<int> &row, int target) {\n    int sum = 0;\n    for (int num : row) {\n        sum += num;\n    }\n    return sum == target;\n}\n\nvoid permuteRows(std::vector<std::vector<int>> &matrix, int target, std::vector<std::vector<int>> &result, std::vector<int> &temp, std::vector<bool> &used) {\n    if (temp.size() == matrix.size()) {\n        if (isSumEqualToTarget(temp, target)) {\n            result.push_back(temp);\n        }\n        return;\n    }\n    for (int i = 0; i < matrix.size(); i++) {\n        if (!used[i]) {\n            used[i] = true;\n            temp.push_back(matrix[i]);\n            permuteRows(matrix, target, result, temp, used);\n            used[i] = false;\n            temp.pop_back();\n        }\n    }\n}\n\nstd::vector<std::vector<int>> findPermutationsWithSum(std::vector<std::vector<int>> &matrix, int target) {\n    std::vector<std::vector<int>> result;\n    std::vector<int> temp;\n    std::vector<bool> used(matrix.size(), false);\n    permuteRows(matrix, target, result, temp, used);\n    return result;\n}\n\nint main() {\n    std::vector<std::vector<int>> matrix = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};\n    int target = 10;\n    std::vector<std::vector<int>> result = findPermutationsWithSum(matrix, target);\n    for (auto row : result) {\n        for (int num : row) {\n            std::cout << num << \" \";\n        }\n        std::cout << std::endl;\n    }\n    return 0;\n}\n```\n\n[/Code 2]\n\n[Asserts 2]\n\n```cpp\n// Assume the given matrix is {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}} and the target is 10\n// Possible permutations with sum 10: \n// 1 2 3 \n// 4 5 6 \n// 7 8 9 \n// 1 2 3 \n// 7 8 9 \n// 4 5 6 \n// 7 8 9 \n// 1 2 3 \n// 4 5 6 \n// 1 2 3 \n// 7 8 9 \n// 4 5 6 \n// 1 2 3 \n// 4 5 6 \n\n// Assert to check the result\nassert(findPermutationsWithSum(matrix, 10) == {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}});\n```\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.707}, {"few_shot_keywords": "['representation', 'level order', 'node', 'binary tree', 'construction', 'tree', 'parent-child relationship', 'constant', 'counter']", "test_keywords": "['level order', 'smallest difference', 'construction', 'binary tree', 'node', 'tree', 'parent-child relationship', 'representation']", "prompt_tokens": 869, "total_tokens": 1523, "completion_tokens": 654, "completion": "[Question 2]\n\nYou are given two binary trees with integer values at each node. Write a function to find the smallest absolute difference between corresponding nodes of the two trees. The two trees are constructed in level order, and the position of a node at the same level in a tree corresponds to the position of the node at the same level in the other tree.\n\nFor example, if the two binary trees are:\nTree 1:\n      1\n     / \\\n    3   2\n   /\n  4\n\nTree 2:\n      6\n     / \\\n    2   8\n   /\n  1\n\nThe smallest absolute difference between corresponding nodes of the two trees is 1, which is the absolute difference between 1 and 2.\n\nWrite a function to construct the binary trees from their level order representations, then find the smallest absolute difference between the corresponding nodes of the two trees.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\nclass TreeNode:\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\ndef constructTree(levelOrder: List[int]) -> TreeNode:\n    if not levelOrder:\n        return None\n    root = TreeNode(levelOrder[0])\n    queue = [root]\n    i = 1\n    while i < len(levelOrder):\n        current = queue.pop(0)\n        if i < len(levelOrder) and levelOrder[i] is not None:\n            current.left = TreeNode(levelOrder[i])\n            queue.append(current.left)\n        i += 1\n        if i < len(levelOrder) and levelOrder[i] is not None:\n            current.right = TreeNode(levelOrder[i])\n            queue.append(current.right)\n        i += 1\n    return root\ndef smallestDifference(root1: TreeNode, root2: TreeNode) -> int:\n    def inorder(node, res):\n        if not node:\n            return\n        inorder(node.left, res)\n        res.append(node.key)\n        inorder(node.right, res)\n    res1, res2 = [], []\n    inorder(root1, res1)\n    inorder(root2, res2)\n    return min(abs(a-b) for a, b in zip(res1, res2))\n\n[/Code 2]\n\n[Asserts 2]\n\ntree1 = constructTree([1, 3, 2, 4])\ntree2 = constructTree([6, 2, 8, 1])\nassert smallestDifference(tree1, tree2) == 1\n\ntree1 = constructTree([1, 2, 3, 4, 5])\ntree2 = constructTree([6, 7, 8, 9, 10])\nassert smallestDifference(tree1, tree2) == 5\n\ntree1 = constructTree([1, 3, 2, 4, 5, 7, 6, 8])\ntree2 = constructTree([6, 2, 8, 1, 9, 3, 7, 10])\nassert smallestDifference(tree1, tree2) == 0\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.738}, {"few_shot_keywords": "['equality', 'denominations', 'diagonal', 'nested loop', 'logic', 'zero', 'comparison', 'scalar', 'matrix', 'filled']", "test_keywords": "['scalar', 'matrix', 'zero', 'character', 'diagonal', 'comparison', 'mark', 'equality']", "prompt_tokens": 676, "total_tokens": 973, "completion_tokens": 297, "completion": "[Question 2]\n\nYou are given a matrix of characters of size N*M. Write a program to check if the given matrix is a scalar matrix, where a scalar matrix is defined as a matrix in which all the non-diagonal elements are zero and all the diagonal elements are equal.\n\nYour task is to write a function that takes a matrix of characters as input and returns True if the matrix is a scalar matrix, and False otherwise.\n\n[/Question 2]\n\n[Code 2]\n\ndef checkScalarMatrix(matrix):\n    diagonal_element = matrix[0][0]\n    \n    for i in range(len(matrix)):\n        for j in range(len(matrix[0])):\n            if i != j and matrix[i][j] != '0':\n                return False\n            if i == j and matrix[i][j] != diagonal_element:\n                return False\n            \n    return True\n\n[/Code 2]\n\n[Asserts 2]\n\nassert checkScalarMatrix([['a', '0', '0'], ['0', 'a', '0'], ['0', '0', 'a']])==True\nassert checkScalarMatrix([['a', 'b', 'c'], ['d', 'e', 'f'], ['g', 'h', 'i']])==False\nassert checkScalarMatrix([['x', '0', '0'], ['0', 'x', '0'], ['0', '0', 'y']])==False\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.858}, {"few_shot_keywords": "['binary', 'inorder', 'construct', 'tree', 'traversal', 'binary tree', 'postorder', 'bitwise', 'smallest']", "test_keywords": "['shortest distance', 'tree', 'vertex cover', 'deque', 'postorder', 'line', 'binary tree', 'traversal', 'construct', 'inorder']", "prompt_tokens": 769, "total_tokens": 1181, "completion_tokens": 412, "completion": "[Question 2]\n\nGiven a binary tree, construct a function to find the shortest distance between two nodes using a deque for traversal.\n\n[/Question 2]\n\n[Code 2]\n\n# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nfrom collections import deque\ndef shortestDistance(root: TreeNode, node1: int, node2: int) -> int:\n    if not root:\n        return 0\n    \n    def findPath(root, target):\n        if not root:\n            return []\n        if root.val == target:\n            return [root.val]\n        left = findPath(root.left, target)\n        right = findPath(root.right, target)\n        if left:\n            return [root.val] + left\n        if right:\n            return [root.val] + right\n        return []\n    \n    path1 = findPath(root, node1)\n    path2 = findPath(root, node2)\n    \n    i = 0\n    while i < len(path1) and i < len(path2) and path1[i] == path2[i]:\n        i += 1\n    \n    return len(path1) + len(path2) - 2*i\n\n[/Code 2]\n\n[Asserts 2]\n\n# Test Case 1\nnode1 = 5\nnode2 = 4\nroot1 = TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(5)), TreeNode(3))\nassert shortestDistance(root1, node1, node2) == 2\n# Test Case 2\nnode3 = 7\nnode4 = 6\nroot2 = TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(5)), TreeNode(3, TreeNode(6), TreeNode(7)))\nassert shortestDistance(root2, node3, node4) == 2\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.713}, {"few_shot_keywords": "['columns', 'rows', 'diagonals', 'square', 'order', 'arrangement', 'sum', 'constant', 'range', 'integers', 'sums', 'magic', 'matrix']", "test_keywords": "['coins', 'integers', 'constant', 'order', 'arrangement', 'columns', 'matrix', 'rows', 'diagonals', 'magic', 'construction', 'square', 'sum']", "prompt_tokens": 745, "total_tokens": 1004, "completion_tokens": 259, "completion": "[Question 2]\n\nYou are given an integer N representing the total amount of money and a list of integers representing the available coins of different denominations. Your task is to find the minimum number of coins required to make up that amount. If it is not possible to make that amount using the given coins, return -1.\n\n[/Question 2]\n\n[Code 2]\n\ndef minCoinsRequired(coins: List[int], amount: int) -> int:\n    dp = [float('inf')] * (amount + 1)\n    dp[0] = 0\n    \n    for coin in coins:\n        for i in range(coin, amount + 1):\n            dp[i] = min(dp[i], dp[i - coin] + 1)\n    \n    return dp[amount] if dp[amount] != float('inf') else -1\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minCoinsRequired([1, 2, 5], 11) == 3\nassert minCoinsRequired([2], 3) == -1\nassert minCoinsRequired([1, 3, 4], 6) == 2\nassert minCoinsRequired([3, 4, 7], 10) == -1", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.706}, {"few_shot_keywords": "['BST', 'matrix', 'adjacent', 'equal', 'combinations', 'columns', 'rows', 'flips', 'surrounded', 'change key', 'operations']", "test_keywords": "['matrix', 'relative complement', 'rows', 'operations', 'equal', 'absolute difference', 'max', 'columns', 'flips', 'children']", "prompt_tokens": 646, "total_tokens": 958, "completion_tokens": 312, "completion": "[Question 2]\n\nYou are given two matrices A and B of the same size N x M. Write a function to find the maximum number of operations (flips) that can be performed on matrix B such that the absolute difference between matrix A and B is equal to the maximum possible value.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef maxFlipsForAbsoluteDifference(A: List[List[int]], B: List[List[int]]) -> int:\n    n = len(A)\n    m = len(A[0])\n    result = 0\n    for i in range(n):\n        for j in range(m):\n            if A[i][j] != B[i][j]:\n                result += 1\n    return result\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maxFlipsForAbsoluteDifference([[1, 0, 1], [0, 1, 0]], [[0, 1, 0], [1, 0, 1]]) == 6\nassert maxFlipsForAbsoluteDifference([[1, 1, 1], [0, 0, 0]], [[0, 0, 0], [1, 1, 1]]) == 6\nassert maxFlipsForAbsoluteDifference([[1, 0, 1], [0, 1, 0]], [[1, 0, 1], [0, 1, 0]]) == 0\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.725}, {"few_shot_keywords": "['indexing', 'sum', 'duplicates', 'frequency', 'matrix', 'counting']", "test_keywords": "['kth', 'counting', 'minimize', 'matrix', 'frequency', 'pairs', 'coordinates', '2D list', 'indexing']", "prompt_tokens": 467, "total_tokens": 735, "completion_tokens": 268, "completion": "[Question 2]\n\nGiven a 2D list representing a matrix of size N x N, find the minimum value of kth most frequent element in the matrix.\n\n[/Question 2]\n\n[Code 2]\n\nfrom collections import Counter\n\ndef kthMostFrequent(matrix: List[List[int]], k: int) -> int:\n    elements = [element for row in matrix for element in row]\n    counts = Counter(elements)\n    sorted_counts = sorted(counts.values(), reverse=True)\n    kth_most_frequent = sorted_counts[k - 1]\n    \n    for key, value in counts.items():\n        if value == kth_most_frequent:\n            return key\n\n[/Code 2]\n\n[Asserts 2]\n\nassert kthMostFrequent([[1, 2, 3], [4, 5, 3], [7, 8, 9]], 1) == 3\nassert kthMostFrequent([[1, 2, 3], [4, 5, 3], [7, 8, 9]], 2) == 5\nassert kthMostFrequent([[1, 2, 3], [4, 5, 3], [7, 8, 9]], 3) == 7", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.883}, {"few_shot_keywords": "['elements', 'diagonal', 'input', 'vertical', 'right subtree', '2D', 'horizontal', 'matrix', 'adjacent', 'product']", "test_keywords": "['shapes', 'vertical', 'elements', '2D', 'diagonal', 'ancestor', 'horizontal', 'adjacent', 'matrix', 'swap', 'product']", "prompt_tokens": 844, "total_tokens": 1139, "completion_tokens": 295, "completion": "[Question 2]\n\nGiven a 2D matrix representing shapes, design a function to swap two adjacent elements (horizontally, vertically, or diagonally) in the matrix. Additionally, the function should return the product of the elements in the new matrix.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\ndef swapAndReturnProduct(matrix: List[List[int]], row1: int, col1: int, row2: int, col2) -> int:\n    rows = len(matrix)\n    cols = len(matrix[0])\n    \n    # Swap the elements\n    matrix[row1][col1], matrix[row2][col2] = matrix[row2][col2], matrix[row1][col1]\n    \n    # Calculate the product of all elements in the new matrix\n    product = 1\n    for i in range(rows):\n        for j in range(cols):\n            product *= matrix[i][j]\n    \n    return product\n\n[/Code 2]\n\n[Asserts 2]\n\nmatrix = [\n    [1, 2, 3],\n    [4, 5, 6],\n    [7, 8, 9]\n]\nassert swapAndReturnProduct(matrix, 0, 0, 0, 1) == 36\nassert swapAndReturnProduct(matrix, 1, 1, 2, 2) == 20160\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.844}, {"few_shot_keywords": "['rotating', 'binary', 'minimum', 'symmetric', 'flips', 'Josephus Circle', '180 degrees', 'matrix', 'number', 'method']", "test_keywords": "['symmetric', 'number', 'minimum', 'column', 'binary', 'conversion', 'rotating', 'frequency', 'flips', 'matrix', '180 degrees']", "prompt_tokens": 575, "total_tokens": 919, "completion_tokens": 344, "completion": "[Question 2]\n\nGiven a binary matrix of size M x N, write a method to find the minimum number of column flips required to make the matrix symmetric with respect to rotating 180 degrees. Also, return the frequency of the most frequent number in the matrix after conversion.\n\n[/Question 2]\n\n[Code 2]\n\ndef minColumnFlipsAndFrequency(matrix):\n    m, n = len(matrix), len(matrix[0])\n    flips = 0\n    frequency = {}\n    \n    for j in range(n):\n        count_one = 0\n        for i in range(m):\n            if matrix[i][j] == 1:\n                count_one += 1\n        if count_one > m - count_one:\n            flips += 1\n        \n        frequency[count_one] = frequency.get(count_one, 0) + 1\n    \n    max_freq = max(frequency.values())\n    \n    return flips, max_freq\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minColumnFlipsAndFrequency([[1, 0, 1],\n                                   [0, 1, 0],\n                                   [1, 0, 1]]) == (1, 4)\nassert minColumnFlipsAndFrequency([[0, 0, 1, 1],\n                                   [1, 1, 0, 0],\n                                   [0, 0, 1, 1]]) == (2, 4)\nassert minColumnFlipsAndFrequency([[1, 0, 1],\n                                   [0, 1, 0],\n                                   [1, 0, 0]]) == (1, 5)\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.706}, {"few_shot_keywords": "['frequency', 'matrix', 'integers', 'inserting', 'even', 'distance', 'odd', 'counting']", "test_keywords": "['integers', 'graph', 'matrix', 'frequency', 'trailing zeroes', 'prime', 'counting', 'even', 'odd']", "prompt_tokens": 534, "total_tokens": 858, "completion_tokens": 324, "completion": "[Question 2]\n\nGiven a graph represented as an adjacency matrix, where each element of the matrix represents the weight of the edge between two vertices, the task is to find the frequency of prime integers with trailing zeroes in the given matrix.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\ndef isPrime(num):\n    if num <= 1:\n        return False\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef countPrimeWithTrailingZeroes(matrix: List[List[int]]):\n    prime_with_zeroes_count = 0\n    for row in matrix:\n        for num in row:\n            if num > 1 and isPrime(num) and num % 10 == 0:\n                prime_with_zeroes_count += 1\n    return prime_with_zeroes_count\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countPrimeWithTrailingZeroes([[2, 3, 5], [7, 10, 11], [13, 17, 20]]) == 1\nassert countPrimeWithTrailingZeroes([[23, 29, 31], [37, 40, 41], [43, 47, 50]]) == 0\nassert countPrimeWithTrailingZeroes([[2, 3, 5], [7, 11, 13], [17, 19, 23]]) == 4\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.81}, {"few_shot_keywords": "['square', 'even', 'matrix', 'iteration', 'pre-order traversal', 'adjacency list', 'comparison', 'boolean', 'nested loop', 'recover', 'logic', 'sum', 'diagonals', 'center', 'right']", "test_keywords": "['nested loop', 'center', 'boolean', 'square', 'sum', 'linked list', 'range', 'matrix', 'iteration', 'diagonals', 'comparison', 'logic']", "prompt_tokens": 640, "total_tokens": 940, "completion_tokens": 300, "completion": "[Question 2]\n\nYou are given a square matrix of integers. Write a function to determine if the sum of elements in each row and each column is the same. Return True if the sums are equal, otherwise return False.\n\n[/Question 2]\n\n[Code 2]\n\ndef equalRowColumnSums(matrix: List[List[int]]) -> bool:\n    n = len(matrix)\n    rowSums = [sum(row) for row in matrix]\n    columnSums = [sum(matrix[i][j] for i in range(n)) for j in range(n)]\n    return all(rowSums[i] == rowSums[i-1] and columnSums[i] == columnSums[i-1] for i in range(1, n))\n\n[/Code 2]\n\n[Asserts 2]\n\nassert equalRowColumnSums([[2, 9, 4], [7, 5, 3], [6, 1, 8]]) == True\nassert equalRowColumnSums([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == False\nassert equalRowColumnSums([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]]) == True\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.736}, {"few_shot_keywords": "['rows', 'unity', 'logic', 'inorder', 'fill', 'positive integer', 'matrix', 'diagonals', 'columns', 'product']", "test_keywords": "['product', 'columns', 'matrix', 'queue', 'unity', 'points', 'gcd', 'square', 'positive integer', 'rows', 'fill', 'colors']", "prompt_tokens": 528, "total_tokens": 874, "completion_tokens": 346, "completion": "[Question 2]\n\nYou are given a positive integer N and a square matrix of size N x N filled with colors represented by positive integers. Write a function to find the GCD of the product of elements in each row and each column of the matrix.\n\n[/Question 2]\n\n[Code 2]\n\nfrom math import gcd\n\ndef findGCD(matrix):\n    row_products = [1] * len(matrix)\n    col_products = [1] * len(matrix[0])\n    \n    for i in range(len(matrix)):\n        for j in range(len(matrix[0])):\n            row_products[i] *= matrix[i][j]\n            col_products[j] *= matrix[i][j]\n    \n    row_gcd = row_products[0]\n    col_gcd = col_products[0]\n    \n    for i in range(1, len(row_products)):\n        row_gcd = gcd(row_gcd, row_products[i])\n    for j in range(1, len(col_products)):\n        col_gcd = gcd(col_gcd, col_products[j])\n    \n    return gcd(row_gcd, col_gcd)\n\n[/Code 2]\n\n[Asserts 2]\n\nassert findGCD([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 1\nassert findGCD([[2, 2, 2], [3, 3, 3], [4, 4, 4]]) == 2\nassert findGCD([[1, 3, 5], [2, 4, 6], [1, 2, 1]]) == 1\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.901}, {"few_shot_keywords": "['binary tree', 'search', 'sorting', '2D array', 'algorithm', 'matrix', 'reverse', 'efficient']", "test_keywords": "['matrix', 'wall', 'search', 'sorting', 'multiplication', 'efficient', 'operators', 'algorithm', 'degrees', 'negate', '2D array']", "prompt_tokens": 663, "total_tokens": 1145, "completion_tokens": 482, "completion": "[Question 2]\n\nYou are given a 2D array representing a matrix consisting of 0s and 1s. The matrix represents a wall where 1s represent solid parts of the wall and 0s represent empty parts. Write an efficient algorithm to determine the minimum number of changes required to negate all the values in the matrix. Negating a value means changing 0 to 1 and 1 to 0. You can only negate a single position at a time and after each negation, the entire matrix should be sorted in non-decreasing order.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\ndef minNegationSteps(matrix: List[List[int]]) -> int:\n    def countOnes(matrix):\n        count = 0\n        for row in matrix:\n            count += row.count(1)\n        return count\n\n    def sortMatrix(matrix):\n        for row in matrix:\n            row.sort()\n        matrix.sort(key=lambda x: x[0])\n\n    if not matrix:\n        return 0\n\n    if not countOnes(matrix):\n        return 0\n\n    steps = 0\n    while countOnes(matrix) > 0:\n        for i in range(len(matrix)):\n            for j in range(len(matrix[0])):\n                matrix[i][j] = 1 - matrix[i][j]\n                sortMatrix(matrix)\n                steps += 1\n                if countOnes(matrix) == 0:\n                    return steps\n                matrix[i][j] = 1 - matrix[i][j]\n\n    return steps\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minNegationSteps([[1, 0, 1], [0, 1, 0], [1, 0, 1]]) == 4\nassert minNegationSteps([[1, 1, 0], [1, 0, 0], [0, 1, 1]]) == 3\nassert minNegationSteps([[1, 0, 1], [0, 1, 0], [1, 1, 1]]) == 3\nassert minNegationSteps([[0, 0, 0], [0, 0, 0], [0, 0, 0]]) == 0\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.773}, {"few_shot_keywords": "['boundary', 'iteration', 'top-left', 'subtree', 'rectangle', 'alternating', 'root', 'determinant', 'matrix', 'nested loop', 'parent-pointer', 'smallest difference', 'pattern']", "test_keywords": "['top-left', 'nested loop', 'rectangle', 'boundary', 'pattern', 'algorithm', 'iteration', 'alternating', 'matrix', 'validation', 'unique']", "prompt_tokens": 868, "total_tokens": 1095, "completion_tokens": 227, "completion": "[Question 2]\n\nWrite a function to validate whether a given matrix is a rectangle or not. The matrix is represented as a list of lists, where each inner list represents a row. The function should return True if the matrix is a rectangle and False otherwise.\n\n[/Question 2]\n\n[Code 2]\n\ndef validateMatrix(matrix):\n    rows = len(matrix)\n    if rows == 0:\n        return False\n    cols = len(matrix[0])\n    for row in matrix:\n        if len(row) != cols:\n            return False\n    return True\n\n[/Code 2]\n\n[Asserts 2]\n\nassert validateMatrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == True\nassert validateMatrix([[1, 2, 3], [4, 5], [6, 7, 8]]) == False\nassert validateMatrix([[1, 2], [3, 4], [5, 6]]) == True\nassert validateMatrix([]) == False\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.911}, {"few_shot_keywords": "['integer', 'nested', 'singly', 'list', 'mark', 'zigzag', 'diagonal', 'matrix', 'traversal']", "test_keywords": "['diagonal', 'matrix', 'zigzag', 'magic', 'integer', 'nested', 'zeros', 'traversal', 'list']", "prompt_tokens": 772, "total_tokens": 1050, "completion_tokens": 278, "completion": "[Question 2]\n\nGiven a matrix of integers, determine if it is a magic square. A magic square is a square matrix where the sum of each row, each column, and each diagonal is the same.\n\n[/Question 2]\n\n[Code 2]\n\ndef isMagicSquare(matrix):\n    n = len(matrix)\n    sum_rows = [sum(row) for row in matrix]\n    sum_cols = [sum(col) for col in zip(*matrix)]\n    sum_diagonals = [sum(matrix[i][i] for i in range(n)), sum(matrix[i][n-i-1] for i in range(n))]\n    all_sums = sum_rows + sum_cols + sum_diagonals\n    return len(set(all_sums)) == 1\n\n[/Code 2]\n\n[Asserts 2]\n\nassert isMagicSquare([[2, 7, 6],[9, 5, 1],[4, 3, 8]]) == True\nassert isMagicSquare([[16, 3, 2, 13], [5, 10, 11, 8], [9, 6, 7, 12], [4, 15, 14, 1]]) == True\nassert isMagicSquare([[1, 1], [1, 1]]) == False\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.919}, {"few_shot_keywords": "['matrix', 'sorting algorithm', 'coprime', 'vertices', 'adjacent elements', 'interchange', 'cost', 'dfs', 'sorting', 'minimum cost']", "test_keywords": "['sorting', 'result', 'sorting algorithm', 'matrix', 'cost', 'minimum cost', 'graph', 'adjacent elements', 'interchange', 'tree construction']", "prompt_tokens": 704, "total_tokens": 1134, "completion_tokens": 430, "completion": "[Question 2]\n\nGiven a list of integers, we want to find the minimum cost to sort the list using a specific sorting algorithm. The cost is defined as the sum of absolute differences between adjacent elements in the sorted list. Additionally, we want to construct a binary tree using the sorted list of integers. Determine the resulting tree.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List, Optional\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef minCostToSortAndGetTree(nums: List[int]) -> (int, Optional[TreeNode]):\n    nums.sort()\n    result = 0\n    n = len(nums)\n    \n    for i in range(n - 1):\n        result += abs(nums[i] - nums[i + 1])\n\n    def constructTree(left, right):\n        if left > right:\n            return None\n        mid = (left + right) // 2\n        node = TreeNode(nums[mid])\n        node.left = constructTree(left, mid - 1)\n        node.right = constructTree(mid + 1, right)\n        return node\n\n    root = constructTree(0, n - 1)\n\n    return result, root\n\n[/Code 2]\n\n[Asserts 2]\n\ncost, tree = minCostToSortAndGetTree([3, 2, 5, 1, 4])\nassert cost == 8\nassert tree.val == 3\nassert tree.left.val == 2\nassert tree.right.val == 5\nassert tree.left.left.val == 1\nassert tree.right.left.val == 4\n\ncost, tree = minCostToSortAndGetTree([7, 4, 10, 1, 5])\nassert cost == 15\nassert tree.val == 5\nassert tree.left.val == 4\nassert tree.right.val == 7\nassert tree.left.left.val == 1\nassert tree.right.right.val == 10\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.809}, {"few_shot_keywords": "['negate', 'search', 'fill', 'matrix', 'row', 'binary', '1s', 'Binary Search Tree', 'iteration', 'maximum']", "test_keywords": "['cost', 'binary', 'threaded binary tree', 'subtree', 'search', 'maximum', 'multiplication', 'row', 'matrix', 'iteration', '1s']", "prompt_tokens": 644, "total_tokens": 979, "completion_tokens": 335, "completion": "[Question 2]\n\nGiven a binary matrix of size m x n, where each element represents the cost of a particular item, find the maximum cost of a submatrix (contiguous subset of the matrix) using iteration.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\ndef maxSubmatrixCost(matrix: List[List[int]]) -> int:\n    m, n = len(matrix), len(matrix[0])\n    maxCost = float('-inf')\n    for i in range(m):\n        for j in range(n):\n            for k in range(i, m):\n                for l in range(j, n):\n                    submatrixCost = 0\n                    for x in range(i, k + 1):\n                        for y in range(j, l + 1):\n                            submatrixCost += matrix[x][y]\n                    maxCost = max(maxCost, submatrixCost)\n    return maxCost\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maxSubmatrixCost([\n  [1, 2, 3],\n  [4, 5, 6],\n  [7, 8, 9]\n]) == 45\nassert maxSubmatrixCost([\n  [1, 2, 3],\n  [4, 5, 6],\n  [7, 8, 9]\n]) == 45\nassert maxSubmatrixCost([\n  [3, 7, 2, 8],\n  [6, 4, 9, 3],\n  [5, 2, 1, 7]\n]) == 42\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.802}, {"few_shot_keywords": "['palindromic', 'minimization', 'rotating', 'matrix', 'DFS', '2D', 'recursion', 'path', 'concatenation', 'distinct', 'operators']", "test_keywords": "['row', 'STL', 'palindromic', 'in-order traversal', 'DFS', 'string', 'recursion', '2D', 'path', 'matrix', 'sorted']", "prompt_tokens": 684, "total_tokens": 1399, "completion_tokens": 715, "completion": "[Question 2]\n\nGiven a 2D matrix of strings, implement a function to find all palindromic paths in the matrix. A palindromic path is a path that forms a palindrome when the strings along the path are concatenated. The path can traverse the matrix in any row and must be sorted in lexicographical order.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef isPalindrome(s: str) -> bool:\n    return s == s[::-1]\n\ndef findPalindromicPaths(matrix: List[List[str]]) -> List[str]:\n    def inOrderTraversal(row, currentPath, result):\n        if row == len(matrix):\n            if isPalindrome(\"\".join(currentPath)):\n                result.append(\"\".join(currentPath))\n            return\n        for string in matrix[row]:\n            inOrderTraversal(row + 1, currentPath + [string], result)\n\n    result = []\n    inOrderTraversal(0, [], result)\n    return sorted(result)\n\n[/Code 2]\n\n[Asserts 2]\n\nassert findPalindromicPaths([[\"a\", \"b\", \"a\"],[\"c\", \"a\", \"b\"],[\"b\", \"a\", \"c\"]])==['abcba', 'abccba', 'acbac', 'acbca', 'babcbab']\nassert findPalindromicPaths([[\"a\", \"aa\", \"aaa\"],[\"b\", \"bb\", \"bbb\"],[\"c\", \"cc\", \"ccc\"]])==['abbacccccbbabb', 'abbbaccccbbab', 'abbbaccccbbaab', 'abbbacccbccbaab', 'abbbacccbaccbbaab', 'abbbacccbcbaccbbaab', 'abbbacccbbbacbbab', 'abbbacccbbacbbbab', 'abbbacccbbbbbacbbab', 'abbbacccbbbabccbbab', 'abbbacccbbbabcccbbab', 'abbbacccbbbabcccbab', 'abbbacccbbbabcccbab', 'abbbacccbbbabcccbbab', 'abbbacccbbbabcccbab', 'abbbacccbbbabcccbbab', 'abbbacccbbbabcccbab', 'abbbacccbbbabcccbab', 'abbbacccbbbabcccbbab', 'abbbacccbbbabcccbab', 'abbbacccbbbabcccbbab', 'abbbacccbbbabcccbab', 'abbbacccbbbabcccbbab', 'abbbacccbbbabcccbab', 'abbbacccbbbabcccbbab', 'abbbacccbbbabcccbab', 'abbbacccbbbabcccbbab', 'abbbacccbbbabcccbab', 'abbbacccbbbabcccbab', 'abbbacccbbbabcccbbab', 'abbbacccbbbabcccbab', 'abbbacccbbbabcccbbab', 'abbbacccbbbabcccbab', 'abbbacccbbbabcccbbab', 'abbbacccbbbabcccbab', 'abbbacccbbbabcccbbab', 'abbbacccbbbabcccbab', 'abbbacccbbbabcccbbab']\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.821}, {"few_shot_keywords": "['construct', 'matrix', 'sum', 'conditional', 'diagonal', 'inside']", "test_keywords": "['spiral', '2D-array', 'sum', 'matrix', 'destination', 'appearance', 'pair', 'diagonal']", "prompt_tokens": 620, "total_tokens": 1120, "completion_tokens": 500, "completion": "[Question 2]\n\nGiven a 2D array representing a matrix of integers, write a function to find the sum of elements that appear in a spiral order from the top-left to the center of the matrix.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\ndef spiralSum(matrix: List[List[int]]) -> int:\n    def in_range(r, c):\n        return 0 <= r < len(matrix) and 0 <= c < len(matrix[0])\n\n    dr = [0, 1, 0, -1]\n    dc = [1, 0, -1, 0]\n\n    total_sum = 0\n    rows, cols = len(matrix), len(matrix[0])\n    r, c = 0, 0\n    for i in range((min(rows, cols) + 1) // 2):\n        total_sum += matrix[r][c]\n        if i == min(rows, cols) // 2:\n            break\n        for j in range(4):\n            while True:\n                new_r, new_c = r + dr[j], c + dc[j]\n                if in_range(new_r, new_c):\n                    r, c = new_r, new_c\n                    total_sum += matrix[r][c]\n                else:\n                    break\n                if (r, c) == (i, i) or (r, c) == (rows - i - 1, cols - i - 1):\n                    break\n\n    return total_sum\n\n[/Code 2]\n\n[Asserts 2]\n\nassert spiralSum([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 25\nassert spiralSum([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]]) == 34\nassert spiralSum([[18, 10, 24, 2, 33], [20, 85, 55, 49, 49], [67, 18, 80, 99, 59], [24, 1, 83, 56, 12], [97, 24, 94, 47, 25]]) == 515\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.867}, {"few_shot_keywords": "['matrix', 'sqrt', 'size', 'nested loop', 'closest pair', 'specific', 'order', 'spiral', 'point', 'direction', 'iteration', 'flips']", "test_keywords": "['dp', 'transformation', 'matrix', 'direction', 'iteration', 'nested loop', 'point', 'order', 'specific', 'spiral']", "prompt_tokens": 698, "total_tokens": 1156, "completion_tokens": 458, "completion": "[Question 2]\n\nGiven a matrix of size M*N, write a dynamic programming (DP) algorithm to find the minimum number of transformations required to transform the matrix into a specific order. The transformation can be performed in a specific direction at each iteration.\n\n[/Question 2]\n\n[Code 2]\n\ndef minTransformations(matrix, m, n, targetOrder):\n    dp = [[0 for _ in range(n)] for _ in range(m)]\n\n    for i in range(m - 1, -1, -1):\n        for j in range(n - 1, -1, -1):\n            if i == m - 1 and j == n - 1:\n                dp[i][j] = 0\n            elif i == m - 1:\n                dp[i][j] = dp[i][j + 1] + 1\n            elif j == n - 1:\n                dp[i][j] = dp[i + 1][j] + 1\n            else:\n                dp[i][j] = min(dp[i + 1][j], dp[i][j + 1]) + 1\n\n    return dp[0][0]\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minTransformations([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3, 3, [(0, 0), (0, 1), (0, 2), (1, 2), (2, 2), (2, 1), (2, 0), (1, 0)])==6\nassert minTransformations([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]], 3, 4, [(0, 0), (0, 1), (1, 1), (1, 0), (2, 0), (2, 1), (2, 2), (2, 3), (1, 3), (0, 3)])==8\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.713}, {"few_shot_keywords": "['index', 'matrix', 'counter', 'diagonals', 'element', 'collections', 'interchange']", "test_keywords": "['element', 'index', 'minimum', 'matrix', 'diagonals', 'interchange', 'internal node', 'in-degree']", "prompt_tokens": 616, "total_tokens": 1007, "completion_tokens": 391, "completion": "[Question 2]\n\nGiven a weighted directed graph represented as an adjacency matrix, write a function to find the internal node with the minimum in-degree. An internal node is a node that is not the source or sink in the graph.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\ndef internalNodeWithMinInDegree(matrix: List[List[int]]) -> int:\n    n = len(matrix)\n    in_degrees = [0] * n\n    for i in range(n):\n        for j in range(n):\n            if matrix[i][j] > 0:\n                in_degrees[j] += 1\n    min_in_degree = float('inf')\n    min_in_degree_node = -1\n    for i in range(1, n-1):\n        if in_degrees[i] < min_in_degree:\n            min_in_degree = in_degrees[i]\n            min_in_degree_node = i\n    return min_in_degree_node\n\n[/Code 2]\n\n[Asserts 2]\n\nassert internalNodeWithMinInDegree([[0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1], [1, 0, 0, 0]]) == 2\nassert internalNodeWithMinInDegree([[0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1], [0, 0, 0, 0]]) == -1\nassert internalNodeWithMinInDegree([[0, 0, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1], [1, 0, 0, 0]]) == 1\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.711}, {"few_shot_keywords": "['iteration', 'math', 'sum', 'empty space', 'diagonal', 'remove', 'alternating', 'nested list', 'kth', 'matrix', 'absolute difference']", "test_keywords": "['math', 'matrix', 'interchange', 'Josephus Circle', 'iteration', 'odd', 'indexing', 'diagonal', 'zeros', 'absolute difference', 'sum', 'nested list']", "prompt_tokens": 524, "total_tokens": 804, "completion_tokens": 280, "completion": "[Question 2]\n\nGiven a square matrix of size N, write a function to interchange the diagonals of the matrix.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef interchangeDiagonals(matrix: List[List[int]]) -> List[List[int]]:\n    n = len(matrix)\n    for i in range(n):\n        if i % 2 == 0:\n            matrix[i][i], matrix[i][n - i - 1] = matrix[i][n - i - 1], matrix[i][i]\n    return matrix\n\n[/Code 2]\n\n[Asserts 2]\n\nassert interchangeDiagonals([[1, 2, 3],[4, 5, 6], [7, 8, 9]]) == [[3, 2, 1], [4, 5, 6], [9, 8, 7]]\nassert interchangeDiagonals([[11, 2, 4],[4, 5, 6], [10, 8, -12]]) == [[4, 2, 11], [4, 5, 6], [-10, 8, -12]]\nassert interchangeDiagonals([[1, 2], [3, 4]]) == [[2, 1], [3, 4]]\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.904}, {"few_shot_keywords": "['direction', 'factors', 'rows', 'strip', 'matrix', 'product', 'order', 'iteration', 'edge', 'spiral', 'count', 'columns', 'complete']", "test_keywords": "['transpose', 'order', 'iteration', 'integer', 'matrix', 'unity', 'rows', 'direction', 'index', 'generation', 'spiral', 'columns', 'count']", "prompt_tokens": 748, "total_tokens": 1036, "completion_tokens": 288, "completion": "[Question 2]\n\nGiven a matrix of integers, write a function to calculate the transpose of the matrix.\n\n[/Question 2]\n\n[Code 2]\n\ndef transposeMatrix(matrix: List[List[int]]) -> List[List[int]]:\n    rows = len(matrix)\n    columns = len(matrix[0])\n    transposed_matrix = [[0 for _ in range(rows)] for _ in range(columns)]\n    \n    for i in range(rows):\n        for j in range(columns):\n            transposed_matrix[j][i] = matrix[i][j]\n    \n    return transposed_matrix\n\n[/Code 2]\n\n[Asserts 2]\n\nassert transposeMatrix([[1, 2, 3], [4, 5, 6]]) == [[1, 4], [2, 5], [3, 6]]\nassert transposeMatrix([[1, 2], [3, 4], [5, 6]]) == [[1, 3, 5], [2, 4, 6]]\nassert transposeMatrix([[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]]) == [[1, 4, 7, 10], [2, 5, 8, 11], [3, 6, 9, 12]]\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.85}, {"few_shot_keywords": "['submatrix', 'minimum', 'operations', 'matrix', 'negate', 'size', 'elements', 'binary', 'formed', 'set']", "test_keywords": "['elements', 'submatrix', 'matrix', 'operations', 'tree structure', 'iterative', 'binary', 'conditional', 'minimum', 'negate', 'set']", "prompt_tokens": 674, "total_tokens": 1130, "completion_tokens": 456, "completion": "[Question 2]\n\nGiven a binary matrix of size N x M, the task is to find the minimum number of operations required to set all elements in a given submatrix to 1. In each operation, it is allowed to negate any submatrix of the matrix. Write an iterative tree structure algorithm to solve this problem.\n\n[/Question 2]\n\n[Code 2]\n\nclass SubMatrixNegation:\n    def __init__(self, matrix):\n        self.matrix = matrix\n        self.m = len(matrix)\n        self.n = len(matrix[0])\n\n    def min_operations(self, start_row, start_col, end_row, end_col):\n        row_range = end_row - start_row + 1\n        col_range = end_col - start_col + 1\n        total_elements = row_range * col_range\n        one_count = 0\n        for i in range(start_row, end_row + 1):\n            one_count += sum(self.matrix[i][start_col:end_col + 1])\n        \n        zero_count = total_elements - one_count\n        return min(one_count, zero_count)\n\n# Example usage\nmatrix = [\n    [1, 0, 0, 1],\n    [0, 1, 1, 0],\n    [1, 0, 0, 1]\n]\nsub_matrix_negation = SubMatrixNegation(matrix)\nprint(sub_matrix_negation.min_operations(0, 0, 2, 3))\n\n[/Code 2]\n\n[Asserts 2]\n\nsub_matrix_negation = SubMatrixNegation([[1, 0, 0, 1], [0, 1, 1, 0], [1, 0, 0, 1]])\nassert sub_matrix_negation.min_operations(0, 0, 2, 3) == 4\nassert sub_matrix_negation.min_operations(0, 0, 1, 2) == 2\nassert sub_matrix_negation.min_operations(1, 1, 2, 2) == 2\nassert sub_matrix_negation.min_operations(0, 1, 2, 3) == 3\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.737}, {"few_shot_keywords": "['euclidean distance', 'transpose', 'skew-symmetric', 'user', 'swap', 'negative', 'program', 'C', 'matrix', 'two pointers', 'input', 'check']", "test_keywords": "['defaultdict', 'C', 'check', '2D grid', 'matrix', 'negative', 'skew-symmetric', 'transpose', 'program', 'input', 'user', 'right']", "prompt_tokens": 755, "total_tokens": 1191, "completion_tokens": 436, "completion": "[Question 2]\n\nWrite a C program that takes user input for a 2D grid matrix and checks if it is a skew-symmetric matrix. The program should utilize the concept of matrix transpose to check whether the input matrix is skew-symmetric (i.e., the transpose of the matrix is the negative of the original matrix).\n\n[/Question 2]\n\n[Code 2]\n\n```c\n#include <stdio.h>\n\nint isSkewSymmetric(int n, int mat[n][n]) {\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (mat[i][j] != -mat[j][i]) {\n                return 0;\n            }\n        }\n    }\n    return 1;\n}\n\nint main() {\n    int n;\n    printf(\"Enter the size of the matrix: \");\n    scanf(\"%d\", &n);\n    \n    int matrix[n][n];\n    printf(\"Enter the elements of the matrix:\\n\");\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            scanf(\"%d\", &matrix[i][j]);\n        }\n    }\n\n    if (isSkewSymmetric(n, matrix)) {\n        printf(\"The matrix is skew symmetric.\\n\");\n    } else {\n        printf(\"The matrix is not skew symmetric.\\n\");\n    }\n    return 0;\n}\n```\n\n[/Code 2]\n\n[Asserts 2]\n\n```c\nint matrix1[3][3] = {{0, -2, 3}, {2, 0, -4}, {-3, 4, 0}};\nint matrix2[3][3] = {{0, 1, 2}, {-1, 0, 3}, {-2, -3, 0}};\nassert(isSkewSymmetric(3, matrix1) == 1);\nassert(isSkewSymmetric(3, matrix2) == 0);\n```\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.92}, {"few_shot_keywords": "['singly linked list', 'real numbers', 'gcd', 'integer', 'sum', 'children', 'matrix', 'singly', 'adjacency list', 'nested loop']", "test_keywords": "['sum', 'nested loop', 'data structure', 'integer', 'gcd', 'repeating', 'duplicates', 'matrix']", "prompt_tokens": 484, "total_tokens": 738, "completion_tokens": 254, "completion": "[Question 2]\n\nGiven a matrix of real numbers, write a function to compute the sum of elements in each column of the matrix and return the result as a list of sums.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\ndef sumOfMatrixColumns(matrix: List[List[float]]) -> List[float]:\n    num_rows = len(matrix)\n    num_cols = len(matrix[0])\n    column_sums = [0] * num_cols\n    for i in range(num_rows):\n        for j in range(num_cols):\n            column_sums[j] += matrix[i][j]\n    return column_sums\n\n[/Code 2]\n\n[Asserts 2]\n\nassert sumOfMatrixColumns([[1.5, 2.5, 3.5], [4.5, 5.5, 6.5], [7.5, 8.5, 9.5]]) == [13.5, 16.5, 19.5]\nassert sumOfMatrixColumns([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == [12, 15, 18]\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.833}, {"few_shot_keywords": "['absolut difference', 'equality', 'matrix', 'operation', 'step', 'recover', 'addition', 'transformation', 'subtraction', 'logic', 'minimum', 'pre-order traversal', 'traversal']", "test_keywords": "['equality', 'matrix', 'transformation', 'insertion', 'absolut difference', 'addition', 'minimum', 'minimization', 'alternating', 'subtraction', 'smallest', 'step', 'adjacency matrix']", "prompt_tokens": 671, "total_tokens": 1125, "completion_tokens": 454, "completion": "[Question 2]\n\nGiven an adjacency matrix representing a graph and a target matrix, the task is to minimize the absolute difference between the target matrix and the adjacency matrix through a series of transformations. A transformation can be either adding or subtracting 1 from any element of the adjacency matrix. Find the smallest number of steps required to achieve equality between the two matrices.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\ndef minimizeAbsoluteDifference(adjacencyMatrix: List[List[int]], targetMatrix: List[List[int]], size: int) -> int:\n    diff = 0\n    for i in range(size):\n        for j in range(size):\n            diff += abs(adjacencyMatrix[i][j] - targetMatrix[i][j])\n    if diff % 2 == 0:\n        return diff // 2\n    else:\n        return -1\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minimizeAbsoluteDifference([[1, 0, 0], [0, 1, 0], [0, 0, 1]], [[1, 0, 0], [0, 1, 0], [0, 0, 1]], 3) == 0\nassert minimizeAbsoluteDifference([[1, 0, 0], [0, 1, 0], [0, 0, 1]], [[0, 1, 0], [1, 0, 0], [0, 0, 1]], 3) == 2\nassert minimizeAbsoluteDifference([[1, 0, 0], [0, 1, 0], [0, 0, 1]], [[0, 0, 0], [0, 0, 0], [0, 0, 0]], 3) == 3\nassert minimizeAbsoluteDifference([[1, 1, 1], [1, 1, 1], [1, 1, 1]], [[0, 0, 0], [0, 0, 0], [0, 0, 0]], 3) == -1\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.76}, {"few_shot_keywords": "['sorting', 'absolute difference', 'transpose', 'size', 'sum', 'math', 'indices', 'integer', 'matrix']", "test_keywords": "['findDistance', 'absolute difference', 'sum', 'size', 'find', 'matrix', 'indices', 'rounded value', 'integer', 'math', 'left subtree']", "prompt_tokens": 472, "total_tokens": 691, "completion_tokens": 219, "completion": "[Question 2]\n\nGiven a matrix M of size N x N, where M[i][j] represents the rounded value of the absolute difference between the indices i and j. Write a function to find the sum of all the elements in the matrix.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef sumOfRoundedMatrix(M: List[List[int]]) -> int:\n    N = len(M)\n    total_sum = 0\n    for i in range(N):\n        for j in range(N):\n            total_sum += M[i][j]\n    return total_sum\n\n[/Code 2]\n\n[Asserts 2]\n\nassert sumOfRoundedMatrix([[0, 1, 2], [1, 0, 1], [2, 1, 0]]) == 8\nassert sumOfRoundedMatrix([[0, 2, 4], [2, 0, 2], [4, 2, 0]]) == 18\nassert sumOfRoundedMatrix([[0]]) == 0", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.743}, {"few_shot_keywords": "['connected cells', 'matrix', 'change key', 'complete', 'perimeter', 'adjacent elements', 'grid', 'palindromic', 'tree construction', 'binary', 'shapes']", "test_keywords": "['perimeter', 'clock', 'matrix', 'C', 'grid', 'shapes', 'connected cells', 'binary tree', 'binary', 'undirected']", "prompt_tokens": 660, "total_tokens": 1283, "completion_tokens": 623, "completion": "[Question 2]\n\nGiven a binary matrix representing a digital clock where 1s represent the segments of the digits, write a function to calculate the perimeter of the displayed digit.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef clockPerimeter(matrix: List[List[int]]) -> int:\n    digit_segments = {\n        0: [1, 1, 1, 0, 1, 1, 1],\n        1: [0, 0, 1, 0, 0, 1, 0],\n        2: [1, 0, 1, 1, 1, 0, 1],\n        3: [1, 0, 1, 1, 0, 1, 1],\n        4: [0, 1, 1, 1, 0, 1, 0],\n        5: [1, 1, 0, 1, 0, 1, 1],\n        6: [1, 1, 0, 1, 1, 1, 1],\n        7: [1, 0, 1, 0, 0, 1, 0],\n        8: [1, 1, 1, 1, 1, 1, 1],\n        9: [1, 1, 1, 1, 0, 1, 1]\n    }\n    \n    def calculate_perimeter(segments):\n        perimeter = 0\n        for i in range(len(segments) - 1):\n            if segments[i] != segments[i + 1]:\n                perimeter += 1\n        if segments[0] != segments[-1]:\n            perimeter += 1\n        return perimeter\n    \n    digit = [-1] * 7\n    for i in range(10):\n        if matrix == [matrix[j][i] for j in range(7)]:\n            digit[i] = 1\n    \n    if -1 in digit:\n        return -1\n    return calculate_perimeter(digit)\n\n[/Code 2]\n\n[Asserts 2]\n\nassert clockPerimeter([[0, 1, 0],\n                       [1, 1, 1],\n                       [1, 0, 1],\n                       [1, 1, 1],\n                       [1, 0, 1],\n                       [1, 1, 1],\n                       [0, 1, 0]]) == 20\nassert clockPerimeter([[0, 1, 0],\n                       [1, 1, 1],\n                       [1, 0, 1],\n                       [1, 1, 1],\n                       [0, 0, 1],\n                       [0, 0, 1],\n                       [0, 0, 1]]) == -1\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.916}, {"few_shot_keywords": "['right', 'node', 'digit', 'construct', 'equality', 'left', 'string', 'parent', 'representation', 'binary tree', 'stack', 'extra space', 'consecutive', 'previous']", "test_keywords": "['absolute differences', 'parent', 'string', 'right', 'node', 'binary tree', 'digit', 'left', 'square', 'representation', 'stack', 'construct']", "prompt_tokens": 824, "total_tokens": 1249, "completion_tokens": 425, "completion": "[Question 2]\n\nYou are given a binary tree where each node contains a digit. Write a function to check if there exists a root-to-leaf path such that the absolute differences between consecutive nodes are all perfect squares.\n\nWrite a function `isSquarePathExists(root: TreeNode) -> bool` that takes the root of the binary tree as input and returns True if there exists a root-to-leaf path satisfying the given condition, otherwise False.\n\n[/Question 2]\n\n[Code 2]\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef isSquarePathExists(root: TreeNode) -> bool:\n    def isPerfectSquare(num):\n        return int(num ** 0.5) ** 2 == num\n    \n    def isSquarePathExistsHelper(node, prev):\n        if not node:\n            return False\n        curr_val = node.val\n        if prev is not None and isPerfectSquare(abs(curr_val - prev)):\n            if not node.left and not node.right:\n                return True\n        return isSquarePathExistsHelper(node.left, curr_val) or isSquarePathExistsHelper(node.right, curr_val)\n    \n    return isSquarePathExistsHelper(root, None)\n\n[/Code 2]\n\n[Asserts 2]\n\n# Example 1\n# Tree:\n#     4\n#    / \\\n#   9   2\n#      / \\\n#     3   5\nroot1 = TreeNode(4, TreeNode(9), TreeNode(2, TreeNode(3), TreeNode(5)))\nassert isSquarePathExists(root1) == True\n\n# Example 2\n# Tree:\n#     3\n#    / \\\n#   8   5\n#  / \\\n# 4   2\nroot2 = TreeNode(3, TreeNode(8, TreeNode(4), TreeNode(2)), TreeNode(5))\nassert isSquarePathExists(root2) == False\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.8}, {"few_shot_keywords": "['elements', 'replace', 'sums', 'matrix', 'sqrt', 'ends', 'rows', 'spiral', 'difference', 'maximum', 'operation', 'binary tree node', 'queue']", "test_keywords": "['difference', 'operation', 'rows', 'replace', 'sorted', 'clique', 'maximum', 'elements', 'sums', 'matrix', 'prime']", "prompt_tokens": 768, "total_tokens": 1287, "completion_tokens": 519, "completion": "[Question 2]\n\nYou are given a square matrix of size N * N. Your task is to replace each element in the matrix with the absolute difference between the sum of elements in its row and the sum of elements in its column. After performing this operation, find the maximum element in the matrix.\n\nWrite a function `maxAbsoluteDifference(matrix: List[List[int]]) -> int` to calculate the maximum element in the matrix after the operation.\n\nNote:\n- The matrix is of size N * N (1 \u2264 N \u2264 100).\n- The elements in the matrix are integers.\n\nExample:\n```\nmatrix = [\n    [1, 2, 3],\n    [4, 5, 6],\n    [7, 8, 9]\n]\n\nmaxAbsoluteDifference(matrix) => 6\n\nExplanation: After the operation, the matrix becomes:\n[\n    [6, 3, 0],\n    [3, 0, 3],\n    [0, 3, 6]\n]\nThe maximum element in the matrix is 6.\n```\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\ndef maxAbsoluteDifference(matrix: List[List[int]]) -> int:\n    n = len(matrix)\n    row_sums = [sum(row) for row in matrix]\n    col_sums = [sum(matrix[i][j] for i in range(n)) for j in range(n)]\n    max_diff = 0\n    for i in range(n):\n        for j in range(n):\n            diff = abs(row_sums[i] - col_sums[j])\n            matrix[i][j] = diff\n            max_diff = max(max_diff, diff)\n    return max_diff\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maxAbsoluteDifference([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 6\nassert maxAbsoluteDifference([[1,2,3],[4,5,6],[7,8,9],[10,11,12]]) == 12\nassert maxAbsoluteDifference([[1,2,3],[4,5,6],[7,8,9],[10,11,12],[13,14,15]]) == 18\nassert maxAbsoluteDifference([[1,2,3],[4,5,6],[7,8,9],[10,11,12],[13,14,15],[16,17,18]]) == 24\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.782}, {"few_shot_keywords": "['leaf', 'binary', 'directions', 'sum', 'interior', 'coverage', 'recursion', 'matrix']", "test_keywords": "['absolut difference', 'matrix', 'rows', 'dictionary', 'binary', 'directions', 'sum', 'coverage']", "prompt_tokens": 724, "total_tokens": 1203, "completion_tokens": 479, "completion": "[Question 2]\n\nYou are given a binary matrix of size N x M. Each row in the matrix represents a binary number. Find the absolute difference in the total coverage of '0's between any two distinct rows in the matrix.\n\nWrite a function to find the absolute difference in the total coverage of '0's between any two distinct rows in the given matrix.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\ndef absoluteDifferenceInCoverage(matrix: List[List[int]]) -> int:\n    rows, cols = len(matrix), len(matrix[0])\n    coverage_dict = {}\n    \n    for i in range(rows):\n        total_coverage = 0\n        for j in range(cols):\n            if matrix[i][j] == 0:\n                coverage = 0\n                for x in range(-1, 2):\n                    for y in range(-1, 2):\n                        if 0 <= j + y < cols and (x != 0 or y != 0) and matrix[i][j + y] == 1:\n                            coverage += 1\n                total_coverage += coverage\n        coverage_dict[i] = total_coverage\n    \n    result = 0\n    for i in range(rows):\n        for j in range(i+1, rows):\n            result = max(result, abs(coverage_dict[i] - coverage_dict[j]))\n    return result\n\n[/Code 2]\n\n[Asserts 2]\n\nassert absoluteDifferenceInCoverage([[1, 0, 1, 0],\n                                     [0, 1, 1, 1],\n                                     [1, 1, 0, 1],\n                                     [0, 0, 1, 0]]) == 3\nassert absoluteDifferenceInCoverage([[0, 0, 0, 0],\n                                     [0, 1, 1, 0],\n                                     [1, 0, 0, 1],\n                                     [1, 1, 1, 1]]) == 4\nassert absoluteDifferenceInCoverage([[1, 1, 1, 1],\n                                     [1, 0, 1, 1],\n                                     [0, 1, 0, 0],\n                                     [1, 1, 1, 1]]) == 2\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.928}, {"few_shot_keywords": "['minimize', 'subsquare', 'spiral order', 'diagonals', 'nested list', 'index', 'binary search', 'element', 'iteration', 'matrix']", "test_keywords": "['nested list', 'iteration', 'vertex cover', 'spiral order', 'element', 'index', 'matrix', 'digits']", "prompt_tokens": 784, "total_tokens": 1073, "completion_tokens": 289, "completion": "[Question 2]\n\nWrite a function to find the minimum element in a given nested list of digits, considering only the elements at the specified indices.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef findMinNested(digits: List[List[int]], indices: List[int]) -> int:\n    min_val = float('inf')\n    for lst in digits:\n        for idx in indices:\n            min_val = min(min_val, lst[idx])\n    return min_val\n\n[/Code 2]\n\n[Asserts 2]\n\nassert findMinNested([[1, 2, 3], [4, 5, 6], [7, 8, 9]], [0, 2]) == 3\nassert findMinNested([[9, 8, 7], [6, 5, 4], [3, 2, 1]], [1, 2]) == 1\nassert findMinNested([[11, 23, 35], [42, 58, 63], [74, 89, 91]], [0, 1]) == 23\nassert findMinNested([[1, 3, 5, 7], [2, 4, 6, 8], [9, 10, 11, 12]], [1, 3]) == 7\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.9}, {"few_shot_keywords": "['generate', 'closest', 'counting', 'iteration', 'zeros', 'nested list', '2D array', 'sorted', 'matrix']", "test_keywords": "['STL', 'nested list', 'sorted', 'zeros', 'point', 'structure', 'iteration', 'increment', '2D array', 'counting', 'matrix', 'binary']", "prompt_tokens": 628, "total_tokens": 930, "completion_tokens": 302, "completion": "[Question 2]\n\nYou are given a 2D array representing a grid of points. Each point has an x and y coordinate. Write a function to count the number of zeros in the grid and return the count.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\ndef countZeros(grid: List[List[int]]) -> int:\n    count = 0\n    for row in grid:\n        for point in row:\n            if point == 0:\n                count += 1\n    return count\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countZeros([[0, 1, 0, 0],\n                   [0, 0, 1, 1],\n                   [0, 1, 0, 1],\n                   [1, 1, 1, 1]]) == 6\nassert countZeros([[0, 0, 0, 1],\n                   [0, 0, 1, 1],\n                   [0, 1, 1, 0],\n                   [1, 1, 1, 1]]) == 7\nassert countZeros([[0, 0, 0, 0],\n                   [0, 0, 0, 0],\n                   [0, 0, 0, 0],\n                   [0, 0, 0, 0]]) == 16\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.948}, {"few_shot_keywords": "['equality', 'linked list', 'subtree', 'filled', 'node', 'sequence', 'left', 'representation', 'binary tree', 'insertion', 'distribution', 'complete', 'minimum cost']", "test_keywords": "['connected cells', 'complete', 'filled', 'linked list', 'node', 'representation', 'insertion', 'left', 'islands', 'binary tree', 'conversion']", "prompt_tokens": 644, "total_tokens": 1175, "completion_tokens": 531, "completion": "[Question 2]\n\nYou are given a 2D matrix representing a grid of cells, each containing a 0 or a 1. A connected component of 1's in the grid is a set of 1's that are all connected. Write a function to find the size of the largest connected component in the grid and represent it using a linked list data structure.\n\n[/Question 2]\n\n[Code 2]\n\nclass Node:\n    def __init__(self, value):\n        self.value = value\n        self.next = None\n\nclass Grid:\n    def __init__(self, matrix):\n        self.matrix = matrix\n        self.visited = [[False for _ in range(len(matrix[0]))] for _ in range(len(matrix))]\n        self.max_component_size = 0\n\n    def is_valid(self, i, j):\n        rows = len(self.matrix)\n        cols = len(self.matrix[0])\n        return 0 <= i < rows and 0 <= j < cols\n\n    def dfs(self, i, j, component_size):\n        if self.is_valid(i, j) and self.matrix[i][j] == 1 and not self.visited[i][j]:\n            self.visited[i][j] = True\n            component_size[0] += 1\n            self.dfs(i+1, j, component_size)\n            self.dfs(i-1, j, component_size)\n            self.dfs(i, j+1, component_size)\n            self.dfs(i, j-1, component_size)\n\n    def find_largest_connected_component(self):\n        rows = len(self.matrix)\n        cols = len(self.matrix[0])\n        for i in range(rows):\n            for j in range(cols):\n                if self.matrix[i][j] == 1 and not self.visited[i][j]:\n                    component_size = [0]\n                    self.dfs(i, j, component_size)\n                    self.max_component_size = max(self.max_component_size, component_size[0])\n        return self.max_component_size\n\ngrid = Grid([\n    [1, 1, 0, 0, 0],\n    [0, 1, 1, 0, 1],\n    [0, 0, 1, 0, 1],\n    [1, 0, 0, 0, 1],\n    [0, 1, 0, 1, 1]\n])\n\n[/Code 2]\n\n[Asserts 2]\n\nassert grid.find_largest_connected_component() == 8\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.83}, {"few_shot_keywords": "['factors', 'maximum', 'binary', 'formed', 'power', 'size', 'matrix']", "test_keywords": "['inorder traversal', 'maximum', 'absolute difference', 'sum of digits', 'formed', 'longest', 'size', 'matrix', 'binary']", "prompt_tokens": 1169, "total_tokens": 1505, "completion_tokens": 336, "completion": "[Question 2]\n\nGiven a binary search tree, write a function to find the maximum absolute difference between the values of any two nodes in its inorder traversal.\n\n[/Question 2]\n\n[Code 2]\n\n# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef maxAncestorDiff(root: TreeNode) -> int:\n\n    def dfs(node, cur_max, cur_min):\n        if not node:\n            return cur_max - cur_min\n        cur_max = max(cur_max, node.val)\n        cur_min = min(cur_min, node.val)\n        left = dfs(node.left, cur_max, cur_min)\n        right = dfs(node.right, cur_max, cur_min)\n        return max(left, right)\n    \n    return dfs(root, root.val, root.val)\n\n[/Code 2]\n\n[Asserts 2]\n\n# Constructing a sample binary tree\nroot = TreeNode(4)\nroot.left = TreeNode(2)\nroot.right = TreeNode(6)\nroot.left.left = TreeNode(1)\nroot.left.right = TreeNode(3)\n\nassert maxAncestorDiff(root) == 3\n\n# Constructing another sample binary tree\nroot = TreeNode(8)\nroot.left = TreeNode(3)\nroot.right = TreeNode(10)\nroot.left.left = TreeNode(1)\nroot.left.right = TreeNode(6)\nroot.left.right.left = TreeNode(4)\nroot.left.right.right = TreeNode(7)\n\nassert maxAncestorDiff(root) == 7\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.819}, {"few_shot_keywords": "['index', 'tree traversal', 'previous', 'square', 'zigzag', 'vertex cover', 'matrix', 'triplets', '2D list', 'order', 'product', 'traversal', 'element']", "test_keywords": "['opened', 'perimeter', 'element', 'max', 'bipartite', 'index', 'minimization', 'traversal', 'matrix', 'previous', '2D list', 'square', 'zigzag', 'order']", "prompt_tokens": 1020, "total_tokens": 1492, "completion_tokens": 472, "completion": "[Question 2]\n\nYou are given a 2D list representing a square matrix where each element either represents an opened or closed gate. Your task is to find the maximum perimeter of the area formed by opened gates. You can treat the whole matrix as a bipartite graph where opened gates are the vertices, and the adjacent gates form the edges. The edges between the opened gates contribute to the perimeter of the area.\n\nWrite a function named `maxGatePerimeter` which takes a 2D list representing the matrix and returns the maximum perimeter of the area formed by opened gates.\n\n[/Question 2]\n\n[Code 2]\n\ndef maxGatePerimeter(matrix: List[List[int]]) -> int:\n    n = len(matrix)\n    max_perimeter = 0\n    for i in range(n):\n        for j in range(n):\n            if matrix[i][j] == 1:\n                perimeter = 4\n                if i > 0 and matrix[i-1][j] == 1:\n                    perimeter -= 1\n                if i < n-1 and matrix[i+1][j] == 1:\n                    perimeter -= 1\n                if j > 0 and matrix[i][j-1] == 1:\n                    perimeter -= 1\n                if j < n-1 and matrix[i][j+1] == 1:\n                    perimeter -= 1\n                max_perimeter = max(max_perimeter, perimeter)\n    return max_perimeter\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maxGatePerimeter([[0, 1, 0, 0],\n                         [1, 1, 1, 0],\n                         [0, 1, 0, 0],\n                         [1, 1, 0, 0]]) == 12\n\nassert maxGatePerimeter([[1, 0, 0, 0],\n                         [0, 0, 0, 0],\n                         [0, 0, 0, 1],\n                         [0, 0, 0, 1]]) == 8\n\nassert maxGatePerimeter([[1, 1, 1],\n                         [1, 0, 1],\n                         [1, 1, 1]]) == 8\n", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.942}, {"few_shot_keywords": "['clockwise', '2D', 'list', 'denominations', 'array', 'top-left', 'generate', 'nested', 'matrix', 'strip', 'odd', 'direction', 'spiral']", "test_keywords": "['spiral', 'dynamic programming', 'direction', 'generate', 'array', 'clockwise', 'kth', 'nested', '2D', 'list', 'swaps', 'top-left', 'matrix', 'negative']", "prompt_tokens": 814, "total_tokens": 1193, "completion_tokens": 379, "completion": "[Question 2]\n\nYou are given a positive integer k and a 2D array matrix of size n x n containing both positive and negative integers. Write a dynamic programming algorithm to generate the kth smallest element in the matrix when the elements of the matrix are arranged in a spiral pattern in a clockwise direction starting from the top-left corner.\n\n[/Question 2]\n\n[Code 2]\n\ndef kthSmallest(matrix: List[List[int]], k: int) -> int:\n    def countLessOrEqual(mid: int) -> int:\n        count, row, col = 0, n - 1, 0\n        while row >= 0 and col < n:\n            if matrix[row][col] <= mid:\n                count += row + 1\n                col += 1\n            else:\n                row -= 1\n        return count\n    \n    n = len(matrix)\n    left, right = matrix[0][0], matrix[n - 1][n - 1]\n    while left < right:\n        mid = left + (right - left) // 2\n        count = countLessOrEqual(mid)\n        if count < k:\n            left = mid + 1\n        else:\n            right = mid\n    return left\n\n[/Code 2]\n\n[Asserts 2]\n\nassert kthSmallest([[1, 3, 5], [6, 7, 12], [11, 14, 14]], 3) == 5\nassert kthSmallest([[-5, -4, -3], [-2, -1, 0], [1, 2, 3]], 5) == -2\nassert kthSmallest([[1, 2], [1, 3]], 3) == 2\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.859}, {"few_shot_keywords": "['recursion', 'node', 'doubly linked list', 'binary tree', 'pointer', 'linked structure', 'in-order traversal', 'order', 'filled', 'data structure', 'clockwise', 'out-degree', '2D']", "test_keywords": "['binary tree', 'inside', 'swap', 'doubly linked list', 'recursion', 'occurrences', 'linked structure', 'node', 'pointer', 'data structure', 'insert', 'in-order traversal']", "prompt_tokens": 694, "total_tokens": 1037, "completion_tokens": 343, "completion": "[Question 2]\n\nWrite a program to swap occurrences of two given nodes in a binary tree. The swapping should be done in such a way that the in-order traversal of the binary tree remains unchanged after the swap.\n\n[/Question 2]\n\n[Code 2]\n\nclass Node:\n    def __init__(self, data: int):\n        self.data = data\n        self.left = None\n        self.right = None\n\n\ndef swapNodes(root: Node, node1: Node, node2: Node) -> None:\n    def inorder(node):\n        if node is None:\n            return\n        inorder(node.left)\n        if node == node1:\n            node1.data, node2.data = node2.data, node1.data\n        elif node == node2:\n            pass  # Already swapped\n        inorder(node.right)\n\n    inorder(root)\n\n[/Code 2]\n\n[Asserts 2]\n\n# Create a Binary Tree\nroot = Node(10)\nroot.left = Node(12)\nroot.right = Node(15)\nroot.left.left = Node(25)\nroot.left.right = Node(30)\nroot.right.left = Node(36)\n# Swap occurrences of two nodes\nnode1 = root.left\nnode2 = root.right.left\nswapNodes(root, node1, node2)\n# Verify the In-order traversal remains unchanged\nresult = []\ndef inorder_traversal(node):\n    if node is None:\n        return\n    inorder_traversal(node.left)\n    result.append(node.data)\n    inorder_traversal(node.right)\n\ninorder_traversal(root)\nassert result == [25, 12, 30, 10, 36, 15]\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.816}, {"few_shot_keywords": "['row', 'boolean', 'search', 'value', 'matrix', 'change', 'position', 'column', 'text', 'iteration']", "test_keywords": "['pointers', 'boolean', 'dfs', 'row', 'column', 'position', 'value', 'matrix', 'search', 'iteration', 'nested list']", "prompt_tokens": 612, "total_tokens": 998, "completion_tokens": 386, "completion": "[Question 2]\n\nGiven a boolean matrix mat of size N x N, write a program to implement a Depth First Search (DFS) algorithm to search for a specific value in the matrix and return its position as (row, column) if found, otherwise return (-1, -1).\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List, Tuple\n\ndef dfsSearch(mat: List[List[bool]], value: bool) -> Tuple[int, int]:\n    def dfs(row, col):\n        if row < 0 or col < 0 or row >= len(mat) or col >= len(mat[0]) or visited[row][col] or mat[row][col] != value:\n            return\n        visited[row][col] = True\n        if mat[row][col] == value:\n            return row, col\n        dfs(row+1, col)\n        dfs(row-1, col)\n        dfs(row, col+1)\n        dfs(row, col-1)\n        \n    visited = [[False for _ in range(len(mat[0]))] for _ in range(len(mat))]\n    for i in range(len(mat)):\n        for j in range(len(mat[0])):\n            if not visited[i][j]:\n                result = dfs(i, j)\n                if result:\n                    return result\n    return (-1, -1)\n\n[/Code 2]\n\n[Asserts 2]\n\nassert dfsSearch([[True, False, True], [False, False, True], [True, True, False]], True) == (0, 0)\nassert dfsSearch([[True, False, True], [False, False, True], [True, True, False]], False) == (1, 1)\nassert dfsSearch([[True, False, True], [False, False, True], [True, True, False]], False) == (-1, -1)", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.792}, {"few_shot_keywords": "['tuple', 'set', 'list', 'selection', 'binary', 'matrix', 'rows', 'unique', 'appearance', 'order', 'coverage']", "test_keywords": "['binary', 'order', 'appearance', 'matrix', 'cycle', 'tuple', 'set', 'rows', 'list', 'unique', 'conditional']", "prompt_tokens": 603, "total_tokens": 1049, "completion_tokens": 446, "completion": "[Question 2]\n\nGiven a binary matrix, write a function to check if there exists a cycle (of length at least 4) in the matrix such that all the elements of the cycle are unique and appear in the same order as they do in the matrix.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef hasUniqueCycle(matrix: List[List[int]]) -> bool:\n    def dfs(x, y, start_x, start_y, cycle_length, visited):\n        if x < 0 or y < 0 or x >= len(matrix) or y >= len(matrix[0]) or (x, y) in visited or (x, y) != (start_x, start_y) and matrix[x][y] != matrix[start_x][start_y]:\n            return False\n        if (x, y) == (start_x, start_y) and cycle_length >= 4:\n            return True\n        visited.add((x, y))\n        for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\n            if dfs(x + dx, y + dy, start_x, start_y, cycle_length + 1, visited):\n                return True\n        visited.remove((x, y))\n        return False\n\n    for i in range(len(matrix)):\n        for j in range(len(matrix[0])):\n            if dfs(i, j, i, j, 1, set()):\n                return True\n    return False\n\n[/Code 2]\n\n[Asserts 2]\n\nassert hasUniqueCycle([[1, 0, 0, 1],\n                       [1, 0, 1, 0],\n                       [0, 1, 0, 1],\n                       [1, 0, 1, 0]]) == True\nassert hasUniqueCycle([[1, 0, 0, 1],\n                       [1, 0, 1, 0],\n                       [0, 1, 0, 1],\n                       [1, 0, 0, 1]]) == False\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.845}, {"few_shot_keywords": "['columns', 'swap', 'starting', 'sorted', 'binary', 'histogram', 'destination', 'matrix', 'stack', 'area', 'largest', 'rectangle']", "test_keywords": "['equality', 'histogram', 'area', 'largest', 'matrix', 'columns', 'swap', 'rectangle', 'binary', 'stack']", "prompt_tokens": 892, "total_tokens": 1366, "completion_tokens": 474, "completion": "[Question 2]\n\nYou are given a binary matrix of size m x n, where each element is either 0 or 1. Write a function to determine if the matrix is sorted in non-decreasing order when considering each row or column. You are also allowed to swap the columns of the matrix.\n\n[/Question 2]\n\n[Code 2]\n\ndef isSorted(matrix: List[List[int]]) -> bool:\n    def isNonDecreasing(arr):\n        return all(arr[i] <= arr[i + 1] for i in range(len(arr) - 1))\n\n    # Check rows\n    for row in matrix:\n        if not isNonDecreasing(row):\n            return False\n\n    # Check columns\n    for col in range(len(matrix[0])):\n        column = [matrix[row][col] for row in range(len(matrix))]\n        if not isNonDecreasing(column):\n            return False\n\n    return True\n\n[/Code 2]\n\n[Asserts 2]\n\nassert isSorted([[1, 0, 1, 0], [1, 0, 1, 1], [1, 1, 1, 1], [1, 0, 0, 1]])\nassert isSorted([[1, 0, 1, 0], [1, 0, 1, 1], [1, 1, 1, 1], [1, 0, 0, 1], [1, 1, 1, 0]])\nassert not isSorted([[1, 0, 1, 0], [1, 0, 0, 1], [1, 1, 1, 1], [1, 0, 1, 1]])\nassert not isSorted([[1, 0, 1, 1], [1, 0, 1, 1], [1, 1, 0, 1], [1, 0, 0, 1]])\nassert isSorted([[1, 1, 1, 1], [1, 1, 1, 1], [1, 0, 0, 1], [1, 1, 1, 1]])\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.849}, {"few_shot_keywords": "['row', 'indexing', 'cell', 'nested loop', 'sum', 'counting', 'column', 'path', 'matrix', 'perimeter', '2D array']", "test_keywords": "['2D array', 'safe', 'row', 'indexing', '180 degrees', 'nested loop', 'surrounded', 'column', 'cell', 'sum', 'matrix']", "prompt_tokens": 773, "total_tokens": 1303, "completion_tokens": 530, "completion": "[Question 2]\n\nGiven a 2D matrix representing a game board where each cell can be either 'X' or 'O', write a function to determine if all the 'O's in the matrix are completely surrounded by 'X's. A 'O' is considered to be surrounded by 'X' if there are 'X's on all four sides of it, including diagonals.\n\nImplement a function `isSurrounded(board)` that takes the game board as input and returns True if all 'O's are surrounded by 'X's, and False otherwise.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\ndef isSurrounded(board: List[List[str]]) -> bool:\n    def dfs(i, j):\n        if i < 0 or j < 0 or i >= len(board) or j >= len(board[0]) or board[i][j] != 'O':\n            return\n        board[i][j] = 'S'\n        dfs(i+1, j)\n        dfs(i-1, j)\n        dfs(i, j+1)\n        dfs(i, j-1)\n\n    for i in range(len(board)):\n        for j in range(len(board[0])):\n            if (i == 0 or j == 0 or i == len(board)-1 or j == len(board[0])-1) and board[i][j] == 'O':\n                dfs(i, j)\n\n    for i in range(len(board)):\n        for j in range(len(board[0])):\n            if board[i][j] == 'O':\n                return False\n\n    return True\n\n[/Code 2]\n\n[Asserts 2]\n\nassert isSurrounded([\n    ['X', 'X', 'X', 'X'],\n    ['X', 'O', 'O', 'X'],\n    ['X', 'X', 'O', 'X'],\n    ['X', 'O', 'X', 'X']\n]) == True\n\nassert isSurrounded([\n    ['X', 'X', 'X', 'X'],\n    ['X', 'O', 'O', 'X'],\n    ['X', 'X', 'O', 'X'],\n    ['X', 'X', 'X', 'X']\n]) == False\n\nassert isSurrounded([\n    ['X', 'X', 'X', 'X'],\n    ['X', 'O', 'O', 'X'],\n    ['X', 'X', 'O', 'X'],\n    ['X', 'O', 'O', 'X']\n]) == False\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.945}, {"few_shot_keywords": "['binary', '2D', 'grid', 'recursion', 'conversion', 'islands', 'row', 'tuple', 'interior', 'set', 'distinct', 'DFS']", "test_keywords": "['distinct', 'operators', 'DFS', 'islands', '2D', 'binary', 'power', 'grid', 'tuple', 'interior', 'set', 'row']", "prompt_tokens": 750, "total_tokens": 1277, "completion_tokens": 527, "completion": "[Question 2]\n\nYou are given a 2D binary grid 'grid' representing a map of '1's (land) and '0's (water). You need to find the number of distinct islands where every island is a row. An island is considered as a row if no 0 exists in the island's interior. Additionally, each island is to be represented as a tuple of its length and the sum of powers of distinct indices where '1' appears.\n\n[/Question 2]\n\n[Code 2]\n\ndef numDistinctIslands(grid: List[List[int]]) -> int:\n    m, n = len(grid), len(grid[0])\n    islands = set()\n    \n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 1:\n                island = []\n                dfs(i, j, i, j, grid, island)\n                islands.add(getIslandSignature(island))\n    \n    return len(islands)\n\ndef dfs(i, j, start_x, start_y, grid, island):\n    if 0 <= i < len(grid) and 0 <= j < len(grid[0]) and grid[i][j] == 1:\n        grid[i][j] = 0\n        island.append((i - start_x, j - start_y))\n        dfs(i+1, j, start_x, start_y, grid, island)\n        dfs(i-1, j, start_x, start_y, grid, island)\n        dfs(i, j+1, start_x, start_y, grid, island)\n        dfs(i, j-1, start_x, start_y, grid, island)\n\ndef getIslandSignature(island):\n    island.sort()\n    diffs = []\n    for tup in island:\n        diffs.append(pow(2, (tup[0]+1)*(tup[1]+1)))\n    return (len(island), sum(set(diffs)))\n\n[/Code 2]\n\n[Asserts 2]\n\nassert numDistinctIslands([[1,1,0,1,1],\n                          [1,0,0,0,0],\n                          [0,0,0,0,1],\n                          [1,1,0,1,1]]) == 3\nassert numDistinctIslands([[1,1,0,0,0],\n                          [1,1,0,0,0],\n                          [0,0,0,1,1],\n                          [0,0,0,1,1]]) == 1\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.92}, {"few_shot_keywords": "['iteration', 'ends', 'dynamic-programming', 'row', 'size', 'dictionary', 'common', 'element', 'matrix']", "test_keywords": "['dictionary', 'row', 'matrix', 'element', 'iteration', 'initial points', 'common', 'STL']", "prompt_tokens": 665, "total_tokens": 1004, "completion_tokens": 339, "completion": "[Question 2]\n\nGiven a matrix mat[][] of size N*M and a dictionary of initial points, find the common element at those initial points in the matrix.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List, Dict\ndef findCommonElementAtInitialPoints(mat: List[List[int]], initialPoints: Dict[str, List[int]]) -> Dict[str, int]:\n    result = {}\n    for key in initialPoints:\n        row, col = initialPoints[key]\n        result[key] = mat[row][col]\n    return result\n\n[/Code 2]\n\n[Asserts 2]\n\nassert findCommonElementAtInitialPoints([[1, 2, 3], [4, 5, 6], [7, 8, 9]], {'point1': [0, 1], 'point2': [2, 2]}) == {'point1': 2, 'point2': 9}\nassert findCommonElementAtInitialPoints([[1, 2, 3], [4, 5, 6], [7, 8, 9]], {'point1': [1, 1], 'point2': [2, 0]}) == {'point1': 5, 'point2': 7}\nassert findCommonElementAtInitialPoints([[1, 2, 3], [4, 5, 6], [7, 8, 9]], {'point1': [0, 0], 'point2': [1, 2]}) == {'point1': 1, 'point2': 6}\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.891}, {"few_shot_keywords": "['boundary', 'mark', 'recover', 'dfs', 'surrounded', 'graph', '2D list', '180 degrees', 'coverage', 'matrix', 'backward', 'replace', 'change']", "test_keywords": "['change', 'count', 'matrix', 'dfs', 'boundary', 'coverage', 'mark', 'recover', 'surrounded', 'replace']", "prompt_tokens": 930, "total_tokens": 1437, "completion_tokens": 507, "completion": "[Question 2]\n\nYou are given a 2D matrix consisting of 0s and 1s. Write a function to count the number of connected components surrounded by 0s (surrounded by 0s from all sides) in the matrix.\n\n[/Question 2]\n\n[Code 2]\n\ndef countSurroundedComponents(matrix):\n\tif not matrix or not matrix[0]:\n\t\treturn 0\n\t\n\tm, n = len(matrix), len(matrix[0])\n\tcount = 0\n\n\tdef dfs(x, y):\n\t\tif x < 0 or x >= m or y < 0 or y >= n or matrix[x][y] != 1:\n\t\t\treturn\n\t\tmatrix[x][y] = -1  # mark as visited\n\t\tdfs(x+1, y)  # up\n\t\tdfs(x-1, y)  # down\n\t\tdfs(x, y+1)  # right\n\t\tdfs(x, y-1)  # left\n\n\tfor i in range(m):\n\t\tfor j in range(n):\n\t\t\tif matrix[i][j] == 1:\n\t\t\t\tif not any([i == 0 or i == m-1 or j == 0 or j == n-1 for i, j in [(i+1, j), (i-1, j), (i, j+1), (i, j-1)]]):\n\t\t\t\t\tcount += 1\n\t\t\t\tdfs(i, j)\n\n\treturn count\n\n[/Code 2]\n\n[Asserts 2]\n\nmatrix1 = [[0, 0, 0, 0, 0],\n\t\t   [0, 1, 1, 1, 0],\n\t\t   [0, 1, 0, 1, 0],\n\t\t   [0, 1, 1, 1, 0],\n\t\t   [0, 0, 0, 0, 0]]\nassert countSurroundedComponents(matrix1) == 1\n\nmatrix2 = [[0, 0, 0, 0, 0],\n\t\t   [0, 1, 1, 1, 0],\n\t\t   [0, 1, 0, 1, 0],\n\t\t   [0, 1, 0, 1, 0],\n\t\t   [0, 0, 0, 0, 0]]\nassert countSurroundedComponents(matrix2) == 2\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.852}, {"few_shot_keywords": "['largest', 'BST', 'subsquare', 'cells', 'surrounded', 'empty space', 'generator', 'sequence', 'wall', 'adjacent', 'edges', 'perfect square', 'matrix', 'target']", "test_keywords": "['wall', 'perfect square', 'palindrome', 'empty space', 'subsquare', 'matrix', 'points', 'surrounded', 'adjacent', 'cells', 'largest']", "prompt_tokens": 939, "total_tokens": 1491, "completion_tokens": 552, "completion": "[Question 2]\n\nGiven a matrix of characters representing walls ('#') and empty spaces ('.'), find the largest subsquare that is a perfect square and is surrounded by walls. The subsquare must consist of at least 4 adjacent cells and when read row-wise or column-wise, the characters form a palindrome.\n\n[/Question 2]\n\n[Code 2]\n\ndef largestPalindromeSubsquare(matrix):\n    def isSurroundedByWall(subsquare):\n        m, n = len(subsquare), len(subsquare[0])\n        for i in range(m):\n            if subsquare[i][0] != '#' or subsquare[i][n-1] != '#':\n                return False\n        for j in range(n):\n            if subsquare[0][j] != '#' or subsquare[m-1][j] != '#':\n                return False\n        return True\n\n    def isPalindrome(s):\n        return s == s[::-1]\n    \n    def checkIfSquare(subsquare):\n        m, n = len(subsquare), len(subsquare[0])\n        size = min(m, n)\n        for i in range(size):\n            row = ''.join(subsquare[i])\n            col = ''.join(subsquare[j][i] for j in range(m))\n            if not isPalindrome(row) or not isPalindrome(col):\n                return False\n        return True\n    \n    res = 0\n    for i in range(len(matrix)):\n        for j in range(len(matrix[0])):\n            if matrix[i][j] == '#':\n                subsquare = [row[j:j+res+1] for row in matrix[i:i+res+1]]\n                while (i+res < len(matrix) and j+res < len(matrix[0]) and isSurroundedByWall(subsquare)):\n                    if checkIfSquare(subsquare):\n                        res += 1\n                    else:\n                        break\n                    if i+res < len(matrix) and j+res < len(matrix[0]):\n                        subsquare = [row[j:j+res+1] for row in matrix[i:i+res+1]]\n    return res * res\n\n[/Code 2]\n\n[Asserts 2]\n\nassert largestPalindromeSubsquare([['#', '#', '#', '#'], ['#', '.', '.', '#'], ['#', '.', '.', '#'], ['#', '#', '#', '#']])==4\nassert largestPalindromeSubsquare([['#', '#', '#', '#'], ['#', '.', '.', '#'], ['#', '.', '.', '#'], ['#', '#', '.', '#']])==1\nassert largestPalindromeSubsquare([['#', '#', '#'], ['#', '.', '#'], ['#', '#', '#']])==1\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.741}, {"few_shot_keywords": "['steps', 'dynamic-programming', 'traversal', 'points', 'grid', 'parent-child relationship', 'order', 'maximum', 'increment']", "test_keywords": "['swaps', 'preorder traversal', 'closest sum', 'dynamic-programming', 'traversal', 'conversion', 'grid', 'maximum', 'points']", "prompt_tokens": 747, "total_tokens": 1203, "completion_tokens": 456, "completion": "[Question 2]\n\nGiven a binary tree and an integer k, the task is to find the maximum sum of the closest value to k in the tree by performing a limited number of swaps. A swap is defined as exchanging the values of two nodes such that the resulting value is closer to k.\n\n[/Question 2]\n\n[Code 2]\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef closestSum(root, k, swaps):\n    closest = [float('inf')]\n    \n    def preorderTraversal(node, path):\n        if not node:\n            return\n        path.append(node.val)\n        if abs(node.val - k) < abs(closest[0] - k):\n            closest[0] = node.val\n        preorderTraversal(node.left, path)\n        preorderTraversal(node.right, path)\n        path.pop()\n    \n    path = []\n    preorderTraversal(root, path)\n    \n    for _ in range(swaps):\n        minDiff = float('inf')\n        for i in range(len(path)):\n            for j in range(i+1, len(path)):\n                diff = abs(path[i] + path[j] - k*2)\n                if diff < minDiff:\n                    minDiff = diff\n                    minIndex1, minIndex2 = i, j\n        path[minIndex1], path[minIndex2] = path[minIndex2], path[minIndex1]\n    \n    return sum(path)\n\n[/Code 2]\n\n[Asserts 2]\n\nnode1 = TreeNode(1)\nnode2 = TreeNode(2)\nnode3 = TreeNode(3)\nnode4 = TreeNode(4)\nnode5 = TreeNode(5)\nnode6 = TreeNode(6)\n\nnode1.left = node2\nnode1.right = node3\nnode2.left = node4\nnode2.right = node5\nnode3.right = node6\n\nassert closestSum(node1, 7, 2) == 17\nassert closestSum(node1, 5, 1) == 14\nassert closestSum(node1, 8, 3) == 18\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.722}, {"few_shot_keywords": "['2D grid', 'coins', 'exit gate', 'dead end', 'maximum', 'directions', 'cell', 'blocked', 'beginning', 'generate', 'boundary', 'undirected', 'doubly linked list', 'integer', 'move']", "test_keywords": "['boundary', 'dead end', 'clock', '2D grid', 'directions', 'distinct elements', 'exit gate', 'level order', 'move', 'maximum', 'cell', 'blocked', 'indexing', 'coins']", "prompt_tokens": 977, "total_tokens": 1528, "completion_tokens": 551, "completion": "[Question 2]\n\nYou are given a 2D grid of size N x N where each cell contains a non-negative integer representing the number of coins present in that cell. Your task is to find the maximum number of coins you can collect while navigating from the top-left cell to the bottom-right cell. You can move in four directions - up, down, left, and right. However, you can only move to cells with a strictly higher number of coins. Additionally, you must ensure that you visit distinct cells and cannot revisit a cell. If there is no path from the top-left cell to the bottom-right cell, return -1.\n\nWrite a function `maxCoinsPath` which takes the grid as input and returns the maximum number of coins that can be collected while following these rules.\n\n[/Question 2]\n\n[Code 2]\n\ndef maxCoinsPath(grid: List[List[int]]) -> int:\n        n = len(grid)\n\n        def isValid(x, y, prevCoin):\n            return 0 <= x < n and 0 <= y < n and grid[x][y] > prevCoin\n\n        def dfs(x, y, prevCoin, visited):\n            if (x, y) == (n-1, n-1):\n                return grid[x][y]\n            maxCoins = -1\n            for dx, dy in [(1, 0), (0, 1), (-1, 0), (0, -1)]:\n                newX, newY = x + dx, y + dy\n                if isValid(newX, newY, prevCoin) and (newX, newY) not in visited:\n                    visited.add((newX, newY))\n                    maxCoins = max(maxCoins, dfs(newX, newY, grid[x][y], visited))\n                    visited.remove((newX, newY))\n            if maxCoins == -1:\n                return -1\n            return grid[x][y] + maxCoins\n\n        result = dfs(0, 0, -1, {(0, 0)})\n        return max(result, -1)\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maxCoinsPath([[0, 2, 3],\n                     [5, 4, 5],\n                     [6, 7, 8]]) == 8\nassert maxCoinsPath([[0, 1, 3],\n                     [2, 4, 5],\n                     [6, 8, 9]]) == 9\nassert maxCoinsPath([[1, 2, 3],\n                     [4, 5, 6],\n                     [7, 8, 9]]) == -1\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.873}, {"few_shot_keywords": "['swap', 'length', '2D', 'DFS', 'maximum', 'consecutive', 'direction', '1s', 'right subtree', 'path', 'recursion', 'character array']", "test_keywords": "['character array', 'maximum', 'recursion', 'sorting', 'DFS', '2D', 'length', 'character', 'path', 'consecutive', 'direction']", "prompt_tokens": 811, "total_tokens": 1371, "completion_tokens": 560, "completion": "[Question 2]\n\nGiven a 2D character array, determine the maximum length of consecutive path formed by characters that are sorted in alphabetical order. The consecutive path can move in any direction (horizontal, vertical, or diagonal), and the characters in the path must be in increasing alphabetical order. Implement this using recursion.\n\n[/Question 2]\n\n[Code 2]\n\ndef is_valid_move(matrix, i, j, prev_char):\n    if i < 0 or j < 0 or i >= len(matrix) or j >= len(matrix[0]) or matrix[i][j] <= prev_char:\n        return False\n    return True\n\ndef maxConsecutiveSortedPath(matrix, i, j, prev_char):\n    if not is_valid_move(matrix, i, j, prev_char):\n        return 0\n    directions = [(0,1),(1,0),(0,-1),(-1,0),(1,1),(-1,-1),(-1,1),(1,-1)]\n    max_length = 0\n    for dir in directions:\n        x, y = i+dir[0], j+dir[1]\n        max_length = max(max_length, maxConsecutiveSortedPath(matrix, x, y, matrix[i][j])+1)\n    return max_length\n\ndef getMaxConsecutiveSortedPath(matrix):\n    max_length = 0\n    for i in range(len(matrix)):\n        for j in range(len(matrix[0])):\n            max_length = max(max_length, maxConsecutiveSortedPath(matrix, i, j, chr(0)))\n    return max_length\n\n[/Code 2]\n\n[Asserts 2]\n\nassert getMaxConsecutiveSortedPath([['a', 'b', 'c'],\n                   ['d', 'e', 'f'],\n                   ['g', 'h', 'i']])==9\nassert getMaxConsecutiveSortedPath([['z', 'y', 'x'],\n                   ['a', 'b', 'c'],\n                   ['d', 'e', 'f']])==6\nassert getMaxConsecutiveSortedPath([['a', 'b', 'c'],\n                   ['f', 'e', 'd'],\n                   ['g', 'h', 'i']])==4\nassert getMaxConsecutiveSortedPath([['f', 'e', 'd'],\n                   ['a', 'b', 'z'],\n                   ['c', 'h', 'i']])==9\nassert getMaxConsecutiveSortedPath([['a', 'b', 'c', 'd'],\n                   ['h', 'g', 'f', 'e'],\n                   ['i', 'j', 'k', 'l'],\n                   ['p', 'o', 'n', 'm']])==16\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.797}, {"few_shot_keywords": "['direction', 'longest', 'dp', 'result', 'starting', 'distinct', 'safe', 'matrix', 'deque', 'path', 'max', 'cell', 'subtree', 'flips', 'find']", "test_keywords": "['combinations', 'find', 'longest', 'starting', 'distinct', 'max', 'dp', 'cell', 'safe', 'path', 'matrix', 'direction', 'result', 'alternating', 'counter']", "prompt_tokens": 1021, "total_tokens": 1477, "completion_tokens": 456, "completion": "[Question 2]\n\nGiven a matrix of distinct integers, find the longest path of alternating increasing and decreasing numbers starting from any cell and going in any direction but not going back to the cell from which you started.\n\n[/Question 2]\n\n[Code 2]\n\nclass Solution:\n    def longestAlternatingPath(self, matrix):\n        if not matrix:\n            return 0\n        row, col = len(matrix), len(matrix[0])\n        dp = [[1, 1] for _ in range(row * col)]\n        res = 1\n        for r in range(row):\n            for c in range(col):\n                num = matrix[r][c]\n                for dr, dc in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\n                    nr, nc = r + dr, c + dc\n                    if 0 <= nr < row and 0 <= nc < col and matrix[nr][nc] != num:\n                        inc, dec = dp[r * col + c]\n                        dp[nr * col + nc][0] = max(dp[nr * col + nc][0], dec + 1)\n                        dp[nr * col + nc][1] = max(dp[nr * col + nc][1], inc + 1)\n                        res = max(res, max(dp[nr * col + nc]))\n        return res\n\nsol = Solution()\nmatrix = [[1, 2, 3], [6, 5, 4], [7, 8, 9]]\nprint(sol.longestAlternatingPath(matrix)) # Output: 9\n\n[/Code 2]\n\n[Asserts 2]\n\nsol = Solution()\nassert sol.longestAlternatingPath([[1, 2, 3], [6, 5, 4], [7, 8, 9]]) == 9\nassert sol.longestAlternatingPath([[1, 2, 3, 4], [8, 7, 6, 5], [9, 10, 11, 12], [16, 15, 14, 13]]) == 8\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.855}, {"few_shot_keywords": "['move', 'backward', 'tree construction', 'initial points', 'length', 'negative', 'right', 'minimum', 'grid', 'down', 'dynamic programming', 'destination', 'positive']", "test_keywords": "['forward', 'negative', 'down', 'duplicates', 'positive', 'initial points', 'move', 'minimum', 'parent-pointer', 'right', 'dynamic programming', 'destination', 'grid', 'coin']", "prompt_tokens": 766, "total_tokens": 1226, "completion_tokens": 460, "completion": "[Question 2]\n\nYou are given a grid representing a coin collecting game where each cell has a certain number of coins (positive or negative). You can move either right or down from each cell. The task is to find the minimum initial points you need to reach the destination cell without encountering negative coins, while also considering the possibility of duplicates in the grid.\n\n[/Question 2]\n\n[Code 2]\n\ndef minInitialPointsWithDuplicates(grid: list) -> int:\n    rows, cols = len(grid), len(grid[0])\n    dp = [[0] * cols for _ in range(rows)]\n    for i in range(rows-1, -1, -1):\n        for j in range(cols-1, -1, -1):\n            if i == rows-1 and j == cols-1:\n                dp[i][j] = max(1, 1 - grid[i][j])\n            elif i == rows-1:\n                dp[i][j] = max(1, dp[i][j+1] - grid[i][j])\n            elif j == cols-1:\n                dp[i][j] = max(1, dp[i+1][j] - grid[i][j])\n            else:\n                dp[i][j] = max(1, min(dp[i+1][j], dp[i][j+1]) - grid[i][j])\n    return dp[0][0]\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minInitialPointsWithDuplicates([[-2, -3, 3], [-5, -10, 1], [10, 30, -5]]) == 7\nassert minInitialPointsWithDuplicates([[2, 6, -6], [1, -2, 6], [-1, 8, 0]]) == 1\nassert minInitialPointsWithDuplicates([[-2, -3, 3], [-8, -10, 1], [10, 30, -5]]) == 16\nassert minInitialPointsWithDuplicates([[-6, -3, 3], [-8, -2, 6], [-1, 8, 0]]) == 1\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.728}, {"few_shot_keywords": "['numbers', 'target', 'repeating', 'occurrence', 'blocked', 'end', 'elements', 'array']", "test_keywords": "['numbers', 'array', 'occurrence', 'coprime', 'connected', 'elements', 'repeating', 'row', 'positive', 'cycle']", "prompt_tokens": 558, "total_tokens": 1066, "completion_tokens": 508, "completion": "[Question 2]\n\nGiven a 2D array representing a matrix of numbers, determine if there exists a positive cycle in the matrix. A positive cycle is defined as a sequence of connected elements in the matrix such that the elements are repeating and coprime to each other. Return True if a positive cycle exists, otherwise return False.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef hasPositiveCycle(matrix: List[List[int]]) -> bool:\n    def coprime(a, b):\n        while b:\n            a, b = b, a % b\n        return a == 1\n    \n    def dfs(i, j, target, visited):\n        if i < 0 or i >= len(matrix) or j < 0 or j >= len(matrix[0]) or (i, j) in visited or matrix[i][j] != target:\n            return False\n        if (i, j) in cycle:\n            return True\n        visited.add((i, j))\n        for x, y in [(i+1, j), (i-1, j), (i, j+1), (i, j-1)]:\n            if 0 <= x < len(matrix) and 0 <= y < len(matrix[0]) and coprime(matrix[i][j], matrix[x][y]):\n                cycle.add((i, j))\n                if dfs(x, y, target, visited):\n                    return True\n                cycle.remove((i, j))\n        return False\n    \n    for i in range(len(matrix)):\n        for j in range(len(matrix[0])):\n            target = matrix[i][j]\n            cycle = set()\n            if dfs(i, j, target, set()):\n                return True\n    return False\n\n[/Code 2]\n\n[Asserts 2]\n\nassert hasPositiveCycle([[2, 3, 4, 5],\n                         [3, 4, 5, 2],\n                         [4, 5, 2, 3],\n                         [5, 2, 3, 4]]) == True\n\nassert hasPositiveCycle([[1, 2, 3],\n                         [4, 5, 6],\n                         [7, 8, 9]]) == False\n\nassert hasPositiveCycle([[2, 3, 4],\n                         [3, 4, 5],\n                         [4, 5, 6]]) == False\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.706}, {"few_shot_keywords": "['sorting', 'selection', 'minimum', 'leaf nodes', 'arrangement', 'array', 'kth', 'squares', 'input', 'smallest difference']", "test_keywords": "['smallest difference', 'selection', 'sorting', 'minimum', 'array', 'minimum value', 'conversion', 'empty space']", "prompt_tokens": 681, "total_tokens": 885, "completion_tokens": 204, "completion": "[Question 2]\n\nGiven an array of integers, write a function to find the minimum value of the absolute differences between any two elements after sorting the array in ascending order.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\ndef minAbsoluteDiff(arr: List[int]) -> int:\n    arr.sort()\n    min_diff = float('inf')\n    for i in range(len(arr) - 1):\n        diff = abs(arr[i] - arr[i + 1])\n        if diff < min_diff:\n            min_diff = diff\n    return min_diff\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minAbsoluteDiff([3, 1, 9, 5, 4])==1\nassert minAbsoluteDiff([10, 12, 13, 15, 20, 24])==1\nassert minAbsoluteDiff([1, 5, 3, 19, 18, 25])==1\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.838}, {"few_shot_keywords": "['elements', 'relative complement', 'sorted', 'tree structure', 'array', 'submatrix', 'intersection']", "test_keywords": "['relative complement', 'array', 'STL', 'sorted', 'sums', 'elements', 'intersection']", "prompt_tokens": 623, "total_tokens": 918, "completion_tokens": 295, "completion": "[Question 2]\n\nYou are given two sorted arrays A[] and B[] of size n and m. Write a function to find the intersection (common elements) of the two arrays using the STL library in C++.\n\n[/Question 2]\n\n[Code 2]\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> intersection(std::vector<int>& A, std::vector<int>& B) {\n    std::vector<int> result;\n    std::set_intersection(A.begin(), A.end(), B.begin(), B.end(), std::back_inserter(result));\n    return result;\n}\n```\n\n[/Code 2]\n\n[Asserts 2]\n\n```cpp\nassert(intersection({1, 2, 3, 4, 5}, {4, 5, 6}) == {4, 5});\nassert(intersection({4, 5, 6}, {1, 2, 3, 4, 5}) == {4, 5});\nassert(intersection({2, 6, 8, 12, 14, 15, 18}, {3, 6, 7, 8, 11, 12, 13, 14, 15, 16, 17, 18, 19}) == {6, 8, 12, 14, 15, 18});\n```", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.82}, {"few_shot_keywords": "['sorting algorithm', 'increment', 'comparison', 'selection', 'operations', 'integer', 'sorting', 'relative complement', 'minimum', 'Excel', 'binary', 'array']", "test_keywords": "['mark', 'array', 'operations', 'sorting', 'comparison', 'minimum', 'increment', 'integer', 'root']", "prompt_tokens": 536, "total_tokens": 749, "completion_tokens": 213, "completion": "[Question 2]\n\nYou are given an array of integers. Write a function to find the minimum number of operations required to sort the array in ascending order. The operations allowed are swapping any two elements of the array. \n\n[/Question 2]\n\n[Code 2]\n\ndef minOperationsToSort(arr):\n    sorted_arr = sorted(arr)\n    count = 0\n    for i in range(len(arr)):\n        if arr[i] != sorted_arr[i]:\n            count += 1\n    return count\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minOperationsToSort([3, 2, 1]) == 3\nassert minOperationsToSort([1, 2, 3, 4, 5]) == 0\nassert minOperationsToSort([5, 4, 3, 2, 1]) == 2\nassert minOperationsToSort([1, 3, 2, 4, 6, 5]) == 2\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.731}, {"few_shot_keywords": "['adjacent', 'prime', 'sorting', 'counting-out game', 'maximize', 'array', 'iteration', 'minimize', 'exponentiation', 'comparison']", "test_keywords": "['construction', 'sorting', 'array', 'comparison', 'maximize', 'minimize', 'iteration', 'clock']", "prompt_tokens": 731, "total_tokens": 1036, "completion_tokens": 305, "completion": "[Question 2]\n\nYou are given an array of n distinct integers representing the time on a 24-hour clock. Your task is to construct a new array by sorting the given array in such a way that the absolute difference between each adjacent element is maximized. Write a function to perform this task.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef maximizeAdjacentDifference(arr: List[int]) -> List[int]:\n    arr.sort()\n    n = len(arr)\n    result = [0]*n\n    start = 0\n    end = n-1\n    i = 0\n    while start <= end:\n        if i % 2 == 0:\n            result[i] = arr[start]\n            start += 1\n        else:\n            result[i] = arr[end]\n            end -= 1\n        i += 1\n    return result\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maximizeAdjacentDifference([1, 7, 11, 15, 20]) == [1, 15, 7, 20, 11]\nassert maximizeAdjacentDifference([12, 4, 7, 19, 23, 10]) == [4, 19, 7, 23, 10, 12]\nassert maximizeAdjacentDifference([5, 10, 15, 20, 25]) == [5, 20, 10, 25, 15]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.87}, {"few_shot_keywords": "['sorted', 'positive integer', 'target', 'pair', 'numbers', 'coins', 'order', 'sum', 'integers', 'arrays', 'closest']", "test_keywords": "['specific', 'defaultdict', 'target', 'closest', 'arrays', 'sorted', 'pair', 'integers', 'sum']", "prompt_tokens": 731, "total_tokens": 1126, "completion_tokens": 395, "completion": "[Question 2]\n\nYou are given two sorted arrays of integers, arr1 and arr2. Write a function findClosestPairs(arr1, arr2, target) that finds the specific pair of integers, one from each array, whose sum is closest to the target. Use a defaultdict to keep track of the closest pairs.\n\n[/Question 2]\n\n[Code 2]\n\nfrom collections import defaultdict\n\ndef findClosestPairs(arr1, arr2, target):\n    diff_map = defaultdict(list)\n    for num1 in arr1:\n        for num2 in arr2:\n            pair_sum = num1 + num2\n            diff_map[abs(pair_sum - target)].append((num1, num2))\n    min_diff = min(diff_map.keys())\n    return diff_map[min_diff]\n\n[/Code 2]\n\n[Asserts 2]\n\nassert findClosestPairs([10, 20, 30, 40], [25, 35, 45, 55], 50) == [(20, 35), (30, 25)]\nassert findClosestPairs([1, 3, 5, 7, 9], [2, 3, 4, 7], 10) == [(3, 7)]\nassert findClosestPairs([1, 4, 5, 7], [10, 20, 30, 40], 32) == [(5, 30)]\nassert findClosestPairs([1, 4, 5, 7], [10, 20, 30, 40], 50) == [(7, 40)]\nassert findClosestPairs([2, 9, 13, 15, 22], [3, 7, 11, 15, 18], 20) == [(9, 11), (13, 7), (15, 5)]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.829}, {"few_shot_keywords": "['result', 'array', 'searching', 'two pointers', 'odd', 'sorted', 'closest sum', 'doubly linked list', 'pair']", "test_keywords": "['binary tree node', 'division', 'largest', 'pair', 'array', 'closest sum', 'sorted', 'two pointers', 'undirected', 'node', 'searching']", "prompt_tokens": 730, "total_tokens": 1149, "completion_tokens": 419, "completion": "[Question 2]\n\nGiven an undirected binary tree, find the largest pair of nodes with the closest sum to a given number k. The tree is sorted in such a way that for each node, all the values in the left subtree are less than the node's value and all the values in the right subtree are greater than the node's value.\n\n[/Question 2]\n\n[Code 2]\n\nclass TreeNode:\n    def __init__(self, value=0, left=None, right=None):\n        self.value = value\n        self.left = left\n        self.right = right\n\ndef closestSumPairInBinaryTree(root: TreeNode, k: int) -> List[int]:\n    def inorderTraversal(node):\n        return inorderTraversal(node.left) + [node.value] + inorderTraversal(node.right) if node else []\n\n    arr = inorderTraversal(root)\n    n = len(arr)\n    ans = [arr[0], arr[n-1]]\n    l, r = 0, n-1\n    diff = float('inf')\n    while l < r:\n        if abs(arr[l] + arr[r] - k) < diff:\n            diff = abs(arr[l] + arr[r] - k)\n            ans[0] = arr[l]\n            ans[1] = arr[r]\n        if arr[l] + arr[r] > k:\n            r -= 1\n        else:\n            l += 1\n    return ans\n\n[/Code 2]\n\n[Asserts 2]\n\ntree = TreeNode(5, TreeNode(3, TreeNode(2), TreeNode(4)), TreeNode(8, TreeNode(6), TreeNode(10)))\nassert closestSumPairInBinaryTree(tree, 7) == [3, 4]\nassert closestSumPairInBinaryTree(tree, 9) == [4, 5]\nassert closestSumPairInBinaryTree(tree, 12) == [5, 8]\nassert closestSumPairInBinaryTree(tree, 15) == [6, 8]\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.769}, {"few_shot_keywords": "['adjacent', 'minimum', 'maximum', 'swaps', 'step', 'sorting', 'position', 'amount', 'array']", "test_keywords": "['maximum', 'money', 'position', 'cumulative', 'sorting', 'blocked', 'swaps', 'array', 'minimum', 'adjacent', 'sum']", "prompt_tokens": 677, "total_tokens": 1088, "completion_tokens": 411, "completion": "[Question 2]\n\nYou are given an array of integers representing the amount of money in each position of a game board. The game board has some positions blocked, and you can perform swaps of adjacent positions to maximize the cumulative sum of money. Write a function to find the maximum cumulative sum of money that can be obtained after performing a certain number of swaps.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef maxCumulativeSum(arr: List[int], allowedSwaps: int) -> int:\n    def dfs(start, end, visited):\n        if start >= end:\n            return 0\n        maxSum = 0\n        for i in range(start, end):\n            if (start, i) not in visited:\n                visited.add((start, i))\n                arr[i], arr[start] = arr[start], arr[i]\n                maxSum = max(maxSum, sum(arr[start:end+1]) + dfs(start+1, end, visited))\n                arr[i], arr[start] = arr[start], arr[i]\n                visited.remove((start, i))\n        return maxSum\n    \n    return sum(arr) + dfs(0, len(arr)-1, set())  # initial sum plus maximum cumulative sum obtained from swaps\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maxCumulativeSum([4, 7, 2, 9, 3, 8], 2) == 40\nassert maxCumulativeSum([1, 2, 3, 4, 5], 1) == 15\nassert maxCumulativeSum([5, 4, 3, 2, 1], 3) == 15\nassert maxCumulativeSum([1, 2, 3, 4, 5], 0) == 15\nassert maxCumulativeSum([5, 5, 5, 5, 5], 10) == 30\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.807}, {"few_shot_keywords": "['number', 'combinations', 'dp', 'dynamic programming', 'n digit numbers', 'count', 'recursion', 'sum of digits', 'positive integer', 'closest sum']", "test_keywords": "['combinations', 'inserting', 'constant', 'scalar', 'n digit numbers', 'in-degree', 'recursion', 'count', 'sum of digits', 'dynamic programming', 'area', 'positive integer']", "prompt_tokens": 618, "total_tokens": 899, "completion_tokens": 281, "completion": "[Question 2]\n\nYou are given a positive integer N. Write a recursive function to count the total number of unique n digit numbers that can be formed by inserting a constant scalar in the middle of the number, and the sum of the digits of the number is equal to a given sum.\n\n[/Question 2]\n\n[Code 2]\n\ndef findCount(n : int, sum : int, scalar: int) -> int :\n    if n == 0 and sum == 0 :\n        return 1\n    if n == 0 :\n        return 0\n    if n == 1 :\n        return 1 if sum >= 0 and sum <= 9 else 0\n    ans = 0\n    for i in range(10) :\n        if sum-i >= 0 and  sum-i <= 9*(n/2) :\n            ans += findCount(n-2, sum-i, scalar)\n    return ans\n\n[/Code 2]\n\n[Asserts 2]\n\nassert findCount(2, 5, 2)==4\nassert findCount(3, 6, 0)==4\nassert findCount(4, 10, 3)==12\nassert findCount(2, 0, 1)==1\nassert findCount(3, 7, 4)==0\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.866}, {"few_shot_keywords": "['palindromic', 'center', 'dynamic programming', 'squares', 'collections', 'positive', 'sum', 'minimum', 'optimization', 'integer']", "test_keywords": "['vertex', 'dynamic programming', 'structure', 'optimization', 'sum', 'children', 'positive', 'integer', 'squares', 'initial points', 'minimum']", "prompt_tokens": 484, "total_tokens": 751, "completion_tokens": 267, "completion": "[Question 2]\n\nGiven a tree structure represented as a collection of vertices, where each vertex has an initial point value, the task is to find the minimum initial points such that at each vertex, the sum of the points of the vertex and its children is positive.\n\n[/Question 2]\n\n[Code 2]\n\nclass TreeNode:\n    def __init__(self, value):\n        self.value = value\n        self.children = []\n\ndef minimumInitialPoints(root: TreeNode) -> int:\n    def dfs(node):\n        if not node.children:\n            return max(1, -node.value + 1)\n        \n        minChildPoints = float('inf')\n        for child in node.children:\n            minChildPoints = min(minChildPoints, dfs(child))\n        \n        return max(1, minChildPoints - node.value)\n    \n    return dfs(root)\n\n[/Code 2]\n\n[Asserts 2]\n\nnode1 = TreeNode(-10)\nnode2 = TreeNode(2)\nnode3 = TreeNode(8)\nnode4 = TreeNode(-3)\nnode5 = TreeNode(4)\nnode6 = TreeNode(6)\nnode1.children = [node2, node3]\nnode2.children = [node4, node5, node6]\n\nassert minimumInitialPoints(node1) == 6\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.724}, {"few_shot_keywords": "['combinations', 'cumulative', 'gcd', 'findDistance', 'coin', 'minimization', 'mirror', 'dynamic programming', 'amount', 'greedy', 'denominations', 'optimization', 'move']", "test_keywords": "['amount', 'operations', 'Excel', 'optimization', 'minimization', 'combinations', 'denominations', 'greedy', 'coin', 'dynamic programming']", "prompt_tokens": 573, "total_tokens": 884, "completion_tokens": 311, "completion": "[Question 2]\n\nYou are given a 2D array representing an Excel spreadsheet with positive integers. Each cell contains either a single positive integer or a formula represented as a string that starts with '=' followed by a valid Excel formula. Write a program to compute the cumulative sum of all the integers in the spreadsheet, considering the values of the cells and the result of the formulas.\n\n[/Question 2]\n\n[Code 2]\n\ndef calculateSpreadsheetSum(spreadsheet: List[List[Union[int, str]]]) -> int:\n        def evaluateCell(cell):\n            if isinstance(cell, int):\n                return cell\n            elif cell.startswith('='):\n                return eval(cell[1:])\n            else:\n                return 0\n\n        total_sum = 0\n        for row in spreadsheet:\n            for cell in row:\n                total_sum += evaluateCell(cell)\n\n        return total_sum\n\n[/Code 2]\n\n[Asserts 2]\n\nspreadsheet1 = [\n    [1, '=2+3', 4],\n    [5, '=SUM(A1:C1)', 6],\n    [7, 8, '=A2*B2']\n]\nassert calculateSpreadsheetSum(spreadsheet1) == 39\n\nspreadsheet2 = [\n    [10, 20, '=A1+A2'],\n    ['=SUM(A1:B1)', 30, 40],\n    [50, 60, 70]\n]\nassert calculateSpreadsheetSum(spreadsheet2) == 280\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.938}, {"few_shot_keywords": "['math', 'range', 'sum', 'decimal', 'digits', 'singly linked list', 'loop', 'iteration']", "test_keywords": "['range', 'sum', 'math', 'initial points', 'loop', 'interior', 'iteration', 'digits', 'points']", "prompt_tokens": 478, "total_tokens": 797, "completion_tokens": 319, "completion": "[Question 2]\n\nYou are given a list of points in the form of (x, y) coordinates. Write a function to calculate the sum of the x-coordinates of all interior points within a given range. An interior point is defined as a point whose x-coordinate is strictly greater than the minimum x-coordinate and strictly less than the maximum x-coordinate.\n\n[/Question 2]\n\n[Code 2]\n\ndef sumOfInteriorXCoordinates(points: list, minX: int, maxX: int) -> int:\n    total_sum = 0\n    for point in points:\n        x, y = point\n        if minX < x < maxX:\n            total_sum += x\n    return total_sum\n\n[/Code 2]\n\n[Asserts 2]\n\nassert sumOfInteriorXCoordinates([(1, 2), (3, 4), (5, 6), (7, 8)], 2, 6) == 8\nassert sumOfInteriorXCoordinates([(1, 2), (3, 4), (5, 6), (7, 8)], 3, 7) == 12\nassert sumOfInteriorXCoordinates([(1, 2), (3, 4), (5, 6), (7, 8)], 4, 5) == 0\nassert sumOfInteriorXCoordinates([(1, 2), (3, 4), (5, 6), (7, 8)], 1, 8) == 15\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.763}, {"few_shot_keywords": "['closed', 'left', 'positive integer', 'exponentiation', 'ways', 'ends', 'opened', 'deque', 'buildings', 'efficient', 'construct']", "test_keywords": "['multiplication', 'construct', 'ends', 'buildings', 'positive integer', 'ways', 'zigzag', 'Fibonacci', 'closed', 'opened', 'diagonal', 'points']", "prompt_tokens": 451, "total_tokens": 654, "completion_tokens": 203, "completion": "[Question 2]\n\nGiven a positive integer n, how many ways can you construct a zigzag sequence of length n using the Fibonacci sequence, where each element is the multiplication of the Fibonacci numbers at the diagonal points of a 2D grid of buildings, with ends either closed or opened?\n\n[/Question 2]\n\n[Code 2]\n\ndef countZigzagWays(n: int) -> int:\n    if n <= 2:\n        return n\n    a, b = 1, 1\n    for _ in range(3, n + 1):\n        a, b = b, a + b\n    return b\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countZigzagWays(1)==1\nassert countZigzagWays(2)==2\nassert countZigzagWays(3)==3\nassert countZigzagWays(4)==5\nassert countZigzagWays(5)==8", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.716}, {"few_shot_keywords": "['dp', 'set', 'algorithm', 'dynamic programming', 'recursive', 'combination']", "test_keywords": "['algorithm', 'dynamic programming', 'counting', 'combination', 'interior', 'recursive']", "prompt_tokens": 495, "total_tokens": 806, "completion_tokens": 311, "completion": "[Question 2]\n\nYou are given an array of integers, you need to find the number of non-empty contiguous subarrays that have an equal number of even and odd elements.\n\n[/Question 2]\n\n[Code 2]\n\ndef countEvenOddSubarrays(arr):\n    count = 0\n    prefix = [0]\n    for num in arr:\n        if num % 2 == 0:\n            prefix.append(prefix[-1] + 1)\n        else:\n            prefix.append(prefix[-1] - 1)\n    even = [0] * 20001\n    odd = [0] * 20001\n    for num in prefix:\n        if num < 0:\n            count += odd[-num]\n            odd[-num] += 1\n        else:\n            count += even[num]\n            even[num] += 1\n    return count\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countEvenOddSubarrays([2, 2, 5, 6, 7])==3\nassert countEvenOddSubarrays([1, 1, 3, 4, 6])==3\nassert countEvenOddSubarrays([1, 2, 3, 4, 5])==2\nassert countEvenOddSubarrays([1, 3, 5, 7, 9])==9\nassert countEvenOddSubarrays([2, 4, 6, 8, 10])==6\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.712}, {"few_shot_keywords": "['searching', 'program', 'permutations', 'indices', 'string', 'pattern', 'algorithm', 'text', 'greedy', 'Boyer Moore', 'wall']", "test_keywords": "['Boyer Moore', 'text', 'directed', 'removal', 'searching', 'symmetric', 'algorithm', 'string', 'indices', 'alternating', 'undirected', 'pattern']", "prompt_tokens": 592, "total_tokens": 778, "completion_tokens": 186, "completion": "[Question 2]\n\nWrite a Python program to find all permutations of a given string that are symmetric. A string is symmetric if it remains unchanged when read forwards and backwards. The program should also handle removal of duplicate permutations.\n\n[/Question 2]\n\n[Code 2]\n\nfrom itertools import permutations\n\ndef isSymmetric(s):\n    return s == s[::-1]\n\ndef findSymmetricPermutations(input_string):\n    perms = set([''.join(p) for p in permutations(input_string)])\n    symmetric_perms = [perm for perm in perms if isSymmetric(perm)]\n    return symmetric_perms\n\n[/Code 2]\n\n[Asserts 2]\n\nassert findSymmetricPermutations('ABA')==['ABA', 'BAA', 'AAB']\nassert findSymmetricPermutations('CDC')==['CDC', 'DCC']\nassert findSymmetricPermutations('ABCD')==[]\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.859}, {"few_shot_keywords": "['string', 'lowercase', 'pattern', 'anagrams', 'indices', 'negate', 'size', 'search']", "test_keywords": "['search', 'postorder', 'cells', 'string', 'lowercase', 'relative complement', 'indices', 'pattern', 'anagrams']", "prompt_tokens": 636, "total_tokens": 952, "completion_tokens": 316, "completion": "[Question 2]\n\nYou are given a list of strings representing cells in a 2D grid. Each cell is a string of lowercase letters representing the content of that cell. Write a Python program to find the relative complement of the cells in the grid with respect to a given pattern string.\n\n[/Question 2]\n\n[Code 2]\n\ndef relativeComplement(grid, pattern):\n    pattern_count = [0] * 26\n    for char in pattern:\n        pattern_count[ord(char) - ord('a')] += 1\n\n    def isAnagram(cell):\n        cell_count = [0] * 26\n        for char in cell:\n            cell_count[ord(char) - ord('a')] += 1\n        return cell_count == pattern_count\n\n    result = []\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if isAnagram(grid[i][j]):\n                result.append((i, j))\n    return result\n\n[/Code 2]\n\n[Asserts 2]\n\nassert relativeComplement([\"abc\", \"def\", \"ghi\"], \"ab\") == [(0, 2)]\nassert relativeComplement([\"xyz\", \"abc\", \"abc\"], \"abc\") == [(0, 0), (0, 1), (1, 0), (1, 1)]\nassert relativeComplement([\"aaa\", \"bbb\", \"ccc\"], \"xyz\") == []\nassert relativeComplement([\"ab\", \"cd\"], \"ef\") == []\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.894}, {"few_shot_keywords": "['combination', 'strip', 'euclidean distance', 'sorting algorithm', 'closest pair', 'step', 'algorithm', 'destination', 'recursion', 'distance', 'sorting', 'point', 'brute force', 'divide and conquer']", "test_keywords": "['Boyer Moore', 'brute force', 'euclidean distance', 'symmetric', 'sorting', 'fill', 'distance', 'maximize', 'strip', 'point', 'algorithm', 'divide and conquer', 'closest pair', 'recursion', 'arrays']", "prompt_tokens": 999, "total_tokens": 1460, "completion_tokens": 461, "completion": "[Question 2]\n\nWrite a program to find the pair of points that maximize the Euclidean distance between them in an array of points using the brute force algorithm.\n\n[/Question 2]\n\n[Code 2]\n\nclass Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\ndef euclideanDistance(p1: Point, p2: Point) -> float:\n    return ((p1.x - p2.x)**2 + (p1.y - p2.y)**2)**0.5\n\ndef maximizeDistance(points: List[Point]) -> Tuple[Point, Point, float]:\n    n = len(points)\n    max_distance = 0\n    max_point1 = None\n    max_point2 = None\n    for i in range(n-1):\n        for j in range(i+1, n):\n            distance = euclideanDistance(points[i], points[j])\n            if distance > max_distance:\n                max_distance = distance\n                max_point1 = points[i]\n                max_point2 = points[j]\n    return (max_point1, max_point2, max_distance)\n\n[/Code 2]\n\n[Asserts 2]\n\npoints1 = [Point(2, 3), Point(12, 30), Point(40, 50), Point(5, 1), Point(12, 10), Point(3, 4)]\npoints2 = [Point(1, 1), Point(2, 2), Point(3, 3), Point(4, 4), Point(5, 5)]\npoints3 = [Point(1, 1), Point(2, 2), Point(10, 10), Point(5, 5)]\nassert maximizeDistance(points1) == (Point(2, 3), Point(40, 50), 56.72741841473134)\nassert maximizeDistance(points2) == (Point(1, 1), Point(5, 5), 5.656854249492381)\nassert maximizeDistance(points3) == (Point(1, 1), Point(10, 10), 12.727922061357855)\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.926}, {"few_shot_keywords": "['scalar', 'line', 'segment', 'start', 'coordinates', 'point', 'vertices', 'end', 'intersect', 'visited', 'intersection']", "test_keywords": "['intersection', 'point', 'start', 'positive integer', 'program', 'path', 'end', 'segment', 'line', 'intersect', 'coordinates']", "prompt_tokens": 915, "total_tokens": 1985, "completion_tokens": 1070, "completion": "[Question 2]\n\nYou are given a set of line segments, each defined by their start and end coordinates. Write a program to find the intersection point of two line segments which is closest to the start point of the first segment. The input consists of the coordinates of the start and end points of each line segment. If there is no intersection point between any two line segments, the program should output \"No intersection point found\".\n\n[/Question 2]\n\n[Code 2]\n\nimport math\n\ndef find_intersection_distance(segment1, segment2):\n    x1, y1 = segment1[0]\n    x2, y2 = segment1[1]\n    x3, y3 = segment2[0]\n    x4, y4 = segment2[1]\n\n    def on_segment(x, y, p, q, r):\n        if (x <= max(p, r) and x >= min(p, r) and y <= max(q, r) and y >= min(q, r)):\n            return True\n        return False\n\n    def orientation(p, q, r):\n        val = (q - p) * (r - q) - (r - p) * (q - r)\n        if (val > 0):\n            return 1\n        elif (val < 0):\n            return 2\n        else:\n            return 0\n\n    o1 = orientation((x1, y1), (x2, y2), (x3, y3))\n    o2 = orientation((x1, y1), (x2, y2), (x4, y4))\n    o3 = orientation((x3, y3), (x4, y4), (x1, y1))\n    o4 = orientation((x3, y3), (x4, y4), (x2, y2))\n\n    if (o1 != o2 and o3 != o4):\n        return 0, (0, 0)\n\n    if (o1 == 0 and on_segment(x3, y3, x1, y1, x2) and on_segment(y3, y3, y1, y2)):\n        return math.sqrt((x1 - x3) ** 2 + (y1 - y3) ** 2), (x3, y3)\n\n    if (o2 == 0 and on_segment(x4, y4, x1, y1, x2) and on_segment(y4, y4, y1, y2)):\n        return math.sqrt((x1 - x4) ** 2 + (y1 - y4) ** 2), (x4, y4)\n\n    if (o3 == 0 and on_segment(x1, y1, x3, y3, x4) and on_segment(y1, y1, y3, y4)):\n        return math.sqrt((x3 - x1) ** 2 + (y3 - y1) ** 2), (x1, y1)\n\n    if (o4 == 0 and on_segment(x2, y2, x3, y3, x4) and on_segment(y2, y2, y3, y4)):\n        return math.sqrt((x3 - x2) ** 2 + (y3 - y2) ** 2), (x2, y2)\n\n    return float('inf'), (0, 0)\n\ndef closest_intersection_point(segments):\n    closest_distance = float('inf')\n    closest_point = (0, 0)\n    for i in range(len(segments)):\n        for j in range(i+1, len(segments)):\n            distance, intersection_point = find_intersection_distance(segments[i], segments[j])\n            if distance < closest_distance:\n                closest_distance = distance\n                closest_point = intersection_point\n    if closest_distance == float('inf'):\n        return \"No intersection point found\"\n    return closest_point\n\n[/Code 2]\n\n[Asserts 2]\n\nassert closest_intersection_point([[(1, 1), (10, 1)], [(1, 2), (10, 2)], [(1, 3), (10, 3)]])==(0, 0)\nassert closest_intersection_point([[(1, 1), (10, 1)], [(1, 2), (10, 2)], [(1, 5), (10, 5)]])==(0, 0)\nassert closest_intersection_point([[(1, 1), (10, 1)], [(1, 2), (10, 2)], [(1, 5), (5, 5)]])==(5, 5)\nassert closest_intersection_point([[(1, 1), (10, 1)], [(1, 2), (10, 2)], [(11, 5), (15, 5)]])==\"No intersection point found\"\nassert closest_intersection_point([[(1, 1), (10, 1)], [(1, 2), (10, 2)]])== \"No intersection point found\"\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.78}, {"few_shot_keywords": "['area', 'math', 'determinant', 'triangle', 'coordinates', 'absolute difference', 'algorithm', 'scalar', 'inside', 'geometry', 'point', 'function']", "test_keywords": "['determinant', 'triangle', 'coordinates', 'area', 'point', 'two pointers', 'algorithm', 'degrees', 'math', 'geometry', 'inside']", "prompt_tokens": 742, "total_tokens": 1000, "completion_tokens": 258, "completion": "[Question 2]\n\nGiven three points A(x1, y1), B(x2, y2), and C(x3, y3) of a triangle, write a function to calculate the area of the triangle using the coordinates of its vertices.\n\n[/Question 2]\n\n[Code 2]\n\ndef calculateTriangleArea(x1: int, y1: int, x2: int, y2: int, x3: int, y3: int) -> float:\n    area = abs((x1*(y2-y3) + x2*(y3-y1) + x3*(y1-y2)) / 2)\n    return area\n\n[/Code 2]\n\n[Asserts 2]\n\nassert calculateTriangleArea(0, 0, 3, 0, 0, 4)==6.0\nassert calculateTriangleArea(1, 1, 3, 4, 6, 8)==5.5\nassert calculateTriangleArea(8, 4, 3, 3, 3, 7)==10.5\nassert calculateTriangleArea(5, 5, 5, 5, 5, 5)==0.0\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.818}, {"few_shot_keywords": "['bitwise', 'operators', 'criteria', 'ways', 'integer', 'scalar', 'exponentiation', 'cumulative', 'multiplication', 'division', 'power']", "test_keywords": "['multiplication', 'operators', 'integer', 'exponentiation', 'division', 'power', 'bitwise', 'money', 'smallest difference', 'mirror']", "prompt_tokens": 494, "total_tokens": 674, "completion_tokens": 180, "completion": "[Question 2]\n\nYou are given an array of integers representing the prices of different items. Write a function to find the smallest difference between any two items and return the result.\n\n[/Question 2]\n\n[Code 2]\n\ndef smallestDifference(prices: List[int]) -> int:\n\tprices.sort()\n\tmin_diff = float('inf')\n\tfor i in range(len(prices) - 1):\n\t\tdiff = abs(prices[i] - prices[i + 1])\n\t\tif diff < min_diff:\n\t\t\tmin_diff = diff\n\treturn min_diff\n\n[/Code 2]\n\n[Asserts 2]\n\nassert smallestDifference([3, 6, 9, 12]) == 3\nassert smallestDifference([10, 15, 20, 25]) == 5\nassert smallestDifference([1, 8, 15, 22]) == 7", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.907}, {"few_shot_keywords": "['level order', 'sqrt', 'distinct', 'factorial', 'top to bottom', 'number', 'smallest', 'position', 'criteria', 'preorder', 'set', 'range', 'factors', 'math', 'prime']", "test_keywords": "['criteria', 'prime', 'distinct', 'factors', 'smallest', 'number', 'connected', 'Boyer Moore', 'range', 'sqrt', 'wall', 'set', 'math', 'root node', 'perfect square']", "prompt_tokens": 641, "total_tokens": 1013, "completion_tokens": 372, "completion": "[Question 2]\n\nGiven a connected graph with nodes labeled from 1 to N and an array representing the criteria for each node, where each criteria is a number. The task is to find the node with the smallest criteria value that is a perfect square of a prime number. Return the node label (number) that fulfills the criteria.\n\n[/Question 2]\n\n[Code 2]\n\nimport math\n\ndef isPrime(num):\n\tif num < 2:\n\t\treturn False\n\tfor i in range(2, int(math.sqrt(num)) + 1):\n\t\tif num % i == 0:\n\t\t\treturn False\n\treturn True\n\ndef smallestNodeWithCriteria(graph, criteria):\n\tsmallest_node = -1\n\tsmallest_criteria = float('inf')\n\tfor node, value in enumerate(criteria):\n\t\tif value >= 0:\n\t\t\tsqrt_val = math.sqrt(value)\n\t\t\tif sqrt_val.is_integer() and isPrime(int(sqrt_val)):\n\t\t\t\tif value < smallest_criteria:\n\t\t\t\t\tsmallest_criteria = value\n\t\t\t\t\tsmallest_node = node + 1\n\treturn smallest_node\n\n[/Code 2]\n\n[Asserts 2]\n\nassert smallestNodeWithCriteria([[1, 2], [2, 3], [3, 4]], [4, 9, 16])==3\nassert smallestNodeWithCriteria([[1, 2], [2, 3], [3, 4]], [1, 4, 9])==2\nassert smallestNodeWithCriteria([[1, 2], [2, 3], [3, 4]], [1, 8, 25])==3\nassert smallestNodeWithCriteria([[1, 2], [2, 3], [3, 4]], [1, 8, 10])==1\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.936}, {"few_shot_keywords": "['collections', 'greedy', 'combinations', 'algorithm', 'string', 'permutations', 'lexicographically', 'sorted', 'absolute difference', 'recursive']", "test_keywords": "['DFS', 'combinations', 'sorted', 'lexicographically', 'algorithm', 'string', 'positive', 'recursive', 'permutations']", "prompt_tokens": 671, "total_tokens": 879, "completion_tokens": 208, "completion": "[Question 2]\n\nGiven a string S, the task is to print all lexicographically sorted permutations of the string where each permutation contains only positive characters.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef sortedPositivePermutations(s: str) -> List[str]:\n    result = []\n    def dfs(s, path, result):\n        if not s:\n            result.append(''.join(path))\n            return\n        for i in range(len(s)):\n            if s[i].isnumeric():\n                dfs(s[:i] + s[i+1:], path + [s[i]], result)\n    dfs(s, [], result)\n    return sorted(result)\n\n[/Code 2]\n\n[Asserts 2]\n\nassert sortedPositivePermutations(\"abc\")==[\"abc\", \"acb\", \"bac\", \"bca\", \"cab\", \"cba\"]\nassert sortedPositivePermutations(\"a1b2\")==[\"ab12\", \"ab21\", \"ba12\", \"ba21\"]\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.902}, {"few_shot_keywords": "['weights', 'grid', 'generator', 'number', 'uniform', 'random', 'absolute difference', 'distribution', 'probability', 'cumulative']", "test_keywords": "['random', 'generator', 'lexicographically', 'reverse', 'uniform', 'probability', 'distribution', 'number', 'weights', 'cumulative']", "prompt_tokens": 507, "total_tokens": 756, "completion_tokens": 249, "completion": "[Question 2]\n\nDesign a random number generator that generates numbers in lexicographically reverse order based on a given probability distribution.\n\n[/Question 2]\n\n[Code 2]\n\nimport random\n\ndef reverseLexicoRand(weights: List[float], nums: List[int]) -> int:\n    cum_weights = [0.0]\n    \n    for w in weights:\n        cum_weights.append(cum_weights[-1] + w)\n    cum_weights = cum_weights[::-1]  # Reverse the cumulative weights\n    \n    r = random.uniform(0.0, cum_weights[0])\n    \n    for i, weight in enumerate(cum_weights):\n        if weight > r:\n            return nums[len(cum_weights) - i - 1]\n\n[/Code 2]\n\n[Asserts 2]\n\n# Example usage\nweights = [0.2, 0.3, 0.5]\nnums = [1, 2, 3]\nresult1 = reverseLexicoRand(weights, nums)\nassert result1 in nums\nresult2 = reverseLexicoRand(weights, nums)\nassert result2 in nums\nresult3 = reverseLexicoRand(weights, nums)\nassert result3 in nums\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.858}, {"few_shot_keywords": "['selection', 'sequence', 'Fibonacci', 'number', 'math', 'indexing', 'queue', 'nodes', 'euclidean distance']", "test_keywords": "['conditional', 'undirected', 'Fibonacci', 'math', 'sequence', 'number', 'increment', 'character']", "prompt_tokens": 573, "total_tokens": 948, "completion_tokens": 375, "completion": "[Question 2]\n\nWrite a Python function that takes a string as input and returns the count of Fibonacci numbers in the string. Assume that a Fibonacci number is any number that is present in the Fibonacci sequence.\n\nIn the given string, you need to identify the numerical characters and then check if any of the numbers formed by those characters are Fibonacci numbers. Return the count of Fibonacci numbers found in the string.\n\n[/Question 2]\n\n[Code 2]\n\ndef isPerfectSquare(x: int) -> bool:\n\ts = int(sqrt(x))\n\treturn s * s == x\n\ndef isFibonacci(n: int) -> bool:\n\treturn isPerfectSquare(5 * n * n + 4) or isPerfectSquare(5 * n * n - 4)\n\ndef countFibonacciInString(input_string: str) -> int:\n\tnumerical_chars = [char for char in input_string if char.isdigit()]\n\tnumbers = [int(''.join(num)) for num in re.findall(r'\\d+', input_string)]\n\tfibonacci_count = sum(1 for num in numbers if isFibonacci(num))\n\treturn fibonacci_count\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countFibonacciInString(\"The Fibonacci sequence is 0, 1, 1, 2, 3, 5, 8, 13, 21, 34.\")==8\nassert countFibonacciInString(\"The number 55 is a Fibonacci number.\")==1\nassert countFibonacciInString(\"Fibonacci numbers are interesting.\")==0\nassert countFibonacciInString(\"The sequence 144, 233, 377 are all Fibonacci numbers.\")==3\nassert countFibonacciInString(\"There are no Fibonacci numbers here.\")==0\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.72}, {"few_shot_keywords": "['factorial', 'LCA', 'manipulation', 'math', 'number', 'count', 'trailing zeroes', 'loop', 'division']", "test_keywords": "['number', 'count', 'loop', 'defaultdict', 'factorial', 'math', 'division', 'indexing', 'trailing zeroes', 'pair']", "prompt_tokens": 453, "total_tokens": 791, "completion_tokens": 338, "completion": "[Question 2]\n\nYou are given an array of numbers. Write a function to count the number of pairs of indices (i, j) such that i < j and the trailing zeroes in the factorial of the element at index i is less than the trailing zeroes in the factorial of the element at index j.\n\n[/Question 2]\n\n[Code 2]\n\nfrom collections import defaultdict\n\ndef countPairsWithTrailingZeroes(arr):\n    def countTrailingZeroes(num):\n        cnt = 0\n        i = 5\n        while (num // i >= 1):\n            cnt += num // i\n            i *= 5\n        return cnt\n    \n    trailing_zeroes_count = defaultdict(int)\n    pairs_count = 0\n    for i in range(len(arr)):\n        trailing_zeroes_count[countTrailingZeroes(arr[i])] += 1\n        for j in range(i+1, len(arr)):\n            if countTrailingZeroes(arr[i]) < countTrailingZeroes(arr[j]):\n                pairs_count += 1\n    \n    return pairs_count\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countPairsWithTrailingZeroes([5, 10, 15, 20, 25]) == 6\nassert countPairsWithTrailingZeroes([2, 4, 6, 8, 10]) == 0\nassert countPairsWithTrailingZeroes([3, 6, 9, 12, 15]) == 10\nassert countPairsWithTrailingZeroes([1, 3, 5, 7, 9]) == 0", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.819}, {"few_shot_keywords": "['find', 'LCA', 'random', '2D array', 'coverage', 'horizontal', 'generation', 'real numbers', 'probability', 'function']", "test_keywords": "['probability', 'full', 'real numbers', 'generation', 'function', 'anagrams', 'boolean', 'random', 'inserting', 'structure']", "prompt_tokens": 622, "total_tokens": 895, "completion_tokens": 273, "completion": "[Question 2]\n\nYou are given a list of strings and you need to write a function to randomly generate an anagram from the list based on the probabilities associated with each string. The probability of choosing a particular string as the anagram is proportional to its length.\n\nWrite a function \\(\\text{generateAnagram}\\) that takes a list of strings and generates an anagram with probabilities based on the lengths of the strings.\n\n[/Question 2]\n\n[Code 2]\n\nimport random\n\ndef generateAnagram(words):\n    word_lengths = [len(word) for word in words]\n    total_length = sum(word_lengths)\n    probabilities = [length / total_length for length in word_lengths]\n    chosen_word = random.choices(words, weights=probabilities, k=1)\n    return ''.join(sorted(chosen_word[0]))\n\n[/Code 2]\n\n[Asserts 2]\n\nassert generateAnagram(['cat', 'dog', 'bird']) in ['cat', 'dog', 'bird']\nassert generateAnagram(['apple', 'banana', 'orange', 'pear']) in ['apple', 'banana', 'orange', 'pear']\nassert generateAnagram(['elephant', 'giraffe', 'hippopotamus']) in ['elephant', 'giraffe', 'hippopotamus']\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.942}, {"few_shot_keywords": "['ASCII', 'character', 'conversion', 'column', 'title', 'Excel', 'selection', 'iteration', 'binary-search', 'math', 'positive integer']", "test_keywords": "['column', 'character', 'ASCII', 'iteration', 'conversion', 'title', 'Excel', 'generator', 'positive integer', 'math', 'row']", "prompt_tokens": 503, "total_tokens": 723, "completion_tokens": 220, "completion": "[Question 2]\n\nWrite a Python function that takes a positive integer and returns the corresponding column title in an Excel sheet. Additionally, implement a generator function to iterate through all column titles up to a given integer. \n\n[/Question 2]\n\n[Code 2]\n\ndef convertToTitle(columnNumber: int) -> str:\n    res = \"\"\n    while columnNumber > 0:\n        columnNumber -= 1\n        res = chr(columnNumber % 26 + ord('A')) + res\n        columnNumber //= 26\n    return res\n\ndef columnTitleGenerator(max_column: int):\n    current_column = 1\n    while current_column <= max_column:\n        yield convertToTitle(current_column)\n        current_column += 1\n\n[/Code 2]\n\n[Asserts 2]\n\nassert convertToTitle(1) == \"A\"\nassert convertToTitle(28) == \"AB\"\nassert convertToTitle(701) == \"ZY\"\nassert list(columnTitleGenerator(5)) == ['A', 'B', 'C', 'D', 'E']", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.888}, {"few_shot_keywords": "['2D list', 'time', 'shapes', 'math', 'brute force', 'anagrams', 'clock', 'angle', 'geometry', 'pairs']", "test_keywords": "['parent-pointer', 'geometry', 'math', 'clock', 'common', 'time', 'search', 'binary', 'angle']", "prompt_tokens": 504, "total_tokens": 831, "completion_tokens": 327, "completion": "[Question 2]\n\nGiven a sorted 2D list where each row is sorted in ascending order, write a function to search for a target value in the 2D list. The 2D list represents a clock, with each row containing the hour and minute angle. Return True if the target value is found in the clock, otherwise return False.\n\n[/Question 2]\n\n[Code 2]\n\ndef searchClock(clock: List[List[int]], target: int) -> bool:\n    rows = len(clock)\n    cols = len(clock[0])\n    left, right = 0, rows * cols - 1\n    while left <= right:\n        mid = (left + right) // 2\n        mid_val = clock[mid // cols][mid % cols]\n        if mid_val == target:\n            return True\n        elif mid_val < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return False\n\n[/Code 2]\n\n[Asserts 2]\n\nclock1 = [\n    [30, 60, 90],\n    [120, 150, 180],\n    [210, 240, 270]\n]\n\nclock2 = [\n    [0, 30, 60],\n    [90, 120, 150],\n    [180, 210, 240]\n]\n\nassert searchClock(clock1, 150) == True\nassert searchClock(clock1, 100) == False\nassert searchClock(clock2, 120) == True\nassert searchClock(clock2, 250) == False", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.757}]