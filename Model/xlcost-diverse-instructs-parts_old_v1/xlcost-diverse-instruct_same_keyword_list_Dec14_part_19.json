[{"few_shot_keywords": "['even', 'boolean', 'rotation', 'substring', 'clockwise', 'gcd', 'anti-clockwise', 'comparison', 'string']", "test_keywords": "['smallest element', 'rotation', 'substring', 'clockwise', 'index', 'anti-clockwise', 'iterating', 'comparison', 'doubly-linked', 'boolean', 'string', 'sqrt']", "prompt_tokens": 561, "total_tokens": 1062, "completion_tokens": 501, "completion": "[Question 2]\n\nYou are given a doubly-linked list and an integer K. The task is to find the smallest element in the sublist obtained by iterating the list from a specified index after rotating it either clockwise or anti-clockwise. Write a function to return the smallest element from the sublist.\n\n[/Question 2]\n\n[Code 2]\n\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.prev = None\n        self.next = None\n\ndef findSmallestElementAfterRotation(head: Node, index: int, isClockwise: bool) -> int:\n    if index < 0:\n        return -1  # Invalid index\n    if head is None:\n        return -1  # Empty list\n  \n    current = head\n    for _ in range(index):\n        if current.next is not None:\n            current = current.next\n        else:\n            return -1  # Index out of range\n\n    if isClockwise:\n        while current.prev is not None:\n            current = current.prev\n    else:\n        while current.next is not None:\n            current = current.next\n            \n    sublist = []\n    while current is not None:\n        sublist.append(current.data)\n        current = current.next\n\n    return min(sublist)\n\n[/Code 2]\n\n[Asserts 2]\n\n# Create a doubly-linked list: 1 <-> 2 <-> 3 <-> 4 <-> 5\nhead = Node(1)\nhead.next = Node(2)\nhead.next.prev = head\nhead.next.next = Node(3)\nhead.next.next.prev = head.next\nhead.next.next.next = Node(4)\nhead.next.next.next.prev = head.next.next\nhead.next.next.next.next = Node(5)\nhead.next.next.next.next.prev = head.next.next.next\n\nassert findSmallestElementAfterRotation(head, 2, True) == 3  # Clockwise rotation from index 2\nassert findSmallestElementAfterRotation(head, 3, False) == 2  # Anti-clockwise rotation from index 3\nassert findSmallestElementAfterRotation(head, 5, False) == 1  # Anti-clockwise rotation from last index\nassert findSmallestElementAfterRotation(head, 6, True) == -1  # Invalid index\nassert findSmallestElementAfterRotation(None, 2, True) == -1  # Empty list\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.927}, {"few_shot_keywords": "['series', 'pattern', 'string', 'deepest leaves', 'rotation', 'calculate', 'word', 'lexicographically', 'permutation', 'minimum', 'required', 'graph theory']", "test_keywords": "['series', 'pattern', 'string', 'factorial', 'map', 'binary', '1x1', 'consecutive', 'rotation', 'minimum', 'permutation', 'lexicographically']", "prompt_tokens": 513, "total_tokens": 784, "completion_tokens": 271, "completion": "[Question 2]\n\nGiven an integer n, calculate the lexicographically minimum string of length n that is a permutation of the string \"123...n\".\n\n[/Question 2]\n\n[Code 2]\n\ndef minLexPermutation(n: int) -> str:\n    factorial = 1\n    for i in range(2, n + 1):\n        factorial *= i\n    result = [str(i) for i in range(1, n + 1)]\n    for i in range(1, factorial):\n        j = n - 1\n        while result[j] > result[j + 1]:\n            j -= 1\n        k = n\n        while result[j] > result[k]:\n            k -= 1\n        result[j], result[k] = result[k], result[j]\n        result[j + 1:] = result[j + 1:][::-1]\n    return ''.join(result)\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minLexPermutation(3) == \"123\"\nassert minLexPermutation(5) == \"12345\"\nassert minLexPermutation(4) == \"1234\"\nassert minLexPermutation(1) == \"1\"\nassert minLexPermutation(6) == \"123456\"\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.724}, {"few_shot_keywords": "['countSetBits', 'set bits', 'even parity', 'doubly-linked', 'binary representation', 'convert', 'remove', 'URL', 'circular', 'coordinates', 'rectangular park', 'nodes', 'integer', 'linked list']", "test_keywords": "['Prufer sequence', 'inverting', 'integer', 'binary representation', 'even parity', 'linked list', 'countSetBits', 'nodes', 'remove', 'set bits', 'circular', 'coin', 'doubly-linked']", "prompt_tokens": 808, "total_tokens": 1336, "completion_tokens": 528, "completion": "[Question 2]\n\nYou are given a Prufer sequence and a circular doubly-linked list of nodes. Write a function to remove nodes from the circular doubly-linked list based on the inverting Prufer sequence. The inverting process involves converting the integer value of the node to its binary representation and then removing the node if the count of set bits is even.\n\n[/Question 2]\n\n[Code 2]\n\n# Class to create nodes of Circular Doubly LinkedList\nclass Node:\n\tdef __init__(self, data):\n\t\tself.data = data\n\t\tself.next = None\n\t\tself.prev = None\n\ndef createCircularDoublyLinkedList(arr, n):\n\tif n < 1:\n\t\treturn None\n\thead = Node(arr[0])\n\tprev = head\n\ttemp = head\n\tfor i in range(1, n):\n\t\ttemp = Node(arr[i])\n\t\tprev.next = temp\n\t\ttemp.prev = prev\n\t\tprev = temp\n\ttemp.next = head\n\thead.prev = temp\n\treturn head\n\n# Function to remove nodes based on inverting Prufer sequence\ndef removeNodesBasedOnPruferSequence(head, prufer_sequence):\n\tif (head == None):\n\t\treturn\n\n\tcurrent = head\n\twhile (current.next != head):\n\t\tnext = current.next\n\t\tif (countSetBits(current.data) % 2 == 0 and prufer_sequence):\n\t\t\tif (current == head):\n\t\t\t\thead = head.next\n\t\t\tcurrent.prev.next = current.next\n\t\t\tcurrent.next.prev = current.prev\n\t\tcurrent = next\n\n\tif (countSetBits(current.data) % 2 == 0 and prufer_sequence):\n\t\tif (current.next == current):\n\t\t\thead = None\n\t\telse:\n\t\t\tcurrent.prev.next = current.next\n\t\t\tcurrent.next.prev = current.prev\n\treturn head\n\n# Utility function to count the set bits in a number\ndef countSetBits(n):\n\tcount = 0\n\twhile (n):\n\t\tcount += n & 1\n\t\tn >>= 1\n\treturn count\n\n[/Code 2]\n\n[Asserts 2]\n\narr = [2, 3, 5, 7, 11, 13, 17]\nprufer_sequence = True\nn = len(arr)\nhead = createCircularDoublyLinkedList(arr, n)\nhead = removeNodesBasedOnPruferSequence(head, prufer_sequence)\nassert head.data == 3\nassert head.next.data == 5\nassert head.next.next.data == 7\nassert head.next.next.next.data == 11\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.831}, {"few_shot_keywords": "['structure', 'dynamic programming', 'maximum value', 'covering', 'input', 'function', 'remove', 'modification', 'insert', 'circular linked list', 'even digit sum', 'node']", "test_keywords": "['function', 'substring', 'left', 'modification', 'subarrays', 'remove', 'structure', 'insert', 'circular linked list', 'even digit sum', 'node']", "prompt_tokens": 812, "total_tokens": 1073, "completion_tokens": 261, "completion": "[Question 2]\n\nGiven a string, write a function to return the count of all substrings with even digit sum. The function should take the input string and return the count of such substrings.\n\n[/Question 2]\n\n[Code 2]\n\n# Function to check if the digit sum is even\ndef isEvenDigitSum(num):\n    sum = 0\n    while num > 0:\n        sum += num % 10\n        num = num // 10\n    return sum % 2 == 0\n\n# Function to return the count of substrings with even digit sum\ndef countEvenDigitSumSubstrings(s):\n    count = 0\n    for i in range(len(s)):\n        num = 0\n        for j in range(i, len(s)):\n            num = num * 10 + int(s[j])\n            if isEvenDigitSum(num):\n                count += 1\n    return count\n\n[/Code 2]\n\n[Asserts 2]\n\n# Test the function with a sample input\nassert countEvenDigitSumSubstrings(\"12345\") == 7\nassert countEvenDigitSumSubstrings(\"121\") == 5\nassert countEvenDigitSumSubstrings(\"1357\") == 4\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.876}, {"few_shot_keywords": "['Fibonacci sequence', 'integers', 'circular', 'word', 'concatenating', 'singly linked list', 'updated head node', 'occurrence', 'Fibonacci nodes', 'conditional', 'remove']", "test_keywords": "['BFS', 'Fibonacci nodes', 'updated head node', 'singly linked list', 'circular linked list', 'divisibility', 'circular', 'remove', 'integers', 'Fibonacci sequence', 'positive real number', 'gcd']", "prompt_tokens": 778, "total_tokens": 1333, "completion_tokens": 555, "completion": "[Question 2]\n\nYou are given a circular singly linked list of positive real numbers. Your task is to remove all nodes from the list that contain values which are Fibonacci numbers and are divisible by a common divisor of all the integers in the list.\n\nWrite a function to perform this operation using Breadth First Search (BFS) and return the updated head node of the circular singly linked list.\n\n[/Question 2]\n\n[Code 2]\n\nclass ListNode:\n    def __init__(self, value: float) -> None:\n        self.val = value\n        self.next = None\n\ndef isFibonacci(num: int) -> bool:\n    a, b = 0, 1\n    while a < num:\n        a, b = b, a + b\n        if a == num:\n            return True\n    return False\n\ndef gcd(a: int, b: int) -> int:\n    while b:\n        a, b = b, a % b\n    return a\n\ndef removeFibonacciDivisibleNodes(head: ListNode) -> ListNode:\n    if not head:\n        return None\n    \n    values = []\n    current = head\n    while True:\n        values.append(current.val)\n        current = current.next\n        if current == head:\n            break\n    \n    common_divisor = values[0]\n    for value in values[1:]:\n        common_divisor = gcd(common_divisor, int(value))\n    \n    queue = [head]\n    visited = set()\n    while queue:\n        node = queue.pop(0)\n        if isFibonacci(node.val) and int(node.val) % common_divisor == 0:\n            node.val = node.next.val\n            node.next = node.next.next\n        if node.next not in visited:\n            queue.append(node.next)\n            visited.add(node.next)\n        if node.next == head:\n            break\n    \n    return head\n\n[/Code 2]\n\n[Asserts 2]\n\n# Create a circular singly linked list 5.0 -> 3.0 -> 9.0 -> 2.0\nnode1 = ListNode(5.0)\nnode2 = ListNode(3.0)\nnode3 = ListNode(9.0)\nnode4 = ListNode(2.0)\nnode1.next = node2\nnode2.next = node3\nnode3.next = node4\nnode4.next = node1\n# Remove Fibonacci divisible nodes from the list\nnew_head = removeFibonacciDivisibleNodes(node1)\n# Check the values after removal\nassert new_head.val == 5.0\nassert new_head.next.val == 3.0\nassert new_head.next.next == new_head\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.768}]