[{"few_shot_keywords": "['consonants', 'cost', 'powers of 2', 'binary', 'math', 'origin', 'computation', 'bit', 'a']", "test_keywords": "['powers of 2', 'start', 'cost', 'language', 'loop', 'math', 'computation', 'select', 'binary', 'points']", "prompt_tokens": 482, "total_tokens": 647, "completion_tokens": 165, "completion": "[Question 2]\n\nWrite a program that takes a number n as input and computes the sum of the first n powers of 2.\n\n[/Question 2]\n\n[Code 2]\n\ndef sumOfPowersOf2(n):\n    total = 0\n    for i in range(1, n + 1):\n        total += 2 ** i\n    return total\n\n[/Code 2]\n\n[Asserts 2]\n\nassert sumOfPowersOf2(1) == 2\nassert sumOfPowersOf2(2) == 6\nassert sumOfPowersOf2(3) == 14\nassert sumOfPowersOf2(4) == 30\nassert sumOfPowersOf2(5) == 62\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.874}, {"few_shot_keywords": "['divisible', 'concatenating', 'integer', 'hashmap', 'array', 'sum', 'encrypted string', 'output', 'count', 'non-negative']", "test_keywords": "['array', 'math', 'integer', 'divisible', 'count', 'numeric string', 'sum', 'flips']", "prompt_tokens": 509, "total_tokens": 861, "completion_tokens": 352, "completion": "[Question 2]\n\nYou are given an array of numeric strings representing binary numbers. Your task is to find the minimum number of flips required to make the sum of all the binary numbers divisible by 3.\n\nWrite a function that takes the array of numeric strings as input and returns the minimum number of flips required to make the sum divisible by 3.\n\n[/Question 2]\n\n[Code 2]\n\ndef minFlipsToMakeDivisibleBy3(nums: List[str]) -> int:\n    count = 0\n    remainders = [0, 0]\n    for num in nums:\n        carry = 0\n        for i in range(len(num) - 1, -1, -1):\n            bit = int(num[i])\n            remainders[(i + 1) % 2] += (bit + carry) % 3\n            count += 1 if bit + carry > 1 else 0\n            carry = (bit + carry) // 2\n        remainders[0] %= 3\n        remainders[1] %= 3\n    return (3 - (remainders[0] + remainders[1]) % 3) % 3 if (remainders[0] + remainders[1]) % 3 != 0 else 0\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minFlipsToMakeDivisibleBy3([\"11\", \"10\", \"01\"]) == 2\nassert minFlipsToMakeDivisibleBy3([\"010\", \"011\", \"110\", \"111\"]) == 3\nassert minFlipsToMakeDivisibleBy3([\"111\", \"111\", \"111\"]) == 0", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.703}, {"few_shot_keywords": "['counting', 'vertical', 'combinatorics', 'search', 'queries', 'ways', 'modular arithmetic', 'coloring', 'subarray', 'dynamic programming']", "test_keywords": "['combinatorics', 'modular arithmetic', 'convex polygon', 'dictionary', 'coloring', 'ways', 'redundant', 'counting', 'dynamic programming', 'attack']", "prompt_tokens": 703, "total_tokens": 1217, "completion_tokens": 514, "completion": "[Question 2]\n\nYou are given a list of N points on a 2D plane. Your task is to find the number of ways to choose 3 points such that they form the vertices of a convex polygon. Return the count modulo 10^9 + 7.\n\nFor example, given the points [(0, 0), (1, 1), (2, 2), (3, 3)], the output should be 3, as there are 3 ways to form a convex polygon using these points: (0, 0), (1, 1), (2, 2) and (1, 1), (2, 2), (3, 3).\n\n[/Question 2]\n\n[Code 2]\n\ndef chooseConvexPolygon(points):\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else -1\n\n    N = len(points)\n    count = 0\n    for i in range(N):\n        slopes = []\n        for j in range(N):\n            if i != j:\n                slope = (points[j][1] - points[i][1]) / (points[j][0] - points[i][0] + 0.0000001)\n                slopes.append(slope)\n        slopes.sort()\n        for j in range(N-1):\n            for k in range(j+1, N-1):\n                if slopes[j] == slopes[k]:\n                    count += 1\n                    break\n    return count\n\n[/Code 2]\n\n[Asserts 2]\n\nassert chooseConvexPolygon([(0, 0), (1, 1), (2, 2), (3, 3)])==3\nassert chooseConvexPolygon([(0, 0), (1, 1), (2, 2), (2, 3), (3, 3)])==6\nassert chooseConvexPolygon([(1, 2), (3, 1), (4, 3), (5, 4)])==0\nassert chooseConvexPolygon([(1, 1), (2, 2), (3, 3)])==1\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.732}, {"few_shot_keywords": "['subset', 'ordered', 'array', 'index', 'integer', 'boolean', 'counting', 'value', 'XOR']", "test_keywords": "['strictly decreasing', 'occurrence', 'subsequences', 'integer', 'ordered', 'convex polygon', 'counting', 'subset', 'formatting', 'value', 'array', 'XOR']", "prompt_tokens": 548, "total_tokens": 817, "completion_tokens": 269, "completion": "[Question 2]\n\nYou are given an array of n integers. Write a function to count the number of strictly decreasing subsequences of the array, such that the XOR of all elements in each subsequence equals a given value X.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\nfrom collections import defaultdict\n\ndef countXorSubsequence(arr: List[int], X: int) -> int:\n    n = len(arr)\n    count = 0\n    dp = defaultdict(int)\n    for num in arr:\n        dp[num] += 1\n        for prev in dp:\n            if num < prev:\n                count += dp[prev]\n                dp[num] += dp[prev]\n    return count\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countXorSubsequence([3, 2, 1, 4], 2) == 4\nassert countXorSubsequence([5, 7, 2, 6, 1], 3) == 6\nassert countXorSubsequence([4, 3, 2, 1], 1) == 4\nassert countXorSubsequence([1, 2, 3, 4], 5) == 0\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.889}, {"few_shot_keywords": "['maximum', 'counting', 'common', 'divisible', 'parts', 'division', 'allowed moves', 'integer']", "test_keywords": "['maximum', 'distinct', 'parts', 'division', '2D array', 'sum', 'integer', 'counting', 'divisible']", "prompt_tokens": 469, "total_tokens": 709, "completion_tokens": 240, "completion": "[Question 2]\n\nYou are given a 2D array containing integers. Write a function to find the maximum sum of distinct parts of the array that are divisible by a given integer.\n\n[/Question 2]\n\n[Code 2]\n\ndef maxSumOfDistinctParts(arr: List[List[int]], divisor: int) -> int:\n    distinct_sums = set()\n    for row in arr:\n        for num in row:\n            if num % divisor == 0:\n                distinct_sums.add(num)\n    return sum(distinct_sums)\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maxSumOfDistinctParts([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == 18\nassert maxSumOfDistinctParts([[10, 20, 30], [40, 50, 60], [70, 80, 90]], 5) == 80\nassert maxSumOfDistinctParts([[11, 22, 33], [44, 55, 66], [77, 88, 99]], 4) == 88", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.876}, {"few_shot_keywords": "['range', 'integer', 'digit', 'while loop', 'distribution', 'counting', 'bits', 'occurs', 'inclusive']", "test_keywords": "['while loop', 'even', 'extract', 'coin', 'absolute difference', 'counting', 'inclusive', 'integer', 'occurs', 'digit', 'range']", "prompt_tokens": 577, "total_tokens": 929, "completion_tokens": 352, "completion": "[Question 2]\n\nYou are given a list of integers representing the results of tossing a fair coin. Write a function to extract the count of occurrences where the absolute difference between consecutive even numbers is an odd integer. The count should be inclusive of the first and last elements in the list.\n\n[/Question 2]\n\n[Code 2]\n\ndef countOddAbsoluteDiffInEvenIndices(results: List[int]) -> int:\n\tcount = 0\n\ti = 0\n\twhile i+1 < len(results):\n\t\tif results[i] % 2 == 0 and results[i+1] % 2 == 0:\n\t\t\tdiff = abs(results[i] - results[i+1])\n\t\t\tif diff % 2 != 0:\n\t\t\t\tcount += 1\n\t\ti += 1\n\treturn count\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countOddAbsoluteDiffInEvenIndices([1, 2, 3, 4, 5, 6, 7, 8, 9]) == 4\nassert countOddAbsoluteDiffInEvenIndices([2, 4, 6, 8, 10, 12]) == 2\nassert countOddAbsoluteDiffInEvenIndices([1, 3, 5, 7, 9, 11, 13]) == 0\nassert countOddAbsoluteDiffInEvenIndices([2, 5, 8, 3, 6, 9, 12]) == 3\nassert countOddAbsoluteDiffInEvenIndices([2, 4, 6, 8, 10, 12, 14, 16]) == 4\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.937}, {"few_shot_keywords": "['count', 'numbers', 'range', 'last digit', 'first digit', 'subset', 'frequency', 'direction']", "test_keywords": "['NOT', 'alphabet', 'range', 'dictionary', 'first digit', 'last digit', 'count', 'numbers']", "prompt_tokens": 477, "total_tokens": 664, "completion_tokens": 187, "completion": "[Question 2]\n\nGiven a dictionary containing ranges of numbers and their corresponding alphabets, write a function to count the total numbers in the ranges where the first and last digits are not the same.\n\n[/Question 2]\n\n[Code 2]\n\ndef countNumbersWithDifferentFirstAndLastDigit(d: dict) -> int:\n    cnt = 0\n    for key, value in d.items():\n        start, end = key.split('-')\n        for i in range(int(start), int(end) + 1):\n            if str(i)[0] != str(i)[-1]:\n                cnt += 1\n    return cnt\n\n[/Code 2]\n\n[Asserts 2]\n\ninput_dict = {\n    \"10-20\": \"A\",\n    \"100-120\": \"B\",\n    \"200-220\": \"C\"\n}\n\nassert countNumbersWithDifferentFirstAndLastDigit(input_dict) == 27", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.729}]