[{"few_shot_keywords": "['hyperperfect number', 'boolean', 'divisors', 'sqrt', 'math', 'triplets', 'positive integer', 'coordinates', 'sum']", "test_keywords": "['sum', 'shift', 'positive integer', 'boolean', 'divisors', 'sqrt', 'math', 'operations', 'prefix sum', 'hyperperfect number']", "prompt_tokens": 599, "total_tokens": 914, "completion_tokens": 315, "completion": "[Question 2]\n\nGiven a positive integer n, write a function that returns a boolean value indicating whether the given number is a Hyperperfect number. A number n is said to be Hyperperfect if the total sum of its divisors, excluding the number itself, is equal to 2n. For example, 28 is a Hyperperfect number because the sum of divisors (excluding 28) is (1 + 2 + 4 + 7 + 14) = 28 * 2. Implement the function isHyperperfect(n: int) -> bool to check if the given number is a Hyperperfect number or not.\n\n[/Question 2]\n\n[Code 2]\n\nimport math\n\ndef isHyperperfect(n: int) -> bool:\n    div_sum = 0\n    i = 1\n    while i <= math.sqrt(n):\n        if n % i == 0:\n            if n / i == i:\n                div_sum += i\n            else:\n                div_sum += (i + n // i)\n        i += 1\n    div_sum -= n  # Exclude the number itself from the sum of divisors\n    return div_sum == 2 * n\n\n[/Code 2]\n\n[Asserts 2]\n\nassert isHyperperfect(28) == True\nassert isHyperperfect(500) == False\nassert isHyperperfect(120) == True\nassert isHyperperfect(33550336) == True\nassert isHyperperfect(12) == False\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.815}, {"few_shot_keywords": "['increasing order', 'if-else', 'recursive', 'Fibonacci', 'sequence', 'range', 'integer', 'combinations', 'digits']", "test_keywords": "['digits', 'path', 'integer', 'combinations', 'greedy', 'tree', 'range', 'recursive', 'global variable', 'increasing order', 'sequence']", "prompt_tokens": 677, "total_tokens": 975, "completion_tokens": 298, "completion": "[Question 2]\n\nYou are given a binary tree where each node contains a single digit. Your task is to find the sum of all root-to-leaf numbers. A root-to-leaf path is a path from the root to any leaf node, where each node contains a single digit and the digits along the path form a number. Return the sum of all root-to-leaf numbers in increasing order.\n\n[/Question 2]\n\n[Code 2]\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef sumNumbers(root: TreeNode) -> int:\n    def dfs(node, path_sum):\n        if not node:\n            return 0\n        path_sum = path_sum*10 + node.val\n        if not node.left and not node.right:\n            return path_sum\n        return dfs(node.left, path_sum) + dfs(node.right, path_sum)\n\n    return dfs(root, 0)\n\n[/Code 2]\n\n[Asserts 2]\n\nassert sumNumbers(TreeNode(1, TreeNode(2), TreeNode(3))) == 25  # 12 + 13 = 25\nassert sumNumbers(TreeNode(4, TreeNode(9, TreeNode(5), TreeNode(1)), TreeNode(0))) == 1026  # 495 + 491 + 40 = 1026\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.73}, {"few_shot_keywords": "['string', 'even parity', 'multiplication', 'mismatch', 'large numbers', 'modulo', 'perfect square', 'nested loop', 'integer', 'math', 'leading zeros']", "test_keywords": "['arranged', 'math', 'integer', 'recursive', 'large numbers', 'multiplication', 'modulo', 'string']", "prompt_tokens": 560, "total_tokens": 757, "completion_tokens": 197, "completion": "[Question 2]\n\nYou are given a string representation of a large integer and an integer K. Write a recursive function to determine if the given large integer is a perfect square when multiplied by K. The function should return True if it's a perfect square, otherwise, return False.\n\n[/Question 2]\n\n[Code 2]\n\ndef isPerfectSquareMult(stringNum: str, K: int) -> bool:\n    num = int(stringNum)\n    product = num * K\n    if product < 0:\n        return False\n    sqrt_product = int(product ** 0.5)\n    return sqrt_product * sqrt_product == product\n\n[/Code 2]\n\n[Asserts 2]\n\nassert isPerfectSquareMult(\"123456789\", 2)==False\nassert isPerfectSquareMult(\"10000000000000000000\", 5)==True\nassert isPerfectSquareMult(\"987654321\", 3)==False\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.767}, {"few_shot_keywords": "['large number', 'modulo', 'divisible', 'check', 'subsets', 'first and last', 'power of 2', 'boolean']", "test_keywords": "['modulo', 'roots', 'check', 'matrix', 'large number', 'divisible', 'boolean']", "prompt_tokens": 446, "total_tokens": 683, "completion_tokens": 237, "completion": "[Question 2]\n\nGiven a large number n and a matrix of size n x n, the task is to check if the sum of the roots of all the elements in the matrix is divisible by 3 or not. If it is divisible by 3, then return True, otherwise return False.\n\n[/Question 2]\n\n[Code 2]\n\nimport math\n\ndef is_sum_of_roots_divisible_by_3(matrix: List[List[int]]) -> bool:\n    root_sum = sum([math.sqrt(x) for row in matrix for x in row])\n    return root_sum % 3 == 0\n\n[/Code 2]\n\n[Asserts 2]\n\nmatrix1 = [[4, 9], [16, 25]]\nmatrix2 = [[2, 3], [5, 6]]\nmatrix3 = [[1, 8], [9, 4]]\n\nassert is_sum_of_roots_divisible_by_3(matrix1) == True\nassert is_sum_of_roots_divisible_by_3(matrix2) == False\nassert is_sum_of_roots_divisible_by_3(matrix3) == False\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.85}, {"few_shot_keywords": "['edges', 'multiplication', 'first and last', 'division', 'factorization', 'integer', 'product', 'sqrt', 'prime', 'math', 'boolean', '0s', 'XOR']", "test_keywords": "['division', 'prime', 'product', 'relatively prime', 'integer', 'math', 'nested loops', 'boolean', 'factorization', 'multiplication', '2', 'string conversion']", "prompt_tokens": 589, "total_tokens": 854, "completion_tokens": 265, "completion": "[Question 2]\n\nWrite a function that takes in a positive integer n and returns True if n is a product of two distinct prime numbers, and False otherwise.\n\n[/Question 2]\n\n[Code 2]\n\ndef isProductOfDistinctPrimes(n: int) -> bool:\n    if n < 4:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            if isPrime(i) and isPrime(n // i) and i != n // i:\n                return True\n    return False\n\ndef isPrime(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, int(num ** 0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\n[/Code 2]\n\n[Asserts 2]\n\nassert isProductOfDistinctPrimes(15) == True\nassert isProductOfDistinctPrimes(20) == False\nassert isProductOfDistinctPrimes(21) == False\nassert isProductOfDistinctPrimes(77) == True\nassert isProductOfDistinctPrimes(13) == False\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.726}, {"few_shot_keywords": "['append', 'loop', 'number', 'break', 'condition', 'boolean', 'prefix', 'adjacent', 'digits', 'toggle', 'equation', 'integer']", "test_keywords": "['number', 'sub-arrays', 'append', 'break', 'maximum', 'count', 'condition', 'loop', 'integer', 'boolean', 'digits', 'search', 'string conversion']", "prompt_tokens": 738, "total_tokens": 999, "completion_tokens": 261, "completion": "[Question 2]\n\nGiven an array of integers, write a function to find the maximum count of sub-arrays with a sum not exceeding a given number K.\n\n[/Question 2]\n\n[Code 2]\n\ndef maxSubArrayCount(arr: List[int], K: int) -> int:\n    count = 0\n    total = 0\n    for num in arr:\n        if total + num <= K:\n            total += num\n        else:\n            total = num\n            count += 1\n    return count\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maxSubArrayCount([1, 2, 3, 4, 5], 8) == 3\nassert maxSubArrayCount([10, 20, 30, 40, 50], 100) == 1\nassert maxSubArrayCount([10, 20, 30, 40, 50], 20) == 5\nassert maxSubArrayCount([5, 5, 5, 5, 5], 10) == 2\nassert maxSubArrayCount([1, 2, 3, 4, 5], 3) == 5\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.846}, {"few_shot_keywords": "['integer', 'digits', 'frequency', 'condition', 'counting', 'sqrt', 'boolean', 'base']", "test_keywords": "['digits', 'frequency', 'difference', 'arithmetic', 'integer', 'non-negative', 'boolean', 'counting']", "prompt_tokens": 592, "total_tokens": 911, "completion_tokens": 319, "completion": "[Question 2]\n\nWrite a function to determine whether the difference between the most frequent digit and the least frequent digit in a given non-negative integer is an arithmetic sequence. If the difference is an arithmetic sequence, return True; otherwise, return False.\n\n\nFor example:\nIf the input integer is 5437, the frequency of 5 is 1, 4 is 1, 3 is 1, and 7 is 1. The difference between the most frequent digit (5) and the least frequent digit (3) is 2, which forms an arithmetic sequence. Therefore, the function should return True for this input.\n\n[/Question 2]\n\n[Code 2]\n\ndef isArithmeticSequence(x: int) -> bool:\n    freq = [0] * 10\n  \n    while (x) :\n        freq[x % 10] += 1\n        x = int(x / 10)\n  \n    freq = [x for x in freq if x > 0]\n    diff = max(freq) - min(freq)\n  \n    for i in range(1, len(freq)):\n        if freq[i] - freq[i-1] != diff:\n            return False\n    return True\n\n[/Code 2]\n\n[Asserts 2]\n\nassert isArithmeticSequence(5437)==True\nassert isArithmeticSequence(1010)==True\nassert isArithmeticSequence(13579)==False\nassert isArithmeticSequence(888)==True\nassert isArithmeticSequence(123456789)==True\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.918}, {"few_shot_keywords": "['occurs', 'math', 'dynamic programming', 'divisible', 'counting', 'check', 'number', 'triplets', 'string', 'product']", "test_keywords": "['divisible', 'string', '1', 'counting', 'check', 'math', 'horizontal', 'combinations', 'number']", "prompt_tokens": 483, "total_tokens": 676, "completion_tokens": 193, "completion": "[Question 2]\n\nGiven a string containing only the characters '0' and '1', the task is to count the number of substrings that start and end with '1'. Return the count of such substrings.\n\n[/Question 2]\n\n[Code 2]\n\ndef countSubstringsWithOnes(s: str) -> int:\n\tcount = 0\n\tfor i in range(len(s)):\n\t\tif s[i] == '1':\n\t\t\tcount += s[i+1:].count('1')\n\treturn count\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countSubstringsWithOnes(\"1011\") == 5\nassert countSubstringsWithOnes(\"1111\") == 10\nassert countSubstringsWithOnes(\"00100101\") == 6\nassert countSubstringsWithOnes(\"0000\") == 0\nassert countSubstringsWithOnes(\"1100110011\") == 12", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.91}]