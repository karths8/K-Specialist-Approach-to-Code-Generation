[{"few_shot_keywords": "['reverse', 'number', 'prime', 'task', 'pairs', 'range', 'optimization', 'math', 'count']", "test_keywords": "['prime', 'ascending', 'pairs', 'range', 'number', 'maximum distance', 'count', 'graph', 'math']", "prompt_tokens": 558, "total_tokens": 819, "completion_tokens": 261, "completion": "[Question 2]\n\nYou are given a range of numbers from L to R. Write a function to find the count of prime number pairs in the range where the second number is the first number + 6, and both numbers are prime. Return the count of such pairs in ascending order.\n\n[/Question 2]\n\n[Code 2]\n\ndef isPrime(n: int) -> bool:\n\tif n <= 1:\n\t\treturn False\n\tfor i in range(2, int(n**0.5) + 1):\n\t\tif n % i == 0:\n\t\t\treturn False\n\treturn True\n\ndef countAscendingPrimePairs(L: int, R: int) -> int:\n\tprime_pairs_count = 0\n\tfor i in range(L, R-6):\n\t\tif isPrime(i) and isPrime(i+6):\n\t\t\tprime_pairs_count += 1\n\treturn prime_pairs_count\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countAscendingPrimePairs(1, 20) == 2\nassert countAscendingPrimePairs(10, 30) == 2\nassert countAscendingPrimePairs(30, 50) == 2\nassert countAscendingPrimePairs(50, 100) == 6\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.85}, {"few_shot_keywords": "['smallest', 'rectangle', 'permutation', 'strictly increasing', 'string', 'undirected', 'dfs', 'remove', 'Sieve of Eratosthenes', 'lexicographically', 'characters']", "test_keywords": "['characters', 'remove', 'reverse', 'lexicographically', 'smallest', 'cost', 'permutation', 'removal', 'algorithm', 'string', 'term']", "prompt_tokens": 599, "total_tokens": 960, "completion_tokens": 361, "completion": "[Question 2]\n\nGiven a string str and an integer K, write a function to find the lexicographically smallest string that can be obtained by removing exactly K characters from the given string. Each removal operation costs a certain amount of money, and the goal is to minimize the total cost of removal.\n\n[/Question 2]\n\n[Code 2]\n\ndef minCostLexicographicallySmallest(s: str, K: int, cost: List[int]) -> str:\n    n = len(s)\n    stack = []\n    for i in range(n):\n        while stack and K and stack[-1] > s[i]:\n            stack.pop()\n            K -= 1\n        stack.append(s[i])\n\n    while K:\n        stack.pop()\n        K -= 1\n\n    res = \"\"\n    for ch in stack:\n        res += ch\n\n    return res\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minCostLexicographicallySmallest(\"abacedf\", 4, [1, 2, 3, 4, 5, 6, 7]) == \"aa\"\nassert minCostLexicographicallySmallest(\"abacedf\", 2, [1, 1, 1, 1, 1, 1, 1]) == \"abcd\"\nassert minCostLexicographicallySmallest(\"abacedf\", 6, [3, 2, 1, 4, 9, 2, 1]) == \"\"\nassert minCostLexicographicallySmallest(\"asdfghjkl\", 3, [1, 1, 1, 1, 1, 1, 1, 1, 1]) == \"ad\"\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.84}, {"few_shot_keywords": "['count', 'array', 'integer', 'indices', 'validation', 'modulo', 'product', 'math', 'pairs', 'odd', 'condition', 'even']", "test_keywords": "['even', 'count', 'array', 'integer', 'math', 'prime numbers', 'target', 'regular expression', 'product', 'odd', 'modulo', 'pairs']", "prompt_tokens": 605, "total_tokens": 876, "completion_tokens": 271, "completion": "[Question 2]\n\nWrite a function to find the count of pairs in an array whose sum is a prime number.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef countPairsWithPrimeSum(arr: List[int]) -> int:\n    def isPrime(n):\n        if n <= 1:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    count = 0\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            if isPrime(arr[i] + arr[j]):\n                count += 1\n    return count\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countPairsWithPrimeSum([1, 2, 3, 4, 5])==4\nassert countPairsWithPrimeSum([2, 2, 2, 2, 2, 2])==0\nassert countPairsWithPrimeSum([3, 7, 11, 13, 17, 19])==15\nassert countPairsWithPrimeSum([6, 4, 10, 15, 3, 9])==7\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.804}, {"few_shot_keywords": "['mergesort', 'positive integer', 'update', 'rearrange', 'queries', 'array', 'division', 'swaps', 'minimum', 'inversions', 'sort', 'triplet']", "test_keywords": "['array', 'bubble sort', 'search', 'inversions', 'maximum distance', 'swaps', 'reverse', 'sort', 'minimum', 'queries', 'update', 'rearrange', 'mergesort']", "prompt_tokens": 789, "total_tokens": 1356, "completion_tokens": 567, "completion": "[Question 2]\n\nYou are given an array and a set of queries that update the array. For each query, you need to output the maximum distance of inversions after the update is performed. An inversion in an array occurs when there are two indices i < j such that arr[i] > arr[j].\n\n[/Question 2]\n\n[Code 2]\n\ndef countInversions(arr):\n    def mergeSort(arr, temp, left, right):\n        inv_count = 0\n        if left < right:\n            mid = (left + right) // 2\n            inv_count += mergeSort(arr, temp, left, mid)\n            inv_count += mergeSort(arr, temp, mid + 1, right)\n            inv_count += merge(arr, temp, left, mid, right)\n        return inv_count\n\n    def merge(arr, temp, left, mid, right):\n        i = left\n        j = mid + 1\n        k = left\n        inv_count = 0\n\n        while i <= mid and j <= right:\n            if arr[i] <= arr[j]:\n                temp[k] = arr[i]\n                k += 1\n                i += 1\n            else:\n                temp[k] = arr[j]\n                k += 1\n                j += 1\n                inv_count += (mid - i + 1)\n\n        while i <= mid:\n            temp[k] = arr[i]\n            k += 1\n            i += 1\n\n        while j <= right:\n            temp[k] = arr[j]\n            k += 1\n            j += 1\n\n        for loop_var in range(left, right + 1):\n            arr[loop_var] = temp[loop_var]\n\n        return inv_count\n\n    n = len(arr)\n    temp = [0] * n\n    return mergeSort(arr, temp, 0, n - 1)\n\ndef maxDistanceOfInversions(arr, queries):\n    result = []\n    for query in queries:\n        idx, val = query\n        arr[idx] = val\n        inversions = countInversions(arr)\n        result.append(inversions)\n    return result\n\n[/Code 2]\n\n[Asserts 2]\n\narr = [1, 20, 6, 4, 5]\nqueries = [(3, 8), (1, 10)]\nassert maxDistanceOfInversions(arr, queries) == [8, 7]\narr = [9, 7, 5, 3, 1]\nqueries = [(4, 2), (2, 4), (5, 6)]\nassert maxDistanceOfInversions(arr, queries) == [10, 7, 5]\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.771}, {"few_shot_keywords": "['Shortest Path Faster Algorithm', 'binary tree', 'root', 'ranges', 'recursive', 'minimization', 'location', 'groups', 'value', 'node', 'smallest', 'path', 'count']", "test_keywords": "['recursive', 'smallest', 'trains', 'binary tree', 'path', 'root', 'minimization', 'task', 'level', 'node', 'count', 'reversals', 'longest', 'value']", "prompt_tokens": 649, "total_tokens": 1029, "completion_tokens": 380, "completion": "[Question 2]\n\nGiven a binary tree representing train tracks, where each node represents a station and its value represents the number of train reversals needed at that station, write a recursive function to find the longest path from the root to a leaf node while minimizing the number of reversals needed.\n\n[/Question 2]\n\n[Code 2]\n\nclass TreeNode:\n    def __init__(self, value=0, left=None, right=None):\n        self.value = value\n        self.left = left\n        self.right = right\n\ndef longestPathWithMinReversals(root: TreeNode, reversals=0) -> int:\n    if not root:\n        return 0\n    if not root.left and not root.right:\n        return 1\n    \n    left_path = longestPathWithMinReversals(root.left, root.value % 2 != reversals) if root.left else 0\n    right_path = longestPathWithMinReversals(root.right, root.value % 2 != reversals) if root.right else 0\n    \n    return max(left_path, right_path) + 1\n\n[/Code 2]\n\n[Asserts 2]\n\ntree1 = TreeNode(1, TreeNode(2, TreeNode(1), TreeNode(2)), TreeNode(1, TreeNode(1), TreeNode(2)))\ntree2 = TreeNode(0, TreeNode(1, TreeNode(0), TreeNode(1)), TreeNode(1, TreeNode(0), TreeNode(1)))\ntree3 = TreeNode(1, TreeNode(1, TreeNode(1), TreeNode(0)), TreeNode(0, TreeNode(0), TreeNode(1)))\nassert longestPathWithMinReversals(tree1) == 4\nassert longestPathWithMinReversals(tree2) == 3\nassert longestPathWithMinReversals(tree3) == 3\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.717}, {"few_shot_keywords": "['amount', 'vertices', 'Shortest Path Faster Algorithm', 'directed graph', 'weighted', 'binary search', 'negative cycle', 'edges', 'integers']", "test_keywords": "['negative cycle', 'representation', 'character', 'integers', 'vertices', 'weighted', 'edges', 'Shortest Path Faster Algorithm', 'directed graph', 'function']", "prompt_tokens": 666, "total_tokens": 1059, "completion_tokens": 393, "completion": "[Question 2]\n\nYou are given a directed graph with n vertices and m weighted edges. Each vertex is represented by a character. The weights of the edges are integers. \n\nWrite a function to find the shortest path from a given source vertex to all other vertices using the Shortest Path Faster Algorithm.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import Dict, List\nfrom collections import defaultdict\nclass Graph:\n\n\tdef __init__(self):\n\t\tself.graph:Dict[str, List[Tuple[str, int]]] = defaultdict(list)\n\n\tdef add_edge(self, u:str, v:str, w:int) -> None:\n\t\tself.graph[u].append((v, w))\n\n\tdef shortest_path(self, src:str) -> Dict[str, int]:\n\t\tdist:Dict[str, int] = {v: float('inf') for v in self.graph}\n\t\tdist[src] = 0\n\n\t\tfor _ in range(len(self.graph) - 1):\n\t\t\tfor u in self.graph:\n\t\t\t\tfor v, w in self.graph[u]:\n\t\t\t\t\tif dist[u] != float('inf') and dist[u] + w < dist[v]:\n\t\t\t\t\t\tdist[v] = dist[u] + w\n\n\t\treturn dist\n\n[/Code 2]\n\n[Asserts 2]\n\ng = Graph()\ng.add_edge('A', 'B', 3)\ng.add_edge('B', 'C', 4)\ng.add_edge('C', 'A', -2)\nresult = g.shortest_path('A')\nassert result == {'A': 0, 'B': 3, 'C': 1}\ng = Graph()\ng.add_edge('A', 'B', 3)\ng.add_edge('B', 'C', 4)\nresult = g.shortest_path('A')\nassert result == {'A': 0, 'B': 3, 'C': 7}\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.841}]