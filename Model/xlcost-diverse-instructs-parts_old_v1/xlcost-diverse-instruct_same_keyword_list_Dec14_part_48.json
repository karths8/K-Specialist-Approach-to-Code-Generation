[{"few_shot_keywords": "['contiguous', 'string', 'set', 'flipping', 'distinct', 'subsequences', 'non-decreasing', 'iteration', 'characters', 'insert']", "test_keywords": "['progression', 'characters', 'set', 'time', 'contiguous', 'subsequences', 'iteration', 'distinct', 'string']", "prompt_tokens": 465, "total_tokens": 669, "completion_tokens": 204, "completion": "[Question 2]\n\nGiven a string s, the task is to find the length of the longest contiguous subsequence of characters in s such that the characters form a non-decreasing progression.\n\n[/Question 2]\n\n[Code 2]\n\ndef longestNonDecreasingSubsequence(s: str) -> int:\n    n = len(s)\n    maxLength = 1\n    currentLength = 1\n    for i in range(1, n):\n        if s[i] >= s[i-1]:\n            currentLength += 1\n        else:\n            maxLength = max(maxLength, currentLength)\n            currentLength = 1\n    return max(maxLength, currentLength)\n\n[/Code 2]\n\n[Asserts 2]\n\nassert longestNonDecreasingSubsequence(\"abcabc\")==3\nassert longestNonDecreasingSubsequence(\"ab\")==2\nassert longestNonDecreasingSubsequence(\"aaa\")==3\nassert longestNonDecreasingSubsequence(\"a\")==1\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.928}, {"few_shot_keywords": "['non-negative', 'digit', 'integer', 'replace', 'maximize', 'source', 'steps', 'leftmost']", "test_keywords": "['calculation', 'replace', 'maximize', 'integer', 'sum', 'digit', 'leftmost', 'non-negative']", "prompt_tokens": 621, "total_tokens": 878, "completion_tokens": 257, "completion": "[Question 2]\n\nGiven a non-negative integer N, the task is to maximize the integer by replacing its leftmost digit with any other digit and calculate the sum of all digits in the resulting integer. Return the maximum possible sum that can be achieved after the replacement.\n\nFor example:\n\nIf N = 349, the maximum sum can be achieved by replacing the leftmost digit (3) with 8, resulting in the integer 849 and a sum of 8 + 4 + 9 = 21.\n\n[/Question 2]\n\n[Code 2]\n\ndef maxSumAfterReplacement(N: int) -> int:\n    N_str = str(N)\n    N_list = list(map(int, N_str))\n    max_sum = sum(N_list)\n    max_sum -= N_list[0]  # Subtract the leftmost digit\n    max_sum += 9  # Add 9 (maximum possible digit)\n    return max_sum\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maxSumAfterReplacement(349)==21\nassert maxSumAfterReplacement(821)==19\nassert maxSumAfterReplacement(456)==24\nassert maxSumAfterReplacement(123)==15\nassert maxSumAfterReplacement(7)==16\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.743}, {"few_shot_keywords": "['counting', 'multiplication', 'set', 'chr', 'range', 'index', 'digits']", "test_keywords": "['range', 'digits', 'multiples', 'counting', 'index', 'set', 'multiplication', 'largest area', 'size', 'minimize']", "prompt_tokens": 602, "total_tokens": 959, "completion_tokens": 357, "completion": "[Question 2]\n\nYou are given a list of integers representing the heights of walls. You need to find the largest rectangular area possible in a histogram formed by the wall heights. The area of each rectangle is the height of the wall multiplied by the number of consecutive walls of equal or greater height. You have to minimize the width of the rectangle and return the largest area that can be formed.\n\n[/Question 2]\n\n[Code 2]\n\ndef largestArea(heights: List[int]) -> int:\n    stack = []\n    max_area = 0\n    index = 0\n    while index < len(heights):\n        if (not stack) or (heights[index] >= heights[stack[-1]]):\n            stack.append(index)\n            index += 1\n        else:\n            top_of_stack = stack.pop()\n            area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index))\n            max_area = max(max_area, area)\n    while stack:\n        top_of_stack = stack.pop()\n        area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index))\n        max_area = max(max_area, area)\n    return max_area\n\n[/Code 2]\n\n[Asserts 2]\n\nassert largestArea([2, 1, 5, 6, 2, 3]) == 10\nassert largestArea([2, 4, 2, 1]) == 6\nassert largestArea([1, 2, 3, 4, 5]) == 9\nassert largestArea([5, 4, 3, 2, 1]) == 9", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.797}, {"few_shot_keywords": "['characters', 'carry', 'binary', 'string', 'adjacent', 'append', 'rearrange']", "test_keywords": "['rearrange', 'adjacent', 'string', 'binary', 'roots', 'increasing order', 'series', 'characters']", "prompt_tokens": 508, "total_tokens": 710, "completion_tokens": 202, "completion": "[Question 2]\n\nGiven a series of binary strings, rearrange the strings in such a way that the roots of the binary strings are in increasing order. Return the rearranged series of strings.\n\n[/Question 2]\n\n[Code 2]\n\nfrom math import sqrt\n\ndef rearrangeBinaryStrings(series):\n    def root(s):\n        return int(s, 2)\n\n    return sorted(series, key=lambda x: root(x))\n\n[/Code 2]\n\n[Asserts 2]\n\nassert rearrangeBinaryStrings([\"101\", \"110\", \"011\", \"100\"]) == ['011', '100', '101', '110']\nassert rearrangeBinaryStrings([\"111\", \"000\", \"001\", \"010\"]) == ['000', '001', '010', '111']\nassert rearrangeBinaryStrings([\"1010\", \"1100\", \"0110\", \"1001\"]) == ['0110', '1001', '1010', '1100']\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.702}, {"few_shot_keywords": "['sequence', 'arithmetic progression', 'math', 'function', 'node', 'term', 'res', 'series', 'hash table', 'boolean', 'sum']", "test_keywords": "['sequence', 'term', 'circle', 'consecutive heads', 'series', 'sum', 'graph', 'even', 'math', 'arithmetic progression']", "prompt_tokens": 557, "total_tokens": 786, "completion_tokens": 229, "completion": "[Question 2]\n\nYou are given a sequence of binary outcomes, where 1 represents heads and 0 represents tails, from a series of consecutive coin tosses. Your task is to find the sum of the lengths of the consecutive heads in the sequence.\n\nWrite a function to calculate the sum of the lengths of consecutive heads in the sequence.\n\n[/Question 2]\n\n[Code 2]\n\ndef sumOfConsecutiveHeads(sequence: str) -> int:\n    count = 0\n    sum = 0\n    for outcome in sequence:\n        if outcome == '1':\n            count += 1\n            sum += count\n        else:\n            count = 0\n    return sum\n\n[/Code 2]\n\n[Asserts 2]\n\nassert sumOfConsecutiveHeads('10111100110011') == 8\nassert sumOfConsecutiveHeads('1111100011101') == 15\nassert sumOfConsecutiveHeads('100011101111') == 5\nassert sumOfConsecutiveHeads('1111111111') == 55\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.925}, {"few_shot_keywords": "['divisible', 'digit', 'modulus', 'counting', 'integer', 'alternating', 'lexicographic']", "test_keywords": "['divisible', 'digit', 'distribution', 'counting', 'integer', 'rearranging', 'statistics', 'prefix', 'list']", "prompt_tokens": 484, "total_tokens": 781, "completion_tokens": 297, "completion": "[Question 2]\n\nGiven a list of integers, rearrange the list such that the integers are distributed in such a way that all the numbers which are divisible by a given integer K appear in the prefix of the list.\n\n[/Question 2]\n\n[Code 2]\n\ndef rearrangeList(nums: List[int], k: int) -> List[int]:\n    divisible_nums = [num for num in nums if num % k == 0]\n    non_divisible_nums = [num for num in nums if num % k != 0]\n    return divisible_nums + non_divisible_nums\n\n[/Code 2]\n\n[Asserts 2]\n\nassert rearrangeList([1, 2, 3, 4, 5, 6, 7, 8, 9], 3) == [3, 6, 9, 1, 2, 4, 5, 7, 8]\nassert rearrangeList([10, 20, 30, 40, 50, 60, 70, 80, 90], 10) == [10, 20, 30, 40, 50, 60, 70, 80, 90]\nassert rearrangeList([123, 456, 789, 101112, 131415], 2) == [456, 101112, 123, 789, 131415]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.858}, {"few_shot_keywords": "['loop', 'statistics', 'range', 'subarray', 'hash', 'size', 'integer', 'array', 'inside', 'count', 'permutation', 'conditional']", "test_keywords": "['count', 'size', 'array', 'loop', 'range', 'integer', 'conditional', 'hour', 'hash', 'arithmetic', 'subarray', 'algorithm', 'permutation']", "prompt_tokens": 755, "total_tokens": 996, "completion_tokens": 241, "completion": "[Question 2]\n\nGiven an array of integers representing the number of hours each employee worked, write a function to calculate the number of subarrays where the total hours worked fall within a given range.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef countSubarraysWithinRange(arr: List[int], lower: int, upper: int) -> int:\n    count = 0\n    prefixSum = 0\n    hashTable = {0: 1}\n    for hour in arr:\n        prefixSum += hour\n        for i in range(lower, upper+1):\n            if prefixSum - i in hashTable:\n                count += hashTable[prefixSum - i]\n        hashTable[prefixSum] = hashTable.get(prefixSum, 0) + 1\n    return count\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countSubarraysWithinRange([1, 2, 3, 4, 5], 3, 6) == 4\nassert countSubarraysWithinRange([3, 4, 2, 2, 4], 5, 7) == 7", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.941}]