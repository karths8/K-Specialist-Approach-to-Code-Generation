[{"few_shot_keywords": "['geometry', 'line', 'subtree', 'slope', 'math', 'equation', 'y-intercept', 'gaussian distribution']", "test_keywords": "['math', 'slope', 'phi', 'empty', 'y-intercept', 'linear equations', 'stack', 'equation', 'line', 'geometry', 'operations']", "prompt_tokens": 598, "total_tokens": 1069, "completion_tokens": 471, "completion": "[Question 2]\n\nImplement a program to solve a system of linear equations using the Gaussian elimination method. The input will be the coefficients of the equations, and the output will be the solution for each variable.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List, Tuple\n\ndef gaussianElimination(coefficients: List[List[float]]) -> List[float]:\n  n = len(coefficients)\n\n  for i in range(n):\n      maxElement = abs(coefficients[i][i])\n      maxRow = i\n      for k in range(i + 1, n):\n          if abs(coefficients[k][i]) > maxElement:\n              maxElement = abs(coefficients[k][i])\n              maxRow = k\n      for k in range(i, n + 1):\n          temp = coefficients[maxRow][k]\n          coefficients[maxRow][k] = coefficients[i][k]\n          coefficients[i][k] = temp\n      for k in range(i + 1, n):\n          c = -coefficients[k][i] / coefficients[i][i]\n          for j in range(i, n + 1):\n              if i == j:\n                  coefficients[k][j] = 0\n              else:\n                  coefficients[k][j] += c * coefficients[i][j]\n  x = [0 for i in range(n)]\n  for i in range(n - 1, -1, -1):\n      x[i] = coefficients[i][n] / coefficients[i][i]\n      for k in range(i - 1, -1, -1):\n          coefficients[k][n] -= coefficients[k][i] * x[i]\n  return x\n\n[/Code 2]\n\n[Asserts 2]\n\nassert gaussianElimination([[2, 1, 1, 8], [-3, -1, 2, -11], [-2, 1, 2, -3]]) == [2.0, 3.0, -1.0]\nassert gaussianElimination([[1, 1, 1, 6], [2, -1, 1, 8], [3, 2, -3, 7]]) == [1.0, 2.0, 3.0]\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.93}, {"few_shot_keywords": "['binary', 'function', 'regular', 'weighted mean', 'minimum', 'integer', 'calculation', 'polygon', 'form', 'number', 'representation']", "test_keywords": "['square root', 'polygon', 'calculation', 'regular', 'form', 'minimum', 'integer', 'binary', 'function', 'task', 'point', 'number', 'representation']", "prompt_tokens": 675, "total_tokens": 1086, "completion_tokens": 411, "completion": "[Question 2]\n\nGiven an integer 'n' and a point (x, y), write a function to calculate the minimum distance between the point (x, y) and any of the vertices of a regular polygon with n sides.\n\nThe regular polygon is formed by connecting the vertices of a regular n-sided polygon such that each vertex is at an equal distance from the center. The vertices are represented as (cos(2 * k * pi / n), sin(2 * k * pi / n)) where k takes values from 0 to n-1.\n\nWrite a function `minDistanceToPolygon` to calculate the minimum distance between the point (x, y) and any of the vertices of the regular polygon with n sides.\n\n[/Question 2]\n\n[Code 2]\n\nimport math\n\ndef minDistanceToPolygon(n, x, y):\n    min_dist = float('inf')\n    for k in range(n):\n        vertex_x = math.cos(2 * k * math.pi / n)\n        vertex_y = math.sin(2 * k * math.pi / n)\n        dist = math.sqrt((vertex_x - x) ** 2 + (vertex_y - y) ** 2)\n        min_dist = min(min_dist, dist)\n    return min_dist\n\n[/Code 2]\n\n[Asserts 2]\n\nassert math.isclose(minDistanceToPolygon(3, 1, 1), 0.5773502691896258, rel_tol=1e-9)\nassert math.isclose(minDistanceToPolygon(4, 0, 0), 1.0, rel_tol=1e-9)\nassert math.isclose(minDistanceToPolygon(5, 1, 1), 0.618033988749895, rel_tol=1e-9)\nassert math.isclose(minDistanceToPolygon(6, 2, 2), 1.7320508075688772, rel_tol=1e-9)\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.773}, {"few_shot_keywords": "['algorithm', 'integer', 'arrangement', 'pattern', 'gaussian distribution', 'index', 'list', 'calculation', 'triangle', 'math', 'maximum height', 'rearranging']", "test_keywords": "['Cartesian plane', 'polygon', 'time complexity', 'maximum height', 'math', 'triangle', 'calculation', 'tree traversal', 'rearranging', 'pattern', 'arrangement', 'maximize']", "prompt_tokens": 511, "total_tokens": 758, "completion_tokens": 247, "completion": "[Question 2]\n\nYou are given a list of points representing the vertices of a polygon on the Cartesian plane. Write a function to calculate the maximum height of the polygon when it is oriented such that its base lies parallel to the x-axis. The time complexity of the algorithm should be optimized to maximize efficiency.\n\n[/Question 2]\n\n[Code 2]\n\ndef maxPolygonHeight(points: List[Tuple[int, int]]) -> float:\n    max_height = 0\n    for i in range(len(points)):\n        current_height = abs(max(points, key=lambda x: x[1])[1] - min(points, key=lambda x: x[1])[1])\n        max_height = max(max_height, current_height)\n        points.append(points.pop(0))  # rearranging the points to calculate the height for different orientations\n    return max_height\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maxPolygonHeight([(0, 0), (0, 5), (4, 5), (4, 0)]) == 5\nassert maxPolygonHeight([(1, 1), (1, 3), (3, 3), (3, 1)]) == 2", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.757}, {"few_shot_keywords": "['optimal stopping', '2-D plane', 'float', 'simplify', 'subarray', 'point', 'gcd', 'distance', 'integral', 'count']", "test_keywords": "['count', 'comparison', '2-D plane', 'round', 'nested loop', 'distance', 'integral', 'swap', 'subtree', 'point', 'gcd']", "prompt_tokens": 510, "total_tokens": 813, "completion_tokens": 303, "completion": "[Question 2]\n\nGiven a list of points in a 2-D plane, write a function to find the count of pairs of points whose distance is an integral value. \n\n[/Question 2]\n\n[Code 2]\n\nfrom math import sqrt\n\ndef gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef countIntegralDistancePairs(points) -> int:\n    count = 0\n    n = len(points)\n    for i in range(n):\n        for j in range(i+1, n):\n            x1, y1 = points[i]\n            x2, y2 = points[j]\n            dx, dy = abs(x2 - x1), abs(y2 - y1)\n            distance = sqrt(dx*dx + dy*dy)\n            if distance.is_integer():\n                count += 1\n    return count\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countIntegralDistancePairs([(1, 1), (2, 2), (3, 3)])==2\nassert countIntegralDistancePairs([(1, 1), (1, 2), (1, 3), (2, 1), (2, 2), (2, 3)])==6\nassert countIntegralDistancePairs([(1, 1), (4, 4)])==1\nassert countIntegralDistancePairs([(1, 1), (1, 1)])==0", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.862}, {"few_shot_keywords": "['computation', 'square', 'points', 'substring', 'boolean', 'geometry', 'distance', 'equivalence relation', 'coordinates', 'product']", "test_keywords": "['check', 'points', 'coordinates', 'geometry', 'strategy', 'distance', 'boolean', 'square']", "prompt_tokens": 751, "total_tokens": 1037, "completion_tokens": 286, "completion": "[Question 2]\n\nYou are given a list of n points in the 2D plane, and you need to implement a function to check if any four points among the given points form a square.\n\n[/Question 2]\n\n[Code 2]\n\nfrom collections import defaultdict\n\ndef dist(p1, p2):\n    return (p1[0] - p2[0])**2 + (p1[1] - p2[1])**2\n\ndef isSquareFormed(points) -> bool:\n    n = len(points)\n    distMap = defaultdict(int)\n    for i in range(n):\n        for j in range(i+1, n):\n            d = dist(points[i], points[j])\n            distMap[d] += 1\n    for key, value in distMap.items():\n        if value >= 2 and (distMap[key*2] - value) >= 2:\n            return True\n    return False\n\n[/Code 2]\n\n[Asserts 2]\n\nassert isSquareFormed([[0, 0], [1, 1], [1, 0], [0, 1], [1, 2]])==True\nassert isSquareFormed([[0, 0], [1, 1], [1, 0], [0, 1], [2, 2]])==False\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.793}]