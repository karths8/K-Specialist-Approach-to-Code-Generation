[{"few_shot_keywords": "['counter', 'array', 'collection', 'minimize', 'max', 'set bits', 'min', 'frequency', 'difference', 'game', 'integers']", "test_keywords": "['array', 'integers', 'frequency', 'min', 'difference', 'collection', 'repeat', 'max', 'point', 'addition', 'counter']", "prompt_tokens": 570, "total_tokens": 867, "completion_tokens": 297, "completion": "[Question 2]\n\nGiven an array of integers, find the maximum frequency of any repeated integer and return the sum of all integers that have that frequency.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\nfrom collections import Counter\n\ndef maxFreqSum(arr: List[int]) -> int:\n    freq = Counter(arr)\n    max_freq = max(freq.values())\n    result = sum(key for key, value in freq.items() if value == max_freq)\n    return result\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maxFreqSum([1, 2, 3, 4, 5, 4, 3, 2, 1, 1, 2, 2, 3])==12\nassert maxFreqSum([4, 4, 4, 4, 4, 4, 4, 4, 4])==36\nassert maxFreqSum([1, 1, 1, 2, 2, 3, 3, 3, 3, 3, 3])==18\nassert maxFreqSum([10, 20, 20, 10, 10, 30, 30, 30, 30, 20, 20, 10])==120\nassert maxFreqSum([1, 2, 3, 4, 5])==15\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.895}, {"few_shot_keywords": "['operation', 'statistics', 'index', 'integers', 'bitwise XOR', 'array', 'circular', 'minimum', 'elements', 'reduce', 'decrement', 'binary search', 'subarray']", "test_keywords": "['decrement', 'elements', 'subarray', 'reduce', 'operation', 'move', 'trees', 'integers', 'Square Root Decomposition', 'array', 'minimum', 'length']", "prompt_tokens": 591, "total_tokens": 918, "completion_tokens": 327, "completion": "[Question 2]\n\nGiven an array of integers, implement a function to find the length of the minimum subarray such that after decrementing all the elements of that subarray, the sum of the array becomes less than a given integer 'k'.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef minSubarrayLength(arr: List[int], k: int) -> int:\n    n = len(arr)\n    res = float('inf')\n    start = 0\n    curr_sum = 0\n    for end in range(n):\n        curr_sum += arr[end]\n        while curr_sum >= k:\n            res = min(res, end - start + 1)\n            curr_sum -= arr[start]\n            start += 1\n    return res if res != float('inf') else 0\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minSubarrayLength([1, 4, 45, 6, 0, 19], 51) == 2\nassert minSubarrayLength([1, 10, 5, 2, 7], 9) == 1\nassert minSubarrayLength([1, 11, 100, 1, 0, 200, 2, 3, 1, 0, 4], 280) == 4\nassert minSubarrayLength([1, 4, 16, 22, 5, 7, 8, 9, 10], 95) == 6\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.928}, {"few_shot_keywords": "['nodes', 'mapping', 'iterative', 'structure', 'coverage', 'value', 'identical', 'binary tree']", "test_keywords": "['value', 'binary tree', 'fairness', 'nodes', 'employee', 'triplet', 'identical', 'GCD', 'structure', 'iterative']", "prompt_tokens": 659, "total_tokens": 1097, "completion_tokens": 438, "completion": "[Question 2]\n\nYou are given a binary tree where each node represents an employee and the value of the node represents the rating of the employee. Write an iterative function to find the triplet of employees in the tree that have the highest \"fairness\" score. The fairness score of a triplet is calculated by taking the greatest common divisor (GCD) of the ratings of the three employees in the triplet.\n\n[/Question 2]\n\n[Code 2]\n\nfrom math import gcd\nfrom collections import deque\n\nclass TreeNode:\n    def __init__(self, value=0, left=None, right=None):\n        self.value = value\n        self.left = left\n        self.right = right\n\ndef fairnessScore(root: TreeNode) -> int:\n    def calculateFairnessScore(triplet):\n        return gcd(triplet[0].value, gcd(triplet[1].value, triplet[2].value))\n\n    max_score = 0\n    queue = deque([root])\n    \n    while queue:\n        node = queue.popleft()\n        if node.left and node.right:\n            triplet1 = [node, node.left, node.right]\n            triplet2 = [node, node.right, node.left]\n            score1 = calculateFairnessScore(triplet1)\n            score2 = calculateFairnessScore(triplet2)\n            max_score = max(max_score, score1, score2)\n            queue.append(node.left)\n            queue.append(node.right)\n    \n    return max_score\n\n[/Code 2]\n\n[Asserts 2]\n\ntree1 = TreeNode(10, TreeNode(8, TreeNode(12), TreeNode(15)), TreeNode(7, TreeNode(9), TreeNode(12)))\nassert fairnessScore(tree1)==8\ntree2 = TreeNode(5, TreeNode(7, TreeNode(15), TreeNode(10)), TreeNode(3, TreeNode(9), TreeNode(4)))\nassert fairnessScore(tree2)==5\ntree3 = TreeNode(20, TreeNode(20, TreeNode(20), TreeNode(20)), TreeNode(20, TreeNode(20), TreeNode(20)))\nassert fairnessScore(tree3)==20\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.822}, {"few_shot_keywords": "['edges', 'connected component', 'queries', 'vacate', 'graph', 'combinations', 'vertices', 'undirected']", "test_keywords": "['smallest', 'queries', 'connected component', 'absolute differences', 'product', 'undirected', 'vertices', 'edges', 'graph', 'binary-search']", "prompt_tokens": 600, "total_tokens": 943, "completion_tokens": 343, "completion": "[Question 2]\n\nGiven an undirected graph with N vertices and M edges, for each query, the task is to find the smallest absolute difference of product of vertices in the connected component of the given vertex.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List, Tuple\n\ndef smallestProductDifference(graph: List[List[int]], queries: List[int]) -> List[int]:\n    def dfs(node, visited, graph, vertices):\n        visited[node] = True\n        vertices.append(node)\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                dfs(neighbor, visited, graph, vertices)\n\n    def productOfVertices(vertices):\n        product = 1\n        for vertex in vertices:\n            product *= vertex\n        return product\n\n    result = []\n    for query in queries:\n        visited = [False] * len(graph)\n        connectedVertices = []\n        dfs(query, visited, graph, connectedVertices)\n        products = [productOfVertices(connectedVertices)]\n        for i in connectedVertices:\n            tempVisited = [False] * len(graph)\n            tempVertices = []\n            dfs(i, tempVisited, graph, tempVertices)\n            if len(tempVertices) > 1:\n                products.append(productOfVertices(tempVertices))\n        products.sort()\n        result.append(abs(products[0] - products[1]))\n    return result\n\n[/Code 2]\n\n[Asserts 2]\n\ngraph = [[1, 2], [0, 2], [0, 1], [4], [3]]\nqueries = [0, 3]\nassert smallestProductDifference(graph, queries) == [0, 1]\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.751}, {"few_shot_keywords": "['subset', 'triplets', 'absolute difference', 'maximum', 'array', 'sum', 'increment', 'divide', 'manipulation', 'subsequence']", "test_keywords": "['array', 'divide', 'absolute difference', 'binary tree', 'sum', 'maximum', 'subset', 'bfs']", "prompt_tokens": 563, "total_tokens": 891, "completion_tokens": 328, "completion": "[Question 2]\n\nGiven a binary tree, write a function to find the maximum absolute difference between the sums of nodes at even level and nodes at odd level. Implement the solution using BFS traversal of the tree.\n\n[/Question 2]\n\n[Code 2]\n\nclass TreeNode:\n    def __init__(self, value=0, left=None, right=None):\n        self.value = value\n        self.left = left\n        self.right = right\n\nfrom collections import deque\ndef maxAbsDifference(root: TreeNode) -> int:\n    if not root:\n        return 0\n    queue = deque([(root, 1)])\n    evenSum, oddSum = 0, 0\n    while queue:\n        node, level = queue.popleft()\n        if level % 2 == 0:\n            evenSum += node.value\n        else:\n            oddSum += node.value\n        if node.left:\n            queue.append((node.left, level + 1))\n        if node.right:\n            queue.append((node.right, level + 1))\n    return abs(evenSum - oddSum)\n\n[/Code 2]\n\n[Asserts 2]\n\ntree1 = TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(5)), TreeNode(3, TreeNode(6), TreeNode(7)))\nassert maxAbsDifference(tree1)==4\n\ntree2 = TreeNode(4, TreeNode(9, TreeNode(5), TreeNode(1)), TreeNode(6, TreeNode(3), TreeNode(2)))\nassert maxAbsDifference(tree2)==9\n\ntree3 = None\nassert maxAbsDifference(tree3)==0", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.848}, {"few_shot_keywords": "['query', 'edges', 'defaultdict', 'binary tree', 'count', 'DFS', 'graph', 'path', 'tree', 'adjacent pairs', 'node']", "test_keywords": "[\"MO's algorithm\", 'node', 'tree', 'edges', 'query', 'defaultdict', 'path', 'count', 'graph', 'modulus', 'DFS', 'maximum']", "prompt_tokens": 666, "total_tokens": 1341, "completion_tokens": 675, "completion": "[Question 2]\n\nYou are given a tree with N nodes and Q queries. Each query consists of a node v and an integer k. For each query, find the maximum value of the count of distinct nodes on the path from the root to node v, such that the count of distinct nodes is less than or equal to k.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List, Tuple\nfrom collections import defaultdict\n\ndef maximumDistinctNodesCount(tree: List[Tuple[int, int]], Q: int, queries: List[Tuple[int, int]]) -> List[int]:\n    graph = defaultdict(list)\n    \n    for edge in tree:\n        u, v = edge\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    eulerTour = []\n    firstOccurrence = {}\n    level = {}\n    \n    def dfs(u, par, lvl):\n        firstOccurrence[u] = len(eulerTour)\n        eulerTour.append(u)\n        level[u] = lvl\n        for v in graph[u]:\n            if v != par:\n                dfs(v, u, lvl + 1)\n                eulerTour.append(u)\n    \n    dfs(1, 0, 0)\n    \n    blockSize = int(2 * (len(eulerTour) ** 0.5))\n    \n    def MOAlgorithm(l, r):\n        count = defaultdict(int)\n        maxDistinctNodes = 0\n        for i in range(l, r + 1):\n            count[eulerTour[i]] += 1\n            if count[eulerTour[i]] == 1:\n                maxDistinctNodes += 1\n        return maxDistinctNodes\n    \n    result = []\n    for query in queries:\n        v, k = query\n        l = firstOccurrence[v]\n        r = firstOccurrence[v] + level[v]\n        if l > r:\n            l, r = r, l\n        lcaBlock = l // blockSize\n        rBlock = r // blockSize\n        maxDistinct = 0\n        if lcaBlock == rBlock:\n            maxDistinct = MOAlgorithm(l, r)\n        else:\n            end = min((lcaBlock + 1) * blockSize - 1, len(eulerTour) - 1)\n            maxDistinct = MOAlgorithm(l, end)\n            for i in range(lcaBlock + 1, rBlock):\n                maxDistinct = max(maxDistinct, MOAlgorithm(i * blockSize, (i + 1) * blockSize - 1))\n            maxDistinct = max(maxDistinct, MOAlgorithm(rBlock * blockSize, r))\n        result.append(min(maxDistinct, k))\n    \n    return result\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maximumDistinctNodesCount([(1, 2), (1, 3), (2, 4), (2, 5)], 3, [(2, 2), (3, 1), (4, 3)]) == [2, 1, 2]\nassert maximumDistinctNodesCount([(1, 2), (2, 3), (3, 4), (3, 5)], 2, [(5, 2), (4, 2)]) == [2, 2]\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.785}]