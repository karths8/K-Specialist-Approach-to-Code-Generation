[{"few_shot_keywords": "['alternately', 'edge', 'weight', 'smallest', 'check sum digit', 'minimization', 'grid', 'product', 'removing', 'dynamic programming', 'path', 'value', 'individual']", "test_keywords": "['edge', 'dynamic programming', 'path', 'product', 'value', 'insert', 'unique paths', 'smallest', 'weight', 'minimization', 'grid']", "prompt_tokens": 755, "total_tokens": 1151, "completion_tokens": 396, "completion": "[Question 2]\n\nGiven a grid with weights on its edges, we need to find the smallest product of the weights along a unique path from the top-left corner to the bottom-right corner, with the constraint that we are allowed to insert additional edges in the grid to minimize the product.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef uniquePathsWithMinProduct(grid: List[List[int]]) -> int:\n    m, n = len(grid), len(grid[0])\n    dp = [[float('inf')] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(m):\n        for j in range(n):\n            if i + 1 < m:\n                dp[i + 1][j] = min(dp[i + 1][j], max(dp[i][j], grid[i + 1][j]))\n            if j + 1 < n:\n                dp[i][j + 1] = min(dp[i][j + 1], max(dp[i][j], grid[i][j + 1]))\n\n    return dp[-1][-1]\n\n[/Code 2]\n\n[Asserts 2]\n\nassert uniquePathsWithMinProduct([[1, 3, 1], [1, 5, 1], [4, 2, 1]]) == 8\nassert uniquePathsWithMinProduct([[2, 1, 3], [1, 4, 6], [3, 2, 4]]) == 12\nassert uniquePathsWithMinProduct([[1, 2, 3, 4], [4, 3, 2, 1], [5, 6, 7, 8]]) == 2\nassert uniquePathsWithMinProduct([[1, 1], [1, 1]]) == 1\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.781}, {"few_shot_keywords": "['iteration', 'blocks', 'query', 'subarray', 'binary', 'Indian', 'decimal', 'tuple', 'strictly decreasing', 'array', 'inclusive', 'index']", "test_keywords": "['index', 'filled', 'decimal', 'query', 'pair', 'LCS', 'binary', 'node sum', 'array', 'inclusive', 'subarray', 'tuple', 'iteration', 'cost']", "prompt_tokens": 726, "total_tokens": 1105, "completion_tokens": 379, "completion": "[Question 2]\n\nYou are given an array of decimal numbers. Write a function to find the subarray with the maximum sum of elements and return the starting and ending indices of the subarray in a tuple.\n\nFor example, given the array [1, -3, 2, 1, -1], the subarray with the maximum sum is [2, 1], and the function should return the tuple (2, 3).\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List, Tuple\ndef maxSumSubarray(arr: List[int]) -> Tuple[int, int]:\n    max_sum = float('-inf')\n    current_sum = 0\n    start = 0\n    end = 0\n    s = 0\n\n    for i in range(len(arr)):\n        current_sum += arr[i]\n        if current_sum > max_sum:\n            max_sum = current_sum\n            start = s\n            end = i\n        if current_sum < 0:\n            current_sum = 0\n            s = i + 1\n    return (start, end)\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maxSumSubarray([1, -3, 2, 1, -1]) == (2, 3)\nassert maxSumSubarray([-2, -3, 4, -1, -2, 1, 5, -3]) == (2, 6)\nassert maxSumSubarray([1, 2, 3, 4, -10, 6, 7, 8]) == (5, 7)\nassert maxSumSubarray([1, 2, -20, 4, 5, 6, 7, 8]) == (3, 7)\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.917}, {"few_shot_keywords": "['factor', 'frequency', 'count', 'multiple', 'range', 'math', 'divisor', 'odd divisors', 'domain name', 'unique paths']", "test_keywords": "['divisor', 'count', 'infinite', 'multiple', 'shortest path', 'increment', 'factor', 'range', 'math']", "prompt_tokens": 462, "total_tokens": 696, "completion_tokens": 234, "completion": "[Question 2]\n\nYou are given a list of integers. Write a function to count the number of elements which have a factor greater than 1 and are divisible by their index position.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef countElementsWithFactorAndDivisibility(nums: List[int]) -> int:\n    count = 0\n    for i in range(1, len(nums)):\n        if nums[i] % i == 0:\n            for j in range(2, nums[i]):\n                if nums[i] % j == 0:\n                    count += 1\n                    break\n    return count\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countElementsWithFactorAndDivisibility([6, 4, 10, 9, 12]) == 3\nassert countElementsWithFactorAndDivisibility([8, 7, 4, 15, 9]) == 2\nassert countElementsWithFactorAndDivisibility([5, 9, 11, 13, 16]) == 4\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.874}, {"few_shot_keywords": "['binary', 'math', 'water', 'representation', 'loop', 'counting', 'integer', 'repetitions', 'enumeration', 'minimum', 'flip']", "test_keywords": "['integer', 'time', 'iteration', 'minimum', 'counting', 'binary', 'math', 'even', 'representation', 'loop']", "prompt_tokens": 458, "total_tokens": 642, "completion_tokens": 184, "completion": "[Question 2]\n\nWrite a function to calculate the minimum number of iterations required to represent an integer N as a sum of even numbers, and return the count of even numbers used in the representation.\n\n[/Question 2]\n\n[Code 2]\n\ndef minEvenSumRepresentation(N: int) -> (int, int):\n    count = 0\n    while (N > 0):\n        if N % 2 == 0:\n            count += 1\n        N -= 2\n    return count, count\n\n[/Code 2]\n\n[Asserts 2]\n\nassert(minEvenSumRepresentation(10)) == (5, 5)\nassert(minEvenSumRepresentation(21)) == (10, 10)\nassert(minEvenSumRepresentation(32)) == (16, 16)\nassert(minEvenSumRepresentation(7)) == (3, 3)\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.947}, {"few_shot_keywords": "['items', 'prefix', 'root', 'integer', 'maximum', 'XOR', 'sum', 'range', 'set']", "test_keywords": "['integer', 'check sum digit', 'maximum', 'XOR', 'set', 'multiplication', 'strings', 'prefix', 'range', 'sum']", "prompt_tokens": 569, "total_tokens": 789, "completion_tokens": 220, "completion": "[Question 2]\n\nGiven two non-negative integers num1 and num2 represented as string, the task is to return the sum of the integers as a string.\n\n[/Question 2]\n\n[Code 2]\n\ndef addStrings(num1: str, num2: str) -> str:\n    res = ''\n    carry = 0\n    i, j = len(num1)-1, len(num2)-1\n    \n    while i >= 0 or j >= 0 or carry:\n        if i >= 0:\n            carry += int(num1[i])\n            i -= 1\n        if j >= 0:\n            carry += int(num2[j])\n            j -= 1\n        res = str(carry%10) + res\n        carry //= 10\n        \n    return res\n\n[/Code 2]\n\n[Asserts 2]\n\nassert addStrings(\"11\", \"123\") == \"134\"\nassert addStrings(\"456\", \"77\") == \"533\"\nassert addStrings(\"0\", \"0\") == \"0\"\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.864}, {"few_shot_keywords": "['element', 'present', 'search', 'array', 'queries', 'max', 'boolean', 'string manipulation', 'PIN', 'insert', 'range']", "test_keywords": "['search', 'range', 'present', 'array', 'math', 'undirected', 'lowest common', 'queries', 'element', 'boolean']", "prompt_tokens": 635, "total_tokens": 1088, "completion_tokens": 453, "completion": "[Question 2]\n\nGiven an undirected graph represented as an adjacency list and a set of queries, each query containing a pair of nodes, find the lowest common ancestor for each pair of nodes in the graph.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List, Tuple, Dict\n\nclass Graph:\n\tdef __init__(self, graph_dict: Dict[int, List[int]]):\n\t\tself.graph = graph_dict\n\n\tdef lowestCommonAncestor(self, u: int, v: int) -> int:\n\t\tancestors_u = set()\n\t\twhile u in self.graph:\n\t\t\tancestors_u.add(u)\n\t\t\tu = self.graph[u]\n\n\t\twhile v in self.graph:\n\t\t\tif v in ancestors_u:\n\t\t\t\treturn v\n\t\t\tv = self.graph[v]\n\n\t\treturn -1  # No common ancestor found\n\ndef processQueries(graph: Graph, queries: List[Tuple[int, int]]) -> List[int]:\n\tresult = []\n\tfor pair in queries:\n\t\tu, v = pair\n\t\tresult.append(graph.lowestCommonAncestor(u, v))\n\treturn result\n\n[/Code 2]\n\n[Asserts 2]\n\nadjacency_list = {1: [2, 3], 2: [1, 4, 5], 3: [1, 6, 7], 4: [2], 5: [2], 6: [3], 7: [3]}\ng = Graph(adjacency_list)\nassert processQueries(g, [(4, 5), (1, 3), (2, 6)]) == [2, 1, 1]\n\nadjacency_list = {1: [2, 3], 2: [1, 4, 5], 3: [1, 6, 7], 4: [2], 5: [2, 8], 6: [3], 7: [3], 8: [5]}\ng = Graph(adjacency_list)\nassert processQueries(g, [(5, 8), (2, 7), (1, 6)]) == [5, 1, 1]\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.909}, {"few_shot_keywords": "['range', 'count', 'binary', 'divisible', 'node removal', 'iterate', 'pairs', 'integers', 'operation']", "test_keywords": "['divisible', 'count', 'driving license', 'python', 'depth-first search', 'size', 'iterate', 'integers', 'range', 'pairs']", "prompt_tokens": 511, "total_tokens": 749, "completion_tokens": 238, "completion": "[Question 2]\n\nYou are given a list of integers and a target integer N. Write a Python function to count the number of pairs of integers in the list that are divisible by the target integer N.\n\n[/Question 2]\n\n[Code 2]\n\ndef countDivisiblePairs(arr, N):\n    count = 0\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            if (arr[i] + arr[j]) % N == 0:\n                count += 1\n    return count\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countDivisiblePairs([1, 2, 3, 4, 5], 3) == 3\nassert countDivisiblePairs([2, 4, 6, 8, 10], 5) == 4\nassert countDivisiblePairs([3, 6, 9, 12, 15], 7) == 4\nassert countDivisiblePairs([5, 10, 15, 20, 25], 4) == 6\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.937}, {"few_shot_keywords": "['map', 'row', 'validate', 'elements', 'array', 'frequency', 'queries', 'count', 'range']", "test_keywords": "['frequency', 'count', 'map', 'efficient', 'queries', 'traversal', 'indexing', 'range', 'negative weight cycle', 'elements', 'array', 'remove']", "prompt_tokens": 687, "total_tokens": 1036, "completion_tokens": 349, "completion": "[Question 2]\n\nGiven an array arr of integers, write a function to remove all the elements from the array which have a frequency greater than a given value, k. After the removal, return the updated array.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List, Dict\ndef removeElementsWithHigherFrequency(arr: List[int], k: int) -> List[int]:\n    frequencyMap = {}\n    for num in arr:\n        if num in frequencyMap:\n            frequencyMap[num] += 1\n        else:\n            frequencyMap[num] = 1\n    \n    updatedArr = [num for num in arr if frequencyMap[num] <= k]\n    return updatedArr\n\n[/Code 2]\n\n[Asserts 2]\n\nassert removeElementsWithHigherFrequency([2, 3, 1, 7, 4, 7, 9, 2, 3, 7], 2) == [2, 3, 1, 4, 2, 3]\nassert removeElementsWithHigherFrequency([1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3, 4, 5], 3) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3, 4, 5]\nassert removeElementsWithHigherFrequency([3, 3, 3, 3, 3, 3, 3, 3, 3], 3) == []\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.933}, {"few_shot_keywords": "['dynamic programming', 'change', 'removal', 'coin', 'map', 'minimum', 'greedy', 'optimization', 'mask', 'target']", "test_keywords": "['steps', 'longest path', 'greedy', 'change', 'events', 'dynamic programming', 'coin', 'code', 'optimization', 'target', 'last row', 'minimum']", "prompt_tokens": 568, "total_tokens": 1018, "completion_tokens": 450, "completion": "[Question 2]\n\nYou are given a grid representing steps and you can move either right, down, or diagonally lower only. Find the length of the longest path from the top-left to the bottom-right with the condition that a step is only valid if it is an event number.\n\n[/Question 2]\n\n[Code 2]\n\ndef isEvenRowStep(stepRow, stepCol):\n    return (stepRow + stepCol) % 2 == 0\n\ndef longestPath(grid):\n    m, n = len(grid), len(grid[0])\n    dp = [[0]*n for _ in range(m)]\n    if isEvenRowStep(0, 0) and grid[0][0] % 2 == 0:\n        dp[0][0] = 1\n    for i in range(1, m):\n        if isEvenRowStep(i, 0) and grid[i][0] % 2 == 0:\n            dp[i][0] = dp[i-1][0] + 1\n    for j in range(1, n):\n        if isEvenRowStep(0, j) and grid[0][j] % 2 == 0:\n            dp[0][j] = dp[0][j-1] + 1\n    for i in range(1, m):\n        for j in range(1, n):\n            if isEvenRowStep(i, j) and grid[i][j] % 2 == 0:\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + 1\n    return dp[m-1][n-1]\n\n[/Code 2]\n\n[Asserts 2]\n\nassert longestPath([[1, 2, 3], [4, 5, 6], [7, 8, 9]])==2\nassert longestPath([[2, 4, 3], [1, 9, 8], [5, 7, 6]])==3\nassert longestPath([[2, 4, 6], [1, 3, 5]])==3", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.947}, {"few_shot_keywords": "['elements', 'arithmetic progression', 'range', 'frequency', 'indexes', 'count', 'validation', 'array']", "test_keywords": "['Aadhar', 'input string', 'frequency', 'count', 'array', 'indexes', 'elements', 'range']", "prompt_tokens": 584, "total_tokens": 848, "completion_tokens": 264, "completion": "[Question 2]\n\nYou are required to write a program that takes an input string and returns the count of occurrences of each element in the given array where the elements are Aadhar numbers.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List, Dict\n\ndef countAadharFrequency(input_str: str, aadhar_numbers: List[str]) -> Dict[str, int]:\n    freq = {}\n    for aadhar in aadhar_numbers:\n        freq[aadhar] = input_str.count(aadhar)\n    return freq\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countAadharFrequency(\"123456789012 987654321098 123456789012\", [\"123456789012\", \"987654321098\"]) == {'123456789012': 2, '987654321098': 1}\nassert countAadharFrequency(\"123456789012 987654321098 123456789012\", [\"111111111111\", \"222222222222\"]) == {'111111111111': 0, '222222222222': 0}\nassert countAadharFrequency(\"123456789012\", [\"123456789012\"]) == {'123456789012': 1}\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.843}, {"few_shot_keywords": "['set', 'Regular Expression', 'count', 'boolean', 'repeated', 'parity', 'string', 'iteration', 'digits', 'range']", "test_keywords": "['count', 'transform', 'repeated', 'iteration', 'string', 'set', 'range', 'digits', 'numbers']", "prompt_tokens": 455, "total_tokens": 628, "completion_tokens": 173, "completion": "[Question 2]\n\nGiven a string, write a function to count the number of times a specific substring appears in the string.\n\n[/Question 2]\n\n[Code 2]\n\ndef countSubstringOccurrences(main_string: str, substring: str) -> int:\n    count = 0\n    for i in range(len(main_string)):\n        if main_string[i:i+len(substring)] == substring:\n            count += 1\n    return count\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countSubstringOccurrences(\"abababab\", \"ab\") == 4\nassert countSubstringOccurrences(\"hello, hello, hello\", \"hello\") == 3\nassert countSubstringOccurrences(\"aaaaa\", \"aa\") == 4\nassert countSubstringOccurrences(\"pythonpythonpython\", \"on\") == 3\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.845}, {"few_shot_keywords": "['operation', 'string', 'adjacent', 'repeated', 'count', 'characters', 'branch', 'binary', 'swap', 'alternate']", "test_keywords": "['count', 'adjacent', 'equal-length', 'alternate', 'longest common subsequence', 'binary', 'swap', 'weights', 'characters', 'operation', 'string']", "prompt_tokens": 516, "total_tokens": 830, "completion_tokens": 314, "completion": "[Question 2]\n\nGiven two equal-length binary strings, S1 and S2, find the length of the longest common subsequence that can be obtained by swapping characters at the same indices in the strings. A swap operation allows you to swap two adjacent characters in a string. \n\n[/Question 2]\n\n[Code 2]\n\ndef longestCommonSubsequenceLength(s1: str, s2: str) -> int:\n    n = len(s1)\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            if s1[i - 1] == s2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    return dp[n][n]\n\n[/Code 2]\n\n[Asserts 2]\n\nassert longestCommonSubsequenceLength(\"1101\", \"1110\") == 3\nassert longestCommonSubsequenceLength(\"101010\", \"010101\") == 6\nassert longestCommonSubsequenceLength(\"1111\", \"0000\") == 0\nassert longestCommonSubsequenceLength(\"1010\", \"1010\") == 4\nassert longestCommonSubsequenceLength(\"1100\", \"0011\") == 2", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.746}, {"few_shot_keywords": "['natural number', 'formula', 'placement', 'sum', 'prefix', 'level', 'arrays', 'matrix', 'numbers', 'distinct numbers']", "test_keywords": "['placement', 'sum', 'distinct numbers', 'depth-first search', 'matrix', 'natural number', 'multiplying', 'formula']", "prompt_tokens": 741, "total_tokens": 1355, "completion_tokens": 614, "completion": "[Question 2]\n\nGiven a matrix filled with distinct numbers and a natural number N, your task is to find all the distinct N-digit numbers that can be formed by multiplying the numbers at adjacent positions in the matrix in a depth-first search manner. The program should return a list of all such distinct N-digit numbers.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List, Set\n\ndef isSafe(x: int, y: int, visited: List[List[bool]]) -> bool:\n    return x>=0 and x<len(visited) and y>=0 and y<len(visited[0]) and not visited[x][y]\n\ndef getAllDistinctNdigitNumbers(matrix: List[List[int]], N: int) -> Set[int]:\n    result = set()\n    def DFS(x: int, y: int, number: int, visited: List[List[bool]]):\n        nonlocal result\n        if len(str(number))==N:\n            result.add(number)\n            return\n        visited[x][y] = True\n        directions = [(0,1),(0,-1),(1,0),(-1,0)]\n        for dx,dy in directions:\n            newX,newY = x+dx,y+dy\n            if isSafe(newX,newY,visited):\n                DFS(newX,newY,number*10+matrix[newX][newY],visited)\n        visited[x][y] = False\n    \n    for i in range(len(matrix)):\n        for j in range(len(matrix[0])):\n            visited = [[False]*len(matrix[0]) for _ in range(len(matrix))]\n            DFS(i,j,matrix[i][j],visited)\n    return result\n\n[/Code 2]\n\n[Asserts 2]\n\nassert getAllDistinctNdigitNumbers([[1,2,3],[4,5,6]], 2) == {14, 12, 15, 23, 21, 24, 35, 32, 36, 45, 43, 46}\nassert getAllDistinctNdigitNumbers([[1,2],[3,4],[5,6]], 3) == {143, 125, 124, 132, 134, 153, 154, 152, 1432, 1425, 1435, 1436, 1256, 1245, 1325, 1324, 1345, 1532, 1542, 1524, 12564, 12456, 13256, 13456, 15324, 15432}\nassert getAllDistinctNdigitNumbers([[1,2,3],[4,5,6],[7,8,9]], 2) == {13, 12, 16, 23, 21, 26, 32, 36, 35, 43, 46, 45, 52, 53, 56, 63, 65, 64}", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.914}, {"few_shot_keywords": "['intervals', 'overlap', 'schedule', 'minimization', 'events', 'batches', 'rooms', 'queries']", "test_keywords": "['repeated', 'overlap', 'batches', 'electronic funds', 'rooms', 'events', 'undirected', 'intervals', 'schedule']", "prompt_tokens": 650, "total_tokens": 901, "completion_tokens": 251, "completion": "[Question 2]\n\nYou are given a list of intervals representing the start and end times of electronic funds transfer events. Write a function to determine if any of the events are repeated or overlap with each other.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List,Tuple\ndef isOverlap(intervals: List[Tuple[int, int]]) -> bool:\n    intervals.sort()\n    for i in range(1, len(intervals)):\n        if intervals[i][0] < intervals[i-1][1]:\n            return True\n    return False\n\n[/Code 2]\n\n[Asserts 2]\n\nassert isOverlap([(1, 3), (2, 6), (5, 7), (8, 10)]) == True\nassert isOverlap([(1, 3), (4, 6), (7, 9), (10, 12)]) == False\nassert isOverlap([(1, 3), (3, 6), (6, 9), (9, 12)]) == True\nassert isOverlap([(1, 3), (4, 7), (6, 8), (9, 12)]) == True\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.717}, {"few_shot_keywords": "['maximize', 'array', 'sum', 'function', 'sorting', 'pairs', 'minimize']", "test_keywords": "['repetitions', 'pairs', 'duplicates', 'sorting', 'array', 'color code', 'minimize', 'sum', 'strictly decreasing']", "prompt_tokens": 547, "total_tokens": 834, "completion_tokens": 287, "completion": "[Question 2]\n\nGiven an array of color codes representing a sequence of colors, find the minimum number of repetitions to remove in order to make the array strictly decreasing.\n\n[/Question 2]\n\n[Code 2]\n\ndef minRepetitionsToRemove(arr: list) -> int:\n    n = len(arr)\n    repetitions = 0\n    for i in range(1, n):\n        if arr[i] >= arr[i-1]:\n            repetitions += 1\n    return repetitions\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minRepetitionsToRemove([5, 4, 3, 2, 1]) == 0\nassert minRepetitionsToRemove([6, 6, 6, 5, 4, 3, 2, 2, 1]) == 2\nassert minRepetitionsToRemove([9, 7, 7, 7, 5, 3, 2, 1]) == 2\nassert minRepetitionsToRemove([10, 9, 8, 8, 7, 6, 5, 4, 3, 2, 1]) == 2\nassert minRepetitionsToRemove([3, 3, 3, 3, 3, 3, 3]) == 6\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.75}, {"few_shot_keywords": "['requests', 'Next Fit', 'divisible', 'memory', 'blocks', 'search', 'algorithm', 'allocation', 'numbers', 'space']", "test_keywords": "['requests', 'allocation', 'uppercase', 'blocks', 'characters', 'space', 'Next Fit', 'algorithm', 'adding', 'memory', 'input']", "prompt_tokens": 620, "total_tokens": 843, "completion_tokens": 223, "completion": "[Question 2]\n\nYou are given an input string containing uppercase characters. Implement an algorithm to allocate memory blocks to the characters based on the Next Fit strategy. The memory allocation will be based on the number of characters and the space required to store each character.\n\n[/Question 2]\n\n[Code 2]\n\ndef nextFitMemoryAllocation(inputString: str, blockSize: int) -> int:\n    memoryBlocks = [blockSize]\n    for char in inputString:\n        allocated = False\n        for i in range(len(memoryBlocks)):\n            if memoryBlocks[i] >= len(inputString):\n                memoryBlocks[i] -= len(inputString)\n                allocated = True\n                break\n        if not allocated:\n            memoryBlocks.append(blockSize - len(inputString))\n    return len(memoryBlocks)\n\n[/Code 2]\n\n[Asserts 2]\n\nassert nextFitMemoryAllocation(\"HELLO\", 10) == 1\nassert nextFitMemoryAllocation(\"WORLD\", 5) == 2\nassert nextFitMemoryAllocation(\"PYTHON\", 3) == 3\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.766}, {"few_shot_keywords": "['root', 'search', 'absolute difference', 'boolean', 'tree traversal', 'sum', 'flip', 'recursive', 'leaf', 'binary tree', 'pair', 'path']", "test_keywords": "['search', 'steps', 'binary tree', 'leaf', 'root', 'path', 'boolean', 'tree traversal', 'sum', 'recursive', 'present', 'pair']", "prompt_tokens": 705, "total_tokens": 1060, "completion_tokens": 355, "completion": "[Question 2]\n\nGiven a binary tree and an integer representing the sum, the task is to find if there exists a root to leaf path where the sum of all the node values in the path is equal to the given sum.\n\nWrite a function `hasPathSum` that takes in the root of the binary tree and an integer `targetSum`, and returns True if such a path exists, otherwise returns False.\n\n[/Question 2]\n\n[Code 2]\n\nclass TreeNode:\n    def __init__(self, value=0, left=None, right=None):\n        self.value = value\n        self.left = left\n        self.right = right\n\ndef hasPathSum(root: TreeNode, targetSum: int) -> bool:\n    if not root:\n        return False\n    if not root.left and not root.right and root.value == targetSum:\n        return True\n    targetSum -= root.value\n    return hasPathSum(root.left, targetSum) or hasPathSum(root.right, targetSum)\n\n[/Code 2]\n\n[Asserts 2]\n\n# Example test cases\ntree1 = TreeNode(5, TreeNode(3, TreeNode(4), TreeNode(1)), TreeNode(8, TreeNode(2), TreeNode(7)))\nassert hasPathSum(tree1, 11) == True\ntree2 = TreeNode(10, TreeNode(5, TreeNode(3, TreeNode(3), TreeNode(-2)), TreeNode(2, None, TreeNode(1))), TreeNode(-3, None, TreeNode(11)))\nassert hasPathSum(tree2, 8) == True\ntree3 = TreeNode(1, TreeNode(2), TreeNode(3))\nassert hasPathSum(tree3, 5) == False\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.828}, {"few_shot_keywords": "['common', 'distance', 'array', 'duplicates', 'check', 'count', 'combinatorics', 'PIN', 'valid', 'permutations', 'range']", "test_keywords": "['regex', 'duplicates', 'combinatorics', 'array', 'permutations', 'valid', 'smallest', 'count', 'distance', 'max_cost', 'range']", "prompt_tokens": 611, "total_tokens": 956, "completion_tokens": 345, "completion": "[Question 2]\n\nYou are given a string S consisting of lowercase English alphabets. The task is to find the smallest substring of S which contains all the characters occurring in S and has a maximum cost not exceeding max_cost. The cost of a substring is defined as the count of duplicates present within the substring.\n\nWrite a function to find the smallest substring satisfying the given conditions.\n\n[/Question 2]\n\n[Code 2]\n\ndef smallestSubstringWithMaxCost(S: str, max_cost: int) -> str:\n    if not S:\n        return \"\"\n    chars_count = {}\n    required_chars = set(S)\n    start, end = 0, 0\n    min_length = float('inf')\n    min_substring = \"\"\n    while end < len(S):\n        if S[end] in chars_count:\n            chars_count[S[end]] += 1\n        else:\n            chars_count[S[end]] = 1\n        while len(chars_count) == len(required_chars):\n            if end - start + 1 < min_length:\n                min_length = end - start + 1\n                min_substring = S[start:end + 1]\n            chars_count[S[start]] -= 1\n            if chars_count[S[start]] == 0:\n                del chars_count[S[start]]\n            start += 1\n        end += 1\n    return min_substring\n\n[/Code 2]\n\n[Asserts 2]\n\nassert smallestSubstringWithMaxCost(\"aabbcc\", 1)==\"a\"\nassert smallestSubstringWithMaxCost(\"aabbcc\", 2)==\"aabb\"\nassert smallestSubstringWithMaxCost(\"abacab\", 3)==\"bacab\"", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.945}, {"few_shot_keywords": "['size', 'division', 'batches', 'complete', 'maximum', 'groups', 'count', 'depth-first search', 'math', 'frequency', 'donuts', 'alpha', 'span', 'input string']", "test_keywords": "['maximum', 'frequency', 'complete', 'batches', 'donuts', 'implementation', 'count', 'groups', 'division', 'math', 'efficient']", "prompt_tokens": 837, "total_tokens": 1244, "completion_tokens": 407, "completion": "[Question 2]\n\nYou are given a list of N donuts. The task is to find the maximum number of complete batches of donuts that can be formed, where each batch must have the same frequency of donuts.\n\nWrite a function maxCompleteBatches that will return the maximum number of complete batches of donuts that can be formed.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef maxCompleteBatches(donuts: List[int]) -> int:\n    # Create a frequency count of donuts\n    donut_freq = {}\n    for donut in donuts:\n        if donut in donut_freq:\n            donut_freq[donut] += 1\n        else:\n            donut_freq[donut] = 1\n    \n    # Find the maximum frequency of donuts\n    max_freq = max(donut_freq.values())\n    \n    # Calculate the maximum number of complete batches\n    max_batches = 0\n    for freq in donut_freq.values():\n        max_batches += freq // max_freq\n    \n    return max_batches\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maxCompleteBatches([1, 2, 3, 4, 5, 1, 2, 3, 1, 1]) == 3\nassert maxCompleteBatches([1, 2, 3, 4, 5, 1, 2, 3, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5]) == 6\nassert maxCompleteBatches([1, 1, 1, 1, 1, 1]) == 6\nassert maxCompleteBatches([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == 1\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.873}, {"few_shot_keywords": "['length', 'array', 'integer', 'value', 'subarray', 'sum', 'elements', '0s', 'greater', 'smallest']", "test_keywords": "['greater', 'integer', 'tree traversal', 'length', 'sum', 'list', 'smallest', 'array', 'dfs', 'subarray', 'value']", "prompt_tokens": 589, "total_tokens": 932, "completion_tokens": 343, "completion": "[Question 2]\n\nGiven a binary tree, find the length of the smallest subarray with sum greater than a given value by traversing the tree using Depth First Search (DFS).\n\n[/Question 2]\n\n[Code 2]\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef smallestSubarrayWithSumDFS(root: TreeNode, x: int) -> int:\n    stack = [(root, [root.val])]\n    min_len = float('inf')\n    while stack:\n        node, path = stack.pop()\n        if sum(path) > x:\n            min_len = min(min_len, len(path))\n        if node.left:\n            stack.append((node.left, path + [node.left.val]))\n        if node.right:\n            stack.append((node.right, path + [node.right.val]))\n    return min_len\n\n[/Code 2]\n\n[Asserts 2]\n\nroot = TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(5)), TreeNode(3, TreeNode(6)))\nassert smallestSubarrayWithSumDFS(root, 8) == 2\nroot = TreeNode(3, TreeNode(2, TreeNode(4), TreeNode(5)), TreeNode(7, TreeNode(6)))\nassert smallestSubarrayWithSumDFS(root, 12) == 1\nroot = TreeNode(1, TreeNode(2, TreeNode(3), TreeNode(4)), TreeNode(5, TreeNode(6), TreeNode(7)))\nassert smallestSubarrayWithSumDFS(root, 15) == float('inf')\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.929}, {"few_shot_keywords": "['rooms', 'root', 'leaf node', 'subset', 'binary tree', 'tuple', 'columns', 'sum', 'India', 'longest path', 'nodes']", "test_keywords": "['nodes', 'sum', 'binary tree', 'frequency', 'graph', 'leaf node', 'root', 'longest path', 'form']", "prompt_tokens": 663, "total_tokens": 987, "completion_tokens": 324, "completion": "[Question 2]\n\nYou are given a binary tree. Write a program to find the sum of all the nodes at even levels (considering the root as level 1) in the binary tree.\n\n[/Question 2]\n\n[Code 2]\n\nclass Node:\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\n\ndef sumNodesAtEvenLevels(root, level):\n    if root is None:\n        return 0\n    if level % 2 == 0:\n        return root.val + sumNodesAtEvenLevels(root.left, level + 1) + sumNodesAtEvenLevels(root.right, level + 1)\n    else:\n        return sumNodesAtEvenLevels(root.left, level + 1) + sumNodesAtEvenLevels(root.right, level + 1)\n\ndef sumNodesAtEvenLevelsWrapper(root):\n    return sumNodesAtEvenLevels(root, 1)\n\n[/Code 2]\n\n[Asserts 2]\n\nroot = Node(1)\nroot.left = Node(2)\nroot.right = Node(3)\nroot.left.left = Node(4)\nroot.left.right = Node(5)\nroot.right.right = Node(7)\nassert sumNodesAtEvenLevelsWrapper(root)==12\nroot = Node(6)\nroot.left = Node(7)\nroot.right = Node(8)\nroot.left.left = Node(2)\nroot.left.right = Node(1)\nroot.right.right = Node(3)\nassert sumNodesAtEvenLevelsWrapper(root)==15\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.786}, {"few_shot_keywords": "['implementation', 'transform', 'operation', 'math', 'water', 'array', 'validate', 'regular expressions', 'steps', 'minimize', 'India', 'target']", "test_keywords": "['minimize', 'steps', 'math', 'target', 'map', 'array', 'operation', 'subarray', 'representation', 'Card Verification Value', 'transform', 'vessels']", "prompt_tokens": 656, "total_tokens": 987, "completion_tokens": 331, "completion": "[Question 2]\n\nYou are given an array representing the water level in different vessels. Your task is to transform the array into a target array representing the water level in each vessel after a series of operations. Each operation involves pouring water from one vessel to another. You need to minimize the number of steps required to transform the given array to the target array.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef minimizeStepsToTransform(array: List[int], target: List[int]) -> int:\n    steps = 0\n    for i in range(len(array)):\n        if array[i] < target[i]:\n            diff = target[i] - array[i]\n            array[i] += diff\n            array[i+1] -= diff\n            steps += 1\n    return steps\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minimizeStepsToTransform([2, 5, 3, 7, 8], [6, 7, 8, 9, 10]) == 3\nassert minimizeStepsToTransform([10, 20, 30, 40, 50], [1, 2, 3, 4, 5]) == 150\nassert minimizeStepsToTransform([1, 1, 1, 1], [1, 1, 1, 1]) == 0\nassert minimizeStepsToTransform([5, 4, 3, 2, 1], [1, 2, 3, 4, 5]) == 12\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.815}, {"few_shot_keywords": "['less than', '01', 'mask', 'subset', 'positive', 'integers', 'shortest path', 'product', 'comparison', 'iteration', 'array']", "test_keywords": "['PIN', 'iteration', 'subset', 'array', 'positive', 'integers', 'comparison', 'less than', 'closest', 'product', 'credit card', 'mask']", "prompt_tokens": 556, "total_tokens": 851, "completion_tokens": 295, "completion": "[Question 2]\n\nYou are given an array of positive integers representing credit card PINs. Write a function to find the closest PIN to a given PIN. If there are multiple PINs with the same closest distance, return the smaller PIN.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef closestPIN(arr: List[int], target: int) -> int:\n    closest = float('inf')\n    closest_pin = float('inf')\n    for pin in arr:\n        if pin != target and abs(pin - target) < closest:\n            closest = abs(pin - target)\n            closest_pin = pin\n        elif pin != target and abs(pin - target) == closest and pin < closest_pin:\n            closest_pin = pin\n    return closest_pin\n\n[/Code 2]\n\n[Asserts 2]\n\nassert closestPIN([1234, 5678, 9876, 5432], 8765) == 9876\nassert closestPIN([1111, 2222, 3333, 4444, 5555], 3333) == 3333\nassert closestPIN([1000, 2000, 3000, 4000, 5000], 2500) == 2000\nassert closestPIN([9999, 8888, 7777, 6666], 10000) == 9999\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.725}, {"few_shot_keywords": "['even', 'electronic funds', 'levels', 'sum', 'constraint', 'subsequence', 'odd', 'adjacent', 'array', 'integers', 'removal', 'maximum', 'parity']", "test_keywords": "['maximum', 'odd', 'subsequence', 'sum', 'element', 'adjacent', 'array', 'HTML', 'constraint', 'integers', 'even', 'parity']", "prompt_tokens": 598, "total_tokens": 873, "completion_tokens": 275, "completion": "[Question 2]\n\nYou are given an array of integers. Write a function to find the maximum sum of a subsequence where each element is adjacent and has an odd parity.\n\n[/Question 2]\n\n[Code 2]\n\ndef maxSumOddParitySubsequence(arr):\n    n = len(arr)\n    incl = 0\n    excl = 0\n    \n    for i in arr:\n        if i % 2 != 0:\n            new_excl = excl if excl > incl else incl\n            incl = excl + i\n            excl = new_excl\n        else:\n            excl = excl if excl > incl else incl\n    \n    return excl if excl > incl else incl\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maxSumOddParitySubsequence([1, 2, 3, 4, 5, 6, 7]) == 16\nassert maxSumOddParitySubsequence([2, 4, 6, 8, 10]) == 0\nassert maxSumOddParitySubsequence([1, 2, 3, 4, 5]) == 9\nassert maxSumOddParitySubsequence([2, 5, 8, 11, 15, 20]) == 31\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.769}, {"few_shot_keywords": "['color code', 'unsorted', 'palindrome', 'binary search', 'undirected', 'merge', 'array', 'integer', 'sum', 'consecutive', 'operation']", "test_keywords": "['operation', 'integer', 'ancestor', 'palindrome', 'merge', 'DFA', 'sum', 'array', 'consecutive']", "prompt_tokens": 616, "total_tokens": 929, "completion_tokens": 313, "completion": "[Question 2]\n\nGiven a list of integers, write a function to merge consecutive elements of the array if their sum is a palindrome. If a merge operation is performed, the function should return the merged array; otherwise, it should return the original array.\n\n[/Question 2]\n\n[Code 2]\n\ndef mergeIfSumIsPalindrome(arr):\n    def isPalindrome(num):\n        return str(num) == str(num)[::-1]\n\n    n = len(arr)\n    for i in range(n - 1):\n        if isPalindrome(arr[i] + arr[i + 1]):\n            arr[i] = arr[i] + arr[i + 1]\n            arr.pop(i + 1)\n            return mergeIfSumIsPalindrome(arr)\n    return arr\n\n[/Code 2]\n\n[Asserts 2]\n\nassert mergeIfSumIsPalindrome([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]\nassert mergeIfSumIsPalindrome([1, 2, 3, 4, 5, 6]) == [3, 7, 5, 6]\nassert mergeIfSumIsPalindrome([1, 2, 3, 4, 9, 10, 11]) == [1, 2, 3, 25, 11]\nassert mergeIfSumIsPalindrome([11, 22, 33, 44]) == [11, 55]\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.712}, {"few_shot_keywords": "['positive', 'array', 'generating', 'sum', 'subset', 'divide and conquer', 'binary search', 'steps']", "test_keywords": "['subset', 'combinations', 'exclude', 'positive', 'array', 'sequence', 'sum']", "prompt_tokens": 469, "total_tokens": 837, "completion_tokens": 368, "completion": "[Question 2]\n\nGiven an array of positive integers, write a function to find all possible subsets of the array that sum up to a given positive number.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef findSubsetsWithSum(arr: List[int], target: int) -> List[List[int]]:\n    def backtrack(start, target, path, res):\n        if target == 0:\n            res.append(path)\n            return\n        for i in range(start, len(arr)):\n            if arr[i] > target:\n                break\n            if i > start and arr[i] == arr[i-1]:\n                continue\n            backtrack(i+1, target-arr[i], path+[arr[i]], res)\n    \n    arr.sort()\n    res = []\n    backtrack(0, target, [], res)\n    return res\n\n[/Code 2]\n\n[Asserts 2]\n\nassert findSubsetsWithSum([2, 3, 6, 7, 5], 7) == [[2, 5], [7]]\nassert findSubsetsWithSum([1, 2, 3, 4, 5], 10) == [[1, 2, 3, 4], [1, 4, 5], [2, 3, 5]]\nassert findSubsetsWithSum([4, 2, 3, 5, 10], 12) == [[2, 3, 7], [5, 7]]\nassert findSubsetsWithSum([1, 2, 3, 4, 5, 6], 7) == [[1, 2, 4], [1, 6], [2, 5], [3, 4]]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.891}, {"few_shot_keywords": "['overlap', 'XOR', 'replacement', 'array', 'distinct', 'bitwise', 'weight', 'swaps', 'subsets', 'typing']", "test_keywords": "['array', 'bitwise', 'distinct', 'indexing', 'XOR', 'recursive approach', 'subsets']", "prompt_tokens": 543, "total_tokens": 862, "completion_tokens": 319, "completion": "[Question 2]\n\nWrite a recursive function to find the distinct bitwise XOR values of all the subsets of a given array and return the list of distinct values.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\ndef distinctXorSubsets(arr: List[int]) -> List[int]:\n    def findXor(index, current_xor):\n        if index == len(arr):\n            return [current_xor]\n        include = findXor(index + 1, current_xor ^ arr[index])\n        exclude = findXor(index + 1, current_xor)\n        return list(set(include + exclude))\n    \n    return findXor(0, 0)\n\n[/Code 2]\n\n[Asserts 2]\n\nassert distinctXorSubsets([1, 3, 5]) == [0, 1, 3, 4, 5, 6]\nassert distinctXorSubsets([2, 4, 6, 8]) == [0, 2, 4, 6, 8, 10, 12, 14, 16]\nassert distinctXorSubsets([3, 6, 9, 12, 15]) == [0, 3, 6, 9, 12, 15, 5, 10]\nassert distinctXorSubsets([1, 2, 4, 8]) == [0, 1, 2, 3, 4, 5, 6, 7, 8]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.938}, {"few_shot_keywords": "['contiguous', 'subarray', 'subsequence', 'length', 'arrays', 'mapping', 'MasterCard', 'validate', 'matrix', 'rearrange', 'inclusive', 'enumeration']", "test_keywords": "['depth', 'filled', 'contiguous', 'arrays', 'enumeration', 'length', 'mapping', 'subsequence', 'subarray']", "prompt_tokens": 708, "total_tokens": 1072, "completion_tokens": 364, "completion": "[Question 2]\n\nGiven a matrix filled with 0s and 1s, the task is to find the depth of the deepest contiguous subarray of 1s.\n\n[/Question 2]\n\n[Code 2]\n\ndef depthOfDeepestContiguousSubarray(matrix):\n    depth = 0\n    for row in matrix:\n        cnt = 0\n        for val in row:\n            if val == 1:\n                cnt += 1\n                depth = max(depth, cnt)\n            else:\n                cnt = 0\n    return depth\n\n[/Code 2]\n\n[Asserts 2]\n\nassert depthOfDeepestContiguousSubarray([[1, 1, 0, 0, 0],\n                                         [1, 1, 1, 1, 0],\n                                         [0, 1, 1, 0, 0],\n                                         [0, 0, 0, 0, 0]]) == 4\n\nassert depthOfDeepestContiguousSubarray([[1, 0, 0, 0, 0],\n                                         [1, 1, 0, 0, 0],\n                                         [1, 1, 1, 0, 0],\n                                         [1, 1, 1, 1, 0]]) == 4\n\nassert depthOfDeepestContiguousSubarray([[1, 0, 1, 1, 1],\n                                         [1, 1, 1, 0, 0],\n                                         [0, 1, 1, 1, 0],\n                                         [0, 0, 0, 0, 0]]) == 3\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.744}, {"few_shot_keywords": "['difference', 'array', 'minimum', 'formula', 'comparison', 'sorting', 'integers']", "test_keywords": "['sorting', 'comparison', 'array', 'minimum', 'difference', 'unique paths', 'change', 'integers', '1s']", "prompt_tokens": 486, "total_tokens": 762, "completion_tokens": 276, "completion": "[Question 2]\n\nYou are given an array of integers where each integer represents the number of 1s in a specific row of a matrix. The array is not sorted. Write a function to find the minimum number of changes required to sort the array in ascending order. A change is defined as swapping two elements in the array.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef minChangesToSort(arr: List[int]) -> int:\n    n = len(arr)\n    changes = 0\n    for i in range(n):\n        for j in range(0, n-i-1):\n            if arr[j] > arr[j+1]:\n                arr[j], arr[j+1] = arr[j+1], arr[j]\n                changes += 1\n    return changes\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minChangesToSort([2, 3, 1, 4]) == 2\nassert minChangesToSort([5, 4, 3, 2, 1]) == 10\nassert minChangesToSort([1, 2, 3, 4, 5]) == 0\nassert minChangesToSort([3, 2, 2, 3, 1]) == 4\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.724}, {"few_shot_keywords": "['space optimization', 'frequency', 'integer division', 'prime', 'bitwise', 'array', 'bit manipulation', 'optimization']", "test_keywords": "['array', 'bitwise', 'bit manipulation', 'space optimization', 'frequency', 'visited', 'integer division', 'optimization', 'calculation']", "prompt_tokens": 592, "total_tokens": 956, "completion_tokens": 364, "completion": "[Question 2]\n\nGiven an array of integers, implement a space-optimized algorithm using bitwise operations to find the element that appears more than n/3 times, where n is the length of the array.\n\n[/Question 2]\n\n[Code 2]\n\ndef majorityElement(arr):\n    candidate1, candidate2, count1, count2 = 0, 0, 0, 0\n    for num in arr:\n        if num == candidate1:\n            count1 += 1\n        elif num == candidate2:\n            count2 += 1\n        elif count1 == 0:\n            candidate1, count1 = num, 1\n        elif count2 == 0:\n            candidate2, count2 = num, 1\n        else:\n            count1 -= 1\n            count2 -= 1\n    count1, count2 = 0, 0\n    for num in arr:\n        if num == candidate1:\n            count1 += 1\n        elif num == candidate2:\n            count2 += 1\n    result = []\n    if count1 > len(arr)//3:\n        result.append(candidate1)\n    if count2 > len(arr)//3:\n        result.append(candidate2)\n    return result\n\n[/Code 2]\n\n[Asserts 2]\n\nassert majorityElement([3, 1, 2, 2, 1, 2, 3, 3])==[2, 3]\nassert majorityElement([1, 2, 3, 4, 2, 2, 8, 2])==[2]\nassert majorityElement([1, 2, 2, 4, 1, 4, 4, 4])==[4]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.948}, {"few_shot_keywords": "['recursive', 'node removal', 'depth', 'integer division', 'data structure', 'path sum', 'binary tree', 'contiguous', 'inorder traversal']", "test_keywords": "['node removal', 'inorder traversal', 'common', 'data structure', 'binary tree', 'path sum', 'branch', 'recursive']", "prompt_tokens": 602, "total_tokens": 1108, "completion_tokens": 506, "completion": "[Question 2]\n\nGiven a binary tree, write a function to find the sum of all paths from the root node to each leaf node. Then, remove any node in the tree if its value is not common in all these paths.\n\n[/Question 2]\n\n[Code 2]\n\nclass TreeNode:\n    def __init__(self, key):\n        self.left = None\n        self.right = None\n        self.val = key\n\ndef inorderTraversal(root: TreeNode):\n    if root:\n        inorderTraversal(root.left)\n        print(root.val)\n        inorderTraversal(root.right)\n\ndef findCommonPaths(root: TreeNode) -> int:\n    if not root:\n        return 0\n    res = []\n    dfs(root, res, 0)\n    return sum(res)\n\ndef dfs(node: TreeNode, res: list, num: int):\n    if not node:\n        return\n    num = num * 10 + node.val\n    if not node.left and not node.right:\n        res.append(num)\n        return\n    dfs(node.left, res, num)\n    dfs(node.right, res, num)\n\ndef removeNonCommonNodes(root: TreeNode):\n    if not root:\n        return\n    res = findCommonPaths(root)\n    dfsRemoval(root, res)\n    return root\n\ndef dfsRemoval(node: TreeNode, target: int):\n    if not node:\n        return\n    if node.val not in str(target):\n        node.val = None\n    dfsRemoval(node.left, target)\n    dfsRemoval(node.right, target)\n\n# Example usage\n# Create a binary tree with nodes\nroot = TreeNode(1)\nroot.left = TreeNode(2)\nroot.right = TreeNode(3)\nroot.left.left = TreeNode(4)\nroot.left.right = TreeNode(5)\nroot.right.left = TreeNode(6)\nroot.right.right = TreeNode(7)\n\nprint(\"Original Tree:\")\ninorderTraversal(root)  # Output: 4, 2, 5, 1, 6, 3, 7\n\nremoveNonCommonNodes(root)\n\nprint(\"Modified Tree:\")\ninorderTraversal(root)  # Output: 4, 2, 5, None, 6, 3, 7\n\n[/Code 2]\n\n[Asserts 2]\n\nassert(findCommonPaths(root))== 127\nassert(removeNonCommonNodes(root))== [4, 2, 5, None, 6, 3, 7]\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.906}, {"few_shot_keywords": "['binary tree', 'traversal', 'path', 'inorder', 'recursion', 'tree', 'preorder', 'postorder', 'data structure', 'domain name', 'node']", "test_keywords": "['modulo', 'traversal', 'subsets', 'node', 'even levels', 'preorder', 'inorder', 'postorder', 'tree', 'data structure', 'palindrome', 'perfect cube', 'binary tree', 'recursion']", "prompt_tokens": 738, "total_tokens": 1189, "completion_tokens": 451, "completion": "[Question 2]\n\nGiven a binary tree, write a function to find all the nodes at even levels and return the subsets of nodes that form palindromes when their values are concatenated. Consider using recursion to solve this problem.\n\n[/Question 2]\n\n[Code 2]\n\nclass TreeNode:\n    def __init__(self, value=0, left=None, right=None):\n        self.value = value\n        self.left = left\n        self.right = right\n\ndef is_palindrome(s):\n    return s == s[::-1]\n\ndef even_level_palindromic_subsets(root: TreeNode):\n    def helper(node, level):\n        if not node:\n            return []\n        if level % 2 == 0:\n            result.append(str(node.value))\n        helper(node.left, level + 1)\n        helper(node.right, level + 1)\n    \n    result = []\n    helper(root, 0)\n    subsets = [result[i:j] for i in range(len(result) + 1) for j in range(i + 1, len(result) + 1)]\n    return [subset for subset in subsets if is_palindrome(''.join(subset))]\n\n[/Code 2]\n\n[Asserts 2]\n\nroot = TreeNode(1, TreeNode(2, TreeNode(3), TreeNode(4)), TreeNode(5, TreeNode(6), TreeNode(7)))\nassert even_level_palindromic_subsets(root) == [['1', '2', '5'], ['1', '2', '3', '4', '6', '7'], ['2', '3', '4', '6', '7'], ['3', '4'], ['4', '6']]\nroot = TreeNode(1, TreeNode(2, TreeNode(3), TreeNode(4)), TreeNode(5, TreeNode(6), TreeNode(7, TreeNode(8), TreeNode(9))))\nassert even_level_palindromic_subsets(root) == [['1', '2', '5'], ['1', '2', '3', '4', '6', '7'], ['2', '3', '4', '6', '7'], ['3', '4'], ['4', '6']]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.799}, {"few_shot_keywords": "['elements', 'array', 'corner', 'maximum', 'subarray', 'Python', 'sum', 'removing']", "test_keywords": "['python', 'subarray', 'sum', 'array', 'elements', 'removing', 'binary search', 'maximum']", "prompt_tokens": 728, "total_tokens": 1197, "completion_tokens": 469, "completion": "[Question 2]\n\nGiven an array of integers, the task is to find the length of the maximum subarray with the sum less than or equal to a given sum S.\n\nYou are required to implement the function ```maxLengthSubarray``` that takes in the following arguments:\n- A list of integers representing the array ```arr```\n- An integer ```n``` representing the size of the array\n- An integer ```S``` representing the maximum sum\n\nThe function should return an integer representing the length of the maximum subarray with the sum less than or equal to the given sum S.\n\nThe solution should utilize binary search to efficiently find the maximum subarray length.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef maxLengthSubarray(arr: List[int], n: int, S: int) -> int:\n    maxLen = 0\n    currSum = 0\n    prefixSum = [0]\n    for num in arr:\n        currSum += num\n        prefixSum.append(currSum)\n    for i in range(n):\n        low, high = i, n\n        while low < high:\n            mid = (low + high + 1) // 2\n            if prefixSum[mid] - prefixSum[i] <= S:\n                low = mid\n            else:\n                high = mid - 1\n        maxLen = max(maxLen, low - i)\n    return maxLen\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maxLengthSubarray([1, 3, 4, 8, 6, 12, 1], 7, 15) == 4\nassert maxLengthSubarray([1, 3, 4, 8, 6, 12, 1], 7, 25) == 6\nassert maxLengthSubarray([10, 20, 30], 3, 15) == 1\nassert maxLengthSubarray([1, 3, 4, 8, 6, 12, 1], 7, 100) == 7\nassert maxLengthSubarray([-1, -2, -3, 4, 5, 6], 6, 0) == 3\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.791}, {"few_shot_keywords": "['operation', 'nearest', 'prime', 'function', 'adding', 'operations', 'subtracting', 'distance', 'element', 'boolean', 'even levels', 'matrix']", "test_keywords": "['function', 'color code', 'adding', 'minimize', 'distance', 'boolean', 'matrix', 'subtracting', 'cost', 'duplicate', 'nearest', 'prime', 'generating', 'element', 'operations']", "prompt_tokens": 797, "total_tokens": 1353, "completion_tokens": 556, "completion": "[Question 2]\n\nYou are given a matrix representing a color image where each element contains a color code. Write a function to minimize the cost of the image by generating a new matrix such that each color code is either a prime number or the nearest prime number (either larger or smaller) of the original color code. The cost of the image is the sum of distances between the original color codes and their corresponding nearest prime color codes.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef isPrime(x: int) -> bool:\n\tif (x <= 1):\n\t\treturn False\n\tif (x <= 3):\n\t\treturn True\n\tif (x % 2 == 0 or x % 3 == 0):\n\t\treturn False\n\ti = 5\n\twhile (i * i <= x):\n\t\tif (x % i == 0 or x % (i +\n\t\t\t\t\t\t\t\t2) == 0):\n\t\t\treturn False\n\t\ti += 6\n\treturn True\n\ndef minimizeCost(image: List[List[int]]) -> int:\n\tcost = 0\n\tfor i in range(len(image)):\n\t\tfor j in range(len(image[0])):\n\t\t\tif not isPrime(image[i][j]):\n\t\t\t\tnearestPrime = 0\n\t\t\t\tdistance = 0\n\t\t\t\tk = image[i][j] + 1\n\t\t\t\tl = image[i][j] - 1\n\t\t\t\twhile True:\n\t\t\t\t\tif isPrime(k):\n\t\t\t\t\t\tnearestPrime = k\n\t\t\t\t\t\tdistance = k - image[i][j]\n\t\t\t\t\t\tbreak\n\t\t\t\t\tk += 1\n\t\t\t\twhile True:\n\t\t\t\t\tif l > 1 and isPrime(l):\n\t\t\t\t\t\tnearestPrime = l\n\t\t\t\t\t\tdistance = image[i][j] - l\n\t\t\t\t\t\tbreak\n\t\t\t\t\tl -= 1\n\t\t\t\tif distance <= image[i][j]:\n\t\t\t\t\timage[i][j] = distance\n\t\t\t\telse:\n\t\t\t\t\timage[i][j] = -distance\n\t\t\t\tcost += abs(distance)\n\treturn cost\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minimizeCost([[1, 2, 3], [4, 5, 6], [7, 8, 9]])==8\nassert minimizeCost([[10, 20, 30], [40, 50, 60], [70, 80, 90]])==42\nassert minimizeCost([[5, 7, 9], [11, 13, 15], [17, 19, 21]])==22\nassert minimizeCost([[11, 13, 17], [19, 23, 29], [31, 37, 41]])==0\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.917}, {"few_shot_keywords": "['pattern', 'minimum', 'cost', 'space optimization', 'array', 'absolute difference', 'integers', 'removal', 'odd divisors', 'fraudulent use']", "test_keywords": "['minimum', 'cost', 'array', 'removal', 'absolute difference', 'integers', 'label']", "prompt_tokens": 556, "total_tokens": 813, "completion_tokens": 257, "completion": "[Question 2]\n\nYou are given an array of integers and a label. The cost of removing an element from the array is the absolute difference between the element and the label. Your task is to find the minimum cost to remove all elements from the array.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\ndef minCostToRemove(arr: List[int], label: int) -> int:\n    cost = 0\n    for num in arr:\n        cost += abs(num - label)\n    return cost\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minCostToRemove([3, 1, 4, 1, 5], 2) == 14\nassert minCostToRemove([2, 7, 1, 4, 6, 3], 5) == 12\nassert minCostToRemove([5, 2, 8, 3, 6], 4) == 14\nassert minCostToRemove([1, 2, 3, 4, 5], 3) == 6\nassert minCostToRemove([10, 20, 30, 40, 50], 25) == 75\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.701}, {"few_shot_keywords": "['binary', 'sub-array', 'node sum', 'length', 'span', 'array', 'credit card', 'optimization', 'sum']", "test_keywords": "['operations', 'binary-search', 'substring', 'node sum', 'sub-array', 'values', 'sum', 'array', 'span', 'length', 'binary']", "prompt_tokens": 713, "total_tokens": 1037, "completion_tokens": 324, "completion": "[Question 2]\n\nYou are given an array of integers and a target sum. Write a function to find the length of the shortest sub-array with a sum greater than or equal to the target sum. If no such sub-array exists, return 0.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\nimport sys\n\ndef shortestSubarrayWithSum(nums: List[int], target: int) -> int:\n    n = len(nums)\n    minLen = sys.maxsize\n    left = 0\n    currSum = 0\n\n    for right in range(n):\n        currSum += nums[right]\n        while currSum >= target:\n            minLen = min(minLen, right - left + 1)\n            currSum -= nums[left]\n            left += 1\n\n    if minLen == sys.maxsize:\n        return 0\n    return minLen\n\n[/Code 2]\n\n[Asserts 2]\n\nassert shortestSubarrayWithSum([1, 4, 45, 6, 0, 19], 51) == 1\nassert shortestSubarrayWithSum([1, 10, 5, 2, 7], 9) == 1\nassert shortestSubarrayWithSum([1, 11, 100, 1, 0, 200, 3, 2, 1, 250], 280) == 4\nassert shortestSubarrayWithSum([1, 2, 4], 8) == 0\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.849}, {"few_shot_keywords": "['subsequence', 'longest', 'time', 'increasing', 'array', 'sorting', 'number', 'count']", "test_keywords": "['longest', 'array', 'increasing', 'batches', 'number', 'subsequence', 'count', 'iterate']", "prompt_tokens": 602, "total_tokens": 1026, "completion_tokens": 424, "completion": "[Question 2]\n\nYou are given an array, and you want to find the length of the longest increasing subsequence in batches of a given size.\n\nWrite a function to find the length of the longest increasing subsequence in each batch of the given size, and return the count of batches where the length of the longest increasing subsequence is greater than or equal to a given number.\n\n[/Question 2]\n\n[Code 2]\n\ndef longestIncreasingSubsequenceBatches(arr, batch_size, min_length):\n    def lis_length(arr):\n        if not arr:\n            return 0\n        n = len(arr)\n        dp = [1] * n\n        for j in range(1, n):\n            for i in range(j):\n                if arr[i] < arr[j]:\n                    dp[j] = max(dp[j], 1 + dp[i])\n        return max(dp)\n    \n    count = 0\n    for i in range(0, len(arr), batch_size):\n        batch = arr[i:i+batch_size]\n        if lis_length(batch) >= min_length:\n            count += 1\n    return count\n\n[/Code 2]\n\n[Asserts 2]\n\nassert(longestIncreasingSubsequenceBatches([1,7,3,5,9,4,8], 3, 2))==2\nassert(longestIncreasingSubsequenceBatches([1,7,3,5,9,4,8], 3, 3))==1\nassert(longestIncreasingSubsequenceBatches([2,4,6,8,10,12,14,16], 4, 3))==2\nassert(longestIncreasingSubsequenceBatches([3,6,9,11,4,5,7,8,10,12,14,16], 6, 4))==1\nassert(longestIncreasingSubsequenceBatches([1,3,5,2,4,6,3,5,7,4,6,8], 5, 3))==2\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.86}, {"few_shot_keywords": "['binary search tree', 'adjacent', 'convert', 'combinatorics', 'node', 'binary tree', 'strictly increasing', 'even levels', 'strictly decreasing', 'odd levels', 'utility function', 'integer division', 'events']", "test_keywords": "['binary tree', 'even levels', 'node', 'unbounded', 'list', 'strictly increasing', 'odd levels', 'strictly decreasing', 'binary search tree', 'utility function']", "prompt_tokens": 720, "total_tokens": 1179, "completion_tokens": 459, "completion": "[Question 2]\n\nGiven a binary tree, write a utility function to convert the tree into an unbounded list such that the values at even levels are strictly increasing and values at odd levels are strictly decreasing.\n\n[/Question 2]\n\n[Code 2]\n\nclass Node:\n    def __init__(self, key):\n        self.data = key\n        self.left = None\n        self.right = None\n\ndef convertToUnboundedList(root, level, unboundedList):\n    if root is None:\n        return\n    if level % 2 == 0:\n        unboundedList[0].append(root.data)\n    else:\n        unboundedList[1].append(root.data)\n    convertToUnboundedList(root.left, level + 1, unboundedList)\n    convertToUnboundedList(root.right, level + 1, unboundedList)\n\ndef isStrictlyIncreasing(lst):\n    return all(lst[i] < lst[i+1] for i in range(len(lst)-1))\n\ndef isStrictlyDecreasing(lst):\n    return all(lst[i] > lst[i+1] for i in range(len(lst)-1))\n\ndef convertTreeToList(root):\n    unboundedList = [[], []]  # [even level values, odd level values]\n    convertToUnboundedList(root, 0, unboundedList)\n    return unboundedList\n\n[/Code 2]\n\n[Asserts 2]\n\nroot = Node(4)\nroot.left = Node(2)\nroot.right = Node(7)\nroot.left.left = Node(1)\nroot.left.right = Node(3)\nroot.right.left = Node(6)\nroot.right.right = Node(8)\nassert convertTreeToList(root) == ([4, 7, 3, 8], [2, 1, 6])\nroot2 = Node(1)\nroot2.left = Node(2)\nroot2.right = Node(3)\nroot2.left.left = Node(4)\nroot2.left.right = Node(5)\nroot2.right.left = Node(6)\nroot2.right.right = Node(7)\nassert convertTreeToList(root2) == ([1, 3, 5, 7], [2, 6, 4])", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.926}, {"few_shot_keywords": "['string', 'encoding', '01', 'minimum', 'removal', 'modulus', 'removing']", "test_keywords": "['minimum', 'XOR', 'string', 'removal', 'encoding', 'schedule']", "prompt_tokens": 657, "total_tokens": 1019, "completion_tokens": 362, "completion": "[Question 2]\n\nGiven a list of positive integers and a value K, write a function to find the minimum number of elements to remove from the list such that the XOR of all remaining elements is less than or equal to K.\n\n[/Question 2]\n\n[Code 2]\n\ndef minRemovalForXOR(arr: List[int], k: int) -> int:\n    n = len(arr)\n    ans = n  # Maximum removals\n    for mask in range(1 << n):\n        cur = 0\n        for i in range(n):\n            if mask & (1 << i):\n                cur ^= arr[i]\n        if cur <= k:\n            bitCount = bin(mask).count('1')  # Count number of set bits\n            ans = min(ans, n - bitCount)  # Update minimum removals\n    return ans if ans < n else -1  # Return -1 if no valid subset found\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minRemovalForXOR([3, 6, 8, 2, 10, 15], 5) == 0\nassert minRemovalForXOR([3, 6, 8, 2, 10, 15], 10) == 2\nassert minRemovalForXOR([7, 2, 5, 8, 9], 10) == 1\nassert minRemovalForXOR([4, 3, 1, 8, 2], 5) == -1\nassert minRemovalForXOR([1, 2, 3, 4, 5], 0) == 0\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.918}, {"few_shot_keywords": "['end', 'unique paths', 'elements', 'formula', 'matrix', 'product', 'count', 'odd divisors', 'algorithm']", "test_keywords": "['count', 'product', 'matrix', 'grid', 'substring', 'odd divisors', 'elements', 'algorithm', 'negatives', 'unique paths']", "prompt_tokens": 786, "total_tokens": 1347, "completion_tokens": 561, "completion": "[Question 2]\n\nGiven a grid represented as a matrix of integers, we need to count the total number of unique paths from the top-left corner to the bottom-right corner such that the product of the elements along the path contains an odd number of divisors and the path consists of only non-negative integers.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef oddDivisorsUniquePaths(grid: List[List[int]]) -> int:\n    def divisors(n):\n        div = []\n        for i in range(1, int(n**(0.5)) + 1):\n            if n % i == 0:\n                if n // i == i:\n                    div.append(i)\n                else:\n                    div.append(i)\n                    div.append(n//i)\n        return div\n    \n    m, n = len(grid), len(grid[0])\n    dp = [[0 for _ in range(n)] for _ in range(m)]\n    dp[0][0] = 1 if grid[0][0] >= 0 and len(divisors(grid[0][0])) % 2 != 0 else 0\n    \n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] if grid[i][0] >= 0 and len(divisors(grid[i][0])) % 2 != 0 else 0\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] if grid[0][j] >= 0 and len(divisors(grid[0][j])) % 2 != 0 else 0\n    \n    for i in range(1, m):\n        for j in range(1, n):\n            if grid[i][j] >= 0:\n                dp[i][j] = dp[i-1][j] + dp[i][j-1] if len(divisors(grid[i][j])) % 2 != 0 else 0\n    \n    return dp[-1][-1]\n\n[/Code 2]\n\n[Asserts 2]\n\nassert oddDivisorsUniquePaths([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 2\nassert oddDivisorsUniquePaths([[2, 3, 4], [5, 6, 7]]) == 3\nassert oddDivisorsUniquePaths([[1, -2, 1], [0, 2, -3], [1, 2, 0]]) == 2\nassert oddDivisorsUniquePaths([[1, 0], [0, 1]]) == 1\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.704}, {"few_shot_keywords": "['element', 'sum', 'matrix', 'selection', 'space complexity', 'LCS', 'function', 'row', 'driving license', 'maximum']", "test_keywords": "['row', 'selection', 'maximum', 'element', 'matrix', 'generating', 'sum', 'pairs', 'NEFT']", "prompt_tokens": 626, "total_tokens": 943, "completion_tokens": 317, "completion": "[Question 2]\n\nWrite a function to find the maximum sum of elements in a matrix by generating all possible pairs of elements from different rows and selecting the pair with the maximum sum.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef maxSumPairElements(matrix: List[List[int]]) -> int:\n    max_sum = float('-inf')\n    for i in range(len(matrix)):\n        for j in range(i+1, len(matrix)):\n            for ele1 in matrix[i]:\n                for ele2 in matrix[j]:\n                    max_sum = max(max_sum, ele1+ele2)\n    return max_sum\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maxSumPairElements([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 17\nassert maxSumPairElements([[3, 7, 2], [1, 8, 4], [5, 6, 9]]) == 17\nassert maxSumPairElements([[10, 20], [30, 40], [50, 60]]) == 110\nassert maxSumPairElements([[5, 5, 5], [5, 5, 5], [5, 5, 5]]) == 10\nassert maxSumPairElements([[1, 1, 1], [1, 1, 1], [1, 1, 1]]) == 2\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.701}, {"few_shot_keywords": "['integer', 'array', 'lowercase', 'removal', 'alternately', 'function', 'label', 'element', 'input string', 'operation', 'dp', 'filled', 'index']", "test_keywords": "['array', 'duplicates', 'function', 'alternately', 'index', 'repeatedly', 'removal', 'integer', 'leaf node', 'element', 'Indian passport', 'label', 'operation']", "prompt_tokens": 528, "total_tokens": 856, "completion_tokens": 328, "completion": "[Question 2]\n\nYou are given an array of integers where each integer represents the label of a node in a binary tree. The array is filled with duplicate elements representing the labels of leaf nodes. Write a function `removeDuplicatesAlternately` to remove the duplicate leaf nodes alternately from the array until no more duplicates are left. The operation is repeated until no more duplicates exist in the array.\n\nFor example, if the input array is [1, 2, 3, 3, 4, 4, 5], the function should remove the duplicates alternately and return [1, 2, 3, 4, 5].\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\ndef removeDuplicatesAlternately(arr: List[int]) -> List[int]:\n    seen = set()\n    result = []\n    for item in arr[::-1]:\n        if item not in seen:\n            result.append(item)\n            seen.add(item)\n    return result[::-1]\n\n[/Code 2]\n\n[Asserts 2]\n\nassert removeDuplicatesAlternately([1, 2, 3, 3, 4, 4, 5]) == [1, 2, 3, 4, 5]\nassert removeDuplicatesAlternately([3, 3, 3, 3, 3]) == [3]\nassert removeDuplicatesAlternately([1, 2, 2, 3, 3, 3, 4, 4, 4, 4]) == [1, 2, 3, 4]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.749}, {"few_shot_keywords": "['maximum', 'NEFT', 'repeated', 'multiplication', 'array', 'sum', 'alphanumeric', 'subsequence', 'pin code', 'index', 'contiguous', 'integer']", "test_keywords": "['subsequence', 'imprinted', 'divisible', 'index', 'maximum', 'infinite', 'subset', 'integer', 'permutation', 'multiplication', 'array', 'sum']", "prompt_tokens": 526, "total_tokens": 795, "completion_tokens": 269, "completion": "[Question 2]\n\nYou are given an array of integers. Write a function to find the maximum sum of a subsequence that is divisible by a given integer.\n\n[/Question 2]\n\n[Code 2]\n\ndef maxSubSeqSumDivisible(nums: list, divisor: int) -> int:\n    maxSum = 0\n    for num in nums:\n        if num % divisor == 0:\n            maxSum = max(maxSum, num)\n    return maxSum\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maxSubSeqSumDivisible([1, 7, 5, 3, 9, 12], 3) == 12\nassert maxSubSeqSumDivisible([4, 8, 15, 16, 23, 42], 5) == 15\nassert maxSubSeqSumDivisible([10, 20, 30, 40, 50], 7) == 0\nassert maxSubSeqSumDivisible([12, 15, 18, 21, 24, 27], 3) == 27\nassert maxSubSeqSumDivisible([3, 6, 9, 12, 15], 5) == 15\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.863}, {"few_shot_keywords": "['sort', 'unbounded', 'array', 'stacks', 'enumeration', 'strictly decreasing', 'absolute difference', 'swap', 'sorting', 'lambda function', 'value']", "test_keywords": "['sort', 'lambda function', 'value', 'change', 'representation', 'palindromic', 'sorting', 'wildcard', 'absolute difference', 'greater', 'array']", "prompt_tokens": 524, "total_tokens": 758, "completion_tokens": 234, "completion": "[Question 2]\n\nYou are given an unbounded array of integers. Write a function to sort the array based on the absolute difference of each number from a given value V, and in case of a tie, sort the numbers in descending order.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef sortArrayByAbsoluteDifference(arr: List[int], V: int) -> List[int]:\n    arr.sort(key=lambda x: (abs(x-V), -x), reverse=True)\n    return arr\n\n[/Code 2]\n\n[Asserts 2]\n\nassert sortArrayByAbsoluteDifference([10, 5, 3, 9, 2], 7)==[9, 5, 10, 3, 2]\nassert sortArrayByAbsoluteDifference([1, 2, 3, 4, 5], 10)==[5, 4, 3, 2, 1]\nassert sortArrayByAbsoluteDifference([50, 20, 18, 10], 21)==[20, 18, 50, 10]\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.769}, {"few_shot_keywords": "['vessels', 'capacity', 'filled', 'steps', 'array', 'time', 'knapsack', 'overlap', 'integer', 'counting']", "test_keywords": "['form', 'minimize', 'counting', 'filled', 'array', 'integer', 'capacity', 'vessels', 'space', 'time']", "prompt_tokens": 546, "total_tokens": 824, "completion_tokens": 278, "completion": "[Question 2]\n\nYou are given an array of integers representing the capacities of different vessels and a target capacity. Write a function to minimize the number of vessels used to reach the target capacity, considering that each vessel can only be used once.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\ndef minimizeVesselsCount(arr: List[int], target_capacity: int) -> int:\n    arr.sort()\n    count = 0\n    l, r = 0, len(arr) - 1\n    while l <= r:\n        if arr[l] + arr[r] <= target_capacity:\n            l += 1\n            r -= 1\n        else:\n            r -= 1\n        count += 1\n    return count\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minimizeVesselsCount([100, 200, 300, 400, 500], 700) == 2\nassert minimizeVesselsCount([200, 350, 150, 300, 500], 700) == 2\nassert minimizeVesselsCount([100, 250, 300, 450, 600], 700) == 3\nassert minimizeVesselsCount([300, 500, 700, 900], 1000) == 2", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.801}, {"few_shot_keywords": "['indices', 'count', 'common ratio', 'geometric progression', 'sorted', 'ord', 'subsequence', 'multiplying', 'string', 'integer', 'max', 'modulus', 'dynamic programming']", "test_keywords": "['subsequence', 'max', 'geometric progression', 'multiplying', 'length', 'distance', 'count', 'integer', 'ord', 'end', 'MAC address', 'dynamic programming', 'indices', 'string', 'modulus', 'common ratio']", "prompt_tokens": 767, "total_tokens": 1093, "completion_tokens": 326, "completion": "[Question 2]\n\nGiven a string representation of a MAC address and an integer N, write a function to find the maximum count of subsequences of the MAC address string, such that the characters at the indices of the subsequence form a geometric progression with a common ratio of N, and the length of the subsequence is maximum.\n\n[/Question 2]\n\n[Code 2]\n\ndef maxCountGeometricProgressionSubsequence(mac: str, N: int) -> int:\n    mod = 10**9 + 7\n    count = [0] * 26\n    for i in range(len(mac)):\n        curr_num = ord(mac[i]) - ord('a')\n        for j in range(26):\n            if (curr_num - j * N) >= 0 and (curr_num - j * N) < 26:\n                count[curr_num] = max(count[curr_num], count[curr_num - j * N] + 1)\n    return max(count) % mod\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maxCountGeometricProgressionSubsequence(\"abcabcabc\", 2) == 3\nassert maxCountGeometricProgressionSubsequence(\"xyzxyzxyz\", 2) == 3\nassert maxCountGeometricProgressionSubsequence(\"aabababcccbccbcccc\", 3) == 4\nassert maxCountGeometricProgressionSubsequence(\"abcdefgh\", 2) == 1\nassert maxCountGeometricProgressionSubsequence(\"abcdef\", 4) == 2\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.87}, {"few_shot_keywords": "['math', 'maximum', 'unique sums', 'formula', 'series', 'positive integer', 'arithmetic progression', 'format', 'common ratio', 'counting']", "test_keywords": "['unique sums', 'math', 'arithmetic progression', 'target', 'formula', 'recursive', 'positive integer', 'counting', 'infinite', 'series']", "prompt_tokens": 436, "total_tokens": 653, "completion_tokens": 217, "completion": "[Question 2]\n\nGiven a positive integer N and a target T, find the number of unique sums of the series 1, 2, 3, ..., N that equals the target T.\n\n[/Question 2]\n\n[Code 2]\n\ndef countUniqueSums(N: int, T: int) -> int:\n\tif N*(N+1)//2 < T:\n\t\treturn 0\n\telif (N*(N+1)//2 - T) % 2 != 0:\n\t\treturn 0\n\telse:\n\t\tcount = (N*(N+1)//2 - T) // 2\n\t\treturn 1 if count == 0 else 2\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countUniqueSums(5, 5) == 2\nassert countUniqueSums(5, 10) == 1\nassert countUniqueSums(10, 15) == 4\nassert countUniqueSums(10, 30) == 0\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.834}, {"few_shot_keywords": "['sorting', 'frequency', 'insertion', 'comparison', 'size', 'array', 'merge', 'indexing', 'nodes']", "test_keywords": "['inclusive', 'adjacent', 'sorting', 'indexing', 'size', 'comparison', 'merge', 'top left', 'rooms', 'insertion', 'array']", "prompt_tokens": 827, "total_tokens": 1104, "completion_tokens": 277, "completion": "[Question 2]\n\nYou are given an array representing the layout of a building. Each element in the array represents a room. The rooms are numbered from 1 to n. The array contains 1s and 0s representing occupied and unoccupied rooms, respectively. Write a function to find the top-left most unoccupied room and its index in the array. If there are adjacent unoccupied rooms, return the index of the leftmost room.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\ndef findTopLeftUnoccupiedRoom(rooms: List[int]) -> int:\n    n = len(rooms)\n    \n    for i in range(n):\n        if rooms[i] == 0:\n            return i + 1\n    \n    return -1\n\n[/Code 2]\n\n[Asserts 2]\n\nassert findTopLeftUnoccupiedRoom([1, 0, 0, 0, 1, 1, 0, 1]) == 2\nassert findTopLeftUnoccupiedRoom([1, 1, 1, 0, 0, 0, 1, 1, 0, 1]) == 4\nassert findTopLeftUnoccupiedRoom([1, 1, 1, 1, 1]) == -1\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.835}, {"few_shot_keywords": "['position', 'sorting', 'Bellman-Ford algorithm', 'array', 'stack', 'swapping', 'operations', 'formula', 'sequence', 'increasing', 'adjacent']", "test_keywords": "['adjacent', 'sequence', 'sorting', 'iteration', 'position', 'swapping', 'increasing', 'operations', 'series', 'array']", "prompt_tokens": 563, "total_tokens": 818, "completion_tokens": 255, "completion": "[Question 2]\n\nYou are given an array of integers. Implement a function to sort the array using the bubble sort algorithm and return the number of swapping operations performed during the sorting process.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef bubbleSortWithSwapsCount(nums: List[int]) -> int:\n    n = len(nums)\n    swap_count = 0\n    for i in range(n):\n        for j in range(0, n-i-1):\n            if nums[j] > nums[j+1]:\n                nums[j], nums[j+1] = nums[j+1], nums[j]\n                swap_count += 1\n    return swap_count\n\n[/Code 2]\n\n[Asserts 2]\n\nassert bubbleSortWithSwapsCount([5, 3, 8, 4, 2])==6\nassert bubbleSortWithSwapsCount([1, 2, 3, 4, 5])==0\nassert bubbleSortWithSwapsCount([5, 4, 3, 2, 1])==10\nassert bubbleSortWithSwapsCount([3, 1, 2, 4, 5])==2\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.82}, {"few_shot_keywords": "['graph', 'factor', 'cycle detection', 'uppercase', 'adjacent list', 'vertices', 'weights', 'edges', 'shortest path', 'negative weight cycle', 'Bellman-Ford algorithm', 'distance']", "test_keywords": "['graph', 'distance', 'cycle detection', 'term', 'squares', 'edges', 'weights', 'shortest path', 'tree node', 'adjacent list', 'vertices', 'negative weight cycle', 'CVV', 'Bellman-Ford algorithm']", "prompt_tokens": 625, "total_tokens": 925, "completion_tokens": 300, "completion": "[Question 2]\n\nGiven a graph with V vertices and E edges and weights of edges represented in adjacent list as graph[], the task is to implement a function to detect a negative weight cycle using the Bellman-Ford algorithm.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List, Tuple\n\nclass Graph:\n    def hasNegativeWeightCycle(self, V: int, graph: List[Tuple[int, int, int]]) -> bool:\n        dist = [float(\"Inf\")] * V\n        dist[0] = 0\n        for _ in range(V - 1):\n            for u, v, w in graph:\n                if dist[u] != float(\"Inf\") and dist[u] + w < dist[v]:\n                    dist[v] = dist[u] + w\n        for u, v, w in graph:\n            if dist[u] != float(\"Inf\") and dist[u] + w < dist[v]:\n                return True\n        return False\n\n[/Code 2]\n\n[Asserts 2]\n\ng = Graph()\nassert g.hasNegativeWeightCycle(3, [(0, 1, -1), (1, 2, -2), (2, 0, -3)]) == True\nassert g.hasNegativeWeightCycle(4, [(0, 1, 1), (1, 2, 3), (2, 3, 5)]) == False\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.737}, {"few_shot_keywords": "['sort', '0s', '1s', 'formula', 'array', 'vessels', 'rearrange', 'image', 'left', 'right', 'operations']", "test_keywords": "['0s', 'regular expression', 'array', 'parent', 'right', 'iterate', 'sort', '1s', 'frequency', 'left', 'rearrange']", "prompt_tokens": 615, "total_tokens": 890, "completion_tokens": 275, "completion": "[Question 2]\n\nYou are given an array containing 0s and 1s. Write a function to rearrange the array such that all 0s are on the left and all 1s are on the right. Additionally, the rearranged array should have 0s before all 1s and 1s should appear in increasing frequency from left to right.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef rearrangeArray(arr: List[int]) -> List[int]:\n    count = arr.count(1)\n    rearranged_arr = [0]*(len(arr)-count) + [1]*count\n    return rearranged_arr\n\n[/Code 2]\n\n[Asserts 2]\n\nassert rearrangeArray([0, 1, 0, 1, 1, 1])==[0, 0, 1, 1, 1, 1]\nassert rearrangeArray([1, 0, 1, 0, 1, 0])==[0, 0, 1, 1, 1, 1]\nassert rearrangeArray([0, 0, 0, 1, 1, 1])==[0, 0, 0, 1, 1, 1]\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.864}, {"few_shot_keywords": "['edges', 'graph', 'distance', 'visited', 'undirected', 'smallest', 'duplicates', 'vertices', 'adjacency list', 'size', 'path', 'queue']", "test_keywords": "['vertices', 'sum', 'queue', 'graph', 'edges', 'visited', 'calculation', 'absolute difference', 'undirected', 'path', 'adjacency list']", "prompt_tokens": 617, "total_tokens": 991, "completion_tokens": 374, "completion": "[Question 2]\n\nGiven an undirected graph with vertices and edges, represented as an adjacency list, write a function to calculate the sum of the absolute differences between the number of edges from each vertex to a given vertex and the number of edges from that vertex to a destination vertex. Return the sum.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\ndef calculateAbsoluteDifferenceSum(n: int, graph: List[List[int]], src: int, dest: int) -> int:\n    queue = []\n    visited = [False]*n\n    edge_count = [0]*n\n    queue.append(src)\n    visited[src] = True\n    while(queue):\n        x = queue.pop(0)\n        for i in graph[x]:\n            if(not visited[i]):\n                queue.append(i)\n                visited[i] = True\n                edge_count[i] = edge_count[x] + 1\n    total_sum = 0\n    for i in range(n):\n        total_sum += abs(edge_count[i]-edge_count[dest])\n    return total_sum\n\n[/Code 2]\n\n[Asserts 2]\n\nassert calculateAbsoluteDifferenceSum(4, [[1, 2], [0, 2], [0, 1, 3], [2]], 0, 3)==4\nassert calculateAbsoluteDifferenceSum(5, [[1, 4], [0, 2, 3, 4], [1, 3], [1, 2], [0, 1]], 0, 3)==8\nassert calculateAbsoluteDifferenceSum(6, [[1, 2], [0, 3], [0, 4], [1, 5], [2], [3]], 3, 5)==6\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.726}, {"few_shot_keywords": "['inorder', 'input', 'sum', 'integers', 'code', 'two-elements', 'closest', 'vertices', 'array', 'sorting', 'intersection']", "test_keywords": "['even', 'array', 'integers', 'sorting', 'closest', 'sum', 'embossed', 'two-elements', 'min']", "prompt_tokens": 609, "total_tokens": 975, "completion_tokens": 366, "completion": "[Question 2]\n\nGiven an array of integers, the task is to find the two elements whose sum is closest to a given target value.\n\n[/Question 2]\n\n[Code 2]\n\ndef closestSum(nums: List[int], target: int) -> List[int]:\n    nums.sort()\n    n = len(nums)\n    closest_sum = float('inf')\n    result = [0, 0]\n    for i in range(n):\n        l, r = i + 1, n - 1\n        while l < r:\n            curr_sum = nums[i] + nums[l] + nums[r]\n            if abs(curr_sum - target) < abs(closest_sum - target):\n                closest_sum = curr_sum\n                result = [nums[i], nums[l], nums[r]]\n            if curr_sum < target:\n                l += 1\n            else:\n                r -= 1\n    return result\n\n[/Code 2]\n\n[Asserts 2]\n\nassert closestSum([1, 60, -10, 70, -80, 85], 0)==[-80, 1, 85]\nassert closestSum([10, 20, 30, 40, 50], 30)==[10, 20, 30]\nassert closestSum([5, 10, -5, 15, 50], 10)==[5, 5, 10]\nassert closestSum([-5, -10, -8, 3, 2, -2], -1)==[-10, 3, 2]\nassert closestSum([8, 6, -14, 150, 3, 0, 3], 5)==[-14, 3, 6]\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.929}, {"few_shot_keywords": "['sum', 'array', 'mask', 'insert', 'integer', 'stacks', 'elements', 'Regular Expression', 'longest common subsequence', 'topmost', 'maximize']", "test_keywords": "['remove', 'topmost', 'elements', 'sum', 'stacks', 'depth', 'array', 'maximize']", "prompt_tokens": 636, "total_tokens": 988, "completion_tokens": 352, "completion": "[Question 2]\n\nYou are given an array of stacks S[] and an integer N. The task is to maximize the sum of the topmost N elements across all stacks by removing elements from the stacks.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef maximizeTopSum(S: List[List[int]], N: int) -> int:\n    resultSum = 0\n    while N > 0:\n        maxSum = float('-inf')\n        maxIndex = -1\n        for i in range(len(S)):\n            if len(S[i]) > 0 and S[i][-1] > maxSum:\n                maxSum = S[i][-1]\n                maxIndex = i\n        if maxIndex != -1:\n            resultSum += S[maxIndex].pop()\n            N -= 1\n        else:\n            break\n    return resultSum\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maximizeTopSum([[5, 2, 1], [7, 4, 2], [8, 3, 6]], 3) == 21\nassert maximizeTopSum([[5, 2, 1], [7, 4, 2], [8, 3, 6]], 3) == 21\nassert maximizeTopSum([[9, 8, 5, 7], [3, 4, 2], [8, 3, 6]], 2) == 17\nassert maximizeTopSum([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 1) == 9\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.725}, {"few_shot_keywords": "['efficient', 'grid', 'modulo', 'dp', 'columns', 'painted', 'ways', 'iteration', 'continuous', 'paint', 'count']", "test_keywords": "['row', 'factor', 'columns', 'iteration', 'CVV', 'continuous', 'dp', 'payment card', 'modulo', 'painted', 'paint', 'count', 'grid', 'ways']", "prompt_tokens": 804, "total_tokens": 1189, "completion_tokens": 385, "completion": "[Question 2]\n\nGiven a grid of size M x N where each cell represents the amount of money. The task is to find the maximum amount of money you can collect if you can start from the top-left cell and end at the bottom-right cell. The only movements allowed are right and down.\n\n[/Question 2]\n\n[Code 2]\n\ndef maxMoney(grid):\n    rows = len(grid)\n    cols = len(grid[0])\n    \n    dp = [[0] * cols for _ in range(rows)]\n    \n    dp[0][0] = grid[0][0]\n    \n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    \n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n    \n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    \n    return dp[rows-1][cols-1]\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maxMoney([[1, 3, 1], [1, 5, 1], [4, 2, 1]]) == 12\nassert maxMoney([[1, 2, 3], [4, 5, 6]]) == 12\nassert maxMoney([[1, 2], [1, 1]]) == 4\nassert maxMoney([[1, 3, 1, 5], [1, 5, 1, 1], [4, 2, 1, 3]]) == 16\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.725}, {"few_shot_keywords": "['binary', 'tree', 'leaves', 'DFA', 'string', 'representation', 'sum', 'path', 'longest path', 'mask']", "test_keywords": "['leaves', 'cycle detection', 'binary', 'sum', 'insertion', 'path', 'tree']", "prompt_tokens": 680, "total_tokens": 979, "completion_tokens": 299, "completion": "[Question 2]\n\nWrite a function to detect if a given binary tree contains a cycle.\n\n[/Question 2]\n\n[Code 2]\n\nclass Node:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef has_cycle(root):\n    def check_cycle(node, visited, parent):\n        if node is None:\n            return False\n        \n        visited.add(node)\n        \n        if node.left:\n            if node.left in visited and node.left != parent:\n                return True\n            if check_cycle(node.left, visited, node):\n                return True\n        \n        if node.right:\n            if node.right in visited and node.right != parent:\n                return True\n            if check_cycle(node.right, visited, node):\n                return True\n        \n        return False\n    \n    return check_cycle(root, set(), None)\n\n[/Code 2]\n\n[Asserts 2]\n\n# Create a tree without a cycle\nroot = Node(1)\nroot.left = Node(2)\nroot.right = Node(3)\nroot.left.left = Node(4)\nroot.left.right = Node(5)\nassert not has_cycle(root)\n\n# Create a tree with a cycle\nroot = Node(1)\nroot.left = Node(2)\nroot.right = Node(3)\nroot.left.left = Node(4)\nroot.left.right = Node(5)\nroot.left.right.left = root\nassert has_cycle(root)\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.771}, {"few_shot_keywords": "['sorting', 'squares', 'array', 'weight', 'swap', 'permutation', 'filled', 'minimum']", "test_keywords": "['blocks', 'sorting', 'swap', 'array', 'modulo', 'minimum', 'permutation', 'payment card', 'recursive', 'Aadhar']", "prompt_tokens": 535, "total_tokens": 880, "completion_tokens": 345, "completion": "[Question 2]\n\nYou are given an array of n elements, each representing the amount due on a payment card. The payment card has a limit on the amount it can hold and cannot exceed this limit. You need to rearrange the elements of the array in such a way that after the rearrangement, the sum of the elements is minimized modulo a given number k. You are allowed to perform a swap operation between any two elements. What is the minimum sum modulo k that can be achieved after rearranging the elements?\n\nWrite a function `minSumModuloK` to find the minimum sum modulo k that can be achieved after rearranging the elements of the array.\n\n[/Question 2]\n\n[Code 2]\n\ndef minSumModuloK(arr, k, limit):\n    n = len(arr)\n    arr.sort()\n    left, right = 0, n - 1\n    result = float('inf')\n    while left < right:\n        current_sum = arr[left] + arr[right]\n        if current_sum <= limit:\n            result = min(result, current_sum % k)\n            left += 1\n        else:\n            right -= 1\n    return result\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minSumModuloK([10, 14, 3, 7, 9], 13, 20)==3\nassert minSumModuloK([5, 8, 6, 3, 2], 10, 15)==5\nassert minSumModuloK([12, 15, 17, 9, 20], 7, 25)==1\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.804}, {"few_shot_keywords": "['product', 'union', 'combinations', 'elements', 'sorted', 'set', 'common', 'intersection', 'distinct', 'arrays', 'order']", "test_keywords": "['sorted', 'elements', 'union', 'arrays', 'allocation', 'set', 'distinct', 'common', 'intersection', 'nodes', 'order']", "prompt_tokens": 921, "total_tokens": 1417, "completion_tokens": 496, "completion": "[Question 2]\n\nYou are given two sorted arrays of integers, A and B. Write a function to merge these two arrays into a single sorted array and return it. Additionally, provide the count of distinct elements in the merged array.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef mergeSortedArrays(arr1: List[int], arr2: List[int]) -> List[int]:\n    merged = []\n    i, j = 0, 0\n    while i < len(arr1) and j < len(arr2):\n        if arr1[i] < arr2[j]:\n            merged.append(arr1[i])\n            i += 1\n        elif arr1[i] > arr2[j]:\n            merged.append(arr2[j])\n            j += 1\n        else:\n            merged.append(arr1[i])\n            i += 1\n            j += 1\n    while i < len(arr1):\n        merged.append(arr1[i])\n        i += 1\n    while j < len(arr2):\n        merged.append(arr2[j])\n        j += 1\n    return merged\n\ndef countDistinctElements(arr: List[int]) -> int:\n    return len(set(arr))\n\n[/Code 2]\n\n[Asserts 2]\n\nassert mergeSortedArrays([1, 3, 5, 7], [2, 4, 6, 8]) == [1, 2, 3, 4, 5, 6, 7, 8]\nassert countDistinctElements([1, 2, 3, 4, 5, 6, 7, 8]) == 8\n\nassert mergeSortedArrays([1, 2, 2, 4, 5, 6], [2, 3, 5, 7]) == [1, 2, 3, 4, 5, 6, 7]\nassert countDistinctElements([1, 2, 2, 3, 4, 5, 6, 7]) == 7\n\nassert mergeSortedArrays([1, 2, 3, 4, 5], []) == [1, 2, 3, 4, 5]\nassert countDistinctElements([1, 2, 3, 4, 5]) == 5\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.861}, {"few_shot_keywords": "['set', 'NEFT', 'input', 'digits', 'less than', 'implementation', 'count', 'function', 'batches', 'numbers']", "test_keywords": "['input', 'set', 'count', 'digits', 'less than', 'words', 'implementation', 'function', 'numbers', 'movement']", "prompt_tokens": 532, "total_tokens": 765, "completion_tokens": 233, "completion": "[Question 2]\n\nYou are given a set of words as input. Write a function to count the number of words containing fewer than N unique digits. Implement the function to accomplish this task.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef countWordsLessThanNDigits(N: int, words: List[str]) -> int:\n    def countUniqueDigits(word):\n        return len(set(word))\n\n    count = 0\n    for word in words:\n        if countUniqueDigits(word) < N:\n            count += 1\n    return count\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countWordsLessThanNDigits(3, ['hello', 'python', 'java', 'world']) == 3\nassert countWordsLessThanNDigits(2, ['hi', 'apple', 'bye', 'world']) == 2\nassert countWordsLessThanNDigits(4, ['programming', 'is', 'fun']) == 3\nassert countWordsLessThanNDigits(5, ['hello', 'world', 'python']) == 0\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.805}, {"few_shot_keywords": "['integers', 'maximum', 'sum', 'unique', 'memoization', 'divisible', 'unbounded', 'array', 'dynamic programming', 'backtracking']", "test_keywords": "['divisible', 'longest path', 'strictly increasing', 'dynamic programming', 'memoization', 'array', 'maximum', 'integers', 'backtracking', 'Goods and Services Tax', 'sum']", "prompt_tokens": 668, "total_tokens": 1082, "completion_tokens": 414, "completion": "[Question 2]\n\nGiven an array arr of integers, the task is to find the length of the longest subsequence in arr such that all elements of the subsequence are strictly increasing and the sum of the elements is divisible by a given integer K.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef longestSubsequenceWithSumDivK(arr: List[int], K: int) -> int:\n    dp = {}\n    def longestSeqSum(index, prev, sum):\n        if index == len(arr):\n            if sum % K == 0:\n                return 1\n            else:\n                return 0\n        if (index, prev, sum) in dp:\n            return dp[(index, prev, sum)]\n        include = 0\n        if arr[index] > prev:\n            include = 1 + longestSeqSum(index + 1, arr[index], sum + arr[index])\n        exclude = longestSeqSum(index + 1, prev, sum)\n        dp[(index, prev, sum)] = max(include, exclude)\n        return dp[(index, prev, sum)]\n        \n    return longestSeqSum(0, float('-inf'), 0)\n\n[/Code 2]\n\n[Asserts 2]\n\nassert longestSubsequenceWithSumDivK([3, 7, 2, 11, 5, 4, 10, 3, 6], 3) == 4\nassert longestSubsequenceWithSumDivK([3, 7, 2, 11, 5, 4, 10, 3, 6], 5) == 4\nassert longestSubsequenceWithSumDivK([1, 2, 3, 4, 1, 2, 3, 4], 5) == 4\nassert longestSubsequenceWithSumDivK([5, 15, 10, 20, 30], 10) == 3\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.71}, {"few_shot_keywords": "['substring', 'set', 'unsorted', 'arrays', 'encoding', 'union', 'duplicate', 'element', 'intersection']", "test_keywords": "['set', 'array', 'element', 'character', 'unsorted', 'union', 'arrays', 'intersection', 'duplicate']", "prompt_tokens": 638, "total_tokens": 808, "completion_tokens": 170, "completion": "[Question 2]\n\nGiven a string, find all duplicate characters in the string and return them as a set. Handle the case when the input string may not be sorted.\n\n[/Question 2]\n\n[Code 2]\n\ndef findDuplicateCharacters(input_string: str) -> set:\n    char_set = set()\n    duplicates = set()\n    for char in input_string:\n        if char in char_set:\n            duplicates.add(char)\n        else:\n            char_set.add(char)\n    return duplicates\n\n[/Code 2]\n\n[Asserts 2]\n\nassert findDuplicateCharacters(\"programming\") == {'g', 'r', 'm'}\nassert findDuplicateCharacters(\"hello\") == {'l'}\nassert findDuplicateCharacters(\"python\") == set()\nassert findDuplicateCharacters(\"aabbc\") == {'a', 'b'}\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.889}, {"few_shot_keywords": "['recursive', 'path', 'words', 'binary tree', 'unbounded', 'sum', 'tree traversal', 'node', 'queue', 'leaf', 'root', 'identical', 'sequence']", "test_keywords": "['subtracting', 'leaf', 'root', 'sum', 'tree traversal', 'preorder', 'binary trees', 'binary tree', 'recursive', 'wildcard', 'node', 'path']", "prompt_tokens": 823, "total_tokens": 1214, "completion_tokens": 391, "completion": "[Question 2]\n\nGiven two binary trees, write a function to check if they are identical or not. Two binary trees are considered identical if they are structurally identical and the nodes have the same value.\n\n[/Question 2]\n\n[Code 2]\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef isIdentical(root1, root2):\n    if root1 is None and root2 is None:\n        return True\n    if root1 is not None and root2 is not None:\n        return (root1.val == root2.val and\n                isIdentical(root1.left, root2.left) and\n                isIdentical(root1.right, root2.right))\n    return False\n\n[/Code 2]\n\n[Asserts 2]\n\n# Tree representation:\n#     Tree 1       Tree 2\n#       1            1\n#      / \\          / \\\n#     2   3        2   3\nroot1 = TreeNode(1)\nroot1.left = TreeNode(2)\nroot1.right = TreeNode(3)\n\nroot2 = TreeNode(1)\nroot2.left = TreeNode(2)\nroot2.right = TreeNode(3)\nassert isIdentical(root1, root2)==True\n\n# Tree representation:\n#     Tree 1       Tree 2\n#       1            1\n#      / \\          / \\\n#     2   3        2   3\nroot1 = TreeNode(1)\nroot1.left = TreeNode(2)\nroot1.right = TreeNode(3)\n\nroot2 = TreeNode(1)\nroot2.left = TreeNode(2)\nroot2.right = TreeNode(4)\nassert isIdentical(root1, root2)==False\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.704}, {"few_shot_keywords": "['match', 'count', 'binary tree', 'PAN number', 'root to leaf', 'distinct numbers', 'donuts', 'path', 'depth-first search', 'bit manipulation', 'recursion', 'unique sums']", "test_keywords": "['depth-first search', 'count', 'root to leaf', 'multiplying', 'bit manipulation', 'binary tree', 'values', 'path', 'recursion']", "prompt_tokens": 590, "total_tokens": 868, "completion_tokens": 278, "completion": "[Question 2]\n\nGiven a binary tree, write a program to implement a function that calculates the product of values in each root to leaf path of the binary tree using depth-first search and recursion.\n\n[/Question 2]\n\n[Code 2]\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef productOfPathValues(root: TreeNode) -> int:\n    def dfs(node, val):\n        if not node:\n            return 0\n        val = (val << 1) | node.val\n        if not node.left and not node.right:\n            return val\n        return dfs(node.left, val) + dfs(node.right, val)\n\n    return dfs(root, 1)\n\n[/Code 2]\n\n[Asserts 2]\n\nroot = TreeNode(1)\nroot.left = TreeNode(0)\nroot.right = TreeNode(1)\nroot.left.left = TreeNode(0)\nroot.left.right = TreeNode(1)\nroot.right.left = TreeNode(1)\nroot.right.right = TreeNode(1)\nassert productOfPathValues(root) == 152\nroot = TreeNode(1)\nroot.left = TreeNode(1)\nroot.right = TreeNode(1)\nassert productOfPathValues(root) == 14\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.753}, {"few_shot_keywords": "['subarray', 'PAN number', 'sorting', 'unsorted', 'length', 'array', 'sorted', 'min', 'less than', 'indices', 'max']", "test_keywords": "['unsorted', 'operations', 'array', 'subarray', 'min', 'length', 'indices', 'minimum', 'sorting', 'max', 'sorted']", "prompt_tokens": 593, "total_tokens": 856, "completion_tokens": 263, "completion": "[Question 2]\n\nYou are given an unsorted array of integers. Implement a function to find the minimum number of operations required to sort the array in non-decreasing order. An operation is defined as reversing the elements of a subarray.\n\nWrite a function that takes in an array of integers and returns the minimum number of operations required to sort the array.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef minOperationsToSort(nums: List[int]) -> int:\n    sorted_nums = sorted(nums)\n    count = 0\n    for i in range(len(nums)):\n        if nums[i] != sorted_nums[i]:\n            j = nums.index(sorted_nums[i])\n            nums[i:j+1] = nums[i:j+1][::-1]\n            count += 1\n    return count\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minOperationsToSort([1, 3, 2, 5, 4])==2\nassert minOperationsToSort([5, 4, 3, 2, 1])==1\nassert minOperationsToSort([1, 2, 3, 4, 5])==0\nassert minOperationsToSort([2, 1])==1\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.895}, {"few_shot_keywords": "['adjacent', 'maximum', 'level', 'binary tree', 'nodes', 'reach', 'sum', 'increment', 'recursion']", "test_keywords": "['nodes', 'entity code', 'recursion', 'sum', 'valid', 'maximum', 'adjacent', 'binary tree']", "prompt_tokens": 656, "total_tokens": 1051, "completion_tokens": 395, "completion": "[Question 2]\n\nGiven a binary tree where each node contains an entity code, write a function to find the maximum sum of entity codes in the binary tree such that no two adjacent nodes are included in the sum. The entity code is a numerical value associated with each node.\n\n[/Question 2]\n\n[Code 2]\n\nclass Node:\n\tdef __init__(self, key):\n\t\tself.entityCode = key\n\t\tself.left = None\n\t\tself.right = None\n\ndef findMaxSum(root):\n\tif not root:\n\t\treturn [0, 0]\n\t\t\n\tl = findMaxSum(root.left)\n\tr = findMaxSum(root.right)\n\t\n\treturn [root.entityCode + l[1] + r[1], max(l) + max(r)]\n\ndef maxSum(root):\n\tres = findMaxSum(root)\n\treturn max(res)\n\n# Example Usage\n# Creating binary tree with entity codes and finding maximum sum\nroot = Node(1)\nroot.left = Node(2)\nroot.right = Node(3)\nroot.left.left = Node(4)\nroot.left.right = Node(5)\nprint(maxSum(root)) # Output: 9\n\n[/Code 2]\n\n[Asserts 2]\n\nroot1 = Node(1)\nroot1.left = Node(2)\nroot1.right = Node(3)\nroot1.left.left = Node(4)\nroot1.left.right = Node(5)\nassert maxSum(root1) == 9\nroot2 = Node(4)\nroot2.left = Node(1)\nroot2.left.left = Node(2)\nroot2.left.right = Node(3)\nassert maxSum(root2) == 7\nroot3 = Node(1)\nroot3.left = Node(4)\nroot3.right = Node(5)\nroot3.left.left = Node(2)\nroot3.left.right = Node(3)\nassert maxSum(root3) == 10\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.818}, {"few_shot_keywords": "['flipping', 'integer', 'schedule', 'signs', 'positive', '1s', 'array', 'multiplying', 'sum', 'negatives', 'sort']", "test_keywords": "['flipping', 'signs', 'positive', 'sort', 'integer', 'array', 'operations', 'enumerate', 'negatives', 'sum']", "prompt_tokens": 695, "total_tokens": 925, "completion_tokens": 230, "completion": "[Question 2]\n\nGiven an array of integers, write a function to determine the minimum number of operations required to convert the array such that all negative integers are positive, and the array is sorted in ascending order.\n\n[/Question 2]\n\n[Code 2]\n\ndef minOperationsToConvert(arr: List[int]) -> int:\n    neg_count = sum(1 for num in arr if num < 0)\n    return max(neg_count, 1)\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minOperationsToConvert([-1, -2, 3, 4, 5]) == 2\nassert minOperationsToConvert([10, 20, 30, 40, 50]) == 1\nassert minOperationsToConvert([5, 4, 3, 2, 1]) == 5\nassert minOperationsToConvert([-5, -4, -3, -2, -1]) == 5\nassert minOperationsToConvert([5, -4, -3, 2, -1]) == 3\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.946}, {"few_shot_keywords": "['sort', 'array', 'comparison', 'pairs', 'math', 'max_cost', 'XOR', 'dynamic programming']", "test_keywords": "['two-elements', 'Deterministic Finite Automaton', 'pairs', 'driving license', 'array', 'XOR', 'parent', 'comparison']", "prompt_tokens": 505, "total_tokens": 790, "completion_tokens": 285, "completion": "[Question 2]\n\nGiven an array of integers, find the two elements that have the maximum XOR value. If there are multiple pairs with the same maximum XOR value, return any one of them.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\ndef maxPairXOR(arr: List[int]) -> List[int]:\n    max_xor = 0\n    res = [0, 0]\n    n = len(arr)\n    for i in range(n):\n        for j in range(i+1, n):\n            xor_val = arr[i] ^ arr[j]\n            if xor_val > max_xor:\n                max_xor = xor_val\n                res = [arr[i], arr[j]]\n    return res\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maxPairXOR([3, 10, 5, 25, 2, 8])==[5, 25]\nassert maxPairXOR([8, 1, 2, 12, 7, 6, 4])==[7, 6]\nassert maxPairXOR([4, 6, 8, 2, 10, 12, 14, 16])==[10, 12]\nassert maxPairXOR([3, 5, 7, 9])==[7, 9]\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.861}, {"few_shot_keywords": "['accommodate', 'integer', 'value', 'array', 'tuple', 'function', 'allocation', 'remove', 'maximum', 'capacity', 'left', 'weight', 'knapsack', 'grid', 'algorithm']", "test_keywords": "['function', 'accommodate', 'tuple', 'maximum', 'MAC address', 'Regular Expression', 'value', 'permutations', 'bit manipulation', 'weight', 'integer', 'capacity', 'knapsack', 'array', 'span']", "prompt_tokens": 807, "total_tokens": 1175, "completion_tokens": 368, "completion": "[Question 2]\n\nYou are given an array of integers and a target integer value. Write a function to find all the tuples of two distinct elements in the array that accommodate the target value when their sum is calculated. The function should return a list of tuples containing the distinct pairs of elements that sum up to the target value.\n\nFor example, given the array [1, 3, 5, 7, 9] and the target value 10, the output will be [(3, 7)] as only the tuple (3, 7) accommodates the target value 10 when their sum is calculated.\n\nWrite a function findTuples that takes in the following parameters:\n- An array of integers\n- A target integer value\n\nThe function should return a list of tuples containing the distinct pairs of elements that sum up to the target value.\n\n[/Question 2]\n\n[Code 2]\n\ndef findTuples(arr: list, target: int) -> list:\n    result = []\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            if arr[i] + arr[j] == target:\n                result.append((arr[i], arr[j]))\n    return result\n\n[/Code 2]\n\n[Asserts 2]\n\nassert findTuples([1, 3, 5, 7, 9], 10) == [(3, 7)]\nassert findTuples([2, 4, 6, 8, 10, 12], 14) == [(4, 10), (6, 8)]\nassert findTuples([3, 6, 9, 12, 15], 18) == [(6, 12), (9, 9)]\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.773}, {"few_shot_keywords": "['difference', 'array', 'pairs', 'tuple', 'DFA', 'target', 'integer', 'count', 'longest', 'extra space', 'distinct']", "test_keywords": "['count', 'target', 'height', 'array', 'integer', 'pairs', 'depth-first search', 'glass', 'distinct', 'difference']", "prompt_tokens": 570, "total_tokens": 832, "completion_tokens": 262, "completion": "[Question 2]\n\nYou are given an array representing the heights of glasses on a shelf. The task is to count the number of distinct pairs of glasses that have a height difference equal to a given target height.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef countPairsWithHeightDifference(arr: List[int], target: int) -> int:\n    count = 0\n    n = len(arr)\n    for i in range(n):\n        for j in range(i+1, n):\n            if abs(arr[i] - arr[j]) == target:\n                count += 1\n    return count\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countPairsWithHeightDifference([1, 5, 3, 4, 2], 1)==3\nassert countPairsWithHeightDifference([8, 12, 16, 4, 0, 20], 4) == 9\nassert countPairsWithHeightDifference([1, 7, 5, 9, 2, 12, 3], 2) == 5\nassert countPairsWithHeightDifference([2, 4, 6, 8], 10) == 0\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.707}, {"few_shot_keywords": "['maximize', 'paint', 'sorted', 'array', 'extra space', 'HTML', 'sorting', 'merge', 'elements', 'algorithm', 'even levels', 'space complexity']", "test_keywords": "['space complexity', 'Globally Unique Identifier', 'extra space', 'array', 'sorted', 'electronic funds', 'merge', 'algorithm', 'sorting']", "prompt_tokens": 707, "total_tokens": 1126, "completion_tokens": 419, "completion": "[Question 2]\n\nYou are working with an electronic funds transfer system and need to generate Globally Unique Identifiers (GUIDs) for each transaction. You have an array of sorted transaction IDs and want to merge them with minimal space complexity, ensuring that each transaction ID is globally unique.\n\nWrite a function to merge the sorted transaction IDs into a single array with minimal space complexity while ensuring that each transaction ID is globally unique.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\ndef mergeTransactionIDs(IDs1: List[str], IDs2: List[str]) -> List[str]:\n    merged = []\n    i = 0\n    j = 0\n    while i < len(IDs1) and j < len(IDs2):\n        if IDs1[i] < IDs2[j]:\n            merged.append(IDs1[i])\n            i += 1\n        elif IDs1[i] > IDs2[j]:\n            merged.append(IDs2[j])\n            j += 1\n        else:\n            merged.append(IDs1[i])\n            i += 1\n            j += 1\n    merged.extend(IDs1[i:])\n    merged.extend(IDs2[j:])\n    return merged\n\n[/Code 2]\n\n[Asserts 2]\n\nassert mergeTransactionIDs(['1001', '1002', '1003'], ['1002', '1004', '1005']) == ['1001', '1002', '1003', '1004', '1005']\nassert mergeTransactionIDs(['2001', '2003', '2005'], ['2002', '2004', '2006']) == ['2001', '2002', '2003', '2004', '2005', '2006']\nassert mergeTransactionIDs(['3001', '3002', '3003'], ['3004', '3005', '3006']) == ['3001', '3002', '3003', '3004', '3005', '3006']\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.833}, {"few_shot_keywords": "['adjacency list', 'maximum', 'words', 'array', 'algorithm', 'minimum', 'integers', 'product', 'space', 'positive']", "test_keywords": "['Deterministic Finite Automaton', 'array', 'removing', 'present', 'Bellman-Ford algorithm', 'maximum', 'minimum', 'product', 'integers', 'queue']", "prompt_tokens": 594, "total_tokens": 1068, "completion_tokens": 474, "completion": "[Question 2]\n\nYou are given an array of integers representing the transition function for a deterministic finite automaton (DFA). The task is to remove the transition for a given integer if it is present, and then implement the Bellman-Ford algorithm to find the maximum product of the remaining integers in the array.\n\n[/Question 2]\n\n[Code 2]\n\nfrom collections import deque\n\ndef removeAndMaxProductDFA(transition: dict, remove: int) -> int:\n    transition.pop(remove, None)\n    max_product = float('-inf')\n    for state, next_state in transition.items():\n        for symbol, value in next_state.items():\n            if value > 0:\n                max_product = max(max_product, symbol * value)\n    return max_product\n\n[/Code 2]\n\n[Asserts 2]\n\ntransition = {1: {2: 3, 3: 4}, 2: {4: 5, 5: 6}, 3: {5: 7, 6: 8}}\nassert removeAndMaxProductDFA(transition, 2) == 42\nassert removeAndMaxProductDFA({1: {2: 3, 3: 4}, 2: {4: 5, 5: 6}, 3: {5: 7, 6: 8}}, 3) == 48\nassert removeAndMaxProductDFA({1: {2: 3, 3: 4}, 2: {4: 5, 5: 6}, 3: {5: 7, 6: 8}}, 4) == 56\nassert removeAndMaxProductDFA({1: {2: 3, 3: 4}, 2: {4: 5, 5: 6}, 3: {5: 7, 6: 8}}, 5) == 48\nassert removeAndMaxProductDFA({1: {2: 3, 3: 4}, 2: {4: 5, 5: 6}, 3: {5: 7, 6: 8}}, 6) == 56\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.891}, {"few_shot_keywords": "['search', 'insert', 'difference', 'delete', 'tree node', 'combinations', 'integer', 'function', 'element', 'unsorted', 'array', 'update']", "test_keywords": "['function', 'movement', 'queries', 'element', 'search', 'insert', 'array', 'unsorted', 'delete', 'update', 'reach', 'integer']", "prompt_tokens": 807, "total_tokens": 1227, "completion_tokens": 420, "completion": "[Question 2]\n\nYou are given an unsorted array of integers and a set of movement queries. The movement queries consist of elements to be searched, inserted, or deleted from the array. You need to write a function to process these movement queries and return the array after processing all the queries.\n\nThe function signature should be as follows:\n\n`processMovementQueries(arr: List[int], queries: List[Tuple[str, int]]) -> List[int]`: Process the movement queries on the array and return the final array after all the queries have been processed.\n\nEach query in the `queries` list is represented as a tuple where:\n- The first element is a string representing the type of movement ('search', 'insert', or 'delete').\n- The second element is an integer representing the element to be searched, inserted, or deleted.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List, Tuple\n\ndef processMovementQueries(arr: List[int], queries: List[Tuple[str, int]]) -> List[int]:\n    for query in queries:\n        action, element = query\n        if action == 'search':\n            if element in arr:\n                print(f\"{element} found in the array\")\n            else:\n                print(f\"{element} not found in the array\")\n        elif action == 'insert':\n            arr.append(element)\n            print(f\"{element} inserted into the array\")\n        elif action == 'delete':\n            if element in arr:\n                arr.remove(element)\n                print(f\"{element} deleted from the array\")\n            else:\n                print(f\"{element} not found in the array, delete operation failed\")\n    return arr\n\n[/Code 2]\n\n[Asserts 2]\n\narr = [5, 1, 9, 2, 5, 1, 7]\nqueries = [('search', 9), ('insert', 8), ('delete', 1)]\nassert processMovementQueries(arr, queries) == [5, 9, 2, 5, 7, 8]\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.899}, {"few_shot_keywords": "['sorting', 'equal-length', 'insert', 'search', 'array', 'leaf node', 'sequence', 'algorithm', 'delete', 'sorted', 'binary search']", "test_keywords": "['binary search', 'delete', 'array', 'sorted', 'algorithm', 'insert', 'indexes', 'search', 'India', 'sorting']", "prompt_tokens": 644, "total_tokens": 1042, "completion_tokens": 398, "completion": "[Question 2]\n\nGiven a sorted array of Indian city names and an operation to insert, delete or search for a city name, write a program to perform these operations. The program should utilize the binary search algorithm to efficiently search for city names in the array.\n\n[/Question 2]\n\n[Code 2]\n\nclass IndianCityArray:\n    def __init__(self, arr):\n        self.arr = arr\n\n    def search(self, city):\n        low = 0\n        high = len(self.arr) - 1\n        while low <= high:\n            mid = (low + high) // 2\n            if self.arr[mid] == city:\n                return mid\n            elif self.arr[mid] < city:\n                low = mid + 1\n            else:\n                high = mid - 1\n        return -1\n\n    def insert(self, city):\n        index = 0\n        for i in range(len(self.arr)):\n            if self.arr[i] < city:\n                index = i + 1\n            else:\n                break\n        self.arr.insert(index, city)\n\n    def delete(self, city):\n        if city in self.arr:\n            self.arr.remove(city)\n        else:\n            print(\"City not found in the array\")\n\nindian_cities = IndianCityArray([\"Ahmedabad\", \"Bangalore\", \"Chennai\", \"Delhi\", \"Kolkata\", \"Mumbai\"])\n\n[/Code 2]\n\n[Asserts 2]\n\nassert indian_cities.search(\"Chennai\") == 2\nindian_cities.insert(\"Hyderabad\")\nassert indian_cities.arr == [\"Ahmedabad\", \"Bangalore\", \"Chennai\", \"Delhi\", \"Hyderabad\", \"Kolkata\", \"Mumbai\"]\nindian_cities.delete(\"Delhi\")\nassert indian_cities.arr == [\"Ahmedabad\", \"Bangalore\", \"Chennai\", \"Hyderabad\", \"Kolkata\", \"Mumbai\"]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.85}, {"few_shot_keywords": "['common', '0s', 'list', 'sorted', 'comparison', 'representation', 'Kadane', 'array', 'intersection', 'integers', 'iteration', 'series']", "test_keywords": "['knapsack', 'comparison', 'odd levels', 'common', 'list', 'intersection', 'sorted', 'array', 'change', 'match', 'iteration']", "prompt_tokens": 804, "total_tokens": 1162, "completion_tokens": 358, "completion": "[Question 2]\n\nYou are given two integer arrays, A and B, both of which are sorted in non-decreasing order. You need to change A such that every element of A is in odd level and every element of A and B are common in A.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef changeArray(A: List[int], B: List[int]) -> List[int]:\n    index = 0\n    for i in range(len(A)):\n        if A[i] in B:\n            if index % 2 == 0:\n                A[i] = 2 * A[i]  # Changing the element to odd level\n            index += 1\n    return A\n\n[/Code 2]\n\n[Asserts 2]\n\nassert changeArray([2, 3, 4, 7, 8], [3, 5, 7, 9]) == [2, 6, 4, 7, 16]\nassert changeArray([1, 2, 3, 4, 5], [5, 6, 7, 8, 9]) == [2, 2, 6, 4, 10]\nassert changeArray([2, 4, 6, 8, 10], [1, 3, 5, 7, 9]) == [2, 4, 6, 8, 10]\nassert changeArray([1, 3, 5, 7, 9], [2, 4, 6, 8, 10]) == [2, 6, 10, 14, 18]\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.833}, {"few_shot_keywords": "['binary-search', 'water', 'queries', 'sorted', 'integer', 'search', 'infinite', 'efficient', 'array']", "test_keywords": "['array', 'index', 'efficient', 'size', 'search', 'infinite', 'capacity', 'binary-search', 'parity', 'integer', 'sorted']", "prompt_tokens": 606, "total_tokens": 952, "completion_tokens": 346, "completion": "[Question 2]\n\nYou are given an infinite sorted array of integers and a target integer x. Write a function to find the index of the target integer in the array using an efficient approach. The array has a maximum capacity of size \"capacity\".\n\n[/Question 2]\n\n[Code 2]\n\ndef findIndex(arr, target, capacity):\n    l, h = 0, min(capacity, len(arr) - 1)\n    while l <= h and arr[h] < target:\n        l = h + 1\n        h = min(h + (h - l + 1) * 2, len(arr) - 1)\n\n    while l <= h:\n        mid = l + (h - l) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            l = mid + 1\n        else:\n            h = mid - 1\n    return -1\n\n[/Code 2]\n\n[Asserts 2]\n\nassert findIndex([1, 3, 5, 7, 9, 11, 13, 15, 17, 19], 7, 10) == 3\nassert findIndex([1, 3, 5, 7, 9, 11, 13, 15, 17, 19], 20, 10) == -1\nassert findIndex([2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22], 14, 15) == 6\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.701}, {"few_shot_keywords": "['pair', 'count', 'typing', 'less than', 'array', 'program', 'search', 'product', 'list', 'minimize', 'time', 'integer', 'subsequence']", "test_keywords": "['child', 'count', 'list', 'product', 'less than', 'mask', 'queries', 'array', 'subsequence', 'integer', 'CVV', 'typing']", "prompt_tokens": 560, "total_tokens": 827, "completion_tokens": 267, "completion": "[Question 2]\n\nYou are given an array of integers and a mask value. Your task is to write a program to count the number of sub-sequences whose product is less than the given mask value.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\ndef countSubsequencesLessThanMask(arr: List[int], mask: int) -> int:\n    count = 0\n    n = len(arr)\n    for i in range(1, 1 << n):\n        product = 1\n        for j in range(n):\n            if (i & (1 << j)):\n                product *= arr[j]\n        if product < mask:\n            count += 1\n    return count\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countSubsequencesLessThanMask([2, 3, 4], 10) == 6\nassert countSubsequencesLessThanMask([1, 2, 3, 4, 5], 30) == 26\nassert countSubsequencesLessThanMask([3, 7, 10], 100) == 7\nassert countSubsequencesLessThanMask([5, 6, 7, 8, 9], 100) == 26\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.822}, {"few_shot_keywords": "['nearest', 'array', 'closest', 'duplicate', 'water', 'bitwise', 'unique', 'integer', 'arithmetic progression', 'element', 'xor']", "test_keywords": "['image', 'duplicate', 'unique', 'digits', 'xor', 'array', 'element', 'bitwise', 'integer']", "prompt_tokens": 468, "total_tokens": 653, "completion_tokens": 185, "completion": "[Question 2]\n\nYou are given an array of integers where every element appears twice except for one. How can you find the unique integer using bitwise XOR operation?\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef findUniqueInteger(arr: List[int]) -> int:\n    unique = 0\n    for num in arr:\n        unique ^= num\n    return unique\n\n[/Code 2]\n\n[Asserts 2]\n\nassert findUniqueInteger([4, 3, 4, 4, 4, 5, 5, 3, 5]) == 4\nassert findUniqueInteger([1, 2, 2, 3, 3]) == 1\nassert findUniqueInteger([7, 3, 5, 4, 5, 3, 4]) == 7\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.822}, {"few_shot_keywords": "['iteration', 'count', 'sum', 'image', 'array', 'triplets', 'span', 'complete', 'perfect cube', 'nested loop']", "test_keywords": "['enumeration', 'sum', 'operations', 'iteration', 'count', 'nested loop', 'triplets', 'perfect cube', 'subset', 'array', 'min']", "prompt_tokens": 606, "total_tokens": 918, "completion_tokens": 312, "completion": "[Question 2]\n\nGiven an array of integers, write a function to find the minimum sum of perfect cube triplets within a subset of the array.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef minSubsetSumOfPerfectCubes(arr: List[int]) -> int:\n    def isPerfectCube(x):\n        cubeRoot = int(x ** (1 / 3))\n        return cubeRoot ** 3 == x\n\n    n = len(arr)\n    minSum = float('inf')\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                if isPerfectCube(arr[i] + arr[j] + arr[k]):\n                    minSum = min(minSum, arr[i] + arr[j] + arr[k])\n    return minSum\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minSubsetSumOfPerfectCubes([1, 2, 3, 4, 5, 6, 7, 8, 9]) == 6\nassert minSubsetSumOfPerfectCubes([3, 7, 11, 17, 25, 28, 36, 40]) == 28\nassert minSubsetSumOfPerfectCubes([1, 8, 27, 64, 125, 216, 343, 512, 729, 1000]) == 192\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.898}, {"few_shot_keywords": "['maximum', 'Goods and Services Tax', 'extension', 'integer division', 'sum', 'integer', 'exclude', 'substring', 'subarray', 'data structure', 'array']", "test_keywords": "['maximum', 'sum', 'integer', 'leaf node', 'subarray', 'array', 'exclude', 'strictly decreasing']", "prompt_tokens": 641, "total_tokens": 910, "completion_tokens": 269, "completion": "[Question 2]\n\nGiven a binary tree, the task is to find the maximum sum of a strictly decreasing subarray from root to leaf node.\n\n[/Question 2]\n\n[Code 2]\n\nclass TreeNode:\n    def __init__(self, value=0, left=None, right=None):\n        self.value = value\n        self.left = left\n        self.right = right\n\ndef maxStrictlyDecreasingSum(root: TreeNode) -> int:\n    if not root:\n        return 0\n\n    def dfs(node, prev):\n        if not node:\n            return 0\n\n        current = node.value + (0 if prev >= node.value else dfs(node.left, node.value) + dfs(node.right, node.value))\n        return max(dfs(node.left, prev), dfs(node.right, prev), current)\n\n    return dfs(root, float('inf'))\n\n[/Code 2]\n\n[Asserts 2]\n\ntree = TreeNode(10, TreeNode(5, TreeNode(2), TreeNode(7)), TreeNode(15, None, TreeNode(20)))\nassert maxStrictlyDecreasingSum(tree) == 32\n\ntree = TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(5)), TreeNode(3, TreeNode(6), TreeNode(7)))\nassert maxStrictlyDecreasingSum(tree) == 7", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.809}, {"few_shot_keywords": "['capacity', 'unbounded', 'value', 'items', 'alternate', 'perfect cube', 'modulo', 'maximum', 'bit manipulation', 'knapsack']", "test_keywords": "['modulo', 'knapsack', 'unbounded', 'value', 'count', 'modulus', 'items', 'maximum', 'capacity']", "prompt_tokens": 584, "total_tokens": 1007, "completion_tokens": 423, "completion": "[Question 2]\n\nYou are given a set of N items, each with a certain value and weight. Given a knapsack with a maximum capacity of W, find the maximum value that can be obtained by selecting a subset of the items such that the sum of their weights does not exceed W. Additionally, the value obtained should be divisible by a given modulus M.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\ndef knapsackWithModulus(W: int, M: int, n: int, val: List[int], wt: List[int]) -> int:\n    dp = [-1] * (W + 1)\n    dp[0] = 0\n\n    for i in range(1, W + 1):\n        for j in range(n):\n            if wt[j] <= i:\n                if dp[i - wt[j]] != -1:\n                    dp[i] = max(dp[i], dp[i - wt[j]] + val[j])\n\n    max_val = 0\n    for i in range(W + 1):\n        if dp[i] != -1 and dp[i] % M == 0:\n            max_val = max(max_val, dp[i])\n\n    return max_val\n\n[/Code 2]\n\n[Asserts 2]\n\nassert knapsackWithModulus(10, 3, 3, [1, 5, 2], [3, 4, 1]) == 9\nassert knapsackWithModulus(8, 4, 3, [2, 7, 4], [2, 4, 3]) == 8\nassert knapsackWithModulus(6, 5, 3, [3, 4, 6], [2, 3, 5]) == 6\nassert knapsackWithModulus(5, 2, 3, [2, 3, 4], [3, 2, 1]) == 4\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.774}, {"few_shot_keywords": "['Regular Expression', 'array', 'algorithm', 'operation', 'Kadane', 'subarray', 'maximum', 'sum', 'space optimization', 'repetitions', 'Next Fit', 'remove']", "test_keywords": "['space', 'edges', 'array', 'subarray', 'remove', 'maximum', 'sort', 'GST', 'Kadane', 'algorithm', 'sum', 'vertices']", "prompt_tokens": 729, "total_tokens": 1159, "completion_tokens": 430, "completion": "[Question 2]\n\nGiven an array representing the daily stock price, the task is to find the maximum profit that can be obtained by performing at most one transaction, where a transaction consists of buying the stock on one day and selling it on another day. You can remove at most one element to maximize the profit.\n\n[/Question 2]\n\n[Code 2]\n\ndef maxProfit(prices: List[int]) -> int:\n        n = len(prices)\n        if n == 0:\n            return 0\n\n        max_profit = 0\n        min_price = prices[0]\n        max_profit_array = [0] * n\n        min_price_array = [0] * n\n\n        for i in range(n):\n            min_price = min(min_price, prices[i])\n            min_price_array[i] = min_price\n\n        for i in range(1, n):\n            max_profit = max(max_profit, prices[i] - min_price_array[i-1])\n            max_profit_array[i] = max_profit\n\n        max_profit = 0\n        max_price = prices[n-1]\n\n        for i in range(n-1, 0, -1):\n            max_price = max(max_price, prices[i])\n            max_profit = max(max_profit, max_price - prices[i-1])\n            max_profit_array[i-1] += max_profit\n\n        return max(max_profit_array)\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maxProfit([7, 1, 5, 3, 6, 4]) == 7\nassert maxProfit([7, 6, 4, 3, 1]) == 0\nassert maxProfit([3, 2, 6, 5, 0, 3]) == 7\nassert maxProfit([2, 3, 1, 4, 5, 7, 3, 2, 9, 8, 5, 4]) == 8\nassert maxProfit([2, 1]) == 0\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.916}, {"few_shot_keywords": "['height', 'sum', 'combinations', 'node', 'shortest path', 'recursion', 'loop', 'binary tree', 'tree traversal']", "test_keywords": "['tree traversal', 'recursion', '7-character string', 'node', 'binary tree', 'unsorted', 'column', 'height', 'sum']", "prompt_tokens": 505, "total_tokens": 761, "completion_tokens": 256, "completion": "[Question 2]\n\nYou are given an unsorted binary tree. Write a recursive function to find the sum of the heights of all nodes whose value forms a 7-character string by performing an in-order traversal of the tree.\n\n[/Question 2]\n\n[Code 2]\n\nclass Node:\n    def __init__(self, key):\n        self.data = key\n        self.left = None\n        self.right = None\n\ndef height(node: Node) -> int:\n\tif node is None:\n\t\treturn 0\n\treturn 1 + max(height(node.left), height(node.right))\n\ndef sumOfHeightFor7CharStrings(node: Node) -> int:\n\tif node is None:\n\t\treturn 0\n\ttotal_sum = 0\n\ttotal_sum += sumOfHeightFor7CharStrings(node.left)\n\tif len(str(node.data)) == 7:\n\t\ttotal_sum += height(node)\n\ttotal_sum += sumOfHeightFor7CharStrings(node.right)\n\treturn total_sum\n\n# Sample binary tree creation\nroot = Node(\"abcdefg\")\nroot.left = Node(\"1234567\")\nroot.right = Node(\"xyz\")\n\n[/Code 2]\n\n[Asserts 2]\n\nassert(sumOfHeightFor7CharStrings(root)) == 8\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.801}, {"few_shot_keywords": "['top left', 'weight', 'prefix', 'last row', 'cell', 'integer', 'maximum', 'path', 'height', 'frequency', 'alphanumeric', 'adjacent', 'matrix', 'absolute difference', 'dynamic programming']", "test_keywords": "['dynamic programming', 'top left', 'weight', 'matrix', 'enumeration', 'integer', 'last row', 'maximum', 'batches', 'path', 'range', 'adjacent', 'cell']", "prompt_tokens": 866, "total_tokens": 1384, "completion_tokens": 518, "completion": "[Question 2]\n\nYou are given a matrix of dimensions N x M. Each cell in the matrix contains an integer representing the weight of the corresponding batch. The task is to find the maximum weight path from the top left to any cell in the last row. You can only move to adjacent cells (i.e., right, right-down, or down). Write a dynamic programming solution to find the maximum weight path.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\ndef maxWeightPath(matrix: List[List[int]]) -> int:\n    n = len(matrix)\n    m = len(matrix[0])\n    dp = [[0 for _ in range(m)] for _ in range(n)]\n\n    for i in range(n):\n        for j in range(m):\n            if i == 0:  # fill the first row\n                dp[i][j] = matrix[i][j]\n            else:\n                if j == 0:  # handle the leftmost column\n                    dp[i][j] = matrix[i][j] + max(dp[i-1][j], dp[i-1][j+1])\n                elif j == m-1:  # handle the rightmost column\n                    dp[i][j] = matrix[i][j] + max(dp[i-1][j-1], dp[i-1][j])\n                else:  # handle the rest of the columns\n                    dp[i][j] = matrix[i][j] + max(dp[i-1][j-1], dp[i-1][j], dp[i-1][j+1])\n\n    return max(dp[n-1])\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maxWeightPath([[4, 2, 3, 4], [2, 9, 1, 10], [15, 1, 3, 0], [16, 92, 41, 44]]) == 128\nassert maxWeightPath([[1, 2, 3, 4], [4, 5, 6, 7], [8, 9, 10, 11], [12, 13, 14, 15]]) == 30\nassert maxWeightPath([[1, 2, 3, 4, 5], [6, 7, 8, 9, 10], [11, 12, 13, 14, 15]]) == 33\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.893}, {"few_shot_keywords": "['element', 'removing', 'integers', 'array', 'paint', 'left', 'greater', 'prefix', 'recursive', 'optimization', 'right', 'remove', 'function', 'binary search', 'minimum']", "test_keywords": "['element', 'prefix', 'removal', 'left', 'array', 'integers', 'undirected', 'minimum', 'greater', 'algorithm', 'squares', 'function', 'remove', 'right', 'alternate']", "prompt_tokens": 699, "total_tokens": 1002, "completion_tokens": 303, "completion": "[Question 2]\n\nGiven an array of integers, the task is to remove elements from the array in an alternate fashion such that the sum of squares of remaining elements is minimum. Write a function to find the minimum sum of squares after the removal of elements.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef minSumOfSquares(arr: List[int]) -> int:\n    arr.sort()\n    n = len(arr)\n    prefixSum = [0] * (n + 1)\n    for i in range(1, n + 1):\n        prefixSum[i] = prefixSum[i - 1] + arr[i - 1]\n    minSum = 0\n    for i in range(n, 0, -2):\n        minSum += arr[i - 1] ** 2\n    return minSum\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minSumOfSquares([4, 5, 3, 1, 2]) == 10\nassert minSumOfSquares([1, 2, 3, 4, 5, 6]) == 22\nassert minSumOfSquares([7, 3, 2, 8, 6, 4, 5]) == 82\nassert minSumOfSquares([5, 4, 3, 2, 1]) == 15\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.868}, {"few_shot_keywords": "['dynamic programming', 'combinations', 'recursion', 'grid', 'down', 'reach', 'movement', 'paths', 'right', 'corner', 'matrix', 'divide and conquer']", "test_keywords": "['dynamic programming', 'movement', 'branch', 'grid', 'paths', 'down', 'matrix', 'reach', 'right', 'pair', 'combinations', 'corner']", "prompt_tokens": 536, "total_tokens": 839, "completion_tokens": 303, "completion": "[Question 2]\n\nGiven a matrix of size m x n, write a function to count the number of unique paths from the top-left corner to the bottom-right corner, with the ability to move only down or right. Additionally, you are allowed to move diagonally in the form of a pair of movements: down and right. Using dynamic programming, implement a solution to find the total number of unique paths.\n\n[/Question 2]\n\n[Code 2]\n\ndef uniquePaths(m: int, n: int) -> int:\n    dp = [[0] * n for _ in range(m)]\n    \n    for i in range(m):\n        dp[i][0] = 1\n    \n    for j in range(n):\n        dp[0][j] = 1\n        \n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = dp[i-1][j] + dp[i][j-1] + dp[i-1][j-1]\n            \n    return dp[m-1][n-1]\n\n[/Code 2]\n\n[Asserts 2]\n\nassert uniquePaths(3, 3) == 6\nassert uniquePaths(3, 2) == 3\nassert uniquePaths(7, 3) == 28\nassert uniquePaths(3, 7) == 28\nassert uniquePaths(1, 1) == 1\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.857}, {"few_shot_keywords": "['array', 'Kadane', 'subsets', 'memory', 'common', 'PIN', 'equal-length', 'repetitions', 'split']", "test_keywords": "['characters', 'repetitions', 'fraudulent use', 'identical', 'subsets', 'split', 'product', 'array', 'equal-length', 'lowercase']", "prompt_tokens": 711, "total_tokens": 955, "completion_tokens": 244, "completion": "[Question 2]\n\nYou are given an array of lowercase characters representing a user's PIN input. The user is suspected of fraudulent use of identical subsets of characters in their PIN. Write a function `checkFraudulentPIN(pin: str) -> bool` that checks if the product of ASCII values of characters in the two equal-length subsets of the PIN is equal, indicating a potential fraudulent use.\n\n[/Question 2]\n\n[Code 2]\n\ndef checkFraudulentPIN(pin: str) -> bool:\n    n = len(pin)\n    if n % 2 != 0:\n        return False\n    product1 = 1\n    product2 = 1\n    for i in range(n // 2):\n        product1 *= ord(pin[i])\n        product2 *= ord(pin[n // 2 + i])\n    return product1 == product2\n\n[/Code 2]\n\n[Asserts 2]\n\nassert checkFraudulentPIN('abcdef') == False\nassert checkFraudulentPIN('abab') == True\nassert checkFraudulentPIN('xyzzyx') == True\nassert checkFraudulentPIN('hello') == False\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.881}, {"few_shot_keywords": "['algorithm', 'corner', 'distance', 'contiguous', 'divide and conquer', 'natural number', 'subtracting', 'subarray', 'sum', 'digit']", "test_keywords": "['algorithm', 'subarray', 'utility function', 'node value', 'sum', 'divide and conquer', 'odd levels', 'rearrange', 'contiguous']", "prompt_tokens": 681, "total_tokens": 1108, "completion_tokens": 427, "completion": "[Question 2]\n\nGiven a binary tree, write a utility function to rearrange the node values at odd levels such that the sum of values in each contiguous subarray at odd levels is maximized using the Divide and Conquer algorithm.\n\n[/Question 2]\n\n[Code 2]\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef maxSumContiguousOddLevels(root):\n    def maxSumHelper(node, level):\n        if not node:\n            return 0\n\n        if level % 2 == 1:\n            left_sum = maxSumHelper(node.left, level + 1)\n            right_sum = maxSumHelper(node.right, level + 1)\n\n            return node.val + max(left_sum, right_sum)\n        else:\n            left_sum = maxSumHelper(node.left, level + 1)\n            right_sum = maxSumHelper(node.right, level + 1)\n\n            return left_sum + right_sum\n\n    return maxSumHelper(root, 1)\n\n[/Code 2]\n\n[Asserts 2]\n\n# Create a binary tree\n#        1\n#       / \\\n#      2   3\n#     / \\\n#    4   5\n# The maximum sum from contiguous subarrays at odd levels is 10 (3 + 7).\nassert maxSumContiguousOddLevels(TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(5)), TreeNode(3))) == 10\n\n# Create a binary tree\n#        4\n#       / \\\n#      3   5\n#     / \\   \\\n#    2   6   7\n# The maximum sum from contiguous subarrays at odd levels is 15 (4 + 11).\nassert maxSumContiguousOddLevels(TreeNode(4, TreeNode(3, TreeNode(2), TreeNode(6)), TreeNode(5, None, TreeNode(7)))) == 15\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.935}, {"few_shot_keywords": "['stack', 'swapping', 'algorithm', '7-character string', 'math', 'leaf', 'capacity', 'two-elements', 'glass', 'dynamic programming', 'optimization', 'water', 'row']", "test_keywords": "['minimum', 'glass', 'stack', 'combinations', 'row', 'math', 'matrix', 'water', 'cost', 'algorithm', 'capacity', 'dynamic programming', 'movement']", "prompt_tokens": 675, "total_tokens": 936, "completion_tokens": 261, "completion": "[Question 2]\n\nYou are given a stack of glasses, each glass with a certain capacity. Write a function to determine the minimum cost to fill a certain amount of water into the glasses using dynamic programming. The cost of filling a glass is the product of the amount of water filled and the capacity of the glass.\n\n[/Question 2]\n\n[Code 2]\n\ndef minCostToFillWater(glasses: List[int], water: int) -> int:\n    n = len(glasses)\n    dp = [float('inf')] * (water + 1)\n    dp[0] = 0\n    for i in range(1, n + 1):\n        for w in range(water, -1, -1):\n            dp[w] = min(dp[w], glasses[i - 1] * max(0, w - glasses[i - 1]))\n    return dp[water]\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minCostToFillWater([1, 2, 3], 3)==3\nassert minCostToFillWater([2, 3, 4, 1], 5)==6\nassert minCostToFillWater([3, 1, 5, 2], 7)==8", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.822}, {"few_shot_keywords": "['integer', 'sum', 'height', 'subtree', 'binary tree', 'recursive', 'traverse', 'match', 'leaf']", "test_keywords": "['selection', 'binary tree', 'right', 'LCS', 'subtree', 'strings', 'recursive', 'sum', 'traverse', 'integer']", "prompt_tokens": 604, "total_tokens": 1125, "completion_tokens": 521, "completion": "[Question 2]\n\nGiven two binary trees, find the sum of the integers formed by the nodes on the right side of the subtree which is the longest common subsequence (LCS) of the two trees. Implement a recursive function to traverse the trees and find the LCS, and then calculate the sum of the integers formed by the right nodes of the LCS subtree.\n\n[/Question 2]\n\n[Code 2]\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n        \ndef sumOfRightNodesLCS(root1: TreeNode, root2: TreeNode) -> int:\n    def lcs(root1, root2):\n        if not root1 or not root2:\n            return ''\n        if root1.val == root2.val:\n            return str(root1.val) + lcs(root1.right, root2.right)\n        else:\n            return max(lcs(root1, root2.right), lcs(root1.right, root2), key=len)\n    \n    lcs_str = lcs(root1, root2)\n    \n    def sum_right_nodes(node, is_lcs):\n        if not node:\n            return 0\n        if is_lcs and node.right:\n            return node.val + sum_right_nodes(node.right, is_lcs) + sum_right_nodes(node.left, is_lcs)\n        else:\n            return sum_right_nodes(node.right, is_lcs) + sum_right_nodes(node.left, is_lcs)\n    \n    return sum_right_nodes(root1, False) + sum_right_nodes(root2, False) + sum_right_nodes(root1, True)\n\n[/Code 2]\n\n[Asserts 2]\n\ntree1 = TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(5)), TreeNode(3, TreeNode(6), TreeNode(7)))\ntree2 = TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(5)), TreeNode(3, TreeNode(6), TreeNode(7)))\nassert sumOfRightNodesLCS(tree1, tree2) == 22\ntree3 = TreeNode(3, TreeNode(1, TreeNode(4), TreeNode(5)), TreeNode(2, TreeNode(6), TreeNode(7)))\ntree4 = TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(5)), TreeNode(3, TreeNode(6), TreeNode(7)))\nassert sumOfRightNodesLCS(tree3, tree4) == 21\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.91}, {"few_shot_keywords": "['palindromic', 'alpha', 'replacement', 'transform', 'minimum', 'matrix', 'column', 'element', 'row', 'paint', 'lowercase', 'repeating characters']", "test_keywords": "['transform', 'lowercase', 'sorted', 'alpha', 'replacement', 'minimum', 'palindromic', 'memory', 'column', 'row', 'element', 'matrix']", "prompt_tokens": 730, "total_tokens": 1067, "completion_tokens": 337, "completion": "[Question 2]\n\nGiven a matrix with R rows and C columns, each containing lowercase alphabets, write a function to determine the minimum number of replacements needed to transform the matrix into a matrix where each row is sorted in alphabetical order. The replacements should be such that the memory usage is minimized.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef minMemoryReplacements(matrix: List[List[str]], R: int, C: int) -> int:\n    cnt = 0\n    for i in range(R):\n        sorted_row = sorted(matrix[i])\n        for j in range(C):\n            if matrix[i][j] != sorted_row[j]:\n                cnt += 1\n    return cnt\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minMemoryReplacements([['a', 'b', 'c'], ['z', 'a', 'a'], ['b', 'b', 'a']], 3, 3) == 3\nassert minMemoryReplacements([['a', 'b', 'c', 'd'], ['z', 'a', 'a', 'z'], ['b', 'b', 'a', 'b']], 3, 4) == 6\nassert minMemoryReplacements([['z', 'x', 'y'], ['y', 'z', 'x'], ['x', 'y', 'z']], 3, 3) == 6\nassert minMemoryReplacements([['a', 'b'], ['a', 'b'], ['b', 'a']], 3, 2) == 2\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.717}, {"few_shot_keywords": "['string', 'ancestor', 'child', 'characters', 'convert', 'bit manipulation', 'boolean', 'consecutive', 'identical', 'multiple']", "test_keywords": "['knapsack', 'characters', 'recursive', 'identical', 'boolean', 'consecutive', 'repeating characters', 'string']", "prompt_tokens": 552, "total_tokens": 788, "completion_tokens": 236, "completion": "[Question 2]\n\nWrite a recursive function to find the maximum number of consecutive repeating characters in a given string. The function should take a string as input and return the maximum count of consecutive repeating characters in the string.\n\n[/Question 2]\n\n[Code 2]\n\n```python\ndef maxConsecutiveRepeating(s: str) -> int:\n    if not s:\n        return 0\n    \n    max_count = 1\n    count = 1\n    \n    for i in range(len(s) - 1):\n        if s[i] == s[i + 1]:\n            count += 1\n            max_count = max(max_count, count)\n        else:\n            count = 1\n            \n    return max_count\n```\n\n[Asserts 2]\n\n```python\nassert maxConsecutiveRepeating(\"hello\") == 2\nassert maxConsecutiveRepeating(\"aaabbbbccc\") == 4\nassert maxConsecutiveRepeating(\"aabbcc\") == 2\nassert maxConsecutiveRepeating(\"aabbcccc\") == 4\nassert maxConsecutiveRepeating(\"aa\") == 2\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.718}, {"few_shot_keywords": "['root', 'string', 'regular expression', 'divisible', 'format', 'validation', 'MAC address', 'hexadecimal', 'pattern']", "test_keywords": "['format', 'string', 'regular expression', 'validation', 'MAC address', 'transform', 'lambda function', 'hexadecimal', 'pattern']", "prompt_tokens": 558, "total_tokens": 870, "completion_tokens": 312, "completion": "[Question 2]\n\nWrite a Python function that takes a string input representing a MAC address and transforms it into a standardized format. The input MAC address may be in various formats, such as \"00:1A:C2:35:00:99\" or \"0C-1A-38-C1-46-12\", and the output should always be in the format \"XX:XX:XX:XX:XX:XX\", where X is a hexadecimal digit (0-9, A-F or a-f).\n\n[/Question 2]\n\n[Code 2]\n\ndef transformMACAddress(mac: str) -> str:\n    transform_format = lambda s: ':'.join([x.zfill(2) for x in s.split('-')])\n    if '-' in mac:\n        return transform_format(mac)\n    else:\n        return mac\n\n[/Code 2]\n\n[Asserts 2]\n\nassert transformMACAddress(\"00-1A-C2-35-00-99\") == \"00:1A:C2:35:00:99\"\nassert transformMACAddress(\"0C-1A-38-C1-46-12\") == \"0C:1A:38:C1:46:12\"\nassert transformMACAddress(\"AB:CD:EF:12:34:56\") == \"AB:CD:EF:12:34:56\"\nassert transformMACAddress(\"78-90-BC-DE-F1-23\") == \"78:90:BC:DE:F1:23\"", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.927}, {"few_shot_keywords": "['filled', 'pattern matching', 'GUID', 'regular expression', 'validate', 'function', 'Python', 'decimal', 'Globally Unique Identifier', 'regex']", "test_keywords": "['Python', 'regex', 'Globally Unique Identifier', 'pattern matching', 'validate', 'number', 'binary tree', 'GUID', 'function', 'regular expression']", "prompt_tokens": 544, "total_tokens": 797, "completion_tokens": 253, "completion": "[Question 2]\n\nIn Python, write a function to validate if a given string is a valid Globally Unique Identifier (GUID) using regular expressions and pattern matching.\n\n[/Question 2]\n\n[Code 2]\n\nimport re\n\ndef validateGUID(guid: str) -> bool:\n    pattern = re.compile('^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[1-5][a-fA-F0-9]{3}-[89abAB][a-fA-F0-9]{3}-[a-fA-F0-9]{12}$')\n    if re.match(pattern, guid):\n        return True\n    else:\n        return False\n\n[/Code 2]\n\n[Asserts 2]\n\nassert(validateGUID(\"01234567-89ab-cdef-0123-456789abcdef\"))==True\nassert(validateGUID(\"01234567-89AB-CDEF-0123-456789ABCDEF\"))==True\nassert(validateGUID(\"01234567-89ab-cdef-0123\"))==False\nassert(validateGUID(\"01234 567-89ab-cdef-0123-456789abcdef\"))==False\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.775}, {"few_shot_keywords": "['validation', 'letter', 'regex', 'format', 'driving license', 'uppercase', 'function', 'digit', 'split', 'Indian']", "test_keywords": "['check', 'adjacency list', 'driving license', 'Indian', 'letter', 'digit', 'format', 'regex', 'validation', 'string', 'uppercase']", "prompt_tokens": 533, "total_tokens": 1098, "completion_tokens": 565, "completion": "[Question 2]\n\nCreate a Python function to check if a given string represents a valid Indian driving license number based on an adjacency list representation. The format of the Indian driving license number is defined as follows: XXXX-YYYYYYY-ZZZZ, where X can be any uppercase letter, Y can be any digit, and Z can be any uppercase letter. Implement the function to validate the given string based on this format and adjacency list representation.\n\n[/Question 2]\n\n[Code 2]\n\ndef checkValidIndianDrivingLicense(adjacency_list: dict, license_num: str) -> bool:\n    if len(license_num) != 16 or license_num[4] != '-' or license_num[11] != '-':\n        return False\n    \n    for i in range(4):\n        if not adjacency_list['uppercase'].get(license_num[i]):\n            return False\n    \n    for i in range(5, 12):\n        if not adjacency_list['digit'].get(license_num[i]):\n            return False\n    \n    for i in range(12, 16):\n        if not adjacency_list['uppercase'].get(license_num[i]):\n            return False\n    \n    return True\n\n[/Code 2]\n\n[Asserts 2]\n\nadjacency_list = {\n    'uppercase': {'A': True, 'B': True, 'C': True, 'D': True, 'E': True, 'F': True, 'G': True, 'H': True, 'I': True, 'J': True, 'K': True, 'L': True, 'M': True, 'N': True, 'O': True, 'P': True, 'Q': True, 'R': True, 'S': True, 'T': True, 'U': True, 'V': True, 'W': True, 'X': True, 'Y': True, 'Z': True},\n    'digit': {'0': True, '1': True, '2': True, '3': True, '4': True, '5': True, '6': True, '7': True, '8': True, '9': True}\n}\n\nassert checkValidIndianDrivingLicense(adjacency_list, \"ABCD-1234567-EFGH\")==True\nassert checkValidIndianDrivingLicense(adjacency_list, \"WXYZ-9876543-ABCD\")==True\nassert checkValidIndianDrivingLicense(adjacency_list, \"1234-5678901-ABCD\")==False\nassert checkValidIndianDrivingLicense(adjacency_list, \"AB!@-1234567-EFGH\")==False\nassert checkValidIndianDrivingLicense(adjacency_list, \"ABCD-123456789-EFGH\")==False\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.786}, {"few_shot_keywords": "['validate', 'Indian passport', 'Python', 'Regular Expression', 'shortest path', 'payment card', '7-character string', 'memory', 'function', 'array', 'digits', 'difference', 'alphabet']", "test_keywords": "['input', 'Python', '7-character string', 'alphabet', 'function', 'digits', 'inclusive', 'height', 'Regular Expression', 'validate', 'Indian passport']", "prompt_tokens": 502, "total_tokens": 766, "completion_tokens": 264, "completion": "[Question 2]\n\nWrite a Python function to validate the height of a person in an Indian passport. The height should be represented as a 3-digit number followed by either 'cm' or 'in' (centimeters or inches), and it should be between 150cm and 190cm inclusive, or between 59in and 75in inclusive.\n\n[/Question 2]\n\n[Code 2]\n\nimport re\n\ndef validatePassportHeight(height: str) -> bool:\n    pattern = \"^(1[5-8][0-9]cm|190cm|[5-6][0-9]in|70in|71in|72in|73in|74in|75in)$\"\n    if re.match(pattern, height):\n        return True\n    else:\n        return False\n\n[/Code 2]\n\n[Asserts 2]\n\nassert validatePassportHeight(\"170cm\")==True\nassert validatePassportHeight(\"160cm\")==True\nassert validatePassportHeight(\"180cm\")==True\nassert validatePassportHeight(\"195cm\")==False\nassert validatePassportHeight(\"65in\")==True\nassert validatePassportHeight(\"55in\")==False\nassert validatePassportHeight(\"72in\")==True\nassert validatePassportHeight(\"80in\")==False", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.868}, {"few_shot_keywords": "['validation', 'adjacency list', 'pattern matching', 'positive integer', 'regular expressions', 'credit card', 'string']", "test_keywords": "['pattern matching', 'credit card', 'child', 'update', 'string', 'validation', 'regular expressions']", "prompt_tokens": 450, "total_tokens": 687, "completion_tokens": 237, "completion": "[Question 2]\n\nWrite a function to validate and update a credit card number by adding '123' at the end of the string if it represents a child credit card (has 'child' in the number) using pattern matching and regular expressions.\n\n[/Question 2]\n\n[Code 2]\n\nimport re\ndef validateAndUpdateCreditCard(cardNumber: str) -> str:\n    childPattern = re.compile(r'^[0-9]{4}-child-[0-9]{4}-[0-9]{4}-[0-9]{4}$')\n    if childPattern.match(cardNumber):\n        return cardNumber + '123'\n    else:\n        return \"Invalid credit card format\"\n\n[/Code 2]\n\n[Asserts 2]\n\nassert(validateAndUpdateCreditCard(\"1234-child-5678-9101-1121\"))==\"1234-child-5678-9101-1121-123\"\nassert(validateAndUpdateCreditCard(\"5678-child-1234-5678-9101\"))==\"Invalid credit card format\"\nassert(validateAndUpdateCreditCard(\"5678-9101-1121-1234-child\"))==\"Invalid credit card format\"", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.858}, {"few_shot_keywords": "['negative weight cycle', 'validation', 'python', 'MasterCard', 'credit card', 'continuous', 'regular expression']", "test_keywords": "['regular expression', 'subtracting', 'python', 'longest', 'credit card', 'distinct', 'MasterCard', 'validation']", "prompt_tokens": 459, "total_tokens": 679, "completion_tokens": 220, "completion": "[Question 2]\n\nIn Python, write a program to find the longest distinct substring in a given string using regular expressions.\n\n[/Question 2]\n\n[Code 2]\n\nimport re\n\ndef longestDistinctSubstring(inputString: str) -> str:\n\tlongestSubstr = ''\n\tfor i in range(len(inputString)):\n\t\tfor j in range(i+1, len(inputString)+1):\n\t\t\tsubstr = inputString[i:j]\n\t\t\tif len(set(substr)) == len(substr) and len(substr) > len(longestSubstr):\n\t\t\t\tlongestSubstr = substr\n\treturn longestSubstr\n\n[/Code 2]\n\n[Asserts 2]\n\nassert longestDistinctSubstring(\"abracadabra\") == \"bracad\"\nassert longestDistinctSubstring(\"pqrstuvw\") == \"pqrstuvw\"\nassert longestDistinctSubstring(\"abcabcbb\") == \"abc\"\nassert longestDistinctSubstring(\"bbbbb\") == \"b\"\nassert longestDistinctSubstring(\"pwwkew\") == \"wke\"\nassert longestDistinctSubstring(\"c\") == \"c\"\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.945}, {"few_shot_keywords": "['traverse', 'payment card', 'PIN', 'pattern', 'imprinted', 'match', 'regular expression', 'validate', 'CVV', 'alphabet', 'embossed', 'Card Verification Value', 'adjacency list', 'fraudulent use']", "test_keywords": "['entity code', 'imprinted', 'embossed', 'regular expression', 'Card Verification Value', 'PIN', 'payment card', 'two-elements', 'match', 'sub-array', 'pattern', 'longest common subsequence', 'fraudulent use', 'validate', 'CVV']", "prompt_tokens": 543, "total_tokens": 801, "completion_tokens": 258, "completion": "[Question 2]\n\nWrite a function to find the longest common subsequence of two entity codes from a payment card. The entity codes are a sequence of characters imprinted or embossed on the card. Use a dynamic programming approach to solve this problem.\n\n[/Question 2]\n\n[Code 2]\n\ndef longestCommonSubsequence(entity1: str, entity2: str) -> str:\n    m = len(entity1)\n    n = len(entity2)\n    \n    dp = [[\"\" for _ in range(n+1)] for _ in range(m+1)]\n    \n    for i in range(1, m+1):\n        for j in range(1, n+1):\n            if entity1[i-1] == entity2[j-1]:\n                dp[i][j] = dp[i-1][j-1] + entity1[i-1]\n            else:\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1], key=len)\n    \n    return dp[m][n]\n\n[/Code 2]\n\n[Asserts 2]\n\nassert longestCommonSubsequence(\"1234\", \"1224534\")==\"1234\"\nassert longestCommonSubsequence(\"abcdef\", \"azced\")==\"acd\"", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.732}, {"few_shot_keywords": "['alphanumeric', 'down', 'sorted', 'NEFT', 'code', 'fraudulent use', 'bank', 'validation', 'settlement', 'combinatorics', 'branch', 'constraint', 'regular expression', 'electronic funds', 'RTGS']", "test_keywords": "['code', 'unique sums', 'electronic funds', 'branch', 'settlement', 'alphanumeric', 'positive integer', 'regular expression', 'sum', 'bank', 'validation', 'cost', 'NEFT', 'corner', 'RTGS']", "prompt_tokens": 583, "total_tokens": 789, "completion_tokens": 206, "completion": "[Question 2]\n\nWrite a Python function that takes a list of alphanumeric codes representing branches of a bank and returns the unique sums of the positive integers present in each code. The function should use regular expression to extract the positive integers from the alphanumeric codes and then calculate the unique sums.\n\n[/Question 2]\n\n[Code 2]\n\nimport re\n\ndef calculateUniqueSums(codes: list) -> list:\n    unique_sums = []\n    for code in codes:\n        integers = re.findall(r'\\d+', code)\n        unique_sum = sum(set(map(int, integers)))\n        unique_sums.append(unique_sum)\n    return unique_sums\n\n[/Code 2]\n\n[Asserts 2]\n\nassert calculateUniqueSums([\"ABC123\", \"DEF456\"]) == [6, 15]\nassert calculateUniqueSums([\"XYZ789\", \"LMN101112\"]) == [24, 14]\nassert calculateUniqueSums([\"PQR456\", \"STU789\"]) == [15, 24]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.877}, {"few_shot_keywords": "['valid', 'digits', 'function', 'GST', 'check sum digit', 'Goods and Services Tax', 'regex', 'Regular Expression', 'match', 'unbounded', 'entity code', 'format', 'edge', 'target', 'PAN number', 'validate', 'Python', 'path sum', 'state code']", "test_keywords": "['check sum digit', 'function', 'validate', 'regex', 'state code', 'file', 'format', 'Regular Expression', 'match', 'PAN number', 'path', 'digits', 'valid', 'GST', 'weight', 'Goods and Services Tax', 'Python', 'entity code']", "prompt_tokens": 657, "total_tokens": 944, "completion_tokens": 287, "completion": "[Question 2]\n\nYour task is to create a Python function to validate a Goods and Services Tax (GST) number. The GST number should be in the format of 2 digits with state code, 10 digits of PAN number, 1 entity code and 1 check sum digit. \nWrite a function that can check if a given GST number is valid or not.\n\n[/Question 2]\n\n[Code 2]\n\nimport re\n\ndef validateGST(gst: str) -> bool:\n    regex = r'^\\d{2}[a-zA-Z]{5}\\d{4}[a-zA-Z]{1}[1-9A-Z]{1}Z\\d{1}$'\n    if re.match(regex, gst):\n        return True\n    else:\n        return False\n\n[/Code 2]\n\n[Asserts 2]\n\nassert validateGST(\"27ABCDE1234A1Z5\") == True\nassert validateGST(\"32ABCDE1234A1Z5\") == False\nassert validateGST(\"27ABCDE1234A11Z5\") == False\nassert validateGST(\"12ABCDE1234A1Z5\") == False\nassert validateGST(\"27ABCDE1234A1Z5\") == True\nassert validateGST(\"27ABCDE1234551Z5\") == True\nassert validateGST(\"27ABCDE1234A1Z55\") == False\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.775}, {"few_shot_keywords": "['efficient', 'validation', 'pattern matching', 'Regular Expression', 'HTML', 'length', 'top left', 'max_cost', 'Python', 'column', 'string']", "test_keywords": "['validation', 'postorder', 'vertices', 'pattern matching', 'Python', 'HTML', 'string manipulation', 'Regular Expression', 'shortest path', 'string', 'difference']", "prompt_tokens": 497, "total_tokens": 789, "completion_tokens": 292, "completion": "[Question 2]\n\nWrite a Python function to validate if a given string represents a postorder traversal of a binary tree. The string will consist of vertices separated by a delimiter. Return True if the string is a valid postorder traversal of a binary tree, and False otherwise.\n\n[/Question 2]\n\n[Code 2]\n\ndef validatePostorderTraversal(postorder: str, delimiter: str) -> bool:\n  vertices = postorder.split(delimiter)\n  stack = []\n  root = float('inf')\n  \n  for vertex in reversed(vertices):\n    if int(vertex) > root:\n      return False\n    while stack and int(vertex) < stack[-1]:\n      root = stack.pop()\n    stack.append(int(vertex))\n  \n  return True\n\n[/Code 2]\n\n[Asserts 2]\n\nassert validatePostorderTraversal(\"1|3|2|5|7|6|4\", \"|\")==True\nassert validatePostorderTraversal(\"1|6|3|2|5|4|7\", \"|\")==False\nassert validatePostorderTraversal(\"5|6|7|3|2|4|1\", \"|\")==True\nassert validatePostorderTraversal(\"1 2 3 4 5\", \" \")==False\nassert validatePostorderTraversal(\"5, 3, 7, 6, 4, 2, 1\", \",\")==True\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.867}, {"few_shot_keywords": "['regex', '0s', 'domain name', 'validation', 'traverse', 'regular expression', 'length', 'hyphen', 'alphanumeric', 'characters']", "test_keywords": "['regex', 'domain name', 'regular expression', 'level', 'validation', 'length', 'alphanumeric', 'sorting', 'hyphen']", "prompt_tokens": 533, "total_tokens": 786, "completion_tokens": 253, "completion": "[Question 2]\n\nWrite a function in Python to validate a list of domain names using regular expressions. Additionally, sort the valid domain names based on their length in ascending order and return the sorted list.\n\n[/Question 2]\n\n[Code 2]\n\nimport re\n\ndef validateAndSortDomainNames(domain_list):\n    valid_domains = []\n    regex = \"^(?!-)[A-Za-z0-9-]{2,63}(?<!-)$\"\n    for domain in domain_list:\n        if re.match(regex, domain):\n            valid_domains.append(domain)\n    valid_domains.sort(key=len)\n    return valid_domains\n\n[/Code 2]\n\n[Asserts 2]\n\nassert validateAndSortDomainNames([\"google.com\", \"example-domain.com\", \"123example.com\", \"-baddomain.com\", \"verylongdomainnamethatiswaytoolongtobevaliddoainnameaccordingtorules.com\"]) == ['google.com', '123example.com', 'example-domain.com']\nassert validateAndSortDomainNames([\"domain.com\", \"example.com\", \"another-example.com\", \"this-is-a-very-long-domain-name-that-is-valid-according-to-the-rules.com\"]) == ['domain.com', 'example.com', 'another-example.com']", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.883}, {"few_shot_keywords": "['boolean', 'match', 'list', 'NEFT', 'pattern', 'validation', 'set', 'cycle detection', 'regular expression', 'string']", "test_keywords": "['pattern', 'boolean', 'string', 'negative weight cycle', 'match', 'regular expression', 'parity', 'validation']", "prompt_tokens": 484, "total_tokens": 647, "completion_tokens": 163, "completion": "[Question 2]\n\nWrite a Python function to validate if a given string represents a binary number using regular expression. The pattern should match strings that only contain 0s and 1s.\n\n[/Question 2]\n\n[Code 2]\n\nimport re\n\ndef validateBinaryNumber(binary: str) -> bool:\n    pattern = \"^[01]+$\"\n    if re.match(pattern, binary):\n        return True\n    return False\n\n[/Code 2]\n\n[Asserts 2]\n\nassert validateBinaryNumber(\"101010\") == True\nassert validateBinaryNumber(\"12345\") == False\nassert validateBinaryNumber(\"01010101\") == True\nassert validateBinaryNumber(\"1010a101\") == False\nassert validateBinaryNumber(\"000111000\") == True\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.713}, {"few_shot_keywords": "['validation', 'divide and conquer', 'regular expression', 'pattern matching', 'image', 'file', 'removal', 'extension']", "test_keywords": "['file', 'extension', 'depth-first search', 'XOR', 'regular expression', 'pattern matching', 'validation', 'image']", "prompt_tokens": 462, "total_tokens": 662, "completion_tokens": 200, "completion": "[Question 2]\n\nYou are given a list of file names with extensions. Write a function to perform pattern matching using Regular Expression to validate whether the file names have valid extensions based on a given set of allowed extensions.\n\n[/Question 2]\n\n[Code 2]\n\nimport re\n\ndef validateFileExtensions(fileNames: list, allowedExtensions: list) -> list:\n    validFiles = []\n    extensionRegex = \"(\" + \"|\".join(allowedExtensions) + \")$\"\n    for fileName in fileNames:\n        if re.search(extensionRegex, fileName):\n            validFiles.append(fileName)\n    return validFiles\n\n[/Code 2]\n\n[Asserts 2]\n\nassert validateFileExtensions([\"image.jpg\", \"document.pdf\", \"script.py\"], [\".jpg\", \".pdf\", \".png\"]) == [\"image.jpg\", \"document.pdf\"]\nassert validateFileExtensions([\"image.jpg\", \"document.pdf\", \"script.py\"], [\".exe\", \".txt\", \".pdf\"]) == [\"document.pdf\"]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.915}, {"few_shot_keywords": "['pattern', 'validation', 'Aadhar', 'digits', 'lambda function', 'regular expressions', 'number', 'format', 'decimal']", "test_keywords": "['Aadhar', 'pattern', 'regular expressions', 'number', 'digits', 'stack', 'calculation', 'integer division', 'validation', 'format', 'letter']", "prompt_tokens": 516, "total_tokens": 820, "completion_tokens": 304, "completion": "[Question 2]\n\nYou have been given a task to validate a given Aadhar number by checking if it follows a specific pattern using regular expressions. Additionally, you need to perform a calculation on the Aadhar number by treating it as a stack of digits and performing integer division. Write a function to validate the Aadhar number using regular expressions and then perform the calculation as specified.\n\n[/Question 2]\n\n[Code 2]\n\nimport re\n\ndef validate_and_calculate_aadhar(aadhar: str) -> int:\n    pattern = \"^\\d{4}\\s\\d{4}\\s\\d{4}$\"\n    if re.match(pattern, aadhar):\n        digits = [int(d) for d in aadhar if d.isdigit()]\n        result = 0\n        for digit in digits:\n            result = result * 10 + digit\n        return result // 5  # Integer division by 5\n    else:\n        return -1  # Invalid Aadhar number\n\n[/Code 2]\n\n[Asserts 2]\n\nassert validate_and_calculate_aadhar(\"1234 5678 9012\") == 246913456\nassert validate_and_calculate_aadhar(\"123456789012\") == -1\nassert validate_and_calculate_aadhar(\"12 45 6789012\") == -1\nassert validate_and_calculate_aadhar(\"1234 678 9012\") == -1\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.753}, {"few_shot_keywords": "['India', 'pin code', 'string manipulation', 'boolean', 'regular expression', 'pattern matching', 'digits', 'validation', 'space', 'GST']", "test_keywords": "['space', 'digit', 'digits', 'India', 'regular expression', 'pattern matching', 'pin code', 'identical', 'validation', 'position', 'string manipulation']", "prompt_tokens": 478, "total_tokens": 684, "completion_tokens": 206, "completion": "[Question 2]\n\nWrite a Python function to check if two Indian pin codes are identical considering the optional space. Use regular expression and string manipulation to validate and compare the pin codes.\n\n[/Question 2]\n\n[Code 2]\n\nimport re\n\ndef compareIndianPinCodes(pin1: str, pin2: str) -> bool:\n    pin1 = re.sub(r'\\s', '', pin1)\n    pin2 = re.sub(r'\\s', '', pin2)\n    return pin1 == pin2\n\n[/Code 2]\n\n[Asserts 2]\n\nassert compareIndianPinCodes(\"110 001\", \"110001\")==True\nassert compareIndianPinCodes(\"400069\", \"400 069\")==True\nassert compareIndianPinCodes(\"123456\", \"654321\")==False\nassert compareIndianPinCodes(\"AB 00123\", \"AB001 23\")==True\nassert compareIndianPinCodes(\"12 3456\", \"12 3456\")==True\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.714}, {"few_shot_keywords": "['words', 'validation', 'root', 'regular expressions', 'hyphen', 'boolean', 'color code', 'extension', 'string', 'pattern', 'path sum', 'hexadecimal']", "test_keywords": "['boolean', 'increment', 'pattern', 'string', 'XOR', 'hexadecimal', 'validation', 'color code', 'regular expressions']", "prompt_tokens": 543, "total_tokens": 737, "completion_tokens": 194, "completion": "[Question 2]\n\nWrite a program to validate a string representing a hexadecimal number using regular expressions. The program should take a string as input and return True if the string represents a valid hexadecimal number, and False otherwise. A valid hexadecimal number should only consist of the characters 0-9 and A-F or a-f.\n\n[/Question 2]\n\n[Code 2]\n\nimport re\n\ndef validateHexNumber(hex_number: str) -> bool:\n    pattern = \"^[A-Fa-f0-9]+$\"\n    if re.match(pattern, hex_number):\n        return True\n    else:\n        return False\n\n[/Code 2]\n\n[Asserts 2]\n\nassert validateHexNumber(\"1a3\")==True\nassert validateHexNumber(\"FF00FF\")==True\nassert validateHexNumber(\"G1\")==False\nassert validateHexNumber(\"123xyz\")==False\nassert validateHexNumber(\"A1!\")==False\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.75}, {"few_shot_keywords": "['matching', 'string', 'PAN Card', 'uppercase', 'regex', 'Python', 'validate', 'regular expressions', 'pattern', 'program']", "test_keywords": "['comparison', 'program', 'pattern', 'regex', 'regular expressions', 'string', 'matching', 'validate', 'PAN Card', 'cell', 'merge', 'schedule', 'Python']", "prompt_tokens": 481, "total_tokens": 932, "completion_tokens": 451, "completion": "[Question 2]\n\nWrite a Python program to merge multiple schedule patterns represented as strings and validate the merged schedule using regular expressions.\n\n[/Question 2]\n\n[Code 2]\n\nimport re\n\ndef mergeAndValidateSchedules(*schedules: str) -> bool:\n    merged_schedule = ''.join(schedules)\n    regex = r'^((Mon|Tue|Wed|Thu|Fri|Sat|Sun),\\d{2}:\\d{2}-\\d{2}:\\d{2};)*((Mon|Tue|Wed|Thu|Fri|Sat|Sun),\\d{2}:\\d{2}-\\d{2}:\\d{2})$'\n    if re.match(regex, merged_schedule):\n        return True\n    else:\n        return False\n\n[/Code 2]\n\n[Asserts 2]\n\nassert mergeAndValidateSchedules(\"Mon,09:00-17:00;Tue,09:00-17:00\", \"Wed,09:00-17:00;Thu,09:00-17:00;Fri,09:00-17:00\")==True\nassert mergeAndValidateSchedules(\"Mon,09:00-17:00;Tue,09:00-17:00\", \"Wed,09:00-17:00;Thu,09:00-17:00;Fri,09:00-17:00\", \"Sat,09:00-17:00\")==False\nassert mergeAndValidateSchedules(\"Mon,09:00-17:00;Tue,09:00-17:00\", \"Wed,09:00-17:00;Thu,09:00-17:00;Fri,09:00-17:00\", \"Sun,09:00-17:00\")==True\nassert mergeAndValidateSchedules(\"Mon,09:00-17:00;Tue,09:00-17:00\", \"Wed,09:00-17:00;Thu,09:00-17:00;Fri,09:00-17:00\", \"01,09:00-17:00\")==False\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.855}, {"few_shot_keywords": "['matrix', 'DFA', '10', 'Deterministic Finite Automaton', 'program', 'end', 'Python', 'accept', 'credit card', 'input string', '01', 'reject', 'arithmetic']", "test_keywords": "['reject', 'Python', 'even', 'nested loop', 'increasing', '10', 'end', 'input string', 'accept', 'repeatedly', '01', 'consecutive', 'program', 'DFA', 'Deterministic Finite Automaton']", "prompt_tokens": 579, "total_tokens": 898, "completion_tokens": 319, "completion": "[Question 2]\n\nWrite a Python program to implement a Deterministic Finite Automaton (DFA) that accepts strings with an even number of consecutive \"01\" or \"10\" occurrences. The DFA should reject strings with an odd number of consecutive \"01\" or \"10\" occurrences.\n\n[/Question 2]\n\n[Code 2]\n\ndef checkDFA(s: str) -> bool:\n    state = 0\n    count = 0\n    for c in s:\n        if state == 0:\n            if c == '0':\n                state = 1\n        elif state == 1:\n            if c == '1':\n                state = 2\n                count += 1\n            elif c == '0':\n                state = 3\n        elif state == 2:\n            if c == '1':\n                state = 2\n                count += 1\n            elif c == '0':\n                state = 3\n        elif state == 3:\n            if c == '0':\n                state = 3\n            elif c == '1':\n                state = 2\n    return count % 2 == 0\n\n[/Code 2]\n\n[Asserts 2]\n\nassert checkDFA(\"10101\")==False\nassert checkDFA(\"010101\")==True\nassert checkDFA(\"1001101\")==False\nassert checkDFA(\"110110\")==True\nassert checkDFA(\"0110101\")==True\nassert checkDFA(\"1110011\")==False\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.94}, {"few_shot_keywords": "['uppercase', 'infinite', 'strings', 'comparison', 'characters', 'substring', 'order', 'blocks']", "test_keywords": "['order', 'HTML', 'characters', 'topmost', 'math', 'strings', 'comparison', 'time']", "prompt_tokens": 476, "total_tokens": 759, "completion_tokens": 283, "completion": "[Question 2]\n\nWrite a function to compare two HTML strings and determine if they have the same topmost HTML tag. Consider the order of characters and the time complexity of your solution.\n\n[/Question 2]\n\n[Code 2]\n\ndef compareTopmostHTMLTag(str1: str, str2: str) -> bool:\n    # Find the topmost HTML tag in str1\n    start_index_1 = str1.find(\"<\")\n    end_index_1 = str1.find(\">\")\n    topmost_tag_1 = str1[start_index_1:end_index_1+1]\n\n    # Find the topmost HTML tag in str2\n    start_index_2 = str2.find(\"<\")\n    end_index_2 = str2.find(\">\")\n    topmost_tag_2 = str2[start_index_2:end_index_2+1]\n\n    # Compare the topmost HTML tags\n    return topmost_tag_1 == topmost_tag_2\n\n[/Code 2]\n\n[Asserts 2]\n\nassert compareTopmostHTMLTag(\"<html><body><h1>Hello</h1></body></html>\", \"<html><div><h2>World</h2></div></html>\")==True\nassert compareTopmostHTMLTag(\"<div><span>Good</span></div>\", \"<h1><p>Bad</p></h1>\")==False", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.809}, {"few_shot_keywords": "['sequence', 'difference', 'function', 'boolean', 'constraint', 'character', 'wildcard', 'string', 'matching']", "test_keywords": "['matching', 'delete', 'string', 'greedy', 'boolean', 'wildcard', 'character', 'sequence', 'cycle detection', 'function']", "prompt_tokens": 540, "total_tokens": 896, "completion_tokens": 356, "completion": "[Question 2]\n\nYou are given a string s and a pattern p. The pattern p may contain wildcard characters '?' and '*'. Each wildcard character can match any single character or a sequence of characters, including an empty sequence. Write a Python function to determine if the pattern p matches with the string s. Return True if there is a match, and False otherwise.\n\n[/Question 2]\n\n[Code 2]\n\ndef isMatch(s: str, p: str) -> bool:\n\tm, n = len(s), len(p)\n\tdp = [[False] * (n + 1) for _ in range(m + 1)]\n\tdp[0][0] = True\n\tfor j in range(1, n + 1):\n\t\tif p[j - 1] == '*':\n\t\t\tdp[0][j] = dp[0][j - 1]\n\tfor i in range(1, m + 1):\n\t\tfor j in range(1, n + 1):\n\t\t\tif p[j - 1] in {s[i - 1], '?'}:\n\t\t\t\tdp[i][j] = dp[i - 1][j - 1]\n\t\t\telif p[j - 1] == '*':\n\t\t\t\tdp[i][j] = dp[i - 1][j] or dp[i][j - 1]\n\treturn dp[m][n]\n\n[/Code 2]\n\n[Asserts 2]\n\nassert isMatch(\"aa\", \"a\") == False\nassert isMatch(\"aa\", \"*\") == True\nassert isMatch(\"cb\", \"?a\") == False\nassert isMatch(\"adceb\", \"*a*b\") == True\nassert isMatch(\"acdcb\", \"a*c?b\") == False", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.923}, {"few_shot_keywords": "['nth term', 'divisible', 'sequence', 'pattern', 'odd', 'leaf', 'data structure', 'arithmetic', 'insert', 'math', 'even', 'subsequence']", "test_keywords": "['minimization', 'even', 'math', 'valid', 'arithmetic', 'generating', 'sequence', 'pattern', 'nth term', 'odd']", "prompt_tokens": 475, "total_tokens": 674, "completion_tokens": 199, "completion": "[Question 2]\n\nWrite a function to generate the nth term of a sequence where each term is the multiplication of the previous term by 3 if the previous term is even, and the previous term plus 1 if the previous term is odd.\n\n[/Question 2]\n\n[Code 2]\n\ndef generateNthTerm(n: int) -> int:\n    if n == 1:\n        return 1\n    else:\n        prev_term = generateNthTerm(n-1)\n        if prev_term % 2 == 0:\n            return prev_term * 3\n        else:\n            return prev_term + 1\n\n[/Code 2]\n\n[Asserts 2]\n\nassert generateNthTerm(1) == 1\nassert generateNthTerm(2) == 3\nassert generateNthTerm(3) == 10\nassert generateNthTerm(4) == 31\nassert generateNthTerm(5) == 94", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.707}, {"few_shot_keywords": "['space complexity', 'math', 'search', 'term', 'sequence', 'calculation', 'extension', 'recursive', 'series', 'space optimization']", "test_keywords": "['sequence', 'duplicate', 'term', 'xor', 'recursive', 'integer', 'math', 'series', 'increasing', 'calculation', 'lowercase']", "prompt_tokens": 464, "total_tokens": 799, "completion_tokens": 335, "completion": "[Question 2]\n\nWrite a recursive function to find the duplicate terms in an increasing sequence of integers using XOR operation.\n\n[/Question 2]\n\n[Code 2]\n\ndef findDuplicateXOR(arr: list, n: int) -> int:\n    if n == 0:\n        return -1\n    xor = arr[0]\n    for i in range(1, n):\n        xor = xor ^ arr[i]\n    for i in range(1, n):\n        xor = xor ^ i\n    return xor\n\n[/Code 2]\n\n[Asserts 2]\n\nassert findDuplicateXOR([1, 2, 3, 4, 4, 5], 6) == 4\nassert findDuplicateXOR([1, 2, 3, 4, 5, 6], 6) == -1\nassert findDuplicateXOR([1, 2, 3, 4, 4, 5, 6, 7, 8, 9, 10, 11, 12], 13) == 4\nassert findDuplicateXOR([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12], 12) == -1\nassert findDuplicateXOR([1, 2, 3, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12], 13) == 3\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.752}, {"few_shot_keywords": "['queue', 'space complexity', 'sum', 'level', 'union', 'tree traversal', 'generating', 'depth', 'binary tree', 'tree node', 'recursion', 'nodes']", "test_keywords": "['tree traversal', 'CVV', 'recursion', 'binary tree', 'depth', 'sum', 'string manipulation', 'level', 'tree node', 'nodes', 'queue']", "prompt_tokens": 612, "total_tokens": 905, "completion_tokens": 293, "completion": "[Question 2]\n\nYou are given a binary tree and a target sum. Write a function to determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.\n\n[/Question 2]\n\n[Code 2]\n\nclass TreeNode:\n    def __init__(self, value=0, left=None, right=None):\n        self.value = value\n        self.left = left\n        self.right = right\n\n\ndef hasPathSum(root: TreeNode, targetSum: int) -> bool:\n    if not root:\n        return False\n    if not root.left and not root.right and root.value == targetSum:\n        return True\n    return hasPathSum(root.left, targetSum - root.value) or hasPathSum(root.right, targetSum - root.value)\n\n[/Code 2]\n\n[Asserts 2]\n\ntree1 = TreeNode(5, TreeNode(4, TreeNode(11, TreeNode(7), TreeNode(2))), TreeNode(8, TreeNode(13), TreeNode(4, None, TreeNode(1))))\nassert hasPathSum(tree1, 22) == True\ntree2 = TreeNode(1, TreeNode(2), TreeNode(3))\nassert hasPathSum(tree2, 5) == False\ntree3 = TreeNode(1, TreeNode(2), TreeNode(3))\nassert hasPathSum(tree3, 4) == True\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.736}, {"few_shot_keywords": "['bitwise', 'sequence', 'array', 'sum', 'repeating characters', 'MAC address', 'Manhattan distance', 'string', 'pairs', 'enumerate']", "test_keywords": "['even', 'sum', 'pairs', 'India', 'enumerate', 'string', 'repeating characters', 'Manhattan distance']", "prompt_tokens": 656, "total_tokens": 1364, "completion_tokens": 708, "completion": "[Question 2]\n\nYou are given a list of strings containing MAC addresses. Each MAC address is a string of 12 hexadecimal digits (0-9 and A-F) separated by colons, for example, \"00:1A:2B:3C:4D:5F\". Write a function to find the sum of even Manhattan distances between all pairs of MAC addresses in the list.\n\nFor example, given the list [\"00:1A:2B:3C:4D:5F\", \"A1:2B:3C:4D:5A:6F\", \"F5:4D:3C:2B:1A:00\"], the even Manhattan distances between the MAC addresses can be calculated as follows:\n- The Manhattan Distance between the first and second MAC address is |0-10| + |0-26| + |26-43| + |26-38| + |26-57| + |31-95| = 128.\n- The Manhattan Distance between the first and third MAC address is |0-245| + |0-77| + |26-51| + |26-38| + |26-21| + |31-0| = 468.\n- The Manhattan Distance between the second and third MAC address is |26-245| + |26-77| + |0-51| + |0-38| + |0-21| + |5-0| = 486.\n\nThe sum of even distances is 128 + 468 + 486 = 1082.\n\nWrite a function that takes in the list of MAC addresses and returns the sum of even Manhattan distances between all pairs of MAC addresses in the list.\n\n[/Question 2]\n\n[Code 2]\n\ndef sumEvenManhattanDistance(mac_addresses: List[str]) -> int:\n    def hex_to_int(hex_val: str) -> int:\n        return int(hex_val, 16)\n\n    def manhattan_distance(mac1: str, mac2: str) -> int:\n        vals1 = [hex_to_int(val) for val in mac1.split(':')]\n        vals2 = [hex_to_int(val) for val in mac2.split(':')]\n        return sum(abs(v1 - v2) for v1, v2 in zip(vals1, vals2))\n\n    sum_distance = 0\n    for i in range(len(mac_addresses)):\n        for j in range(i+1, len(mac_addresses)):\n            distance = manhattan_distance(mac_addresses[i], mac_addresses[j])\n            if distance % 2 == 0:\n                sum_distance += distance\n    return sum_distance\n\n[/Code 2]\n\n[Asserts 2]\n\nassert sumEvenManhattanDistance([\"00:1A:2B:3C:4D:5F\", \"A1:2B:3C:4D:5A:6F\", \"F5:4D:3C:2B:1A:00\"]) == 1082\nassert sumEvenManhattanDistance([\"00:00:00:00:00:00\", \"FF:FF:FF:FF:FF:FF\"]) == 0\nassert sumEvenManhattanDistance([\"00:00:00:00:00:00\", \"00:00:00:00:00:00\", \"00:00:00:00:FF:FF\"]) == 480", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.943}, {"few_shot_keywords": "['consecutive', 'binary', 'allocation', 'odd', 'convert', 'state code', 'flip', 'prefix', 'minimum', 'string']", "test_keywords": "['string', 'leaf', 'index', 'flip', 'binary', 'prefix', 'convert', 'minimum']", "prompt_tokens": 615, "total_tokens": 853, "completion_tokens": 238, "completion": "[Question 2]\n\nGiven a binary string representing a binary tree, where '0' represents a leaf node and '1' represents an internal node, find the minimum index to flip to convert the binary tree to a full binary tree. A full binary tree is a binary tree in which each node has either 0 or 2 children.\n\n[/Question 2]\n\n[Code 2]\n\ndef minIndexToFlip(binaryString: str) -> int:\n    leafCount = 0\n    index = -1\n    for i in range(len(binaryString)):\n        if binaryString[i] == '0':\n            leafCount += 1\n        elif binaryString[i] == '1':\n            leafCount -= 1\n        if leafCount < 0:\n            index = i\n            break\n    return index\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minIndexToFlip(\"1011\") == 2\nassert minIndexToFlip(\"1101001\") == 4\nassert minIndexToFlip(\"100\") == -1\nassert minIndexToFlip(\"1010101\") == 2\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.73}, {"few_shot_keywords": "['maximize', 'weight', 'Card Verification Value', 'words', 'individual', 'max_cost', 'form', 'set', 'stack', 'input', 'characters', 'cost', 'extra space']", "test_keywords": "['cost', 'combinatorics', 'weight', 'max_cost', 'characters', 'integer division', 'input', 'individual', 'words', 'set', 'form', 'maximize', 'allocation']", "prompt_tokens": 591, "total_tokens": 1128, "completion_tokens": 537, "completion": "[Question 2]\n\nYou are given a list of characters and their respective weights. Your task is to allocate the characters to form words in such a way that the cost of forming the words is maximized. The cost of forming a word is calculated based on the individual weights of the characters and is subject to integer division constraints.\n\n[/Question 2]\n\n[Code 2]\n\ndef maximizeWordFormation(characters: list, weights: list, words: list, max_cost: int) -> list:\n    allocations = []\n    for word in words:\n        allocation = {}\n        remaining_weight = max_cost\n        for char in word:\n            if char in characters:\n                index = characters.index(char)\n                if weights[index] <= remaining_weight:\n                    allocation[char] = weights[index]\n                    remaining_weight -= weights[index]\n        allocations.append(allocation)\n    return allocations\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maximizeWordFormation([\"a\", \"b\", \"c\"], [3, 4, 5], [\"abc\", \"bca\", \"acb\"], 8) == [{'a': 3, 'b': 4}, {'a': 3, 'b': 4}, {'a': 3, 'c': 5}]\nassert maximizeWordFormation([\"x\", \"y\", \"z\"], [1, 2, 3], [\"xyz\", \"abc\", \"def\"], 5) == [{}, {}, {}]\nassert maximizeWordFormation([\"a\", \"b\", \"c\", \"d\"], [1, 2, 3, 4], [\"abcd\", \"dabc\", \"abcd\"], 10) == [{'a': 1, 'b': 2, 'c': 3, 'd': 4}, {'a': 1, 'b': 2, 'c': 3, 'd': 4}, {'a': 1, 'b': 2, 'c': 3, 'd': 4}]\nassert maximizeWordFormation([\"x\", \"y\"], [2, 3], [\"xyx\", \"yyy\"], 10) == [{'x': 2, 'y': 3}, {'y': 3}, {}]\nassert maximizeWordFormation([\"a\", \"b\", \"c\"], [1, 2, 3], [\"aabbcc\", \"abbccc\"], 15) == [{'a': 1, 'b': 2, 'c': 3}, {'a': 1, 'b': 2, 'c': 3}]\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.847}, {"few_shot_keywords": "['string', 'query', 'less than', 'sum', 'squares', 'ASCII', 'substring', 'update', 'settlement', 'arithmetic progression', 'recursion']", "test_keywords": "['placement', 'update', 'query', 'substring', 'algorithm', 'sum', 'squares', 'validate', 'signs', 'ASCII', 'max', 'string']", "prompt_tokens": 610, "total_tokens": 958, "completion_tokens": 348, "completion": "[Question 2]\n\nYou are given a string s. You need to implement an algorithm to answer Q queries of the following types:\n\n1. Update the character at position pos to new character c.\n2. Validate if the substring [l, r] has the maximum sum of squares of ASCII values, and return True if the sum is positive, else return False.\n\nYour task is to write a program that efficiently processes these queries and returns the results as a list of booleans.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\ndef validateMaxSumOfSquares(s: str, queries: List[List[int]]) -> List[bool]:\n    ans = []\n    for query in queries:\n        if query[0] == 1:  # update query\n            pos, new_char = query[1], query[2]\n            s = s[:pos-1] + new_char + s[pos:]\n        else:  # validate max sum of squares query\n            l, r = query[1], query[2]\n            sub_str = s[l-1:r]\n            ascii_sum = 0\n            for char in sub_str:\n                ascii_sum += ord(char) ** 2\n            ans.append(ascii_sum > 0)\n    return ans\n\n[/Code 2]\n\n[Asserts 2]\n\nassert validateMaxSumOfSquares('abcd', [[2, 1, 3], [2, 2, 4]]) == [True, True]\nassert validateMaxSumOfSquares('xyz', [[1, 2, 'm'], [2, 1, 3]]) == [True, False]\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.927}, {"few_shot_keywords": "['max_cost', 'LCS', 'unbounded', 'longest common subsequence', 'repetitions', 'swapping', 'repeatedly', 'generating', 'strings', 'characters']", "test_keywords": "['LCS', 'repeatedly', 'generating', 'characters', 'order', 'swaps', 'strings', 'longest common subsequence', 'parity', 'swapping', 'optimization']", "prompt_tokens": 641, "total_tokens": 996, "completion_tokens": 355, "completion": "[Question 2]\n\nYou are given two strings s1 and s2. Your task is to find the length of the Longest Common Subsequence (LCS) such that the parity of the number of character swaps needed to generate any character in the subsequence from s1 and s2 is optimized. \n\n[/Question 2]\n\n[Code 2]\n\ndef longest_common_subsequence_parity_optimized(s1: str, s2: str) -> int:\n    m, n = len(s1), len(s2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if s1[i - 1] == s2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n\n    return dp[m][n]\n\n[/Code 2]\n\n[Asserts 2]\n\nassert longest_common_subsequence_parity_optimized(\"abcde\", \"ace\") == 3\nassert longest_common_subsequence_parity_optimized(\"abc\", \"def\") == 0\nassert longest_common_subsequence_parity_optimized(\"helloworld\", \"hdlrow\") == 5\nassert longest_common_subsequence_parity_optimized(\"AGGTAB\", \"GXTXAYB\") == 4\nassert longest_common_subsequence_parity_optimized(\"ABCDGH\", \"AEDFHR\") == 3\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.837}, {"few_shot_keywords": "['string', 'increment', 'file', 'last row', 'conversion', 'comparison']", "test_keywords": "['increment', 'comparison', 'time', 'conversion', 'movement', 'string', 'iteration', 'sum']", "prompt_tokens": 513, "total_tokens": 718, "completion_tokens": 205, "completion": "[Question 2]\n\nYou are given a string s consisting of lowercase English letters, and a number k. Your task is to convert the string s to a new string by moving each letter k times forward in the alphabet. Return the new string.\n\n[/Question 2]\n\n[Code 2]\n\ndef moveLetters(s: str, k: int) -> str:\n    result = \"\"\n    for char in s:\n        new_char = chr(((ord(char) - ord('a') + k) % 26) + ord('a'))\n        result += new_char\n    return result\n\n[/Code 2]\n\n[Asserts 2]\n\nassert moveLetters(\"abc\", 1) == \"bcd\"\nassert moveLetters(\"xyz\", 3) == \"abc\"\nassert moveLetters(\"hello\", 5) == \"mjqqt\"\nassert moveLetters(\"world\", 10) == \"gybvn\"\nassert moveLetters(\"programming\", 7) == \"xytwxzlmyxa\"", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.809}, {"few_shot_keywords": "['substring', 'minimization', 'swaps', 'imprinted', 'string', 'merge', 'counting', 'indexing', 'iteration', 'accept']", "test_keywords": "['XOR', 'substring', 'efficient', 'bit manipulation', 'indexing', 'counting', 'swaps', 'subtree', 'iteration', 'string', 'minimization']", "prompt_tokens": 541, "total_tokens": 835, "completion_tokens": 294, "completion": "[Question 2]\n\nGiven a string s and two integers L and R, the task is to find the number of substrings of s in which the bitwise XOR of the ASCII values of the characters in the substring is even.\n\n[/Question 2]\n\n[Code 2]\n\ndef countEvenXORSubstrings(s: str, L: int, R: int) -> int:\n    result = 0\n    n = len(s)\n    for i in range(n):\n        for j in range(i, n):\n            if (j - i + 1 >= L and j - i + 1 <= R):\n                xor_val = 0\n                for k in range(i, j + 1):\n                    xor_val ^= ord(s[k])\n                if(xor_val % 2 == 0):\n                    result += 1\n    return result\n\n[/Code 2]\n\n[Asserts 2]\n\nassert(countEvenXORSubstrings(\"abc\", 1, 2)) == 3\nassert(countEvenXORSubstrings(\"aba\", 1, 2)) == 4\nassert(countEvenXORSubstrings(\"abc\", 2, 2)) == 0\nassert(countEvenXORSubstrings(\"1010\", 1, 4)) == 10\nassert(countEvenXORSubstrings(\"xy\", 1, 2)) == 2\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.909}, {"few_shot_keywords": "['integer', 'check', 'boolean', 'substring', 'representation', 'binary', 'branch', 'Goods and Services Tax', 'payment card']", "test_keywords": "['integer', 'traverse', 'check', 'stack', 'leaves', 'swap', 'binary', 'boolean', 'representation', 'substring', 'visited']", "prompt_tokens": 460, "total_tokens": 880, "completion_tokens": 420, "completion": "[Question 2]\n\nGiven a binary tree, write a function to check if the binary tree leaves at the same level can be swapped to create a symmetric tree. The function should return True if swapping the leaves can create a symmetric tree, otherwise return False.\n\n[/Question 2]\n\n[Code 2]\n\nclass TreeNode:\n    def __init__(self, value=0, left=None, right=None):\n        self.value = value\n        self.left = left\n        self.right = right\n\ndef isSymmetricTree(root: TreeNode) -> bool:\n    def checkSymmetry(node, level, leaves):\n        if not node:\n            return\n        if not node.left and not node.right:\n            if level in leaves:\n                leaves[level].append(node.value)\n            else:\n                leaves[level] = [node.value]\n        else:\n            checkSymmetry(node.left, level+1, leaves)\n            checkSymmetry(node.right, level+1, leaves)\n    \n    leaves = {}\n    checkSymmetry(root, 0, leaves)\n    for level, values in leaves.items():\n        if values != values[::-1]:\n            return False\n    return True\n\n[/Code 2]\n\n[Asserts 2]\n\ntree1 = TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(5)), TreeNode(2, TreeNode(5), TreeNode(4)))\ntree2 = TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(5)), TreeNode(2, None, TreeNode(4)))\ntree3 = TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(5)), TreeNode(2, TreeNode(5)))\ntree4 = TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(5)), TreeNode(2, TreeNode(5), TreeNode(4, TreeNode(6))))\n\nassert isSymmetricTree(tree1) == True\nassert isSymmetricTree(tree2) == True\nassert isSymmetricTree(tree3) == False\nassert isSymmetricTree(tree4) == False\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.812}, {"few_shot_keywords": "['character', 'regular expression', 'string', 'removal', 'split', 'minimum', 'frequency']", "test_keywords": "['character', 'closest', 'strictly decreasing', 'string', 'frequency', 'minimum', 'ancestor', 'dp', 'conversion', 'removal']", "prompt_tokens": 539, "total_tokens": 933, "completion_tokens": 394, "completion": "[Question 2]\n\nGiven two strings s and t, the task is to find the minimum number of character removals required in string s such that s becomes strictly decreasing and also closest to string t in terms of frequency of characters.\n\n[/Question 2]\n\n[Code 2]\n\ndef minRemovalsToMakeStrictlyDecreasing(s: str, t: str) -> int:\n    # Count frequency of characters in both strings\n    s_freq = {char: s.count(char) for char in set(s)}\n    t_freq = {char: t.count(char) for char in set(t)}\n\n    # Initialize minimum removals\n    min_removals = 0\n\n    # Check if s is not strictly decreasing, then find the minimum removals to make it strictly decreasing\n    while not isStrictlyDecreasing(s):\n        max_char = max(s_freq, key=s_freq.get)\n        if s_freq[max_char] > t_freq.get(max_char, 0):\n            s_freq[max_char] -= 1\n            min_removals += 1\n        else:\n            break\n\n    return min_removals\n\ndef isStrictlyDecreasing(s: str) -> bool:\n    return all(s[i] > s[i+1] for i in range(len(s)-1))\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minRemovalsToMakeStrictlyDecreasing(\"abcdef\", \"aabbbcc\")==3\nassert minRemovalsToMakeStrictlyDecreasing(\"abcdef\", \"aabbbcc\") == 3\nassert minRemovalsToMakeStrictlyDecreasing(\"aabbcc\", \"aabbbcc\")==0\nassert minRemovalsToMakeStrictlyDecreasing(\"abc\", \"def\")==3\nassert minRemovalsToMakeStrictlyDecreasing(\"aaaabbbccc\", \"aabbbcc\")==3\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.752}, {"few_shot_keywords": "['present', 'even', 'string', 'odd', 'Deterministic Finite Automaton', 'transform', 'odd divisors', 'DFA', 'identical', 'boolean', 'counting', 'character']", "test_keywords": "['row', 'DFA', 'even', 'driving license', 'Deterministic Finite Automaton', 'counting', 'boolean', 'odd', 'string', 'character']", "prompt_tokens": 601, "total_tokens": 865, "completion_tokens": 264, "completion": "[Question 2]\n\nYou are required to construct a Deterministic Finite Automaton (DFA) that checks if a given string represents a valid driving license number. The driving license number follows a specific format where the first character is a letter, followed by 7 digits, and ends with a letter.\n\nWrite a Python program to construct the DFA which accepts a string and returns True if it represents a valid driving license number, and False otherwise.\n\n[/Question 2]\n\n[Code 2]\n\ndef validDrivingLicenseNumber(string: str) -> bool:\n    if len(string) != 9:\n        return False\n    if not string[0].isalpha() or not string[-1].isalpha():\n        return False\n    if not string[1:8].isdigit():\n        return False\n    return True\n\n[/Code 2]\n\n[Asserts 2]\n\nassert validDrivingLicenseNumber(\"A1234567Z\")==True\nassert validDrivingLicenseNumber(\"AB123456Z\")==False\nassert validDrivingLicenseNumber(\"A12345678Z\")==False\nassert validDrivingLicenseNumber(\"123456789\")==False\nassert validDrivingLicenseNumber(\"A12345B7Z\")==False\nassert validDrivingLicenseNumber(\"A1234567\")==False\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.713}, {"few_shot_keywords": "['nodes', 'levels', 'multiplying', 'extension', 'allocation', 'absolute difference', 'binary tree', 'sum', 'recursion', 'traversal', 'identical', 'data structure', 'tree', 'math']", "test_keywords": "['levels', 'absolute difference', 'data structure', 'nodes', 'recursion', 'traversal', 'sum', 'depth', 'tree', 'order', 'binary tree', 'events', 'python']", "prompt_tokens": 760, "total_tokens": 1248, "completion_tokens": 488, "completion": "[Question 2]\n\nWrite a Python function to find the absolute difference between the sum of nodes at odd levels and the sum of nodes at even levels in a binary tree.\n\n[/Question 2]\n\n[Code 2]\n\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.left = None\n        self.right = None\n\ndef levelOrderTraversal(root, level, oddSum, evenSum):\n    if not root:\n        return\n    if level % 2 == 0:\n        evenSum[0] += root.data\n    else:\n        oddSum[0] += root.data\n    levelOrderTraversal(root.left, level + 1, oddSum, evenSum)\n    levelOrderTraversal(root.right, level + 1, oddSum, evenSum)\n\ndef getLevelDiff(root):\n    if not root:\n        return 0\n    oddSum = [0]\n    evenSum = [0]\n    levelOrderTraversal(root, 1, oddSum, evenSum)\n    return abs(oddSum[0] - evenSum[0])\n\n# Example usage\ntree = Node(1)\ntree.left = Node(2)\ntree.right = Node(3)\ntree.left.left = Node(4)\ntree.left.right = Node(5)\nprint(getLevelDiff(tree))  # Output: 3\n\n[/Code 2]\n\n[Asserts 2]\n\ntree1 = Node(1)\ntree1.left = Node(2)\ntree1.right = Node(3)\ntree1.left.left = Node(4)\ntree1.left.right = Node(5)\nassert getLevelDiff(tree1) == 3\ntree2 = Node(10)\ntree2.left = Node(20)\ntree2.right = Node(30)\ntree2.left.left = Node(40)\ntree2.left.right = Node(50)\ntree2.right.left = Node(60)\ntree2.right.right = Node(70)\nassert getLevelDiff(tree2) == 10\ntree3 = Node(3)\ntree3.left = Node(5)\ntree3.right = Node(7)\ntree3.left.left = Node(8)\ntree3.left.right = Node(9)\ntree3.right.left = Node(10)\ntree3.right.right = Node(11)\nassert getLevelDiff(tree3) == 13\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.796}, {"few_shot_keywords": "['smallest', 'sum', 'boolean', 'insertion', 'tree', 'integer', 'root', 'path', 'value', 'leaf', 'node', 'binary tree']", "test_keywords": "['root', 'value', 'leaf', 'tree', 'binary tree', 'binary search tree', 'integer', 'difference', 'boolean', 'insert', 'ways', 'path', 'sum', 'node']", "prompt_tokens": 621, "total_tokens": 934, "completion_tokens": 313, "completion": "[Question 2]\n\nGiven a binary search tree, write a function to find the absolute difference between the values of the root and leaf nodes along the longest path in the tree.\n\n[/Question 2]\n\n[Code 2]\n\n# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, value=0, left=None, right=None):\n        self.value = value\n        self.left = left\n        self.right = right\n\ndef maxAncestorDiff(root: TreeNode) -> int:\n    def dfs(node, max_val, min_val):\n        if not node:\n            return max_val - min_val\n        max_val = max(max_val, node.value)\n        min_val = min(min_val, node.value)\n        return max(dfs(node.left, max_val, min_val), dfs(node.right, max_val, min_val))\n\n    return dfs(root, root.value, root.value)\n\n[/Code 2]\n\n[Asserts 2]\n\ntree1 = TreeNode(8, TreeNode(3, TreeNode(1), TreeNode(6, TreeNode(4), TreeNode(7))), TreeNode(10, None, TreeNode(14, TreeNode(13))))\nassert maxAncestorDiff(tree1)==7\ntree2 = TreeNode(2, None, TreeNode(0, TreeNode(1)))\nassert maxAncestorDiff(tree2)==2\ntree3 = TreeNode(1, None, TreeNode(2, None, TreeNode(0, TreeNode(3))))\nassert maxAncestorDiff(tree3)==3\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.937}, {"few_shot_keywords": "['sum', 'program', 'digit', 'leaf', 'path', 'cell', 'dfs', 'recursion', 'binary tree', 'ASCII', 'distinct numbers', 'node', 'root']", "test_keywords": "['binary tree', 'digit', 'node', 'root', 'path', 'path sum', 'distinct', 'recursion', 'leaf', 'dfs', 'sum']", "prompt_tokens": 573, "total_tokens": 844, "completion_tokens": 271, "completion": "[Question 2]\n\nGiven the root of a binary tree and a target sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.\n\n[/Question 2]\n\n[Code 2]\n\n# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef hasPathSum(root: TreeNode, targetSum: int) -> bool:\n    if not root:\n        return False\n    if not root.left and not root.right and root.val == targetSum:\n        return True\n    targetSum -= root.val\n    return hasPathSum(root.left, targetSum) or hasPathSum(root.right, targetSum)\n\n[/Code 2]\n\n[Asserts 2]\n\nroot1 = TreeNode(5, TreeNode(4, TreeNode(11, TreeNode(7), TreeNode(2))), TreeNode(8, TreeNode(13), TreeNode(4, None, TreeNode(1))))\nassert hasPathSum(root1, 22) == True\nroot2 = TreeNode(1, TreeNode(2), TreeNode(3))\nassert hasPathSum(root2, 5) == False\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.719}, {"few_shot_keywords": "['merge', 'pairs', 'binary trees', 'node sum', 'iterative approach', 'range', 'recursive approach', 'enumeration']", "test_keywords": "['recursive approach', 'squares', 'Globally Unique Identifier', 'check', 'iterative approach', 'merge', 'node sum', 'undirected', 'binary trees']", "prompt_tokens": 902, "total_tokens": 1275, "completion_tokens": 373, "completion": "[Question 2]\n\nGiven a list of integers, implement a function to merge the squares of these integers using both recursive and iterative approaches. Additionally, check if the resulting merged square is a Globally Unique Identifier (GUID).\n\n[/Question 2]\n\n[Code 2]\n\n# Recursive Approach\ndef mergeSquaresRecursive(nums: List[int]) -> bool:\n    def merge(nums: List[int]) -> int:\n        if len(nums) == 1:\n            return nums[0]**2\n        mid = len(nums) // 2\n        left_sum = merge(nums[:mid])\n        right_sum = merge(nums[mid:])\n        return left_sum + right_sum\n\n    merged_square = merge(nums)\n    return isGUID(merged_square)\n\n# Iterative Approach\ndef mergeSquaresIterative(nums: List[int]) -> bool:\n    stack = [num**2 for num in nums]\n    while len(stack) > 1:\n        n1 = stack.pop()\n        n2 = stack.pop()\n        stack.append(n1 + n2)\n    merged_square = stack[0]\n    return isGUID(merged_square)\n\ndef isGUID(n: int) -> bool:\n    # Check if n satisfies the requirements of a Globally Unique Identifier\n    return True  # Placeholder for GUID check\n\n[/Code 2]\n\n[Asserts 2]\n\n# Example 1\nnums1 = [1, 2, 3, 4, 5]\nassert mergeSquaresRecursive(nums1) == True\nassert mergeSquaresIterative(nums1) == True\n# Example 2\nnums2 = [3, 7, 2, 5, 4]\nassert mergeSquaresRecursive(nums2) == True\nassert mergeSquaresIterative(nums2) == True\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.892}, {"few_shot_keywords": "['closest', 'child', 'tree', 'sum', 'node', 'parent', 'algorithm', 'root', 'alternate', 'graph', 'data structure']", "test_keywords": "['graph', 'child', 'coin', 'sum', 'data structure', 'parent', 'tree', 'node', 'algorithm', 'root']", "prompt_tokens": 575, "total_tokens": 924, "completion_tokens": 349, "completion": "[Question 2]\n\nYou are given a binary tree and each node contains a value of either 0 or 1. The task is to find the sum of all the values in the tree where the path from the root to the leaf node represents a binary number. \n\nFor example, given the tree:\n\n```\n    1\n   / \\\n  0   1\n / \\ / \\\n1  0 0  1\n```\n\nThe binary numbers represented by the paths are 1001, 1000, 101, and 11. The sum of these binary numbers is 23.\n\n[/Question 2]\n\n[Code 2]\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef sumRootToLeaf(root: TreeNode) -> int:\n    def dfs(node, current):\n        if not node:\n            return 0\n        current = (current << 1) | node.val\n        if not node.left and not node.right:\n            return current\n        return dfs(node.left, current) + dfs(node.right, current)\n\n    return dfs(root, 0)\n\n[/Code 2]\n\n[Asserts 2]\n\ntree = TreeNode(1, TreeNode(0, TreeNode(1), TreeNode(0)), TreeNode(1, TreeNode(0), TreeNode(1)))\nassert sumRootToLeaf(tree) == 23\n\ntree2 = TreeNode(1, TreeNode(1, TreeNode(0), TreeNode(1)), TreeNode(0, TreeNode(0), TreeNode(1)))\nassert sumRootToLeaf(tree2) == 28\n\n", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.841}, {"few_shot_keywords": "['inorder', 'binary tree', 'recursive', 'postorder', 'numbers', 'distinct numbers', 'enumerate', 'subtree', 'indices', 'traversal', 'preorder', 'root']", "test_keywords": "['root', 'binary', 'inorder', 'traversal', 'subtree', 'preorder', 'recursive', 'postorder', 'binary tree']", "prompt_tokens": 622, "total_tokens": 943, "completion_tokens": 321, "completion": "[Question 2]\n\nGiven a binary tree, write a function to check if it is a subtree of another binary tree.\n\n[/Question 2]\n\n[Code 2]\n\nclass TreeNode:\n    def __init__(self, value=0, left=None, right=None):\n        self.value = value\n        self.left = left\n        self.right = right\n\ndef areIdentical(root1, root2):\n    if not root1 and not root2:\n        return True\n    if not root1 or not root2:\n        return False\n    return (root1.value == root2.value and\n            areIdentical(root1.left, root2.left) and\n            areIdentical(root1.right, root2.right))\n\ndef isSubtree(T, S):\n    if not T:\n        return False\n    if areIdentical(T, S):\n        return True\n    return isSubtree(T.left, S) or isSubtree(T.right, S)\n\n[/Code 2]\n\n[Asserts 2]\n\nT = TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(5)), TreeNode(3))\nS = TreeNode(2, TreeNode(4), TreeNode(5))\nassert isSubtree(T, S) == True\n\nT = TreeNode(3, TreeNode(4, TreeNode(1), TreeNode(2, TreeNode(0)), TreeNode(3)))\nS = TreeNode(4, TreeNode(1), TreeNode(2, TreeNode(0), TreeNode(3)))\nassert isSubtree(T, S) == False\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.848}, {"few_shot_keywords": "['pin code', 'removing', 'columns', 'flip', 'binary search tree', 'values', 'ancestor', 'lowest common']", "test_keywords": "['Next Fit', 'ancestor', 'divisor', 'split', 'binary search tree', 'payment card', 'values', 'lowest common']", "prompt_tokens": 567, "total_tokens": 787, "completion_tokens": 220, "completion": "[Question 2]\n\nYou are given a list of payment card values, and you need to implement the Next Fit algorithm to split the list into groups such that the sum of values in each group does not exceed a given divisor. Write a function to implement the Next Fit algorithm and return the number of groups formed.\n\n[/Question 2]\n\n[Code 2]\n\ndef nextFit(card_values, divisor):\n    groups = 1\n    current_sum = 0\n    for value in card_values:\n        if current_sum + value <= divisor:\n            current_sum += value\n        else:\n            groups += 1\n            current_sum = value\n    return groups\n\n[/Code 2]\n\n[Asserts 2]\n\nassert nextFit([20, 30, 10, 40, 50], 50) == 3\nassert nextFit([15, 25, 35, 10, 20], 50) == 2\nassert nextFit([10, 20, 30, 40, 50], 35) == 3", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.94}, {"few_shot_keywords": "['repeated', 'traversal', 'ancestor', 'binary tree', 'recursive', 'difference', 'characters', 'maximum', 'queries', 'node value']", "test_keywords": "['maximum', 'donuts', 'node value', 'cost', 'recursive', 'difference', 'binary tree', 'split', 'ancestor', 'negative weight cycle', 'traversal', 'squares']", "prompt_tokens": 687, "total_tokens": 1126, "completion_tokens": 439, "completion": "[Question 2]\n\nYou are given a binary tree representing a network of connected nodes. Each node has a certain cost associated with it, and you need to split the network in such a way that the difference between the maximum cost in each split subnetwork is minimized. Your task is to write a recursive function to find the maximum difference in cost between two non-empty subnetworks that can be formed by splitting the given binary tree at any node.\n\n[/Question 2]\n\n[Code 2]\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef maxCostDifference(root: TreeNode) -> int:\n    max_diff = float('-inf')\n    \n    def find_max(node):\n        nonlocal max_diff\n        if not node:\n            return float('inf'), float('-inf')\n        left_min, left_max = find_max(node.left)\n        right_min, right_max = find_max(node.right)\n        min_val = min(left_min, right_min, node.val)\n        max_val = max(left_max, right_max, node.val)\n        max_diff = max(max_diff, abs(max_val - min_val))\n        return min_val, max_val\n    \n    find_max(root)\n    return max_diff\n\n[/Code 2]\n\n[Asserts 2]\n\n# Create a test binary tree\n#     1\n#    / \\\n#   3   2\n#  /     \\\n# 4       5\ntree = TreeNode(1,\n                TreeNode(3, TreeNode(4)),\n                TreeNode(2, None, TreeNode(5)))\nassert maxCostDifference(tree) == 3\n\n# Create a test binary tree\n#     4\n#    / \\\n#   3   7\n#  /   / \\\n# 5   2   6\ntree2 = TreeNode(4,\n                 TreeNode(3, TreeNode(5)),\n                 TreeNode(7, TreeNode(2), TreeNode(6)))\nassert maxCostDifference(tree2) == 4\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.803}, {"few_shot_keywords": "['root', 'level', 'traversal', '01', 'binary', 'tree', 'path', 'LCA', 'common', 'node']", "test_keywords": "['tree', 'present', 'path', 'common', 'LCA', 'traversal', 'binary', 'node', 'root']", "prompt_tokens": 725, "total_tokens": 1126, "completion_tokens": 401, "completion": "[Question 2]\n\nGiven a binary tree and two nodes, find the lowest common ancestor (LCA) of the two given nodes in the tree. If either or both nodes are not present in the tree, return -1.\n\n[/Question 2]\n\n[Code 2]\n\nclass TreeNode:\n    def __init__(self, key):\n        self.val = key\n        self.left = None\n        self.right = None\n\ndef lowestCommonAncestor(root, p, q):\n    if root is None:\n        return None\n    if root.val == p or root.val== q:\n        return root\n\n    left = lowestCommonAncestor(root.left, p, q)\n    right = lowestCommonAncestor(root.right, p, q)\n\n    if left and right:\n        return root\n    return left if left else right\n\nroot = TreeNode(3)\nroot.left = TreeNode(5)\nroot.right = TreeNode(1)\nroot.left.left = TreeNode(6)\nroot.left.right = TreeNode(2)\nroot.left.right.left = TreeNode(7)\nroot.left.right.right = TreeNode(4)\nroot.right.left = TreeNode(0)\nroot.right.right = TreeNode(8)\n\nassert lowestCommonAncestor(root, 5, 1).val == 3\nassert lowestCommonAncestor(root, 5, 4).val == 5\nassert lowestCommonAncestor(root, 6, 4).val == 5\nassert lowestCommonAncestor(root, 7, 0).val == 5\n\n[/Code 2]\n\n[Asserts 2]\n\nassert lowestCommonAncestor(root, 5, 1).val == 3\nassert lowestCommonAncestor(root, 5, 4).val == 5\nassert lowestCommonAncestor(root, 6, 4).val == 5\nassert lowestCommonAncestor(root, 7, 0).val == 5\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.779}]