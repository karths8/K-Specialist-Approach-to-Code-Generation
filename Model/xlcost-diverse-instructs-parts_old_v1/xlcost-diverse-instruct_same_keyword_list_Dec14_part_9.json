[{"few_shot_keywords": "['2D array', 'node', 'tree traversal', 'binary tree', 'together', 'boolean', 'ancestor', 'multiples of 10', 'print', 'recursive', 'count']", "test_keywords": "['recursive', 'polygon', 'boolean', 'ratio', 'ancestor', 'node', 'tree traversal', 'binary tree', 'print']", "prompt_tokens": 561, "total_tokens": 871, "completion_tokens": 310, "completion": "[Question 2]\n\nWrite a recursive function to print all the nodes of a binary tree in a specific ratio-based pattern.\n\n[/Question 2]\n\n[Code 2]\n\nclass Node:\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n\ndef printNodesInRatio(node: Node, level: int, isAlternate: bool) -> None:\n    if node is None:\n        return\n    if level == 1:\n        print(node.key, end=\" \")\n    else:\n        if isAlternate:\n            printNodesInRatio(node.left, level - 1, isAlternate)\n            printNodesInRatio(node.right, level - 1, isAlternate)\n        else:\n            printNodesInRatio(node.right, level - 1, isAlternate)\n            printNodesInRatio(node.left, level - 1, isAlternate)\n\n[/Code 2]\n\n[Asserts 2]\n\nroot = Node(1)\nroot.left = Node(2)\nroot.right = Node(3)\nroot.left.left = Node(4)\nroot.left.right = Node(5)\nroot.right.left = Node(6)\nroot.right.right = Node(7)\n\nassert printNodesInRatio(root, 1, True)==None\nassert printNodesInRatio(root, 2, True)==None\nassert printNodesInRatio(root, 3, True)==None\nassert printNodesInRatio(root, 4, True)==None\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.88}, {"few_shot_keywords": "['data structure', 'implementation', 'element', 'Binary Indexed Tree', 'color', 'point query', 'permutations', 'range', 'point update', 'prefix sum', 'BIT', 'query', 'range update', 'update', 'mathematics']", "test_keywords": "['Binary Indexed Tree', 'multiples of 10', 'data structure', 'prefix sum', 'BIT', 'list', 'return', 'point query', 'point update', 'implementation', 'if statement', 'range update', 'query', 'update', 'element', 'range']", "prompt_tokens": 726, "total_tokens": 1181, "completion_tokens": 455, "completion": "[Question 2]\n\nYou are given a list of integers and are required to perform point updates and range queries on multiples of 10. Implement a data structure using a Binary Indexed Tree (BIT) to efficiently handle the following operations:\n1. **Point Update:** Update the value of an element at index 'i' to a new value 'val'.\n2. **Range Query:** Find the count of elements in the range 'l' to 'r' that are multiples of 10.\n\nWrite a program to implement the Binary Indexed Tree to handle these operations efficiently.\n\n[/Question 2]\n\n[Code 2]\n\nclass BITMultiplesOf10:\n    def __init__(self, nums):\n        self.bit = [0] * (len(nums) + 1)\n        self.nums = nums\n\n        for i in range(len(nums)):\n            self.update(i+1, nums[i] % 10)\n\n    def update(self, i, val):\n        diff = val - self.nums[i-1] % 10\n        self.nums[i-1] = val\n\n        while i < len(self.bit):\n            self.bit[i] += diff\n            i += i & -i\n\n    def prefixSum(self, i):\n        res = 0\n        while i > 0:\n            res += self.bit[i]\n            i -= i & -i\n        return res\n\n    def rangeQuery(self, l, r):\n        return self.prefixSum(r+1) - self.prefixSum(l)\n\n# Example usage:\narr = [12, 25, 40, 57, 63]\nbit = BITMultiplesOf10(arr)\nassert bit.rangeQuery(1, 3) == 2\nbit.update(2, 30)\nassert bit.rangeQuery(1, 3) == 3\n\n[/Code 2]\n\n[Asserts 2]\n\narr = [12, 25, 40, 57, 63]\nbit = BITMultiplesOf10(arr)\nassert bit.rangeQuery(1, 3) == 2\nbit.update(2, 30)\nassert bit.rangeQuery(1, 3) == 3\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.848}, {"few_shot_keywords": "['position', 'rules', 'coordinates', 'movement', 'cell', 'matrix', 'variables', 'iteration', 'while loop', 'component']", "test_keywords": "['iteration', 'coordinates', 'rules', 'cell', 'matrix', 'range update', 'movement', 'digital sum', 'position']", "prompt_tokens": 666, "total_tokens": 1114, "completion_tokens": 448, "completion": "[Question 2]\n\nGiven a matrix of size m x n and a list of range updates, where each update is represented by four integers (r1, c1, r2, c2) representing the coordinates of the top-left and bottom-right cells of a submatrix, implement a function to update the matrix based on the following rules:\n- For each cell in the submatrix, add the digital sum of its row and column to its current value.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\ndef updateMatrix(matrix: List[List[int]], updates: List[List[int]]) -> List[List[int]]:\n    for update in updates:\n        r1, c1, r2, c2 = update\n        for i in range(r1, r2+1):\n            for j in range(c1, c2+1):\n                row_sum = sum(int(digit) for digit in str(i))\n                col_sum = sum(int(digit) for digit in str(j))\n                matrix[i-1][j-1] += row_sum + col_sum\n    return matrix\n\n[/Code 2]\n\n[Asserts 2]\n\nmatrix = [\n    [1, 2, 3],\n    [4, 5, 6],\n    [7, 8, 9]\n]\nupdates = [[1, 1, 2, 2], [2, 2, 3, 3]]\nassert updateMatrix(matrix, updates) == [\n    [11, 16, 21],\n    [16, 22, 28],\n    [21, 28, 35]\n]\n\nmatrix2 = [\n    [9, 8, 7],\n    [6, 5, 4],\n    [3, 2, 1]\n]\nupdates2 = [[1, 1, 1, 1], [2, 2, 2, 2]]\nassert updateMatrix(matrix2, updates2) == [\n    [10, 8, 7],\n    [6, 12, 4],\n    [3, 2, 11]\n] \n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.801}, {"few_shot_keywords": "['pairwise difference', 'count', 'subset', 'iteration', 'zeroes', 'integer', 'valid', 'array', 'nested loop', 'unit digit', 'sqrt', 'increasing', 'factor']", "test_keywords": "['factor', 'frequency', 'array', 'iteration', 'range update', 'nested loop', 'subset', 'valid', 'integer', 'count']", "prompt_tokens": 564, "total_tokens": 879, "completion_tokens": 315, "completion": "[Question 2]\n\nGiven an array of integers, write a function to calculate the frequency of the factors of each integer in the array and return the count of valid subsets where the unit digit of the product of the subset is a perfect square.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\nfrom collections import defaultdict\ndef countValidSubsets(arr: List[int]) -> int:\n    factors = defaultdict(int)\n    for num in arr:\n        for i in range(1, num+1):\n            if num % i == 0:\n                factors[i] += 1\n    \n    count = 0\n    for i in range(len(arr)):\n        for j in range(i, len(arr)):\n            subset = arr[i:j+1]\n            product = 1\n            for num in subset:\n                product *= num\n            if str(product)[-1] in {'0', '1', '4', '5', '6', '9'}:\n                count += 1\n    return count\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countValidSubsets([2, 3, 4, 5])==9\nassert countValidSubsets([1, 2, 3, 4, 5, 6])==21\nassert countValidSubsets([10, 20, 30, 40, 50])==18\nassert countValidSubsets([7, 14, 21, 28, 35])==7\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.842}, {"few_shot_keywords": "['first day', 'day of the week', 'invalid input', 'target year', 'even', 'rules', 'week', 'base year', 'reference', 'strictly']", "test_keywords": "['prefixes', 'reference', 'function', 'formatting', 'target year', 'day of the week', 'first day', 'algorithm', 'base year', 'week']", "prompt_tokens": 582, "total_tokens": 1020, "completion_tokens": 438, "completion": "[Question 2]\n\nYou are required to write a function that takes a year as input and returns a list of the prefixes for each day of the week within that year. The prefixes follow the format \"1st Monday\", \"2nd Tuesday\", and so on.\n\nWrite a function that takes in the target year and returns a dictionary where the keys are the day of the week (0 to 6 representing Monday to Sunday) and the values are lists of the formatted prefixes for each day of the week.\n\nAssume that the input year is valid and that the first day of the year is Monday.\n\n[/Question 2]\n\n[Code 2]\n\nfrom datetime import datetime, timedelta\n\ndef getDayPrefixes(targetYear: int) -> dict:\n    prefixes = {}\n    days = [\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\", \"Sunday\"]\n    for i in range(7):\n        prefixes[i] = [(datetime(targetYear, 1, 1) + timedelta(days=j)).strftime(\"%-dth %A\") for j in range(i, 365, 7)]\n    return prefixes\n\n[/Code 2]\n\n[Asserts 2]\n\nassert getDayPrefixes(2022) == {\n    0: ['1st Monday', '8th Monday', '15th Monday', '22nd Monday', '29th Monday'],\n    1: ['2nd Tuesday', '9th Tuesday', '16th Tuesday', '23rd Tuesday', '30th Tuesday'],\n    2: ['3rd Wednesday', '10th Wednesday', '17th Wednesday', '24th Wednesday', '31st Wednesday'],\n    3: ['4th Thursday', '11th Thursday', '18th Thursday', '25th Thursday'],\n    4: ['5th Friday', '12th Friday', '19th Friday', '26th Friday'],\n    5: ['6th Saturday', '13th Saturday', '20th Saturday', '27th Saturday'],\n    6: ['7th Sunday', '14th Sunday', '21st Sunday', '28th Sunday']\n}", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct", "temperature": 0.759}]