[{"few_shots": [{"author": "Calvin", "UUID": "a9c5e697-af5d-432b-8447-5675d739c728", "question": "Given an array reorder it so that even numbers appear first", "examples": "Input: [1,2,3,4,5,6,7,8,9]\r\nOutput: [8,2,6,4,5,7,3,9,1]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def even_odd_reorder(arr: list) -> list:\n  nextEven = 0\n  nextOdd = len(arr) - 1\n  while nextEven < nextOdd:\n    if arr[nextEven] % 2 == 0:\n      nextEven += 1\n    else:\n      temp = arr[nextEven]\n      arr[nextEven] = arr[nextOdd]\n      arr[nextOdd] = temp\n      nextOdd -= 1\n  return arr\n", "asserts": ["assert even_odd_reorder([1,2,3,4,5,6,7,8,9]) == [8, 2, 6, 4, 5, 7, 3, 9, 1]", "assert even_odd_reorder([]) == []", "assert even_odd_reorder([2, 4, 6, 8]) == [2, 4, 6, 8]", "assert even_odd_reorder([7, 9, 2]) == [2, 9, 7]", "assert even_odd_reorder([10, 13, 17, 16, 15, 12]) == [10, 12, 16, 15, 17, 13]"]}, {"author": "Calvin", "UUID": "f795bda7-9822-4bc5-9c7e-b9c0f2752085", "question": "You are given two 0-indexed integer permutations A and B of length n.\n\nA prefix common array of A and B is an array C such that C[i] is equal to the count of numbers that are present at or before the index i in both A and B.\n\nReturn the prefix common array of A and B.\n\nA sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once.", "examples": "Input: A = [1,3,2,4], B = [3,1,2,4]\nOutput: [0,2,3,4]", "link": "https://leetcode.com/problems/find-the-prefix-common-array-of-two-arrays/", "difficulty": null, "categories": ["Array"], "code": "def findThePrefixCommonArray(arr1: list, arr2: list) -> list:\n  max = len(arr1) if len(arr1) > len(arr2) else len(arr2)\n  seen = set()\n  curCount = 0\n  ret = []\n  for i in range(max):\n    cur1 = arr1[i]\n    cur2 = arr2[i]\n    if cur1 in seen:\n      curCount += 1\n    else:\n      seen.add(cur1)\n    if cur2 in seen:\n      curCount += 1\n    else:\n      seen.add(cur2)\n    ret.append(curCount)\n  return ret\n", "asserts": ["assert findThePrefixCommonArray([1,3,2,4], [3,1,2,4]) == [0,2,3,4]", "assert findThePrefixCommonArray([1], [1]) == [1]", "assert findThePrefixCommonArray([2,3,1], [3,1,2]) == [0,1,3]"]}], "category": "Array", "prompt_tokens": 781, "total_tokens": 1051, "completion_tokens": 270, "completion": "Given an array of integers, move all zeros to the end of the array while maintaining the relative order of the non-zero elements. Do this in-place using constant extra space.\n\n###Code: \n\ndef move_zeros_to_end(arr: list) -> list:\n    non_zero_index = 0\n    for i in range(len(arr)):\n        if arr[i] != 0:\n            arr[non_zero_index], arr[i] = arr[i], arr[non_zero_index]\n            non_zero_index += 1\n    return arr\n\n###Testcases: \n\nassert move_zeros_to_end([0,1,0,3,12]) == [1,3,12,0,0]\nassert move_zeros_to_end([0,0,1]) == [1,0,0]\nassert move_zeros_to_end([4,2,4,0,0,3,0,5,1,0]) == [4,2,4,3,5,1,0,0,0,0]\nassert move_zeros_to_end([1,2,3,4,5]) == [1,2,3,4,5]\nassert move_zeros_to_end([0,0,0,0,0]) == [0,0,0,0,0]\n\n[/Example 3]", "temperature": 0.653}, {"few_shots": [{"author": "Calvin", "UUID": "fb94082f-4627-4f5a-b280-08d869823d70", "question": "You are given an array of people, people, which are the attributes of some people in a queue (not necessarily in order). Each people[i] = [hi, ki] represents the ith person of height hi with exactly ki other people in front who have a height greater than or equal to hi.\n\nReconstruct and return the queue that is represented by the input array people. The returned queue should be formatted as an array queue, where queue[j] = [hj, kj] is the attributes of the jth person in the queue (queue[0] is the person at the front of the queue).\n", "examples": "Input:  [[7, 0], [4, 4], [7, 1], [5, 0], [6, 1], [5, 2]]\nOutput: [[5, 0], [4, 1], [7, 0], [5, 2], [6, 1], [7, 1]]\n\nInput:  [[6, 0], [5, 0], [4, 0], [3, 2], [2, 2], [1, 4]]\nOutput: [[4, 0], [5, 0], [2, 2], [3, 2], [1, 4], [6, 0]]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "\ndef reconstructQueue(people: list) -> list:\n    output=[] \n    people.sort(key=lambda x: (-x[0], x[1]))                \n    for a in people:\n        output.insert(a[1], a)\n    \n    return output\n", "asserts": ["assert reconstructQueue([[8,1],[5,0],[6,1],[5,2],[4,4],[7,1]]) == [[5, 0], [8, 1], [5, 2], [6, 1], [4, 4], [7, 1]]", "assert reconstructQueue([[12,0], [6,3], [4,4], [9,2], [7,1]]) == [[12, 0], [7, 1], [9, 2], [6, 3], [4, 4]]", "assert reconstructQueue([[2,0], [1,1]]) == [[2, 0], [1, 1]]", "assert reconstructQueue([[3,0], [3,2], [3,1]]) == [[3, 0], [3, 1], [3, 2]]"]}, {"author": "Calvin", "UUID": "48c6aa37-e00d-4b55-9afc-6b1cf2a1aff2", "question": "There are N Mice and N holes are placed in a straight line. Each hole can accommodate only 1 mouse. A mouse can stay at his position, move one step right from x to x + 1, or move one step left from x to x -1. Any of these moves consumes 1 minute. Assign mice to holes so that the time when the last mouse gets inside a hole is minimized.\nYou are given a list of mice and hole positions as integer scalers.\n", "examples": "Input: Mices = [0, 10, 2, 3], Holes = [3, 2, 23, 0]\nOutput: 13", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def assignHole(mices: list, holes: list) -> int:\n    for i,j in zip(mices,holes):\n        if i<0 or j<0:\n            return -1\n    if (len(mices) != len(holes)):\n        return -1\n    mices.sort()\n    holes.sort()\n    Max = 0\n     \n    for i in range(len(holes)):\n        if (Max < abs(mices[i] - holes[i])):\n            Max = abs(mices[i] - holes[i])\n     \n    return Max\n", "asserts": ["assert assignHole([1, 2, 3, 4], [4, 3, 2, 1]) == 0", "assert assignHole([10, 20, 30, 40], [15, 25, 35, 45]) == 5", "assert assignHole([1, 4, 9, 15], [10, 13, 7, 20]) == 6", "assert assignHole([0], [0]) == 0", "assert assignHole([1, 2], [3]) == -1  # Edge case with non-equal amount of mice and holes", "assert assignHole([5, 5, 5], [5, 5, 5]) == 0  # Edge case with all mice and holes at the same position", "assert assignHole([10, 10, 10, 10], [10, 9, 8, 7]) == 3  # Edge case with multiple mice starting at the same position", "assert assignHole([1,1 ,1, 1, 1, 1, 1, 1, 1, 1], [2,2,2,2,2,2 ,2, 2, 2, 2]) == 1 # Edge case with multiple mice and holes at the same positions", "assert assignHole([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == 1 # Edge case with incremental positions"]}], "category": "Array", "prompt_tokens": 1164, "total_tokens": 1548, "completion_tokens": 384, "completion": "Given an array of integers nums and an integer k, return the total number of continuous subarrays whose sum equals to k.\n\n###Code:\n\n```python\ndef subarraySum(nums: list, k: int) -> int:\n    count = 0\n    for start in range(len(nums)):\n        sum_ = 0\n        for end in range(start, len(nums)):\n            sum_ += nums[end]\n            if sum_ == k:\n                count += 1\n    return count\n```\n\n###Testcases:\n\n```python\nassert subarraySum([1, 1, 1], 2) == 2\nassert subarraySum([1, 2, 3], 3) == 2\nassert subarraySum([1, 2, 1, 2, 1], 3) == 4\nassert subarraySum([10, 2, -2, -20, 10], -10) == 3\nassert subarraySum([], 0) == 0  # Edge case with an empty array\nassert subarraySum([1, -1, 0], 0) == 3  # Edge case with zeros and negative numbers\nassert subarraySum([-1, -1, -1], -2) == 2  # Edge case with all negative numbers\nassert subarraySum([5, 5, 5, 5, 5], 15) == 1  # Edge case with uniform values\nassert subarraySum([1], 0) == 0  # Edge case with single element and non-matching k\nassert subarraySum([1, 2, 3, 4, 5], 15) == 1  # Edge case with sum equal to the sum of whole array\n```\n[/Example 3]", "temperature": 0.892}, {"few_shots": [{"author": "Calvin", "UUID": "a9c5e697-af5d-432b-8447-5675d739c728", "question": "Given an array reorder it so that even numbers appear first", "examples": "Input: [1,2,3,4,5,6,7,8,9]\r\nOutput: [8,2,6,4,5,7,3,9,1]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def even_odd_reorder(arr: list) -> list:\n  nextEven = 0\n  nextOdd = len(arr) - 1\n  while nextEven < nextOdd:\n    if arr[nextEven] % 2 == 0:\n      nextEven += 1\n    else:\n      temp = arr[nextEven]\n      arr[nextEven] = arr[nextOdd]\n      arr[nextOdd] = temp\n      nextOdd -= 1\n  return arr\n", "asserts": ["assert even_odd_reorder([1,2,3,4,5,6,7,8,9]) == [8, 2, 6, 4, 5, 7, 3, 9, 1]", "assert even_odd_reorder([]) == []", "assert even_odd_reorder([2, 4, 6, 8]) == [2, 4, 6, 8]", "assert even_odd_reorder([7, 9, 2]) == [2, 9, 7]", "assert even_odd_reorder([10, 13, 17, 16, 15, 12]) == [10, 12, 16, 15, 17, 13]"]}, {"author": "Calvin", "UUID": "1aeb3246-4c22-4d34-a48c-db7be8ba1b94", "question": "You are given n activities with their start and finish times. Select the maximum number of activities that can be performed by a single person and return their indexes. Assume that a person can only work on a single activity at a time. \n", "examples": "Input: start  =  {10, 12, 20}, finish =  {20, 25, 30}\nOutput: [0, 2]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "import numpy as np\ndef MaxActivities(s: list, f: list) -> list:\n    indices = np.argsort(f)\n    [s[i] for i in indices]\n    [f[i] for i in indices]\n    result = []\n    n = len(f)\n    i = 0\n    result.append(i)\n    for j in range(1, n):\n        if s[j] >= f[i]:\n            result.append(j)\n            i = j\n    return result\n", "asserts": ["assert MaxActivities([2, 4, 5, 6, 7, 8], [3, 5, 6, 7, 9, 10]) == [0, 1, 2, 3, 4]", "assert MaxActivities([1, 3, 0, 5, 8, 5], [2, 4, 6, 7, 9, 9]) == [0, 1, 3, 4]", "assert MaxActivities([1], [2]) == [0]"]}], "category": "Array", "prompt_tokens": 746, "total_tokens": 941, "completion_tokens": 195, "completion": "Write a function to rotate an array to the right by k steps, where k is non-negative.\n\n###Code: \n\ndef rotate_array(nums: list, k: int) -> list:\n    k = k % len(nums)  # in case the number of rotations exceeds the array length\n    nums[:] = nums[-k:] + nums[:-k]\n    return nums\n\n\n###Testcases: \n\nassert rotate_array([1,2,3,4,5,6,7], 3) == [5,6,7,1,2,3,4]\nassert rotate_array([-1,-100,3,99], 2) == [3,99,-1,-100]\nassert rotate_array([1,2,3], 0) == [1,2,3]\nassert rotate_array([1,2], 5) == [2,1]\nassert rotate_array([], 3) == []\n\n[/Example 3]", "temperature": 0.804}, {"few_shots": [{"author": "Calvin", "UUID": "f795bda7-9822-4bc5-9c7e-b9c0f2752085", "question": "You are given two 0-indexed integer permutations A and B of length n.\n\nA prefix common array of A and B is an array C such that C[i] is equal to the count of numbers that are present at or before the index i in both A and B.\n\nReturn the prefix common array of A and B.\n\nA sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once.", "examples": "Input: A = [1,3,2,4], B = [3,1,2,4]\nOutput: [0,2,3,4]", "link": "https://leetcode.com/problems/find-the-prefix-common-array-of-two-arrays/", "difficulty": null, "categories": ["Array"], "code": "def findThePrefixCommonArray(arr1: list, arr2: list) -> list:\n  max = len(arr1) if len(arr1) > len(arr2) else len(arr2)\n  seen = set()\n  curCount = 0\n  ret = []\n  for i in range(max):\n    cur1 = arr1[i]\n    cur2 = arr2[i]\n    if cur1 in seen:\n      curCount += 1\n    else:\n      seen.add(cur1)\n    if cur2 in seen:\n      curCount += 1\n    else:\n      seen.add(cur2)\n    ret.append(curCount)\n  return ret\n", "asserts": ["assert findThePrefixCommonArray([1,3,2,4], [3,1,2,4]) == [0,2,3,4]", "assert findThePrefixCommonArray([1], [1]) == [1]", "assert findThePrefixCommonArray([2,3,1], [3,1,2]) == [0,1,3]"]}, {"author": "Calvin", "UUID": "48c6aa37-e00d-4b55-9afc-6b1cf2a1aff2", "question": "There are N Mice and N holes are placed in a straight line. Each hole can accommodate only 1 mouse. A mouse can stay at his position, move one step right from x to x + 1, or move one step left from x to x -1. Any of these moves consumes 1 minute. Assign mice to holes so that the time when the last mouse gets inside a hole is minimized.\nYou are given a list of mice and hole positions as integer scalers.\n", "examples": "Input: Mices = [0, 10, 2, 3], Holes = [3, 2, 23, 0]\nOutput: 13", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def assignHole(mices: list, holes: list) -> int:\n    for i,j in zip(mices,holes):\n        if i<0 or j<0:\n            return -1\n    if (len(mices) != len(holes)):\n        return -1\n    mices.sort()\n    holes.sort()\n    Max = 0\n     \n    for i in range(len(holes)):\n        if (Max < abs(mices[i] - holes[i])):\n            Max = abs(mices[i] - holes[i])\n     \n    return Max\n", "asserts": ["assert assignHole([1, 2, 3, 4], [4, 3, 2, 1]) == 0", "assert assignHole([10, 20, 30, 40], [15, 25, 35, 45]) == 5", "assert assignHole([1, 4, 9, 15], [10, 13, 7, 20]) == 6", "assert assignHole([0], [0]) == 0", "assert assignHole([1, 2], [3]) == -1  # Edge case with non-equal amount of mice and holes", "assert assignHole([5, 5, 5], [5, 5, 5]) == 0  # Edge case with all mice and holes at the same position", "assert assignHole([10, 10, 10, 10], [10, 9, 8, 7]) == 3  # Edge case with multiple mice starting at the same position", "assert assignHole([1,1 ,1, 1, 1, 1, 1, 1, 1, 1], [2,2,2,2,2,2 ,2, 2, 2, 2]) == 1 # Edge case with multiple mice and holes at the same positions", "assert assignHole([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == 1 # Edge case with incremental positions"]}], "category": "Array", "prompt_tokens": 1103, "total_tokens": 1487, "completion_tokens": 384, "completion": "Given a list of integers, write a function to move all zeros to the end of it while maintaining the relative order of the non-zero elements. You must do this in-place without making a copy of the array. Minimize the total number of operations.\n\n###Code: \n\ndef moveZerosToEnd(nums: list) -> None:\n    non_zero_index = 0\n    for i in range(len(nums)):\n        if nums[i] != 0:\n            nums[non_zero_index], nums[i] = nums[i], nums[non_zero_index]\n            non_zero_index += 1\n\n###Testcases: \n\narr1 = [0, 1, 0, 3, 12]\nmoveZerosToEnd(arr1)\nassert arr1 == [1, 3, 12, 0, 0]\n\narr2 = [0, 0, 1]\nmoveZerosToEnd(arr2)\nassert arr2 == [1, 0, 0]\n\narr3 = [4, 2, 4, 0, 0, 3, 0, 5, 1, 0]\nmoveZerosToEnd(arr3)\nassert arr3 == [4, 2, 4, 3, 5, 1, 0, 0, 0, 0]\n\narr4 = [1, 2, 3, 4]\nmoveZerosToEnd(arr4)\nassert arr4 == [1, 2, 3, 4]\n\narr5 = [0, 0, 0, 0, 0, 0]\nmoveZerosToEnd(arr5)\nassert arr5 == [0, 0, 0, 0, 0, 0]\n\narr6 = []\nmoveZerosToEnd(arr6)\nassert arr6 == []\n\n[/Example 3]", "temperature": 0.673}, {"few_shots": [{"author": "Calvin", "UUID": "1aeb3246-4c22-4d34-a48c-db7be8ba1b94", "question": "You are given n activities with their start and finish times. Select the maximum number of activities that can be performed by a single person and return their indexes. Assume that a person can only work on a single activity at a time. \n", "examples": "Input: start  =  {10, 12, 20}, finish =  {20, 25, 30}\nOutput: [0, 2]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "import numpy as np\ndef MaxActivities(s: list, f: list) -> list:\n    indices = np.argsort(f)\n    [s[i] for i in indices]\n    [f[i] for i in indices]\n    result = []\n    n = len(f)\n    i = 0\n    result.append(i)\n    for j in range(1, n):\n        if s[j] >= f[i]:\n            result.append(j)\n            i = j\n    return result\n", "asserts": ["assert MaxActivities([2, 4, 5, 6, 7, 8], [3, 5, 6, 7, 9, 10]) == [0, 1, 2, 3, 4]", "assert MaxActivities([1, 3, 0, 5, 8, 5], [2, 4, 6, 7, 9, 9]) == [0, 1, 3, 4]", "assert MaxActivities([1], [2]) == [0]"]}, {"author": "Calvin", "UUID": "48c6aa37-e00d-4b55-9afc-6b1cf2a1aff2", "question": "There are N Mice and N holes are placed in a straight line. Each hole can accommodate only 1 mouse. A mouse can stay at his position, move one step right from x to x + 1, or move one step left from x to x -1. Any of these moves consumes 1 minute. Assign mice to holes so that the time when the last mouse gets inside a hole is minimized.\nYou are given a list of mice and hole positions as integer scalers.\n", "examples": "Input: Mices = [0, 10, 2, 3], Holes = [3, 2, 23, 0]\nOutput: 13", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def assignHole(mices: list, holes: list) -> int:\n    for i,j in zip(mices,holes):\n        if i<0 or j<0:\n            return -1\n    if (len(mices) != len(holes)):\n        return -1\n    mices.sort()\n    holes.sort()\n    Max = 0\n     \n    for i in range(len(holes)):\n        if (Max < abs(mices[i] - holes[i])):\n            Max = abs(mices[i] - holes[i])\n     \n    return Max\n", "asserts": ["assert assignHole([1, 2, 3, 4], [4, 3, 2, 1]) == 0", "assert assignHole([10, 20, 30, 40], [15, 25, 35, 45]) == 5", "assert assignHole([1, 4, 9, 15], [10, 13, 7, 20]) == 6", "assert assignHole([0], [0]) == 0", "assert assignHole([1, 2], [3]) == -1  # Edge case with non-equal amount of mice and holes", "assert assignHole([5, 5, 5], [5, 5, 5]) == 0  # Edge case with all mice and holes at the same position", "assert assignHole([10, 10, 10, 10], [10, 9, 8, 7]) == 3  # Edge case with multiple mice starting at the same position", "assert assignHole([1,1 ,1, 1, 1, 1, 1, 1, 1, 1], [2,2,2,2,2,2 ,2, 2, 2, 2]) == 1 # Edge case with multiple mice and holes at the same positions", "assert assignHole([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == 1 # Edge case with incremental positions"]}], "category": "Array", "prompt_tokens": 1068, "total_tokens": 1328, "completion_tokens": 260, "completion": "Write a function that takes an unsorted array of non-negative integers and returns an array of duplicated numbers in the order they first appeared in the input array. If no duplicates exist, return an empty array.\n\n###Code: \n\ndef findDuplicates(arr: list) -> list:\n    seen = set()\n    duplicates = []\n    for num in arr:\n        if num in seen:\n            duplicates.append(num)\n        else:\n            seen.add(num)\n    return duplicates\n\n###Testcases: \n\nassert findDuplicates([1, 2, 3, 1, 2, 4]) == [1, 2]\nassert findDuplicates([1, 1, 1, 1, 1]) == [1, 1, 1, 1]\nassert findDuplicates([1, 2, 3, 4, 5]) == []\nassert findDuplicates([]) == []\nassert findDuplicates([2, 4, 6, 8, 10, 2, 6, 10]) == [2, 6, 10]\nassert findDuplicates([5, 3, 5, 3, 9, 1, 3]) == [5, 3, 3]\n\n[/Example 3]", "temperature": 0.899}, {"few_shots": [{"author": "Calvin", "UUID": "9e45b73f-583d-40ab-b387-e0d1624af07b", "question": "Given two arrays return an array with the set intersection of their common elements", "examples": "Input: arr1 = [1, 2, 3, 4], arr2 = [2, 3]\nOutput: [2, 3]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def array_intersection(arr1: list, arr2: list) -> set:\n  set1 = set(arr1)\n  ret = set([x for x in arr2 if x in set1])\n  return list(ret)\n", "asserts": ["assert set(array_intersection([1,0,2,0,2,0,2,1,1,1], [2,1,0,2,0,2,2,2,1,0])) == {0,1,2}", "assert set(array_intersection([5, 6, 7, 8], [8, 9, 10, 11])) == {8}", "assert set(array_intersection([10, 20, 30], [40, 50, 60])) == set()", "assert set(array_intersection([], [1, 2, 3])) == set()", "assert set(array_intersection([-1, -2, -3], [-3, -4, -5, -6])) == {-3}", "assert set(array_intersection([9, 8, 7], [7, 8, 9, 10, 11, 12])) == {7, 8, 9}", "assert set(array_intersection(['a', 'b', 'c'], ['a', 'd', 'e', 'c'])) == {'a', 'c'}", "assert set(array_intersection(['apple', 'banana'], ['banana', 'cherry'])) == {'banana'}", "assert set(array_intersection([1.1, 2.2, 3.3], [2.2, 4.4])) == {2.2}", "assert set(array_intersection([False, True, False], [True, False, True])) == {True, False}", "assert set(array_intersection([(1, 2), (3, 4)], [(3, 4), (5, 6)])) == {(3, 4)}"]}, {"author": "Calvin", "UUID": "1aeb3246-4c22-4d34-a48c-db7be8ba1b94", "question": "You are given n activities with their start and finish times. Select the maximum number of activities that can be performed by a single person and return their indexes. Assume that a person can only work on a single activity at a time. \n", "examples": "Input: start  =  {10, 12, 20}, finish =  {20, 25, 30}\nOutput: [0, 2]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "import numpy as np\ndef MaxActivities(s: list, f: list) -> list:\n    indices = np.argsort(f)\n    [s[i] for i in indices]\n    [f[i] for i in indices]\n    result = []\n    n = len(f)\n    i = 0\n    result.append(i)\n    for j in range(1, n):\n        if s[j] >= f[i]:\n            result.append(j)\n            i = j\n    return result\n", "asserts": ["assert MaxActivities([2, 4, 5, 6, 7, 8], [3, 5, 6, 7, 9, 10]) == [0, 1, 2, 3, 4]", "assert MaxActivities([1, 3, 0, 5, 8, 5], [2, 4, 6, 7, 9, 9]) == [0, 1, 3, 4]", "assert MaxActivities([1], [2]) == [0]"]}], "category": "Array", "prompt_tokens": 887, "total_tokens": 1235, "completion_tokens": 348, "completion": "Write a function that rotates an array to the right by k steps, where k is non-negative. Perform the operation in-place with O(1) extra space.\n\n###Code: \n\ndef rotate_array(nums: list, k: int) -> None:\n    n = len(nums)\n    k = k % n\n    nums[:] = nums[n-k:] + nums[:n-k]\n\n###Testcases: \n\nassert (lambda x: rotate_array(x, 3) or x)([1,2,3,4,5,6,7]) == [5,6,7,1,2,3,4]\nassert (lambda x: rotate_array(x, 2) or x)([-1,-100,3,99]) == [3,99,-1,-100]\nassert (lambda x: rotate_array(x, 0) or x)([1,2,3]) == [1,2,3]\nassert (lambda x: rotate_array(x, 1) or x)([1]) == [1]\nassert (lambda x: rotate_array(x, 2) or x)([1,2]) == [1,2]\nassert (lambda x: rotate_array(x, 5) or x)([1,2,3,4,5,6]) == [2,3,4,5,6,1]\nassert (lambda x: rotate_array(x, 3) or x)([]) == []\nassert (lambda x: rotate_array(x, 4) or x)([1,1,2,2,3,3]) == [2,2,3,3,1,1]\n\n[/Example 3]", "temperature": 0.776}, {"few_shots": [{"author": "Calvin", "UUID": "f795bda7-9822-4bc5-9c7e-b9c0f2752085", "question": "You are given two 0-indexed integer permutations A and B of length n.\n\nA prefix common array of A and B is an array C such that C[i] is equal to the count of numbers that are present at or before the index i in both A and B.\n\nReturn the prefix common array of A and B.\n\nA sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once.", "examples": "Input: A = [1,3,2,4], B = [3,1,2,4]\nOutput: [0,2,3,4]", "link": "https://leetcode.com/problems/find-the-prefix-common-array-of-two-arrays/", "difficulty": null, "categories": ["Array"], "code": "def findThePrefixCommonArray(arr1: list, arr2: list) -> list:\n  max = len(arr1) if len(arr1) > len(arr2) else len(arr2)\n  seen = set()\n  curCount = 0\n  ret = []\n  for i in range(max):\n    cur1 = arr1[i]\n    cur2 = arr2[i]\n    if cur1 in seen:\n      curCount += 1\n    else:\n      seen.add(cur1)\n    if cur2 in seen:\n      curCount += 1\n    else:\n      seen.add(cur2)\n    ret.append(curCount)\n  return ret\n", "asserts": ["assert findThePrefixCommonArray([1,3,2,4], [3,1,2,4]) == [0,2,3,4]", "assert findThePrefixCommonArray([1], [1]) == [1]", "assert findThePrefixCommonArray([2,3,1], [3,1,2]) == [0,1,3]"]}, {"author": "Calvin", "UUID": "1aeb3246-4c22-4d34-a48c-db7be8ba1b94", "question": "You are given n activities with their start and finish times. Select the maximum number of activities that can be performed by a single person and return their indexes. Assume that a person can only work on a single activity at a time. \n", "examples": "Input: start  =  {10, 12, 20}, finish =  {20, 25, 30}\nOutput: [0, 2]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "import numpy as np\ndef MaxActivities(s: list, f: list) -> list:\n    indices = np.argsort(f)\n    [s[i] for i in indices]\n    [f[i] for i in indices]\n    result = []\n    n = len(f)\n    i = 0\n    result.append(i)\n    for j in range(1, n):\n        if s[j] >= f[i]:\n            result.append(j)\n            i = j\n    return result\n", "asserts": ["assert MaxActivities([2, 4, 5, 6, 7, 8], [3, 5, 6, 7, 9, 10]) == [0, 1, 2, 3, 4]", "assert MaxActivities([1, 3, 0, 5, 8, 5], [2, 4, 6, 7, 9, 9]) == [0, 1, 3, 4]", "assert MaxActivities([1], [2]) == [0]"]}], "category": "Array", "prompt_tokens": 782, "total_tokens": 1069, "completion_tokens": 287, "completion": "Given an array of integers, find the maximum difference between any two elements such that the larger element comes after the smaller element in the array. Return the maximum difference found, or return -1 if no such element pair (i, j) exists such that i < j and arr[i] < arr[j].\n\n###Code:\n\ndef maxDifference(arr: list) -> int:\n    if len(arr) < 2:\n        return -1\n    min_element = arr[0]\n    max_diff = arr[1] - arr[0]\n    for i in range(1, len(arr)):\n        if arr[i] - min_element > max_diff:\n            max_diff = arr[i] - min_element\n        if arr[i] < min_element:\n            min_element = arr[i]\n    return max_diff if max_diff > 0 else -1\n\n\n###Testcases:\n\nassert maxDifference([2, 3, 10, 6, 4, 8, 1]) == 8\nassert maxDifference([7, 9, 5, 6, 3, 2]) == 2\nassert maxDifference([1, 2, 6, 4]) == 5\nassert maxDifference([9, 8, 7, 6, 5]) == -1\nassert maxDifference([5]) == -1\n\n[/Example 3]", "temperature": 0.713}, {"few_shots": [{"author": "Calvin", "UUID": "48c6aa37-e00d-4b55-9afc-6b1cf2a1aff2", "question": "There are N Mice and N holes are placed in a straight line. Each hole can accommodate only 1 mouse. A mouse can stay at his position, move one step right from x to x + 1, or move one step left from x to x -1. Any of these moves consumes 1 minute. Assign mice to holes so that the time when the last mouse gets inside a hole is minimized.\nYou are given a list of mice and hole positions as integer scalers.\n", "examples": "Input: Mices = [0, 10, 2, 3], Holes = [3, 2, 23, 0]\nOutput: 13", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def assignHole(mices: list, holes: list) -> int:\n    for i,j in zip(mices,holes):\n        if i<0 or j<0:\n            return -1\n    if (len(mices) != len(holes)):\n        return -1\n    mices.sort()\n    holes.sort()\n    Max = 0\n     \n    for i in range(len(holes)):\n        if (Max < abs(mices[i] - holes[i])):\n            Max = abs(mices[i] - holes[i])\n     \n    return Max\n", "asserts": ["assert assignHole([1, 2, 3, 4], [4, 3, 2, 1]) == 0", "assert assignHole([10, 20, 30, 40], [15, 25, 35, 45]) == 5", "assert assignHole([1, 4, 9, 15], [10, 13, 7, 20]) == 6", "assert assignHole([0], [0]) == 0", "assert assignHole([1, 2], [3]) == -1  # Edge case with non-equal amount of mice and holes", "assert assignHole([5, 5, 5], [5, 5, 5]) == 0  # Edge case with all mice and holes at the same position", "assert assignHole([10, 10, 10, 10], [10, 9, 8, 7]) == 3  # Edge case with multiple mice starting at the same position", "assert assignHole([1,1 ,1, 1, 1, 1, 1, 1, 1, 1], [2,2,2,2,2,2 ,2, 2, 2, 2]) == 1 # Edge case with multiple mice and holes at the same positions", "assert assignHole([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == 1 # Edge case with incremental positions"]}, {"author": "Calvin", "UUID": "a9c5e697-af5d-432b-8447-5675d739c728", "question": "Given an array reorder it so that even numbers appear first", "examples": "Input: [1,2,3,4,5,6,7,8,9]\r\nOutput: [8,2,6,4,5,7,3,9,1]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def even_odd_reorder(arr: list) -> list:\n  nextEven = 0\n  nextOdd = len(arr) - 1\n  while nextEven < nextOdd:\n    if arr[nextEven] % 2 == 0:\n      nextEven += 1\n    else:\n      temp = arr[nextEven]\n      arr[nextEven] = arr[nextOdd]\n      arr[nextOdd] = temp\n      nextOdd -= 1\n  return arr\n", "asserts": ["assert even_odd_reorder([1,2,3,4,5,6,7,8,9]) == [8, 2, 6, 4, 5, 7, 3, 9, 1]", "assert even_odd_reorder([]) == []", "assert even_odd_reorder([2, 4, 6, 8]) == [2, 4, 6, 8]", "assert even_odd_reorder([7, 9, 2]) == [2, 9, 7]", "assert even_odd_reorder([10, 13, 17, 16, 15, 12]) == [10, 12, 16, 15, 17, 13]"]}], "category": "Array", "prompt_tokens": 1067, "total_tokens": 1329, "completion_tokens": 262, "completion": "Write a function that takes an array of integers and returns the sum of the elements at the even indices (0, 2, 4, ...) minus the sum of the elements at the odd indices (1, 3, 5, ...).\n\n###Code: \n\ndef even_odd_index_sum_difference(arr):\n    even_sum = sum(arr[i] for i in range(0, len(arr), 2))\n    odd_sum = sum(arr[i] for i in range(1, len(arr), 2))\n    return even_sum - odd_sum\n\n###Testcases: \n\nassert even_odd_index_sum_difference([1, 2, 3, 4, 5, 6]) == (1 + 3 + 5) - (2 + 4 + 6)\nassert even_odd_index_sum_difference([10, -1, -1, 10]) == (10 + -1) - (-1 + 10)\nassert even_odd_index_sum_difference([]) == 0\nassert even_odd_index_sum_difference([50]) == 50\nassert even_odd_index_sum_difference([-10, 20, -30, 40, -50]) == (-10 + -30 + -50) - (20 + 40)\n\n[/Example 3]", "temperature": 0.788}, {"few_shots": [{"author": "Calvin", "UUID": "fb94082f-4627-4f5a-b280-08d869823d70", "question": "You are given an array of people, people, which are the attributes of some people in a queue (not necessarily in order). Each people[i] = [hi, ki] represents the ith person of height hi with exactly ki other people in front who have a height greater than or equal to hi.\n\nReconstruct and return the queue that is represented by the input array people. The returned queue should be formatted as an array queue, where queue[j] = [hj, kj] is the attributes of the jth person in the queue (queue[0] is the person at the front of the queue).\n", "examples": "Input:  [[7, 0], [4, 4], [7, 1], [5, 0], [6, 1], [5, 2]]\nOutput: [[5, 0], [4, 1], [7, 0], [5, 2], [6, 1], [7, 1]]\n\nInput:  [[6, 0], [5, 0], [4, 0], [3, 2], [2, 2], [1, 4]]\nOutput: [[4, 0], [5, 0], [2, 2], [3, 2], [1, 4], [6, 0]]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "\ndef reconstructQueue(people: list) -> list:\n    output=[] \n    people.sort(key=lambda x: (-x[0], x[1]))                \n    for a in people:\n        output.insert(a[1], a)\n    \n    return output\n", "asserts": ["assert reconstructQueue([[8,1],[5,0],[6,1],[5,2],[4,4],[7,1]]) == [[5, 0], [8, 1], [5, 2], [6, 1], [4, 4], [7, 1]]", "assert reconstructQueue([[12,0], [6,3], [4,4], [9,2], [7,1]]) == [[12, 0], [7, 1], [9, 2], [6, 3], [4, 4]]", "assert reconstructQueue([[2,0], [1,1]]) == [[2, 0], [1, 1]]", "assert reconstructQueue([[3,0], [3,2], [3,1]]) == [[3, 0], [3, 1], [3, 2]]"]}, {"author": "Calvin", "UUID": "a9c5e697-af5d-432b-8447-5675d739c728", "question": "Given an array reorder it so that even numbers appear first", "examples": "Input: [1,2,3,4,5,6,7,8,9]\r\nOutput: [8,2,6,4,5,7,3,9,1]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def even_odd_reorder(arr: list) -> list:\n  nextEven = 0\n  nextOdd = len(arr) - 1\n  while nextEven < nextOdd:\n    if arr[nextEven] % 2 == 0:\n      nextEven += 1\n    else:\n      temp = arr[nextEven]\n      arr[nextEven] = arr[nextOdd]\n      arr[nextOdd] = temp\n      nextOdd -= 1\n  return arr\n", "asserts": ["assert even_odd_reorder([1,2,3,4,5,6,7,8,9]) == [8, 2, 6, 4, 5, 7, 3, 9, 1]", "assert even_odd_reorder([]) == []", "assert even_odd_reorder([2, 4, 6, 8]) == [2, 4, 6, 8]", "assert even_odd_reorder([7, 9, 2]) == [2, 9, 7]", "assert even_odd_reorder([10, 13, 17, 16, 15, 12]) == [10, 12, 16, 15, 17, 13]"]}], "category": "Array", "prompt_tokens": 842, "total_tokens": 1212, "completion_tokens": 370, "completion": "Write a function that takes an array of numbers and returns an array of arrays, where each subarray contains all unique pairs of numbers that sum up to a target value. Each pair should be sorted in ascending order, and the array of pairs should be sorted in ascending order by the first number, and then by the second number in each pair.\n\n###Code:\n\n```python\ndef two_sum_pairs(nums: list, target: int) -> list:\n    nums.sort()\n    pairs = []\n    left, right = 0, len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            pairs.append([nums[left], nums[right]])\n            left += 1\n            right -= 1\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return pairs\n\n```\n\n###Testcases: \n\n```python\nassert two_sum_pairs([2, 3, 4, -1, 0, 2, 3, -2], 5) == [[2, 3], [2, 3]]\nassert two_sum_pairs([1, -1, 2, -2, 3, 0], 1) == [[-1, 2], [0, 1]]\nassert two_sum_pairs([3, 1, 3, 2], 6) == [[3, 3]]\nassert two_sum_pairs([0, 0, 0, 0], 0) == [[0, 0]]\nassert two_sum_pairs([], 3) == []\nassert two_sum_pairs([5, 5, 5], 10) == [[5, 5]]\n```\n\n[/Example 3]", "temperature": 0.831}, {"few_shots": [{"author": "Calvin", "UUID": "9e45b73f-583d-40ab-b387-e0d1624af07b", "question": "Given two arrays return an array with the set intersection of their common elements", "examples": "Input: arr1 = [1, 2, 3, 4], arr2 = [2, 3]\nOutput: [2, 3]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def array_intersection(arr1: list, arr2: list) -> set:\n  set1 = set(arr1)\n  ret = set([x for x in arr2 if x in set1])\n  return list(ret)\n", "asserts": ["assert set(array_intersection([1,0,2,0,2,0,2,1,1,1], [2,1,0,2,0,2,2,2,1,0])) == {0,1,2}", "assert set(array_intersection([5, 6, 7, 8], [8, 9, 10, 11])) == {8}", "assert set(array_intersection([10, 20, 30], [40, 50, 60])) == set()", "assert set(array_intersection([], [1, 2, 3])) == set()", "assert set(array_intersection([-1, -2, -3], [-3, -4, -5, -6])) == {-3}", "assert set(array_intersection([9, 8, 7], [7, 8, 9, 10, 11, 12])) == {7, 8, 9}", "assert set(array_intersection(['a', 'b', 'c'], ['a', 'd', 'e', 'c'])) == {'a', 'c'}", "assert set(array_intersection(['apple', 'banana'], ['banana', 'cherry'])) == {'banana'}", "assert set(array_intersection([1.1, 2.2, 3.3], [2.2, 4.4])) == {2.2}", "assert set(array_intersection([False, True, False], [True, False, True])) == {True, False}", "assert set(array_intersection([(1, 2), (3, 4)], [(3, 4), (5, 6)])) == {(3, 4)}"]}, {"author": "Calvin", "UUID": "48c6aa37-e00d-4b55-9afc-6b1cf2a1aff2", "question": "There are N Mice and N holes are placed in a straight line. Each hole can accommodate only 1 mouse. A mouse can stay at his position, move one step right from x to x + 1, or move one step left from x to x -1. Any of these moves consumes 1 minute. Assign mice to holes so that the time when the last mouse gets inside a hole is minimized.\nYou are given a list of mice and hole positions as integer scalers.\n", "examples": "Input: Mices = [0, 10, 2, 3], Holes = [3, 2, 23, 0]\nOutput: 13", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def assignHole(mices: list, holes: list) -> int:\n    for i,j in zip(mices,holes):\n        if i<0 or j<0:\n            return -1\n    if (len(mices) != len(holes)):\n        return -1\n    mices.sort()\n    holes.sort()\n    Max = 0\n     \n    for i in range(len(holes)):\n        if (Max < abs(mices[i] - holes[i])):\n            Max = abs(mices[i] - holes[i])\n     \n    return Max\n", "asserts": ["assert assignHole([1, 2, 3, 4], [4, 3, 2, 1]) == 0", "assert assignHole([10, 20, 30, 40], [15, 25, 35, 45]) == 5", "assert assignHole([1, 4, 9, 15], [10, 13, 7, 20]) == 6", "assert assignHole([0], [0]) == 0", "assert assignHole([1, 2], [3]) == -1  # Edge case with non-equal amount of mice and holes", "assert assignHole([5, 5, 5], [5, 5, 5]) == 0  # Edge case with all mice and holes at the same position", "assert assignHole([10, 10, 10, 10], [10, 9, 8, 7]) == 3  # Edge case with multiple mice starting at the same position", "assert assignHole([1,1 ,1, 1, 1, 1, 1, 1, 1, 1], [2,2,2,2,2,2 ,2, 2, 2, 2]) == 1 # Edge case with multiple mice and holes at the same positions", "assert assignHole([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == 1 # Edge case with incremental positions"]}], "category": "Array", "prompt_tokens": 1208, "total_tokens": 1826, "completion_tokens": 618, "completion": "Given two equal-length arrays `nums1` and `nums2`, where `nums1[i]` is an element from the first array and `nums2[i]` is the corresponding element from the second array, create and return an array that for each element from the first array, contains the next greater element of that element in the second array.\n\nThe next greater element of a number in the second array is the first greater number to its right in the second array. If it does not exist, output -1 for that number.\n\n###Code: \n\ndef next_greater_element(nums1: list, nums2: list) -> list:\n    result = []\n    greater_dict = {}\n    stack = []\n    \n    # Generate a dictionary with all the next greater elements for nums2\n    for num in nums2:\n        while stack and stack[-1] < num:\n            greater_dict[stack.pop()] = num\n        stack.append(num)\n    \n    # If there is no next greater element, the dictionary will contain -1\n    while stack:\n        greater_dict[stack.pop()] = -1\n    \n    # Map the next greater elements from nums2 to nums1\n    for num in nums1:\n        result.append(greater_dict[num])\n        \n    return result\n\n###Testcases: \n\nassert next_greater_element([4, 1, 2], [1, 3, 4, 2]) == [-1, 3, 3]\nassert next_greater_element([2, 4], [1, 2, 3, 4]) == [3, -1]\nassert next_greater_element([1, 3, 5, 7], [7, 5, 3, 1]) == [-1, -1, -1, -1]\nassert next_greater_element([2, 4, 6], [6, 4, 2, 1, 5]) == [5, 5, -1]\nassert next_greater_element([], []) == []\nassert next_greater_element([10, 20, 30], [30, 10, 20, 5, 25]) == [30, 30, -1]\nassert next_greater_element([9, 8, 7], [7, 8, 9, 11, 10]) == [11, 9, 8]\nassert next_greater_element([1, 1, 1, 1], [1, 3, 4, 2]) == [3, 3, 3, 3]\nassert next_greater_element([5, 5, 5], [6, 5, 4, 3, 2, 1, 7]) == [7, 7, 7]\nassert next_greater_element([14, 10], [15, 13, 14, 17, 12, 10, 16]) == [17, 12]\n\n[/Example 3]", "temperature": 0.931}, {"few_shots": [{"author": "Calvin", "UUID": "1aeb3246-4c22-4d34-a48c-db7be8ba1b94", "question": "You are given n activities with their start and finish times. Select the maximum number of activities that can be performed by a single person and return their indexes. Assume that a person can only work on a single activity at a time. \n", "examples": "Input: start  =  {10, 12, 20}, finish =  {20, 25, 30}\nOutput: [0, 2]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "import numpy as np\ndef MaxActivities(s: list, f: list) -> list:\n    indices = np.argsort(f)\n    [s[i] for i in indices]\n    [f[i] for i in indices]\n    result = []\n    n = len(f)\n    i = 0\n    result.append(i)\n    for j in range(1, n):\n        if s[j] >= f[i]:\n            result.append(j)\n            i = j\n    return result\n", "asserts": ["assert MaxActivities([2, 4, 5, 6, 7, 8], [3, 5, 6, 7, 9, 10]) == [0, 1, 2, 3, 4]", "assert MaxActivities([1, 3, 0, 5, 8, 5], [2, 4, 6, 7, 9, 9]) == [0, 1, 3, 4]", "assert MaxActivities([1], [2]) == [0]"]}, {"author": "Calvin", "UUID": "48c6aa37-e00d-4b55-9afc-6b1cf2a1aff2", "question": "There are N Mice and N holes are placed in a straight line. Each hole can accommodate only 1 mouse. A mouse can stay at his position, move one step right from x to x + 1, or move one step left from x to x -1. Any of these moves consumes 1 minute. Assign mice to holes so that the time when the last mouse gets inside a hole is minimized.\nYou are given a list of mice and hole positions as integer scalers.\n", "examples": "Input: Mices = [0, 10, 2, 3], Holes = [3, 2, 23, 0]\nOutput: 13", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def assignHole(mices: list, holes: list) -> int:\n    for i,j in zip(mices,holes):\n        if i<0 or j<0:\n            return -1\n    if (len(mices) != len(holes)):\n        return -1\n    mices.sort()\n    holes.sort()\n    Max = 0\n     \n    for i in range(len(holes)):\n        if (Max < abs(mices[i] - holes[i])):\n            Max = abs(mices[i] - holes[i])\n     \n    return Max\n", "asserts": ["assert assignHole([1, 2, 3, 4], [4, 3, 2, 1]) == 0", "assert assignHole([10, 20, 30, 40], [15, 25, 35, 45]) == 5", "assert assignHole([1, 4, 9, 15], [10, 13, 7, 20]) == 6", "assert assignHole([0], [0]) == 0", "assert assignHole([1, 2], [3]) == -1  # Edge case with non-equal amount of mice and holes", "assert assignHole([5, 5, 5], [5, 5, 5]) == 0  # Edge case with all mice and holes at the same position", "assert assignHole([10, 10, 10, 10], [10, 9, 8, 7]) == 3  # Edge case with multiple mice starting at the same position", "assert assignHole([1,1 ,1, 1, 1, 1, 1, 1, 1, 1], [2,2,2,2,2,2 ,2, 2, 2, 2]) == 1 # Edge case with multiple mice and holes at the same positions", "assert assignHole([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == 1 # Edge case with incremental positions"]}], "category": "Array", "prompt_tokens": 1068, "total_tokens": 1556, "completion_tokens": 488, "completion": "Write a function that takes an array of integers and rotates it to the right by a given number of steps. Each step should move the last element of the array to the front of the array and shift all other elements to the right by one. The function should return the rotated array.\n\n###Code:\n\ndef rotateArrayRight(arr: list, steps: int) -> list:\n    if not arr or steps < 0:\n        return arr\n    steps = steps % len(arr)  # Normalize the steps in case it's greater than array length\n    return arr[-steps:] + arr[:-steps]\n\n###Testcases:\n\nassert rotateArrayRight([1, 2, 3, 4, 5], 2) == [4, 5, 1, 2, 3]\nassert rotateArrayRight([1, 2, 3, 4, 5], 0) == [1, 2, 3, 4, 5]\nassert rotateArrayRight([1], 100) == [1]\nassert rotateArrayRight([], 2) == []\nassert rotateArrayRight([1, 2, 3, 4, 5, 6], 3) == [4, 5, 6, 1, 2, 3]\nassert rotateArrayRight([1, 2, 3, 4, 5, 6, 7], 1) == [7, 1, 2, 3, 4, 5, 6]\nassert rotateArrayRight([1, 2, 3, 4, 5, 6, 7], 7) == [1, 2, 3, 4, 5, 6, 7]  # Full rotation ends up with the original array\nassert rotateArrayRight([1, 2, 3, 4, 5, 6, 7], -1) == [1, 2, 3, 4, 5, 6, 7]  # Negative steps should do nothing\nassert rotateArrayRight([1, 2, 3, 4], 5) == [4, 1, 2, 3]  # More steps than elements leads to a normalized rotation\n\n[/Example 3]", "temperature": 0.856}, {"few_shots": [{"author": "Calvin", "UUID": "9e45b73f-583d-40ab-b387-e0d1624af07b", "question": "Given two arrays return an array with the set intersection of their common elements", "examples": "Input: arr1 = [1, 2, 3, 4], arr2 = [2, 3]\nOutput: [2, 3]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def array_intersection(arr1: list, arr2: list) -> set:\n  set1 = set(arr1)\n  ret = set([x for x in arr2 if x in set1])\n  return list(ret)\n", "asserts": ["assert set(array_intersection([1,0,2,0,2,0,2,1,1,1], [2,1,0,2,0,2,2,2,1,0])) == {0,1,2}", "assert set(array_intersection([5, 6, 7, 8], [8, 9, 10, 11])) == {8}", "assert set(array_intersection([10, 20, 30], [40, 50, 60])) == set()", "assert set(array_intersection([], [1, 2, 3])) == set()", "assert set(array_intersection([-1, -2, -3], [-3, -4, -5, -6])) == {-3}", "assert set(array_intersection([9, 8, 7], [7, 8, 9, 10, 11, 12])) == {7, 8, 9}", "assert set(array_intersection(['a', 'b', 'c'], ['a', 'd', 'e', 'c'])) == {'a', 'c'}", "assert set(array_intersection(['apple', 'banana'], ['banana', 'cherry'])) == {'banana'}", "assert set(array_intersection([1.1, 2.2, 3.3], [2.2, 4.4])) == {2.2}", "assert set(array_intersection([False, True, False], [True, False, True])) == {True, False}", "assert set(array_intersection([(1, 2), (3, 4)], [(3, 4), (5, 6)])) == {(3, 4)}"]}, {"author": "Calvin", "UUID": "a9c5e697-af5d-432b-8447-5675d739c728", "question": "Given an array reorder it so that even numbers appear first", "examples": "Input: [1,2,3,4,5,6,7,8,9]\r\nOutput: [8,2,6,4,5,7,3,9,1]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def even_odd_reorder(arr: list) -> list:\n  nextEven = 0\n  nextOdd = len(arr) - 1\n  while nextEven < nextOdd:\n    if arr[nextEven] % 2 == 0:\n      nextEven += 1\n    else:\n      temp = arr[nextEven]\n      arr[nextEven] = arr[nextOdd]\n      arr[nextOdd] = temp\n      nextOdd -= 1\n  return arr\n", "asserts": ["assert even_odd_reorder([1,2,3,4,5,6,7,8,9]) == [8, 2, 6, 4, 5, 7, 3, 9, 1]", "assert even_odd_reorder([]) == []", "assert even_odd_reorder([2, 4, 6, 8]) == [2, 4, 6, 8]", "assert even_odd_reorder([7, 9, 2]) == [2, 9, 7]", "assert even_odd_reorder([10, 13, 17, 16, 15, 12]) == [10, 12, 16, 15, 17, 13]"]}], "category": "Array", "prompt_tokens": 886, "total_tokens": 1153, "completion_tokens": 267, "completion": "Given an array of integers, return an array that contains the product of every other number except the number at that index without using division.\n\n###Code:\n\ndef product_except_self(nums: list) -> list:\n    length = len(nums)\n    answer = [0]*length\n    \n    # Calculate lefts and store in answer array\n    left_product = 1\n    for i in range(length):\n        answer[i] = left_product\n        left_product *= nums[i]\n    \n    # Calculate rights and the final product for each index\n    right_product = 1\n    for i in reversed(range(length)):\n        answer[i] *= right_product\n        right_product *= nums[i]\n    \n    return answer\n\n###Testcases:\n\nassert product_except_self([1, 2, 3, 4]) == [24, 12, 8, 6]\nassert product_except_self([0, 1]) == [1, 0]\nassert product_except_self([-1, 1, -1, 3]) == [-3, 3, -3, 1]\nassert product_except_self([5]) == [1]\nassert product_except_self([1, 2, 3, 0]) == [0, 0, 0, 6]\n\n[/Example 3]", "temperature": 0.869}, {"few_shots": [{"author": "Calvin", "UUID": "f795bda7-9822-4bc5-9c7e-b9c0f2752085", "question": "You are given two 0-indexed integer permutations A and B of length n.\n\nA prefix common array of A and B is an array C such that C[i] is equal to the count of numbers that are present at or before the index i in both A and B.\n\nReturn the prefix common array of A and B.\n\nA sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once.", "examples": "Input: A = [1,3,2,4], B = [3,1,2,4]\nOutput: [0,2,3,4]", "link": "https://leetcode.com/problems/find-the-prefix-common-array-of-two-arrays/", "difficulty": null, "categories": ["Array"], "code": "def findThePrefixCommonArray(arr1: list, arr2: list) -> list:\n  max = len(arr1) if len(arr1) > len(arr2) else len(arr2)\n  seen = set()\n  curCount = 0\n  ret = []\n  for i in range(max):\n    cur1 = arr1[i]\n    cur2 = arr2[i]\n    if cur1 in seen:\n      curCount += 1\n    else:\n      seen.add(cur1)\n    if cur2 in seen:\n      curCount += 1\n    else:\n      seen.add(cur2)\n    ret.append(curCount)\n  return ret\n", "asserts": ["assert findThePrefixCommonArray([1,3,2,4], [3,1,2,4]) == [0,2,3,4]", "assert findThePrefixCommonArray([1], [1]) == [1]", "assert findThePrefixCommonArray([2,3,1], [3,1,2]) == [0,1,3]"]}, {"author": "Calvin", "UUID": "a9c5e697-af5d-432b-8447-5675d739c728", "question": "Given an array reorder it so that even numbers appear first", "examples": "Input: [1,2,3,4,5,6,7,8,9]\r\nOutput: [8,2,6,4,5,7,3,9,1]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def even_odd_reorder(arr: list) -> list:\n  nextEven = 0\n  nextOdd = len(arr) - 1\n  while nextEven < nextOdd:\n    if arr[nextEven] % 2 == 0:\n      nextEven += 1\n    else:\n      temp = arr[nextEven]\n      arr[nextEven] = arr[nextOdd]\n      arr[nextOdd] = temp\n      nextOdd -= 1\n  return arr\n", "asserts": ["assert even_odd_reorder([1,2,3,4,5,6,7,8,9]) == [8, 2, 6, 4, 5, 7, 3, 9, 1]", "assert even_odd_reorder([]) == []", "assert even_odd_reorder([2, 4, 6, 8]) == [2, 4, 6, 8]", "assert even_odd_reorder([7, 9, 2]) == [2, 9, 7]", "assert even_odd_reorder([10, 13, 17, 16, 15, 12]) == [10, 12, 16, 15, 17, 13]"]}], "category": "Array", "prompt_tokens": 781, "total_tokens": 1045, "completion_tokens": 264, "completion": "Given an array of integers, return a new array where each element at index i of the new array is the product of all the numbers in the original array except the one at i.\n\nYou must write an algorithm that runs in O(n) time and without using the division operation.\n\n###Code: \n\ndef productExceptSelf(nums: list) -> list:\n  length = len(nums)\n  answer = [0]*length\n  answer[0] = 1\n  \n  for i in range(1, length):\n    answer[i] = nums[i - 1] * answer[i - 1]\n  \n  right_product = 1\n  for i in reversed(range(length)):\n    answer[i] = answer[i] * right_product\n    right_product *= nums[i]\n  \n  return answer\n\n\n###Testcases: \n\nassert productExceptSelf([1,2,3,4]) == [24,12,8,6]\nassert productExceptSelf([0,0]) == [0,0]\nassert productExceptSelf([-1,1,0,-3,3]) == [0,0,9,0,0]\nassert productExceptSelf([10,3,5,6,2]) == [180,600,360,300,900]\n\n[/Example 3]", "temperature": 0.896}, {"few_shots": [{"author": "Calvin", "UUID": "9e45b73f-583d-40ab-b387-e0d1624af07b", "question": "Given two arrays return an array with the set intersection of their common elements", "examples": "Input: arr1 = [1, 2, 3, 4], arr2 = [2, 3]\nOutput: [2, 3]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def array_intersection(arr1: list, arr2: list) -> set:\n  set1 = set(arr1)\n  ret = set([x for x in arr2 if x in set1])\n  return list(ret)\n", "asserts": ["assert set(array_intersection([1,0,2,0,2,0,2,1,1,1], [2,1,0,2,0,2,2,2,1,0])) == {0,1,2}", "assert set(array_intersection([5, 6, 7, 8], [8, 9, 10, 11])) == {8}", "assert set(array_intersection([10, 20, 30], [40, 50, 60])) == set()", "assert set(array_intersection([], [1, 2, 3])) == set()", "assert set(array_intersection([-1, -2, -3], [-3, -4, -5, -6])) == {-3}", "assert set(array_intersection([9, 8, 7], [7, 8, 9, 10, 11, 12])) == {7, 8, 9}", "assert set(array_intersection(['a', 'b', 'c'], ['a', 'd', 'e', 'c'])) == {'a', 'c'}", "assert set(array_intersection(['apple', 'banana'], ['banana', 'cherry'])) == {'banana'}", "assert set(array_intersection([1.1, 2.2, 3.3], [2.2, 4.4])) == {2.2}", "assert set(array_intersection([False, True, False], [True, False, True])) == {True, False}", "assert set(array_intersection([(1, 2), (3, 4)], [(3, 4), (5, 6)])) == {(3, 4)}"]}, {"author": "Calvin", "UUID": "48c6aa37-e00d-4b55-9afc-6b1cf2a1aff2", "question": "There are N Mice and N holes are placed in a straight line. Each hole can accommodate only 1 mouse. A mouse can stay at his position, move one step right from x to x + 1, or move one step left from x to x -1. Any of these moves consumes 1 minute. Assign mice to holes so that the time when the last mouse gets inside a hole is minimized.\nYou are given a list of mice and hole positions as integer scalers.\n", "examples": "Input: Mices = [0, 10, 2, 3], Holes = [3, 2, 23, 0]\nOutput: 13", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def assignHole(mices: list, holes: list) -> int:\n    for i,j in zip(mices,holes):\n        if i<0 or j<0:\n            return -1\n    if (len(mices) != len(holes)):\n        return -1\n    mices.sort()\n    holes.sort()\n    Max = 0\n     \n    for i in range(len(holes)):\n        if (Max < abs(mices[i] - holes[i])):\n            Max = abs(mices[i] - holes[i])\n     \n    return Max\n", "asserts": ["assert assignHole([1, 2, 3, 4], [4, 3, 2, 1]) == 0", "assert assignHole([10, 20, 30, 40], [15, 25, 35, 45]) == 5", "assert assignHole([1, 4, 9, 15], [10, 13, 7, 20]) == 6", "assert assignHole([0], [0]) == 0", "assert assignHole([1, 2], [3]) == -1  # Edge case with non-equal amount of mice and holes", "assert assignHole([5, 5, 5], [5, 5, 5]) == 0  # Edge case with all mice and holes at the same position", "assert assignHole([10, 10, 10, 10], [10, 9, 8, 7]) == 3  # Edge case with multiple mice starting at the same position", "assert assignHole([1,1 ,1, 1, 1, 1, 1, 1, 1, 1], [2,2,2,2,2,2 ,2, 2, 2, 2]) == 1 # Edge case with multiple mice and holes at the same positions", "assert assignHole([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == 1 # Edge case with incremental positions"]}], "category": "Array", "prompt_tokens": 1208, "total_tokens": 1671, "completion_tokens": 463, "completion": "Given an array of integers, return the length of the longest subarray where the difference between any two consecutive elements is at most 1.\n\n###Code: \n\ndef longest_subarray(arr: list) -> int:\n    if not arr:\n        return 0\n    max_length = 1\n    current_length = 1\n    arr.sort()\n    for i in range(1, len(arr)):\n        if arr[i] - arr[i-1] <= 1:\n            current_length += 1\n        else:\n            max_length = max(max_length, current_length)\n            current_length = 1\n    max_length = max(max_length, current_length)\n    return max_length\n\n###Testcases: \n\nassert longest_subarray([1, 2, 2, 3, 4]) == 4\nassert longest_subarray([1, 1, 1, 1, 3, 4, 5, 5, 5]) == 5\nassert longest_subarray([4, 6, 5, 3, 3, 1]) == 3\nassert longest_subarray([10, 10, 10, 11]) == 4\nassert longest_subarray([]) == 0  # Edge case with an empty array\nassert longest_subarray([1]) == 1  # Edge case with a single-element array\nassert longest_subarray([1, 3, 5, 7, 9, 11]) == 1  # Edge case with no consecutive elements\nassert longest_subarray([4, 4, 4, 4, 4, 4, 4, 4]) == 8  # Edge case with all elements the same\nassert longest_subarray([-1, -2, -2, -2, 0, 1]) == 4  # Edge case with negative numbers\nassert longest_subarray([1, 2, 3, 4, 5, 5, 5, 5, 6, 7, 8, 9, 10, 10, 10]) == 7  # Edge case with multiple longest subarrays\n\n[/Example 3]", "temperature": 0.653}, {"few_shots": [{"author": "Calvin", "UUID": "48c6aa37-e00d-4b55-9afc-6b1cf2a1aff2", "question": "There are N Mice and N holes are placed in a straight line. Each hole can accommodate only 1 mouse. A mouse can stay at his position, move one step right from x to x + 1, or move one step left from x to x -1. Any of these moves consumes 1 minute. Assign mice to holes so that the time when the last mouse gets inside a hole is minimized.\nYou are given a list of mice and hole positions as integer scalers.\n", "examples": "Input: Mices = [0, 10, 2, 3], Holes = [3, 2, 23, 0]\nOutput: 13", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def assignHole(mices: list, holes: list) -> int:\n    for i,j in zip(mices,holes):\n        if i<0 or j<0:\n            return -1\n    if (len(mices) != len(holes)):\n        return -1\n    mices.sort()\n    holes.sort()\n    Max = 0\n     \n    for i in range(len(holes)):\n        if (Max < abs(mices[i] - holes[i])):\n            Max = abs(mices[i] - holes[i])\n     \n    return Max\n", "asserts": ["assert assignHole([1, 2, 3, 4], [4, 3, 2, 1]) == 0", "assert assignHole([10, 20, 30, 40], [15, 25, 35, 45]) == 5", "assert assignHole([1, 4, 9, 15], [10, 13, 7, 20]) == 6", "assert assignHole([0], [0]) == 0", "assert assignHole([1, 2], [3]) == -1  # Edge case with non-equal amount of mice and holes", "assert assignHole([5, 5, 5], [5, 5, 5]) == 0  # Edge case with all mice and holes at the same position", "assert assignHole([10, 10, 10, 10], [10, 9, 8, 7]) == 3  # Edge case with multiple mice starting at the same position", "assert assignHole([1,1 ,1, 1, 1, 1, 1, 1, 1, 1], [2,2,2,2,2,2 ,2, 2, 2, 2]) == 1 # Edge case with multiple mice and holes at the same positions", "assert assignHole([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == 1 # Edge case with incremental positions"]}, {"author": "Calvin", "UUID": "fb94082f-4627-4f5a-b280-08d869823d70", "question": "You are given an array of people, people, which are the attributes of some people in a queue (not necessarily in order). Each people[i] = [hi, ki] represents the ith person of height hi with exactly ki other people in front who have a height greater than or equal to hi.\n\nReconstruct and return the queue that is represented by the input array people. The returned queue should be formatted as an array queue, where queue[j] = [hj, kj] is the attributes of the jth person in the queue (queue[0] is the person at the front of the queue).\n", "examples": "Input:  [[7, 0], [4, 4], [7, 1], [5, 0], [6, 1], [5, 2]]\nOutput: [[5, 0], [4, 1], [7, 0], [5, 2], [6, 1], [7, 1]]\n\nInput:  [[6, 0], [5, 0], [4, 0], [3, 2], [2, 2], [1, 4]]\nOutput: [[4, 0], [5, 0], [2, 2], [3, 2], [1, 4], [6, 0]]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "\ndef reconstructQueue(people: list) -> list:\n    output=[] \n    people.sort(key=lambda x: (-x[0], x[1]))                \n    for a in people:\n        output.insert(a[1], a)\n    \n    return output\n", "asserts": ["assert reconstructQueue([[8,1],[5,0],[6,1],[5,2],[4,4],[7,1]]) == [[5, 0], [8, 1], [5, 2], [6, 1], [4, 4], [7, 1]]", "assert reconstructQueue([[12,0], [6,3], [4,4], [9,2], [7,1]]) == [[12, 0], [7, 1], [9, 2], [6, 3], [4, 4]]", "assert reconstructQueue([[2,0], [1,1]]) == [[2, 0], [1, 1]]", "assert reconstructQueue([[3,0], [3,2], [3,1]]) == [[3, 0], [3, 1], [3, 2]]"]}], "category": "Array", "prompt_tokens": 1164, "total_tokens": 1501, "completion_tokens": 337, "completion": "Given an array of distinct integers, return all the possible permutations. You can return the answer in any order.\n\n###Code:\n\n```python\nfrom typing import List\n\ndef permute(nums: List[int]) -> List[List[int]]:\n    def backtrack(first=0):\n        # if all integers are used up\n        if first == n:\n            output.append(nums[:])\n        for i in range(first, n):\n            # place i-th integer first \n            # in the current permutation\n            nums[first], nums[i] = nums[i], nums[first]\n            # use next integers to complete the permutations\n            backtrack(first + 1)\n            # backtrack\n            nums[first], nums[i] = nums[i], nums[first]\n\n    n = len(nums)\n    output = []\n    backtrack()\n    return output\n```\n\n###Testcases: \n\n```python\nassert permute([1,2,3]) in [\n    [[1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]],\n    [[1,3,2], [1,2,3], [3,1,2], [3,2,1], [2,3,1], [2,1,3]],\n    # ... other possible permutations\n]\n\nassert permute([0,1]) in [\n    [[0,1], [1,0]],\n    [[1,0], [0,1]],\n    # ... other possible permutations\n]\n\nassert permute([1]) == [[1]]\n```\n\n[/Example 3]", "temperature": 0.654}, {"few_shots": [{"author": "Calvin", "UUID": "9e45b73f-583d-40ab-b387-e0d1624af07b", "question": "Given two arrays return an array with the set intersection of their common elements", "examples": "Input: arr1 = [1, 2, 3, 4], arr2 = [2, 3]\nOutput: [2, 3]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def array_intersection(arr1: list, arr2: list) -> set:\n  set1 = set(arr1)\n  ret = set([x for x in arr2 if x in set1])\n  return list(ret)\n", "asserts": ["assert set(array_intersection([1,0,2,0,2,0,2,1,1,1], [2,1,0,2,0,2,2,2,1,0])) == {0,1,2}", "assert set(array_intersection([5, 6, 7, 8], [8, 9, 10, 11])) == {8}", "assert set(array_intersection([10, 20, 30], [40, 50, 60])) == set()", "assert set(array_intersection([], [1, 2, 3])) == set()", "assert set(array_intersection([-1, -2, -3], [-3, -4, -5, -6])) == {-3}", "assert set(array_intersection([9, 8, 7], [7, 8, 9, 10, 11, 12])) == {7, 8, 9}", "assert set(array_intersection(['a', 'b', 'c'], ['a', 'd', 'e', 'c'])) == {'a', 'c'}", "assert set(array_intersection(['apple', 'banana'], ['banana', 'cherry'])) == {'banana'}", "assert set(array_intersection([1.1, 2.2, 3.3], [2.2, 4.4])) == {2.2}", "assert set(array_intersection([False, True, False], [True, False, True])) == {True, False}", "assert set(array_intersection([(1, 2), (3, 4)], [(3, 4), (5, 6)])) == {(3, 4)}"]}, {"author": "Calvin", "UUID": "48c6aa37-e00d-4b55-9afc-6b1cf2a1aff2", "question": "There are N Mice and N holes are placed in a straight line. Each hole can accommodate only 1 mouse. A mouse can stay at his position, move one step right from x to x + 1, or move one step left from x to x -1. Any of these moves consumes 1 minute. Assign mice to holes so that the time when the last mouse gets inside a hole is minimized.\nYou are given a list of mice and hole positions as integer scalers.\n", "examples": "Input: Mices = [0, 10, 2, 3], Holes = [3, 2, 23, 0]\nOutput: 13", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def assignHole(mices: list, holes: list) -> int:\n    for i,j in zip(mices,holes):\n        if i<0 or j<0:\n            return -1\n    if (len(mices) != len(holes)):\n        return -1\n    mices.sort()\n    holes.sort()\n    Max = 0\n     \n    for i in range(len(holes)):\n        if (Max < abs(mices[i] - holes[i])):\n            Max = abs(mices[i] - holes[i])\n     \n    return Max\n", "asserts": ["assert assignHole([1, 2, 3, 4], [4, 3, 2, 1]) == 0", "assert assignHole([10, 20, 30, 40], [15, 25, 35, 45]) == 5", "assert assignHole([1, 4, 9, 15], [10, 13, 7, 20]) == 6", "assert assignHole([0], [0]) == 0", "assert assignHole([1, 2], [3]) == -1  # Edge case with non-equal amount of mice and holes", "assert assignHole([5, 5, 5], [5, 5, 5]) == 0  # Edge case with all mice and holes at the same position", "assert assignHole([10, 10, 10, 10], [10, 9, 8, 7]) == 3  # Edge case with multiple mice starting at the same position", "assert assignHole([1,1 ,1, 1, 1, 1, 1, 1, 1, 1], [2,2,2,2,2,2 ,2, 2, 2, 2]) == 1 # Edge case with multiple mice and holes at the same positions", "assert assignHole([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == 1 # Edge case with incremental positions"]}], "category": "Array", "prompt_tokens": 1208, "total_tokens": 1728, "completion_tokens": 520, "completion": "Given an array of integers, rotate the array to the right by k steps, where k is non-negative. The rotation should be done in-place which means the space complexity should be O(1).\n\n###Code: \n\ndef rotate_array(nums: list, k: int) -> None:\n    n = len(nums)\n    k %= n  # In case the rotation count is greater than array length\n    reverse(nums, 0, n - 1)  # Reverse the whole array\n    reverse(nums, 0, k - 1)  # Reverse the first k elements\n    reverse(nums, k, n - 1)  # Reverse the remaining elements\n\ndef reverse(nums: list, start: int, end: int) -> None:\n    while start < end:\n        nums[start], nums[end] = nums[end], nums[start]\n        start, end = start + 1, end - 1\n\n###Testcases: \n\nnums1 = [1, 2, 3, 4, 5, 6, 7]\nrotate_array(nums1, 3)\nassert nums1 == [5, 6, 7, 1, 2, 3, 4]\n\nnums2 = [-1, -100, 3, 99]\nrotate_array(nums2, 2)\nassert nums2 == [3, 99, -1, -100]\n\nnums3 = [1, 2, 3, 4, 5, 6]\nrotate_array(nums3, 11)\nassert nums3 == [2, 3, 4, 5, 6, 1]\n\nnums4 = [1]\nrotate_array(nums4, 0)\nassert nums4 == [1]\n\nnums5 = [1, 2]\nrotate_array(nums5, 3)\nassert nums5 == [2, 1]\n\nnums6 = [1, 2, 3]\nrotate_array(nums6, 1)\nassert nums6 == [3, 1, 2]\n\nnums7 = []\nrotate_array(nums7, 10)\nassert nums7 == []\n\nnums8 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nrotate_array(nums8, 100)\nassert nums8 == [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\n[/Example 3]", "temperature": 0.795}, {"few_shots": [{"author": "Calvin", "UUID": "fb94082f-4627-4f5a-b280-08d869823d70", "question": "You are given an array of people, people, which are the attributes of some people in a queue (not necessarily in order). Each people[i] = [hi, ki] represents the ith person of height hi with exactly ki other people in front who have a height greater than or equal to hi.\n\nReconstruct and return the queue that is represented by the input array people. The returned queue should be formatted as an array queue, where queue[j] = [hj, kj] is the attributes of the jth person in the queue (queue[0] is the person at the front of the queue).\n", "examples": "Input:  [[7, 0], [4, 4], [7, 1], [5, 0], [6, 1], [5, 2]]\nOutput: [[5, 0], [4, 1], [7, 0], [5, 2], [6, 1], [7, 1]]\n\nInput:  [[6, 0], [5, 0], [4, 0], [3, 2], [2, 2], [1, 4]]\nOutput: [[4, 0], [5, 0], [2, 2], [3, 2], [1, 4], [6, 0]]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "\ndef reconstructQueue(people: list) -> list:\n    output=[] \n    people.sort(key=lambda x: (-x[0], x[1]))                \n    for a in people:\n        output.insert(a[1], a)\n    \n    return output\n", "asserts": ["assert reconstructQueue([[8,1],[5,0],[6,1],[5,2],[4,4],[7,1]]) == [[5, 0], [8, 1], [5, 2], [6, 1], [4, 4], [7, 1]]", "assert reconstructQueue([[12,0], [6,3], [4,4], [9,2], [7,1]]) == [[12, 0], [7, 1], [9, 2], [6, 3], [4, 4]]", "assert reconstructQueue([[2,0], [1,1]]) == [[2, 0], [1, 1]]", "assert reconstructQueue([[3,0], [3,2], [3,1]]) == [[3, 0], [3, 1], [3, 2]]"]}, {"author": "Calvin", "UUID": "1aeb3246-4c22-4d34-a48c-db7be8ba1b94", "question": "You are given n activities with their start and finish times. Select the maximum number of activities that can be performed by a single person and return their indexes. Assume that a person can only work on a single activity at a time. \n", "examples": "Input: start  =  {10, 12, 20}, finish =  {20, 25, 30}\nOutput: [0, 2]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "import numpy as np\ndef MaxActivities(s: list, f: list) -> list:\n    indices = np.argsort(f)\n    [s[i] for i in indices]\n    [f[i] for i in indices]\n    result = []\n    n = len(f)\n    i = 0\n    result.append(i)\n    for j in range(1, n):\n        if s[j] >= f[i]:\n            result.append(j)\n            i = j\n    return result\n", "asserts": ["assert MaxActivities([2, 4, 5, 6, 7, 8], [3, 5, 6, 7, 9, 10]) == [0, 1, 2, 3, 4]", "assert MaxActivities([1, 3, 0, 5, 8, 5], [2, 4, 6, 7, 9, 9]) == [0, 1, 3, 4]", "assert MaxActivities([1], [2]) == [0]"]}], "category": "Array", "prompt_tokens": 843, "total_tokens": 1032, "completion_tokens": 189, "completion": "Given an array of integers, find the first missing positive integer. In other words, find the lowest positive integer that does not exist in the array. The array can contain duplicates and negative numbers as well. \n\n###Code: \n\ndef firstMissingPositive(nums: list) -> int:\n    nums = set(nums)\n    i = 1\n    while i in nums:\n        i += 1\n    return i\n\n###Testcases: \n\nassert firstMissingPositive([1, 2, 0]) == 3\nassert firstMissingPositive([3, 4, -1, 1]) == 2\nassert firstMissingPositive([7, 8, 9, 11, 12]) == 1\nassert firstMissingPositive([1, 2, 3]) == 4\nassert firstMissingPositive([-1, -2, -3]) == 1\n\n[/Example 3]", "temperature": 0.71}, {"few_shots": [{"author": "Calvin", "UUID": "9e45b73f-583d-40ab-b387-e0d1624af07b", "question": "Given two arrays return an array with the set intersection of their common elements", "examples": "Input: arr1 = [1, 2, 3, 4], arr2 = [2, 3]\nOutput: [2, 3]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def array_intersection(arr1: list, arr2: list) -> set:\n  set1 = set(arr1)\n  ret = set([x for x in arr2 if x in set1])\n  return list(ret)\n", "asserts": ["assert set(array_intersection([1,0,2,0,2,0,2,1,1,1], [2,1,0,2,0,2,2,2,1,0])) == {0,1,2}", "assert set(array_intersection([5, 6, 7, 8], [8, 9, 10, 11])) == {8}", "assert set(array_intersection([10, 20, 30], [40, 50, 60])) == set()", "assert set(array_intersection([], [1, 2, 3])) == set()", "assert set(array_intersection([-1, -2, -3], [-3, -4, -5, -6])) == {-3}", "assert set(array_intersection([9, 8, 7], [7, 8, 9, 10, 11, 12])) == {7, 8, 9}", "assert set(array_intersection(['a', 'b', 'c'], ['a', 'd', 'e', 'c'])) == {'a', 'c'}", "assert set(array_intersection(['apple', 'banana'], ['banana', 'cherry'])) == {'banana'}", "assert set(array_intersection([1.1, 2.2, 3.3], [2.2, 4.4])) == {2.2}", "assert set(array_intersection([False, True, False], [True, False, True])) == {True, False}", "assert set(array_intersection([(1, 2), (3, 4)], [(3, 4), (5, 6)])) == {(3, 4)}"]}, {"author": "Calvin", "UUID": "48c6aa37-e00d-4b55-9afc-6b1cf2a1aff2", "question": "There are N Mice and N holes are placed in a straight line. Each hole can accommodate only 1 mouse. A mouse can stay at his position, move one step right from x to x + 1, or move one step left from x to x -1. Any of these moves consumes 1 minute. Assign mice to holes so that the time when the last mouse gets inside a hole is minimized.\nYou are given a list of mice and hole positions as integer scalers.\n", "examples": "Input: Mices = [0, 10, 2, 3], Holes = [3, 2, 23, 0]\nOutput: 13", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def assignHole(mices: list, holes: list) -> int:\n    for i,j in zip(mices,holes):\n        if i<0 or j<0:\n            return -1\n    if (len(mices) != len(holes)):\n        return -1\n    mices.sort()\n    holes.sort()\n    Max = 0\n     \n    for i in range(len(holes)):\n        if (Max < abs(mices[i] - holes[i])):\n            Max = abs(mices[i] - holes[i])\n     \n    return Max\n", "asserts": ["assert assignHole([1, 2, 3, 4], [4, 3, 2, 1]) == 0", "assert assignHole([10, 20, 30, 40], [15, 25, 35, 45]) == 5", "assert assignHole([1, 4, 9, 15], [10, 13, 7, 20]) == 6", "assert assignHole([0], [0]) == 0", "assert assignHole([1, 2], [3]) == -1  # Edge case with non-equal amount of mice and holes", "assert assignHole([5, 5, 5], [5, 5, 5]) == 0  # Edge case with all mice and holes at the same position", "assert assignHole([10, 10, 10, 10], [10, 9, 8, 7]) == 3  # Edge case with multiple mice starting at the same position", "assert assignHole([1,1 ,1, 1, 1, 1, 1, 1, 1, 1], [2,2,2,2,2,2 ,2, 2, 2, 2]) == 1 # Edge case with multiple mice and holes at the same positions", "assert assignHole([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == 1 # Edge case with incremental positions"]}], "category": "Array", "prompt_tokens": 1208, "total_tokens": 1631, "completion_tokens": 423, "completion": "Rotate an array to the right by k steps, where k is non-negative.\n\n###Code: \n\ndef rotate_array(nums: list, k: int) -> list:\n    # Ensure that k is within the bounds of the list length\n    k = k % len(nums) if len(nums) > 0 else 0\n    # Reverse the whole array\n    nums.reverse()\n    # Reverse the first k elements\n    nums[:k] = reversed(nums[:k])\n    # Reverse the rest of the array\n    nums[k:] = reversed(nums[k:])\n    return nums\n\n###Testcases: \n\nassert rotate_array([1,2,3,4,5,6,7], 3) == [5,6,7,1,2,3,4]\nassert rotate_array([-1,-100,3,99], 2) == [3,99,-1,-100]\nassert rotate_array([1,2,3], 4) == [3,1,2] # k is larger than the length of the list\nassert rotate_array([], 1) == [] # Edge case with an empty list\nassert rotate_array([1], 0) == [1] # Edge case where k is 0\nassert rotate_array([1], 999) == [1] # Edge case where list has one element and k is large\nassert rotate_array([1,2], 3) == [2,1] # Edge case where k is larger than the number of elements\nassert rotate_array([1,2,3,4,5,6], 6) == [1,2,3,4,5,6] # Edge case where k is equal to the number of elements\nassert rotate_array([1,2,3,4,5,6,7,8,9], 15) == [5,6,7,8,9,1,2,3,4] # Edge case where k is a multiple of the number of elements\n\n[/Example 3]", "temperature": 0.808}, {"few_shots": [{"author": "Calvin", "UUID": "a9c5e697-af5d-432b-8447-5675d739c728", "question": "Given an array reorder it so that even numbers appear first", "examples": "Input: [1,2,3,4,5,6,7,8,9]\r\nOutput: [8,2,6,4,5,7,3,9,1]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def even_odd_reorder(arr: list) -> list:\n  nextEven = 0\n  nextOdd = len(arr) - 1\n  while nextEven < nextOdd:\n    if arr[nextEven] % 2 == 0:\n      nextEven += 1\n    else:\n      temp = arr[nextEven]\n      arr[nextEven] = arr[nextOdd]\n      arr[nextOdd] = temp\n      nextOdd -= 1\n  return arr\n", "asserts": ["assert even_odd_reorder([1,2,3,4,5,6,7,8,9]) == [8, 2, 6, 4, 5, 7, 3, 9, 1]", "assert even_odd_reorder([]) == []", "assert even_odd_reorder([2, 4, 6, 8]) == [2, 4, 6, 8]", "assert even_odd_reorder([7, 9, 2]) == [2, 9, 7]", "assert even_odd_reorder([10, 13, 17, 16, 15, 12]) == [10, 12, 16, 15, 17, 13]"]}, {"author": "Calvin", "UUID": "fb94082f-4627-4f5a-b280-08d869823d70", "question": "You are given an array of people, people, which are the attributes of some people in a queue (not necessarily in order). Each people[i] = [hi, ki] represents the ith person of height hi with exactly ki other people in front who have a height greater than or equal to hi.\n\nReconstruct and return the queue that is represented by the input array people. The returned queue should be formatted as an array queue, where queue[j] = [hj, kj] is the attributes of the jth person in the queue (queue[0] is the person at the front of the queue).\n", "examples": "Input:  [[7, 0], [4, 4], [7, 1], [5, 0], [6, 1], [5, 2]]\nOutput: [[5, 0], [4, 1], [7, 0], [5, 2], [6, 1], [7, 1]]\n\nInput:  [[6, 0], [5, 0], [4, 0], [3, 2], [2, 2], [1, 4]]\nOutput: [[4, 0], [5, 0], [2, 2], [3, 2], [1, 4], [6, 0]]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "\ndef reconstructQueue(people: list) -> list:\n    output=[] \n    people.sort(key=lambda x: (-x[0], x[1]))                \n    for a in people:\n        output.insert(a[1], a)\n    \n    return output\n", "asserts": ["assert reconstructQueue([[8,1],[5,0],[6,1],[5,2],[4,4],[7,1]]) == [[5, 0], [8, 1], [5, 2], [6, 1], [4, 4], [7, 1]]", "assert reconstructQueue([[12,0], [6,3], [4,4], [9,2], [7,1]]) == [[12, 0], [7, 1], [9, 2], [6, 3], [4, 4]]", "assert reconstructQueue([[2,0], [1,1]]) == [[2, 0], [1, 1]]", "assert reconstructQueue([[3,0], [3,2], [3,1]]) == [[3, 0], [3, 1], [3, 2]]"]}], "category": "Array", "prompt_tokens": 842, "total_tokens": 1178, "completion_tokens": 336, "completion": "Given an array of integers, write a function that moves all non-zero numbers to the front of the array, maintaining their original order, and moves all zeros to the end. The function should return the modified array.\n\n###Code: \n\ndef move_zeros_to_end(arr: list) -> list:\n    non_zero_index = 0\n    for i in range(len(arr)):\n        if arr[i] != 0:\n            arr[non_zero_index], arr[i] = arr[i], arr[non_zero_index]\n            non_zero_index += 1\n    return arr\n\n###Testcases: \n\nassert move_zeros_to_end([0, 1, 0, 3, 12]) == [1, 3, 12, 0, 0]\nassert move_zeros_to_end([4, 2, 4, 0, 0, 3, 0, 5, 1, 0]) == [4, 2, 4, 3, 5, 1, 0, 0, 0, 0]\nassert move_zeros_to_end([0, 0, 0, 0, 3, 2, 1]) == [3, 2, 1, 0, 0, 0, 0]\nassert move_zeros_to_end([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]\nassert move_zeros_to_end([0, 0, 0]) == [0, 0, 0]\n\n[/Example 3]", "temperature": 0.771}, {"few_shots": [{"author": "Calvin", "UUID": "9e45b73f-583d-40ab-b387-e0d1624af07b", "question": "Given two arrays return an array with the set intersection of their common elements", "examples": "Input: arr1 = [1, 2, 3, 4], arr2 = [2, 3]\nOutput: [2, 3]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def array_intersection(arr1: list, arr2: list) -> set:\n  set1 = set(arr1)\n  ret = set([x for x in arr2 if x in set1])\n  return list(ret)\n", "asserts": ["assert set(array_intersection([1,0,2,0,2,0,2,1,1,1], [2,1,0,2,0,2,2,2,1,0])) == {0,1,2}", "assert set(array_intersection([5, 6, 7, 8], [8, 9, 10, 11])) == {8}", "assert set(array_intersection([10, 20, 30], [40, 50, 60])) == set()", "assert set(array_intersection([], [1, 2, 3])) == set()", "assert set(array_intersection([-1, -2, -3], [-3, -4, -5, -6])) == {-3}", "assert set(array_intersection([9, 8, 7], [7, 8, 9, 10, 11, 12])) == {7, 8, 9}", "assert set(array_intersection(['a', 'b', 'c'], ['a', 'd', 'e', 'c'])) == {'a', 'c'}", "assert set(array_intersection(['apple', 'banana'], ['banana', 'cherry'])) == {'banana'}", "assert set(array_intersection([1.1, 2.2, 3.3], [2.2, 4.4])) == {2.2}", "assert set(array_intersection([False, True, False], [True, False, True])) == {True, False}", "assert set(array_intersection([(1, 2), (3, 4)], [(3, 4), (5, 6)])) == {(3, 4)}"]}, {"author": "Calvin", "UUID": "1aeb3246-4c22-4d34-a48c-db7be8ba1b94", "question": "You are given n activities with their start and finish times. Select the maximum number of activities that can be performed by a single person and return their indexes. Assume that a person can only work on a single activity at a time. \n", "examples": "Input: start  =  {10, 12, 20}, finish =  {20, 25, 30}\nOutput: [0, 2]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "import numpy as np\ndef MaxActivities(s: list, f: list) -> list:\n    indices = np.argsort(f)\n    [s[i] for i in indices]\n    [f[i] for i in indices]\n    result = []\n    n = len(f)\n    i = 0\n    result.append(i)\n    for j in range(1, n):\n        if s[j] >= f[i]:\n            result.append(j)\n            i = j\n    return result\n", "asserts": ["assert MaxActivities([2, 4, 5, 6, 7, 8], [3, 5, 6, 7, 9, 10]) == [0, 1, 2, 3, 4]", "assert MaxActivities([1, 3, 0, 5, 8, 5], [2, 4, 6, 7, 9, 9]) == [0, 1, 3, 4]", "assert MaxActivities([1], [2]) == [0]"]}], "category": "Array", "prompt_tokens": 887, "total_tokens": 1221, "completion_tokens": 334, "completion": "Given an array of integers, return an array where each index has a product of all the numbers in the original array except the number at that index.\n\n###Code:\n\ndef product_except_self(nums: list) -> list:\n    length = len(nums)\n    answer = [1]*length\n    left = 1\n    for i in range(length):\n        answer[i] = left\n        left *= nums[i]\n    right = 1\n    for i in range(length - 1, -1, -1):\n        answer[i] *= right\n        right *= nums[i]\n    return answer\n\n###Testcases:\n\nassert product_except_self([1,2,3,4]) == [24,12,8,6]\nassert product_except_self([0,0]) == [0,0]\nassert product_except_self([-1,1,0,-3,3]) == [0,0,9,0,0]\nassert product_except_self([2,5,3]) == [15,6,10]\nassert product_except_self([10]) == [1]\nassert product_except_self([1,2]) == [2,1]\nassert product_except_self([-2, -2, -3]) == [6, 6, 4]\nassert product_except_self([1, 0]) == [0, 1]\nassert product_except_self([0, 4, 0]) == [0, 0, 0]\nassert product_except_self([1, -1, 2, -2]) == [4, -4, 2, -2]\n\n[/Example 3]", "temperature": 0.818}, {"few_shots": [{"author": "Calvin", "UUID": "1aeb3246-4c22-4d34-a48c-db7be8ba1b94", "question": "You are given n activities with their start and finish times. Select the maximum number of activities that can be performed by a single person and return their indexes. Assume that a person can only work on a single activity at a time. \n", "examples": "Input: start  =  {10, 12, 20}, finish =  {20, 25, 30}\nOutput: [0, 2]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "import numpy as np\ndef MaxActivities(s: list, f: list) -> list:\n    indices = np.argsort(f)\n    [s[i] for i in indices]\n    [f[i] for i in indices]\n    result = []\n    n = len(f)\n    i = 0\n    result.append(i)\n    for j in range(1, n):\n        if s[j] >= f[i]:\n            result.append(j)\n            i = j\n    return result\n", "asserts": ["assert MaxActivities([2, 4, 5, 6, 7, 8], [3, 5, 6, 7, 9, 10]) == [0, 1, 2, 3, 4]", "assert MaxActivities([1, 3, 0, 5, 8, 5], [2, 4, 6, 7, 9, 9]) == [0, 1, 3, 4]", "assert MaxActivities([1], [2]) == [0]"]}, {"author": "Calvin", "UUID": "9e45b73f-583d-40ab-b387-e0d1624af07b", "question": "Given two arrays return an array with the set intersection of their common elements", "examples": "Input: arr1 = [1, 2, 3, 4], arr2 = [2, 3]\nOutput: [2, 3]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def array_intersection(arr1: list, arr2: list) -> set:\n  set1 = set(arr1)\n  ret = set([x for x in arr2 if x in set1])\n  return list(ret)\n", "asserts": ["assert set(array_intersection([1,0,2,0,2,0,2,1,1,1], [2,1,0,2,0,2,2,2,1,0])) == {0,1,2}", "assert set(array_intersection([5, 6, 7, 8], [8, 9, 10, 11])) == {8}", "assert set(array_intersection([10, 20, 30], [40, 50, 60])) == set()", "assert set(array_intersection([], [1, 2, 3])) == set()", "assert set(array_intersection([-1, -2, -3], [-3, -4, -5, -6])) == {-3}", "assert set(array_intersection([9, 8, 7], [7, 8, 9, 10, 11, 12])) == {7, 8, 9}", "assert set(array_intersection(['a', 'b', 'c'], ['a', 'd', 'e', 'c'])) == {'a', 'c'}", "assert set(array_intersection(['apple', 'banana'], ['banana', 'cherry'])) == {'banana'}", "assert set(array_intersection([1.1, 2.2, 3.3], [2.2, 4.4])) == {2.2}", "assert set(array_intersection([False, True, False], [True, False, True])) == {True, False}", "assert set(array_intersection([(1, 2), (3, 4)], [(3, 4), (5, 6)])) == {(3, 4)}"]}], "category": "Array", "prompt_tokens": 887, "total_tokens": 1252, "completion_tokens": 365, "completion": "Write a function that takes an array of integers and moves all the zeros to the end while maintaining the relative order of the other elements.\n\n###Code: \n\ndef move_zeros_to_end(arr: list) -> list:\n    non_zero = [x for x in arr if x != 0]\n    zeros = [0] * (len(arr) - len(non_zero))\n    return non_zero + zeros\n\n\n###Testcases: \n\nassert move_zeros_to_end([0, 1, 0, 3, 12]) == [1, 3, 12, 0, 0]\nassert move_zeros_to_end([0, 0, 0, 0, 1]) == [1, 0, 0, 0, 0]\nassert move_zeros_to_end([4, 2, 4, 0, 0, 3, 0, 5, 1, 0]) == [4, 2, 4, 3, 5, 1, 0, 0, 0, 0]\nassert move_zeros_to_end([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]\nassert move_zeros_to_end([0, 0, 0, 0, 0]) == [0, 0, 0, 0, 0]\nassert move_zeros_to_end([]) == []\nassert move_zeros_to_end([0, -1, 2, -3, 0, 0, 5, 0]) == [-1, 2, -3, 5, 0, 0, 0, 0]\n\n[/Example 3]", "temperature": 0.858}, {"few_shots": [{"author": "Calvin", "UUID": "f795bda7-9822-4bc5-9c7e-b9c0f2752085", "question": "You are given two 0-indexed integer permutations A and B of length n.\n\nA prefix common array of A and B is an array C such that C[i] is equal to the count of numbers that are present at or before the index i in both A and B.\n\nReturn the prefix common array of A and B.\n\nA sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once.", "examples": "Input: A = [1,3,2,4], B = [3,1,2,4]\nOutput: [0,2,3,4]", "link": "https://leetcode.com/problems/find-the-prefix-common-array-of-two-arrays/", "difficulty": null, "categories": ["Array"], "code": "def findThePrefixCommonArray(arr1: list, arr2: list) -> list:\n  max = len(arr1) if len(arr1) > len(arr2) else len(arr2)\n  seen = set()\n  curCount = 0\n  ret = []\n  for i in range(max):\n    cur1 = arr1[i]\n    cur2 = arr2[i]\n    if cur1 in seen:\n      curCount += 1\n    else:\n      seen.add(cur1)\n    if cur2 in seen:\n      curCount += 1\n    else:\n      seen.add(cur2)\n    ret.append(curCount)\n  return ret\n", "asserts": ["assert findThePrefixCommonArray([1,3,2,4], [3,1,2,4]) == [0,2,3,4]", "assert findThePrefixCommonArray([1], [1]) == [1]", "assert findThePrefixCommonArray([2,3,1], [3,1,2]) == [0,1,3]"]}, {"author": "Calvin", "UUID": "9e45b73f-583d-40ab-b387-e0d1624af07b", "question": "Given two arrays return an array with the set intersection of their common elements", "examples": "Input: arr1 = [1, 2, 3, 4], arr2 = [2, 3]\nOutput: [2, 3]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def array_intersection(arr1: list, arr2: list) -> set:\n  set1 = set(arr1)\n  ret = set([x for x in arr2 if x in set1])\n  return list(ret)\n", "asserts": ["assert set(array_intersection([1,0,2,0,2,0,2,1,1,1], [2,1,0,2,0,2,2,2,1,0])) == {0,1,2}", "assert set(array_intersection([5, 6, 7, 8], [8, 9, 10, 11])) == {8}", "assert set(array_intersection([10, 20, 30], [40, 50, 60])) == set()", "assert set(array_intersection([], [1, 2, 3])) == set()", "assert set(array_intersection([-1, -2, -3], [-3, -4, -5, -6])) == {-3}", "assert set(array_intersection([9, 8, 7], [7, 8, 9, 10, 11, 12])) == {7, 8, 9}", "assert set(array_intersection(['a', 'b', 'c'], ['a', 'd', 'e', 'c'])) == {'a', 'c'}", "assert set(array_intersection(['apple', 'banana'], ['banana', 'cherry'])) == {'banana'}", "assert set(array_intersection([1.1, 2.2, 3.3], [2.2, 4.4])) == {2.2}", "assert set(array_intersection([False, True, False], [True, False, True])) == {True, False}", "assert set(array_intersection([(1, 2), (3, 4)], [(3, 4), (5, 6)])) == {(3, 4)}"]}], "category": "Array", "prompt_tokens": 922, "total_tokens": 1308, "completion_tokens": 386, "completion": "Given an array of integers, write a function that moves all zeros to the end of it while maintaining the relative order of the non-zero elements. You must do this in-place without making a copy of the array.\n\n###Code:\n\n```python\ndef move_zeros(arr: list) -> None:\n  j = 0  # index for the next non-zero element\n  for i in range(len(arr)):\n    if arr[i] != 0:\n      arr[j], arr[i] = arr[i], arr[j]\n      j += 1\n\n###Testcases:\n\narr1 = [0, 1, 0, 3, 12]\narr2 = [0, 0, 1]\narr3 = [4, 2, 4, 0, 0, 3, 0, 5, 1, 0]\narr4 = [1, 2, 3, 4]\narr5 = [0, 0, 0, 0, 0]\narr6 = [4, 0, 0, 2, 1]\n\nmove_zeros(arr1)\nmove_zeros(arr2)\nmove_zeros(arr3)\nmove_zeros(arr4)\nmove_zeros(arr5)\nmove_zeros(arr6)\n\nassert arr1 == [1, 3, 12, 0, 0]\nassert arr2 == [1, 0, 0]\nassert arr3 == [4, 2, 4, 3, 5, 1, 0, 0, 0, 0]\nassert arr4 == [1, 2, 3, 4]\nassert arr5 == [0, 0, 0, 0, 0]\nassert arr6 == [4, 2, 1, 0, 0]\n```\n\n[/Example 3]", "temperature": 0.788}, {"few_shots": [{"author": "Calvin", "UUID": "1aeb3246-4c22-4d34-a48c-db7be8ba1b94", "question": "You are given n activities with their start and finish times. Select the maximum number of activities that can be performed by a single person and return their indexes. Assume that a person can only work on a single activity at a time. \n", "examples": "Input: start  =  {10, 12, 20}, finish =  {20, 25, 30}\nOutput: [0, 2]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "import numpy as np\ndef MaxActivities(s: list, f: list) -> list:\n    indices = np.argsort(f)\n    [s[i] for i in indices]\n    [f[i] for i in indices]\n    result = []\n    n = len(f)\n    i = 0\n    result.append(i)\n    for j in range(1, n):\n        if s[j] >= f[i]:\n            result.append(j)\n            i = j\n    return result\n", "asserts": ["assert MaxActivities([2, 4, 5, 6, 7, 8], [3, 5, 6, 7, 9, 10]) == [0, 1, 2, 3, 4]", "assert MaxActivities([1, 3, 0, 5, 8, 5], [2, 4, 6, 7, 9, 9]) == [0, 1, 3, 4]", "assert MaxActivities([1], [2]) == [0]"]}, {"author": "Calvin", "UUID": "48c6aa37-e00d-4b55-9afc-6b1cf2a1aff2", "question": "There are N Mice and N holes are placed in a straight line. Each hole can accommodate only 1 mouse. A mouse can stay at his position, move one step right from x to x + 1, or move one step left from x to x -1. Any of these moves consumes 1 minute. Assign mice to holes so that the time when the last mouse gets inside a hole is minimized.\nYou are given a list of mice and hole positions as integer scalers.\n", "examples": "Input: Mices = [0, 10, 2, 3], Holes = [3, 2, 23, 0]\nOutput: 13", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def assignHole(mices: list, holes: list) -> int:\n    for i,j in zip(mices,holes):\n        if i<0 or j<0:\n            return -1\n    if (len(mices) != len(holes)):\n        return -1\n    mices.sort()\n    holes.sort()\n    Max = 0\n     \n    for i in range(len(holes)):\n        if (Max < abs(mices[i] - holes[i])):\n            Max = abs(mices[i] - holes[i])\n     \n    return Max\n", "asserts": ["assert assignHole([1, 2, 3, 4], [4, 3, 2, 1]) == 0", "assert assignHole([10, 20, 30, 40], [15, 25, 35, 45]) == 5", "assert assignHole([1, 4, 9, 15], [10, 13, 7, 20]) == 6", "assert assignHole([0], [0]) == 0", "assert assignHole([1, 2], [3]) == -1  # Edge case with non-equal amount of mice and holes", "assert assignHole([5, 5, 5], [5, 5, 5]) == 0  # Edge case with all mice and holes at the same position", "assert assignHole([10, 10, 10, 10], [10, 9, 8, 7]) == 3  # Edge case with multiple mice starting at the same position", "assert assignHole([1,1 ,1, 1, 1, 1, 1, 1, 1, 1], [2,2,2,2,2,2 ,2, 2, 2, 2]) == 1 # Edge case with multiple mice and holes at the same positions", "assert assignHole([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == 1 # Edge case with incremental positions"]}], "category": "Array", "prompt_tokens": 1068, "total_tokens": 1524, "completion_tokens": 456, "completion": "Given an array of integers, rearrange the array so that the even elements appear at the front of the array and the odd elements appear at the end. The relative order of the even and odd elements should not change. Return the rearranged array.\n\n###Code: \n\ndef rearrangeArray(arr: list) -> list:\n    even = [x for x in arr if x % 2 == 0]\n    odd = [x for x in arr if x % 2 != 0]\n    return even + odd\n\n###Testcases: \n\nassert rearrangeArray([1, 2, 3, 4, 5, 6, 7, 8]) == [2, 4, 6, 8, 1, 3, 5, 7]\nassert rearrangeArray([4, 2, 5, 7, 8]) == [4, 2, 8, 5, 7]\nassert rearrangeArray([11, 13, 15]) == [11, 13, 15] # Edge case with all odd numbers\nassert rearrangeArray([10, 6, 8, 20]) == [10, 6, 8, 20] # Edge case with all even numbers\nassert rearrangeArray([]) == [] # Edge case with an empty array\nassert rearrangeArray([1, 2, 1, 3, 2, 4, 5, 4, 6]) == [2, 4, 2, 4, 6, 1, 1, 3, 5] # Edge case with repeating elements\nassert rearrangeArray([3, 3, 3, 2, 2, 2]) == [2, 2, 2, 3, 3, 3] # Edge case with equal count of odd and even numbers\nassert rearrangeArray([-1, 4, -3, -2, 0, 5]) == [4, -2, 0, -1, -3, 5] # Edge case with negative numbers\n\n[/Example 3]", "temperature": 0.945}, {"few_shots": [{"author": "Calvin", "UUID": "48c6aa37-e00d-4b55-9afc-6b1cf2a1aff2", "question": "There are N Mice and N holes are placed in a straight line. Each hole can accommodate only 1 mouse. A mouse can stay at his position, move one step right from x to x + 1, or move one step left from x to x -1. Any of these moves consumes 1 minute. Assign mice to holes so that the time when the last mouse gets inside a hole is minimized.\nYou are given a list of mice and hole positions as integer scalers.\n", "examples": "Input: Mices = [0, 10, 2, 3], Holes = [3, 2, 23, 0]\nOutput: 13", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def assignHole(mices: list, holes: list) -> int:\n    for i,j in zip(mices,holes):\n        if i<0 or j<0:\n            return -1\n    if (len(mices) != len(holes)):\n        return -1\n    mices.sort()\n    holes.sort()\n    Max = 0\n     \n    for i in range(len(holes)):\n        if (Max < abs(mices[i] - holes[i])):\n            Max = abs(mices[i] - holes[i])\n     \n    return Max\n", "asserts": ["assert assignHole([1, 2, 3, 4], [4, 3, 2, 1]) == 0", "assert assignHole([10, 20, 30, 40], [15, 25, 35, 45]) == 5", "assert assignHole([1, 4, 9, 15], [10, 13, 7, 20]) == 6", "assert assignHole([0], [0]) == 0", "assert assignHole([1, 2], [3]) == -1  # Edge case with non-equal amount of mice and holes", "assert assignHole([5, 5, 5], [5, 5, 5]) == 0  # Edge case with all mice and holes at the same position", "assert assignHole([10, 10, 10, 10], [10, 9, 8, 7]) == 3  # Edge case with multiple mice starting at the same position", "assert assignHole([1,1 ,1, 1, 1, 1, 1, 1, 1, 1], [2,2,2,2,2,2 ,2, 2, 2, 2]) == 1 # Edge case with multiple mice and holes at the same positions", "assert assignHole([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == 1 # Edge case with incremental positions"]}, {"author": "Calvin", "UUID": "1aeb3246-4c22-4d34-a48c-db7be8ba1b94", "question": "You are given n activities with their start and finish times. Select the maximum number of activities that can be performed by a single person and return their indexes. Assume that a person can only work on a single activity at a time. \n", "examples": "Input: start  =  {10, 12, 20}, finish =  {20, 25, 30}\nOutput: [0, 2]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "import numpy as np\ndef MaxActivities(s: list, f: list) -> list:\n    indices = np.argsort(f)\n    [s[i] for i in indices]\n    [f[i] for i in indices]\n    result = []\n    n = len(f)\n    i = 0\n    result.append(i)\n    for j in range(1, n):\n        if s[j] >= f[i]:\n            result.append(j)\n            i = j\n    return result\n", "asserts": ["assert MaxActivities([2, 4, 5, 6, 7, 8], [3, 5, 6, 7, 9, 10]) == [0, 1, 2, 3, 4]", "assert MaxActivities([1, 3, 0, 5, 8, 5], [2, 4, 6, 7, 9, 9]) == [0, 1, 3, 4]", "assert MaxActivities([1], [2]) == [0]"]}], "category": "Array", "prompt_tokens": 1068, "total_tokens": 1412, "completion_tokens": 344, "completion": "Given an array of integers, find the length of the longest subarray where the difference between any two consecutive elements is at most 1.\n\n###Code: \n\ndef longestSubarray(arr: list) -> int:\n    if not arr:\n        return 0\n    max_len = 1\n    curr_len = 1\n    for i in range(1, len(arr)):\n        if abs(arr[i] - arr[i - 1]) <= 1:\n            curr_len += 1\n        else:\n            curr_len = 1\n        max_len = max(max_len, curr_len)\n    return max_len\n\n###Testcases: \n\nassert longestSubarray([1, 2, 2, 3, 4]) == 3\nassert longestSubarray([1, 1, 1, 1, 3, 3, 2, 2]) == 5\nassert longestSubarray([4, 6, 5, 5, 6, 7]) == 3\nassert longestSubarray([10]) == 1\nassert longestSubarray([1, 2, 3, 4, 5, 3, 2]) == 2\nassert longestSubarray([]) == 0  # Edge case with empty array\nassert longestSubarray([1, 3, 5, 7, 9]) == 1  # Edge case with differences greater than 1\nassert longestSubarray([2, 2, 2, 2, 2, 2]) == 6  # Edge case with all elements the same\n\n[/Example 3]", "temperature": 0.777}, {"few_shots": [{"author": "Calvin", "UUID": "1aeb3246-4c22-4d34-a48c-db7be8ba1b94", "question": "You are given n activities with their start and finish times. Select the maximum number of activities that can be performed by a single person and return their indexes. Assume that a person can only work on a single activity at a time. \n", "examples": "Input: start  =  {10, 12, 20}, finish =  {20, 25, 30}\nOutput: [0, 2]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "import numpy as np\ndef MaxActivities(s: list, f: list) -> list:\n    indices = np.argsort(f)\n    [s[i] for i in indices]\n    [f[i] for i in indices]\n    result = []\n    n = len(f)\n    i = 0\n    result.append(i)\n    for j in range(1, n):\n        if s[j] >= f[i]:\n            result.append(j)\n            i = j\n    return result\n", "asserts": ["assert MaxActivities([2, 4, 5, 6, 7, 8], [3, 5, 6, 7, 9, 10]) == [0, 1, 2, 3, 4]", "assert MaxActivities([1, 3, 0, 5, 8, 5], [2, 4, 6, 7, 9, 9]) == [0, 1, 3, 4]", "assert MaxActivities([1], [2]) == [0]"]}, {"author": "Calvin", "UUID": "48c6aa37-e00d-4b55-9afc-6b1cf2a1aff2", "question": "There are N Mice and N holes are placed in a straight line. Each hole can accommodate only 1 mouse. A mouse can stay at his position, move one step right from x to x + 1, or move one step left from x to x -1. Any of these moves consumes 1 minute. Assign mice to holes so that the time when the last mouse gets inside a hole is minimized.\nYou are given a list of mice and hole positions as integer scalers.\n", "examples": "Input: Mices = [0, 10, 2, 3], Holes = [3, 2, 23, 0]\nOutput: 13", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def assignHole(mices: list, holes: list) -> int:\n    for i,j in zip(mices,holes):\n        if i<0 or j<0:\n            return -1\n    if (len(mices) != len(holes)):\n        return -1\n    mices.sort()\n    holes.sort()\n    Max = 0\n     \n    for i in range(len(holes)):\n        if (Max < abs(mices[i] - holes[i])):\n            Max = abs(mices[i] - holes[i])\n     \n    return Max\n", "asserts": ["assert assignHole([1, 2, 3, 4], [4, 3, 2, 1]) == 0", "assert assignHole([10, 20, 30, 40], [15, 25, 35, 45]) == 5", "assert assignHole([1, 4, 9, 15], [10, 13, 7, 20]) == 6", "assert assignHole([0], [0]) == 0", "assert assignHole([1, 2], [3]) == -1  # Edge case with non-equal amount of mice and holes", "assert assignHole([5, 5, 5], [5, 5, 5]) == 0  # Edge case with all mice and holes at the same position", "assert assignHole([10, 10, 10, 10], [10, 9, 8, 7]) == 3  # Edge case with multiple mice starting at the same position", "assert assignHole([1,1 ,1, 1, 1, 1, 1, 1, 1, 1], [2,2,2,2,2,2 ,2, 2, 2, 2]) == 1 # Edge case with multiple mice and holes at the same positions", "assert assignHole([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == 1 # Edge case with incremental positions"]}], "category": "Array", "prompt_tokens": 1068, "total_tokens": 1455, "completion_tokens": 387, "completion": "Given an array of integers, write a function that returns `True` if there is a triplet (a, b, c) that satisfies a^2 + b^2 = c^2. The function should not consider repeated elements as a valid triplet.\n\n\n###Code: \n\ndef isTriplet(arr: list) -> bool:\n    n = len(arr)\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                x = arr[i] ** 2\n                y = arr[j] ** 2\n                z = arr[k] ** 2\n                if x == y + z or y == x + z or z == x + y:\n                    return True\n    return False\n\n\n###Testcases: \n\nassert isTriplet([3, 1, 4, 6, 5]) == True\nassert isTriplet([10, 4, 6, 12, 5]) == True\nassert isTriplet([1, 2, 3]) == False\nassert isTriplet([0, 1, 2, 3, 4]) == False\nassert isTriplet([5, 12, 13]) == True\nassert isTriplet([5, 12, 13, 5, 12, 13]) == False  # Edge case with repeated elements\nassert isTriplet([9, 40, 41, 8, 15]) == True\nassert isTriplet([]) == False  # Edge case with an empty array\nassert isTriplet([1]) == False  # Edge case with a single element\nassert isTriplet([1, 1, 1, 1]) == False  # Edge case with all elements the same\n\n[/Example 3]", "temperature": 0.713}, {"few_shots": [{"author": "Calvin", "UUID": "a9c5e697-af5d-432b-8447-5675d739c728", "question": "Given an array reorder it so that even numbers appear first", "examples": "Input: [1,2,3,4,5,6,7,8,9]\r\nOutput: [8,2,6,4,5,7,3,9,1]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def even_odd_reorder(arr: list) -> list:\n  nextEven = 0\n  nextOdd = len(arr) - 1\n  while nextEven < nextOdd:\n    if arr[nextEven] % 2 == 0:\n      nextEven += 1\n    else:\n      temp = arr[nextEven]\n      arr[nextEven] = arr[nextOdd]\n      arr[nextOdd] = temp\n      nextOdd -= 1\n  return arr\n", "asserts": ["assert even_odd_reorder([1,2,3,4,5,6,7,8,9]) == [8, 2, 6, 4, 5, 7, 3, 9, 1]", "assert even_odd_reorder([]) == []", "assert even_odd_reorder([2, 4, 6, 8]) == [2, 4, 6, 8]", "assert even_odd_reorder([7, 9, 2]) == [2, 9, 7]", "assert even_odd_reorder([10, 13, 17, 16, 15, 12]) == [10, 12, 16, 15, 17, 13]"]}, {"author": "Calvin", "UUID": "9e45b73f-583d-40ab-b387-e0d1624af07b", "question": "Given two arrays return an array with the set intersection of their common elements", "examples": "Input: arr1 = [1, 2, 3, 4], arr2 = [2, 3]\nOutput: [2, 3]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def array_intersection(arr1: list, arr2: list) -> set:\n  set1 = set(arr1)\n  ret = set([x for x in arr2 if x in set1])\n  return list(ret)\n", "asserts": ["assert set(array_intersection([1,0,2,0,2,0,2,1,1,1], [2,1,0,2,0,2,2,2,1,0])) == {0,1,2}", "assert set(array_intersection([5, 6, 7, 8], [8, 9, 10, 11])) == {8}", "assert set(array_intersection([10, 20, 30], [40, 50, 60])) == set()", "assert set(array_intersection([], [1, 2, 3])) == set()", "assert set(array_intersection([-1, -2, -3], [-3, -4, -5, -6])) == {-3}", "assert set(array_intersection([9, 8, 7], [7, 8, 9, 10, 11, 12])) == {7, 8, 9}", "assert set(array_intersection(['a', 'b', 'c'], ['a', 'd', 'e', 'c'])) == {'a', 'c'}", "assert set(array_intersection(['apple', 'banana'], ['banana', 'cherry'])) == {'banana'}", "assert set(array_intersection([1.1, 2.2, 3.3], [2.2, 4.4])) == {2.2}", "assert set(array_intersection([False, True, False], [True, False, True])) == {True, False}", "assert set(array_intersection([(1, 2), (3, 4)], [(3, 4), (5, 6)])) == {(3, 4)}"]}], "category": "Array", "prompt_tokens": 886, "total_tokens": 1252, "completion_tokens": 366, "completion": "Given an array of integers, find the first missing positive integer. In other words, find the lowest positive integer that does not exist in the array. The array can contain duplicates and negative numbers as well.\n\n###Code:\n\n```python\ndef first_missing_positive(nums: list) -> int:\n    if not nums:\n        return 1\n    \n    nums.append(0)\n    n = len(nums)\n    for i in range(n): # remove those useless elements\n        if nums[i] < 0 or nums[i] >= n:\n            nums[i] = 0\n    \n    for i in range(n): # use the index as the hash to record the frequency of each number\n        nums[nums[i] % n] += n\n        \n    for i in range(1, n):\n        if nums[i] // n == 0:\n            return i\n    \n    return n\n\n\n###Testcases:\n\nassert first_missing_positive([1, 2, 0]) == 3\nassert first_missing_positive([3, 4, -1, 1]) == 2\nassert first_missing_positive([7, 8, 9, 11, 12]) == 1\nassert first_missing_positive([]) == 1\nassert first_missing_positive([0, 2, 2, 1, 1]) == 3\nassert first_missing_positive([1]) == 2\nassert first_missing_positive([-1, -2, -3]) == 1\nassert first_missing_positive([1, 2, 3]) == 4\nassert first_missing_positive([3, 2, 1, -1, -2, -5, 0, 4, 5, 6]) == 7\n```\n\n[/Example 3]", "temperature": 0.799}, {"few_shots": [{"author": "Calvin", "UUID": "a9c5e697-af5d-432b-8447-5675d739c728", "question": "Given an array reorder it so that even numbers appear first", "examples": "Input: [1,2,3,4,5,6,7,8,9]\r\nOutput: [8,2,6,4,5,7,3,9,1]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def even_odd_reorder(arr: list) -> list:\n  nextEven = 0\n  nextOdd = len(arr) - 1\n  while nextEven < nextOdd:\n    if arr[nextEven] % 2 == 0:\n      nextEven += 1\n    else:\n      temp = arr[nextEven]\n      arr[nextEven] = arr[nextOdd]\n      arr[nextOdd] = temp\n      nextOdd -= 1\n  return arr\n", "asserts": ["assert even_odd_reorder([1,2,3,4,5,6,7,8,9]) == [8, 2, 6, 4, 5, 7, 3, 9, 1]", "assert even_odd_reorder([]) == []", "assert even_odd_reorder([2, 4, 6, 8]) == [2, 4, 6, 8]", "assert even_odd_reorder([7, 9, 2]) == [2, 9, 7]", "assert even_odd_reorder([10, 13, 17, 16, 15, 12]) == [10, 12, 16, 15, 17, 13]"]}, {"author": "Calvin", "UUID": "1aeb3246-4c22-4d34-a48c-db7be8ba1b94", "question": "You are given n activities with their start and finish times. Select the maximum number of activities that can be performed by a single person and return their indexes. Assume that a person can only work on a single activity at a time. \n", "examples": "Input: start  =  {10, 12, 20}, finish =  {20, 25, 30}\nOutput: [0, 2]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "import numpy as np\ndef MaxActivities(s: list, f: list) -> list:\n    indices = np.argsort(f)\n    [s[i] for i in indices]\n    [f[i] for i in indices]\n    result = []\n    n = len(f)\n    i = 0\n    result.append(i)\n    for j in range(1, n):\n        if s[j] >= f[i]:\n            result.append(j)\n            i = j\n    return result\n", "asserts": ["assert MaxActivities([2, 4, 5, 6, 7, 8], [3, 5, 6, 7, 9, 10]) == [0, 1, 2, 3, 4]", "assert MaxActivities([1, 3, 0, 5, 8, 5], [2, 4, 6, 7, 9, 9]) == [0, 1, 3, 4]", "assert MaxActivities([1], [2]) == [0]"]}], "category": "Array", "prompt_tokens": 746, "total_tokens": 1012, "completion_tokens": 266, "completion": "Given an array of integers, write a function to move all zeros to the end while maintaining the relative order of the non-zero elements.\n\n###Code:\n\n```python\ndef move_zeros_to_end(arr: list) -> list:\n    non_zero_index = 0\n    for i in range(len(arr)):\n        if arr[i] != 0:\n            arr[non_zero_index], arr[i] = arr[i], arr[non_zero_index]\n            non_zero_index += 1\n    return arr\n```\n\n###Testcases:\n\n```python\nassert move_zeros_to_end([0,1,0,3,12]) == [1,3,12,0,0]\nassert move_zeros_to_end([0,0,1]) == [1,0,0]\nassert move_zeros_to_end([4,2,4,0,0,3,0,5,1,0]) == [4,2,4,3,5,1,0,0,0,0]\nassert move_zeros_to_end([1,2,3,4]) == [1,2,3,4]\nassert move_zeros_to_end([0,0,0,0,0]) == [0,0,0,0,0]\n```\n\n[/Example 3]", "temperature": 0.91}, {"few_shots": [{"author": "Calvin", "UUID": "fb94082f-4627-4f5a-b280-08d869823d70", "question": "You are given an array of people, people, which are the attributes of some people in a queue (not necessarily in order). Each people[i] = [hi, ki] represents the ith person of height hi with exactly ki other people in front who have a height greater than or equal to hi.\n\nReconstruct and return the queue that is represented by the input array people. The returned queue should be formatted as an array queue, where queue[j] = [hj, kj] is the attributes of the jth person in the queue (queue[0] is the person at the front of the queue).\n", "examples": "Input:  [[7, 0], [4, 4], [7, 1], [5, 0], [6, 1], [5, 2]]\nOutput: [[5, 0], [4, 1], [7, 0], [5, 2], [6, 1], [7, 1]]\n\nInput:  [[6, 0], [5, 0], [4, 0], [3, 2], [2, 2], [1, 4]]\nOutput: [[4, 0], [5, 0], [2, 2], [3, 2], [1, 4], [6, 0]]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "\ndef reconstructQueue(people: list) -> list:\n    output=[] \n    people.sort(key=lambda x: (-x[0], x[1]))                \n    for a in people:\n        output.insert(a[1], a)\n    \n    return output\n", "asserts": ["assert reconstructQueue([[8,1],[5,0],[6,1],[5,2],[4,4],[7,1]]) == [[5, 0], [8, 1], [5, 2], [6, 1], [4, 4], [7, 1]]", "assert reconstructQueue([[12,0], [6,3], [4,4], [9,2], [7,1]]) == [[12, 0], [7, 1], [9, 2], [6, 3], [4, 4]]", "assert reconstructQueue([[2,0], [1,1]]) == [[2, 0], [1, 1]]", "assert reconstructQueue([[3,0], [3,2], [3,1]]) == [[3, 0], [3, 1], [3, 2]]"]}, {"author": "Calvin", "UUID": "9e45b73f-583d-40ab-b387-e0d1624af07b", "question": "Given two arrays return an array with the set intersection of their common elements", "examples": "Input: arr1 = [1, 2, 3, 4], arr2 = [2, 3]\nOutput: [2, 3]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def array_intersection(arr1: list, arr2: list) -> set:\n  set1 = set(arr1)\n  ret = set([x for x in arr2 if x in set1])\n  return list(ret)\n", "asserts": ["assert set(array_intersection([1,0,2,0,2,0,2,1,1,1], [2,1,0,2,0,2,2,2,1,0])) == {0,1,2}", "assert set(array_intersection([5, 6, 7, 8], [8, 9, 10, 11])) == {8}", "assert set(array_intersection([10, 20, 30], [40, 50, 60])) == set()", "assert set(array_intersection([], [1, 2, 3])) == set()", "assert set(array_intersection([-1, -2, -3], [-3, -4, -5, -6])) == {-3}", "assert set(array_intersection([9, 8, 7], [7, 8, 9, 10, 11, 12])) == {7, 8, 9}", "assert set(array_intersection(['a', 'b', 'c'], ['a', 'd', 'e', 'c'])) == {'a', 'c'}", "assert set(array_intersection(['apple', 'banana'], ['banana', 'cherry'])) == {'banana'}", "assert set(array_intersection([1.1, 2.2, 3.3], [2.2, 4.4])) == {2.2}", "assert set(array_intersection([False, True, False], [True, False, True])) == {True, False}", "assert set(array_intersection([(1, 2), (3, 4)], [(3, 4), (5, 6)])) == {(3, 4)}"]}], "category": "Array", "prompt_tokens": 983, "total_tokens": 1370, "completion_tokens": 387, "completion": "Given an array of integers `nums` and an integer `target`, return indices of the two numbers such that they add up to `target`.\n\nYou may assume that each input would have exactly one solution, and you may not use the same element twice. You can return the answer in any order.\n\n###Code: \n\ndef two_sum(nums: list, target: int) -> list:\n    prev_map = {}  # val -> index\n    \n    for i, n in enumerate(nums):\n        diff = target - n\n        if diff in prev_map:\n            return [prev_map[diff], i]\n        prev_map[n] = i\n    return []\n\n###Testcases: \n\nassert two_sum([2, 7, 11, 15], 9) == [0, 1]\nassert two_sum([3, 2, 4], 6) == [1, 2]\nassert two_sum([3, 3], 6) == [0, 1]\nassert two_sum([0, 4, 3, 0], 0) == [0, 3]\nassert two_sum([-3, 4, 3, 90], 0) == [0, 2]\nassert two_sum([1, 2, 3], 4) == [0, 2]\nassert two_sum([4, 2, 6, 5, 7], 13) == [2, 4]\nassert two_sum([1, 5, 2, 8], 10) == [1, 3]\nassert two_sum([-1, -2, -3, -4, -5], -8) == [2, 4]\nassert two_sum([123, 456, 789, 0], 789) == [2, 3]\n\n[/Example 3]", "temperature": 0.683}, {"few_shots": [{"author": "Calvin", "UUID": "9e45b73f-583d-40ab-b387-e0d1624af07b", "question": "Given two arrays return an array with the set intersection of their common elements", "examples": "Input: arr1 = [1, 2, 3, 4], arr2 = [2, 3]\nOutput: [2, 3]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def array_intersection(arr1: list, arr2: list) -> set:\n  set1 = set(arr1)\n  ret = set([x for x in arr2 if x in set1])\n  return list(ret)\n", "asserts": ["assert set(array_intersection([1,0,2,0,2,0,2,1,1,1], [2,1,0,2,0,2,2,2,1,0])) == {0,1,2}", "assert set(array_intersection([5, 6, 7, 8], [8, 9, 10, 11])) == {8}", "assert set(array_intersection([10, 20, 30], [40, 50, 60])) == set()", "assert set(array_intersection([], [1, 2, 3])) == set()", "assert set(array_intersection([-1, -2, -3], [-3, -4, -5, -6])) == {-3}", "assert set(array_intersection([9, 8, 7], [7, 8, 9, 10, 11, 12])) == {7, 8, 9}", "assert set(array_intersection(['a', 'b', 'c'], ['a', 'd', 'e', 'c'])) == {'a', 'c'}", "assert set(array_intersection(['apple', 'banana'], ['banana', 'cherry'])) == {'banana'}", "assert set(array_intersection([1.1, 2.2, 3.3], [2.2, 4.4])) == {2.2}", "assert set(array_intersection([False, True, False], [True, False, True])) == {True, False}", "assert set(array_intersection([(1, 2), (3, 4)], [(3, 4), (5, 6)])) == {(3, 4)}"]}, {"author": "Calvin", "UUID": "a9c5e697-af5d-432b-8447-5675d739c728", "question": "Given an array reorder it so that even numbers appear first", "examples": "Input: [1,2,3,4,5,6,7,8,9]\r\nOutput: [8,2,6,4,5,7,3,9,1]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def even_odd_reorder(arr: list) -> list:\n  nextEven = 0\n  nextOdd = len(arr) - 1\n  while nextEven < nextOdd:\n    if arr[nextEven] % 2 == 0:\n      nextEven += 1\n    else:\n      temp = arr[nextEven]\n      arr[nextEven] = arr[nextOdd]\n      arr[nextOdd] = temp\n      nextOdd -= 1\n  return arr\n", "asserts": ["assert even_odd_reorder([1,2,3,4,5,6,7,8,9]) == [8, 2, 6, 4, 5, 7, 3, 9, 1]", "assert even_odd_reorder([]) == []", "assert even_odd_reorder([2, 4, 6, 8]) == [2, 4, 6, 8]", "assert even_odd_reorder([7, 9, 2]) == [2, 9, 7]", "assert even_odd_reorder([10, 13, 17, 16, 15, 12]) == [10, 12, 16, 15, 17, 13]"]}], "category": "Array", "prompt_tokens": 886, "total_tokens": 1186, "completion_tokens": 300, "completion": "Given an array of integers, move all the zeros to the end of the array while maintaining the relative order of the non-zero elements.\n\n###Code: \n\ndef move_zeros(arr: list) -> list:\n    idx = 0\n    for num in arr:\n        if num != 0:\n            arr[idx] = num\n            idx += 1\n    for i in range(idx, len(arr)):\n        arr[i] = 0\n    return arr\n\n###Testcases: \n\nassert move_zeros([0,1,0,3,12]) == [1,3,12,0,0]\nassert move_zeros([0,0,0,0,3,2,1]) == [3,2,1,0,0,0,0]\nassert move_zeros([1,7,0,0,8,0,10,0]) == [1,7,8,10,0,0,0,0]\nassert move_zeros([4,1,2,0,0,1,2,0,3,0]) == [4,1,2,1,2,3,0,0,0,0]\nassert move_zeros([0,0,0]) == [0,0,0]\nassert move_zeros([1,2,3,4,5]) == [1,2,3,4,5]\nassert move_zeros([]) == []\n\n[/Example 3]", "temperature": 0.773}, {"few_shots": [{"author": "Calvin", "UUID": "fb94082f-4627-4f5a-b280-08d869823d70", "question": "You are given an array of people, people, which are the attributes of some people in a queue (not necessarily in order). Each people[i] = [hi, ki] represents the ith person of height hi with exactly ki other people in front who have a height greater than or equal to hi.\n\nReconstruct and return the queue that is represented by the input array people. The returned queue should be formatted as an array queue, where queue[j] = [hj, kj] is the attributes of the jth person in the queue (queue[0] is the person at the front of the queue).\n", "examples": "Input:  [[7, 0], [4, 4], [7, 1], [5, 0], [6, 1], [5, 2]]\nOutput: [[5, 0], [4, 1], [7, 0], [5, 2], [6, 1], [7, 1]]\n\nInput:  [[6, 0], [5, 0], [4, 0], [3, 2], [2, 2], [1, 4]]\nOutput: [[4, 0], [5, 0], [2, 2], [3, 2], [1, 4], [6, 0]]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "\ndef reconstructQueue(people: list) -> list:\n    output=[] \n    people.sort(key=lambda x: (-x[0], x[1]))                \n    for a in people:\n        output.insert(a[1], a)\n    \n    return output\n", "asserts": ["assert reconstructQueue([[8,1],[5,0],[6,1],[5,2],[4,4],[7,1]]) == [[5, 0], [8, 1], [5, 2], [6, 1], [4, 4], [7, 1]]", "assert reconstructQueue([[12,0], [6,3], [4,4], [9,2], [7,1]]) == [[12, 0], [7, 1], [9, 2], [6, 3], [4, 4]]", "assert reconstructQueue([[2,0], [1,1]]) == [[2, 0], [1, 1]]", "assert reconstructQueue([[3,0], [3,2], [3,1]]) == [[3, 0], [3, 1], [3, 2]]"]}, {"author": "Calvin", "UUID": "1aeb3246-4c22-4d34-a48c-db7be8ba1b94", "question": "You are given n activities with their start and finish times. Select the maximum number of activities that can be performed by a single person and return their indexes. Assume that a person can only work on a single activity at a time. \n", "examples": "Input: start  =  {10, 12, 20}, finish =  {20, 25, 30}\nOutput: [0, 2]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "import numpy as np\ndef MaxActivities(s: list, f: list) -> list:\n    indices = np.argsort(f)\n    [s[i] for i in indices]\n    [f[i] for i in indices]\n    result = []\n    n = len(f)\n    i = 0\n    result.append(i)\n    for j in range(1, n):\n        if s[j] >= f[i]:\n            result.append(j)\n            i = j\n    return result\n", "asserts": ["assert MaxActivities([2, 4, 5, 6, 7, 8], [3, 5, 6, 7, 9, 10]) == [0, 1, 2, 3, 4]", "assert MaxActivities([1, 3, 0, 5, 8, 5], [2, 4, 6, 7, 9, 9]) == [0, 1, 3, 4]", "assert MaxActivities([1], [2]) == [0]"]}], "category": "Array", "prompt_tokens": 843, "total_tokens": 1130, "completion_tokens": 287, "completion": "Given an array of integers, find the continuous subarray (containing at least one number) which has the largest sum and return its sum. Also, return the indices of the start and end of the subarray. If there is a tie, return the subarray with the smallest starting index.\n\n\n###Code: \n\ndef maxSubArray(nums: list) -> tuple:\n    max_sum = float('-inf')\n    current_sum = 0\n    start = 0\n    end = 0\n    temp_start = 0\n    \n    for i in range(len(nums)):\n        current_sum += nums[i]\n        if current_sum > max_sum:\n            max_sum = current_sum\n            start = temp_start\n            end = i\n        if current_sum < 0:\n            current_sum = 0\n            temp_start = i + 1\n    \n    return max_sum, start, end\n\n\n###Testcases: \n\nassert maxSubArray([-2,1,-3,4,-1,2,1,-5,4]) == (6, 3, 6)\nassert maxSubArray([1]) == (1, 0, 0)\nassert maxSubArray([5,4,-1,7,8]) == (23, 0, 4)\nassert maxSubArray([-2,-1]) == (-1, 1, 1)\n\n[/Example 3]", "temperature": 0.782}, {"few_shots": [{"author": "Calvin", "UUID": "fb94082f-4627-4f5a-b280-08d869823d70", "question": "You are given an array of people, people, which are the attributes of some people in a queue (not necessarily in order). Each people[i] = [hi, ki] represents the ith person of height hi with exactly ki other people in front who have a height greater than or equal to hi.\n\nReconstruct and return the queue that is represented by the input array people. The returned queue should be formatted as an array queue, where queue[j] = [hj, kj] is the attributes of the jth person in the queue (queue[0] is the person at the front of the queue).\n", "examples": "Input:  [[7, 0], [4, 4], [7, 1], [5, 0], [6, 1], [5, 2]]\nOutput: [[5, 0], [4, 1], [7, 0], [5, 2], [6, 1], [7, 1]]\n\nInput:  [[6, 0], [5, 0], [4, 0], [3, 2], [2, 2], [1, 4]]\nOutput: [[4, 0], [5, 0], [2, 2], [3, 2], [1, 4], [6, 0]]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "\ndef reconstructQueue(people: list) -> list:\n    output=[] \n    people.sort(key=lambda x: (-x[0], x[1]))                \n    for a in people:\n        output.insert(a[1], a)\n    \n    return output\n", "asserts": ["assert reconstructQueue([[8,1],[5,0],[6,1],[5,2],[4,4],[7,1]]) == [[5, 0], [8, 1], [5, 2], [6, 1], [4, 4], [7, 1]]", "assert reconstructQueue([[12,0], [6,3], [4,4], [9,2], [7,1]]) == [[12, 0], [7, 1], [9, 2], [6, 3], [4, 4]]", "assert reconstructQueue([[2,0], [1,1]]) == [[2, 0], [1, 1]]", "assert reconstructQueue([[3,0], [3,2], [3,1]]) == [[3, 0], [3, 1], [3, 2]]"]}, {"author": "Calvin", "UUID": "f795bda7-9822-4bc5-9c7e-b9c0f2752085", "question": "You are given two 0-indexed integer permutations A and B of length n.\n\nA prefix common array of A and B is an array C such that C[i] is equal to the count of numbers that are present at or before the index i in both A and B.\n\nReturn the prefix common array of A and B.\n\nA sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once.", "examples": "Input: A = [1,3,2,4], B = [3,1,2,4]\nOutput: [0,2,3,4]", "link": "https://leetcode.com/problems/find-the-prefix-common-array-of-two-arrays/", "difficulty": null, "categories": ["Array"], "code": "def findThePrefixCommonArray(arr1: list, arr2: list) -> list:\n  max = len(arr1) if len(arr1) > len(arr2) else len(arr2)\n  seen = set()\n  curCount = 0\n  ret = []\n  for i in range(max):\n    cur1 = arr1[i]\n    cur2 = arr2[i]\n    if cur1 in seen:\n      curCount += 1\n    else:\n      seen.add(cur1)\n    if cur2 in seen:\n      curCount += 1\n    else:\n      seen.add(cur2)\n    ret.append(curCount)\n  return ret\n", "asserts": ["assert findThePrefixCommonArray([1,3,2,4], [3,1,2,4]) == [0,2,3,4]", "assert findThePrefixCommonArray([1], [1]) == [1]", "assert findThePrefixCommonArray([2,3,1], [3,1,2]) == [0,1,3]"]}], "category": "Array", "prompt_tokens": 878, "total_tokens": 1235, "completion_tokens": 357, "completion": "Given an integer array `nums` sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same.\n\nSince it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array `nums`. More formally, if there are `k` elements after removing the duplicates, then the first `k` elements of `nums` should hold the final result. It does not matter what you leave beyond the first `k` elements.\n\nReturn `k` after placing the final result in the first `k` slots of `nums`.\n\nDo not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.\n\n###Code: \n\ndef removeDuplicates(nums: list) -> int:\n    if not nums:\n        return 0\n\n    k = 1\n    for i in range(1, len(nums)):\n        if nums[i] != nums[k - 1]:\n            nums[k] = nums[i]\n            k += 1\n    return k\n\n\n###Testcases: \n\nassert removeDuplicates([1,1,2]) == 2, \"Test case 1 failed\"\nassert removeDuplicates([0,0,1,1,1,2,2,3,3,4]) == 5, \"Test case 2 failed\"\nassert removeDuplicates([1,2,3,4]) == 4, \"Test case 3 failed\"\nassert removeDuplicates([-1,0,0,0,0,3,3]) == 3, \"Test case 4 failed\"\n\n[/Example 3]", "temperature": 0.881}, {"few_shots": [{"author": "Calvin", "UUID": "f795bda7-9822-4bc5-9c7e-b9c0f2752085", "question": "You are given two 0-indexed integer permutations A and B of length n.\n\nA prefix common array of A and B is an array C such that C[i] is equal to the count of numbers that are present at or before the index i in both A and B.\n\nReturn the prefix common array of A and B.\n\nA sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once.", "examples": "Input: A = [1,3,2,4], B = [3,1,2,4]\nOutput: [0,2,3,4]", "link": "https://leetcode.com/problems/find-the-prefix-common-array-of-two-arrays/", "difficulty": null, "categories": ["Array"], "code": "def findThePrefixCommonArray(arr1: list, arr2: list) -> list:\n  max = len(arr1) if len(arr1) > len(arr2) else len(arr2)\n  seen = set()\n  curCount = 0\n  ret = []\n  for i in range(max):\n    cur1 = arr1[i]\n    cur2 = arr2[i]\n    if cur1 in seen:\n      curCount += 1\n    else:\n      seen.add(cur1)\n    if cur2 in seen:\n      curCount += 1\n    else:\n      seen.add(cur2)\n    ret.append(curCount)\n  return ret\n", "asserts": ["assert findThePrefixCommonArray([1,3,2,4], [3,1,2,4]) == [0,2,3,4]", "assert findThePrefixCommonArray([1], [1]) == [1]", "assert findThePrefixCommonArray([2,3,1], [3,1,2]) == [0,1,3]"]}, {"author": "Calvin", "UUID": "48c6aa37-e00d-4b55-9afc-6b1cf2a1aff2", "question": "There are N Mice and N holes are placed in a straight line. Each hole can accommodate only 1 mouse. A mouse can stay at his position, move one step right from x to x + 1, or move one step left from x to x -1. Any of these moves consumes 1 minute. Assign mice to holes so that the time when the last mouse gets inside a hole is minimized.\nYou are given a list of mice and hole positions as integer scalers.\n", "examples": "Input: Mices = [0, 10, 2, 3], Holes = [3, 2, 23, 0]\nOutput: 13", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def assignHole(mices: list, holes: list) -> int:\n    for i,j in zip(mices,holes):\n        if i<0 or j<0:\n            return -1\n    if (len(mices) != len(holes)):\n        return -1\n    mices.sort()\n    holes.sort()\n    Max = 0\n     \n    for i in range(len(holes)):\n        if (Max < abs(mices[i] - holes[i])):\n            Max = abs(mices[i] - holes[i])\n     \n    return Max\n", "asserts": ["assert assignHole([1, 2, 3, 4], [4, 3, 2, 1]) == 0", "assert assignHole([10, 20, 30, 40], [15, 25, 35, 45]) == 5", "assert assignHole([1, 4, 9, 15], [10, 13, 7, 20]) == 6", "assert assignHole([0], [0]) == 0", "assert assignHole([1, 2], [3]) == -1  # Edge case with non-equal amount of mice and holes", "assert assignHole([5, 5, 5], [5, 5, 5]) == 0  # Edge case with all mice and holes at the same position", "assert assignHole([10, 10, 10, 10], [10, 9, 8, 7]) == 3  # Edge case with multiple mice starting at the same position", "assert assignHole([1,1 ,1, 1, 1, 1, 1, 1, 1, 1], [2,2,2,2,2,2 ,2, 2, 2, 2]) == 1 # Edge case with multiple mice and holes at the same positions", "assert assignHole([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == 1 # Edge case with incremental positions"]}], "category": "Array", "prompt_tokens": 1103, "total_tokens": 1651, "completion_tokens": 548, "completion": "Given an array of integers, return a new array such that each element at index i of the new array is the product of all the numbers in the original array except the one at i.\n\nYou must write an algorithm that runs in O(n) time and without using the division operation.\n\n###Code: \n\ndef productExceptSelf(nums: list) -> list:\n    length = len(nums)\n    answer = [0]*length\n\n    # answer[i] contains the product of all the elements to the left\n    # Note: for the element at index '0', there are no elements to the left,\n    # so the answer[0] would be 1\n    answer[0] = 1\n    for i in range(1, length):\n        answer[i] = nums[i - 1] * answer[i - 1]\n\n    # R contains the product of all the elements to the right\n    # Note: for the element at index 'length - 1', there are no elements to the right,\n    # so the R would be 1\n    R = 1\n    for i in reversed(range(length)):\n        # For the index 'i', R would contain the\n        # product of all elements to the right. We update R accordingly\n        answer[i] = answer[i] * R\n        R *= nums[i]\n\n    return answer\n\n\n###Testcases: \n\nassert productExceptSelf([1,2,3,4]) == [24,12,8,6]\nassert productExceptSelf([0,0]) == [0,0]\nassert productExceptSelf([1,0]) == [0,1]\nassert productExceptSelf([-1,1,0,-3,3]) == [0,0,9,0,0]\nassert productExceptSelf([]) == []  # Edge case with empty list\nassert productExceptSelf([2]) == [1]  # Edge case with single element\nassert productExceptSelf([1,2,3,0,4,5]) == [0,0,0,120,0,0]  # Edge case with a zero in the array\nassert productExceptSelf([1,2,3,0,0,5]) == [0,0,0,0,0,0]  # Edge case with multiple zeros in the array\nassert productExceptSelf([1,1,1,1,1,1,1,1,1,1]) == [1,1,1,1,1,1,1,1,1,1]  # Edge case with all elements the same\n\n[/Example 3]", "temperature": 0.849}, {"few_shots": [{"author": "Calvin", "UUID": "f795bda7-9822-4bc5-9c7e-b9c0f2752085", "question": "You are given two 0-indexed integer permutations A and B of length n.\n\nA prefix common array of A and B is an array C such that C[i] is equal to the count of numbers that are present at or before the index i in both A and B.\n\nReturn the prefix common array of A and B.\n\nA sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once.", "examples": "Input: A = [1,3,2,4], B = [3,1,2,4]\nOutput: [0,2,3,4]", "link": "https://leetcode.com/problems/find-the-prefix-common-array-of-two-arrays/", "difficulty": null, "categories": ["Array"], "code": "def findThePrefixCommonArray(arr1: list, arr2: list) -> list:\n  max = len(arr1) if len(arr1) > len(arr2) else len(arr2)\n  seen = set()\n  curCount = 0\n  ret = []\n  for i in range(max):\n    cur1 = arr1[i]\n    cur2 = arr2[i]\n    if cur1 in seen:\n      curCount += 1\n    else:\n      seen.add(cur1)\n    if cur2 in seen:\n      curCount += 1\n    else:\n      seen.add(cur2)\n    ret.append(curCount)\n  return ret\n", "asserts": ["assert findThePrefixCommonArray([1,3,2,4], [3,1,2,4]) == [0,2,3,4]", "assert findThePrefixCommonArray([1], [1]) == [1]", "assert findThePrefixCommonArray([2,3,1], [3,1,2]) == [0,1,3]"]}, {"author": "Calvin", "UUID": "a9c5e697-af5d-432b-8447-5675d739c728", "question": "Given an array reorder it so that even numbers appear first", "examples": "Input: [1,2,3,4,5,6,7,8,9]\r\nOutput: [8,2,6,4,5,7,3,9,1]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def even_odd_reorder(arr: list) -> list:\n  nextEven = 0\n  nextOdd = len(arr) - 1\n  while nextEven < nextOdd:\n    if arr[nextEven] % 2 == 0:\n      nextEven += 1\n    else:\n      temp = arr[nextEven]\n      arr[nextEven] = arr[nextOdd]\n      arr[nextOdd] = temp\n      nextOdd -= 1\n  return arr\n", "asserts": ["assert even_odd_reorder([1,2,3,4,5,6,7,8,9]) == [8, 2, 6, 4, 5, 7, 3, 9, 1]", "assert even_odd_reorder([]) == []", "assert even_odd_reorder([2, 4, 6, 8]) == [2, 4, 6, 8]", "assert even_odd_reorder([7, 9, 2]) == [2, 9, 7]", "assert even_odd_reorder([10, 13, 17, 16, 15, 12]) == [10, 12, 16, 15, 17, 13]"]}], "category": "Array", "prompt_tokens": 781, "total_tokens": 1102, "completion_tokens": 321, "completion": "Implement a function that merges two sorted integer arrays into one sorted array.\n\n###Code:\n\n```python\ndef merge_sorted_arrays(arr1: list, arr2: list) -> list:\n    merged = []\n    i, j = 0, 0\n    while i < len(arr1) and j < len(arr2):\n        if arr1[i] <= arr2[j]:\n            merged.append(arr1[i])\n            i += 1\n        else:\n            merged.append(arr2[j])\n            j += 1\n    # Append remaining elements, if any\n    while i < len(arr1):\n        merged.append(arr1[i])\n        i += 1\n    while j < len(arr2):\n        merged.append(arr2[j])\n        j += 1\n    return merged\n```\n\n###Testcases: \n\n```python\nassert merge_sorted_arrays([1,3,5], [2,4,6]) == [1,2,3,4,5,6]\nassert merge_sorted_arrays([], [1,2,3]) == [1,2,3]\nassert merge_sorted_arrays([5,10,15], []) == [5,10,15]\nassert merge_sorted_arrays([1,2],[3,4,5]) == [1,2,3,4,5]\nassert merge_sorted_arrays([2,5,7],[1,3,4,6,8,9]) == [1,2,3,4,5,6,7,8,9]\n```\n\n[/Example 3]", "temperature": 0.719}, {"few_shots": [{"author": "Calvin", "UUID": "a9c5e697-af5d-432b-8447-5675d739c728", "question": "Given an array reorder it so that even numbers appear first", "examples": "Input: [1,2,3,4,5,6,7,8,9]\r\nOutput: [8,2,6,4,5,7,3,9,1]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def even_odd_reorder(arr: list) -> list:\n  nextEven = 0\n  nextOdd = len(arr) - 1\n  while nextEven < nextOdd:\n    if arr[nextEven] % 2 == 0:\n      nextEven += 1\n    else:\n      temp = arr[nextEven]\n      arr[nextEven] = arr[nextOdd]\n      arr[nextOdd] = temp\n      nextOdd -= 1\n  return arr\n", "asserts": ["assert even_odd_reorder([1,2,3,4,5,6,7,8,9]) == [8, 2, 6, 4, 5, 7, 3, 9, 1]", "assert even_odd_reorder([]) == []", "assert even_odd_reorder([2, 4, 6, 8]) == [2, 4, 6, 8]", "assert even_odd_reorder([7, 9, 2]) == [2, 9, 7]", "assert even_odd_reorder([10, 13, 17, 16, 15, 12]) == [10, 12, 16, 15, 17, 13]"]}, {"author": "Calvin", "UUID": "9e45b73f-583d-40ab-b387-e0d1624af07b", "question": "Given two arrays return an array with the set intersection of their common elements", "examples": "Input: arr1 = [1, 2, 3, 4], arr2 = [2, 3]\nOutput: [2, 3]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def array_intersection(arr1: list, arr2: list) -> set:\n  set1 = set(arr1)\n  ret = set([x for x in arr2 if x in set1])\n  return list(ret)\n", "asserts": ["assert set(array_intersection([1,0,2,0,2,0,2,1,1,1], [2,1,0,2,0,2,2,2,1,0])) == {0,1,2}", "assert set(array_intersection([5, 6, 7, 8], [8, 9, 10, 11])) == {8}", "assert set(array_intersection([10, 20, 30], [40, 50, 60])) == set()", "assert set(array_intersection([], [1, 2, 3])) == set()", "assert set(array_intersection([-1, -2, -3], [-3, -4, -5, -6])) == {-3}", "assert set(array_intersection([9, 8, 7], [7, 8, 9, 10, 11, 12])) == {7, 8, 9}", "assert set(array_intersection(['a', 'b', 'c'], ['a', 'd', 'e', 'c'])) == {'a', 'c'}", "assert set(array_intersection(['apple', 'banana'], ['banana', 'cherry'])) == {'banana'}", "assert set(array_intersection([1.1, 2.2, 3.3], [2.2, 4.4])) == {2.2}", "assert set(array_intersection([False, True, False], [True, False, True])) == {True, False}", "assert set(array_intersection([(1, 2), (3, 4)], [(3, 4), (5, 6)])) == {(3, 4)}"]}], "category": "Array", "prompt_tokens": 886, "total_tokens": 1241, "completion_tokens": 355, "completion": "Given an array of integers, move all zeros to the end while maintaining the relative order of the non-zero elements.\n\n###Code: \n\ndef move_zeros(arr: list) -> list:\n    zero_count = arr.count(0)\n    arr[:] = [num for num in arr if num != 0]\n    arr.extend([0] * zero_count)\n    return arr\n\n###Testcases: \n\nassert move_zeros([0,1,0,3,12]) == [1,3,12,0,0]\nassert move_zeros([0,0,0,1,2]) == [1,2,0,0,0]\nassert move_zeros([4,2,4,0,0,3,0,5,1,0]) == [4,2,4,3,5,1,0,0,0,0]\nassert move_zeros([0,0,1,0]) == [1,0,0,0]\nassert move_zeros([1,0,1,0,1,0,1,0]) == [1,1,1,1,0,0,0,0]\nassert move_zeros([0]) == [0]\nassert move_zeros([0,0,0]) == [0,0,0]\nassert move_zeros([1,2,3,4,5]) == [1,2,3,4,5]\nassert move_zeros([-1,0,2,0,-3]) == [-1,2,-3,0,0]\nassert move_zeros([0,-1,0,2,0,-3]) == [-1,2,-3,0,0,0] \n\n[/Example 3]", "temperature": 0.811}, {"few_shots": [{"author": "Calvin", "UUID": "a9c5e697-af5d-432b-8447-5675d739c728", "question": "Given an array reorder it so that even numbers appear first", "examples": "Input: [1,2,3,4,5,6,7,8,9]\r\nOutput: [8,2,6,4,5,7,3,9,1]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def even_odd_reorder(arr: list) -> list:\n  nextEven = 0\n  nextOdd = len(arr) - 1\n  while nextEven < nextOdd:\n    if arr[nextEven] % 2 == 0:\n      nextEven += 1\n    else:\n      temp = arr[nextEven]\n      arr[nextEven] = arr[nextOdd]\n      arr[nextOdd] = temp\n      nextOdd -= 1\n  return arr\n", "asserts": ["assert even_odd_reorder([1,2,3,4,5,6,7,8,9]) == [8, 2, 6, 4, 5, 7, 3, 9, 1]", "assert even_odd_reorder([]) == []", "assert even_odd_reorder([2, 4, 6, 8]) == [2, 4, 6, 8]", "assert even_odd_reorder([7, 9, 2]) == [2, 9, 7]", "assert even_odd_reorder([10, 13, 17, 16, 15, 12]) == [10, 12, 16, 15, 17, 13]"]}, {"author": "Calvin", "UUID": "fb94082f-4627-4f5a-b280-08d869823d70", "question": "You are given an array of people, people, which are the attributes of some people in a queue (not necessarily in order). Each people[i] = [hi, ki] represents the ith person of height hi with exactly ki other people in front who have a height greater than or equal to hi.\n\nReconstruct and return the queue that is represented by the input array people. The returned queue should be formatted as an array queue, where queue[j] = [hj, kj] is the attributes of the jth person in the queue (queue[0] is the person at the front of the queue).\n", "examples": "Input:  [[7, 0], [4, 4], [7, 1], [5, 0], [6, 1], [5, 2]]\nOutput: [[5, 0], [4, 1], [7, 0], [5, 2], [6, 1], [7, 1]]\n\nInput:  [[6, 0], [5, 0], [4, 0], [3, 2], [2, 2], [1, 4]]\nOutput: [[4, 0], [5, 0], [2, 2], [3, 2], [1, 4], [6, 0]]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "\ndef reconstructQueue(people: list) -> list:\n    output=[] \n    people.sort(key=lambda x: (-x[0], x[1]))                \n    for a in people:\n        output.insert(a[1], a)\n    \n    return output\n", "asserts": ["assert reconstructQueue([[8,1],[5,0],[6,1],[5,2],[4,4],[7,1]]) == [[5, 0], [8, 1], [5, 2], [6, 1], [4, 4], [7, 1]]", "assert reconstructQueue([[12,0], [6,3], [4,4], [9,2], [7,1]]) == [[12, 0], [7, 1], [9, 2], [6, 3], [4, 4]]", "assert reconstructQueue([[2,0], [1,1]]) == [[2, 0], [1, 1]]", "assert reconstructQueue([[3,0], [3,2], [3,1]]) == [[3, 0], [3, 1], [3, 2]]"]}], "category": "Array", "prompt_tokens": 842, "total_tokens": 1098, "completion_tokens": 256, "completion": "Find the \"pivot\" index of an array where the sum of the numbers to the left of the index is equal to the sum of the numbers to the right of the index. If no such index exists, return -1. If there are multiple pivot indexes, you should return the left-most pivot index.\n\n###Code: \n\n```python\ndef find_pivot_index(nums: list) -> int:\n    total_sum = sum(nums)\n    left_sum = 0\n    for i, num in enumerate(nums):\n        if left_sum == (total_sum - left_sum - num):\n            return i\n        left_sum += num\n    return -1\n```\n\n###Testcases: \n\n```python\nassert find_pivot_index([1, 7, 3, 6, 5, 6]) == 3\nassert find_pivot_index([1, 2, 3]) == -1\nassert find_pivot_index([2, 1, -1]) == 0\nassert find_pivot_index([]) == -1\nassert find_pivot_index([0, 0, 0, 0]) == 0  # The pivot could be any index in this case\n```\n\n[/Example 3]", "temperature": 0.896}, {"few_shots": [{"author": "Calvin", "UUID": "fb94082f-4627-4f5a-b280-08d869823d70", "question": "You are given an array of people, people, which are the attributes of some people in a queue (not necessarily in order). Each people[i] = [hi, ki] represents the ith person of height hi with exactly ki other people in front who have a height greater than or equal to hi.\n\nReconstruct and return the queue that is represented by the input array people. The returned queue should be formatted as an array queue, where queue[j] = [hj, kj] is the attributes of the jth person in the queue (queue[0] is the person at the front of the queue).\n", "examples": "Input:  [[7, 0], [4, 4], [7, 1], [5, 0], [6, 1], [5, 2]]\nOutput: [[5, 0], [4, 1], [7, 0], [5, 2], [6, 1], [7, 1]]\n\nInput:  [[6, 0], [5, 0], [4, 0], [3, 2], [2, 2], [1, 4]]\nOutput: [[4, 0], [5, 0], [2, 2], [3, 2], [1, 4], [6, 0]]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "\ndef reconstructQueue(people: list) -> list:\n    output=[] \n    people.sort(key=lambda x: (-x[0], x[1]))                \n    for a in people:\n        output.insert(a[1], a)\n    \n    return output\n", "asserts": ["assert reconstructQueue([[8,1],[5,0],[6,1],[5,2],[4,4],[7,1]]) == [[5, 0], [8, 1], [5, 2], [6, 1], [4, 4], [7, 1]]", "assert reconstructQueue([[12,0], [6,3], [4,4], [9,2], [7,1]]) == [[12, 0], [7, 1], [9, 2], [6, 3], [4, 4]]", "assert reconstructQueue([[2,0], [1,1]]) == [[2, 0], [1, 1]]", "assert reconstructQueue([[3,0], [3,2], [3,1]]) == [[3, 0], [3, 1], [3, 2]]"]}, {"author": "Calvin", "UUID": "9e45b73f-583d-40ab-b387-e0d1624af07b", "question": "Given two arrays return an array with the set intersection of their common elements", "examples": "Input: arr1 = [1, 2, 3, 4], arr2 = [2, 3]\nOutput: [2, 3]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def array_intersection(arr1: list, arr2: list) -> set:\n  set1 = set(arr1)\n  ret = set([x for x in arr2 if x in set1])\n  return list(ret)\n", "asserts": ["assert set(array_intersection([1,0,2,0,2,0,2,1,1,1], [2,1,0,2,0,2,2,2,1,0])) == {0,1,2}", "assert set(array_intersection([5, 6, 7, 8], [8, 9, 10, 11])) == {8}", "assert set(array_intersection([10, 20, 30], [40, 50, 60])) == set()", "assert set(array_intersection([], [1, 2, 3])) == set()", "assert set(array_intersection([-1, -2, -3], [-3, -4, -5, -6])) == {-3}", "assert set(array_intersection([9, 8, 7], [7, 8, 9, 10, 11, 12])) == {7, 8, 9}", "assert set(array_intersection(['a', 'b', 'c'], ['a', 'd', 'e', 'c'])) == {'a', 'c'}", "assert set(array_intersection(['apple', 'banana'], ['banana', 'cherry'])) == {'banana'}", "assert set(array_intersection([1.1, 2.2, 3.3], [2.2, 4.4])) == {2.2}", "assert set(array_intersection([False, True, False], [True, False, True])) == {True, False}", "assert set(array_intersection([(1, 2), (3, 4)], [(3, 4), (5, 6)])) == {(3, 4)}"]}], "category": "Array", "prompt_tokens": 983, "total_tokens": 1452, "completion_tokens": 469, "completion": "Given an array of integers, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.\n\n###Code: \n\n```python\ndef maxSubArray(nums: list) -> int:\n    max_sum = current_sum = nums[0]\n    for num in nums[1:]:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    return max_sum\n```\n\n###Testcases: \n\n```python\nassert maxSubArray([-2,1,-3,4,-1,2,1,-5,4]) == 6  # [4,-1,2,1] has the largest sum = 6\nassert maxSubArray([1]) == 1                       # [1] has the largest sum = 1\nassert maxSubArray([5,4,-1,7,8]) == 23            # [5,4,-1,7,8] has the largest sum = 23\nassert maxSubArray([-1,-2,-3,-4]) == -1           # [-1] has the largest sum = -1\nassert maxSubArray([0]) == 0                      # [0] has the largest sum = 0\nassert maxSubArray([-2, -1]) == -1                # [-1] has the largest sum = -1\nassert maxSubArray([-2, 1]) == 1                  # [1] has the largest sum = 1\nassert maxSubArray([1, 2, 3, 4]) == 10            # [1, 2, 3, 4] has the largest sum = 10\nassert maxSubArray([-1, 1, 2, 3, -2, 2]) == 6     # [1, 2, 3, -2, 2] has the largest sum = 6\nassert maxSubArray([-2, -3, 4, -1, -2, 1, 5, -3]) == 7  # [4, -1, -2, 1, 5] has the largest sum = 7\n```\n\n[/Example 3]", "temperature": 0.832}, {"few_shots": [{"author": "Calvin", "UUID": "f795bda7-9822-4bc5-9c7e-b9c0f2752085", "question": "You are given two 0-indexed integer permutations A and B of length n.\n\nA prefix common array of A and B is an array C such that C[i] is equal to the count of numbers that are present at or before the index i in both A and B.\n\nReturn the prefix common array of A and B.\n\nA sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once.", "examples": "Input: A = [1,3,2,4], B = [3,1,2,4]\nOutput: [0,2,3,4]", "link": "https://leetcode.com/problems/find-the-prefix-common-array-of-two-arrays/", "difficulty": null, "categories": ["Array"], "code": "def findThePrefixCommonArray(arr1: list, arr2: list) -> list:\n  max = len(arr1) if len(arr1) > len(arr2) else len(arr2)\n  seen = set()\n  curCount = 0\n  ret = []\n  for i in range(max):\n    cur1 = arr1[i]\n    cur2 = arr2[i]\n    if cur1 in seen:\n      curCount += 1\n    else:\n      seen.add(cur1)\n    if cur2 in seen:\n      curCount += 1\n    else:\n      seen.add(cur2)\n    ret.append(curCount)\n  return ret\n", "asserts": ["assert findThePrefixCommonArray([1,3,2,4], [3,1,2,4]) == [0,2,3,4]", "assert findThePrefixCommonArray([1], [1]) == [1]", "assert findThePrefixCommonArray([2,3,1], [3,1,2]) == [0,1,3]"]}, {"author": "Calvin", "UUID": "48c6aa37-e00d-4b55-9afc-6b1cf2a1aff2", "question": "There are N Mice and N holes are placed in a straight line. Each hole can accommodate only 1 mouse. A mouse can stay at his position, move one step right from x to x + 1, or move one step left from x to x -1. Any of these moves consumes 1 minute. Assign mice to holes so that the time when the last mouse gets inside a hole is minimized.\nYou are given a list of mice and hole positions as integer scalers.\n", "examples": "Input: Mices = [0, 10, 2, 3], Holes = [3, 2, 23, 0]\nOutput: 13", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def assignHole(mices: list, holes: list) -> int:\n    for i,j in zip(mices,holes):\n        if i<0 or j<0:\n            return -1\n    if (len(mices) != len(holes)):\n        return -1\n    mices.sort()\n    holes.sort()\n    Max = 0\n     \n    for i in range(len(holes)):\n        if (Max < abs(mices[i] - holes[i])):\n            Max = abs(mices[i] - holes[i])\n     \n    return Max\n", "asserts": ["assert assignHole([1, 2, 3, 4], [4, 3, 2, 1]) == 0", "assert assignHole([10, 20, 30, 40], [15, 25, 35, 45]) == 5", "assert assignHole([1, 4, 9, 15], [10, 13, 7, 20]) == 6", "assert assignHole([0], [0]) == 0", "assert assignHole([1, 2], [3]) == -1  # Edge case with non-equal amount of mice and holes", "assert assignHole([5, 5, 5], [5, 5, 5]) == 0  # Edge case with all mice and holes at the same position", "assert assignHole([10, 10, 10, 10], [10, 9, 8, 7]) == 3  # Edge case with multiple mice starting at the same position", "assert assignHole([1,1 ,1, 1, 1, 1, 1, 1, 1, 1], [2,2,2,2,2,2 ,2, 2, 2, 2]) == 1 # Edge case with multiple mice and holes at the same positions", "assert assignHole([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == 1 # Edge case with incremental positions"]}], "category": "Array", "prompt_tokens": 1103, "total_tokens": 1415, "completion_tokens": 312, "completion": "Write a function that takes an unsorted array consisting of consecutive integers [1, 2, 3, ..., n] without any duplicates. The function should sort the array, but it can only swap the zeroth element with any other element. The goal is to determine the minimum number of swaps necessary to sort the array.\n\n###Code: \n\ndef minSwapsToSort(arr: list) -> int:\n    swaps = 0\n    for i in range(len(arr)):\n        if i+1 != arr[i]:\n            idx_to_swap = arr.index(i + 1, i)\n            arr[i], arr[idx_to_swap] = arr[idx_to_swap], arr[i]\n            swaps += 1\n    return swaps\n\n###Testcases: \n\nassert minSwapsToSort([4, 3, 1, 2]) == 3\nassert minSwapsToSort([1, 5, 4, 3, 2]) == 2\nassert minSwapsToSort([1, 2, 3, 5, 4, 6]) == 1\nassert minSwapsToSort([1, 2, 3]) == 0  # Already sorted\nassert minSwapsToSort([2, 1, 5, 3, 4]) == 3\nassert minSwapsToSort([7, 1, 3, 2, 4, 5, 6]) == 5\n\n[/Example 3]", "temperature": 0.907}, {"few_shots": [{"author": "Calvin", "UUID": "f795bda7-9822-4bc5-9c7e-b9c0f2752085", "question": "You are given two 0-indexed integer permutations A and B of length n.\n\nA prefix common array of A and B is an array C such that C[i] is equal to the count of numbers that are present at or before the index i in both A and B.\n\nReturn the prefix common array of A and B.\n\nA sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once.", "examples": "Input: A = [1,3,2,4], B = [3,1,2,4]\nOutput: [0,2,3,4]", "link": "https://leetcode.com/problems/find-the-prefix-common-array-of-two-arrays/", "difficulty": null, "categories": ["Array"], "code": "def findThePrefixCommonArray(arr1: list, arr2: list) -> list:\n  max = len(arr1) if len(arr1) > len(arr2) else len(arr2)\n  seen = set()\n  curCount = 0\n  ret = []\n  for i in range(max):\n    cur1 = arr1[i]\n    cur2 = arr2[i]\n    if cur1 in seen:\n      curCount += 1\n    else:\n      seen.add(cur1)\n    if cur2 in seen:\n      curCount += 1\n    else:\n      seen.add(cur2)\n    ret.append(curCount)\n  return ret\n", "asserts": ["assert findThePrefixCommonArray([1,3,2,4], [3,1,2,4]) == [0,2,3,4]", "assert findThePrefixCommonArray([1], [1]) == [1]", "assert findThePrefixCommonArray([2,3,1], [3,1,2]) == [0,1,3]"]}, {"author": "Calvin", "UUID": "1aeb3246-4c22-4d34-a48c-db7be8ba1b94", "question": "You are given n activities with their start and finish times. Select the maximum number of activities that can be performed by a single person and return their indexes. Assume that a person can only work on a single activity at a time. \n", "examples": "Input: start  =  {10, 12, 20}, finish =  {20, 25, 30}\nOutput: [0, 2]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "import numpy as np\ndef MaxActivities(s: list, f: list) -> list:\n    indices = np.argsort(f)\n    [s[i] for i in indices]\n    [f[i] for i in indices]\n    result = []\n    n = len(f)\n    i = 0\n    result.append(i)\n    for j in range(1, n):\n        if s[j] >= f[i]:\n            result.append(j)\n            i = j\n    return result\n", "asserts": ["assert MaxActivities([2, 4, 5, 6, 7, 8], [3, 5, 6, 7, 9, 10]) == [0, 1, 2, 3, 4]", "assert MaxActivities([1, 3, 0, 5, 8, 5], [2, 4, 6, 7, 9, 9]) == [0, 1, 3, 4]", "assert MaxActivities([1], [2]) == [0]"]}], "category": "Array", "prompt_tokens": 782, "total_tokens": 1080, "completion_tokens": 298, "completion": "Given an array of integers and a target value, find all unique combinations of array elements where the elements sum to the target value. Each number in the array may only be used once in the combination. Return a list of all unique combinations. Note that the combinations can be in any order.\n\n###Code:\n\ndef combinationSum2(candidates: list, target: int) -> list:\n    def backtrack(start, end, target, path):\n        if target == 0:\n            results.append(list(path))\n            return\n        if target < 0:\n            return\n        prev = -1\n        for i in range(start, end):\n            if candidates[i] == prev:\n                continue\n            path.append(candidates[i])\n            backtrack(i+1, end, target-candidates[i], path)\n            path.pop()\n            prev = candidates[i]\n    \n    candidates.sort()\n    results = []\n    backtrack(0, len(candidates), target, [])\n    return results\n\n###Testcases:\n\nassert combinationSum2([10,1,2,7,6,1,5], 8) == [[1,1,6],[1,2,5],[1,7],[2,6]]\nassert combinationSum2([2,5,2,1,2], 5) == [[1,2,2],[5]]\nassert combinationSum2([2,3,6,7], 7) == [[7]]\n\n[/Example 3]", "temperature": 0.733}, {"few_shots": [{"author": "Calvin", "UUID": "fb94082f-4627-4f5a-b280-08d869823d70", "question": "You are given an array of people, people, which are the attributes of some people in a queue (not necessarily in order). Each people[i] = [hi, ki] represents the ith person of height hi with exactly ki other people in front who have a height greater than or equal to hi.\n\nReconstruct and return the queue that is represented by the input array people. The returned queue should be formatted as an array queue, where queue[j] = [hj, kj] is the attributes of the jth person in the queue (queue[0] is the person at the front of the queue).\n", "examples": "Input:  [[7, 0], [4, 4], [7, 1], [5, 0], [6, 1], [5, 2]]\nOutput: [[5, 0], [4, 1], [7, 0], [5, 2], [6, 1], [7, 1]]\n\nInput:  [[6, 0], [5, 0], [4, 0], [3, 2], [2, 2], [1, 4]]\nOutput: [[4, 0], [5, 0], [2, 2], [3, 2], [1, 4], [6, 0]]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "\ndef reconstructQueue(people: list) -> list:\n    output=[] \n    people.sort(key=lambda x: (-x[0], x[1]))                \n    for a in people:\n        output.insert(a[1], a)\n    \n    return output\n", "asserts": ["assert reconstructQueue([[8,1],[5,0],[6,1],[5,2],[4,4],[7,1]]) == [[5, 0], [8, 1], [5, 2], [6, 1], [4, 4], [7, 1]]", "assert reconstructQueue([[12,0], [6,3], [4,4], [9,2], [7,1]]) == [[12, 0], [7, 1], [9, 2], [6, 3], [4, 4]]", "assert reconstructQueue([[2,0], [1,1]]) == [[2, 0], [1, 1]]", "assert reconstructQueue([[3,0], [3,2], [3,1]]) == [[3, 0], [3, 1], [3, 2]]"]}, {"author": "Calvin", "UUID": "a9c5e697-af5d-432b-8447-5675d739c728", "question": "Given an array reorder it so that even numbers appear first", "examples": "Input: [1,2,3,4,5,6,7,8,9]\r\nOutput: [8,2,6,4,5,7,3,9,1]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def even_odd_reorder(arr: list) -> list:\n  nextEven = 0\n  nextOdd = len(arr) - 1\n  while nextEven < nextOdd:\n    if arr[nextEven] % 2 == 0:\n      nextEven += 1\n    else:\n      temp = arr[nextEven]\n      arr[nextEven] = arr[nextOdd]\n      arr[nextOdd] = temp\n      nextOdd -= 1\n  return arr\n", "asserts": ["assert even_odd_reorder([1,2,3,4,5,6,7,8,9]) == [8, 2, 6, 4, 5, 7, 3, 9, 1]", "assert even_odd_reorder([]) == []", "assert even_odd_reorder([2, 4, 6, 8]) == [2, 4, 6, 8]", "assert even_odd_reorder([7, 9, 2]) == [2, 9, 7]", "assert even_odd_reorder([10, 13, 17, 16, 15, 12]) == [10, 12, 16, 15, 17, 13]"]}], "category": "Array", "prompt_tokens": 842, "total_tokens": 1099, "completion_tokens": 257, "completion": "Write a function that takes an array of integers and returns the length of the longest subsequence where the difference between consecutive integers is one. A subsequence is a sequence that can be derived from an array by deleting some or no elements without changing the order of the remaining elements.\n\n###Code: \n\ndef longestSubsequence(arr: list) -> int:\n    number_dict = {}\n    longest = 0\n    for number in arr:\n        left = number_dict.get(number - 1, 0)\n        right = number_dict.get(number + 1, 0)\n        length = 1 + max(left, right)\n        number_dict[number] = length\n        longest = max(longest, length)\n    return longest\n\n###Testcases: \n\nassert longestSubsequence([1,2,3,4,5,6]) == 6\nassert longestSubsequence([1,3,2,7,8,4]) == 4\nassert longestSubsequence([8,9,1,2,3,1]) == 3\nassert longestSubsequence([100, 4, 200, 1, 3, 2]) == 4\nassert longestSubsequence([1]) == 1\n\n[/Example 3]", "temperature": 0.726}, {"few_shots": [{"author": "Calvin", "UUID": "f795bda7-9822-4bc5-9c7e-b9c0f2752085", "question": "You are given two 0-indexed integer permutations A and B of length n.\n\nA prefix common array of A and B is an array C such that C[i] is equal to the count of numbers that are present at or before the index i in both A and B.\n\nReturn the prefix common array of A and B.\n\nA sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once.", "examples": "Input: A = [1,3,2,4], B = [3,1,2,4]\nOutput: [0,2,3,4]", "link": "https://leetcode.com/problems/find-the-prefix-common-array-of-two-arrays/", "difficulty": null, "categories": ["Array"], "code": "def findThePrefixCommonArray(arr1: list, arr2: list) -> list:\n  max = len(arr1) if len(arr1) > len(arr2) else len(arr2)\n  seen = set()\n  curCount = 0\n  ret = []\n  for i in range(max):\n    cur1 = arr1[i]\n    cur2 = arr2[i]\n    if cur1 in seen:\n      curCount += 1\n    else:\n      seen.add(cur1)\n    if cur2 in seen:\n      curCount += 1\n    else:\n      seen.add(cur2)\n    ret.append(curCount)\n  return ret\n", "asserts": ["assert findThePrefixCommonArray([1,3,2,4], [3,1,2,4]) == [0,2,3,4]", "assert findThePrefixCommonArray([1], [1]) == [1]", "assert findThePrefixCommonArray([2,3,1], [3,1,2]) == [0,1,3]"]}, {"author": "Calvin", "UUID": "fb94082f-4627-4f5a-b280-08d869823d70", "question": "You are given an array of people, people, which are the attributes of some people in a queue (not necessarily in order). Each people[i] = [hi, ki] represents the ith person of height hi with exactly ki other people in front who have a height greater than or equal to hi.\n\nReconstruct and return the queue that is represented by the input array people. The returned queue should be formatted as an array queue, where queue[j] = [hj, kj] is the attributes of the jth person in the queue (queue[0] is the person at the front of the queue).\n", "examples": "Input:  [[7, 0], [4, 4], [7, 1], [5, 0], [6, 1], [5, 2]]\nOutput: [[5, 0], [4, 1], [7, 0], [5, 2], [6, 1], [7, 1]]\n\nInput:  [[6, 0], [5, 0], [4, 0], [3, 2], [2, 2], [1, 4]]\nOutput: [[4, 0], [5, 0], [2, 2], [3, 2], [1, 4], [6, 0]]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "\ndef reconstructQueue(people: list) -> list:\n    output=[] \n    people.sort(key=lambda x: (-x[0], x[1]))                \n    for a in people:\n        output.insert(a[1], a)\n    \n    return output\n", "asserts": ["assert reconstructQueue([[8,1],[5,0],[6,1],[5,2],[4,4],[7,1]]) == [[5, 0], [8, 1], [5, 2], [6, 1], [4, 4], [7, 1]]", "assert reconstructQueue([[12,0], [6,3], [4,4], [9,2], [7,1]]) == [[12, 0], [7, 1], [9, 2], [6, 3], [4, 4]]", "assert reconstructQueue([[2,0], [1,1]]) == [[2, 0], [1, 1]]", "assert reconstructQueue([[3,0], [3,2], [3,1]]) == [[3, 0], [3, 1], [3, 2]]"]}], "category": "Array", "prompt_tokens": 878, "total_tokens": 1118, "completion_tokens": 240, "completion": "You are given an array `prices` where `prices[i]` is the price of a given stock on the ith day, and an integer `fee` representing a transaction fee.\n\nFind the maximum profit you can achieve. You may complete as many transactions as you like, but you need to pay the transaction fee for each transaction. Note: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).\n\n###Code:\n\n```python\ndef maxProfit(prices: list, fee: int) -> int:\n    cash, hold = 0, -prices[0]\n    for i in range(1, len(prices)):\n        cash = max(cash, hold + prices[i] - fee)\n        hold = max(hold, cash - prices[i])\n    return cash\n```\n\n###Testcases:\n\n```python\nassert maxProfit([1, 3, 2, 8, 4, 9], 2) == 8\nassert maxProfit([1, 3, 7, 5, 10, 3], 3) == 6\n```\n\n[/Example 3]", "temperature": 0.883}, {"few_shots": [{"author": "Calvin", "UUID": "48c6aa37-e00d-4b55-9afc-6b1cf2a1aff2", "question": "There are N Mice and N holes are placed in a straight line. Each hole can accommodate only 1 mouse. A mouse can stay at his position, move one step right from x to x + 1, or move one step left from x to x -1. Any of these moves consumes 1 minute. Assign mice to holes so that the time when the last mouse gets inside a hole is minimized.\nYou are given a list of mice and hole positions as integer scalers.\n", "examples": "Input: Mices = [0, 10, 2, 3], Holes = [3, 2, 23, 0]\nOutput: 13", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def assignHole(mices: list, holes: list) -> int:\n    for i,j in zip(mices,holes):\n        if i<0 or j<0:\n            return -1\n    if (len(mices) != len(holes)):\n        return -1\n    mices.sort()\n    holes.sort()\n    Max = 0\n     \n    for i in range(len(holes)):\n        if (Max < abs(mices[i] - holes[i])):\n            Max = abs(mices[i] - holes[i])\n     \n    return Max\n", "asserts": ["assert assignHole([1, 2, 3, 4], [4, 3, 2, 1]) == 0", "assert assignHole([10, 20, 30, 40], [15, 25, 35, 45]) == 5", "assert assignHole([1, 4, 9, 15], [10, 13, 7, 20]) == 6", "assert assignHole([0], [0]) == 0", "assert assignHole([1, 2], [3]) == -1  # Edge case with non-equal amount of mice and holes", "assert assignHole([5, 5, 5], [5, 5, 5]) == 0  # Edge case with all mice and holes at the same position", "assert assignHole([10, 10, 10, 10], [10, 9, 8, 7]) == 3  # Edge case with multiple mice starting at the same position", "assert assignHole([1,1 ,1, 1, 1, 1, 1, 1, 1, 1], [2,2,2,2,2,2 ,2, 2, 2, 2]) == 1 # Edge case with multiple mice and holes at the same positions", "assert assignHole([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == 1 # Edge case with incremental positions"]}, {"author": "Calvin", "UUID": "9e45b73f-583d-40ab-b387-e0d1624af07b", "question": "Given two arrays return an array with the set intersection of their common elements", "examples": "Input: arr1 = [1, 2, 3, 4], arr2 = [2, 3]\nOutput: [2, 3]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def array_intersection(arr1: list, arr2: list) -> set:\n  set1 = set(arr1)\n  ret = set([x for x in arr2 if x in set1])\n  return list(ret)\n", "asserts": ["assert set(array_intersection([1,0,2,0,2,0,2,1,1,1], [2,1,0,2,0,2,2,2,1,0])) == {0,1,2}", "assert set(array_intersection([5, 6, 7, 8], [8, 9, 10, 11])) == {8}", "assert set(array_intersection([10, 20, 30], [40, 50, 60])) == set()", "assert set(array_intersection([], [1, 2, 3])) == set()", "assert set(array_intersection([-1, -2, -3], [-3, -4, -5, -6])) == {-3}", "assert set(array_intersection([9, 8, 7], [7, 8, 9, 10, 11, 12])) == {7, 8, 9}", "assert set(array_intersection(['a', 'b', 'c'], ['a', 'd', 'e', 'c'])) == {'a', 'c'}", "assert set(array_intersection(['apple', 'banana'], ['banana', 'cherry'])) == {'banana'}", "assert set(array_intersection([1.1, 2.2, 3.3], [2.2, 4.4])) == {2.2}", "assert set(array_intersection([False, True, False], [True, False, True])) == {True, False}", "assert set(array_intersection([(1, 2), (3, 4)], [(3, 4), (5, 6)])) == {(3, 4)}"]}], "category": "Array", "prompt_tokens": 1208, "total_tokens": 1644, "completion_tokens": 436, "completion": "Given an array of integers, find all pairs of elements that sum up to a specific target number. Return a list of pairs, each pair represented as a tuple.\n\n###Code: \n\ndef two_sum_pairs(arr: list, target: int) -> list:\n    seen = {}\n    pairs = []\n    for num in arr:\n        if target - num in seen:\n            pairs.append((target - num, num))\n        seen[num] = True\n    return pairs\n\n###Testcases: \n\nassert two_sum_pairs([1, 2, 3, 4, 5], 5) == [(2, 3), (1, 4)]\nassert two_sum_pairs([10, -1, 1, 0, 2, -2, -10], 0) == [(10, -10), (-1, 1), (2, -2)]\nassert two_sum_pairs([1, 1, 1, 1], 2) == [(1, 1), (1, 1), (1, 1)]\nassert two_sum_pairs([5, 5, 3, 0, -2, 3, -5], 3) == [(0, 3), (-2, 5), (0, 3), (-2, 5), (-5, 8)]\nassert two_sum_pairs([0, 2, 4, 6, 8, 10], 7) == []\nassert two_sum_pairs([], 100) == []\nassert two_sum_pairs([50], 100) == []\nassert two_sum_pairs([-3, -1, 1, 2, 5, 7], 4) == [(-1, 5), (1, 3)]\nassert two_sum_pairs([100, 200, 300, 400], 500) == [(100, 400), (200, 300)]\nassert two_sum_pairs([1, 5, 7, -1], 6) == [(1, 5), (7, -1)]\n\n[/Example 3]", "temperature": 0.669}, {"few_shots": [{"author": "Calvin", "UUID": "9e45b73f-583d-40ab-b387-e0d1624af07b", "question": "Given two arrays return an array with the set intersection of their common elements", "examples": "Input: arr1 = [1, 2, 3, 4], arr2 = [2, 3]\nOutput: [2, 3]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def array_intersection(arr1: list, arr2: list) -> set:\n  set1 = set(arr1)\n  ret = set([x for x in arr2 if x in set1])\n  return list(ret)\n", "asserts": ["assert set(array_intersection([1,0,2,0,2,0,2,1,1,1], [2,1,0,2,0,2,2,2,1,0])) == {0,1,2}", "assert set(array_intersection([5, 6, 7, 8], [8, 9, 10, 11])) == {8}", "assert set(array_intersection([10, 20, 30], [40, 50, 60])) == set()", "assert set(array_intersection([], [1, 2, 3])) == set()", "assert set(array_intersection([-1, -2, -3], [-3, -4, -5, -6])) == {-3}", "assert set(array_intersection([9, 8, 7], [7, 8, 9, 10, 11, 12])) == {7, 8, 9}", "assert set(array_intersection(['a', 'b', 'c'], ['a', 'd', 'e', 'c'])) == {'a', 'c'}", "assert set(array_intersection(['apple', 'banana'], ['banana', 'cherry'])) == {'banana'}", "assert set(array_intersection([1.1, 2.2, 3.3], [2.2, 4.4])) == {2.2}", "assert set(array_intersection([False, True, False], [True, False, True])) == {True, False}", "assert set(array_intersection([(1, 2), (3, 4)], [(3, 4), (5, 6)])) == {(3, 4)}"]}, {"author": "Calvin", "UUID": "fb94082f-4627-4f5a-b280-08d869823d70", "question": "You are given an array of people, people, which are the attributes of some people in a queue (not necessarily in order). Each people[i] = [hi, ki] represents the ith person of height hi with exactly ki other people in front who have a height greater than or equal to hi.\n\nReconstruct and return the queue that is represented by the input array people. The returned queue should be formatted as an array queue, where queue[j] = [hj, kj] is the attributes of the jth person in the queue (queue[0] is the person at the front of the queue).\n", "examples": "Input:  [[7, 0], [4, 4], [7, 1], [5, 0], [6, 1], [5, 2]]\nOutput: [[5, 0], [4, 1], [7, 0], [5, 2], [6, 1], [7, 1]]\n\nInput:  [[6, 0], [5, 0], [4, 0], [3, 2], [2, 2], [1, 4]]\nOutput: [[4, 0], [5, 0], [2, 2], [3, 2], [1, 4], [6, 0]]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "\ndef reconstructQueue(people: list) -> list:\n    output=[] \n    people.sort(key=lambda x: (-x[0], x[1]))                \n    for a in people:\n        output.insert(a[1], a)\n    \n    return output\n", "asserts": ["assert reconstructQueue([[8,1],[5,0],[6,1],[5,2],[4,4],[7,1]]) == [[5, 0], [8, 1], [5, 2], [6, 1], [4, 4], [7, 1]]", "assert reconstructQueue([[12,0], [6,3], [4,4], [9,2], [7,1]]) == [[12, 0], [7, 1], [9, 2], [6, 3], [4, 4]]", "assert reconstructQueue([[2,0], [1,1]]) == [[2, 0], [1, 1]]", "assert reconstructQueue([[3,0], [3,2], [3,1]]) == [[3, 0], [3, 1], [3, 2]]"]}], "category": "Array", "prompt_tokens": 983, "total_tokens": 1310, "completion_tokens": 327, "completion": "Given an array of integers, write a function that moves all zeros to the end of it while maintaining the relative order of the non-zero elements.\n\n###Code: \n\ndef move_zeros(arr: list) -> list:\n    non_zero = [x for x in arr if x != 0]\n    zeros = [0] * (len(arr) - len(non_zero))\n    return non_zero + zeros\n\n###Testcases: \n\nassert move_zeros([0,1,0,3,12]) == [1,3,12,0,0]\nassert move_zeros([0,0,1]) == [1,0,0]\nassert move_zeros([4,2,4,0,0,3,0,5,1,0]) == [4,2,4,3,5,1,0,0,0,0]\nassert move_zeros([1,7,3,0,0,9,0]) == [1,7,3,9,0,0,0]\nassert move_zeros([0,0,0]) == [0,0,0]\nassert move_zeros([1,2,3,4,5]) == [1,2,3,4,5]\nassert move_zeros([]) == []\nassert move_zeros([0,-1,0,-3,12]) == [-1,-3,12,0,0]\nassert move_zeros([-1,0,0,0,3,0,-7]) == [-1,3,-7,0,0,0,0]\n\n[/Example 3]", "temperature": 0.699}, {"few_shots": [{"author": "Calvin", "UUID": "f795bda7-9822-4bc5-9c7e-b9c0f2752085", "question": "You are given two 0-indexed integer permutations A and B of length n.\n\nA prefix common array of A and B is an array C such that C[i] is equal to the count of numbers that are present at or before the index i in both A and B.\n\nReturn the prefix common array of A and B.\n\nA sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once.", "examples": "Input: A = [1,3,2,4], B = [3,1,2,4]\nOutput: [0,2,3,4]", "link": "https://leetcode.com/problems/find-the-prefix-common-array-of-two-arrays/", "difficulty": null, "categories": ["Array"], "code": "def findThePrefixCommonArray(arr1: list, arr2: list) -> list:\n  max = len(arr1) if len(arr1) > len(arr2) else len(arr2)\n  seen = set()\n  curCount = 0\n  ret = []\n  for i in range(max):\n    cur1 = arr1[i]\n    cur2 = arr2[i]\n    if cur1 in seen:\n      curCount += 1\n    else:\n      seen.add(cur1)\n    if cur2 in seen:\n      curCount += 1\n    else:\n      seen.add(cur2)\n    ret.append(curCount)\n  return ret\n", "asserts": ["assert findThePrefixCommonArray([1,3,2,4], [3,1,2,4]) == [0,2,3,4]", "assert findThePrefixCommonArray([1], [1]) == [1]", "assert findThePrefixCommonArray([2,3,1], [3,1,2]) == [0,1,3]"]}, {"author": "Calvin", "UUID": "9e45b73f-583d-40ab-b387-e0d1624af07b", "question": "Given two arrays return an array with the set intersection of their common elements", "examples": "Input: arr1 = [1, 2, 3, 4], arr2 = [2, 3]\nOutput: [2, 3]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def array_intersection(arr1: list, arr2: list) -> set:\n  set1 = set(arr1)\n  ret = set([x for x in arr2 if x in set1])\n  return list(ret)\n", "asserts": ["assert set(array_intersection([1,0,2,0,2,0,2,1,1,1], [2,1,0,2,0,2,2,2,1,0])) == {0,1,2}", "assert set(array_intersection([5, 6, 7, 8], [8, 9, 10, 11])) == {8}", "assert set(array_intersection([10, 20, 30], [40, 50, 60])) == set()", "assert set(array_intersection([], [1, 2, 3])) == set()", "assert set(array_intersection([-1, -2, -3], [-3, -4, -5, -6])) == {-3}", "assert set(array_intersection([9, 8, 7], [7, 8, 9, 10, 11, 12])) == {7, 8, 9}", "assert set(array_intersection(['a', 'b', 'c'], ['a', 'd', 'e', 'c'])) == {'a', 'c'}", "assert set(array_intersection(['apple', 'banana'], ['banana', 'cherry'])) == {'banana'}", "assert set(array_intersection([1.1, 2.2, 3.3], [2.2, 4.4])) == {2.2}", "assert set(array_intersection([False, True, False], [True, False, True])) == {True, False}", "assert set(array_intersection([(1, 2), (3, 4)], [(3, 4), (5, 6)])) == {(3, 4)}"]}], "category": "Array", "prompt_tokens": 922, "total_tokens": 1252, "completion_tokens": 330, "completion": "Given an array of integers, implement a function that returns a new array containing each element of the original array squared, and sorted in non-decreasing order.\n\n###Code: \n\ndef sorted_squared_array(arr: list) -> list:\n    return sorted([x*x for x in arr])\n\n###Testcases: \n\nassert sorted_squared_array([-4, -1, 0, 3, 10]) == [0, 1, 9, 16, 100]\nassert sorted_squared_array([-7, -3, 2, 3, 11]) == [4, 9, 9, 49, 121]\nassert sorted_squared_array([1, 2, 3, 4, 5]) == [1, 4, 9, 16, 25]\nassert sorted_squared_array([-5, -4, -3, -2, -1]) == [1, 4, 9, 16, 25]\nassert sorted_squared_array([0, 0, 0, 0, 0]) == [0, 0, 0, 0, 0]\nassert sorted_squared_array([-1, 0, 1]) == [0, 1, 1]\nassert sorted_squared_array([]) == []\nassert sorted_squared_array([10]) == [100]\nassert sorted_squared_array([-10]) == [100]\nassert sorted_squared_array([-2, -1, 0, 1, 2]) == [0, 1, 1, 4, 4]\n\n[/Example 3]", "temperature": 0.709}, {"few_shots": [{"author": "Calvin", "UUID": "fb94082f-4627-4f5a-b280-08d869823d70", "question": "You are given an array of people, people, which are the attributes of some people in a queue (not necessarily in order). Each people[i] = [hi, ki] represents the ith person of height hi with exactly ki other people in front who have a height greater than or equal to hi.\n\nReconstruct and return the queue that is represented by the input array people. The returned queue should be formatted as an array queue, where queue[j] = [hj, kj] is the attributes of the jth person in the queue (queue[0] is the person at the front of the queue).\n", "examples": "Input:  [[7, 0], [4, 4], [7, 1], [5, 0], [6, 1], [5, 2]]\nOutput: [[5, 0], [4, 1], [7, 0], [5, 2], [6, 1], [7, 1]]\n\nInput:  [[6, 0], [5, 0], [4, 0], [3, 2], [2, 2], [1, 4]]\nOutput: [[4, 0], [5, 0], [2, 2], [3, 2], [1, 4], [6, 0]]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "\ndef reconstructQueue(people: list) -> list:\n    output=[] \n    people.sort(key=lambda x: (-x[0], x[1]))                \n    for a in people:\n        output.insert(a[1], a)\n    \n    return output\n", "asserts": ["assert reconstructQueue([[8,1],[5,0],[6,1],[5,2],[4,4],[7,1]]) == [[5, 0], [8, 1], [5, 2], [6, 1], [4, 4], [7, 1]]", "assert reconstructQueue([[12,0], [6,3], [4,4], [9,2], [7,1]]) == [[12, 0], [7, 1], [9, 2], [6, 3], [4, 4]]", "assert reconstructQueue([[2,0], [1,1]]) == [[2, 0], [1, 1]]", "assert reconstructQueue([[3,0], [3,2], [3,1]]) == [[3, 0], [3, 1], [3, 2]]"]}, {"author": "Calvin", "UUID": "f795bda7-9822-4bc5-9c7e-b9c0f2752085", "question": "You are given two 0-indexed integer permutations A and B of length n.\n\nA prefix common array of A and B is an array C such that C[i] is equal to the count of numbers that are present at or before the index i in both A and B.\n\nReturn the prefix common array of A and B.\n\nA sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once.", "examples": "Input: A = [1,3,2,4], B = [3,1,2,4]\nOutput: [0,2,3,4]", "link": "https://leetcode.com/problems/find-the-prefix-common-array-of-two-arrays/", "difficulty": null, "categories": ["Array"], "code": "def findThePrefixCommonArray(arr1: list, arr2: list) -> list:\n  max = len(arr1) if len(arr1) > len(arr2) else len(arr2)\n  seen = set()\n  curCount = 0\n  ret = []\n  for i in range(max):\n    cur1 = arr1[i]\n    cur2 = arr2[i]\n    if cur1 in seen:\n      curCount += 1\n    else:\n      seen.add(cur1)\n    if cur2 in seen:\n      curCount += 1\n    else:\n      seen.add(cur2)\n    ret.append(curCount)\n  return ret\n", "asserts": ["assert findThePrefixCommonArray([1,3,2,4], [3,1,2,4]) == [0,2,3,4]", "assert findThePrefixCommonArray([1], [1]) == [1]", "assert findThePrefixCommonArray([2,3,1], [3,1,2]) == [0,1,3]"]}], "category": "Array", "prompt_tokens": 878, "total_tokens": 1180, "completion_tokens": 302, "completion": "Given a non-empty array of integers nums, write a function that moves all 0's to the end of it while maintaining the relative order of the non-zero elements.\n\nYou must do this in-place without making a copy of the array and minimize the total number of operations.\n\n###Code: \n\ndef moveZeroesToEnd(nums: list) -> None:\n    zero_position = 0  \n    for i in range(len(nums)):\n        if nums[i] != 0:\n            nums[i], nums[zero_position] = nums[zero_position], nums[i]\n            zero_position += 1\n\n###Testcases: \n\nassert (a:=moveZeroesToEnd([0,1,0,3,12])) is None and a is None, a\nassert (a:=[0,1,0,3,12]) is None or (moveZeroesToEnd(a), a) == (None, [1,3,12,0,0]), a\nassert (a:=[0,0,1]) is None or (moveZeroesToEnd(a), a) == (None, [1,0,0]), a\nassert (a:=[4,2,4,0,0,3,0,5,1,0]) is None or (moveZeroesToEnd(a), a) == (None, [4,2,4,3,5,1,0,0,0,0]), a\n\n[/Example 3]", "temperature": 0.682}, {"few_shots": [{"author": "Calvin", "UUID": "9e45b73f-583d-40ab-b387-e0d1624af07b", "question": "Given two arrays return an array with the set intersection of their common elements", "examples": "Input: arr1 = [1, 2, 3, 4], arr2 = [2, 3]\nOutput: [2, 3]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def array_intersection(arr1: list, arr2: list) -> set:\n  set1 = set(arr1)\n  ret = set([x for x in arr2 if x in set1])\n  return list(ret)\n", "asserts": ["assert set(array_intersection([1,0,2,0,2,0,2,1,1,1], [2,1,0,2,0,2,2,2,1,0])) == {0,1,2}", "assert set(array_intersection([5, 6, 7, 8], [8, 9, 10, 11])) == {8}", "assert set(array_intersection([10, 20, 30], [40, 50, 60])) == set()", "assert set(array_intersection([], [1, 2, 3])) == set()", "assert set(array_intersection([-1, -2, -3], [-3, -4, -5, -6])) == {-3}", "assert set(array_intersection([9, 8, 7], [7, 8, 9, 10, 11, 12])) == {7, 8, 9}", "assert set(array_intersection(['a', 'b', 'c'], ['a', 'd', 'e', 'c'])) == {'a', 'c'}", "assert set(array_intersection(['apple', 'banana'], ['banana', 'cherry'])) == {'banana'}", "assert set(array_intersection([1.1, 2.2, 3.3], [2.2, 4.4])) == {2.2}", "assert set(array_intersection([False, True, False], [True, False, True])) == {True, False}", "assert set(array_intersection([(1, 2), (3, 4)], [(3, 4), (5, 6)])) == {(3, 4)}"]}, {"author": "Calvin", "UUID": "a9c5e697-af5d-432b-8447-5675d739c728", "question": "Given an array reorder it so that even numbers appear first", "examples": "Input: [1,2,3,4,5,6,7,8,9]\r\nOutput: [8,2,6,4,5,7,3,9,1]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def even_odd_reorder(arr: list) -> list:\n  nextEven = 0\n  nextOdd = len(arr) - 1\n  while nextEven < nextOdd:\n    if arr[nextEven] % 2 == 0:\n      nextEven += 1\n    else:\n      temp = arr[nextEven]\n      arr[nextEven] = arr[nextOdd]\n      arr[nextOdd] = temp\n      nextOdd -= 1\n  return arr\n", "asserts": ["assert even_odd_reorder([1,2,3,4,5,6,7,8,9]) == [8, 2, 6, 4, 5, 7, 3, 9, 1]", "assert even_odd_reorder([]) == []", "assert even_odd_reorder([2, 4, 6, 8]) == [2, 4, 6, 8]", "assert even_odd_reorder([7, 9, 2]) == [2, 9, 7]", "assert even_odd_reorder([10, 13, 17, 16, 15, 12]) == [10, 12, 16, 15, 17, 13]"]}], "category": "Array", "prompt_tokens": 886, "total_tokens": 1276, "completion_tokens": 390, "completion": "Given an array of integers, return a new array where each element at index `i` of the new array is the product of all the numbers in the original array except the one at `i`.\n\n###Code:\n\n```python\ndef product_except_self(nums: list) -> list:\n    length = len(nums)\n    answer = [0]*length\n    \n    # answer[i] contains the product of all the elements to the left of i\n    answer[0] = 1\n    for i in range(1, length):\n        answer[i] = nums[i - 1] * answer[i - 1]\n    \n    # R contains the product of all the elements to the right\n    R = 1\n    for i in reversed(range(length)):\n        # for the index 'i', R would contain the\n        # product of all elements to the right. We update R accordingly\n        answer[i] *= R\n        R *= nums[i]\n        \n    return answer\n```\n\n###Testcases:\n\n```python\nassert product_except_self([1, 2, 3, 4]) == [24, 12, 8, 6]\nassert product_except_self([0, 0]) == [0, 0]\nassert product_except_self([1, 0]) == [0, 1]\nassert product_except_self([-1, 1, -1, 1]) == [1, -1, 1, -1]\nassert product_except_self([1, 1, 1, 1]) == [1, 1, 1, 1]\nassert product_except_self([1, -1, 2, -2]) == [4, -4, 2, -2]\nassert product_except_self([3, 2, 1]) == [2, 3, 6]\n```\n\n[/Example 3]", "temperature": 0.82}, {"few_shots": [{"author": "Calvin", "UUID": "48c6aa37-e00d-4b55-9afc-6b1cf2a1aff2", "question": "There are N Mice and N holes are placed in a straight line. Each hole can accommodate only 1 mouse. A mouse can stay at his position, move one step right from x to x + 1, or move one step left from x to x -1. Any of these moves consumes 1 minute. Assign mice to holes so that the time when the last mouse gets inside a hole is minimized.\nYou are given a list of mice and hole positions as integer scalers.\n", "examples": "Input: Mices = [0, 10, 2, 3], Holes = [3, 2, 23, 0]\nOutput: 13", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def assignHole(mices: list, holes: list) -> int:\n    for i,j in zip(mices,holes):\n        if i<0 or j<0:\n            return -1\n    if (len(mices) != len(holes)):\n        return -1\n    mices.sort()\n    holes.sort()\n    Max = 0\n     \n    for i in range(len(holes)):\n        if (Max < abs(mices[i] - holes[i])):\n            Max = abs(mices[i] - holes[i])\n     \n    return Max\n", "asserts": ["assert assignHole([1, 2, 3, 4], [4, 3, 2, 1]) == 0", "assert assignHole([10, 20, 30, 40], [15, 25, 35, 45]) == 5", "assert assignHole([1, 4, 9, 15], [10, 13, 7, 20]) == 6", "assert assignHole([0], [0]) == 0", "assert assignHole([1, 2], [3]) == -1  # Edge case with non-equal amount of mice and holes", "assert assignHole([5, 5, 5], [5, 5, 5]) == 0  # Edge case with all mice and holes at the same position", "assert assignHole([10, 10, 10, 10], [10, 9, 8, 7]) == 3  # Edge case with multiple mice starting at the same position", "assert assignHole([1,1 ,1, 1, 1, 1, 1, 1, 1, 1], [2,2,2,2,2,2 ,2, 2, 2, 2]) == 1 # Edge case with multiple mice and holes at the same positions", "assert assignHole([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == 1 # Edge case with incremental positions"]}, {"author": "Calvin", "UUID": "fb94082f-4627-4f5a-b280-08d869823d70", "question": "You are given an array of people, people, which are the attributes of some people in a queue (not necessarily in order). Each people[i] = [hi, ki] represents the ith person of height hi with exactly ki other people in front who have a height greater than or equal to hi.\n\nReconstruct and return the queue that is represented by the input array people. The returned queue should be formatted as an array queue, where queue[j] = [hj, kj] is the attributes of the jth person in the queue (queue[0] is the person at the front of the queue).\n", "examples": "Input:  [[7, 0], [4, 4], [7, 1], [5, 0], [6, 1], [5, 2]]\nOutput: [[5, 0], [4, 1], [7, 0], [5, 2], [6, 1], [7, 1]]\n\nInput:  [[6, 0], [5, 0], [4, 0], [3, 2], [2, 2], [1, 4]]\nOutput: [[4, 0], [5, 0], [2, 2], [3, 2], [1, 4], [6, 0]]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "\ndef reconstructQueue(people: list) -> list:\n    output=[] \n    people.sort(key=lambda x: (-x[0], x[1]))                \n    for a in people:\n        output.insert(a[1], a)\n    \n    return output\n", "asserts": ["assert reconstructQueue([[8,1],[5,0],[6,1],[5,2],[4,4],[7,1]]) == [[5, 0], [8, 1], [5, 2], [6, 1], [4, 4], [7, 1]]", "assert reconstructQueue([[12,0], [6,3], [4,4], [9,2], [7,1]]) == [[12, 0], [7, 1], [9, 2], [6, 3], [4, 4]]", "assert reconstructQueue([[2,0], [1,1]]) == [[2, 0], [1, 1]]", "assert reconstructQueue([[3,0], [3,2], [3,1]]) == [[3, 0], [3, 1], [3, 2]]"]}], "category": "Array", "prompt_tokens": 1164, "total_tokens": 1512, "completion_tokens": 348, "completion": "Given an array of integers nums, write a function that returns true if there exists a triple of indices (i, j, k) such that:\n- i < j < k,\n- nums[i] < nums[j], and\n- nums[j] < nums[k]\n\nOtherwise, return false if no such indices exist.\n\n###Code:\n\n```python\ndef increasingTriplet(nums: list) -> bool:\n    if len(nums) < 3:\n        return False\n    first = second = float('inf')\n    for n in nums:\n        if n <= first:\n            first = n\n        elif n <= second:\n            second = n\n        else:\n            return True\n    return False\n```\n\n###Testcases:\n\n```python\nassert increasingTriplet([1, 2, 3, 4, 5]) == True\nassert increasingTriplet([5, 4, 3, 2, 1]) == False\nassert increasingTriplet([2, 1, 5, 0, 4, 6]) == True\nassert increasingTriplet([5, 1, 5, 5, 2, 5, 4]) == False\nassert increasingTriplet([10, 1, 2, 3]) == True\nassert increasingTriplet([1, 2, 3, 1, 2, 1]) == True\nassert increasingTriplet([2, 1, 1, 2, 1, 3]) == True\nassert increasingTriplet([1, 2]) == False  # Edge case with less than 3 numbers\n```\n\n[/Example 3]", "temperature": 0.813}, {"few_shots": [{"author": "Calvin", "UUID": "f795bda7-9822-4bc5-9c7e-b9c0f2752085", "question": "You are given two 0-indexed integer permutations A and B of length n.\n\nA prefix common array of A and B is an array C such that C[i] is equal to the count of numbers that are present at or before the index i in both A and B.\n\nReturn the prefix common array of A and B.\n\nA sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once.", "examples": "Input: A = [1,3,2,4], B = [3,1,2,4]\nOutput: [0,2,3,4]", "link": "https://leetcode.com/problems/find-the-prefix-common-array-of-two-arrays/", "difficulty": null, "categories": ["Array"], "code": "def findThePrefixCommonArray(arr1: list, arr2: list) -> list:\n  max = len(arr1) if len(arr1) > len(arr2) else len(arr2)\n  seen = set()\n  curCount = 0\n  ret = []\n  for i in range(max):\n    cur1 = arr1[i]\n    cur2 = arr2[i]\n    if cur1 in seen:\n      curCount += 1\n    else:\n      seen.add(cur1)\n    if cur2 in seen:\n      curCount += 1\n    else:\n      seen.add(cur2)\n    ret.append(curCount)\n  return ret\n", "asserts": ["assert findThePrefixCommonArray([1,3,2,4], [3,1,2,4]) == [0,2,3,4]", "assert findThePrefixCommonArray([1], [1]) == [1]", "assert findThePrefixCommonArray([2,3,1], [3,1,2]) == [0,1,3]"]}, {"author": "Calvin", "UUID": "fb94082f-4627-4f5a-b280-08d869823d70", "question": "You are given an array of people, people, which are the attributes of some people in a queue (not necessarily in order). Each people[i] = [hi, ki] represents the ith person of height hi with exactly ki other people in front who have a height greater than or equal to hi.\n\nReconstruct and return the queue that is represented by the input array people. The returned queue should be formatted as an array queue, where queue[j] = [hj, kj] is the attributes of the jth person in the queue (queue[0] is the person at the front of the queue).\n", "examples": "Input:  [[7, 0], [4, 4], [7, 1], [5, 0], [6, 1], [5, 2]]\nOutput: [[5, 0], [4, 1], [7, 0], [5, 2], [6, 1], [7, 1]]\n\nInput:  [[6, 0], [5, 0], [4, 0], [3, 2], [2, 2], [1, 4]]\nOutput: [[4, 0], [5, 0], [2, 2], [3, 2], [1, 4], [6, 0]]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "\ndef reconstructQueue(people: list) -> list:\n    output=[] \n    people.sort(key=lambda x: (-x[0], x[1]))                \n    for a in people:\n        output.insert(a[1], a)\n    \n    return output\n", "asserts": ["assert reconstructQueue([[8,1],[5,0],[6,1],[5,2],[4,4],[7,1]]) == [[5, 0], [8, 1], [5, 2], [6, 1], [4, 4], [7, 1]]", "assert reconstructQueue([[12,0], [6,3], [4,4], [9,2], [7,1]]) == [[12, 0], [7, 1], [9, 2], [6, 3], [4, 4]]", "assert reconstructQueue([[2,0], [1,1]]) == [[2, 0], [1, 1]]", "assert reconstructQueue([[3,0], [3,2], [3,1]]) == [[3, 0], [3, 1], [3, 2]]"]}], "category": "Array", "prompt_tokens": 878, "total_tokens": 1072, "completion_tokens": 194, "completion": "Given an integer array nums and an integer k, return true if there are two distinct indices i and j in the array such that nums[i] == nums[j] and abs(i - j) <= k.\n\n###Code: \n\ndef containsNearbyDuplicate(nums: list, k: int) -> bool:\n    seen = {}\n    for i, value in enumerate(nums):\n        if value in seen and i - seen[value] <= k:\n            return True\n        seen[value] = i\n    return False\n\n###Testcases: \n\nassert containsNearbyDuplicate([1,2,3,1], 3) == True\nassert containsNearbyDuplicate([1,0,1,1], 1) == True\nassert containsNearbyDuplicate([1,2,3,1,2,3], 2) == False\nassert containsNearbyDuplicate([99,99], 2) == True\n\n[/Example 3]", "temperature": 0.864}, {"few_shots": [{"author": "Calvin", "UUID": "fb94082f-4627-4f5a-b280-08d869823d70", "question": "You are given an array of people, people, which are the attributes of some people in a queue (not necessarily in order). Each people[i] = [hi, ki] represents the ith person of height hi with exactly ki other people in front who have a height greater than or equal to hi.\n\nReconstruct and return the queue that is represented by the input array people. The returned queue should be formatted as an array queue, where queue[j] = [hj, kj] is the attributes of the jth person in the queue (queue[0] is the person at the front of the queue).\n", "examples": "Input:  [[7, 0], [4, 4], [7, 1], [5, 0], [6, 1], [5, 2]]\nOutput: [[5, 0], [4, 1], [7, 0], [5, 2], [6, 1], [7, 1]]\n\nInput:  [[6, 0], [5, 0], [4, 0], [3, 2], [2, 2], [1, 4]]\nOutput: [[4, 0], [5, 0], [2, 2], [3, 2], [1, 4], [6, 0]]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "\ndef reconstructQueue(people: list) -> list:\n    output=[] \n    people.sort(key=lambda x: (-x[0], x[1]))                \n    for a in people:\n        output.insert(a[1], a)\n    \n    return output\n", "asserts": ["assert reconstructQueue([[8,1],[5,0],[6,1],[5,2],[4,4],[7,1]]) == [[5, 0], [8, 1], [5, 2], [6, 1], [4, 4], [7, 1]]", "assert reconstructQueue([[12,0], [6,3], [4,4], [9,2], [7,1]]) == [[12, 0], [7, 1], [9, 2], [6, 3], [4, 4]]", "assert reconstructQueue([[2,0], [1,1]]) == [[2, 0], [1, 1]]", "assert reconstructQueue([[3,0], [3,2], [3,1]]) == [[3, 0], [3, 1], [3, 2]]"]}, {"author": "Calvin", "UUID": "f795bda7-9822-4bc5-9c7e-b9c0f2752085", "question": "You are given two 0-indexed integer permutations A and B of length n.\n\nA prefix common array of A and B is an array C such that C[i] is equal to the count of numbers that are present at or before the index i in both A and B.\n\nReturn the prefix common array of A and B.\n\nA sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once.", "examples": "Input: A = [1,3,2,4], B = [3,1,2,4]\nOutput: [0,2,3,4]", "link": "https://leetcode.com/problems/find-the-prefix-common-array-of-two-arrays/", "difficulty": null, "categories": ["Array"], "code": "def findThePrefixCommonArray(arr1: list, arr2: list) -> list:\n  max = len(arr1) if len(arr1) > len(arr2) else len(arr2)\n  seen = set()\n  curCount = 0\n  ret = []\n  for i in range(max):\n    cur1 = arr1[i]\n    cur2 = arr2[i]\n    if cur1 in seen:\n      curCount += 1\n    else:\n      seen.add(cur1)\n    if cur2 in seen:\n      curCount += 1\n    else:\n      seen.add(cur2)\n    ret.append(curCount)\n  return ret\n", "asserts": ["assert findThePrefixCommonArray([1,3,2,4], [3,1,2,4]) == [0,2,3,4]", "assert findThePrefixCommonArray([1], [1]) == [1]", "assert findThePrefixCommonArray([2,3,1], [3,1,2]) == [0,1,3]"]}], "category": "Array", "prompt_tokens": 878, "total_tokens": 1105, "completion_tokens": 227, "completion": "Given an array of integers nums, replace each element with the smallest element to its right and return the updated array. If there is no element to the right, replace it with -1.\n\n###Code: \n\ndef replaceElements(arr: list) -> list:\n    n = len(arr)\n    max_right = -1\n    for i in range(n-1, -1, -1):\n        new_max = max(max_right, arr[i])\n        arr[i] = max_right\n        max_right = new_max\n    return arr\n\n\n###Testcases: \n\nassert replaceElements([17,18,5,4,6,1]) == [18, 6, 6, 6, 1, -1]\nassert replaceElements([2, 3, 1, 8, 2, 3, 1]) == [3, 8, 8, 3, 3, 1, -1]\nassert replaceElements([5, 7]) == [7, -1]\nassert replaceElements([9]) == [-1]\n\n[/Example 3]", "temperature": 0.913}, {"few_shots": [{"author": "Calvin", "UUID": "fb94082f-4627-4f5a-b280-08d869823d70", "question": "You are given an array of people, people, which are the attributes of some people in a queue (not necessarily in order). Each people[i] = [hi, ki] represents the ith person of height hi with exactly ki other people in front who have a height greater than or equal to hi.\n\nReconstruct and return the queue that is represented by the input array people. The returned queue should be formatted as an array queue, where queue[j] = [hj, kj] is the attributes of the jth person in the queue (queue[0] is the person at the front of the queue).\n", "examples": "Input:  [[7, 0], [4, 4], [7, 1], [5, 0], [6, 1], [5, 2]]\nOutput: [[5, 0], [4, 1], [7, 0], [5, 2], [6, 1], [7, 1]]\n\nInput:  [[6, 0], [5, 0], [4, 0], [3, 2], [2, 2], [1, 4]]\nOutput: [[4, 0], [5, 0], [2, 2], [3, 2], [1, 4], [6, 0]]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "\ndef reconstructQueue(people: list) -> list:\n    output=[] \n    people.sort(key=lambda x: (-x[0], x[1]))                \n    for a in people:\n        output.insert(a[1], a)\n    \n    return output\n", "asserts": ["assert reconstructQueue([[8,1],[5,0],[6,1],[5,2],[4,4],[7,1]]) == [[5, 0], [8, 1], [5, 2], [6, 1], [4, 4], [7, 1]]", "assert reconstructQueue([[12,0], [6,3], [4,4], [9,2], [7,1]]) == [[12, 0], [7, 1], [9, 2], [6, 3], [4, 4]]", "assert reconstructQueue([[2,0], [1,1]]) == [[2, 0], [1, 1]]", "assert reconstructQueue([[3,0], [3,2], [3,1]]) == [[3, 0], [3, 1], [3, 2]]"]}, {"author": "Calvin", "UUID": "9e45b73f-583d-40ab-b387-e0d1624af07b", "question": "Given two arrays return an array with the set intersection of their common elements", "examples": "Input: arr1 = [1, 2, 3, 4], arr2 = [2, 3]\nOutput: [2, 3]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def array_intersection(arr1: list, arr2: list) -> set:\n  set1 = set(arr1)\n  ret = set([x for x in arr2 if x in set1])\n  return list(ret)\n", "asserts": ["assert set(array_intersection([1,0,2,0,2,0,2,1,1,1], [2,1,0,2,0,2,2,2,1,0])) == {0,1,2}", "assert set(array_intersection([5, 6, 7, 8], [8, 9, 10, 11])) == {8}", "assert set(array_intersection([10, 20, 30], [40, 50, 60])) == set()", "assert set(array_intersection([], [1, 2, 3])) == set()", "assert set(array_intersection([-1, -2, -3], [-3, -4, -5, -6])) == {-3}", "assert set(array_intersection([9, 8, 7], [7, 8, 9, 10, 11, 12])) == {7, 8, 9}", "assert set(array_intersection(['a', 'b', 'c'], ['a', 'd', 'e', 'c'])) == {'a', 'c'}", "assert set(array_intersection(['apple', 'banana'], ['banana', 'cherry'])) == {'banana'}", "assert set(array_intersection([1.1, 2.2, 3.3], [2.2, 4.4])) == {2.2}", "assert set(array_intersection([False, True, False], [True, False, True])) == {True, False}", "assert set(array_intersection([(1, 2), (3, 4)], [(3, 4), (5, 6)])) == {(3, 4)}"]}], "category": "Array", "prompt_tokens": 983, "total_tokens": 1317, "completion_tokens": 334, "completion": "Given an array of integers and an integer k, rotate the array to the right by k steps, where k is non-negative.\n\n###Code: \n\ndef rotate_array(nums: list, k: int) -> None:\n    k = k % len(nums)\n    nums[:] = nums[-k:] + nums[:-k]\n\n###Testcases: \n\nassert (arr := [1,2,3,4,5,6,7]) or rotate_array(arr, 3) or arr == [5,6,7,1,2,3,4]\nassert (arr := [-1,-100,3,99]) or rotate_array(arr, 2) or arr == [3,99,-1,-100]\nassert (arr := [1]) or rotate_array(arr, 0) or arr == [1]\nassert (arr := [1,2]) or rotate_array(arr, 3) or arr == [2,1]\nassert (arr := [1,2,3]) or rotate_array(arr, 4) or arr == [3,1,2]\nassert (arr := [1,2,3,4,5,6]) or rotate_array(arr, 11) or arr == [2,3,4,5,6,1]\nassert (arr := [1,2,3,4,5,6,7,8,9,10,11,12]) or rotate_array(arr, 7) or arr == [6,7,8,9,10,11,12,1,2,3,4,5]\n\n[/Example 3]", "temperature": 0.741}, {"few_shots": [{"author": "Calvin", "UUID": "a9c5e697-af5d-432b-8447-5675d739c728", "question": "Given an array reorder it so that even numbers appear first", "examples": "Input: [1,2,3,4,5,6,7,8,9]\r\nOutput: [8,2,6,4,5,7,3,9,1]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def even_odd_reorder(arr: list) -> list:\n  nextEven = 0\n  nextOdd = len(arr) - 1\n  while nextEven < nextOdd:\n    if arr[nextEven] % 2 == 0:\n      nextEven += 1\n    else:\n      temp = arr[nextEven]\n      arr[nextEven] = arr[nextOdd]\n      arr[nextOdd] = temp\n      nextOdd -= 1\n  return arr\n", "asserts": ["assert even_odd_reorder([1,2,3,4,5,6,7,8,9]) == [8, 2, 6, 4, 5, 7, 3, 9, 1]", "assert even_odd_reorder([]) == []", "assert even_odd_reorder([2, 4, 6, 8]) == [2, 4, 6, 8]", "assert even_odd_reorder([7, 9, 2]) == [2, 9, 7]", "assert even_odd_reorder([10, 13, 17, 16, 15, 12]) == [10, 12, 16, 15, 17, 13]"]}, {"author": "Calvin", "UUID": "1aeb3246-4c22-4d34-a48c-db7be8ba1b94", "question": "You are given n activities with their start and finish times. Select the maximum number of activities that can be performed by a single person and return their indexes. Assume that a person can only work on a single activity at a time. \n", "examples": "Input: start  =  {10, 12, 20}, finish =  {20, 25, 30}\nOutput: [0, 2]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "import numpy as np\ndef MaxActivities(s: list, f: list) -> list:\n    indices = np.argsort(f)\n    [s[i] for i in indices]\n    [f[i] for i in indices]\n    result = []\n    n = len(f)\n    i = 0\n    result.append(i)\n    for j in range(1, n):\n        if s[j] >= f[i]:\n            result.append(j)\n            i = j\n    return result\n", "asserts": ["assert MaxActivities([2, 4, 5, 6, 7, 8], [3, 5, 6, 7, 9, 10]) == [0, 1, 2, 3, 4]", "assert MaxActivities([1, 3, 0, 5, 8, 5], [2, 4, 6, 7, 9, 9]) == [0, 1, 3, 4]", "assert MaxActivities([1], [2]) == [0]"]}], "category": "Array", "prompt_tokens": 746, "total_tokens": 1032, "completion_tokens": 286, "completion": "Write a function that takes an unsorted array of integers and returns the length of the longest consecutive elements sequence. The sequence has to be strictly increasing and consecutive integers. \n\n###Code: \n\ndef longest_consecutive_sequence(arr: list) -> int:\n    if not arr:\n        return 0\n\n    arr = set(arr)  # Convert to set to remove duplicates and enable O(1) lookups\n    longest_streak = 0\n\n    for number in arr:\n        if number - 1 not in arr:\n            current_number = number\n            current_streak = 1\n\n            while current_number + 1 in arr:\n                current_number += 1\n                current_streak += 1\n\n            longest_streak = max(longest_streak, current_streak)\n\n    return longest_streak\n\n\n###Testcases: \n\nassert longest_consecutive_sequence([100, 4, 200, 1, 3, 2]) == 4\nassert longest_consecutive_sequence([0, -1]) == 2\nassert longest_consecutive_sequence([9,1,4,7,3,-1,0,5,8,-1,6]) == 7\nassert longest_consecutive_sequence([]) == 0\nassert longest_consecutive_sequence([-2, -3, -1, 1, 0]) == 4\n\n[/Example 3]", "temperature": 0.884}, {"few_shots": [{"author": "Calvin", "UUID": "48c6aa37-e00d-4b55-9afc-6b1cf2a1aff2", "question": "There are N Mice and N holes are placed in a straight line. Each hole can accommodate only 1 mouse. A mouse can stay at his position, move one step right from x to x + 1, or move one step left from x to x -1. Any of these moves consumes 1 minute. Assign mice to holes so that the time when the last mouse gets inside a hole is minimized.\nYou are given a list of mice and hole positions as integer scalers.\n", "examples": "Input: Mices = [0, 10, 2, 3], Holes = [3, 2, 23, 0]\nOutput: 13", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def assignHole(mices: list, holes: list) -> int:\n    for i,j in zip(mices,holes):\n        if i<0 or j<0:\n            return -1\n    if (len(mices) != len(holes)):\n        return -1\n    mices.sort()\n    holes.sort()\n    Max = 0\n     \n    for i in range(len(holes)):\n        if (Max < abs(mices[i] - holes[i])):\n            Max = abs(mices[i] - holes[i])\n     \n    return Max\n", "asserts": ["assert assignHole([1, 2, 3, 4], [4, 3, 2, 1]) == 0", "assert assignHole([10, 20, 30, 40], [15, 25, 35, 45]) == 5", "assert assignHole([1, 4, 9, 15], [10, 13, 7, 20]) == 6", "assert assignHole([0], [0]) == 0", "assert assignHole([1, 2], [3]) == -1  # Edge case with non-equal amount of mice and holes", "assert assignHole([5, 5, 5], [5, 5, 5]) == 0  # Edge case with all mice and holes at the same position", "assert assignHole([10, 10, 10, 10], [10, 9, 8, 7]) == 3  # Edge case with multiple mice starting at the same position", "assert assignHole([1,1 ,1, 1, 1, 1, 1, 1, 1, 1], [2,2,2,2,2,2 ,2, 2, 2, 2]) == 1 # Edge case with multiple mice and holes at the same positions", "assert assignHole([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == 1 # Edge case with incremental positions"]}, {"author": "Calvin", "UUID": "9e45b73f-583d-40ab-b387-e0d1624af07b", "question": "Given two arrays return an array with the set intersection of their common elements", "examples": "Input: arr1 = [1, 2, 3, 4], arr2 = [2, 3]\nOutput: [2, 3]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def array_intersection(arr1: list, arr2: list) -> set:\n  set1 = set(arr1)\n  ret = set([x for x in arr2 if x in set1])\n  return list(ret)\n", "asserts": ["assert set(array_intersection([1,0,2,0,2,0,2,1,1,1], [2,1,0,2,0,2,2,2,1,0])) == {0,1,2}", "assert set(array_intersection([5, 6, 7, 8], [8, 9, 10, 11])) == {8}", "assert set(array_intersection([10, 20, 30], [40, 50, 60])) == set()", "assert set(array_intersection([], [1, 2, 3])) == set()", "assert set(array_intersection([-1, -2, -3], [-3, -4, -5, -6])) == {-3}", "assert set(array_intersection([9, 8, 7], [7, 8, 9, 10, 11, 12])) == {7, 8, 9}", "assert set(array_intersection(['a', 'b', 'c'], ['a', 'd', 'e', 'c'])) == {'a', 'c'}", "assert set(array_intersection(['apple', 'banana'], ['banana', 'cherry'])) == {'banana'}", "assert set(array_intersection([1.1, 2.2, 3.3], [2.2, 4.4])) == {2.2}", "assert set(array_intersection([False, True, False], [True, False, True])) == {True, False}", "assert set(array_intersection([(1, 2), (3, 4)], [(3, 4), (5, 6)])) == {(3, 4)}"]}], "category": "Array", "prompt_tokens": 1208, "total_tokens": 1785, "completion_tokens": 577, "completion": "Given an array arr[] of N integers, arrange the elements of the array in zig-zag fashion. The converted array should be in form a < b > c < d > e < f. The relative order of elements is same in the output, i.e., you have to iterate over the array only once.\n\n###Code: \n\ndef zigzag_arrangement(arr: list) -> list:\n    flag = True\n  \n    for i in range(len(arr)-1):\n        if flag:\n            if arr[i] > arr[i+1]:\n                arr[i], arr[i+1] = arr[i+1], arr[i]\n        else:\n            if arr[i] < arr[i+1]:\n                arr[i], arr[i+1] = arr[i+1], arr[i]\n        flag = not flag\n    \n    return arr\n\n###Testcases: \n\nassert zigzag_arrangement([4, 3, 7, 8, 6, 2, 1]) == [3, 7, 4, 8, 2, 6, 1]\nassert zigzag_arrangement([1, 4, 3, 2]) == [1, 4, 2, 3]\nassert zigzag_arrangement([1, 3, 2, 4]) == [1, 3, 2, 4]\nassert zigzag_arrangement([1]) == [1]\nassert zigzag_arrangement([4, 3, 2, 1]) == [3, 4, 1, 2]\nassert zigzag_arrangement([1, 2, 3, 4, 5, 6, 7]) == [1, 3, 2, 5, 4, 7, 6]\nassert zigzag_arrangement([100, 90, 40, 50, 30]) == [90, 100, 40, 50, 30]\nassert zigzag_arrangement([1, 2, 3, 4]) == [1, 3, 2, 4]\nassert zigzag_arrangement([-1, -2, -3, -4, -5, -6, -7]) == [-2, -1, -4, -3, -6, -5, -7]\nassert zigzag_arrangement([0, 1, 0, 1, 0, 1]) == [0, 1, 0, 1, 0, 1]\nassert zigzag_arrangement([10]) == [10]\nassert zigzag_arrangement([1, 0, 0, -1]) == [0, 1, -1, 0] \n\n[/Example 3]", "temperature": 0.912}, {"few_shots": [{"author": "Calvin", "UUID": "fb94082f-4627-4f5a-b280-08d869823d70", "question": "You are given an array of people, people, which are the attributes of some people in a queue (not necessarily in order). Each people[i] = [hi, ki] represents the ith person of height hi with exactly ki other people in front who have a height greater than or equal to hi.\n\nReconstruct and return the queue that is represented by the input array people. The returned queue should be formatted as an array queue, where queue[j] = [hj, kj] is the attributes of the jth person in the queue (queue[0] is the person at the front of the queue).\n", "examples": "Input:  [[7, 0], [4, 4], [7, 1], [5, 0], [6, 1], [5, 2]]\nOutput: [[5, 0], [4, 1], [7, 0], [5, 2], [6, 1], [7, 1]]\n\nInput:  [[6, 0], [5, 0], [4, 0], [3, 2], [2, 2], [1, 4]]\nOutput: [[4, 0], [5, 0], [2, 2], [3, 2], [1, 4], [6, 0]]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "\ndef reconstructQueue(people: list) -> list:\n    output=[] \n    people.sort(key=lambda x: (-x[0], x[1]))                \n    for a in people:\n        output.insert(a[1], a)\n    \n    return output\n", "asserts": ["assert reconstructQueue([[8,1],[5,0],[6,1],[5,2],[4,4],[7,1]]) == [[5, 0], [8, 1], [5, 2], [6, 1], [4, 4], [7, 1]]", "assert reconstructQueue([[12,0], [6,3], [4,4], [9,2], [7,1]]) == [[12, 0], [7, 1], [9, 2], [6, 3], [4, 4]]", "assert reconstructQueue([[2,0], [1,1]]) == [[2, 0], [1, 1]]", "assert reconstructQueue([[3,0], [3,2], [3,1]]) == [[3, 0], [3, 1], [3, 2]]"]}, {"author": "Calvin", "UUID": "f795bda7-9822-4bc5-9c7e-b9c0f2752085", "question": "You are given two 0-indexed integer permutations A and B of length n.\n\nA prefix common array of A and B is an array C such that C[i] is equal to the count of numbers that are present at or before the index i in both A and B.\n\nReturn the prefix common array of A and B.\n\nA sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once.", "examples": "Input: A = [1,3,2,4], B = [3,1,2,4]\nOutput: [0,2,3,4]", "link": "https://leetcode.com/problems/find-the-prefix-common-array-of-two-arrays/", "difficulty": null, "categories": ["Array"], "code": "def findThePrefixCommonArray(arr1: list, arr2: list) -> list:\n  max = len(arr1) if len(arr1) > len(arr2) else len(arr2)\n  seen = set()\n  curCount = 0\n  ret = []\n  for i in range(max):\n    cur1 = arr1[i]\n    cur2 = arr2[i]\n    if cur1 in seen:\n      curCount += 1\n    else:\n      seen.add(cur1)\n    if cur2 in seen:\n      curCount += 1\n    else:\n      seen.add(cur2)\n    ret.append(curCount)\n  return ret\n", "asserts": ["assert findThePrefixCommonArray([1,3,2,4], [3,1,2,4]) == [0,2,3,4]", "assert findThePrefixCommonArray([1], [1]) == [1]", "assert findThePrefixCommonArray([2,3,1], [3,1,2]) == [0,1,3]"]}], "category": "Array", "prompt_tokens": 878, "total_tokens": 1238, "completion_tokens": 360, "completion": "Given an array of strictly increasing integers `arr`, return the number of triangles that can be formed. A triangle is valid if the sum of any two sides is greater than the third side. For example, if the sides of the triangle are `a`, `b`, and `c` where `a < b < c`, then all three conditions `a + b > c`, `a + c > b`, and `b + c > a` must be satisfied.\n\n###Code:\n\n```python\ndef countTriangles(arr: list) -> int:\n    n = len(arr)\n    count = 0\n    for i in range(n - 2):\n        k = i + 2\n        for j in range(i + 1, n):\n            while k < n and arr[i] + arr[j] > arr[k]:\n                k += 1\n            if k > j:\n                count += k - j - 1\n    return count\n```\n\n###Testcases:\n\n```python\nassert countTriangles([2, 2, 3, 4]) == 3  # Triangles with sides (2,3,4), (2,3,4), and (2,2,3)\nassert countTriangles([4, 6, 7, 8, 9]) == 10  # Various combinations e.g., (4,6,7), (6,7,8), etc.\nassert countTriangles([10, 21, 22, 100, 101, 200, 300]) == 4  # (21,22,100), (21,100,101), (22,100,101), (100,101,200)\n```\n\n[/Example 3]", "temperature": 0.944}, {"few_shots": [{"author": "Calvin", "UUID": "f795bda7-9822-4bc5-9c7e-b9c0f2752085", "question": "You are given two 0-indexed integer permutations A and B of length n.\n\nA prefix common array of A and B is an array C such that C[i] is equal to the count of numbers that are present at or before the index i in both A and B.\n\nReturn the prefix common array of A and B.\n\nA sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once.", "examples": "Input: A = [1,3,2,4], B = [3,1,2,4]\nOutput: [0,2,3,4]", "link": "https://leetcode.com/problems/find-the-prefix-common-array-of-two-arrays/", "difficulty": null, "categories": ["Array"], "code": "def findThePrefixCommonArray(arr1: list, arr2: list) -> list:\n  max = len(arr1) if len(arr1) > len(arr2) else len(arr2)\n  seen = set()\n  curCount = 0\n  ret = []\n  for i in range(max):\n    cur1 = arr1[i]\n    cur2 = arr2[i]\n    if cur1 in seen:\n      curCount += 1\n    else:\n      seen.add(cur1)\n    if cur2 in seen:\n      curCount += 1\n    else:\n      seen.add(cur2)\n    ret.append(curCount)\n  return ret\n", "asserts": ["assert findThePrefixCommonArray([1,3,2,4], [3,1,2,4]) == [0,2,3,4]", "assert findThePrefixCommonArray([1], [1]) == [1]", "assert findThePrefixCommonArray([2,3,1], [3,1,2]) == [0,1,3]"]}, {"author": "Calvin", "UUID": "fb94082f-4627-4f5a-b280-08d869823d70", "question": "You are given an array of people, people, which are the attributes of some people in a queue (not necessarily in order). Each people[i] = [hi, ki] represents the ith person of height hi with exactly ki other people in front who have a height greater than or equal to hi.\n\nReconstruct and return the queue that is represented by the input array people. The returned queue should be formatted as an array queue, where queue[j] = [hj, kj] is the attributes of the jth person in the queue (queue[0] is the person at the front of the queue).\n", "examples": "Input:  [[7, 0], [4, 4], [7, 1], [5, 0], [6, 1], [5, 2]]\nOutput: [[5, 0], [4, 1], [7, 0], [5, 2], [6, 1], [7, 1]]\n\nInput:  [[6, 0], [5, 0], [4, 0], [3, 2], [2, 2], [1, 4]]\nOutput: [[4, 0], [5, 0], [2, 2], [3, 2], [1, 4], [6, 0]]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "\ndef reconstructQueue(people: list) -> list:\n    output=[] \n    people.sort(key=lambda x: (-x[0], x[1]))                \n    for a in people:\n        output.insert(a[1], a)\n    \n    return output\n", "asserts": ["assert reconstructQueue([[8,1],[5,0],[6,1],[5,2],[4,4],[7,1]]) == [[5, 0], [8, 1], [5, 2], [6, 1], [4, 4], [7, 1]]", "assert reconstructQueue([[12,0], [6,3], [4,4], [9,2], [7,1]]) == [[12, 0], [7, 1], [9, 2], [6, 3], [4, 4]]", "assert reconstructQueue([[2,0], [1,1]]) == [[2, 0], [1, 1]]", "assert reconstructQueue([[3,0], [3,2], [3,1]]) == [[3, 0], [3, 1], [3, 2]]"]}], "category": "Array", "prompt_tokens": 878, "total_tokens": 1185, "completion_tokens": 307, "completion": "Given an array of intervals where intervals[i] = [starti, endi], merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input.\n\n###Code: \n\ndef mergeIntervals(intervals: list) -> list:\n    intervals.sort(key=lambda x: x[0])  # Sort the intervals by their start value.\n    merged = []\n    for interval in intervals:\n        # If the list of merged intervals is empty, or if the current interval doesn't overlap\n        # with the previous one, simply append it.\n        if not merged or merged[-1][1] < interval[0]:\n            merged.append(interval)\n        else:\n            # There is overlap, so we merge the current and previous intervals.\n            merged[-1][1] = max(merged[-1][1], interval[1])\n    return merged\n\n###Testcases: \n\nassert mergeIntervals([[1,3],[2,6],[8,10],[15,18]]) == [[1,6],[8,10],[15,18]]\nassert mergeIntervals([[1,4],[4,5]]) == [[1,5]]\nassert mergeIntervals([[1,4],[0,2],[3,5]]) == [[0,5]]\nassert mergeIntervals([[1,4],[0,4]]) == [[0,4]]\nassert mergeIntervals([[1,4],[2,3]]) == [[1,4]]\n\n[/Example 3]", "temperature": 0.931}, {"few_shots": [{"author": "Calvin", "UUID": "48c6aa37-e00d-4b55-9afc-6b1cf2a1aff2", "question": "There are N Mice and N holes are placed in a straight line. Each hole can accommodate only 1 mouse. A mouse can stay at his position, move one step right from x to x + 1, or move one step left from x to x -1. Any of these moves consumes 1 minute. Assign mice to holes so that the time when the last mouse gets inside a hole is minimized.\nYou are given a list of mice and hole positions as integer scalers.\n", "examples": "Input: Mices = [0, 10, 2, 3], Holes = [3, 2, 23, 0]\nOutput: 13", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def assignHole(mices: list, holes: list) -> int:\n    for i,j in zip(mices,holes):\n        if i<0 or j<0:\n            return -1\n    if (len(mices) != len(holes)):\n        return -1\n    mices.sort()\n    holes.sort()\n    Max = 0\n     \n    for i in range(len(holes)):\n        if (Max < abs(mices[i] - holes[i])):\n            Max = abs(mices[i] - holes[i])\n     \n    return Max\n", "asserts": ["assert assignHole([1, 2, 3, 4], [4, 3, 2, 1]) == 0", "assert assignHole([10, 20, 30, 40], [15, 25, 35, 45]) == 5", "assert assignHole([1, 4, 9, 15], [10, 13, 7, 20]) == 6", "assert assignHole([0], [0]) == 0", "assert assignHole([1, 2], [3]) == -1  # Edge case with non-equal amount of mice and holes", "assert assignHole([5, 5, 5], [5, 5, 5]) == 0  # Edge case with all mice and holes at the same position", "assert assignHole([10, 10, 10, 10], [10, 9, 8, 7]) == 3  # Edge case with multiple mice starting at the same position", "assert assignHole([1,1 ,1, 1, 1, 1, 1, 1, 1, 1], [2,2,2,2,2,2 ,2, 2, 2, 2]) == 1 # Edge case with multiple mice and holes at the same positions", "assert assignHole([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == 1 # Edge case with incremental positions"]}, {"author": "Calvin", "UUID": "fb94082f-4627-4f5a-b280-08d869823d70", "question": "You are given an array of people, people, which are the attributes of some people in a queue (not necessarily in order). Each people[i] = [hi, ki] represents the ith person of height hi with exactly ki other people in front who have a height greater than or equal to hi.\n\nReconstruct and return the queue that is represented by the input array people. The returned queue should be formatted as an array queue, where queue[j] = [hj, kj] is the attributes of the jth person in the queue (queue[0] is the person at the front of the queue).\n", "examples": "Input:  [[7, 0], [4, 4], [7, 1], [5, 0], [6, 1], [5, 2]]\nOutput: [[5, 0], [4, 1], [7, 0], [5, 2], [6, 1], [7, 1]]\n\nInput:  [[6, 0], [5, 0], [4, 0], [3, 2], [2, 2], [1, 4]]\nOutput: [[4, 0], [5, 0], [2, 2], [3, 2], [1, 4], [6, 0]]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "\ndef reconstructQueue(people: list) -> list:\n    output=[] \n    people.sort(key=lambda x: (-x[0], x[1]))                \n    for a in people:\n        output.insert(a[1], a)\n    \n    return output\n", "asserts": ["assert reconstructQueue([[8,1],[5,0],[6,1],[5,2],[4,4],[7,1]]) == [[5, 0], [8, 1], [5, 2], [6, 1], [4, 4], [7, 1]]", "assert reconstructQueue([[12,0], [6,3], [4,4], [9,2], [7,1]]) == [[12, 0], [7, 1], [9, 2], [6, 3], [4, 4]]", "assert reconstructQueue([[2,0], [1,1]]) == [[2, 0], [1, 1]]", "assert reconstructQueue([[3,0], [3,2], [3,1]]) == [[3, 0], [3, 1], [3, 2]]"]}], "category": "Array", "prompt_tokens": 1164, "total_tokens": 1476, "completion_tokens": 312, "completion": "Implement a function that takes an array of integers and a target value and returns indices of the two numbers such that they add up to the target value.\n\nYou may assume that each input would have exactly one solution, and you may not use the same element twice.\n\nYou can return the answer in any order.\n\n\n###Code: \n\ndef twoSum(nums: list, target: int) -> list:\n    prevMap = {}  # val -> index\n    \n    for i, n in enumerate(nums):\n        diff = target - n\n        if diff in prevMap:\n            return [prevMap[diff], i]\n        prevMap[n] = i\n    return []\n\n\n###Testcases:\n\nassert twoSum([2, 7, 11, 15], 9) == [0, 1]\nassert twoSum([3, 2, 4], 6) == [1, 2]\nassert twoSum([3, 3], 6) == [0, 1]\nassert twoSum([2, 5, 5, 11], 10) == [1, 2]\nassert twoSum([-1, -2, -3, -4, -5], -8) == [2, 4]\nassert twoSum([0, 4, 3, 0], 0) == [0, 3]\nassert twoSum([-3, 4, 3, 90], 0) == [0, 2]\n\n[/Example 3]", "temperature": 0.711}, {"few_shots": [{"author": "Calvin", "UUID": "1aeb3246-4c22-4d34-a48c-db7be8ba1b94", "question": "You are given n activities with their start and finish times. Select the maximum number of activities that can be performed by a single person and return their indexes. Assume that a person can only work on a single activity at a time. \n", "examples": "Input: start  =  {10, 12, 20}, finish =  {20, 25, 30}\nOutput: [0, 2]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "import numpy as np\ndef MaxActivities(s: list, f: list) -> list:\n    indices = np.argsort(f)\n    [s[i] for i in indices]\n    [f[i] for i in indices]\n    result = []\n    n = len(f)\n    i = 0\n    result.append(i)\n    for j in range(1, n):\n        if s[j] >= f[i]:\n            result.append(j)\n            i = j\n    return result\n", "asserts": ["assert MaxActivities([2, 4, 5, 6, 7, 8], [3, 5, 6, 7, 9, 10]) == [0, 1, 2, 3, 4]", "assert MaxActivities([1, 3, 0, 5, 8, 5], [2, 4, 6, 7, 9, 9]) == [0, 1, 3, 4]", "assert MaxActivities([1], [2]) == [0]"]}, {"author": "Calvin", "UUID": "f795bda7-9822-4bc5-9c7e-b9c0f2752085", "question": "You are given two 0-indexed integer permutations A and B of length n.\n\nA prefix common array of A and B is an array C such that C[i] is equal to the count of numbers that are present at or before the index i in both A and B.\n\nReturn the prefix common array of A and B.\n\nA sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once.", "examples": "Input: A = [1,3,2,4], B = [3,1,2,4]\nOutput: [0,2,3,4]", "link": "https://leetcode.com/problems/find-the-prefix-common-array-of-two-arrays/", "difficulty": null, "categories": ["Array"], "code": "def findThePrefixCommonArray(arr1: list, arr2: list) -> list:\n  max = len(arr1) if len(arr1) > len(arr2) else len(arr2)\n  seen = set()\n  curCount = 0\n  ret = []\n  for i in range(max):\n    cur1 = arr1[i]\n    cur2 = arr2[i]\n    if cur1 in seen:\n      curCount += 1\n    else:\n      seen.add(cur1)\n    if cur2 in seen:\n      curCount += 1\n    else:\n      seen.add(cur2)\n    ret.append(curCount)\n  return ret\n", "asserts": ["assert findThePrefixCommonArray([1,3,2,4], [3,1,2,4]) == [0,2,3,4]", "assert findThePrefixCommonArray([1], [1]) == [1]", "assert findThePrefixCommonArray([2,3,1], [3,1,2]) == [0,1,3]"]}], "category": "Array", "prompt_tokens": 782, "total_tokens": 1094, "completion_tokens": 312, "completion": "Given an array of positive integers, find the contiguous subarray that sums to a given number X. If there are multiple subarrays with sum equal to X, return the subarray with the smallest starting index. If no subarray with the given sum is found, return an empty array.\n\n###Code: \n\ndef subarraySum(nums: list, target: int) -> list:\n    current_sum = 0\n    start = 0\n    for i in range(len(nums)):\n        current_sum += nums[i]\n        while current_sum > target and start <= i:\n            current_sum -= nums[start]\n            start += 1\n        if current_sum == target:\n            return nums[start:i+1]\n    return []\n\n###Testcases: \n\nassert subarraySum([1, 2, 3, 7, 5], 12) == [2, 3, 7]\nassert subarraySum([1, 2, 3, 4, 5], 9) == [2, 3, 4]\nassert subarraySum([1, 4, 20, 3, 10, 5], 33) == [20, 3, 10]\nassert subarraySum([1, 4, 0, 0, 3, 10, 5], 7) == [4, 0, 0, 3]\nassert subarraySum([1, 4], 0) == []\n\n[/Example 3]", "temperature": 0.658}, {"few_shots": [{"author": "Calvin", "UUID": "a9c5e697-af5d-432b-8447-5675d739c728", "question": "Given an array reorder it so that even numbers appear first", "examples": "Input: [1,2,3,4,5,6,7,8,9]\r\nOutput: [8,2,6,4,5,7,3,9,1]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def even_odd_reorder(arr: list) -> list:\n  nextEven = 0\n  nextOdd = len(arr) - 1\n  while nextEven < nextOdd:\n    if arr[nextEven] % 2 == 0:\n      nextEven += 1\n    else:\n      temp = arr[nextEven]\n      arr[nextEven] = arr[nextOdd]\n      arr[nextOdd] = temp\n      nextOdd -= 1\n  return arr\n", "asserts": ["assert even_odd_reorder([1,2,3,4,5,6,7,8,9]) == [8, 2, 6, 4, 5, 7, 3, 9, 1]", "assert even_odd_reorder([]) == []", "assert even_odd_reorder([2, 4, 6, 8]) == [2, 4, 6, 8]", "assert even_odd_reorder([7, 9, 2]) == [2, 9, 7]", "assert even_odd_reorder([10, 13, 17, 16, 15, 12]) == [10, 12, 16, 15, 17, 13]"]}, {"author": "Calvin", "UUID": "48c6aa37-e00d-4b55-9afc-6b1cf2a1aff2", "question": "There are N Mice and N holes are placed in a straight line. Each hole can accommodate only 1 mouse. A mouse can stay at his position, move one step right from x to x + 1, or move one step left from x to x -1. Any of these moves consumes 1 minute. Assign mice to holes so that the time when the last mouse gets inside a hole is minimized.\nYou are given a list of mice and hole positions as integer scalers.\n", "examples": "Input: Mices = [0, 10, 2, 3], Holes = [3, 2, 23, 0]\nOutput: 13", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def assignHole(mices: list, holes: list) -> int:\n    for i,j in zip(mices,holes):\n        if i<0 or j<0:\n            return -1\n    if (len(mices) != len(holes)):\n        return -1\n    mices.sort()\n    holes.sort()\n    Max = 0\n     \n    for i in range(len(holes)):\n        if (Max < abs(mices[i] - holes[i])):\n            Max = abs(mices[i] - holes[i])\n     \n    return Max\n", "asserts": ["assert assignHole([1, 2, 3, 4], [4, 3, 2, 1]) == 0", "assert assignHole([10, 20, 30, 40], [15, 25, 35, 45]) == 5", "assert assignHole([1, 4, 9, 15], [10, 13, 7, 20]) == 6", "assert assignHole([0], [0]) == 0", "assert assignHole([1, 2], [3]) == -1  # Edge case with non-equal amount of mice and holes", "assert assignHole([5, 5, 5], [5, 5, 5]) == 0  # Edge case with all mice and holes at the same position", "assert assignHole([10, 10, 10, 10], [10, 9, 8, 7]) == 3  # Edge case with multiple mice starting at the same position", "assert assignHole([1,1 ,1, 1, 1, 1, 1, 1, 1, 1], [2,2,2,2,2,2 ,2, 2, 2, 2]) == 1 # Edge case with multiple mice and holes at the same positions", "assert assignHole([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == 1 # Edge case with incremental positions"]}], "category": "Array", "prompt_tokens": 1067, "total_tokens": 1485, "completion_tokens": 418, "completion": "Given an array of integers, determine if it is monotonically increasing or decreasing. An array is monotonically increasing if for all i <= j, arr[i] <= arr[j]. Similarly, an array is monotonically decreasing if for all i <= j, arr[i] >= arr[j]. If the array is either monotonically increasing or decreasing, return `True`. Otherwise, return `False`.\n\n###Code: \n\n```python\ndef isMonotonic(arr: list) -> bool:\n    if not arr:\n        return True\n    \n    increasing = decreasing = True\n    \n    for i in range(1, len(arr)):\n        if arr[i] > arr[i - 1]:\n            decreasing = False\n        elif arr[i] < arr[i - 1]:\n            increasing = False\n            \n    return increasing or decreasing\n```\n\n###Testcases: \n\n```python\nassert isMonotonic([1, 2, 2, 3]) == True\nassert isMonotonic([6, 5, 4, 4]) == True\nassert isMonotonic([1, 3, 2]) == False\nassert isMonotonic([1, 2, 4, 5]) == True\nassert isMonotonic([1]) == True\nassert isMonotonic([]) == True\nassert isMonotonic([5, 5, 5, 5, 5]) == True\nassert isMonotonic([10, 10, 8, 7, 6, 5, 5, 3]) == True\nassert isMonotonic([1, 2, 0, 3, 4, 5, 6, 7, 8, 9]) == False\nassert isMonotonic([5, 4, 3, 2, 1, 0, -1, -2, -3, -4, -5]) == True\n```\n\n[/Example 3]", "temperature": 0.876}, {"few_shots": [{"author": "Calvin", "UUID": "a9c5e697-af5d-432b-8447-5675d739c728", "question": "Given an array reorder it so that even numbers appear first", "examples": "Input: [1,2,3,4,5,6,7,8,9]\r\nOutput: [8,2,6,4,5,7,3,9,1]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def even_odd_reorder(arr: list) -> list:\n  nextEven = 0\n  nextOdd = len(arr) - 1\n  while nextEven < nextOdd:\n    if arr[nextEven] % 2 == 0:\n      nextEven += 1\n    else:\n      temp = arr[nextEven]\n      arr[nextEven] = arr[nextOdd]\n      arr[nextOdd] = temp\n      nextOdd -= 1\n  return arr\n", "asserts": ["assert even_odd_reorder([1,2,3,4,5,6,7,8,9]) == [8, 2, 6, 4, 5, 7, 3, 9, 1]", "assert even_odd_reorder([]) == []", "assert even_odd_reorder([2, 4, 6, 8]) == [2, 4, 6, 8]", "assert even_odd_reorder([7, 9, 2]) == [2, 9, 7]", "assert even_odd_reorder([10, 13, 17, 16, 15, 12]) == [10, 12, 16, 15, 17, 13]"]}, {"author": "Calvin", "UUID": "1aeb3246-4c22-4d34-a48c-db7be8ba1b94", "question": "You are given n activities with their start and finish times. Select the maximum number of activities that can be performed by a single person and return their indexes. Assume that a person can only work on a single activity at a time. \n", "examples": "Input: start  =  {10, 12, 20}, finish =  {20, 25, 30}\nOutput: [0, 2]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "import numpy as np\ndef MaxActivities(s: list, f: list) -> list:\n    indices = np.argsort(f)\n    [s[i] for i in indices]\n    [f[i] for i in indices]\n    result = []\n    n = len(f)\n    i = 0\n    result.append(i)\n    for j in range(1, n):\n        if s[j] >= f[i]:\n            result.append(j)\n            i = j\n    return result\n", "asserts": ["assert MaxActivities([2, 4, 5, 6, 7, 8], [3, 5, 6, 7, 9, 10]) == [0, 1, 2, 3, 4]", "assert MaxActivities([1, 3, 0, 5, 8, 5], [2, 4, 6, 7, 9, 9]) == [0, 1, 3, 4]", "assert MaxActivities([1], [2]) == [0]"]}], "category": "Array", "prompt_tokens": 746, "total_tokens": 957, "completion_tokens": 211, "completion": "Write a function to rotate an array to the right by k steps, where k is non-negative, and return the array. Do the rotation in-place.\n\n###Code: \n\ndef rotate_array(arr: list, k: int) -> list:\n    n = len(arr)\n    k %= n  # In case the number of rotations exceeds the length\n    arr[:] = arr[-k:] + arr[:-k]\n    return arr\n\n###Testcases: \n\nassert rotate_array([1,2,3,4,5,6,7], 3) == [5,6,7,1,2,3,4]\nassert rotate_array([-1,-100,3,99], 2) == [3,99,-1,-100]\nassert rotate_array([1,2,3], 0) == [1,2,3]\nassert rotate_array([], 5) == []\nassert rotate_array([1,2,3], 4) == [3,1,2]\n\n[/Example 3]", "temperature": 0.843}, {"few_shots": [{"author": "Calvin", "UUID": "a9c5e697-af5d-432b-8447-5675d739c728", "question": "Given an array reorder it so that even numbers appear first", "examples": "Input: [1,2,3,4,5,6,7,8,9]\r\nOutput: [8,2,6,4,5,7,3,9,1]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def even_odd_reorder(arr: list) -> list:\n  nextEven = 0\n  nextOdd = len(arr) - 1\n  while nextEven < nextOdd:\n    if arr[nextEven] % 2 == 0:\n      nextEven += 1\n    else:\n      temp = arr[nextEven]\n      arr[nextEven] = arr[nextOdd]\n      arr[nextOdd] = temp\n      nextOdd -= 1\n  return arr\n", "asserts": ["assert even_odd_reorder([1,2,3,4,5,6,7,8,9]) == [8, 2, 6, 4, 5, 7, 3, 9, 1]", "assert even_odd_reorder([]) == []", "assert even_odd_reorder([2, 4, 6, 8]) == [2, 4, 6, 8]", "assert even_odd_reorder([7, 9, 2]) == [2, 9, 7]", "assert even_odd_reorder([10, 13, 17, 16, 15, 12]) == [10, 12, 16, 15, 17, 13]"]}, {"author": "Calvin", "UUID": "f795bda7-9822-4bc5-9c7e-b9c0f2752085", "question": "You are given two 0-indexed integer permutations A and B of length n.\n\nA prefix common array of A and B is an array C such that C[i] is equal to the count of numbers that are present at or before the index i in both A and B.\n\nReturn the prefix common array of A and B.\n\nA sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once.", "examples": "Input: A = [1,3,2,4], B = [3,1,2,4]\nOutput: [0,2,3,4]", "link": "https://leetcode.com/problems/find-the-prefix-common-array-of-two-arrays/", "difficulty": null, "categories": ["Array"], "code": "def findThePrefixCommonArray(arr1: list, arr2: list) -> list:\n  max = len(arr1) if len(arr1) > len(arr2) else len(arr2)\n  seen = set()\n  curCount = 0\n  ret = []\n  for i in range(max):\n    cur1 = arr1[i]\n    cur2 = arr2[i]\n    if cur1 in seen:\n      curCount += 1\n    else:\n      seen.add(cur1)\n    if cur2 in seen:\n      curCount += 1\n    else:\n      seen.add(cur2)\n    ret.append(curCount)\n  return ret\n", "asserts": ["assert findThePrefixCommonArray([1,3,2,4], [3,1,2,4]) == [0,2,3,4]", "assert findThePrefixCommonArray([1], [1]) == [1]", "assert findThePrefixCommonArray([2,3,1], [3,1,2]) == [0,1,3]"]}], "category": "Array", "prompt_tokens": 781, "total_tokens": 1111, "completion_tokens": 330, "completion": "Write a function that takes an array of integers and returns an array where each index stores the product of all numbers in the array except the number at the index itself. You cannot use division.\n\n###Code: \n\ndef array_of_array_products(arr: list) -> list:\n    if len(arr) < 2:\n        return []\n    \n    prefix_products = []\n    for num in arr:\n        if prefix_products:\n            prefix_products.append(prefix_products[-1] * num)\n        else:\n            prefix_products.append(num)\n    \n    suffix_product = 1\n    for i in range(len(arr) - 1, -1, -1):\n        if i < len(arr) - 1:\n            prefix_products[i] *= suffix_product\n        suffix_product *= arr[i]\n    \n    result = [suffix_product]\n    for i in range(1, len(arr)):\n        result.append(prefix_products[i - 1] * suffix_product)\n        suffix_product *= arr[i]\n    \n    return result\n\n###Testcases: \n\nassert array_of_array_products([1, 2, 3, 4]) == [24, 12, 8, 6]\nassert array_of_array_products([2, 3, 4, 5]) == [60, 40, 30, 24]\nassert array_of_array_products([3, 2, 1]) == [2, 3, 6]\nassert array_of_array_products([0, 4, 2]) == [8, 0, 0]\nassert array_of_array_products([1]) == []\n\n[/Example 3]", "temperature": 0.874}, {"few_shots": [{"author": "Calvin", "UUID": "fb94082f-4627-4f5a-b280-08d869823d70", "question": "You are given an array of people, people, which are the attributes of some people in a queue (not necessarily in order). Each people[i] = [hi, ki] represents the ith person of height hi with exactly ki other people in front who have a height greater than or equal to hi.\n\nReconstruct and return the queue that is represented by the input array people. The returned queue should be formatted as an array queue, where queue[j] = [hj, kj] is the attributes of the jth person in the queue (queue[0] is the person at the front of the queue).\n", "examples": "Input:  [[7, 0], [4, 4], [7, 1], [5, 0], [6, 1], [5, 2]]\nOutput: [[5, 0], [4, 1], [7, 0], [5, 2], [6, 1], [7, 1]]\n\nInput:  [[6, 0], [5, 0], [4, 0], [3, 2], [2, 2], [1, 4]]\nOutput: [[4, 0], [5, 0], [2, 2], [3, 2], [1, 4], [6, 0]]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "\ndef reconstructQueue(people: list) -> list:\n    output=[] \n    people.sort(key=lambda x: (-x[0], x[1]))                \n    for a in people:\n        output.insert(a[1], a)\n    \n    return output\n", "asserts": ["assert reconstructQueue([[8,1],[5,0],[6,1],[5,2],[4,4],[7,1]]) == [[5, 0], [8, 1], [5, 2], [6, 1], [4, 4], [7, 1]]", "assert reconstructQueue([[12,0], [6,3], [4,4], [9,2], [7,1]]) == [[12, 0], [7, 1], [9, 2], [6, 3], [4, 4]]", "assert reconstructQueue([[2,0], [1,1]]) == [[2, 0], [1, 1]]", "assert reconstructQueue([[3,0], [3,2], [3,1]]) == [[3, 0], [3, 1], [3, 2]]"]}, {"author": "Calvin", "UUID": "f795bda7-9822-4bc5-9c7e-b9c0f2752085", "question": "You are given two 0-indexed integer permutations A and B of length n.\n\nA prefix common array of A and B is an array C such that C[i] is equal to the count of numbers that are present at or before the index i in both A and B.\n\nReturn the prefix common array of A and B.\n\nA sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once.", "examples": "Input: A = [1,3,2,4], B = [3,1,2,4]\nOutput: [0,2,3,4]", "link": "https://leetcode.com/problems/find-the-prefix-common-array-of-two-arrays/", "difficulty": null, "categories": ["Array"], "code": "def findThePrefixCommonArray(arr1: list, arr2: list) -> list:\n  max = len(arr1) if len(arr1) > len(arr2) else len(arr2)\n  seen = set()\n  curCount = 0\n  ret = []\n  for i in range(max):\n    cur1 = arr1[i]\n    cur2 = arr2[i]\n    if cur1 in seen:\n      curCount += 1\n    else:\n      seen.add(cur1)\n    if cur2 in seen:\n      curCount += 1\n    else:\n      seen.add(cur2)\n    ret.append(curCount)\n  return ret\n", "asserts": ["assert findThePrefixCommonArray([1,3,2,4], [3,1,2,4]) == [0,2,3,4]", "assert findThePrefixCommonArray([1], [1]) == [1]", "assert findThePrefixCommonArray([2,3,1], [3,1,2]) == [0,1,3]"]}], "category": "Array", "prompt_tokens": 878, "total_tokens": 1177, "completion_tokens": 299, "completion": "Given an array of n integers where each integer describes the number of chocolates in a box, you can choose two boxes and combine their chocolates to form a new box. The cost of combining two boxes is equal to the sum of the number of chocolates in both boxes.\n\nYou need to combine the boxes until there is only one box left. Return the minimum cost to combine all the boxes into one box.\n\n###Code: \n\ndef minCostToCombineBoxes(boxes: list) -> int:\n    import heapq\n\n    # Convert the list into a min-heap\n    heapq.heapify(boxes)\n    total_cost = 0\n\n    # While there is more than one box\n    while len(boxes) > 1:\n        # Take out two smallest boxes and combine them\n        first = heapq.heappop(boxes)\n        second = heapq.heappop(boxes)\n        cost = first + second\n        total_cost += cost\n        # Add the combined box back into the heap\n        heapq.heappush(boxes, cost)\n\n    return total_cost\n\n###Testcases: \n\nassert minCostToCombineBoxes([1,2,3,4]) == 19\nassert minCostToCombineBoxes([1,8,3]) == 18\nassert minCostToCombineBoxes([5]) == 0\nassert minCostToCombineBoxes([1,2,1,2,1,2]) == 21\n\n[/Example 3]", "temperature": 0.77}, {"few_shots": [{"author": "Calvin", "UUID": "9e45b73f-583d-40ab-b387-e0d1624af07b", "question": "Given two arrays return an array with the set intersection of their common elements", "examples": "Input: arr1 = [1, 2, 3, 4], arr2 = [2, 3]\nOutput: [2, 3]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def array_intersection(arr1: list, arr2: list) -> set:\n  set1 = set(arr1)\n  ret = set([x for x in arr2 if x in set1])\n  return list(ret)\n", "asserts": ["assert set(array_intersection([1,0,2,0,2,0,2,1,1,1], [2,1,0,2,0,2,2,2,1,0])) == {0,1,2}", "assert set(array_intersection([5, 6, 7, 8], [8, 9, 10, 11])) == {8}", "assert set(array_intersection([10, 20, 30], [40, 50, 60])) == set()", "assert set(array_intersection([], [1, 2, 3])) == set()", "assert set(array_intersection([-1, -2, -3], [-3, -4, -5, -6])) == {-3}", "assert set(array_intersection([9, 8, 7], [7, 8, 9, 10, 11, 12])) == {7, 8, 9}", "assert set(array_intersection(['a', 'b', 'c'], ['a', 'd', 'e', 'c'])) == {'a', 'c'}", "assert set(array_intersection(['apple', 'banana'], ['banana', 'cherry'])) == {'banana'}", "assert set(array_intersection([1.1, 2.2, 3.3], [2.2, 4.4])) == {2.2}", "assert set(array_intersection([False, True, False], [True, False, True])) == {True, False}", "assert set(array_intersection([(1, 2), (3, 4)], [(3, 4), (5, 6)])) == {(3, 4)}"]}, {"author": "Calvin", "UUID": "a9c5e697-af5d-432b-8447-5675d739c728", "question": "Given an array reorder it so that even numbers appear first", "examples": "Input: [1,2,3,4,5,6,7,8,9]\r\nOutput: [8,2,6,4,5,7,3,9,1]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def even_odd_reorder(arr: list) -> list:\n  nextEven = 0\n  nextOdd = len(arr) - 1\n  while nextEven < nextOdd:\n    if arr[nextEven] % 2 == 0:\n      nextEven += 1\n    else:\n      temp = arr[nextEven]\n      arr[nextEven] = arr[nextOdd]\n      arr[nextOdd] = temp\n      nextOdd -= 1\n  return arr\n", "asserts": ["assert even_odd_reorder([1,2,3,4,5,6,7,8,9]) == [8, 2, 6, 4, 5, 7, 3, 9, 1]", "assert even_odd_reorder([]) == []", "assert even_odd_reorder([2, 4, 6, 8]) == [2, 4, 6, 8]", "assert even_odd_reorder([7, 9, 2]) == [2, 9, 7]", "assert even_odd_reorder([10, 13, 17, 16, 15, 12]) == [10, 12, 16, 15, 17, 13]"]}], "category": "Array", "prompt_tokens": 886, "total_tokens": 1182, "completion_tokens": 296, "completion": "Given an array of integers, move all zeros to the end of the array while maintaining the relative order of the non-zero elements.\n\n###Code: \n\ndef move_zeros_to_end(arr: list) -> list:\n    non_zero_index = 0\n    for i in range(len(arr)):\n        if arr[i] != 0:\n            arr[non_zero_index] = arr[i]\n            non_zero_index += 1\n    for i in range(non_zero_index, len(arr)):\n        arr[i] = 0\n    return arr\n\n###Testcases: \n\nassert move_zeros_to_end([0,1,0,3,12]) == [1,3,12,0,0]\nassert move_zeros_to_end([4,2,4,0,0,3,0,5,1,0]) == [4,2,4,3,5,1,0,0,0,0]\nassert move_zeros_to_end([0,0,0,0,0]) == [0,0,0,0,0]\nassert move_zeros_to_end([1,2,3,4,5]) == [1,2,3,4,5]\nassert move_zeros_to_end([0,1,0,3,0,0,0,0,12]) == [1,3,12,0,0,0,0,0,0]\n\n[/Example 3]", "temperature": 0.762}, {"few_shots": [{"author": "Calvin", "UUID": "fb94082f-4627-4f5a-b280-08d869823d70", "question": "You are given an array of people, people, which are the attributes of some people in a queue (not necessarily in order). Each people[i] = [hi, ki] represents the ith person of height hi with exactly ki other people in front who have a height greater than or equal to hi.\n\nReconstruct and return the queue that is represented by the input array people. The returned queue should be formatted as an array queue, where queue[j] = [hj, kj] is the attributes of the jth person in the queue (queue[0] is the person at the front of the queue).\n", "examples": "Input:  [[7, 0], [4, 4], [7, 1], [5, 0], [6, 1], [5, 2]]\nOutput: [[5, 0], [4, 1], [7, 0], [5, 2], [6, 1], [7, 1]]\n\nInput:  [[6, 0], [5, 0], [4, 0], [3, 2], [2, 2], [1, 4]]\nOutput: [[4, 0], [5, 0], [2, 2], [3, 2], [1, 4], [6, 0]]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "\ndef reconstructQueue(people: list) -> list:\n    output=[] \n    people.sort(key=lambda x: (-x[0], x[1]))                \n    for a in people:\n        output.insert(a[1], a)\n    \n    return output\n", "asserts": ["assert reconstructQueue([[8,1],[5,0],[6,1],[5,2],[4,4],[7,1]]) == [[5, 0], [8, 1], [5, 2], [6, 1], [4, 4], [7, 1]]", "assert reconstructQueue([[12,0], [6,3], [4,4], [9,2], [7,1]]) == [[12, 0], [7, 1], [9, 2], [6, 3], [4, 4]]", "assert reconstructQueue([[2,0], [1,1]]) == [[2, 0], [1, 1]]", "assert reconstructQueue([[3,0], [3,2], [3,1]]) == [[3, 0], [3, 1], [3, 2]]"]}, {"author": "Calvin", "UUID": "1aeb3246-4c22-4d34-a48c-db7be8ba1b94", "question": "You are given n activities with their start and finish times. Select the maximum number of activities that can be performed by a single person and return their indexes. Assume that a person can only work on a single activity at a time. \n", "examples": "Input: start  =  {10, 12, 20}, finish =  {20, 25, 30}\nOutput: [0, 2]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "import numpy as np\ndef MaxActivities(s: list, f: list) -> list:\n    indices = np.argsort(f)\n    [s[i] for i in indices]\n    [f[i] for i in indices]\n    result = []\n    n = len(f)\n    i = 0\n    result.append(i)\n    for j in range(1, n):\n        if s[j] >= f[i]:\n            result.append(j)\n            i = j\n    return result\n", "asserts": ["assert MaxActivities([2, 4, 5, 6, 7, 8], [3, 5, 6, 7, 9, 10]) == [0, 1, 2, 3, 4]", "assert MaxActivities([1, 3, 0, 5, 8, 5], [2, 4, 6, 7, 9, 9]) == [0, 1, 3, 4]", "assert MaxActivities([1], [2]) == [0]"]}], "category": "Array", "prompt_tokens": 843, "total_tokens": 1067, "completion_tokens": 224, "completion": "Given an array of integers, return the length of the longest subarray that contains only even numbers.\n\n###Code:\n\ndef longestEvenSubarray(nums: list) -> int:\n    max_length = 0\n    current_length = 0\n    \n    for num in nums:\n        if num % 2 == 0:\n            current_length += 1\n            max_length = max(max_length, current_length)\n        else:\n            current_length = 0\n    \n    return max_length\n\n###Testcases:\n\nassert longestEvenSubarray([1, 2, 2, 3, 4, 4, 4, 5, 6]) == 3\nassert longestEvenSubarray([2, 2, 2, 2]) == 4\nassert longestEvenSubarray([1, 3, 5, 7]) == 0\nassert longestEvenSubarray([5, 6, 2, 4, 6, 8, 1, 4, 2, 2]) == 4\n\n[/Example 3]", "temperature": 0.78}, {"few_shots": [{"author": "Calvin", "UUID": "48c6aa37-e00d-4b55-9afc-6b1cf2a1aff2", "question": "There are N Mice and N holes are placed in a straight line. Each hole can accommodate only 1 mouse. A mouse can stay at his position, move one step right from x to x + 1, or move one step left from x to x -1. Any of these moves consumes 1 minute. Assign mice to holes so that the time when the last mouse gets inside a hole is minimized.\nYou are given a list of mice and hole positions as integer scalers.\n", "examples": "Input: Mices = [0, 10, 2, 3], Holes = [3, 2, 23, 0]\nOutput: 13", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def assignHole(mices: list, holes: list) -> int:\n    for i,j in zip(mices,holes):\n        if i<0 or j<0:\n            return -1\n    if (len(mices) != len(holes)):\n        return -1\n    mices.sort()\n    holes.sort()\n    Max = 0\n     \n    for i in range(len(holes)):\n        if (Max < abs(mices[i] - holes[i])):\n            Max = abs(mices[i] - holes[i])\n     \n    return Max\n", "asserts": ["assert assignHole([1, 2, 3, 4], [4, 3, 2, 1]) == 0", "assert assignHole([10, 20, 30, 40], [15, 25, 35, 45]) == 5", "assert assignHole([1, 4, 9, 15], [10, 13, 7, 20]) == 6", "assert assignHole([0], [0]) == 0", "assert assignHole([1, 2], [3]) == -1  # Edge case with non-equal amount of mice and holes", "assert assignHole([5, 5, 5], [5, 5, 5]) == 0  # Edge case with all mice and holes at the same position", "assert assignHole([10, 10, 10, 10], [10, 9, 8, 7]) == 3  # Edge case with multiple mice starting at the same position", "assert assignHole([1,1 ,1, 1, 1, 1, 1, 1, 1, 1], [2,2,2,2,2,2 ,2, 2, 2, 2]) == 1 # Edge case with multiple mice and holes at the same positions", "assert assignHole([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == 1 # Edge case with incremental positions"]}, {"author": "Calvin", "UUID": "fb94082f-4627-4f5a-b280-08d869823d70", "question": "You are given an array of people, people, which are the attributes of some people in a queue (not necessarily in order). Each people[i] = [hi, ki] represents the ith person of height hi with exactly ki other people in front who have a height greater than or equal to hi.\n\nReconstruct and return the queue that is represented by the input array people. The returned queue should be formatted as an array queue, where queue[j] = [hj, kj] is the attributes of the jth person in the queue (queue[0] is the person at the front of the queue).\n", "examples": "Input:  [[7, 0], [4, 4], [7, 1], [5, 0], [6, 1], [5, 2]]\nOutput: [[5, 0], [4, 1], [7, 0], [5, 2], [6, 1], [7, 1]]\n\nInput:  [[6, 0], [5, 0], [4, 0], [3, 2], [2, 2], [1, 4]]\nOutput: [[4, 0], [5, 0], [2, 2], [3, 2], [1, 4], [6, 0]]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "\ndef reconstructQueue(people: list) -> list:\n    output=[] \n    people.sort(key=lambda x: (-x[0], x[1]))                \n    for a in people:\n        output.insert(a[1], a)\n    \n    return output\n", "asserts": ["assert reconstructQueue([[8,1],[5,0],[6,1],[5,2],[4,4],[7,1]]) == [[5, 0], [8, 1], [5, 2], [6, 1], [4, 4], [7, 1]]", "assert reconstructQueue([[12,0], [6,3], [4,4], [9,2], [7,1]]) == [[12, 0], [7, 1], [9, 2], [6, 3], [4, 4]]", "assert reconstructQueue([[2,0], [1,1]]) == [[2, 0], [1, 1]]", "assert reconstructQueue([[3,0], [3,2], [3,1]]) == [[3, 0], [3, 1], [3, 2]]"]}], "category": "Array", "prompt_tokens": 1164, "total_tokens": 1453, "completion_tokens": 289, "completion": "Given an array of integers, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum. A subarray is a contiguous part of an array.\n\n\n###Code: \n\ndef maxSubArray(nums: list) -> int:\n    max_current = max_global = nums[0]\n    for i in range(1, len(nums)):\n        max_current = max(nums[i], max_current + nums[i])\n        if max_current > max_global:\n            max_global = max_current\n    return max_global\n\n\n###Testcases: \n\nassert maxSubArray([-2,1,-3,4,-1,2,1,-5,4]) == 6\nassert maxSubArray([1]) == 1\nassert maxSubArray([5,4,-1,7,8]) == 23\nassert maxSubArray([-2,-1]) == -1\nassert maxSubArray([-1,0,-2]) == 0\nassert maxSubArray([-1,1,2,1]) == 4\nassert maxSubArray([1,2,-1,-2,2,1,-2,1,4,-5,4]) == 6\nassert maxSubArray([1,2,-1,-2,2,1,-2,1,4,-5,4,0,2]) == 7\n\n[/Example 3]", "temperature": 0.706}, {"few_shots": [{"author": "Calvin", "UUID": "f795bda7-9822-4bc5-9c7e-b9c0f2752085", "question": "You are given two 0-indexed integer permutations A and B of length n.\n\nA prefix common array of A and B is an array C such that C[i] is equal to the count of numbers that are present at or before the index i in both A and B.\n\nReturn the prefix common array of A and B.\n\nA sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once.", "examples": "Input: A = [1,3,2,4], B = [3,1,2,4]\nOutput: [0,2,3,4]", "link": "https://leetcode.com/problems/find-the-prefix-common-array-of-two-arrays/", "difficulty": null, "categories": ["Array"], "code": "def findThePrefixCommonArray(arr1: list, arr2: list) -> list:\n  max = len(arr1) if len(arr1) > len(arr2) else len(arr2)\n  seen = set()\n  curCount = 0\n  ret = []\n  for i in range(max):\n    cur1 = arr1[i]\n    cur2 = arr2[i]\n    if cur1 in seen:\n      curCount += 1\n    else:\n      seen.add(cur1)\n    if cur2 in seen:\n      curCount += 1\n    else:\n      seen.add(cur2)\n    ret.append(curCount)\n  return ret\n", "asserts": ["assert findThePrefixCommonArray([1,3,2,4], [3,1,2,4]) == [0,2,3,4]", "assert findThePrefixCommonArray([1], [1]) == [1]", "assert findThePrefixCommonArray([2,3,1], [3,1,2]) == [0,1,3]"]}, {"author": "Calvin", "UUID": "1aeb3246-4c22-4d34-a48c-db7be8ba1b94", "question": "You are given n activities with their start and finish times. Select the maximum number of activities that can be performed by a single person and return their indexes. Assume that a person can only work on a single activity at a time. \n", "examples": "Input: start  =  {10, 12, 20}, finish =  {20, 25, 30}\nOutput: [0, 2]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "import numpy as np\ndef MaxActivities(s: list, f: list) -> list:\n    indices = np.argsort(f)\n    [s[i] for i in indices]\n    [f[i] for i in indices]\n    result = []\n    n = len(f)\n    i = 0\n    result.append(i)\n    for j in range(1, n):\n        if s[j] >= f[i]:\n            result.append(j)\n            i = j\n    return result\n", "asserts": ["assert MaxActivities([2, 4, 5, 6, 7, 8], [3, 5, 6, 7, 9, 10]) == [0, 1, 2, 3, 4]", "assert MaxActivities([1, 3, 0, 5, 8, 5], [2, 4, 6, 7, 9, 9]) == [0, 1, 3, 4]", "assert MaxActivities([1], [2]) == [0]"]}], "category": "Array", "prompt_tokens": 782, "total_tokens": 1116, "completion_tokens": 334, "completion": "You are given an array of integers, where each element represents the maximum number of steps that can be jumped going forward from that element. Write a function to return the minimum number of jumps you must take in order to get from the start to the end of the array.\n\nYou can assume you can always reach the end of the array.\n\n###Code: \n\ndef minJumps(arr: list) -> int:\n    n = len(arr)\n    if n <= 1:\n        return 0\n    \n    jumps = 0\n    max_reach = arr[0]\n    step = arr[0]\n    \n    for i in range(1, n):\n        if i == n - 1:\n            return jumps + 1\n        \n        max_reach = max(max_reach, i + arr[i])\n        step -= 1\n        \n        if step == 0:\n            jumps += 1\n            if i >= max_reach:\n                return float('inf')\n            step = max_reach - i\n    return jumps\n\n###Testcases: \n\nassert minJumps([2, 3, 1, 1, 2, 4, 2, 0, 1, 1]) == 4\nassert minJumps([1, 1, 1, 1, 1, 1, 1, 1, 1, 1]) == 9\nassert minJumps([10, 9, 8, 7, 6, 5, 4, 3, 2, 1]) == 1\n\n[/Example 3]", "temperature": 0.939}, {"few_shots": [{"author": "Calvin", "UUID": "a9c5e697-af5d-432b-8447-5675d739c728", "question": "Given an array reorder it so that even numbers appear first", "examples": "Input: [1,2,3,4,5,6,7,8,9]\r\nOutput: [8,2,6,4,5,7,3,9,1]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def even_odd_reorder(arr: list) -> list:\n  nextEven = 0\n  nextOdd = len(arr) - 1\n  while nextEven < nextOdd:\n    if arr[nextEven] % 2 == 0:\n      nextEven += 1\n    else:\n      temp = arr[nextEven]\n      arr[nextEven] = arr[nextOdd]\n      arr[nextOdd] = temp\n      nextOdd -= 1\n  return arr\n", "asserts": ["assert even_odd_reorder([1,2,3,4,5,6,7,8,9]) == [8, 2, 6, 4, 5, 7, 3, 9, 1]", "assert even_odd_reorder([]) == []", "assert even_odd_reorder([2, 4, 6, 8]) == [2, 4, 6, 8]", "assert even_odd_reorder([7, 9, 2]) == [2, 9, 7]", "assert even_odd_reorder([10, 13, 17, 16, 15, 12]) == [10, 12, 16, 15, 17, 13]"]}, {"author": "Calvin", "UUID": "1aeb3246-4c22-4d34-a48c-db7be8ba1b94", "question": "You are given n activities with their start and finish times. Select the maximum number of activities that can be performed by a single person and return their indexes. Assume that a person can only work on a single activity at a time. \n", "examples": "Input: start  =  {10, 12, 20}, finish =  {20, 25, 30}\nOutput: [0, 2]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "import numpy as np\ndef MaxActivities(s: list, f: list) -> list:\n    indices = np.argsort(f)\n    [s[i] for i in indices]\n    [f[i] for i in indices]\n    result = []\n    n = len(f)\n    i = 0\n    result.append(i)\n    for j in range(1, n):\n        if s[j] >= f[i]:\n            result.append(j)\n            i = j\n    return result\n", "asserts": ["assert MaxActivities([2, 4, 5, 6, 7, 8], [3, 5, 6, 7, 9, 10]) == [0, 1, 2, 3, 4]", "assert MaxActivities([1, 3, 0, 5, 8, 5], [2, 4, 6, 7, 9, 9]) == [0, 1, 3, 4]", "assert MaxActivities([1], [2]) == [0]"]}], "category": "Array", "prompt_tokens": 746, "total_tokens": 1033, "completion_tokens": 287, "completion": "Given an array of integers, return true if and only if it is possible to rearrange the array such that arithmetic progression can be formed with a common difference. If possible, return the common difference.\n\n###Code:\n\ndef can_reform_to_arithmetic_progression(arr: list) -> tuple:\n    if len(arr) < 2:\n        return (False, None)\n    arr.sort()\n    common_diff = arr[1] - arr[0]\n    for i in range(2, len(arr)):\n        if arr[i] - arr[i - 1] != common_diff:\n            return (False, None)\n    return (True, common_diff)\n\n###Testcases:\n\nassert can_reform_to_arithmetic_progression([3, 5, 1]) == (True, 2)\nassert can_reform_to_arithmetic_progression([1, 2, 4]) == (False, None)\nassert can_reform_to_arithmetic_progression([5, 5, 5]) == (True, 0)\nassert can_reform_to_arithmetic_progression([]) == (False, None)\nassert can_reform_to_arithmetic_progression([1]) == (True, 0)\nassert can_reform_to_arithmetic_progression([11, 1, 5, 3, 7, 9]) == (True, 2)\n\n[/Example 3]", "temperature": 0.882}, {"few_shots": [{"author": "Calvin", "UUID": "f795bda7-9822-4bc5-9c7e-b9c0f2752085", "question": "You are given two 0-indexed integer permutations A and B of length n.\n\nA prefix common array of A and B is an array C such that C[i] is equal to the count of numbers that are present at or before the index i in both A and B.\n\nReturn the prefix common array of A and B.\n\nA sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once.", "examples": "Input: A = [1,3,2,4], B = [3,1,2,4]\nOutput: [0,2,3,4]", "link": "https://leetcode.com/problems/find-the-prefix-common-array-of-two-arrays/", "difficulty": null, "categories": ["Array"], "code": "def findThePrefixCommonArray(arr1: list, arr2: list) -> list:\n  max = len(arr1) if len(arr1) > len(arr2) else len(arr2)\n  seen = set()\n  curCount = 0\n  ret = []\n  for i in range(max):\n    cur1 = arr1[i]\n    cur2 = arr2[i]\n    if cur1 in seen:\n      curCount += 1\n    else:\n      seen.add(cur1)\n    if cur2 in seen:\n      curCount += 1\n    else:\n      seen.add(cur2)\n    ret.append(curCount)\n  return ret\n", "asserts": ["assert findThePrefixCommonArray([1,3,2,4], [3,1,2,4]) == [0,2,3,4]", "assert findThePrefixCommonArray([1], [1]) == [1]", "assert findThePrefixCommonArray([2,3,1], [3,1,2]) == [0,1,3]"]}, {"author": "Calvin", "UUID": "1aeb3246-4c22-4d34-a48c-db7be8ba1b94", "question": "You are given n activities with their start and finish times. Select the maximum number of activities that can be performed by a single person and return their indexes. Assume that a person can only work on a single activity at a time. \n", "examples": "Input: start  =  {10, 12, 20}, finish =  {20, 25, 30}\nOutput: [0, 2]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "import numpy as np\ndef MaxActivities(s: list, f: list) -> list:\n    indices = np.argsort(f)\n    [s[i] for i in indices]\n    [f[i] for i in indices]\n    result = []\n    n = len(f)\n    i = 0\n    result.append(i)\n    for j in range(1, n):\n        if s[j] >= f[i]:\n            result.append(j)\n            i = j\n    return result\n", "asserts": ["assert MaxActivities([2, 4, 5, 6, 7, 8], [3, 5, 6, 7, 9, 10]) == [0, 1, 2, 3, 4]", "assert MaxActivities([1, 3, 0, 5, 8, 5], [2, 4, 6, 7, 9, 9]) == [0, 1, 3, 4]", "assert MaxActivities([1], [2]) == [0]"]}], "category": "Array", "prompt_tokens": 782, "total_tokens": 1042, "completion_tokens": 260, "completion": "Write a function to rotate an array by k steps to the right (for an array in ascending order, k positive steps would rotate the elements to the right). The rotation must be done in-place, which means modifying the input array directly without using an extra array.\n\n###Code: \n\ndef rotateArray(nums: list, k: int) -> None:\n    n = len(nums)\n    k = k % n  # To account for rotations larger than the array size\n\n    # Reverse the entire array\n    nums.reverse()\n    \n    # Reverse first k elements\n    nums[:k] = nums[:k][::-1]\n    \n    # Reverse the rest (n-k elements)\n    nums[k:] = nums[k:][::-1]\n  \n\n###Testcases: \n\nnums1 = [1,2,3,4,5,6,7]\nrotateArray(nums1, 3)\nassert nums1 == [5,6,7,1,2,3,4]\n\nnums2 = [-1,-100,3,99]\nrotateArray(nums2, 2)\nassert nums2 == [3,99,-1,-100]\n\nnums3 = [1]\nrotateArray(nums3, 0)\nassert nums3 == [1]\n\n[/Example 3]", "temperature": 0.921}, {"few_shots": [{"author": "Calvin", "UUID": "1aeb3246-4c22-4d34-a48c-db7be8ba1b94", "question": "You are given n activities with their start and finish times. Select the maximum number of activities that can be performed by a single person and return their indexes. Assume that a person can only work on a single activity at a time. \n", "examples": "Input: start  =  {10, 12, 20}, finish =  {20, 25, 30}\nOutput: [0, 2]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "import numpy as np\ndef MaxActivities(s: list, f: list) -> list:\n    indices = np.argsort(f)\n    [s[i] for i in indices]\n    [f[i] for i in indices]\n    result = []\n    n = len(f)\n    i = 0\n    result.append(i)\n    for j in range(1, n):\n        if s[j] >= f[i]:\n            result.append(j)\n            i = j\n    return result\n", "asserts": ["assert MaxActivities([2, 4, 5, 6, 7, 8], [3, 5, 6, 7, 9, 10]) == [0, 1, 2, 3, 4]", "assert MaxActivities([1, 3, 0, 5, 8, 5], [2, 4, 6, 7, 9, 9]) == [0, 1, 3, 4]", "assert MaxActivities([1], [2]) == [0]"]}, {"author": "Calvin", "UUID": "48c6aa37-e00d-4b55-9afc-6b1cf2a1aff2", "question": "There are N Mice and N holes are placed in a straight line. Each hole can accommodate only 1 mouse. A mouse can stay at his position, move one step right from x to x + 1, or move one step left from x to x -1. Any of these moves consumes 1 minute. Assign mice to holes so that the time when the last mouse gets inside a hole is minimized.\nYou are given a list of mice and hole positions as integer scalers.\n", "examples": "Input: Mices = [0, 10, 2, 3], Holes = [3, 2, 23, 0]\nOutput: 13", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def assignHole(mices: list, holes: list) -> int:\n    for i,j in zip(mices,holes):\n        if i<0 or j<0:\n            return -1\n    if (len(mices) != len(holes)):\n        return -1\n    mices.sort()\n    holes.sort()\n    Max = 0\n     \n    for i in range(len(holes)):\n        if (Max < abs(mices[i] - holes[i])):\n            Max = abs(mices[i] - holes[i])\n     \n    return Max\n", "asserts": ["assert assignHole([1, 2, 3, 4], [4, 3, 2, 1]) == 0", "assert assignHole([10, 20, 30, 40], [15, 25, 35, 45]) == 5", "assert assignHole([1, 4, 9, 15], [10, 13, 7, 20]) == 6", "assert assignHole([0], [0]) == 0", "assert assignHole([1, 2], [3]) == -1  # Edge case with non-equal amount of mice and holes", "assert assignHole([5, 5, 5], [5, 5, 5]) == 0  # Edge case with all mice and holes at the same position", "assert assignHole([10, 10, 10, 10], [10, 9, 8, 7]) == 3  # Edge case with multiple mice starting at the same position", "assert assignHole([1,1 ,1, 1, 1, 1, 1, 1, 1, 1], [2,2,2,2,2,2 ,2, 2, 2, 2]) == 1 # Edge case with multiple mice and holes at the same positions", "assert assignHole([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == 1 # Edge case with incremental positions"]}], "category": "Array", "prompt_tokens": 1068, "total_tokens": 1442, "completion_tokens": 374, "completion": "Given an array of integers, return the indices of the two numbers that add up to a specific target.\n\nYou may assume that each input would have exactly one solution, and you may not use the same element twice.\n\n###Code: \n\ndef twoSum(nums: list, target: int) -> list:\n    num_to_index = {}\n    for i, num in enumerate(nums):\n        if target - num in num_to_index:\n            return [num_to_index[target - num], i]\n        num_to_index[num] = i\n    return []\n\n###Testcases: \n\nassert twoSum([2, 7, 11, 15], 9) == [0, 1]\nassert twoSum([3, 2, 4], 6) == [1, 2]\nassert twoSum([3, 3], 6) == [0, 1]\nassert twoSum([-1, -2, -3, -4, -5], -8) == [2, 4]\nassert twoSum([20, 50, 40, 25, 30, 10], 90) == [1, 2]\nassert twoSum([1, 4, 5, 11, 12], 15) == [1, 4]\nassert twoSum([0, 4, 3, 0], 0) == [0, 3]\nassert twoSum([-3, 4, 3, 90], 0) == [0, 2]\nassert twoSum([1, 3, 4, 2], 6) == [1, 3]\nassert twoSum([2, 5, 5, 11], 10) == [1, 2] \n\n[/Example 3]", "temperature": 0.795}, {"few_shots": [{"author": "Calvin", "UUID": "f795bda7-9822-4bc5-9c7e-b9c0f2752085", "question": "You are given two 0-indexed integer permutations A and B of length n.\n\nA prefix common array of A and B is an array C such that C[i] is equal to the count of numbers that are present at or before the index i in both A and B.\n\nReturn the prefix common array of A and B.\n\nA sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once.", "examples": "Input: A = [1,3,2,4], B = [3,1,2,4]\nOutput: [0,2,3,4]", "link": "https://leetcode.com/problems/find-the-prefix-common-array-of-two-arrays/", "difficulty": null, "categories": ["Array"], "code": "def findThePrefixCommonArray(arr1: list, arr2: list) -> list:\n  max = len(arr1) if len(arr1) > len(arr2) else len(arr2)\n  seen = set()\n  curCount = 0\n  ret = []\n  for i in range(max):\n    cur1 = arr1[i]\n    cur2 = arr2[i]\n    if cur1 in seen:\n      curCount += 1\n    else:\n      seen.add(cur1)\n    if cur2 in seen:\n      curCount += 1\n    else:\n      seen.add(cur2)\n    ret.append(curCount)\n  return ret\n", "asserts": ["assert findThePrefixCommonArray([1,3,2,4], [3,1,2,4]) == [0,2,3,4]", "assert findThePrefixCommonArray([1], [1]) == [1]", "assert findThePrefixCommonArray([2,3,1], [3,1,2]) == [0,1,3]"]}, {"author": "Calvin", "UUID": "fb94082f-4627-4f5a-b280-08d869823d70", "question": "You are given an array of people, people, which are the attributes of some people in a queue (not necessarily in order). Each people[i] = [hi, ki] represents the ith person of height hi with exactly ki other people in front who have a height greater than or equal to hi.\n\nReconstruct and return the queue that is represented by the input array people. The returned queue should be formatted as an array queue, where queue[j] = [hj, kj] is the attributes of the jth person in the queue (queue[0] is the person at the front of the queue).\n", "examples": "Input:  [[7, 0], [4, 4], [7, 1], [5, 0], [6, 1], [5, 2]]\nOutput: [[5, 0], [4, 1], [7, 0], [5, 2], [6, 1], [7, 1]]\n\nInput:  [[6, 0], [5, 0], [4, 0], [3, 2], [2, 2], [1, 4]]\nOutput: [[4, 0], [5, 0], [2, 2], [3, 2], [1, 4], [6, 0]]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "\ndef reconstructQueue(people: list) -> list:\n    output=[] \n    people.sort(key=lambda x: (-x[0], x[1]))                \n    for a in people:\n        output.insert(a[1], a)\n    \n    return output\n", "asserts": ["assert reconstructQueue([[8,1],[5,0],[6,1],[5,2],[4,4],[7,1]]) == [[5, 0], [8, 1], [5, 2], [6, 1], [4, 4], [7, 1]]", "assert reconstructQueue([[12,0], [6,3], [4,4], [9,2], [7,1]]) == [[12, 0], [7, 1], [9, 2], [6, 3], [4, 4]]", "assert reconstructQueue([[2,0], [1,1]]) == [[2, 0], [1, 1]]", "assert reconstructQueue([[3,0], [3,2], [3,1]]) == [[3, 0], [3, 1], [3, 2]]"]}], "category": "Array", "prompt_tokens": 878, "total_tokens": 1263, "completion_tokens": 385, "completion": "Given an integer array nums of size n, return the difference between the largest and smallest value of nums after performing the following operation exactly once:\n\n - Choose two integers in nums and replace both elements with a single integer equal to the average of these two integers. We can use the floor of the average here.\n\nThe difference between the largest and smallest value of an array is the absolute difference between the maximum and minimum element in the array.\n\n###Code:\n\n```python\nfrom math import floor\n\ndef minMaxAfterOperation(nums: list) -> int:\n    nums.sort()\n    min_val = nums[0]\n    max_val = nums[-1]\n    \n    # Check if replacing the two smallest numbers with their average benefits\n    if (nums[0] + nums[1]) / 2 < nums[0]:\n        nums[0] = floor((nums[0] + nums[1]) / 2)\n        nums.pop(1)\n        min_val = nums[0]\n    \n    # Check if replacing the two largest numbers with their average benefits\n    n = len(nums)\n    if (nums[n - 1] + nums[n - 2]) / 2 > nums[n - 1]:\n        nums[n - 1] = floor((nums[n - 1] + nums[n - 2]) / 2)\n        nums.pop(n - 2)\n        max_val = nums[-1]\n\n    return max_val - min_val\n```\n\n###Testcases:\n\n```python\nassert minMaxAfterOperation([1,5,6,2,8]) == 6\nassert minMaxAfterOperation([1,3,4]) == 3\nassert minMaxAfterOperation([4,1,8,2]) == 6\nassert minMaxAfterOperation([9,4,1,7]) == 8\n```\n\n[/Example 3]", "temperature": 0.888}, {"few_shots": [{"author": "Calvin", "UUID": "fb94082f-4627-4f5a-b280-08d869823d70", "question": "You are given an array of people, people, which are the attributes of some people in a queue (not necessarily in order). Each people[i] = [hi, ki] represents the ith person of height hi with exactly ki other people in front who have a height greater than or equal to hi.\n\nReconstruct and return the queue that is represented by the input array people. The returned queue should be formatted as an array queue, where queue[j] = [hj, kj] is the attributes of the jth person in the queue (queue[0] is the person at the front of the queue).\n", "examples": "Input:  [[7, 0], [4, 4], [7, 1], [5, 0], [6, 1], [5, 2]]\nOutput: [[5, 0], [4, 1], [7, 0], [5, 2], [6, 1], [7, 1]]\n\nInput:  [[6, 0], [5, 0], [4, 0], [3, 2], [2, 2], [1, 4]]\nOutput: [[4, 0], [5, 0], [2, 2], [3, 2], [1, 4], [6, 0]]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "\ndef reconstructQueue(people: list) -> list:\n    output=[] \n    people.sort(key=lambda x: (-x[0], x[1]))                \n    for a in people:\n        output.insert(a[1], a)\n    \n    return output\n", "asserts": ["assert reconstructQueue([[8,1],[5,0],[6,1],[5,2],[4,4],[7,1]]) == [[5, 0], [8, 1], [5, 2], [6, 1], [4, 4], [7, 1]]", "assert reconstructQueue([[12,0], [6,3], [4,4], [9,2], [7,1]]) == [[12, 0], [7, 1], [9, 2], [6, 3], [4, 4]]", "assert reconstructQueue([[2,0], [1,1]]) == [[2, 0], [1, 1]]", "assert reconstructQueue([[3,0], [3,2], [3,1]]) == [[3, 0], [3, 1], [3, 2]]"]}, {"author": "Calvin", "UUID": "9e45b73f-583d-40ab-b387-e0d1624af07b", "question": "Given two arrays return an array with the set intersection of their common elements", "examples": "Input: arr1 = [1, 2, 3, 4], arr2 = [2, 3]\nOutput: [2, 3]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def array_intersection(arr1: list, arr2: list) -> set:\n  set1 = set(arr1)\n  ret = set([x for x in arr2 if x in set1])\n  return list(ret)\n", "asserts": ["assert set(array_intersection([1,0,2,0,2,0,2,1,1,1], [2,1,0,2,0,2,2,2,1,0])) == {0,1,2}", "assert set(array_intersection([5, 6, 7, 8], [8, 9, 10, 11])) == {8}", "assert set(array_intersection([10, 20, 30], [40, 50, 60])) == set()", "assert set(array_intersection([], [1, 2, 3])) == set()", "assert set(array_intersection([-1, -2, -3], [-3, -4, -5, -6])) == {-3}", "assert set(array_intersection([9, 8, 7], [7, 8, 9, 10, 11, 12])) == {7, 8, 9}", "assert set(array_intersection(['a', 'b', 'c'], ['a', 'd', 'e', 'c'])) == {'a', 'c'}", "assert set(array_intersection(['apple', 'banana'], ['banana', 'cherry'])) == {'banana'}", "assert set(array_intersection([1.1, 2.2, 3.3], [2.2, 4.4])) == {2.2}", "assert set(array_intersection([False, True, False], [True, False, True])) == {True, False}", "assert set(array_intersection([(1, 2), (3, 4)], [(3, 4), (5, 6)])) == {(3, 4)}"]}], "category": "Array", "prompt_tokens": 983, "total_tokens": 1452, "completion_tokens": 469, "completion": "Write a function `rotate_array` that takes an array of integers and an integer `n` as inputs and rotates the array to the right by `n` steps. If `n` is negative, the array should be rotated to the left.\n\n###Code: \n\ndef rotate_array(nums: list, n: int) -> list:\n    if not nums:\n        return []\n    n = n % len(nums)  # to handle rotation larger than array size\n    return nums[-n:] + nums[:-n]\n\n###Testcases: \n\n# Rotate to the right (positive steps)\nassert rotate_array([1, 2, 3, 4, 5], 2) == [4, 5, 1, 2, 3]\nassert rotate_array([1, 2, 3, 4, 5, 6, 7], 3) == [5, 6, 7, 1, 2, 3, 4]\n\n# Rotate to the left (negative steps)\nassert rotate_array([1, 2, 3, 4, 5], -2) == [3, 4, 5, 1, 2]\nassert rotate_array([1, 2, 3, 4, 5, 6, 7], -3) == [4, 5, 6, 7, 1, 2, 3]\n\n# No rotation (zero steps)\nassert rotate_array([1, 2, 3, 4, 5], 0) == [1, 2, 3, 4, 5]\n\n# Rotation larger than array size\nassert rotate_array([1, 2, 3, 4, 5], 10) == [1, 2, 3, 4, 5]\n\n# Single element rotation\nassert rotate_array([1], 3) == [1]\n\n# Empty array\nassert rotate_array([], 3) == []\n\n# Rotation with a large negative number\nassert rotate_array([1, 2, 3, 4, 5], -100) == [1, 2, 3, 4, 5]\n\n[/Example 3]", "temperature": 0.886}, {"few_shots": [{"author": "Calvin", "UUID": "48c6aa37-e00d-4b55-9afc-6b1cf2a1aff2", "question": "There are N Mice and N holes are placed in a straight line. Each hole can accommodate only 1 mouse. A mouse can stay at his position, move one step right from x to x + 1, or move one step left from x to x -1. Any of these moves consumes 1 minute. Assign mice to holes so that the time when the last mouse gets inside a hole is minimized.\nYou are given a list of mice and hole positions as integer scalers.\n", "examples": "Input: Mices = [0, 10, 2, 3], Holes = [3, 2, 23, 0]\nOutput: 13", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def assignHole(mices: list, holes: list) -> int:\n    for i,j in zip(mices,holes):\n        if i<0 or j<0:\n            return -1\n    if (len(mices) != len(holes)):\n        return -1\n    mices.sort()\n    holes.sort()\n    Max = 0\n     \n    for i in range(len(holes)):\n        if (Max < abs(mices[i] - holes[i])):\n            Max = abs(mices[i] - holes[i])\n     \n    return Max\n", "asserts": ["assert assignHole([1, 2, 3, 4], [4, 3, 2, 1]) == 0", "assert assignHole([10, 20, 30, 40], [15, 25, 35, 45]) == 5", "assert assignHole([1, 4, 9, 15], [10, 13, 7, 20]) == 6", "assert assignHole([0], [0]) == 0", "assert assignHole([1, 2], [3]) == -1  # Edge case with non-equal amount of mice and holes", "assert assignHole([5, 5, 5], [5, 5, 5]) == 0  # Edge case with all mice and holes at the same position", "assert assignHole([10, 10, 10, 10], [10, 9, 8, 7]) == 3  # Edge case with multiple mice starting at the same position", "assert assignHole([1,1 ,1, 1, 1, 1, 1, 1, 1, 1], [2,2,2,2,2,2 ,2, 2, 2, 2]) == 1 # Edge case with multiple mice and holes at the same positions", "assert assignHole([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == 1 # Edge case with incremental positions"]}, {"author": "Calvin", "UUID": "f795bda7-9822-4bc5-9c7e-b9c0f2752085", "question": "You are given two 0-indexed integer permutations A and B of length n.\n\nA prefix common array of A and B is an array C such that C[i] is equal to the count of numbers that are present at or before the index i in both A and B.\n\nReturn the prefix common array of A and B.\n\nA sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once.", "examples": "Input: A = [1,3,2,4], B = [3,1,2,4]\nOutput: [0,2,3,4]", "link": "https://leetcode.com/problems/find-the-prefix-common-array-of-two-arrays/", "difficulty": null, "categories": ["Array"], "code": "def findThePrefixCommonArray(arr1: list, arr2: list) -> list:\n  max = len(arr1) if len(arr1) > len(arr2) else len(arr2)\n  seen = set()\n  curCount = 0\n  ret = []\n  for i in range(max):\n    cur1 = arr1[i]\n    cur2 = arr2[i]\n    if cur1 in seen:\n      curCount += 1\n    else:\n      seen.add(cur1)\n    if cur2 in seen:\n      curCount += 1\n    else:\n      seen.add(cur2)\n    ret.append(curCount)\n  return ret\n", "asserts": ["assert findThePrefixCommonArray([1,3,2,4], [3,1,2,4]) == [0,2,3,4]", "assert findThePrefixCommonArray([1], [1]) == [1]", "assert findThePrefixCommonArray([2,3,1], [3,1,2]) == [0,1,3]"]}], "category": "Array", "prompt_tokens": 1103, "total_tokens": 1298, "completion_tokens": 195, "completion": "Given an array of integers, you need to find the maximum product of three numbers in the array. The integers in the array can be both positive and negative.\n\n###Code: \n\n```python\ndef maximumProduct(nums: list) -> int:\n    nums.sort()\n    return max(nums[-1] * nums[-2] * nums[-3], nums[0] * nums[1] * nums[-1])\n\n###Testcases: \n\nassert maximumProduct([1, 2, 3]) == 6\nassert maximumProduct([1, 2, 3, 4]) == 24\nassert maximumProduct([-1, -2, -3]) == -6\nassert maximumProduct([-100, -98, -1, 2, 3, 4]) == 39200\nassert maximumProduct([-1, -2, 1, 2, 3]) == 6\n```\n\n[/Example 3]", "temperature": 0.696}, {"few_shots": [{"author": "Calvin", "UUID": "a9c5e697-af5d-432b-8447-5675d739c728", "question": "Given an array reorder it so that even numbers appear first", "examples": "Input: [1,2,3,4,5,6,7,8,9]\r\nOutput: [8,2,6,4,5,7,3,9,1]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def even_odd_reorder(arr: list) -> list:\n  nextEven = 0\n  nextOdd = len(arr) - 1\n  while nextEven < nextOdd:\n    if arr[nextEven] % 2 == 0:\n      nextEven += 1\n    else:\n      temp = arr[nextEven]\n      arr[nextEven] = arr[nextOdd]\n      arr[nextOdd] = temp\n      nextOdd -= 1\n  return arr\n", "asserts": ["assert even_odd_reorder([1,2,3,4,5,6,7,8,9]) == [8, 2, 6, 4, 5, 7, 3, 9, 1]", "assert even_odd_reorder([]) == []", "assert even_odd_reorder([2, 4, 6, 8]) == [2, 4, 6, 8]", "assert even_odd_reorder([7, 9, 2]) == [2, 9, 7]", "assert even_odd_reorder([10, 13, 17, 16, 15, 12]) == [10, 12, 16, 15, 17, 13]"]}, {"author": "Calvin", "UUID": "fb94082f-4627-4f5a-b280-08d869823d70", "question": "You are given an array of people, people, which are the attributes of some people in a queue (not necessarily in order). Each people[i] = [hi, ki] represents the ith person of height hi with exactly ki other people in front who have a height greater than or equal to hi.\n\nReconstruct and return the queue that is represented by the input array people. The returned queue should be formatted as an array queue, where queue[j] = [hj, kj] is the attributes of the jth person in the queue (queue[0] is the person at the front of the queue).\n", "examples": "Input:  [[7, 0], [4, 4], [7, 1], [5, 0], [6, 1], [5, 2]]\nOutput: [[5, 0], [4, 1], [7, 0], [5, 2], [6, 1], [7, 1]]\n\nInput:  [[6, 0], [5, 0], [4, 0], [3, 2], [2, 2], [1, 4]]\nOutput: [[4, 0], [5, 0], [2, 2], [3, 2], [1, 4], [6, 0]]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "\ndef reconstructQueue(people: list) -> list:\n    output=[] \n    people.sort(key=lambda x: (-x[0], x[1]))                \n    for a in people:\n        output.insert(a[1], a)\n    \n    return output\n", "asserts": ["assert reconstructQueue([[8,1],[5,0],[6,1],[5,2],[4,4],[7,1]]) == [[5, 0], [8, 1], [5, 2], [6, 1], [4, 4], [7, 1]]", "assert reconstructQueue([[12,0], [6,3], [4,4], [9,2], [7,1]]) == [[12, 0], [7, 1], [9, 2], [6, 3], [4, 4]]", "assert reconstructQueue([[2,0], [1,1]]) == [[2, 0], [1, 1]]", "assert reconstructQueue([[3,0], [3,2], [3,1]]) == [[3, 0], [3, 1], [3, 2]]"]}], "category": "Array", "prompt_tokens": 842, "total_tokens": 1035, "completion_tokens": 193, "completion": "Given two integer arrays, return their intersection. Each element in the result must be unique and you may return the result in any order.\n\n###Code:\n\ndef intersection(nums1: list, nums2: list) -> list:\n    # Convert both lists to sets to remove duplicates and then find intersection.\n    result = list(set(nums1) & set(nums2))\n    return result\n\n###Testcases:\n\nassert sorted(intersection([1,2,2,1], [2,2])) == [2]\nassert sorted(intersection([4,9,5], [9,4,9,8,4])) == [4, 9]\nassert sorted(intersection([1,7,3], [2,4,6])) == []\nassert sorted(intersection([], [1, 2, 3])) == []\nassert sorted(intersection([2,2,2], [2,2])) == [2]\n\n[/Example 3]", "temperature": 0.935}, {"few_shots": [{"author": "Calvin", "UUID": "f795bda7-9822-4bc5-9c7e-b9c0f2752085", "question": "You are given two 0-indexed integer permutations A and B of length n.\n\nA prefix common array of A and B is an array C such that C[i] is equal to the count of numbers that are present at or before the index i in both A and B.\n\nReturn the prefix common array of A and B.\n\nA sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once.", "examples": "Input: A = [1,3,2,4], B = [3,1,2,4]\nOutput: [0,2,3,4]", "link": "https://leetcode.com/problems/find-the-prefix-common-array-of-two-arrays/", "difficulty": null, "categories": ["Array"], "code": "def findThePrefixCommonArray(arr1: list, arr2: list) -> list:\n  max = len(arr1) if len(arr1) > len(arr2) else len(arr2)\n  seen = set()\n  curCount = 0\n  ret = []\n  for i in range(max):\n    cur1 = arr1[i]\n    cur2 = arr2[i]\n    if cur1 in seen:\n      curCount += 1\n    else:\n      seen.add(cur1)\n    if cur2 in seen:\n      curCount += 1\n    else:\n      seen.add(cur2)\n    ret.append(curCount)\n  return ret\n", "asserts": ["assert findThePrefixCommonArray([1,3,2,4], [3,1,2,4]) == [0,2,3,4]", "assert findThePrefixCommonArray([1], [1]) == [1]", "assert findThePrefixCommonArray([2,3,1], [3,1,2]) == [0,1,3]"]}, {"author": "Calvin", "UUID": "9e45b73f-583d-40ab-b387-e0d1624af07b", "question": "Given two arrays return an array with the set intersection of their common elements", "examples": "Input: arr1 = [1, 2, 3, 4], arr2 = [2, 3]\nOutput: [2, 3]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def array_intersection(arr1: list, arr2: list) -> set:\n  set1 = set(arr1)\n  ret = set([x for x in arr2 if x in set1])\n  return list(ret)\n", "asserts": ["assert set(array_intersection([1,0,2,0,2,0,2,1,1,1], [2,1,0,2,0,2,2,2,1,0])) == {0,1,2}", "assert set(array_intersection([5, 6, 7, 8], [8, 9, 10, 11])) == {8}", "assert set(array_intersection([10, 20, 30], [40, 50, 60])) == set()", "assert set(array_intersection([], [1, 2, 3])) == set()", "assert set(array_intersection([-1, -2, -3], [-3, -4, -5, -6])) == {-3}", "assert set(array_intersection([9, 8, 7], [7, 8, 9, 10, 11, 12])) == {7, 8, 9}", "assert set(array_intersection(['a', 'b', 'c'], ['a', 'd', 'e', 'c'])) == {'a', 'c'}", "assert set(array_intersection(['apple', 'banana'], ['banana', 'cherry'])) == {'banana'}", "assert set(array_intersection([1.1, 2.2, 3.3], [2.2, 4.4])) == {2.2}", "assert set(array_intersection([False, True, False], [True, False, True])) == {True, False}", "assert set(array_intersection([(1, 2), (3, 4)], [(3, 4), (5, 6)])) == {(3, 4)}"]}], "category": "Array", "prompt_tokens": 922, "total_tokens": 1428, "completion_tokens": 506, "completion": "Given an array of distinct integers, return all the triplets `[nums[i], nums[j], nums[k]]` such that `i`, `j`, and `k` are distinct, and `nums[i] + nums[j] + nums[k] == 0`. All the triplets should be unique.\n\n###Code: \n\ndef three_sum(nums: list[int]) -> list[list[int]]:\n    nums.sort()\n    result = []\n    for i in range(len(nums) - 2):\n        if i > 0 and nums[i] == nums[i-1]:\n            continue\n        left, right = i + 1, len(nums) - 1\n        while left < right:\n            sum = nums[i] + nums[left] + nums[right]\n            if sum < 0:\n                left += 1\n            elif sum > 0:\n                right -= 1\n            else:\n                result.append([nums[i], nums[left], nums[right]])\n                while left < right and nums[left] == nums[left + 1]:\n                    left += 1\n                while left < right and nums[right] == nums[right - 1]:\n                    right -= 1\n                left += 1\n                right -= 1\n    return result\n\n\n###Testcases: \n\nassert three_sum([-1, 0, 1, 2, -1, -4]) == [[-1, -1, 2], [-1, 0, 1]]\nassert three_sum([]) == []\nassert three_sum([0]) == []\nassert three_sum([0, 0, 0, 0]) == [[0, 0, 0]]\nassert three_sum([-2, 0, 1, 1, 2]) == [[-2, 0, 2], [-2, 1, 1]]\nassert three_sum([-1, 0, 1, 0]) == [[-1, 0, 1]]\nassert three_sum([3, -2, 1, 0]) == []\nassert three_sum([1, -1, -1, 0]) == [[-1, 0, 1]]\nassert three_sum([-4, -2, 1, 2, 3, 3]) == [[-4, 1, 3], [-2, -2, 4], [-2, 1, 1]]\n\n[/Example 3]", "temperature": 0.783}, {"few_shots": [{"author": "Calvin", "UUID": "9e45b73f-583d-40ab-b387-e0d1624af07b", "question": "Given two arrays return an array with the set intersection of their common elements", "examples": "Input: arr1 = [1, 2, 3, 4], arr2 = [2, 3]\nOutput: [2, 3]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def array_intersection(arr1: list, arr2: list) -> set:\n  set1 = set(arr1)\n  ret = set([x for x in arr2 if x in set1])\n  return list(ret)\n", "asserts": ["assert set(array_intersection([1,0,2,0,2,0,2,1,1,1], [2,1,0,2,0,2,2,2,1,0])) == {0,1,2}", "assert set(array_intersection([5, 6, 7, 8], [8, 9, 10, 11])) == {8}", "assert set(array_intersection([10, 20, 30], [40, 50, 60])) == set()", "assert set(array_intersection([], [1, 2, 3])) == set()", "assert set(array_intersection([-1, -2, -3], [-3, -4, -5, -6])) == {-3}", "assert set(array_intersection([9, 8, 7], [7, 8, 9, 10, 11, 12])) == {7, 8, 9}", "assert set(array_intersection(['a', 'b', 'c'], ['a', 'd', 'e', 'c'])) == {'a', 'c'}", "assert set(array_intersection(['apple', 'banana'], ['banana', 'cherry'])) == {'banana'}", "assert set(array_intersection([1.1, 2.2, 3.3], [2.2, 4.4])) == {2.2}", "assert set(array_intersection([False, True, False], [True, False, True])) == {True, False}", "assert set(array_intersection([(1, 2), (3, 4)], [(3, 4), (5, 6)])) == {(3, 4)}"]}, {"author": "Calvin", "UUID": "1aeb3246-4c22-4d34-a48c-db7be8ba1b94", "question": "You are given n activities with their start and finish times. Select the maximum number of activities that can be performed by a single person and return their indexes. Assume that a person can only work on a single activity at a time. \n", "examples": "Input: start  =  {10, 12, 20}, finish =  {20, 25, 30}\nOutput: [0, 2]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "import numpy as np\ndef MaxActivities(s: list, f: list) -> list:\n    indices = np.argsort(f)\n    [s[i] for i in indices]\n    [f[i] for i in indices]\n    result = []\n    n = len(f)\n    i = 0\n    result.append(i)\n    for j in range(1, n):\n        if s[j] >= f[i]:\n            result.append(j)\n            i = j\n    return result\n", "asserts": ["assert MaxActivities([2, 4, 5, 6, 7, 8], [3, 5, 6, 7, 9, 10]) == [0, 1, 2, 3, 4]", "assert MaxActivities([1, 3, 0, 5, 8, 5], [2, 4, 6, 7, 9, 9]) == [0, 1, 3, 4]", "assert MaxActivities([1], [2]) == [0]"]}], "category": "Array", "prompt_tokens": 887, "total_tokens": 1448, "completion_tokens": 561, "completion": "Write a function that merges two sorted arrays into a single sorted array. The function should not use any built-in sort functions and should perform the merge in-place, using the first array to store the result if it has enough space to hold the combined elements from both arrays. If the first array does not have enough space, then return a new array with the merged elements.\n\n###Code:\n\ndef merge_sorted_arrays(arr1: list, arr2: list) -> list:\n    if len(arr1) >= len(arr1) + len(arr2):\n        result = arr1\n    else:\n        result = arr1 + [None] * (len(arr2) - (len(arr1) - len(arr2)))\n\n    m, n = len(arr1), len(arr2)\n    i, j, k = m-1, n-1, m+n-1\n    \n    while i >= 0 and j >= 0:\n        if arr1[i] > arr2[j]:\n            result[k] = arr1[i]\n            i -= 1\n        else:\n            result[k] = arr2[j]\n            j -= 1\n        k -= 1\n\n    while j >= 0:\n        result[k] = arr2[j]\n        j -= 1\n        k -= 1\n\n    return result\n\n\n###Testcases:\n\nassert merge_sorted_arrays([1, 2, 3, 0, 0, 0], [2, 5, 6]) == [1, 2, 2, 3, 5, 6]\nassert merge_sorted_arrays([1, 3, 5, 7], [2, 4, 6, 8]) == [1, 2, 3, 4, 5, 6, 7, 8]\nassert merge_sorted_arrays([4, 0, 0, 0], [1, 2, 3]) == [1, 2, 3, 4]\nassert merge_sorted_arrays([], [1, 2, 3]) == [1, 2, 3]\nassert merge_sorted_arrays([1, 2, 3], []) == [1, 2, 3]\nassert merge_sorted_arrays([5, 6, 7], [1, 2, 8]) == [1, 2, 5, 6, 7, 8]\nassert merge_sorted_arrays([1, 3, 5, 0, 0, 0], [2, 4, 6]) == [1, 2, 3, 4, 5, 6]\n\n[/Example 3]", "temperature": 0.929}, {"few_shots": [{"author": "Calvin", "UUID": "9e45b73f-583d-40ab-b387-e0d1624af07b", "question": "Given two arrays return an array with the set intersection of their common elements", "examples": "Input: arr1 = [1, 2, 3, 4], arr2 = [2, 3]\nOutput: [2, 3]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def array_intersection(arr1: list, arr2: list) -> set:\n  set1 = set(arr1)\n  ret = set([x for x in arr2 if x in set1])\n  return list(ret)\n", "asserts": ["assert set(array_intersection([1,0,2,0,2,0,2,1,1,1], [2,1,0,2,0,2,2,2,1,0])) == {0,1,2}", "assert set(array_intersection([5, 6, 7, 8], [8, 9, 10, 11])) == {8}", "assert set(array_intersection([10, 20, 30], [40, 50, 60])) == set()", "assert set(array_intersection([], [1, 2, 3])) == set()", "assert set(array_intersection([-1, -2, -3], [-3, -4, -5, -6])) == {-3}", "assert set(array_intersection([9, 8, 7], [7, 8, 9, 10, 11, 12])) == {7, 8, 9}", "assert set(array_intersection(['a', 'b', 'c'], ['a', 'd', 'e', 'c'])) == {'a', 'c'}", "assert set(array_intersection(['apple', 'banana'], ['banana', 'cherry'])) == {'banana'}", "assert set(array_intersection([1.1, 2.2, 3.3], [2.2, 4.4])) == {2.2}", "assert set(array_intersection([False, True, False], [True, False, True])) == {True, False}", "assert set(array_intersection([(1, 2), (3, 4)], [(3, 4), (5, 6)])) == {(3, 4)}"]}, {"author": "Calvin", "UUID": "fb94082f-4627-4f5a-b280-08d869823d70", "question": "You are given an array of people, people, which are the attributes of some people in a queue (not necessarily in order). Each people[i] = [hi, ki] represents the ith person of height hi with exactly ki other people in front who have a height greater than or equal to hi.\n\nReconstruct and return the queue that is represented by the input array people. The returned queue should be formatted as an array queue, where queue[j] = [hj, kj] is the attributes of the jth person in the queue (queue[0] is the person at the front of the queue).\n", "examples": "Input:  [[7, 0], [4, 4], [7, 1], [5, 0], [6, 1], [5, 2]]\nOutput: [[5, 0], [4, 1], [7, 0], [5, 2], [6, 1], [7, 1]]\n\nInput:  [[6, 0], [5, 0], [4, 0], [3, 2], [2, 2], [1, 4]]\nOutput: [[4, 0], [5, 0], [2, 2], [3, 2], [1, 4], [6, 0]]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "\ndef reconstructQueue(people: list) -> list:\n    output=[] \n    people.sort(key=lambda x: (-x[0], x[1]))                \n    for a in people:\n        output.insert(a[1], a)\n    \n    return output\n", "asserts": ["assert reconstructQueue([[8,1],[5,0],[6,1],[5,2],[4,4],[7,1]]) == [[5, 0], [8, 1], [5, 2], [6, 1], [4, 4], [7, 1]]", "assert reconstructQueue([[12,0], [6,3], [4,4], [9,2], [7,1]]) == [[12, 0], [7, 1], [9, 2], [6, 3], [4, 4]]", "assert reconstructQueue([[2,0], [1,1]]) == [[2, 0], [1, 1]]", "assert reconstructQueue([[3,0], [3,2], [3,1]]) == [[3, 0], [3, 1], [3, 2]]"]}], "category": "Array", "prompt_tokens": 983, "total_tokens": 1360, "completion_tokens": 377, "completion": "Write a function that given an array of integers, returns the maximum sum of a subsequence such that no two numbers in the sequence are adjacent in the original array.\n\n###Code:\n\n```python\ndef max_non_adjacent_sum(nums: list) -> int:\n    include, exclude = 0, 0\n    for num in nums:\n        new_exclude = max(include, exclude)\n        include = exclude + num\n        exclude = new_exclude\n    return max(include, exclude)\n\n```\n\n###Testcases:\n\n```python\nassert max_non_adjacent_sum([3, 2, 7, 10]) == 13 # choose numbers 3 and 10\nassert max_non_adjacent_sum([3, 2, 5, 10, 7]) == 15 # choose numbers 3, 5 and 7\nassert max_non_adjacent_sum([2, 1, 1, 2]) == 4 # choose numbers 2 and 2\nassert max_non_adjacent_sum([-2, 1, 3, -4, 5]) == 8 # choose numbers 1 and 5\nassert max_non_adjacent_sum([0, 0, 0, 0, 0]) == 0 # choose no numbers\nassert max_non_adjacent_sum([5, 5, 10, 100, 10, 5]) == 110 # choose numbers 5, 100 and 5\nassert max_non_adjacent_sum([3, -1, 4, -1, 5]) == 9 # choose numbers 3 and 5\nassert max_non_adjacent_sum([3, 2, -3, -1, 10]) == 13 # choose numbers 3 and 10\n```\n\n[/Example 3]", "temperature": 0.678}, {"few_shots": [{"author": "Calvin", "UUID": "1aeb3246-4c22-4d34-a48c-db7be8ba1b94", "question": "You are given n activities with their start and finish times. Select the maximum number of activities that can be performed by a single person and return their indexes. Assume that a person can only work on a single activity at a time. \n", "examples": "Input: start  =  {10, 12, 20}, finish =  {20, 25, 30}\nOutput: [0, 2]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "import numpy as np\ndef MaxActivities(s: list, f: list) -> list:\n    indices = np.argsort(f)\n    [s[i] for i in indices]\n    [f[i] for i in indices]\n    result = []\n    n = len(f)\n    i = 0\n    result.append(i)\n    for j in range(1, n):\n        if s[j] >= f[i]:\n            result.append(j)\n            i = j\n    return result\n", "asserts": ["assert MaxActivities([2, 4, 5, 6, 7, 8], [3, 5, 6, 7, 9, 10]) == [0, 1, 2, 3, 4]", "assert MaxActivities([1, 3, 0, 5, 8, 5], [2, 4, 6, 7, 9, 9]) == [0, 1, 3, 4]", "assert MaxActivities([1], [2]) == [0]"]}, {"author": "Calvin", "UUID": "fb94082f-4627-4f5a-b280-08d869823d70", "question": "You are given an array of people, people, which are the attributes of some people in a queue (not necessarily in order). Each people[i] = [hi, ki] represents the ith person of height hi with exactly ki other people in front who have a height greater than or equal to hi.\n\nReconstruct and return the queue that is represented by the input array people. The returned queue should be formatted as an array queue, where queue[j] = [hj, kj] is the attributes of the jth person in the queue (queue[0] is the person at the front of the queue).\n", "examples": "Input:  [[7, 0], [4, 4], [7, 1], [5, 0], [6, 1], [5, 2]]\nOutput: [[5, 0], [4, 1], [7, 0], [5, 2], [6, 1], [7, 1]]\n\nInput:  [[6, 0], [5, 0], [4, 0], [3, 2], [2, 2], [1, 4]]\nOutput: [[4, 0], [5, 0], [2, 2], [3, 2], [1, 4], [6, 0]]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "\ndef reconstructQueue(people: list) -> list:\n    output=[] \n    people.sort(key=lambda x: (-x[0], x[1]))                \n    for a in people:\n        output.insert(a[1], a)\n    \n    return output\n", "asserts": ["assert reconstructQueue([[8,1],[5,0],[6,1],[5,2],[4,4],[7,1]]) == [[5, 0], [8, 1], [5, 2], [6, 1], [4, 4], [7, 1]]", "assert reconstructQueue([[12,0], [6,3], [4,4], [9,2], [7,1]]) == [[12, 0], [7, 1], [9, 2], [6, 3], [4, 4]]", "assert reconstructQueue([[2,0], [1,1]]) == [[2, 0], [1, 1]]", "assert reconstructQueue([[3,0], [3,2], [3,1]]) == [[3, 0], [3, 1], [3, 2]]"]}], "category": "Array", "prompt_tokens": 843, "total_tokens": 1092, "completion_tokens": 249, "completion": "Write a function that takes an unsorted array of integers and returns the length of the longest consecutive elements sequence. Your algorithm should run in O(n) complexity.\n\n###Code: \n\n```python\ndef longestConsecutive(nums: list) -> int:\n    if not nums:\n        return 0\n\n    nums_set = set(nums)\n    longest_streak = 0\n\n    for num in nums_set:\n        if num - 1 not in nums_set:\n            current_num = num\n            current_streak = 1\n\n            while current_num + 1 in nums_set:\n                current_num += 1\n                current_streak += 1\n\n            longest_streak = max(longest_streak, current_streak)\n\n    return longest_streak\n```\n\n###Testcases: \n\n```python\nassert longestConsecutive([100, 4, 200, 1, 3, 2]) == 4\nassert longestConsecutive([9,1,4,7,3,-1,0,5,8,-1,6]) == 7\nassert longestConsecutive([]) == 0\nassert longestConsecutive([0]) == 1\n```\n\n[/Example 3]", "temperature": 0.794}, {"few_shots": [{"author": "Calvin", "UUID": "f795bda7-9822-4bc5-9c7e-b9c0f2752085", "question": "You are given two 0-indexed integer permutations A and B of length n.\n\nA prefix common array of A and B is an array C such that C[i] is equal to the count of numbers that are present at or before the index i in both A and B.\n\nReturn the prefix common array of A and B.\n\nA sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once.", "examples": "Input: A = [1,3,2,4], B = [3,1,2,4]\nOutput: [0,2,3,4]", "link": "https://leetcode.com/problems/find-the-prefix-common-array-of-two-arrays/", "difficulty": null, "categories": ["Array"], "code": "def findThePrefixCommonArray(arr1: list, arr2: list) -> list:\n  max = len(arr1) if len(arr1) > len(arr2) else len(arr2)\n  seen = set()\n  curCount = 0\n  ret = []\n  for i in range(max):\n    cur1 = arr1[i]\n    cur2 = arr2[i]\n    if cur1 in seen:\n      curCount += 1\n    else:\n      seen.add(cur1)\n    if cur2 in seen:\n      curCount += 1\n    else:\n      seen.add(cur2)\n    ret.append(curCount)\n  return ret\n", "asserts": ["assert findThePrefixCommonArray([1,3,2,4], [3,1,2,4]) == [0,2,3,4]", "assert findThePrefixCommonArray([1], [1]) == [1]", "assert findThePrefixCommonArray([2,3,1], [3,1,2]) == [0,1,3]"]}, {"author": "Calvin", "UUID": "48c6aa37-e00d-4b55-9afc-6b1cf2a1aff2", "question": "There are N Mice and N holes are placed in a straight line. Each hole can accommodate only 1 mouse. A mouse can stay at his position, move one step right from x to x + 1, or move one step left from x to x -1. Any of these moves consumes 1 minute. Assign mice to holes so that the time when the last mouse gets inside a hole is minimized.\nYou are given a list of mice and hole positions as integer scalers.\n", "examples": "Input: Mices = [0, 10, 2, 3], Holes = [3, 2, 23, 0]\nOutput: 13", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def assignHole(mices: list, holes: list) -> int:\n    for i,j in zip(mices,holes):\n        if i<0 or j<0:\n            return -1\n    if (len(mices) != len(holes)):\n        return -1\n    mices.sort()\n    holes.sort()\n    Max = 0\n     \n    for i in range(len(holes)):\n        if (Max < abs(mices[i] - holes[i])):\n            Max = abs(mices[i] - holes[i])\n     \n    return Max\n", "asserts": ["assert assignHole([1, 2, 3, 4], [4, 3, 2, 1]) == 0", "assert assignHole([10, 20, 30, 40], [15, 25, 35, 45]) == 5", "assert assignHole([1, 4, 9, 15], [10, 13, 7, 20]) == 6", "assert assignHole([0], [0]) == 0", "assert assignHole([1, 2], [3]) == -1  # Edge case with non-equal amount of mice and holes", "assert assignHole([5, 5, 5], [5, 5, 5]) == 0  # Edge case with all mice and holes at the same position", "assert assignHole([10, 10, 10, 10], [10, 9, 8, 7]) == 3  # Edge case with multiple mice starting at the same position", "assert assignHole([1,1 ,1, 1, 1, 1, 1, 1, 1, 1], [2,2,2,2,2,2 ,2, 2, 2, 2]) == 1 # Edge case with multiple mice and holes at the same positions", "assert assignHole([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == 1 # Edge case with incremental positions"]}], "category": "Array", "prompt_tokens": 1103, "total_tokens": 1566, "completion_tokens": 463, "completion": "Given an integer array nums and an integer val, remove all occurrences of val in nums in-place. The relative order of the elements may be changed.\n\nIt doesn't matter what you leave beyond the new length.\n\nReturn the new length of the array after the removal.\n\n###Code: \n\ndef removeElement(nums: list, val: int) -> int:\n    k = 0  # Initialize a pointer for the position of the non-val elements\n    for i in range(len(nums)):\n        if nums[i] != val:\n            nums[k] = nums[i]\n            k += 1\n    return k\n\n###Testcases: \n\nassert removeElement([3, 2, 2, 3], 3) == 2  # After function, array starts with [2, 2]\nassert removeElement([0, 1, 2, 2, 3, 0, 4, 2], 2) == 5  # After function, array starts with [0, 1, 3, 0, 4]\nassert removeElement([1], 1) == 0  # After function, array is empty\nassert removeElement([2, 2, 2], 2) == 0  # After function, array is empty\nassert removeElement([4, 1, 2, 3, 5], 4) == 4  # After function, array starts with [1, 2, 3, 5]\nassert removeElement([], 1) == 0  # Edge case with empty array\nassert removeElement([1, 1, 1, 1, 1], 2) == 5  # Edge case with no occurrence of val, array remains unchanged\nassert removeElement([2, 3, 3, 2, 4], 3) == 3  # After function, array starts with [2, 2, 4]\nassert removeElement([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10) == 9 # Edge case with val at the last position\n\n[/Example 3]", "temperature": 0.804}, {"few_shots": [{"author": "Calvin", "UUID": "48c6aa37-e00d-4b55-9afc-6b1cf2a1aff2", "question": "There are N Mice and N holes are placed in a straight line. Each hole can accommodate only 1 mouse. A mouse can stay at his position, move one step right from x to x + 1, or move one step left from x to x -1. Any of these moves consumes 1 minute. Assign mice to holes so that the time when the last mouse gets inside a hole is minimized.\nYou are given a list of mice and hole positions as integer scalers.\n", "examples": "Input: Mices = [0, 10, 2, 3], Holes = [3, 2, 23, 0]\nOutput: 13", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def assignHole(mices: list, holes: list) -> int:\n    for i,j in zip(mices,holes):\n        if i<0 or j<0:\n            return -1\n    if (len(mices) != len(holes)):\n        return -1\n    mices.sort()\n    holes.sort()\n    Max = 0\n     \n    for i in range(len(holes)):\n        if (Max < abs(mices[i] - holes[i])):\n            Max = abs(mices[i] - holes[i])\n     \n    return Max\n", "asserts": ["assert assignHole([1, 2, 3, 4], [4, 3, 2, 1]) == 0", "assert assignHole([10, 20, 30, 40], [15, 25, 35, 45]) == 5", "assert assignHole([1, 4, 9, 15], [10, 13, 7, 20]) == 6", "assert assignHole([0], [0]) == 0", "assert assignHole([1, 2], [3]) == -1  # Edge case with non-equal amount of mice and holes", "assert assignHole([5, 5, 5], [5, 5, 5]) == 0  # Edge case with all mice and holes at the same position", "assert assignHole([10, 10, 10, 10], [10, 9, 8, 7]) == 3  # Edge case with multiple mice starting at the same position", "assert assignHole([1,1 ,1, 1, 1, 1, 1, 1, 1, 1], [2,2,2,2,2,2 ,2, 2, 2, 2]) == 1 # Edge case with multiple mice and holes at the same positions", "assert assignHole([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == 1 # Edge case with incremental positions"]}, {"author": "Calvin", "UUID": "9e45b73f-583d-40ab-b387-e0d1624af07b", "question": "Given two arrays return an array with the set intersection of their common elements", "examples": "Input: arr1 = [1, 2, 3, 4], arr2 = [2, 3]\nOutput: [2, 3]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def array_intersection(arr1: list, arr2: list) -> set:\n  set1 = set(arr1)\n  ret = set([x for x in arr2 if x in set1])\n  return list(ret)\n", "asserts": ["assert set(array_intersection([1,0,2,0,2,0,2,1,1,1], [2,1,0,2,0,2,2,2,1,0])) == {0,1,2}", "assert set(array_intersection([5, 6, 7, 8], [8, 9, 10, 11])) == {8}", "assert set(array_intersection([10, 20, 30], [40, 50, 60])) == set()", "assert set(array_intersection([], [1, 2, 3])) == set()", "assert set(array_intersection([-1, -2, -3], [-3, -4, -5, -6])) == {-3}", "assert set(array_intersection([9, 8, 7], [7, 8, 9, 10, 11, 12])) == {7, 8, 9}", "assert set(array_intersection(['a', 'b', 'c'], ['a', 'd', 'e', 'c'])) == {'a', 'c'}", "assert set(array_intersection(['apple', 'banana'], ['banana', 'cherry'])) == {'banana'}", "assert set(array_intersection([1.1, 2.2, 3.3], [2.2, 4.4])) == {2.2}", "assert set(array_intersection([False, True, False], [True, False, True])) == {True, False}", "assert set(array_intersection([(1, 2), (3, 4)], [(3, 4), (5, 6)])) == {(3, 4)}"]}], "category": "Array", "prompt_tokens": 1208, "total_tokens": 1530, "completion_tokens": 322, "completion": "Given an array of unique integers and a target value, determine if there is a pair of integers in the array that sums up to the target value.\n\n###Code: \n\ndef has_pair_with_sum(arr: list, target: int) -> bool:\n    seen = set()\n    for num in arr:\n        if target - num in seen:\n            return True\n        seen.add(num)\n    return False\n\n###Testcases: \n\nassert has_pair_with_sum([1, 2, 3, 4], 5) == True\nassert has_pair_with_sum([1, 2, 3, 4], 8) == False\nassert has_pair_with_sum([-1, -2, -3, -4], -7) == True\nassert has_pair_with_sum([1, 3, 5, 7], 12) == False\nassert has_pair_with_sum([0, 14, 3, 7], 17) == True\nassert has_pair_with_sum([1, 5, 7, -1], 6) == True\nassert has_pair_with_sum([10, 15, 3, 7], 17) == True\nassert has_pair_with_sum([10, 15, 3, 4], 19) == True\nassert has_pair_with_sum([1, 2, 3, 6], 9) == True\nassert has_pair_with_sum([0, 2, 9, 11], 0) == False\n\n[/Example 3]", "temperature": 0.847}, {"few_shots": [{"author": "Calvin", "UUID": "fb94082f-4627-4f5a-b280-08d869823d70", "question": "You are given an array of people, people, which are the attributes of some people in a queue (not necessarily in order). Each people[i] = [hi, ki] represents the ith person of height hi with exactly ki other people in front who have a height greater than or equal to hi.\n\nReconstruct and return the queue that is represented by the input array people. The returned queue should be formatted as an array queue, where queue[j] = [hj, kj] is the attributes of the jth person in the queue (queue[0] is the person at the front of the queue).\n", "examples": "Input:  [[7, 0], [4, 4], [7, 1], [5, 0], [6, 1], [5, 2]]\nOutput: [[5, 0], [4, 1], [7, 0], [5, 2], [6, 1], [7, 1]]\n\nInput:  [[6, 0], [5, 0], [4, 0], [3, 2], [2, 2], [1, 4]]\nOutput: [[4, 0], [5, 0], [2, 2], [3, 2], [1, 4], [6, 0]]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "\ndef reconstructQueue(people: list) -> list:\n    output=[] \n    people.sort(key=lambda x: (-x[0], x[1]))                \n    for a in people:\n        output.insert(a[1], a)\n    \n    return output\n", "asserts": ["assert reconstructQueue([[8,1],[5,0],[6,1],[5,2],[4,4],[7,1]]) == [[5, 0], [8, 1], [5, 2], [6, 1], [4, 4], [7, 1]]", "assert reconstructQueue([[12,0], [6,3], [4,4], [9,2], [7,1]]) == [[12, 0], [7, 1], [9, 2], [6, 3], [4, 4]]", "assert reconstructQueue([[2,0], [1,1]]) == [[2, 0], [1, 1]]", "assert reconstructQueue([[3,0], [3,2], [3,1]]) == [[3, 0], [3, 1], [3, 2]]"]}, {"author": "Calvin", "UUID": "a9c5e697-af5d-432b-8447-5675d739c728", "question": "Given an array reorder it so that even numbers appear first", "examples": "Input: [1,2,3,4,5,6,7,8,9]\r\nOutput: [8,2,6,4,5,7,3,9,1]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def even_odd_reorder(arr: list) -> list:\n  nextEven = 0\n  nextOdd = len(arr) - 1\n  while nextEven < nextOdd:\n    if arr[nextEven] % 2 == 0:\n      nextEven += 1\n    else:\n      temp = arr[nextEven]\n      arr[nextEven] = arr[nextOdd]\n      arr[nextOdd] = temp\n      nextOdd -= 1\n  return arr\n", "asserts": ["assert even_odd_reorder([1,2,3,4,5,6,7,8,9]) == [8, 2, 6, 4, 5, 7, 3, 9, 1]", "assert even_odd_reorder([]) == []", "assert even_odd_reorder([2, 4, 6, 8]) == [2, 4, 6, 8]", "assert even_odd_reorder([7, 9, 2]) == [2, 9, 7]", "assert even_odd_reorder([10, 13, 17, 16, 15, 12]) == [10, 12, 16, 15, 17, 13]"]}], "category": "Array", "prompt_tokens": 842, "total_tokens": 1055, "completion_tokens": 213, "completion": "Given an array of integers `nums` and an integer `k`, rotate the array to the right by `k` steps, where `k` is non-negative.\n\n###Code: \n\n```python\ndef rotateArray(nums: list, k: int) -> None:\n    k = k % len(nums)\n    nums[:] = nums[-k:] + nums[:-k]\n\n###Testcases: \n\nassert rotateArray([1,2,3,4,5,6,7], 3) == [5,6,7,1,2,3,4]\nassert rotateArray([-1,-100,3,99], 2) == [3,99,-1,-100]\nassert rotateArray([1,2], 3) == [2,1]\nassert rotateArray([1], 0) == [1]\nassert rotateArray([1,2,3,4,5,6], 11) == [2,3,4,5,6,1]\n```\n\n[/Example 3]", "temperature": 0.79}, {"few_shots": [{"author": "Calvin", "UUID": "a9c5e697-af5d-432b-8447-5675d739c728", "question": "Given an array reorder it so that even numbers appear first", "examples": "Input: [1,2,3,4,5,6,7,8,9]\r\nOutput: [8,2,6,4,5,7,3,9,1]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def even_odd_reorder(arr: list) -> list:\n  nextEven = 0\n  nextOdd = len(arr) - 1\n  while nextEven < nextOdd:\n    if arr[nextEven] % 2 == 0:\n      nextEven += 1\n    else:\n      temp = arr[nextEven]\n      arr[nextEven] = arr[nextOdd]\n      arr[nextOdd] = temp\n      nextOdd -= 1\n  return arr\n", "asserts": ["assert even_odd_reorder([1,2,3,4,5,6,7,8,9]) == [8, 2, 6, 4, 5, 7, 3, 9, 1]", "assert even_odd_reorder([]) == []", "assert even_odd_reorder([2, 4, 6, 8]) == [2, 4, 6, 8]", "assert even_odd_reorder([7, 9, 2]) == [2, 9, 7]", "assert even_odd_reorder([10, 13, 17, 16, 15, 12]) == [10, 12, 16, 15, 17, 13]"]}, {"author": "Calvin", "UUID": "fb94082f-4627-4f5a-b280-08d869823d70", "question": "You are given an array of people, people, which are the attributes of some people in a queue (not necessarily in order). Each people[i] = [hi, ki] represents the ith person of height hi with exactly ki other people in front who have a height greater than or equal to hi.\n\nReconstruct and return the queue that is represented by the input array people. The returned queue should be formatted as an array queue, where queue[j] = [hj, kj] is the attributes of the jth person in the queue (queue[0] is the person at the front of the queue).\n", "examples": "Input:  [[7, 0], [4, 4], [7, 1], [5, 0], [6, 1], [5, 2]]\nOutput: [[5, 0], [4, 1], [7, 0], [5, 2], [6, 1], [7, 1]]\n\nInput:  [[6, 0], [5, 0], [4, 0], [3, 2], [2, 2], [1, 4]]\nOutput: [[4, 0], [5, 0], [2, 2], [3, 2], [1, 4], [6, 0]]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "\ndef reconstructQueue(people: list) -> list:\n    output=[] \n    people.sort(key=lambda x: (-x[0], x[1]))                \n    for a in people:\n        output.insert(a[1], a)\n    \n    return output\n", "asserts": ["assert reconstructQueue([[8,1],[5,0],[6,1],[5,2],[4,4],[7,1]]) == [[5, 0], [8, 1], [5, 2], [6, 1], [4, 4], [7, 1]]", "assert reconstructQueue([[12,0], [6,3], [4,4], [9,2], [7,1]]) == [[12, 0], [7, 1], [9, 2], [6, 3], [4, 4]]", "assert reconstructQueue([[2,0], [1,1]]) == [[2, 0], [1, 1]]", "assert reconstructQueue([[3,0], [3,2], [3,1]]) == [[3, 0], [3, 1], [3, 2]]"]}], "category": "Array", "prompt_tokens": 842, "total_tokens": 1569, "completion_tokens": 727, "completion": "Write a function that rotates an array to the right by k steps, where k is non-negative, and try to come up as many solutions as you can, and analyze their time and space complexity.\n\n###Code:\n\n```python\n# Solution 1: Using list slicing\ndef rotate_array(arr: list, k: int) -> list:\n    n = len(arr)\n    k %= n  # to handle cases where k is more than n\n    return arr[-k:] + arr[:-k]\n\n# Solution 2: Using reverse\ndef rotate_array_in_place(arr: list, k: int) -> None:\n    def reverse(nums: list, start: int, end: int) -> None:\n        while start < end:\n            nums[start], nums[end] = nums[end], nums[start]\n            start, end = start + 1, end - 1\n    n = len(arr)\n    k %= n\n    reverse(arr, 0, n - 1)\n    reverse(arr, 0, k - 1)\n    reverse(arr, k, n - 1)\n    return arr\n\n# Solution 3: Using extra array\ndef rotate_array_extra_space(arr: list, k: int) -> list:\n    n = len(arr)\n    k %= n\n    rotated = [0] * n\n    for i in range(n):\n        rotated[(i + k) % n] = arr[i]\n    return rotated\n```\n\n###Testcases:\n\n```python\n# For Solution 1\nassert rotate_array([1,2,3,4,5,6,7], 3) == [5,6,7,1,2,3,4]\nassert rotate_array([-1,-100,3,99], 2) == [3,99,-1,-100]\nassert rotate_array([1,2,3], 0) == [1,2,3]\n\n# For Solution 2\narr = [1,2,3,4,5,6,7]\nrotate_array_in_place(arr, 3)\nassert arr == [5,6,7,1,2,3,4]\n\narr = [-1,-100,3,99]\nrotate_array_in_place(arr, 2)\nassert arr == [3,99,-1,-100]\n\narr = [1,2,3]\nrotate_array_in_place(arr, 0)\nassert arr == [1,2,3]\n\n# For Solution 3\nassert rotate_array_extra_space([1,2,3,4,5,6], 2) == [5,6,1,2,3,4]\nassert rotate_array_extra_space([1,2,3,4,5,6], 7) == [6,1,2,3,4,5]\nassert rotate_array_extra_space([1], 10) == [1]\n```\n\n###Analysis:\n\n- Solution 1 (List Slicing): Time complexity is O(n) due to the slicing of the list, and the space complexity is O(n) because it creates a new list.\n  \n- Solution 2 (In-Place Reverse): Time complexity is O(n) since each element is moved once, and the space complexity is O(1) because it rotates the array in place.\n  \n- Solution 3 (Extra Space): Time complexity is O(n) as it traverses the list once, and the space complexity is O(n) due to the creation of an additional array.\n\n[/Example 3]", "temperature": 0.83}, {"few_shots": [{"author": "Calvin", "UUID": "fb94082f-4627-4f5a-b280-08d869823d70", "question": "You are given an array of people, people, which are the attributes of some people in a queue (not necessarily in order). Each people[i] = [hi, ki] represents the ith person of height hi with exactly ki other people in front who have a height greater than or equal to hi.\n\nReconstruct and return the queue that is represented by the input array people. The returned queue should be formatted as an array queue, where queue[j] = [hj, kj] is the attributes of the jth person in the queue (queue[0] is the person at the front of the queue).\n", "examples": "Input:  [[7, 0], [4, 4], [7, 1], [5, 0], [6, 1], [5, 2]]\nOutput: [[5, 0], [4, 1], [7, 0], [5, 2], [6, 1], [7, 1]]\n\nInput:  [[6, 0], [5, 0], [4, 0], [3, 2], [2, 2], [1, 4]]\nOutput: [[4, 0], [5, 0], [2, 2], [3, 2], [1, 4], [6, 0]]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "\ndef reconstructQueue(people: list) -> list:\n    output=[] \n    people.sort(key=lambda x: (-x[0], x[1]))                \n    for a in people:\n        output.insert(a[1], a)\n    \n    return output\n", "asserts": ["assert reconstructQueue([[8,1],[5,0],[6,1],[5,2],[4,4],[7,1]]) == [[5, 0], [8, 1], [5, 2], [6, 1], [4, 4], [7, 1]]", "assert reconstructQueue([[12,0], [6,3], [4,4], [9,2], [7,1]]) == [[12, 0], [7, 1], [9, 2], [6, 3], [4, 4]]", "assert reconstructQueue([[2,0], [1,1]]) == [[2, 0], [1, 1]]", "assert reconstructQueue([[3,0], [3,2], [3,1]]) == [[3, 0], [3, 1], [3, 2]]"]}, {"author": "Calvin", "UUID": "1aeb3246-4c22-4d34-a48c-db7be8ba1b94", "question": "You are given n activities with their start and finish times. Select the maximum number of activities that can be performed by a single person and return their indexes. Assume that a person can only work on a single activity at a time. \n", "examples": "Input: start  =  {10, 12, 20}, finish =  {20, 25, 30}\nOutput: [0, 2]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "import numpy as np\ndef MaxActivities(s: list, f: list) -> list:\n    indices = np.argsort(f)\n    [s[i] for i in indices]\n    [f[i] for i in indices]\n    result = []\n    n = len(f)\n    i = 0\n    result.append(i)\n    for j in range(1, n):\n        if s[j] >= f[i]:\n            result.append(j)\n            i = j\n    return result\n", "asserts": ["assert MaxActivities([2, 4, 5, 6, 7, 8], [3, 5, 6, 7, 9, 10]) == [0, 1, 2, 3, 4]", "assert MaxActivities([1, 3, 0, 5, 8, 5], [2, 4, 6, 7, 9, 9]) == [0, 1, 3, 4]", "assert MaxActivities([1], [2]) == [0]"]}], "category": "Array", "prompt_tokens": 843, "total_tokens": 1137, "completion_tokens": 294, "completion": "Given an array of integers, write a function to move all 0's to the end of it while maintaining the relative order of the non-zero elements. The function should not return anything, it should modify the input array in-place.\n\n###Code: \n\ndef moveZeroes(nums: list) -> None:\n    j = 0\n    for num in nums:\n        if num != 0:\n            nums[j] = num\n            j += 1\n    for i in range(j, len(nums)):\n        nums[i] = 0\n\n###Testcases: \n\nnums1 = [0, 1, 0, 3, 12]\nmoveZeroes(nums1)\nassert nums1 == [1, 3, 12, 0, 0]\n\nnums2 = [0, 0, 1]\nmoveZeroes(nums2)\nassert nums2 == [1, 0, 0]\n\nnums3 = [2, 1]\nmoveZeroes(nums3)\nassert nums3 == [2, 1]\n\nnums4 = [4, 2, 4, 0, 0, 3, 0, 5, 1, 0]\nmoveZeroes(nums4)\nassert nums4 == [4, 2, 4, 3, 5, 1, 0, 0, 0, 0]\n\n[/Example 3]", "temperature": 0.841}, {"few_shots": [{"author": "Calvin", "UUID": "1aeb3246-4c22-4d34-a48c-db7be8ba1b94", "question": "You are given n activities with their start and finish times. Select the maximum number of activities that can be performed by a single person and return their indexes. Assume that a person can only work on a single activity at a time. \n", "examples": "Input: start  =  {10, 12, 20}, finish =  {20, 25, 30}\nOutput: [0, 2]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "import numpy as np\ndef MaxActivities(s: list, f: list) -> list:\n    indices = np.argsort(f)\n    [s[i] for i in indices]\n    [f[i] for i in indices]\n    result = []\n    n = len(f)\n    i = 0\n    result.append(i)\n    for j in range(1, n):\n        if s[j] >= f[i]:\n            result.append(j)\n            i = j\n    return result\n", "asserts": ["assert MaxActivities([2, 4, 5, 6, 7, 8], [3, 5, 6, 7, 9, 10]) == [0, 1, 2, 3, 4]", "assert MaxActivities([1, 3, 0, 5, 8, 5], [2, 4, 6, 7, 9, 9]) == [0, 1, 3, 4]", "assert MaxActivities([1], [2]) == [0]"]}, {"author": "Calvin", "UUID": "f795bda7-9822-4bc5-9c7e-b9c0f2752085", "question": "You are given two 0-indexed integer permutations A and B of length n.\n\nA prefix common array of A and B is an array C such that C[i] is equal to the count of numbers that are present at or before the index i in both A and B.\n\nReturn the prefix common array of A and B.\n\nA sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once.", "examples": "Input: A = [1,3,2,4], B = [3,1,2,4]\nOutput: [0,2,3,4]", "link": "https://leetcode.com/problems/find-the-prefix-common-array-of-two-arrays/", "difficulty": null, "categories": ["Array"], "code": "def findThePrefixCommonArray(arr1: list, arr2: list) -> list:\n  max = len(arr1) if len(arr1) > len(arr2) else len(arr2)\n  seen = set()\n  curCount = 0\n  ret = []\n  for i in range(max):\n    cur1 = arr1[i]\n    cur2 = arr2[i]\n    if cur1 in seen:\n      curCount += 1\n    else:\n      seen.add(cur1)\n    if cur2 in seen:\n      curCount += 1\n    else:\n      seen.add(cur2)\n    ret.append(curCount)\n  return ret\n", "asserts": ["assert findThePrefixCommonArray([1,3,2,4], [3,1,2,4]) == [0,2,3,4]", "assert findThePrefixCommonArray([1], [1]) == [1]", "assert findThePrefixCommonArray([2,3,1], [3,1,2]) == [0,1,3]"]}], "category": "Array", "prompt_tokens": 782, "total_tokens": 987, "completion_tokens": 205, "completion": "You are given an array of non-negative integers and an integer total. Write a function that returns the number of continuous subarrays that sum to the integer total.\n\n###Code: \n\ndef subarraySum(nums: list, total: int) -> int:\n    count, current_sum = 0, 0\n    sums = {0: 1}\n\n    for num in nums:\n        current_sum += num\n        count += sums.get(current_sum - total, 0)\n        sums[current_sum] = sums.get(current_sum, 0) + 1\n\n    return count\n\n\n###Testcases: \n\nassert subarraySum([1,1,1], 2) == 2\nassert subarraySum([1,2,3], 3) == 2\nassert subarraySum([1,2,1,2,1], 3) == 4\nassert subarraySum([10,2,3], 5) == 0\n\n[/Example 3]", "temperature": 0.867}, {"few_shots": [{"author": "Calvin", "UUID": "1aeb3246-4c22-4d34-a48c-db7be8ba1b94", "question": "You are given n activities with their start and finish times. Select the maximum number of activities that can be performed by a single person and return their indexes. Assume that a person can only work on a single activity at a time. \n", "examples": "Input: start  =  {10, 12, 20}, finish =  {20, 25, 30}\nOutput: [0, 2]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "import numpy as np\ndef MaxActivities(s: list, f: list) -> list:\n    indices = np.argsort(f)\n    [s[i] for i in indices]\n    [f[i] for i in indices]\n    result = []\n    n = len(f)\n    i = 0\n    result.append(i)\n    for j in range(1, n):\n        if s[j] >= f[i]:\n            result.append(j)\n            i = j\n    return result\n", "asserts": ["assert MaxActivities([2, 4, 5, 6, 7, 8], [3, 5, 6, 7, 9, 10]) == [0, 1, 2, 3, 4]", "assert MaxActivities([1, 3, 0, 5, 8, 5], [2, 4, 6, 7, 9, 9]) == [0, 1, 3, 4]", "assert MaxActivities([1], [2]) == [0]"]}, {"author": "Calvin", "UUID": "f795bda7-9822-4bc5-9c7e-b9c0f2752085", "question": "You are given two 0-indexed integer permutations A and B of length n.\n\nA prefix common array of A and B is an array C such that C[i] is equal to the count of numbers that are present at or before the index i in both A and B.\n\nReturn the prefix common array of A and B.\n\nA sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once.", "examples": "Input: A = [1,3,2,4], B = [3,1,2,4]\nOutput: [0,2,3,4]", "link": "https://leetcode.com/problems/find-the-prefix-common-array-of-two-arrays/", "difficulty": null, "categories": ["Array"], "code": "def findThePrefixCommonArray(arr1: list, arr2: list) -> list:\n  max = len(arr1) if len(arr1) > len(arr2) else len(arr2)\n  seen = set()\n  curCount = 0\n  ret = []\n  for i in range(max):\n    cur1 = arr1[i]\n    cur2 = arr2[i]\n    if cur1 in seen:\n      curCount += 1\n    else:\n      seen.add(cur1)\n    if cur2 in seen:\n      curCount += 1\n    else:\n      seen.add(cur2)\n    ret.append(curCount)\n  return ret\n", "asserts": ["assert findThePrefixCommonArray([1,3,2,4], [3,1,2,4]) == [0,2,3,4]", "assert findThePrefixCommonArray([1], [1]) == [1]", "assert findThePrefixCommonArray([2,3,1], [3,1,2]) == [0,1,3]"]}], "category": "Array", "prompt_tokens": 782, "total_tokens": 1018, "completion_tokens": 236, "completion": "Given an array of non-negative integers arr and an integer target, find the length of the shortest non-empty subarray of arr whose sum is at least target. If no such subarray exists, return 0.\n\n###Code:\n\ndef minSubArrayLen(target: int, nums: list) -> int:\n    n = len(nums)\n    ans = n + 1  # Set ans to a large value\n    left = 0\n    sum = 0\n    for right in range(n):\n        sum += nums[right]\n        while sum >= target:\n            ans = min(ans, right - left + 1)\n            sum -= nums[left]\n            left += 1\n    return ans if ans != n + 1 else 0\n\n###Testcases:\n\nassert minSubArrayLen(7, [2,3,1,2,4,3]) == 2\nassert minSubArrayLen(4, [1,4,4]) == 1\nassert minSubArrayLen(11, [1,1,1,1,1,1,1,1]) == 0\n\n[/Example 3]", "temperature": 0.888}, {"few_shots": [{"author": "Calvin", "UUID": "9e45b73f-583d-40ab-b387-e0d1624af07b", "question": "Given two arrays return an array with the set intersection of their common elements", "examples": "Input: arr1 = [1, 2, 3, 4], arr2 = [2, 3]\nOutput: [2, 3]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def array_intersection(arr1: list, arr2: list) -> set:\n  set1 = set(arr1)\n  ret = set([x for x in arr2 if x in set1])\n  return list(ret)\n", "asserts": ["assert set(array_intersection([1,0,2,0,2,0,2,1,1,1], [2,1,0,2,0,2,2,2,1,0])) == {0,1,2}", "assert set(array_intersection([5, 6, 7, 8], [8, 9, 10, 11])) == {8}", "assert set(array_intersection([10, 20, 30], [40, 50, 60])) == set()", "assert set(array_intersection([], [1, 2, 3])) == set()", "assert set(array_intersection([-1, -2, -3], [-3, -4, -5, -6])) == {-3}", "assert set(array_intersection([9, 8, 7], [7, 8, 9, 10, 11, 12])) == {7, 8, 9}", "assert set(array_intersection(['a', 'b', 'c'], ['a', 'd', 'e', 'c'])) == {'a', 'c'}", "assert set(array_intersection(['apple', 'banana'], ['banana', 'cherry'])) == {'banana'}", "assert set(array_intersection([1.1, 2.2, 3.3], [2.2, 4.4])) == {2.2}", "assert set(array_intersection([False, True, False], [True, False, True])) == {True, False}", "assert set(array_intersection([(1, 2), (3, 4)], [(3, 4), (5, 6)])) == {(3, 4)}"]}, {"author": "Calvin", "UUID": "f795bda7-9822-4bc5-9c7e-b9c0f2752085", "question": "You are given two 0-indexed integer permutations A and B of length n.\n\nA prefix common array of A and B is an array C such that C[i] is equal to the count of numbers that are present at or before the index i in both A and B.\n\nReturn the prefix common array of A and B.\n\nA sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once.", "examples": "Input: A = [1,3,2,4], B = [3,1,2,4]\nOutput: [0,2,3,4]", "link": "https://leetcode.com/problems/find-the-prefix-common-array-of-two-arrays/", "difficulty": null, "categories": ["Array"], "code": "def findThePrefixCommonArray(arr1: list, arr2: list) -> list:\n  max = len(arr1) if len(arr1) > len(arr2) else len(arr2)\n  seen = set()\n  curCount = 0\n  ret = []\n  for i in range(max):\n    cur1 = arr1[i]\n    cur2 = arr2[i]\n    if cur1 in seen:\n      curCount += 1\n    else:\n      seen.add(cur1)\n    if cur2 in seen:\n      curCount += 1\n    else:\n      seen.add(cur2)\n    ret.append(curCount)\n  return ret\n", "asserts": ["assert findThePrefixCommonArray([1,3,2,4], [3,1,2,4]) == [0,2,3,4]", "assert findThePrefixCommonArray([1], [1]) == [1]", "assert findThePrefixCommonArray([2,3,1], [3,1,2]) == [0,1,3]"]}], "category": "Array", "prompt_tokens": 922, "total_tokens": 1233, "completion_tokens": 311, "completion": "Given an array of integers, find the length of the longest subarray where the absolute difference between any two elements is less than or equal to 1.\n\n###Code:\n\n```python\ndef longest_subarray(arr: list) -> int:\n    if not arr:\n        return 0\n    arr.sort()\n    max_length = 1\n    current_length = 1\n    for i in range(1, len(arr)):\n        if arr[i] - arr[i - 1] <= 1:\n            current_length += 1\n            max_length = max(max_length, current_length)\n        else:\n            current_length = 1\n    return max_length\n```\n\n###Testcases:\n\n```python\nassert longest_subarray([1, 2, 2, 3]) == 3\nassert longest_subarray([1, 1, 1, 3, 3]) == 3\nassert longest_subarray([4, 6, 5, 3, 3, 1]) == 3\nassert longest_subarray([1, 2, 3, 4, 5]) == 2\nassert longest_subarray([1]) == 1\nassert longest_subarray([10, 10, 10, 10]) == 4\nassert longest_subarray([]) == 0\nassert longest_subarray([-2, -1, -1, -1, 0, 1]) == 4\n```\n\n[/Example 3]", "temperature": 0.869}, {"few_shots": [{"author": "Calvin", "UUID": "48c6aa37-e00d-4b55-9afc-6b1cf2a1aff2", "question": "There are N Mice and N holes are placed in a straight line. Each hole can accommodate only 1 mouse. A mouse can stay at his position, move one step right from x to x + 1, or move one step left from x to x -1. Any of these moves consumes 1 minute. Assign mice to holes so that the time when the last mouse gets inside a hole is minimized.\nYou are given a list of mice and hole positions as integer scalers.\n", "examples": "Input: Mices = [0, 10, 2, 3], Holes = [3, 2, 23, 0]\nOutput: 13", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def assignHole(mices: list, holes: list) -> int:\n    for i,j in zip(mices,holes):\n        if i<0 or j<0:\n            return -1\n    if (len(mices) != len(holes)):\n        return -1\n    mices.sort()\n    holes.sort()\n    Max = 0\n     \n    for i in range(len(holes)):\n        if (Max < abs(mices[i] - holes[i])):\n            Max = abs(mices[i] - holes[i])\n     \n    return Max\n", "asserts": ["assert assignHole([1, 2, 3, 4], [4, 3, 2, 1]) == 0", "assert assignHole([10, 20, 30, 40], [15, 25, 35, 45]) == 5", "assert assignHole([1, 4, 9, 15], [10, 13, 7, 20]) == 6", "assert assignHole([0], [0]) == 0", "assert assignHole([1, 2], [3]) == -1  # Edge case with non-equal amount of mice and holes", "assert assignHole([5, 5, 5], [5, 5, 5]) == 0  # Edge case with all mice and holes at the same position", "assert assignHole([10, 10, 10, 10], [10, 9, 8, 7]) == 3  # Edge case with multiple mice starting at the same position", "assert assignHole([1,1 ,1, 1, 1, 1, 1, 1, 1, 1], [2,2,2,2,2,2 ,2, 2, 2, 2]) == 1 # Edge case with multiple mice and holes at the same positions", "assert assignHole([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == 1 # Edge case with incremental positions"]}, {"author": "Calvin", "UUID": "fb94082f-4627-4f5a-b280-08d869823d70", "question": "You are given an array of people, people, which are the attributes of some people in a queue (not necessarily in order). Each people[i] = [hi, ki] represents the ith person of height hi with exactly ki other people in front who have a height greater than or equal to hi.\n\nReconstruct and return the queue that is represented by the input array people. The returned queue should be formatted as an array queue, where queue[j] = [hj, kj] is the attributes of the jth person in the queue (queue[0] is the person at the front of the queue).\n", "examples": "Input:  [[7, 0], [4, 4], [7, 1], [5, 0], [6, 1], [5, 2]]\nOutput: [[5, 0], [4, 1], [7, 0], [5, 2], [6, 1], [7, 1]]\n\nInput:  [[6, 0], [5, 0], [4, 0], [3, 2], [2, 2], [1, 4]]\nOutput: [[4, 0], [5, 0], [2, 2], [3, 2], [1, 4], [6, 0]]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "\ndef reconstructQueue(people: list) -> list:\n    output=[] \n    people.sort(key=lambda x: (-x[0], x[1]))                \n    for a in people:\n        output.insert(a[1], a)\n    \n    return output\n", "asserts": ["assert reconstructQueue([[8,1],[5,0],[6,1],[5,2],[4,4],[7,1]]) == [[5, 0], [8, 1], [5, 2], [6, 1], [4, 4], [7, 1]]", "assert reconstructQueue([[12,0], [6,3], [4,4], [9,2], [7,1]]) == [[12, 0], [7, 1], [9, 2], [6, 3], [4, 4]]", "assert reconstructQueue([[2,0], [1,1]]) == [[2, 0], [1, 1]]", "assert reconstructQueue([[3,0], [3,2], [3,1]]) == [[3, 0], [3, 1], [3, 2]]"]}], "category": "Array", "prompt_tokens": 1164, "total_tokens": 1504, "completion_tokens": 340, "completion": "Given an array of integers, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum. A subarray is a contiguous part of an array.\n\n\n###Code: \n\n```python\ndef maxSubArray(nums: list) -> int:\n    if not nums:\n        return 0\n\n    current_sum = max_sum = nums[0]\n    \n    for num in nums[1:]:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n        \n    return max_sum\n```\n\n###Testcases: \n\n```python\nassert maxSubArray([-2,1,-3,4,-1,2,1,-5,4]) == 6\nassert maxSubArray([1]) == 1\nassert maxSubArray([5,4,-1,7,8]) == 23\nassert maxSubArray([-2,-3,-1]) == -1\nassert maxSubArray([]) == 0  # Edge case with an empty array\nassert maxSubArray([1,2,3,4,5,6,7,8,9,10]) == 55  # Edge case with an array of positive numbers\nassert maxSubArray([-1,-2,-3,-4,-5,-6,-7,-8,-9,-10]) == -1  # Edge case with an array of negative numbers\nassert maxSubArray([0,0,0,0,0,0,0,0,0,0]) == 0  # Edge case with an array of zeros\n``` \n\n[/Example 3]", "temperature": 0.679}, {"few_shots": [{"author": "Calvin", "UUID": "48c6aa37-e00d-4b55-9afc-6b1cf2a1aff2", "question": "There are N Mice and N holes are placed in a straight line. Each hole can accommodate only 1 mouse. A mouse can stay at his position, move one step right from x to x + 1, or move one step left from x to x -1. Any of these moves consumes 1 minute. Assign mice to holes so that the time when the last mouse gets inside a hole is minimized.\nYou are given a list of mice and hole positions as integer scalers.\n", "examples": "Input: Mices = [0, 10, 2, 3], Holes = [3, 2, 23, 0]\nOutput: 13", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def assignHole(mices: list, holes: list) -> int:\n    for i,j in zip(mices,holes):\n        if i<0 or j<0:\n            return -1\n    if (len(mices) != len(holes)):\n        return -1\n    mices.sort()\n    holes.sort()\n    Max = 0\n     \n    for i in range(len(holes)):\n        if (Max < abs(mices[i] - holes[i])):\n            Max = abs(mices[i] - holes[i])\n     \n    return Max\n", "asserts": ["assert assignHole([1, 2, 3, 4], [4, 3, 2, 1]) == 0", "assert assignHole([10, 20, 30, 40], [15, 25, 35, 45]) == 5", "assert assignHole([1, 4, 9, 15], [10, 13, 7, 20]) == 6", "assert assignHole([0], [0]) == 0", "assert assignHole([1, 2], [3]) == -1  # Edge case with non-equal amount of mice and holes", "assert assignHole([5, 5, 5], [5, 5, 5]) == 0  # Edge case with all mice and holes at the same position", "assert assignHole([10, 10, 10, 10], [10, 9, 8, 7]) == 3  # Edge case with multiple mice starting at the same position", "assert assignHole([1,1 ,1, 1, 1, 1, 1, 1, 1, 1], [2,2,2,2,2,2 ,2, 2, 2, 2]) == 1 # Edge case with multiple mice and holes at the same positions", "assert assignHole([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == 1 # Edge case with incremental positions"]}, {"author": "Calvin", "UUID": "a9c5e697-af5d-432b-8447-5675d739c728", "question": "Given an array reorder it so that even numbers appear first", "examples": "Input: [1,2,3,4,5,6,7,8,9]\r\nOutput: [8,2,6,4,5,7,3,9,1]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def even_odd_reorder(arr: list) -> list:\n  nextEven = 0\n  nextOdd = len(arr) - 1\n  while nextEven < nextOdd:\n    if arr[nextEven] % 2 == 0:\n      nextEven += 1\n    else:\n      temp = arr[nextEven]\n      arr[nextEven] = arr[nextOdd]\n      arr[nextOdd] = temp\n      nextOdd -= 1\n  return arr\n", "asserts": ["assert even_odd_reorder([1,2,3,4,5,6,7,8,9]) == [8, 2, 6, 4, 5, 7, 3, 9, 1]", "assert even_odd_reorder([]) == []", "assert even_odd_reorder([2, 4, 6, 8]) == [2, 4, 6, 8]", "assert even_odd_reorder([7, 9, 2]) == [2, 9, 7]", "assert even_odd_reorder([10, 13, 17, 16, 15, 12]) == [10, 12, 16, 15, 17, 13]"]}], "category": "Array", "prompt_tokens": 1067, "total_tokens": 1388, "completion_tokens": 321, "completion": "Find the smallest positive integer value that cannot be represented as sum of any subset of a given array of positive integers?\n\n###Code: \n\ndef findSmallest(arr: list) -> int:\n    res = 1  # Initialize result\n    arr.sort()\n    \n    # Traverse the array and increment 'res' if arr[i] is\n    # smaller than or equal to 'res'.\n    for i in range(len(arr)):\n        if arr[i] <= res:\n            res = res + arr[i]\n        else:\n            break\n    return res\n\n###Testcases: \n\nassert findSmallest([1, 3, 6, 10, 11, 15]) == 2\nassert findSmallest([1, 1, 1, 1]) == 5\nassert findSmallest([1, 1, 3, 4]) == 10\nassert findSmallest([1, 2, 5, 10, 20, 40]) == 4\nassert findSmallest([1, 2, 3, 4, 5, 6]) == 22\nassert findSmallest([1]) == 2\nassert findSmallest([2, 3, 7, 6, 8]) == 1  # Edge case where the array does not include 1\nassert findSmallest([4, 13, 2, 3, 1]) == 14  # Edge case with a non-sorted input array\n\n[/Example 3]", "temperature": 0.76}, {"few_shots": [{"author": "Calvin", "UUID": "a9c5e697-af5d-432b-8447-5675d739c728", "question": "Given an array reorder it so that even numbers appear first", "examples": "Input: [1,2,3,4,5,6,7,8,9]\r\nOutput: [8,2,6,4,5,7,3,9,1]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def even_odd_reorder(arr: list) -> list:\n  nextEven = 0\n  nextOdd = len(arr) - 1\n  while nextEven < nextOdd:\n    if arr[nextEven] % 2 == 0:\n      nextEven += 1\n    else:\n      temp = arr[nextEven]\n      arr[nextEven] = arr[nextOdd]\n      arr[nextOdd] = temp\n      nextOdd -= 1\n  return arr\n", "asserts": ["assert even_odd_reorder([1,2,3,4,5,6,7,8,9]) == [8, 2, 6, 4, 5, 7, 3, 9, 1]", "assert even_odd_reorder([]) == []", "assert even_odd_reorder([2, 4, 6, 8]) == [2, 4, 6, 8]", "assert even_odd_reorder([7, 9, 2]) == [2, 9, 7]", "assert even_odd_reorder([10, 13, 17, 16, 15, 12]) == [10, 12, 16, 15, 17, 13]"]}, {"author": "Calvin", "UUID": "f795bda7-9822-4bc5-9c7e-b9c0f2752085", "question": "You are given two 0-indexed integer permutations A and B of length n.\n\nA prefix common array of A and B is an array C such that C[i] is equal to the count of numbers that are present at or before the index i in both A and B.\n\nReturn the prefix common array of A and B.\n\nA sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once.", "examples": "Input: A = [1,3,2,4], B = [3,1,2,4]\nOutput: [0,2,3,4]", "link": "https://leetcode.com/problems/find-the-prefix-common-array-of-two-arrays/", "difficulty": null, "categories": ["Array"], "code": "def findThePrefixCommonArray(arr1: list, arr2: list) -> list:\n  max = len(arr1) if len(arr1) > len(arr2) else len(arr2)\n  seen = set()\n  curCount = 0\n  ret = []\n  for i in range(max):\n    cur1 = arr1[i]\n    cur2 = arr2[i]\n    if cur1 in seen:\n      curCount += 1\n    else:\n      seen.add(cur1)\n    if cur2 in seen:\n      curCount += 1\n    else:\n      seen.add(cur2)\n    ret.append(curCount)\n  return ret\n", "asserts": ["assert findThePrefixCommonArray([1,3,2,4], [3,1,2,4]) == [0,2,3,4]", "assert findThePrefixCommonArray([1], [1]) == [1]", "assert findThePrefixCommonArray([2,3,1], [3,1,2]) == [0,1,3]"]}], "category": "Array", "prompt_tokens": 781, "total_tokens": 1178, "completion_tokens": 397, "completion": "Given an integer array `nums` sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same.\n\nSince it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array `nums`. More formally, if there are `k` elements after removing the duplicates, then the first `k` elements of `nums` should hold the final result. It does not matter what you leave beyond the first `k` elements.\n\nReturn `k` after placing the final result in the first `k` slots of `nums`.\n\nDo not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.\n\n###Code: \n\ndef remove_duplicates(nums: list) -> int:\n    if not nums:\n        return 0\n    \n    # Initialize the counter for unique elements\n    unique_count = 1\n    \n    # Iterate through the list starting from the second element\n    for i in range(1, len(nums)):\n        # Check if the current element is different from the previous one\n        if nums[i] != nums[i - 1]:\n            # It's a unique element, so move it to the front part of the list\n            nums[unique_count] = nums[i]\n            unique_count += 1\n    \n    return unique_count\n\n###Testcases: \n\nassert remove_duplicates([1, 1, 2]) == 2\nassert remove_duplicates([0,0,1,1,1,2,2,3,3,4]) == 5\nassert remove_duplicates([1,2,3]) == 3\nassert remove_duplicates([]) == 0\nassert remove_duplicates([1,1,1,1,1,1,1]) == 1\n\n[/Example 3]", "temperature": 0.763}, {"few_shots": [{"author": "Calvin", "UUID": "fb94082f-4627-4f5a-b280-08d869823d70", "question": "You are given an array of people, people, which are the attributes of some people in a queue (not necessarily in order). Each people[i] = [hi, ki] represents the ith person of height hi with exactly ki other people in front who have a height greater than or equal to hi.\n\nReconstruct and return the queue that is represented by the input array people. The returned queue should be formatted as an array queue, where queue[j] = [hj, kj] is the attributes of the jth person in the queue (queue[0] is the person at the front of the queue).\n", "examples": "Input:  [[7, 0], [4, 4], [7, 1], [5, 0], [6, 1], [5, 2]]\nOutput: [[5, 0], [4, 1], [7, 0], [5, 2], [6, 1], [7, 1]]\n\nInput:  [[6, 0], [5, 0], [4, 0], [3, 2], [2, 2], [1, 4]]\nOutput: [[4, 0], [5, 0], [2, 2], [3, 2], [1, 4], [6, 0]]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "\ndef reconstructQueue(people: list) -> list:\n    output=[] \n    people.sort(key=lambda x: (-x[0], x[1]))                \n    for a in people:\n        output.insert(a[1], a)\n    \n    return output\n", "asserts": ["assert reconstructQueue([[8,1],[5,0],[6,1],[5,2],[4,4],[7,1]]) == [[5, 0], [8, 1], [5, 2], [6, 1], [4, 4], [7, 1]]", "assert reconstructQueue([[12,0], [6,3], [4,4], [9,2], [7,1]]) == [[12, 0], [7, 1], [9, 2], [6, 3], [4, 4]]", "assert reconstructQueue([[2,0], [1,1]]) == [[2, 0], [1, 1]]", "assert reconstructQueue([[3,0], [3,2], [3,1]]) == [[3, 0], [3, 1], [3, 2]]"]}, {"author": "Calvin", "UUID": "f795bda7-9822-4bc5-9c7e-b9c0f2752085", "question": "You are given two 0-indexed integer permutations A and B of length n.\n\nA prefix common array of A and B is an array C such that C[i] is equal to the count of numbers that are present at or before the index i in both A and B.\n\nReturn the prefix common array of A and B.\n\nA sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once.", "examples": "Input: A = [1,3,2,4], B = [3,1,2,4]\nOutput: [0,2,3,4]", "link": "https://leetcode.com/problems/find-the-prefix-common-array-of-two-arrays/", "difficulty": null, "categories": ["Array"], "code": "def findThePrefixCommonArray(arr1: list, arr2: list) -> list:\n  max = len(arr1) if len(arr1) > len(arr2) else len(arr2)\n  seen = set()\n  curCount = 0\n  ret = []\n  for i in range(max):\n    cur1 = arr1[i]\n    cur2 = arr2[i]\n    if cur1 in seen:\n      curCount += 1\n    else:\n      seen.add(cur1)\n    if cur2 in seen:\n      curCount += 1\n    else:\n      seen.add(cur2)\n    ret.append(curCount)\n  return ret\n", "asserts": ["assert findThePrefixCommonArray([1,3,2,4], [3,1,2,4]) == [0,2,3,4]", "assert findThePrefixCommonArray([1], [1]) == [1]", "assert findThePrefixCommonArray([2,3,1], [3,1,2]) == [0,1,3]"]}], "category": "Array", "prompt_tokens": 878, "total_tokens": 1114, "completion_tokens": 236, "completion": "Given an array of integers nums and an integer k, return the total number of continuous subarrays whose sum equals to k.\n\nA subarray is a contiguous non-empty sequence of elements within an array.\n\n###Code:\n\n```python\ndef subarraySum(nums: list, k: int) -> int:\n    count = 0\n    sum_map = {0: 1}\n    current_sum = 0\n    for num in nums:\n        current_sum += num\n        if current_sum - k in sum_map:\n            count += sum_map[current_sum - k]\n        sum_map[current_sum] = sum_map.get(current_sum, 0) + 1\n    return count\n```\n\n###Testcases:\n\n```python\nassert subarraySum([1, 1, 1], 2) == 2\nassert subarraySum([1, 2, 3], 3) == 2\nassert subarraySum([1, -1, 0], 0) == 3\nassert subarraySum([-1, -1, 1], 0) == 1\n```\n\n[/Example 3]", "temperature": 0.83}, {"few_shots": [{"author": "Calvin", "UUID": "1aeb3246-4c22-4d34-a48c-db7be8ba1b94", "question": "You are given n activities with their start and finish times. Select the maximum number of activities that can be performed by a single person and return their indexes. Assume that a person can only work on a single activity at a time. \n", "examples": "Input: start  =  {10, 12, 20}, finish =  {20, 25, 30}\nOutput: [0, 2]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "import numpy as np\ndef MaxActivities(s: list, f: list) -> list:\n    indices = np.argsort(f)\n    [s[i] for i in indices]\n    [f[i] for i in indices]\n    result = []\n    n = len(f)\n    i = 0\n    result.append(i)\n    for j in range(1, n):\n        if s[j] >= f[i]:\n            result.append(j)\n            i = j\n    return result\n", "asserts": ["assert MaxActivities([2, 4, 5, 6, 7, 8], [3, 5, 6, 7, 9, 10]) == [0, 1, 2, 3, 4]", "assert MaxActivities([1, 3, 0, 5, 8, 5], [2, 4, 6, 7, 9, 9]) == [0, 1, 3, 4]", "assert MaxActivities([1], [2]) == [0]"]}, {"author": "Calvin", "UUID": "48c6aa37-e00d-4b55-9afc-6b1cf2a1aff2", "question": "There are N Mice and N holes are placed in a straight line. Each hole can accommodate only 1 mouse. A mouse can stay at his position, move one step right from x to x + 1, or move one step left from x to x -1. Any of these moves consumes 1 minute. Assign mice to holes so that the time when the last mouse gets inside a hole is minimized.\nYou are given a list of mice and hole positions as integer scalers.\n", "examples": "Input: Mices = [0, 10, 2, 3], Holes = [3, 2, 23, 0]\nOutput: 13", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def assignHole(mices: list, holes: list) -> int:\n    for i,j in zip(mices,holes):\n        if i<0 or j<0:\n            return -1\n    if (len(mices) != len(holes)):\n        return -1\n    mices.sort()\n    holes.sort()\n    Max = 0\n     \n    for i in range(len(holes)):\n        if (Max < abs(mices[i] - holes[i])):\n            Max = abs(mices[i] - holes[i])\n     \n    return Max\n", "asserts": ["assert assignHole([1, 2, 3, 4], [4, 3, 2, 1]) == 0", "assert assignHole([10, 20, 30, 40], [15, 25, 35, 45]) == 5", "assert assignHole([1, 4, 9, 15], [10, 13, 7, 20]) == 6", "assert assignHole([0], [0]) == 0", "assert assignHole([1, 2], [3]) == -1  # Edge case with non-equal amount of mice and holes", "assert assignHole([5, 5, 5], [5, 5, 5]) == 0  # Edge case with all mice and holes at the same position", "assert assignHole([10, 10, 10, 10], [10, 9, 8, 7]) == 3  # Edge case with multiple mice starting at the same position", "assert assignHole([1,1 ,1, 1, 1, 1, 1, 1, 1, 1], [2,2,2,2,2,2 ,2, 2, 2, 2]) == 1 # Edge case with multiple mice and holes at the same positions", "assert assignHole([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == 1 # Edge case with incremental positions"]}], "category": "Array", "prompt_tokens": 1068, "total_tokens": 1556, "completion_tokens": 488, "completion": "Given an array consisting of n integers, find the contiguous subarray of given length k that has the maximum average value. You need to output the maximum average value.\n\n###Code: \n\nimport numpy as np\ndef findMaxAverage(nums: list, k: int) -> float:\n    if len(nums) == 0 or k <= 0 or k > len(nums):\n        return 0\n    current_sum = sum(nums[0:k])\n    max_sum = current_sum\n    for i in range(len(nums) - k):\n        current_sum = current_sum - nums[i] + nums[i+k]\n        max_sum = max(max_sum, current_sum)\n    return max_sum / k\n\n###Testcases: \n\nassert findMaxAverage([1, 12, -5, -6, 50, 3], 4) == 12.75\nassert findMaxAverage([5, 7, 8, 2, 3], 2) == 7.5\nassert findMaxAverage([4, 0, 4, 3, 3, 1, -1, 5], 5) == 3.0\nassert findMaxAverage([11, -8, 16, -7, 24, -2, 3], 3) == 11.0\nassert findMaxAverage([1], 1) == 1\nassert findMaxAverage([-1, -2, -3, -4], 2) == -2.5\nassert findMaxAverage([7, 4, 5, 8, 8, 3, 9, 8, 7, 6], 7) == 6.5714\nassert findMaxAverage([0, 4, 0, 3, 2], 1) == 4\nassert findMaxAverage([], 3) == 0  # Edge case with empty array\nassert findMaxAverage([1, 2], 3) == 0  # Edge case where k is greater than array length\nassert findMaxAverage([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 2) == 9.5  # Edge case with incremental values\n\n[/Example 3]", "temperature": 0.913}, {"few_shots": [{"author": "Calvin", "UUID": "48c6aa37-e00d-4b55-9afc-6b1cf2a1aff2", "question": "There are N Mice and N holes are placed in a straight line. Each hole can accommodate only 1 mouse. A mouse can stay at his position, move one step right from x to x + 1, or move one step left from x to x -1. Any of these moves consumes 1 minute. Assign mice to holes so that the time when the last mouse gets inside a hole is minimized.\nYou are given a list of mice and hole positions as integer scalers.\n", "examples": "Input: Mices = [0, 10, 2, 3], Holes = [3, 2, 23, 0]\nOutput: 13", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def assignHole(mices: list, holes: list) -> int:\n    for i,j in zip(mices,holes):\n        if i<0 or j<0:\n            return -1\n    if (len(mices) != len(holes)):\n        return -1\n    mices.sort()\n    holes.sort()\n    Max = 0\n     \n    for i in range(len(holes)):\n        if (Max < abs(mices[i] - holes[i])):\n            Max = abs(mices[i] - holes[i])\n     \n    return Max\n", "asserts": ["assert assignHole([1, 2, 3, 4], [4, 3, 2, 1]) == 0", "assert assignHole([10, 20, 30, 40], [15, 25, 35, 45]) == 5", "assert assignHole([1, 4, 9, 15], [10, 13, 7, 20]) == 6", "assert assignHole([0], [0]) == 0", "assert assignHole([1, 2], [3]) == -1  # Edge case with non-equal amount of mice and holes", "assert assignHole([5, 5, 5], [5, 5, 5]) == 0  # Edge case with all mice and holes at the same position", "assert assignHole([10, 10, 10, 10], [10, 9, 8, 7]) == 3  # Edge case with multiple mice starting at the same position", "assert assignHole([1,1 ,1, 1, 1, 1, 1, 1, 1, 1], [2,2,2,2,2,2 ,2, 2, 2, 2]) == 1 # Edge case with multiple mice and holes at the same positions", "assert assignHole([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == 1 # Edge case with incremental positions"]}, {"author": "Calvin", "UUID": "a9c5e697-af5d-432b-8447-5675d739c728", "question": "Given an array reorder it so that even numbers appear first", "examples": "Input: [1,2,3,4,5,6,7,8,9]\r\nOutput: [8,2,6,4,5,7,3,9,1]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def even_odd_reorder(arr: list) -> list:\n  nextEven = 0\n  nextOdd = len(arr) - 1\n  while nextEven < nextOdd:\n    if arr[nextEven] % 2 == 0:\n      nextEven += 1\n    else:\n      temp = arr[nextEven]\n      arr[nextEven] = arr[nextOdd]\n      arr[nextOdd] = temp\n      nextOdd -= 1\n  return arr\n", "asserts": ["assert even_odd_reorder([1,2,3,4,5,6,7,8,9]) == [8, 2, 6, 4, 5, 7, 3, 9, 1]", "assert even_odd_reorder([]) == []", "assert even_odd_reorder([2, 4, 6, 8]) == [2, 4, 6, 8]", "assert even_odd_reorder([7, 9, 2]) == [2, 9, 7]", "assert even_odd_reorder([10, 13, 17, 16, 15, 12]) == [10, 12, 16, 15, 17, 13]"]}], "category": "Array", "prompt_tokens": 1067, "total_tokens": 1337, "completion_tokens": 270, "completion": "Find the maximum consecutive ones (1s) in an array of 0s and 1s.\n\n###Code:\n\ndef findMaxConsecutiveOnes(nums: list) -> int:\n    max_count = 0\n    count = 0\n    for num in nums:\n        if num == 1:\n            count += 1\n            max_count = max(max_count, count)\n        else:\n            count = 0\n    return max_count\n\n###Testcases:\n\nassert findMaxConsecutiveOnes([1, 1, 0, 1, 1, 1]) == 3\nassert findMaxConsecutiveOnes([1, 0, 1, 0, 1, 0, 1]) == 1\nassert findMaxConsecutiveOnes([0, 0, 0, 0, 0]) == 0\nassert findMaxConsecutiveOnes([1, 1, 1, 1, 1]) == 5\nassert findMaxConsecutiveOnes([]) == 0\nassert findMaxConsecutiveOnes([0, 1, 1, 0, 1, 1, 1, 1, 0, 1]) == 4\n\n[/Example 3]", "temperature": 0.731}, {"few_shots": [{"author": "Calvin", "UUID": "9e45b73f-583d-40ab-b387-e0d1624af07b", "question": "Given two arrays return an array with the set intersection of their common elements", "examples": "Input: arr1 = [1, 2, 3, 4], arr2 = [2, 3]\nOutput: [2, 3]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def array_intersection(arr1: list, arr2: list) -> set:\n  set1 = set(arr1)\n  ret = set([x for x in arr2 if x in set1])\n  return list(ret)\n", "asserts": ["assert set(array_intersection([1,0,2,0,2,0,2,1,1,1], [2,1,0,2,0,2,2,2,1,0])) == {0,1,2}", "assert set(array_intersection([5, 6, 7, 8], [8, 9, 10, 11])) == {8}", "assert set(array_intersection([10, 20, 30], [40, 50, 60])) == set()", "assert set(array_intersection([], [1, 2, 3])) == set()", "assert set(array_intersection([-1, -2, -3], [-3, -4, -5, -6])) == {-3}", "assert set(array_intersection([9, 8, 7], [7, 8, 9, 10, 11, 12])) == {7, 8, 9}", "assert set(array_intersection(['a', 'b', 'c'], ['a', 'd', 'e', 'c'])) == {'a', 'c'}", "assert set(array_intersection(['apple', 'banana'], ['banana', 'cherry'])) == {'banana'}", "assert set(array_intersection([1.1, 2.2, 3.3], [2.2, 4.4])) == {2.2}", "assert set(array_intersection([False, True, False], [True, False, True])) == {True, False}", "assert set(array_intersection([(1, 2), (3, 4)], [(3, 4), (5, 6)])) == {(3, 4)}"]}, {"author": "Calvin", "UUID": "1aeb3246-4c22-4d34-a48c-db7be8ba1b94", "question": "You are given n activities with their start and finish times. Select the maximum number of activities that can be performed by a single person and return their indexes. Assume that a person can only work on a single activity at a time. \n", "examples": "Input: start  =  {10, 12, 20}, finish =  {20, 25, 30}\nOutput: [0, 2]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "import numpy as np\ndef MaxActivities(s: list, f: list) -> list:\n    indices = np.argsort(f)\n    [s[i] for i in indices]\n    [f[i] for i in indices]\n    result = []\n    n = len(f)\n    i = 0\n    result.append(i)\n    for j in range(1, n):\n        if s[j] >= f[i]:\n            result.append(j)\n            i = j\n    return result\n", "asserts": ["assert MaxActivities([2, 4, 5, 6, 7, 8], [3, 5, 6, 7, 9, 10]) == [0, 1, 2, 3, 4]", "assert MaxActivities([1, 3, 0, 5, 8, 5], [2, 4, 6, 7, 9, 9]) == [0, 1, 3, 4]", "assert MaxActivities([1], [2]) == [0]"]}], "category": "Array", "prompt_tokens": 887, "total_tokens": 1311, "completion_tokens": 424, "completion": "Given an array of integers, return a new array such that each element at index `i` of the new array is the product of all the numbers in the original array except the one at `i`. You must write an algorithm that runs in O(n) time and without using the division operation.\n\n###Code: \n\ndef product_except_self(nums: list) -> list:\n    length = len(nums)\n    answer = [0]*length\n    \n    # answer[i] contains the product of all the elements to the left\n    # Note: for the element at index '0', there are no elements to the left,\n    # so the answer[0] would be 1\n    answer[0] = 1\n    for i in range(1, length):\n        answer[i] = nums[i - 1] * answer[i - 1]\n    \n    # R contains the product of all the elements to the right\n    # Note: for the element at index 'length - 1', there are no elements to the right,\n    # so the R would be 1\n    R = 1\n    for i in reversed(range(length)):\n        # For the index 'i', R would contain the \n        # product of all elements to the right. We update R accordingly\n        answer[i] = answer[i] * R\n        R *= nums[i]\n    \n    return answer\n\n###Testcases: \n\nassert product_except_self([1, 2, 3, 4]) == [24, 12, 8, 6]\nassert product_except_self([0, 0]) == [0, 0]\nassert product_except_self([1, 0]) == [0, 1]\nassert product_except_self([4, 5, 1, 8, 2]) == [80, 64, 320, 40, 160]\nassert product_except_self([-2, -1, -3, -4]) == [-12, -24, -8, -6]\n\n[/Example 3]", "temperature": 0.662}, {"few_shots": [{"author": "Calvin", "UUID": "1aeb3246-4c22-4d34-a48c-db7be8ba1b94", "question": "You are given n activities with their start and finish times. Select the maximum number of activities that can be performed by a single person and return their indexes. Assume that a person can only work on a single activity at a time. \n", "examples": "Input: start  =  {10, 12, 20}, finish =  {20, 25, 30}\nOutput: [0, 2]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "import numpy as np\ndef MaxActivities(s: list, f: list) -> list:\n    indices = np.argsort(f)\n    [s[i] for i in indices]\n    [f[i] for i in indices]\n    result = []\n    n = len(f)\n    i = 0\n    result.append(i)\n    for j in range(1, n):\n        if s[j] >= f[i]:\n            result.append(j)\n            i = j\n    return result\n", "asserts": ["assert MaxActivities([2, 4, 5, 6, 7, 8], [3, 5, 6, 7, 9, 10]) == [0, 1, 2, 3, 4]", "assert MaxActivities([1, 3, 0, 5, 8, 5], [2, 4, 6, 7, 9, 9]) == [0, 1, 3, 4]", "assert MaxActivities([1], [2]) == [0]"]}, {"author": "Calvin", "UUID": "a9c5e697-af5d-432b-8447-5675d739c728", "question": "Given an array reorder it so that even numbers appear first", "examples": "Input: [1,2,3,4,5,6,7,8,9]\r\nOutput: [8,2,6,4,5,7,3,9,1]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def even_odd_reorder(arr: list) -> list:\n  nextEven = 0\n  nextOdd = len(arr) - 1\n  while nextEven < nextOdd:\n    if arr[nextEven] % 2 == 0:\n      nextEven += 1\n    else:\n      temp = arr[nextEven]\n      arr[nextEven] = arr[nextOdd]\n      arr[nextOdd] = temp\n      nextOdd -= 1\n  return arr\n", "asserts": ["assert even_odd_reorder([1,2,3,4,5,6,7,8,9]) == [8, 2, 6, 4, 5, 7, 3, 9, 1]", "assert even_odd_reorder([]) == []", "assert even_odd_reorder([2, 4, 6, 8]) == [2, 4, 6, 8]", "assert even_odd_reorder([7, 9, 2]) == [2, 9, 7]", "assert even_odd_reorder([10, 13, 17, 16, 15, 12]) == [10, 12, 16, 15, 17, 13]"]}], "category": "Array", "prompt_tokens": 746, "total_tokens": 980, "completion_tokens": 234, "completion": "Given an array of integers where every element appears three times except for one which appears exactly once, find and return the non-duplicated integer.\n\n###Code: \n\ndef singleNumber(nums: list) -> int:\n    ones, twos = 0, 0\n    for num in nums:\n        # first appearance: \n        # add num to ones \n        ones = (ones ^ num) & ~twos\n        \n        # second appearance: \n        # remove num from ones, add num to twos\n        twos = (twos ^ num) & ~ones\n        \n    return ones\n\n###Testcases: \n\nassert singleNumber([2,2,3,2]) == 3\nassert singleNumber([0,1,0,1,0,1,99]) == 99\nassert singleNumber([1]) == 1\nassert singleNumber([-2,-2,1,1,-3,1,-3,-3,-4,-2]) == -4\nassert singleNumber([30000,500,100,30000,100,30000,100]) == 500\n\n[/Example 3]", "temperature": 0.724}, {"few_shots": [{"author": "Calvin", "UUID": "a9c5e697-af5d-432b-8447-5675d739c728", "question": "Given an array reorder it so that even numbers appear first", "examples": "Input: [1,2,3,4,5,6,7,8,9]\r\nOutput: [8,2,6,4,5,7,3,9,1]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def even_odd_reorder(arr: list) -> list:\n  nextEven = 0\n  nextOdd = len(arr) - 1\n  while nextEven < nextOdd:\n    if arr[nextEven] % 2 == 0:\n      nextEven += 1\n    else:\n      temp = arr[nextEven]\n      arr[nextEven] = arr[nextOdd]\n      arr[nextOdd] = temp\n      nextOdd -= 1\n  return arr\n", "asserts": ["assert even_odd_reorder([1,2,3,4,5,6,7,8,9]) == [8, 2, 6, 4, 5, 7, 3, 9, 1]", "assert even_odd_reorder([]) == []", "assert even_odd_reorder([2, 4, 6, 8]) == [2, 4, 6, 8]", "assert even_odd_reorder([7, 9, 2]) == [2, 9, 7]", "assert even_odd_reorder([10, 13, 17, 16, 15, 12]) == [10, 12, 16, 15, 17, 13]"]}, {"author": "Calvin", "UUID": "48c6aa37-e00d-4b55-9afc-6b1cf2a1aff2", "question": "There are N Mice and N holes are placed in a straight line. Each hole can accommodate only 1 mouse. A mouse can stay at his position, move one step right from x to x + 1, or move one step left from x to x -1. Any of these moves consumes 1 minute. Assign mice to holes so that the time when the last mouse gets inside a hole is minimized.\nYou are given a list of mice and hole positions as integer scalers.\n", "examples": "Input: Mices = [0, 10, 2, 3], Holes = [3, 2, 23, 0]\nOutput: 13", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def assignHole(mices: list, holes: list) -> int:\n    for i,j in zip(mices,holes):\n        if i<0 or j<0:\n            return -1\n    if (len(mices) != len(holes)):\n        return -1\n    mices.sort()\n    holes.sort()\n    Max = 0\n     \n    for i in range(len(holes)):\n        if (Max < abs(mices[i] - holes[i])):\n            Max = abs(mices[i] - holes[i])\n     \n    return Max\n", "asserts": ["assert assignHole([1, 2, 3, 4], [4, 3, 2, 1]) == 0", "assert assignHole([10, 20, 30, 40], [15, 25, 35, 45]) == 5", "assert assignHole([1, 4, 9, 15], [10, 13, 7, 20]) == 6", "assert assignHole([0], [0]) == 0", "assert assignHole([1, 2], [3]) == -1  # Edge case with non-equal amount of mice and holes", "assert assignHole([5, 5, 5], [5, 5, 5]) == 0  # Edge case with all mice and holes at the same position", "assert assignHole([10, 10, 10, 10], [10, 9, 8, 7]) == 3  # Edge case with multiple mice starting at the same position", "assert assignHole([1,1 ,1, 1, 1, 1, 1, 1, 1, 1], [2,2,2,2,2,2 ,2, 2, 2, 2]) == 1 # Edge case with multiple mice and holes at the same positions", "assert assignHole([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == 1 # Edge case with incremental positions"]}], "category": "Array", "prompt_tokens": 1067, "total_tokens": 1591, "completion_tokens": 524, "completion": "Given an array of integers, write a function to move all 0's to the end of it while maintaining the relative order of the non-zero elements. The function should not return anything and must modify the input array in-place.\n\n###Code:\n\ndef move_zeroes(arr: list):\n    non_zero_index = 0\n    for i in range(len(arr)):\n        if arr[i] != 0:\n            arr[non_zero_index], arr[i] = arr[i], arr[non_zero_index]\n            non_zero_index += 1\n\n###Testcases:\n\nassert (a := [0, 1, 0, 3, 12]) or (move_zeroes(a), a) == [1, 3, 12, 0, 0]\nassert (a := [0, 0, 1]) or (move_zeroes(a), a) == [1, 0, 0]\nassert (a := [1, 2, 0, 4, 3]) or (move_zeroes(a), a) == [1, 2, 4, 3, 0]\nassert (a := [0, 0, 0, 0, 0, 1]) or (move_zeroes(a), a) == [1, 0, 0, 0, 0, 0]\nassert (a := [4, 2, 4, 0, 0, 3, 0, 5, 1, 0]) or (move_zeroes(a), a) == [4, 2, 4, 3, 5, 1, 0, 0, 0, 0]\nassert (a := []) or (move_zeroes(a), a) == []  # Edge case with empty array\nassert (a := [0, 0, 0]) or (move_zeroes(a), a) == [0, 0, 0]  # Edge case with all zeros\nassert (a := [1, 2, 3]) or (move_zeroes(a), a) == [1, 2, 3]  # Edge case with no zeros\nassert (a := [0]) or (move_zeroes(a), a) == [0]  # Edge case with single zero\nassert (a := [1]) or (move_zeroes(a), a) == [1]  # Edge case with single non-zero\n\n[/Example 3]", "temperature": 0.837}, {"few_shots": [{"author": "Calvin", "UUID": "a9c5e697-af5d-432b-8447-5675d739c728", "question": "Given an array reorder it so that even numbers appear first", "examples": "Input: [1,2,3,4,5,6,7,8,9]\r\nOutput: [8,2,6,4,5,7,3,9,1]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def even_odd_reorder(arr: list) -> list:\n  nextEven = 0\n  nextOdd = len(arr) - 1\n  while nextEven < nextOdd:\n    if arr[nextEven] % 2 == 0:\n      nextEven += 1\n    else:\n      temp = arr[nextEven]\n      arr[nextEven] = arr[nextOdd]\n      arr[nextOdd] = temp\n      nextOdd -= 1\n  return arr\n", "asserts": ["assert even_odd_reorder([1,2,3,4,5,6,7,8,9]) == [8, 2, 6, 4, 5, 7, 3, 9, 1]", "assert even_odd_reorder([]) == []", "assert even_odd_reorder([2, 4, 6, 8]) == [2, 4, 6, 8]", "assert even_odd_reorder([7, 9, 2]) == [2, 9, 7]", "assert even_odd_reorder([10, 13, 17, 16, 15, 12]) == [10, 12, 16, 15, 17, 13]"]}, {"author": "Calvin", "UUID": "9e45b73f-583d-40ab-b387-e0d1624af07b", "question": "Given two arrays return an array with the set intersection of their common elements", "examples": "Input: arr1 = [1, 2, 3, 4], arr2 = [2, 3]\nOutput: [2, 3]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def array_intersection(arr1: list, arr2: list) -> set:\n  set1 = set(arr1)\n  ret = set([x for x in arr2 if x in set1])\n  return list(ret)\n", "asserts": ["assert set(array_intersection([1,0,2,0,2,0,2,1,1,1], [2,1,0,2,0,2,2,2,1,0])) == {0,1,2}", "assert set(array_intersection([5, 6, 7, 8], [8, 9, 10, 11])) == {8}", "assert set(array_intersection([10, 20, 30], [40, 50, 60])) == set()", "assert set(array_intersection([], [1, 2, 3])) == set()", "assert set(array_intersection([-1, -2, -3], [-3, -4, -5, -6])) == {-3}", "assert set(array_intersection([9, 8, 7], [7, 8, 9, 10, 11, 12])) == {7, 8, 9}", "assert set(array_intersection(['a', 'b', 'c'], ['a', 'd', 'e', 'c'])) == {'a', 'c'}", "assert set(array_intersection(['apple', 'banana'], ['banana', 'cherry'])) == {'banana'}", "assert set(array_intersection([1.1, 2.2, 3.3], [2.2, 4.4])) == {2.2}", "assert set(array_intersection([False, True, False], [True, False, True])) == {True, False}", "assert set(array_intersection([(1, 2), (3, 4)], [(3, 4), (5, 6)])) == {(3, 4)}"]}], "category": "Array", "prompt_tokens": 886, "total_tokens": 1046, "completion_tokens": 160, "completion": "Given an array of integers, return an array with each value doubled.\n\n###Code: \n\ndef double_values(arr: list) -> list:\n  return [x * 2 for x in arr]\n\n\n###Testcases:\n\nassert double_values([1, 2, 3, 4]) == [2, 4, 6, 8]\nassert double_values([-1, -2, -3]) == [-2, -4, -6]\nassert double_values([0, 0, 0]) == [0, 0, 0]\nassert double_values([]) == []\nassert double_values([100, 200, 300]) == [200, 400, 600]\nassert double_values([5]) == [10]\n\n[/Example 3]", "temperature": 0.929}, {"few_shots": [{"author": "Calvin", "UUID": "9e45b73f-583d-40ab-b387-e0d1624af07b", "question": "Given two arrays return an array with the set intersection of their common elements", "examples": "Input: arr1 = [1, 2, 3, 4], arr2 = [2, 3]\nOutput: [2, 3]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def array_intersection(arr1: list, arr2: list) -> set:\n  set1 = set(arr1)\n  ret = set([x for x in arr2 if x in set1])\n  return list(ret)\n", "asserts": ["assert set(array_intersection([1,0,2,0,2,0,2,1,1,1], [2,1,0,2,0,2,2,2,1,0])) == {0,1,2}", "assert set(array_intersection([5, 6, 7, 8], [8, 9, 10, 11])) == {8}", "assert set(array_intersection([10, 20, 30], [40, 50, 60])) == set()", "assert set(array_intersection([], [1, 2, 3])) == set()", "assert set(array_intersection([-1, -2, -3], [-3, -4, -5, -6])) == {-3}", "assert set(array_intersection([9, 8, 7], [7, 8, 9, 10, 11, 12])) == {7, 8, 9}", "assert set(array_intersection(['a', 'b', 'c'], ['a', 'd', 'e', 'c'])) == {'a', 'c'}", "assert set(array_intersection(['apple', 'banana'], ['banana', 'cherry'])) == {'banana'}", "assert set(array_intersection([1.1, 2.2, 3.3], [2.2, 4.4])) == {2.2}", "assert set(array_intersection([False, True, False], [True, False, True])) == {True, False}", "assert set(array_intersection([(1, 2), (3, 4)], [(3, 4), (5, 6)])) == {(3, 4)}"]}, {"author": "Calvin", "UUID": "48c6aa37-e00d-4b55-9afc-6b1cf2a1aff2", "question": "There are N Mice and N holes are placed in a straight line. Each hole can accommodate only 1 mouse. A mouse can stay at his position, move one step right from x to x + 1, or move one step left from x to x -1. Any of these moves consumes 1 minute. Assign mice to holes so that the time when the last mouse gets inside a hole is minimized.\nYou are given a list of mice and hole positions as integer scalers.\n", "examples": "Input: Mices = [0, 10, 2, 3], Holes = [3, 2, 23, 0]\nOutput: 13", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def assignHole(mices: list, holes: list) -> int:\n    for i,j in zip(mices,holes):\n        if i<0 or j<0:\n            return -1\n    if (len(mices) != len(holes)):\n        return -1\n    mices.sort()\n    holes.sort()\n    Max = 0\n     \n    for i in range(len(holes)):\n        if (Max < abs(mices[i] - holes[i])):\n            Max = abs(mices[i] - holes[i])\n     \n    return Max\n", "asserts": ["assert assignHole([1, 2, 3, 4], [4, 3, 2, 1]) == 0", "assert assignHole([10, 20, 30, 40], [15, 25, 35, 45]) == 5", "assert assignHole([1, 4, 9, 15], [10, 13, 7, 20]) == 6", "assert assignHole([0], [0]) == 0", "assert assignHole([1, 2], [3]) == -1  # Edge case with non-equal amount of mice and holes", "assert assignHole([5, 5, 5], [5, 5, 5]) == 0  # Edge case with all mice and holes at the same position", "assert assignHole([10, 10, 10, 10], [10, 9, 8, 7]) == 3  # Edge case with multiple mice starting at the same position", "assert assignHole([1,1 ,1, 1, 1, 1, 1, 1, 1, 1], [2,2,2,2,2,2 ,2, 2, 2, 2]) == 1 # Edge case with multiple mice and holes at the same positions", "assert assignHole([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == 1 # Edge case with incremental positions"]}], "category": "Array", "prompt_tokens": 1208, "total_tokens": 1641, "completion_tokens": 433, "completion": "Write a function that takes an array of integers and returns the length of the longest consecutive elements sequence. The sequence has to consist of consecutive numbers, and it can be in any order.\n\n###Code:\n\n```python\ndef longest_consecutive(nums: list) -> int:\n    if not nums:\n        return 0\n    \n    nums_set = set(nums)\n    longest_streak = 0\n    \n    for num in nums_set:\n        if num - 1 not in nums_set:\n            current_num = num\n            current_streak = 1\n            \n            while current_num + 1 in nums_set:\n                current_num += 1\n                current_streak += 1\n            \n            longest_streak = max(longest_streak, current_streak)\n    \n    return longest_streak\n```\n\n###Testcases:\n\n```python\nassert longest_consecutive([100, 4, 200, 1, 3, 2]) == 4\nassert longest_consecutive([0, -1]) == 2\nassert longest_consecutive([1, 2, 0, 1]) == 3\nassert longest_consecutive([9, 1, 4, 7, 3, -1, 0, 5, 8, -1, 6]) == 7\nassert longest_consecutive([]) == 0\nassert longest_consecutive([1]) == 1\nassert longest_consecutive([-2, -3, -4, -1, 0, 1]) == 6\nassert longest_consecutive([10, 5, 12, 3, 55, 30, 4, 11, 2]) == 4\nassert longest_consecutive([1, 9, 3, 10, 4, 20, 2]) == 4\nassert longest_consecutive([1, 1, 1, 1, 1]) == 1\nassert longest_consecutive([1, 3, 5, 2, 4]) == 5\n```\n\n[/Example 3]", "temperature": 0.778}, {"few_shots": [{"author": "Calvin", "UUID": "f795bda7-9822-4bc5-9c7e-b9c0f2752085", "question": "You are given two 0-indexed integer permutations A and B of length n.\n\nA prefix common array of A and B is an array C such that C[i] is equal to the count of numbers that are present at or before the index i in both A and B.\n\nReturn the prefix common array of A and B.\n\nA sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once.", "examples": "Input: A = [1,3,2,4], B = [3,1,2,4]\nOutput: [0,2,3,4]", "link": "https://leetcode.com/problems/find-the-prefix-common-array-of-two-arrays/", "difficulty": null, "categories": ["Array"], "code": "def findThePrefixCommonArray(arr1: list, arr2: list) -> list:\n  max = len(arr1) if len(arr1) > len(arr2) else len(arr2)\n  seen = set()\n  curCount = 0\n  ret = []\n  for i in range(max):\n    cur1 = arr1[i]\n    cur2 = arr2[i]\n    if cur1 in seen:\n      curCount += 1\n    else:\n      seen.add(cur1)\n    if cur2 in seen:\n      curCount += 1\n    else:\n      seen.add(cur2)\n    ret.append(curCount)\n  return ret\n", "asserts": ["assert findThePrefixCommonArray([1,3,2,4], [3,1,2,4]) == [0,2,3,4]", "assert findThePrefixCommonArray([1], [1]) == [1]", "assert findThePrefixCommonArray([2,3,1], [3,1,2]) == [0,1,3]"]}, {"author": "Calvin", "UUID": "1aeb3246-4c22-4d34-a48c-db7be8ba1b94", "question": "You are given n activities with their start and finish times. Select the maximum number of activities that can be performed by a single person and return their indexes. Assume that a person can only work on a single activity at a time. \n", "examples": "Input: start  =  {10, 12, 20}, finish =  {20, 25, 30}\nOutput: [0, 2]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "import numpy as np\ndef MaxActivities(s: list, f: list) -> list:\n    indices = np.argsort(f)\n    [s[i] for i in indices]\n    [f[i] for i in indices]\n    result = []\n    n = len(f)\n    i = 0\n    result.append(i)\n    for j in range(1, n):\n        if s[j] >= f[i]:\n            result.append(j)\n            i = j\n    return result\n", "asserts": ["assert MaxActivities([2, 4, 5, 6, 7, 8], [3, 5, 6, 7, 9, 10]) == [0, 1, 2, 3, 4]", "assert MaxActivities([1, 3, 0, 5, 8, 5], [2, 4, 6, 7, 9, 9]) == [0, 1, 3, 4]", "assert MaxActivities([1], [2]) == [0]"]}], "category": "Array", "prompt_tokens": 782, "total_tokens": 1082, "completion_tokens": 300, "completion": "Given an array of non-negative integers arr and a positive integer k, write a function that returns an array containing all the distinct numbers in arr that have exactly k distinct positive divisors. The divisors of a number include 1 and the number itself. The output array should be in ascending order.\n\n###Code: \n\ndef k_divisors(arr: list, k: int) -> list:\n    def count_divisors(n):\n        count = 0\n        for i in range(1, int(n ** 0.5) + 1):\n            if n % i == 0:\n                count += 1 if i * i == n else 2\n        return count\n\n    result = []\n    seen = set()\n    for num in arr:\n        if num not in seen and count_divisors(num) == k:\n            seen.add(num)\n            result.append(num)\n\n    return sorted(result)\n\n\n###Testcases: \n\nassert k_divisors([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 4) == [6, 10]\nassert k_divisors([12, 18, 20, 24, 36], 6) == [18, 20, 24]\nassert k_divisors([10, 22, 28, 33, 42], 8) == [28, 42]\n\n[/Example 3]", "temperature": 0.924}, {"few_shots": [{"author": "Calvin", "UUID": "a9c5e697-af5d-432b-8447-5675d739c728", "question": "Given an array reorder it so that even numbers appear first", "examples": "Input: [1,2,3,4,5,6,7,8,9]\r\nOutput: [8,2,6,4,5,7,3,9,1]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def even_odd_reorder(arr: list) -> list:\n  nextEven = 0\n  nextOdd = len(arr) - 1\n  while nextEven < nextOdd:\n    if arr[nextEven] % 2 == 0:\n      nextEven += 1\n    else:\n      temp = arr[nextEven]\n      arr[nextEven] = arr[nextOdd]\n      arr[nextOdd] = temp\n      nextOdd -= 1\n  return arr\n", "asserts": ["assert even_odd_reorder([1,2,3,4,5,6,7,8,9]) == [8, 2, 6, 4, 5, 7, 3, 9, 1]", "assert even_odd_reorder([]) == []", "assert even_odd_reorder([2, 4, 6, 8]) == [2, 4, 6, 8]", "assert even_odd_reorder([7, 9, 2]) == [2, 9, 7]", "assert even_odd_reorder([10, 13, 17, 16, 15, 12]) == [10, 12, 16, 15, 17, 13]"]}, {"author": "Calvin", "UUID": "f795bda7-9822-4bc5-9c7e-b9c0f2752085", "question": "You are given two 0-indexed integer permutations A and B of length n.\n\nA prefix common array of A and B is an array C such that C[i] is equal to the count of numbers that are present at or before the index i in both A and B.\n\nReturn the prefix common array of A and B.\n\nA sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once.", "examples": "Input: A = [1,3,2,4], B = [3,1,2,4]\nOutput: [0,2,3,4]", "link": "https://leetcode.com/problems/find-the-prefix-common-array-of-two-arrays/", "difficulty": null, "categories": ["Array"], "code": "def findThePrefixCommonArray(arr1: list, arr2: list) -> list:\n  max = len(arr1) if len(arr1) > len(arr2) else len(arr2)\n  seen = set()\n  curCount = 0\n  ret = []\n  for i in range(max):\n    cur1 = arr1[i]\n    cur2 = arr2[i]\n    if cur1 in seen:\n      curCount += 1\n    else:\n      seen.add(cur1)\n    if cur2 in seen:\n      curCount += 1\n    else:\n      seen.add(cur2)\n    ret.append(curCount)\n  return ret\n", "asserts": ["assert findThePrefixCommonArray([1,3,2,4], [3,1,2,4]) == [0,2,3,4]", "assert findThePrefixCommonArray([1], [1]) == [1]", "assert findThePrefixCommonArray([2,3,1], [3,1,2]) == [0,1,3]"]}], "category": "Array", "prompt_tokens": 781, "total_tokens": 1046, "completion_tokens": 265, "completion": "Given an array of integers, return a new array such that each element at index `i` of the new array is the product of all the numbers in the original array except the one at `i`.\n\n###Code:\n\ndef product_array_except_self(nums: list) -> list:\n    length = len(nums)\n    answer = [1] * length\n    \n    # Calculate lefts and store in answer\n    left = 1\n    for i in range(length):\n        answer[i] = left\n        left *= nums[i]\n    \n    # Calculate rights and the product from the end of the array\n    right = 1\n    for i in reversed(range(length)):\n        answer[i] *= right\n        right *= nums[i]\n\n    return answer\n\n###Testcases:\n\nassert product_array_except_self([1, 2, 3, 4]) == [24, 12, 8, 6]\nassert product_array_except_self([0, 0]) == [0, 0]\nassert product_array_except_self([1, 0]) == [0, 1]\nassert product_array_except_self([-1, 1, -2, 2]) == [-4, 4, -2, 2]\nassert product_array_except_self([9]) == [1]", "temperature": 0.662}, {"few_shots": [{"author": "Calvin", "UUID": "f795bda7-9822-4bc5-9c7e-b9c0f2752085", "question": "You are given two 0-indexed integer permutations A and B of length n.\n\nA prefix common array of A and B is an array C such that C[i] is equal to the count of numbers that are present at or before the index i in both A and B.\n\nReturn the prefix common array of A and B.\n\nA sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once.", "examples": "Input: A = [1,3,2,4], B = [3,1,2,4]\nOutput: [0,2,3,4]", "link": "https://leetcode.com/problems/find-the-prefix-common-array-of-two-arrays/", "difficulty": null, "categories": ["Array"], "code": "def findThePrefixCommonArray(arr1: list, arr2: list) -> list:\n  max = len(arr1) if len(arr1) > len(arr2) else len(arr2)\n  seen = set()\n  curCount = 0\n  ret = []\n  for i in range(max):\n    cur1 = arr1[i]\n    cur2 = arr2[i]\n    if cur1 in seen:\n      curCount += 1\n    else:\n      seen.add(cur1)\n    if cur2 in seen:\n      curCount += 1\n    else:\n      seen.add(cur2)\n    ret.append(curCount)\n  return ret\n", "asserts": ["assert findThePrefixCommonArray([1,3,2,4], [3,1,2,4]) == [0,2,3,4]", "assert findThePrefixCommonArray([1], [1]) == [1]", "assert findThePrefixCommonArray([2,3,1], [3,1,2]) == [0,1,3]"]}, {"author": "Calvin", "UUID": "a9c5e697-af5d-432b-8447-5675d739c728", "question": "Given an array reorder it so that even numbers appear first", "examples": "Input: [1,2,3,4,5,6,7,8,9]\r\nOutput: [8,2,6,4,5,7,3,9,1]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def even_odd_reorder(arr: list) -> list:\n  nextEven = 0\n  nextOdd = len(arr) - 1\n  while nextEven < nextOdd:\n    if arr[nextEven] % 2 == 0:\n      nextEven += 1\n    else:\n      temp = arr[nextEven]\n      arr[nextEven] = arr[nextOdd]\n      arr[nextOdd] = temp\n      nextOdd -= 1\n  return arr\n", "asserts": ["assert even_odd_reorder([1,2,3,4,5,6,7,8,9]) == [8, 2, 6, 4, 5, 7, 3, 9, 1]", "assert even_odd_reorder([]) == []", "assert even_odd_reorder([2, 4, 6, 8]) == [2, 4, 6, 8]", "assert even_odd_reorder([7, 9, 2]) == [2, 9, 7]", "assert even_odd_reorder([10, 13, 17, 16, 15, 12]) == [10, 12, 16, 15, 17, 13]"]}], "category": "Array", "prompt_tokens": 781, "total_tokens": 1020, "completion_tokens": 239, "completion": "Write a function that takes an array of integers and returns a new array containing only the unique elements in the order that they first appeared in the input array.\n\n###Code:\n\n```python\ndef unique_elements(arr: list) -> list:\n    seen = set()\n    unique = []\n    for el in arr:\n        if el not in seen:\n            unique.append(el)\n            seen.add(el)\n    return unique\n```\n\n###Testcases:\n\n```python\nassert unique_elements([1, 2, 3, 2, 4, 3]) == [1, 2, 3, 4]\nassert unique_elements([5, 5, 5, 5, 5]) == [5]\nassert unique_elements([2, 1, 2, 3, 4, 3, 4, 5]) == [2, 1, 3, 4, 5]\nassert unique_elements([]) == []\nassert unique_elements([10, 22, 10, 20, 11, 22]) == [10, 22, 20, 11]\n```\n\n[/Example 3]", "temperature": 0.691}, {"few_shots": [{"author": "Calvin", "UUID": "48c6aa37-e00d-4b55-9afc-6b1cf2a1aff2", "question": "There are N Mice and N holes are placed in a straight line. Each hole can accommodate only 1 mouse. A mouse can stay at his position, move one step right from x to x + 1, or move one step left from x to x -1. Any of these moves consumes 1 minute. Assign mice to holes so that the time when the last mouse gets inside a hole is minimized.\nYou are given a list of mice and hole positions as integer scalers.\n", "examples": "Input: Mices = [0, 10, 2, 3], Holes = [3, 2, 23, 0]\nOutput: 13", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def assignHole(mices: list, holes: list) -> int:\n    for i,j in zip(mices,holes):\n        if i<0 or j<0:\n            return -1\n    if (len(mices) != len(holes)):\n        return -1\n    mices.sort()\n    holes.sort()\n    Max = 0\n     \n    for i in range(len(holes)):\n        if (Max < abs(mices[i] - holes[i])):\n            Max = abs(mices[i] - holes[i])\n     \n    return Max\n", "asserts": ["assert assignHole([1, 2, 3, 4], [4, 3, 2, 1]) == 0", "assert assignHole([10, 20, 30, 40], [15, 25, 35, 45]) == 5", "assert assignHole([1, 4, 9, 15], [10, 13, 7, 20]) == 6", "assert assignHole([0], [0]) == 0", "assert assignHole([1, 2], [3]) == -1  # Edge case with non-equal amount of mice and holes", "assert assignHole([5, 5, 5], [5, 5, 5]) == 0  # Edge case with all mice and holes at the same position", "assert assignHole([10, 10, 10, 10], [10, 9, 8, 7]) == 3  # Edge case with multiple mice starting at the same position", "assert assignHole([1,1 ,1, 1, 1, 1, 1, 1, 1, 1], [2,2,2,2,2,2 ,2, 2, 2, 2]) == 1 # Edge case with multiple mice and holes at the same positions", "assert assignHole([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == 1 # Edge case with incremental positions"]}, {"author": "Calvin", "UUID": "a9c5e697-af5d-432b-8447-5675d739c728", "question": "Given an array reorder it so that even numbers appear first", "examples": "Input: [1,2,3,4,5,6,7,8,9]\r\nOutput: [8,2,6,4,5,7,3,9,1]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def even_odd_reorder(arr: list) -> list:\n  nextEven = 0\n  nextOdd = len(arr) - 1\n  while nextEven < nextOdd:\n    if arr[nextEven] % 2 == 0:\n      nextEven += 1\n    else:\n      temp = arr[nextEven]\n      arr[nextEven] = arr[nextOdd]\n      arr[nextOdd] = temp\n      nextOdd -= 1\n  return arr\n", "asserts": ["assert even_odd_reorder([1,2,3,4,5,6,7,8,9]) == [8, 2, 6, 4, 5, 7, 3, 9, 1]", "assert even_odd_reorder([]) == []", "assert even_odd_reorder([2, 4, 6, 8]) == [2, 4, 6, 8]", "assert even_odd_reorder([7, 9, 2]) == [2, 9, 7]", "assert even_odd_reorder([10, 13, 17, 16, 15, 12]) == [10, 12, 16, 15, 17, 13]"]}], "category": "Array", "prompt_tokens": 1067, "total_tokens": 1392, "completion_tokens": 325, "completion": "Write a function that takes an array of integers and returns the length of the longest subsequence where the difference between adjacent elements is one or less.\n\n###Code: \n\ndef longest_subsequence(arr: list) -> int:\n    if not arr:\n        return 0\n    \n    arr.sort()\n    longest, current_length = 1, 1\n    \n    for i in range(1, len(arr)):\n        if arr[i] - arr[i-1] <= 1:\n            current_length += 1\n        else:\n            longest = max(longest, current_length)\n            current_length = 1\n    \n    return max(longest, current_length)\n\n###Testcases: \n\nassert longest_subsequence([1, 2, 3, 4, 5, 3, 2]) == 5\nassert longest_subsequence([10, 9, 1, 2, 3, 11, 10]) == 4\nassert longest_subsequence([4, 6, 5, 3, 3, 1]) == 3\nassert longest_subsequence([1, 1, 1, 1, 1]) == 5\nassert longest_subsequence([]) == 0\nassert longest_subsequence([1]) == 1\nassert longest_subsequence([1, 3, 5, 7, 9, 11]) == 1\nassert longest_subsequence([5, 5, 4, 4, 3, 2, 1]) == 7\n\n[/Example 3]", "temperature": 0.727}, {"few_shots": [{"author": "Calvin", "UUID": "48c6aa37-e00d-4b55-9afc-6b1cf2a1aff2", "question": "There are N Mice and N holes are placed in a straight line. Each hole can accommodate only 1 mouse. A mouse can stay at his position, move one step right from x to x + 1, or move one step left from x to x -1. Any of these moves consumes 1 minute. Assign mice to holes so that the time when the last mouse gets inside a hole is minimized.\nYou are given a list of mice and hole positions as integer scalers.\n", "examples": "Input: Mices = [0, 10, 2, 3], Holes = [3, 2, 23, 0]\nOutput: 13", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def assignHole(mices: list, holes: list) -> int:\n    for i,j in zip(mices,holes):\n        if i<0 or j<0:\n            return -1\n    if (len(mices) != len(holes)):\n        return -1\n    mices.sort()\n    holes.sort()\n    Max = 0\n     \n    for i in range(len(holes)):\n        if (Max < abs(mices[i] - holes[i])):\n            Max = abs(mices[i] - holes[i])\n     \n    return Max\n", "asserts": ["assert assignHole([1, 2, 3, 4], [4, 3, 2, 1]) == 0", "assert assignHole([10, 20, 30, 40], [15, 25, 35, 45]) == 5", "assert assignHole([1, 4, 9, 15], [10, 13, 7, 20]) == 6", "assert assignHole([0], [0]) == 0", "assert assignHole([1, 2], [3]) == -1  # Edge case with non-equal amount of mice and holes", "assert assignHole([5, 5, 5], [5, 5, 5]) == 0  # Edge case with all mice and holes at the same position", "assert assignHole([10, 10, 10, 10], [10, 9, 8, 7]) == 3  # Edge case with multiple mice starting at the same position", "assert assignHole([1,1 ,1, 1, 1, 1, 1, 1, 1, 1], [2,2,2,2,2,2 ,2, 2, 2, 2]) == 1 # Edge case with multiple mice and holes at the same positions", "assert assignHole([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == 1 # Edge case with incremental positions"]}, {"author": "Calvin", "UUID": "1aeb3246-4c22-4d34-a48c-db7be8ba1b94", "question": "You are given n activities with their start and finish times. Select the maximum number of activities that can be performed by a single person and return their indexes. Assume that a person can only work on a single activity at a time. \n", "examples": "Input: start  =  {10, 12, 20}, finish =  {20, 25, 30}\nOutput: [0, 2]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "import numpy as np\ndef MaxActivities(s: list, f: list) -> list:\n    indices = np.argsort(f)\n    [s[i] for i in indices]\n    [f[i] for i in indices]\n    result = []\n    n = len(f)\n    i = 0\n    result.append(i)\n    for j in range(1, n):\n        if s[j] >= f[i]:\n            result.append(j)\n            i = j\n    return result\n", "asserts": ["assert MaxActivities([2, 4, 5, 6, 7, 8], [3, 5, 6, 7, 9, 10]) == [0, 1, 2, 3, 4]", "assert MaxActivities([1, 3, 0, 5, 8, 5], [2, 4, 6, 7, 9, 9]) == [0, 1, 3, 4]", "assert MaxActivities([1], [2]) == [0]"]}], "category": "Array", "prompt_tokens": 1068, "total_tokens": 1449, "completion_tokens": 381, "completion": "Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order. You must write an algorithm with O(log n) runtime complexity.\n\n\n###Code:\n\ndef searchInsert(nums: list, target: int) -> int:\n    left, right = 0, len(nums) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return left\n\n\n###Testcases:\n\nassert searchInsert([1,3,5,6], 5) == 2\nassert searchInsert([1,3,5,6], 2) == 1\nassert searchInsert([1,3,5,6], 7) == 4\nassert searchInsert([1,3,5,6], 0) == 0\nassert searchInsert([1,3,5,6,8,9,10], 8) == 4\nassert searchInsert([], 5) == 0 # Edge case with empty array\nassert searchInsert([2, 3, 5, 6, 9], 4) == 2  # Edge case with target in the middle of two elements\nassert searchInsert([1, 2, 3, 4, 5, 10], 6) == 5 # Edge case with target between two elements with a gap\nassert searchInsert([1, 2, 3, 4, 5], 6) == 5 # Edge case with target greater than all elements\n\n[/Example 3]", "temperature": 0.831}, {"few_shots": [{"author": "Calvin", "UUID": "48c6aa37-e00d-4b55-9afc-6b1cf2a1aff2", "question": "There are N Mice and N holes are placed in a straight line. Each hole can accommodate only 1 mouse. A mouse can stay at his position, move one step right from x to x + 1, or move one step left from x to x -1. Any of these moves consumes 1 minute. Assign mice to holes so that the time when the last mouse gets inside a hole is minimized.\nYou are given a list of mice and hole positions as integer scalers.\n", "examples": "Input: Mices = [0, 10, 2, 3], Holes = [3, 2, 23, 0]\nOutput: 13", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def assignHole(mices: list, holes: list) -> int:\n    for i,j in zip(mices,holes):\n        if i<0 or j<0:\n            return -1\n    if (len(mices) != len(holes)):\n        return -1\n    mices.sort()\n    holes.sort()\n    Max = 0\n     \n    for i in range(len(holes)):\n        if (Max < abs(mices[i] - holes[i])):\n            Max = abs(mices[i] - holes[i])\n     \n    return Max\n", "asserts": ["assert assignHole([1, 2, 3, 4], [4, 3, 2, 1]) == 0", "assert assignHole([10, 20, 30, 40], [15, 25, 35, 45]) == 5", "assert assignHole([1, 4, 9, 15], [10, 13, 7, 20]) == 6", "assert assignHole([0], [0]) == 0", "assert assignHole([1, 2], [3]) == -1  # Edge case with non-equal amount of mice and holes", "assert assignHole([5, 5, 5], [5, 5, 5]) == 0  # Edge case with all mice and holes at the same position", "assert assignHole([10, 10, 10, 10], [10, 9, 8, 7]) == 3  # Edge case with multiple mice starting at the same position", "assert assignHole([1,1 ,1, 1, 1, 1, 1, 1, 1, 1], [2,2,2,2,2,2 ,2, 2, 2, 2]) == 1 # Edge case with multiple mice and holes at the same positions", "assert assignHole([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == 1 # Edge case with incremental positions"]}, {"author": "Calvin", "UUID": "f795bda7-9822-4bc5-9c7e-b9c0f2752085", "question": "You are given two 0-indexed integer permutations A and B of length n.\n\nA prefix common array of A and B is an array C such that C[i] is equal to the count of numbers that are present at or before the index i in both A and B.\n\nReturn the prefix common array of A and B.\n\nA sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once.", "examples": "Input: A = [1,3,2,4], B = [3,1,2,4]\nOutput: [0,2,3,4]", "link": "https://leetcode.com/problems/find-the-prefix-common-array-of-two-arrays/", "difficulty": null, "categories": ["Array"], "code": "def findThePrefixCommonArray(arr1: list, arr2: list) -> list:\n  max = len(arr1) if len(arr1) > len(arr2) else len(arr2)\n  seen = set()\n  curCount = 0\n  ret = []\n  for i in range(max):\n    cur1 = arr1[i]\n    cur2 = arr2[i]\n    if cur1 in seen:\n      curCount += 1\n    else:\n      seen.add(cur1)\n    if cur2 in seen:\n      curCount += 1\n    else:\n      seen.add(cur2)\n    ret.append(curCount)\n  return ret\n", "asserts": ["assert findThePrefixCommonArray([1,3,2,4], [3,1,2,4]) == [0,2,3,4]", "assert findThePrefixCommonArray([1], [1]) == [1]", "assert findThePrefixCommonArray([2,3,1], [3,1,2]) == [0,1,3]"]}], "category": "Array", "prompt_tokens": 1103, "total_tokens": 1505, "completion_tokens": 402, "completion": "Given an array of integers, return the length of the longest consecutive elements sequence. The array might have duplicates, and the sequence must not contain any duplicates. A consecutive elements sequence is a sequence in which integers are sequential, for example, 1, 2, 3, 4.\n\n###Code:\n\n```python\ndef longest_consecutive(nums: list) -> int:\n    if not nums:\n        return 0\n\n    nums = sorted(set(nums))\n    longest_streak = 1\n    current_streak = 1\n\n    for i in range(1, len(nums)):\n        if nums[i] == nums[i-1] + 1:\n            current_streak += 1\n        else:\n            longest_streak = max(longest_streak, current_streak)\n            current_streak = 1\n\n    return max(longest_streak, current_streak)\n```\n\n###Testcases:\n\n```python\nassert longest_consecutive([100, 4, 200, 1, 3, 2]) == 4\nassert longest_consecutive([1, 2, 0, 1]) == 3\nassert longest_consecutive([9, 1, 4, 7, 3, -2, 0, 1, 2]) == 5\nassert longest_consecutive([]) == 0\nassert longest_consecutive([0]) == 1\nassert longest_consecutive([-2, -3, -4, -1, 0]) == 5\nassert longest_consecutive([1, 1, 1, 1, 1]) == 1  # Edge case with duplicates\nassert longest_consecutive([1, 3, 5, 2, 4]) == 5  # Test with shuffled consecutive numbers\nassert longest_consecutive([10, 5, 12, 3]) == 1  # Test with no consecutive numbers\n```", "temperature": 0.765}, {"few_shots": [{"author": "Calvin", "UUID": "1aeb3246-4c22-4d34-a48c-db7be8ba1b94", "question": "You are given n activities with their start and finish times. Select the maximum number of activities that can be performed by a single person and return their indexes. Assume that a person can only work on a single activity at a time. \n", "examples": "Input: start  =  {10, 12, 20}, finish =  {20, 25, 30}\nOutput: [0, 2]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "import numpy as np\ndef MaxActivities(s: list, f: list) -> list:\n    indices = np.argsort(f)\n    [s[i] for i in indices]\n    [f[i] for i in indices]\n    result = []\n    n = len(f)\n    i = 0\n    result.append(i)\n    for j in range(1, n):\n        if s[j] >= f[i]:\n            result.append(j)\n            i = j\n    return result\n", "asserts": ["assert MaxActivities([2, 4, 5, 6, 7, 8], [3, 5, 6, 7, 9, 10]) == [0, 1, 2, 3, 4]", "assert MaxActivities([1, 3, 0, 5, 8, 5], [2, 4, 6, 7, 9, 9]) == [0, 1, 3, 4]", "assert MaxActivities([1], [2]) == [0]"]}, {"author": "Calvin", "UUID": "f795bda7-9822-4bc5-9c7e-b9c0f2752085", "question": "You are given two 0-indexed integer permutations A and B of length n.\n\nA prefix common array of A and B is an array C such that C[i] is equal to the count of numbers that are present at or before the index i in both A and B.\n\nReturn the prefix common array of A and B.\n\nA sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once.", "examples": "Input: A = [1,3,2,4], B = [3,1,2,4]\nOutput: [0,2,3,4]", "link": "https://leetcode.com/problems/find-the-prefix-common-array-of-two-arrays/", "difficulty": null, "categories": ["Array"], "code": "def findThePrefixCommonArray(arr1: list, arr2: list) -> list:\n  max = len(arr1) if len(arr1) > len(arr2) else len(arr2)\n  seen = set()\n  curCount = 0\n  ret = []\n  for i in range(max):\n    cur1 = arr1[i]\n    cur2 = arr2[i]\n    if cur1 in seen:\n      curCount += 1\n    else:\n      seen.add(cur1)\n    if cur2 in seen:\n      curCount += 1\n    else:\n      seen.add(cur2)\n    ret.append(curCount)\n  return ret\n", "asserts": ["assert findThePrefixCommonArray([1,3,2,4], [3,1,2,4]) == [0,2,3,4]", "assert findThePrefixCommonArray([1], [1]) == [1]", "assert findThePrefixCommonArray([2,3,1], [3,1,2]) == [0,1,3]"]}], "category": "Array", "prompt_tokens": 782, "total_tokens": 936, "completion_tokens": 154, "completion": "Given an array of integers, you need to find the maximum product of two distinct numbers in the array. The function should return the maximum product that can be achieved from any pair of distinct elements within the array.\n\n###Code: \n\ndef maxProduct(nums: list) -> int:\n    nums.sort()\n    return max(nums[-1] * nums[-2], nums[0] * nums[1])\n\n###Testcases: \n\nassert maxProduct([5, 20, 2, 6]) == 120\nassert maxProduct([-10, -20, 1, 3]) == 200\nassert maxProduct([0, 2, 3, -2, 4, -1]) == 8\n\n[/Example 3]", "temperature": 0.812}, {"few_shots": [{"author": "Calvin", "UUID": "a9c5e697-af5d-432b-8447-5675d739c728", "question": "Given an array reorder it so that even numbers appear first", "examples": "Input: [1,2,3,4,5,6,7,8,9]\r\nOutput: [8,2,6,4,5,7,3,9,1]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def even_odd_reorder(arr: list) -> list:\n  nextEven = 0\n  nextOdd = len(arr) - 1\n  while nextEven < nextOdd:\n    if arr[nextEven] % 2 == 0:\n      nextEven += 1\n    else:\n      temp = arr[nextEven]\n      arr[nextEven] = arr[nextOdd]\n      arr[nextOdd] = temp\n      nextOdd -= 1\n  return arr\n", "asserts": ["assert even_odd_reorder([1,2,3,4,5,6,7,8,9]) == [8, 2, 6, 4, 5, 7, 3, 9, 1]", "assert even_odd_reorder([]) == []", "assert even_odd_reorder([2, 4, 6, 8]) == [2, 4, 6, 8]", "assert even_odd_reorder([7, 9, 2]) == [2, 9, 7]", "assert even_odd_reorder([10, 13, 17, 16, 15, 12]) == [10, 12, 16, 15, 17, 13]"]}, {"author": "Calvin", "UUID": "1aeb3246-4c22-4d34-a48c-db7be8ba1b94", "question": "You are given n activities with their start and finish times. Select the maximum number of activities that can be performed by a single person and return their indexes. Assume that a person can only work on a single activity at a time. \n", "examples": "Input: start  =  {10, 12, 20}, finish =  {20, 25, 30}\nOutput: [0, 2]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "import numpy as np\ndef MaxActivities(s: list, f: list) -> list:\n    indices = np.argsort(f)\n    [s[i] for i in indices]\n    [f[i] for i in indices]\n    result = []\n    n = len(f)\n    i = 0\n    result.append(i)\n    for j in range(1, n):\n        if s[j] >= f[i]:\n            result.append(j)\n            i = j\n    return result\n", "asserts": ["assert MaxActivities([2, 4, 5, 6, 7, 8], [3, 5, 6, 7, 9, 10]) == [0, 1, 2, 3, 4]", "assert MaxActivities([1, 3, 0, 5, 8, 5], [2, 4, 6, 7, 9, 9]) == [0, 1, 3, 4]", "assert MaxActivities([1], [2]) == [0]"]}], "category": "Array", "prompt_tokens": 746, "total_tokens": 1029, "completion_tokens": 283, "completion": "Given an array containing n numbers. The problem is to find the length of the longest contiguous subarray with the sum equal to a given value k.\n\n###Code: \n\ndef max_subarray_length_with_sum(arr: list, k: int) -> int:\n    seen_sums = {0: -1}\n    max_length = 0\n    current_sum = 0\n    for idx, num in enumerate(arr):\n        current_sum += num\n        if current_sum not in seen_sums:\n            seen_sums[current_sum] = idx\n        if (current_sum - k) in seen_sums:\n            max_length = max(max_length, idx - seen_sums[current_sum - k])\n    return max_length\n\n###Testcases: \n\nassert max_subarray_length_with_sum([1, -1, 5, -2, 3], 3) == 4\nassert max_subarray_length_with_sum([-2, -1, 2, 1], 1) == 2\nassert max_subarray_length_with_sum([1, 2, 3], 3) == 2\nassert max_subarray_length_with_sum([], 0) == 0\nassert max_subarray_length_with_sum([10, 5, 2, 7, 1, 9], 15) == 4\n\n[/Example 3]", "temperature": 0.902}, {"few_shots": [{"author": "Calvin", "UUID": "1aeb3246-4c22-4d34-a48c-db7be8ba1b94", "question": "You are given n activities with their start and finish times. Select the maximum number of activities that can be performed by a single person and return their indexes. Assume that a person can only work on a single activity at a time. \n", "examples": "Input: start  =  {10, 12, 20}, finish =  {20, 25, 30}\nOutput: [0, 2]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "import numpy as np\ndef MaxActivities(s: list, f: list) -> list:\n    indices = np.argsort(f)\n    [s[i] for i in indices]\n    [f[i] for i in indices]\n    result = []\n    n = len(f)\n    i = 0\n    result.append(i)\n    for j in range(1, n):\n        if s[j] >= f[i]:\n            result.append(j)\n            i = j\n    return result\n", "asserts": ["assert MaxActivities([2, 4, 5, 6, 7, 8], [3, 5, 6, 7, 9, 10]) == [0, 1, 2, 3, 4]", "assert MaxActivities([1, 3, 0, 5, 8, 5], [2, 4, 6, 7, 9, 9]) == [0, 1, 3, 4]", "assert MaxActivities([1], [2]) == [0]"]}, {"author": "Calvin", "UUID": "a9c5e697-af5d-432b-8447-5675d739c728", "question": "Given an array reorder it so that even numbers appear first", "examples": "Input: [1,2,3,4,5,6,7,8,9]\r\nOutput: [8,2,6,4,5,7,3,9,1]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def even_odd_reorder(arr: list) -> list:\n  nextEven = 0\n  nextOdd = len(arr) - 1\n  while nextEven < nextOdd:\n    if arr[nextEven] % 2 == 0:\n      nextEven += 1\n    else:\n      temp = arr[nextEven]\n      arr[nextEven] = arr[nextOdd]\n      arr[nextOdd] = temp\n      nextOdd -= 1\n  return arr\n", "asserts": ["assert even_odd_reorder([1,2,3,4,5,6,7,8,9]) == [8, 2, 6, 4, 5, 7, 3, 9, 1]", "assert even_odd_reorder([]) == []", "assert even_odd_reorder([2, 4, 6, 8]) == [2, 4, 6, 8]", "assert even_odd_reorder([7, 9, 2]) == [2, 9, 7]", "assert even_odd_reorder([10, 13, 17, 16, 15, 12]) == [10, 12, 16, 15, 17, 13]"]}], "category": "Array", "prompt_tokens": 746, "total_tokens": 1013, "completion_tokens": 267, "completion": "Given an array of integers, write a function that moves all zeros to the end while maintaining the relative order of the non-zero elements.\n\n###Code: \n\ndef move_zeros_to_end(arr: list) -> list:\n    non_zero_index = 0\n    for i in range(len(arr)):\n        if arr[i] != 0:\n            arr[non_zero_index], arr[i] = arr[i], arr[non_zero_index]\n            non_zero_index += 1\n    return arr\n\n###Testcases: \n\nassert move_zeros_to_end([0,1,0,3,12]) == [1,3,12,0,0]\nassert move_zeros_to_end([1,7,0,0,8,0,10,12]) == [1,7,8,10,12,0,0,0]\nassert move_zeros_to_end([0,0,0,0,0,1]) == [1,0,0,0,0,0]\nassert move_zeros_to_end([]) == []\nassert move_zeros_to_end([4,2,4,0,0,3,0,5,1,0]) == [4,2,4,3,5,1,0,0,0,0]\n\n[/Example 3]", "temperature": 0.807}, {"few_shots": [{"author": "Calvin", "UUID": "9e45b73f-583d-40ab-b387-e0d1624af07b", "question": "Given two arrays return an array with the set intersection of their common elements", "examples": "Input: arr1 = [1, 2, 3, 4], arr2 = [2, 3]\nOutput: [2, 3]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def array_intersection(arr1: list, arr2: list) -> set:\n  set1 = set(arr1)\n  ret = set([x for x in arr2 if x in set1])\n  return list(ret)\n", "asserts": ["assert set(array_intersection([1,0,2,0,2,0,2,1,1,1], [2,1,0,2,0,2,2,2,1,0])) == {0,1,2}", "assert set(array_intersection([5, 6, 7, 8], [8, 9, 10, 11])) == {8}", "assert set(array_intersection([10, 20, 30], [40, 50, 60])) == set()", "assert set(array_intersection([], [1, 2, 3])) == set()", "assert set(array_intersection([-1, -2, -3], [-3, -4, -5, -6])) == {-3}", "assert set(array_intersection([9, 8, 7], [7, 8, 9, 10, 11, 12])) == {7, 8, 9}", "assert set(array_intersection(['a', 'b', 'c'], ['a', 'd', 'e', 'c'])) == {'a', 'c'}", "assert set(array_intersection(['apple', 'banana'], ['banana', 'cherry'])) == {'banana'}", "assert set(array_intersection([1.1, 2.2, 3.3], [2.2, 4.4])) == {2.2}", "assert set(array_intersection([False, True, False], [True, False, True])) == {True, False}", "assert set(array_intersection([(1, 2), (3, 4)], [(3, 4), (5, 6)])) == {(3, 4)}"]}, {"author": "Calvin", "UUID": "a9c5e697-af5d-432b-8447-5675d739c728", "question": "Given an array reorder it so that even numbers appear first", "examples": "Input: [1,2,3,4,5,6,7,8,9]\r\nOutput: [8,2,6,4,5,7,3,9,1]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def even_odd_reorder(arr: list) -> list:\n  nextEven = 0\n  nextOdd = len(arr) - 1\n  while nextEven < nextOdd:\n    if arr[nextEven] % 2 == 0:\n      nextEven += 1\n    else:\n      temp = arr[nextEven]\n      arr[nextEven] = arr[nextOdd]\n      arr[nextOdd] = temp\n      nextOdd -= 1\n  return arr\n", "asserts": ["assert even_odd_reorder([1,2,3,4,5,6,7,8,9]) == [8, 2, 6, 4, 5, 7, 3, 9, 1]", "assert even_odd_reorder([]) == []", "assert even_odd_reorder([2, 4, 6, 8]) == [2, 4, 6, 8]", "assert even_odd_reorder([7, 9, 2]) == [2, 9, 7]", "assert even_odd_reorder([10, 13, 17, 16, 15, 12]) == [10, 12, 16, 15, 17, 13]"]}], "category": "Array", "prompt_tokens": 886, "total_tokens": 1148, "completion_tokens": 262, "completion": "Given an array of integers, return the maximum product that can be obtained from any three numbers in the array.\n\n###Code: \n\n```python\nfrom itertools import combinations\n\ndef max_product_of_three(nums: list) -> int:\n    return max(a * b * c for a, b, c in combinations(nums, 3))\n\n```\n\n###Testcases: \n\n```python\nassert max_product_of_three([1, 2, 3]) == 6\nassert max_product_of_three([-10, -10, 1, 3, 2]) == 300\nassert max_product_of_three([10, 3, 5, 6, 20]) == 1200\nassert max_product_of_three([-1, -2, -3, -4]) == -6\nassert max_product_of_three([1, 2, 3, 4, 5]) == 60\nassert max_product_of_three([0, 2, 3]) == 0\nassert max_product_of_three([-1, -2, -3, 7]) == 42\nassert max_product_of_three([1, -4, 3, -6, 7, 0]) == 168\n```\n\n[/Example 3]", "temperature": 0.683}, {"few_shots": [{"author": "Calvin", "UUID": "48c6aa37-e00d-4b55-9afc-6b1cf2a1aff2", "question": "There are N Mice and N holes are placed in a straight line. Each hole can accommodate only 1 mouse. A mouse can stay at his position, move one step right from x to x + 1, or move one step left from x to x -1. Any of these moves consumes 1 minute. Assign mice to holes so that the time when the last mouse gets inside a hole is minimized.\nYou are given a list of mice and hole positions as integer scalers.\n", "examples": "Input: Mices = [0, 10, 2, 3], Holes = [3, 2, 23, 0]\nOutput: 13", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def assignHole(mices: list, holes: list) -> int:\n    for i,j in zip(mices,holes):\n        if i<0 or j<0:\n            return -1\n    if (len(mices) != len(holes)):\n        return -1\n    mices.sort()\n    holes.sort()\n    Max = 0\n     \n    for i in range(len(holes)):\n        if (Max < abs(mices[i] - holes[i])):\n            Max = abs(mices[i] - holes[i])\n     \n    return Max\n", "asserts": ["assert assignHole([1, 2, 3, 4], [4, 3, 2, 1]) == 0", "assert assignHole([10, 20, 30, 40], [15, 25, 35, 45]) == 5", "assert assignHole([1, 4, 9, 15], [10, 13, 7, 20]) == 6", "assert assignHole([0], [0]) == 0", "assert assignHole([1, 2], [3]) == -1  # Edge case with non-equal amount of mice and holes", "assert assignHole([5, 5, 5], [5, 5, 5]) == 0  # Edge case with all mice and holes at the same position", "assert assignHole([10, 10, 10, 10], [10, 9, 8, 7]) == 3  # Edge case with multiple mice starting at the same position", "assert assignHole([1,1 ,1, 1, 1, 1, 1, 1, 1, 1], [2,2,2,2,2,2 ,2, 2, 2, 2]) == 1 # Edge case with multiple mice and holes at the same positions", "assert assignHole([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == 1 # Edge case with incremental positions"]}, {"author": "Calvin", "UUID": "9e45b73f-583d-40ab-b387-e0d1624af07b", "question": "Given two arrays return an array with the set intersection of their common elements", "examples": "Input: arr1 = [1, 2, 3, 4], arr2 = [2, 3]\nOutput: [2, 3]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def array_intersection(arr1: list, arr2: list) -> set:\n  set1 = set(arr1)\n  ret = set([x for x in arr2 if x in set1])\n  return list(ret)\n", "asserts": ["assert set(array_intersection([1,0,2,0,2,0,2,1,1,1], [2,1,0,2,0,2,2,2,1,0])) == {0,1,2}", "assert set(array_intersection([5, 6, 7, 8], [8, 9, 10, 11])) == {8}", "assert set(array_intersection([10, 20, 30], [40, 50, 60])) == set()", "assert set(array_intersection([], [1, 2, 3])) == set()", "assert set(array_intersection([-1, -2, -3], [-3, -4, -5, -6])) == {-3}", "assert set(array_intersection([9, 8, 7], [7, 8, 9, 10, 11, 12])) == {7, 8, 9}", "assert set(array_intersection(['a', 'b', 'c'], ['a', 'd', 'e', 'c'])) == {'a', 'c'}", "assert set(array_intersection(['apple', 'banana'], ['banana', 'cherry'])) == {'banana'}", "assert set(array_intersection([1.1, 2.2, 3.3], [2.2, 4.4])) == {2.2}", "assert set(array_intersection([False, True, False], [True, False, True])) == {True, False}", "assert set(array_intersection([(1, 2), (3, 4)], [(3, 4), (5, 6)])) == {(3, 4)}"]}], "category": "Array", "prompt_tokens": 1208, "total_tokens": 1569, "completion_tokens": 361, "completion": "Write a function to find the first non-repeated integer in an array. If there is no non-repeated integer, return -1.\n\n###Code: \n\n```python\ndef first_non_repeated_integer(arr: list) -> int:\n    counts = {}\n    for num in arr:\n        counts[num] = counts.get(num, 0) + 1\n    for num in arr:\n        if counts[num] == 1:\n            return num\n    return -1\n```\n\n###Testcases: \n\n```python\nassert first_non_repeated_integer([1, 2, 2, 3, 4, 4, 5, 3]) == 1\nassert first_non_repeated_integer([7, 7, 8, 8, 0, 0, 10]) == 10\nassert first_non_repeated_integer([3, 3, 4, 4, 5, 5, 5]) == -1\nassert first_non_repeated_integer([-1, -2, -2, -1, -3]) == -3\nassert first_non_repeated_integer([]) == -1  # Edge case with empty array\nassert first_non_repeated_integer([5]) == 5  # Edge case with one element\nassert first_non_repeated_integer([2, 2, 2, 2, 3]) == 3  # Edge case with all elements repeated except one\nassert first_non_repeated_integer([1, 1, 2, 2, 3, 3, 4, 5, 5]) == 4  # Edge case with the first non-repeated integer towards the end\n```\n\n[/Example 3]", "temperature": 0.814}, {"few_shots": [{"author": "Calvin", "UUID": "a9c5e697-af5d-432b-8447-5675d739c728", "question": "Given an array reorder it so that even numbers appear first", "examples": "Input: [1,2,3,4,5,6,7,8,9]\r\nOutput: [8,2,6,4,5,7,3,9,1]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def even_odd_reorder(arr: list) -> list:\n  nextEven = 0\n  nextOdd = len(arr) - 1\n  while nextEven < nextOdd:\n    if arr[nextEven] % 2 == 0:\n      nextEven += 1\n    else:\n      temp = arr[nextEven]\n      arr[nextEven] = arr[nextOdd]\n      arr[nextOdd] = temp\n      nextOdd -= 1\n  return arr\n", "asserts": ["assert even_odd_reorder([1,2,3,4,5,6,7,8,9]) == [8, 2, 6, 4, 5, 7, 3, 9, 1]", "assert even_odd_reorder([]) == []", "assert even_odd_reorder([2, 4, 6, 8]) == [2, 4, 6, 8]", "assert even_odd_reorder([7, 9, 2]) == [2, 9, 7]", "assert even_odd_reorder([10, 13, 17, 16, 15, 12]) == [10, 12, 16, 15, 17, 13]"]}, {"author": "Calvin", "UUID": "fb94082f-4627-4f5a-b280-08d869823d70", "question": "You are given an array of people, people, which are the attributes of some people in a queue (not necessarily in order). Each people[i] = [hi, ki] represents the ith person of height hi with exactly ki other people in front who have a height greater than or equal to hi.\n\nReconstruct and return the queue that is represented by the input array people. The returned queue should be formatted as an array queue, where queue[j] = [hj, kj] is the attributes of the jth person in the queue (queue[0] is the person at the front of the queue).\n", "examples": "Input:  [[7, 0], [4, 4], [7, 1], [5, 0], [6, 1], [5, 2]]\nOutput: [[5, 0], [4, 1], [7, 0], [5, 2], [6, 1], [7, 1]]\n\nInput:  [[6, 0], [5, 0], [4, 0], [3, 2], [2, 2], [1, 4]]\nOutput: [[4, 0], [5, 0], [2, 2], [3, 2], [1, 4], [6, 0]]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "\ndef reconstructQueue(people: list) -> list:\n    output=[] \n    people.sort(key=lambda x: (-x[0], x[1]))                \n    for a in people:\n        output.insert(a[1], a)\n    \n    return output\n", "asserts": ["assert reconstructQueue([[8,1],[5,0],[6,1],[5,2],[4,4],[7,1]]) == [[5, 0], [8, 1], [5, 2], [6, 1], [4, 4], [7, 1]]", "assert reconstructQueue([[12,0], [6,3], [4,4], [9,2], [7,1]]) == [[12, 0], [7, 1], [9, 2], [6, 3], [4, 4]]", "assert reconstructQueue([[2,0], [1,1]]) == [[2, 0], [1, 1]]", "assert reconstructQueue([[3,0], [3,2], [3,1]]) == [[3, 0], [3, 1], [3, 2]]"]}], "category": "Array", "prompt_tokens": 842, "total_tokens": 1125, "completion_tokens": 283, "completion": "Given an array of integers, write a function to move all 0's to the end of it while maintaining the relative order of the non-zero elements.\n\n###Code: \n\ndef moveZeroes(nums: list) -> None:\n    zero = 0  # pointer for the next zero\n    for i in range(len(nums)):\n        if nums[i] != 0:\n            nums[i], nums[zero] = nums[zero], nums[i]\n            zero += 1\n\n###Testcases: \n\nassert moveZeroes([0,1,0,3,12]) == [1,3,12,0,0]\nassert moveZeroes([0,0,1]) == [1,0,0]\nassert moveZeroes([1,7,0,0,8,0,10,12,0,4]) == [1,7,8,10,12,4,0,0,0,0]\nassert moveZeroes([4,2,4,0,0,3,0,5,1,0]) == [4,2,4,3,5,1,0,0,0,0]\nassert moveZeroes([0,0,0,0,3,2,1]) == [3,2,1,0,0,0,0]\n\n[/Example 3]", "temperature": 0.768}, {"few_shots": [{"author": "Calvin", "UUID": "fb94082f-4627-4f5a-b280-08d869823d70", "question": "You are given an array of people, people, which are the attributes of some people in a queue (not necessarily in order). Each people[i] = [hi, ki] represents the ith person of height hi with exactly ki other people in front who have a height greater than or equal to hi.\n\nReconstruct and return the queue that is represented by the input array people. The returned queue should be formatted as an array queue, where queue[j] = [hj, kj] is the attributes of the jth person in the queue (queue[0] is the person at the front of the queue).\n", "examples": "Input:  [[7, 0], [4, 4], [7, 1], [5, 0], [6, 1], [5, 2]]\nOutput: [[5, 0], [4, 1], [7, 0], [5, 2], [6, 1], [7, 1]]\n\nInput:  [[6, 0], [5, 0], [4, 0], [3, 2], [2, 2], [1, 4]]\nOutput: [[4, 0], [5, 0], [2, 2], [3, 2], [1, 4], [6, 0]]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "\ndef reconstructQueue(people: list) -> list:\n    output=[] \n    people.sort(key=lambda x: (-x[0], x[1]))                \n    for a in people:\n        output.insert(a[1], a)\n    \n    return output\n", "asserts": ["assert reconstructQueue([[8,1],[5,0],[6,1],[5,2],[4,4],[7,1]]) == [[5, 0], [8, 1], [5, 2], [6, 1], [4, 4], [7, 1]]", "assert reconstructQueue([[12,0], [6,3], [4,4], [9,2], [7,1]]) == [[12, 0], [7, 1], [9, 2], [6, 3], [4, 4]]", "assert reconstructQueue([[2,0], [1,1]]) == [[2, 0], [1, 1]]", "assert reconstructQueue([[3,0], [3,2], [3,1]]) == [[3, 0], [3, 1], [3, 2]]"]}, {"author": "Calvin", "UUID": "1aeb3246-4c22-4d34-a48c-db7be8ba1b94", "question": "You are given n activities with their start and finish times. Select the maximum number of activities that can be performed by a single person and return their indexes. Assume that a person can only work on a single activity at a time. \n", "examples": "Input: start  =  {10, 12, 20}, finish =  {20, 25, 30}\nOutput: [0, 2]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "import numpy as np\ndef MaxActivities(s: list, f: list) -> list:\n    indices = np.argsort(f)\n    [s[i] for i in indices]\n    [f[i] for i in indices]\n    result = []\n    n = len(f)\n    i = 0\n    result.append(i)\n    for j in range(1, n):\n        if s[j] >= f[i]:\n            result.append(j)\n            i = j\n    return result\n", "asserts": ["assert MaxActivities([2, 4, 5, 6, 7, 8], [3, 5, 6, 7, 9, 10]) == [0, 1, 2, 3, 4]", "assert MaxActivities([1, 3, 0, 5, 8, 5], [2, 4, 6, 7, 9, 9]) == [0, 1, 3, 4]", "assert MaxActivities([1], [2]) == [0]"]}], "category": "Array", "prompt_tokens": 843, "total_tokens": 1075, "completion_tokens": 232, "completion": "Write a function that takes an array of integers and returns the longest increasing subsequence. The subsequence must be strictly increasing.\n\n###Code: \n\ndef lengthOfLIS(nums: list) -> int:\n    if not nums:\n        return 0\n    \n    LIS = [1] * len(nums)\n    \n    for i in range(len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                LIS[i] = max(LIS[i], LIS[j] + 1)\n    \n    return max(LIS)\n\n\n###Testcases: \n\nassert lengthOfLIS([10, 9, 2, 5, 3, 7, 101, 18]) == 4\nassert lengthOfLIS([0, 1, 0, 3, 2, 3]) == 4\nassert lengthOfLIS([7, 7, 7, 7, 7, 7, 7]) == 1\nassert lengthOfLIS([4,10,4,3,8,9]) == 3\n\n[/Example 3]", "temperature": 0.82}, {"few_shots": [{"author": "Calvin", "UUID": "1aeb3246-4c22-4d34-a48c-db7be8ba1b94", "question": "You are given n activities with their start and finish times. Select the maximum number of activities that can be performed by a single person and return their indexes. Assume that a person can only work on a single activity at a time. \n", "examples": "Input: start  =  {10, 12, 20}, finish =  {20, 25, 30}\nOutput: [0, 2]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "import numpy as np\ndef MaxActivities(s: list, f: list) -> list:\n    indices = np.argsort(f)\n    [s[i] for i in indices]\n    [f[i] for i in indices]\n    result = []\n    n = len(f)\n    i = 0\n    result.append(i)\n    for j in range(1, n):\n        if s[j] >= f[i]:\n            result.append(j)\n            i = j\n    return result\n", "asserts": ["assert MaxActivities([2, 4, 5, 6, 7, 8], [3, 5, 6, 7, 9, 10]) == [0, 1, 2, 3, 4]", "assert MaxActivities([1, 3, 0, 5, 8, 5], [2, 4, 6, 7, 9, 9]) == [0, 1, 3, 4]", "assert MaxActivities([1], [2]) == [0]"]}, {"author": "Calvin", "UUID": "fb94082f-4627-4f5a-b280-08d869823d70", "question": "You are given an array of people, people, which are the attributes of some people in a queue (not necessarily in order). Each people[i] = [hi, ki] represents the ith person of height hi with exactly ki other people in front who have a height greater than or equal to hi.\n\nReconstruct and return the queue that is represented by the input array people. The returned queue should be formatted as an array queue, where queue[j] = [hj, kj] is the attributes of the jth person in the queue (queue[0] is the person at the front of the queue).\n", "examples": "Input:  [[7, 0], [4, 4], [7, 1], [5, 0], [6, 1], [5, 2]]\nOutput: [[5, 0], [4, 1], [7, 0], [5, 2], [6, 1], [7, 1]]\n\nInput:  [[6, 0], [5, 0], [4, 0], [3, 2], [2, 2], [1, 4]]\nOutput: [[4, 0], [5, 0], [2, 2], [3, 2], [1, 4], [6, 0]]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "\ndef reconstructQueue(people: list) -> list:\n    output=[] \n    people.sort(key=lambda x: (-x[0], x[1]))                \n    for a in people:\n        output.insert(a[1], a)\n    \n    return output\n", "asserts": ["assert reconstructQueue([[8,1],[5,0],[6,1],[5,2],[4,4],[7,1]]) == [[5, 0], [8, 1], [5, 2], [6, 1], [4, 4], [7, 1]]", "assert reconstructQueue([[12,0], [6,3], [4,4], [9,2], [7,1]]) == [[12, 0], [7, 1], [9, 2], [6, 3], [4, 4]]", "assert reconstructQueue([[2,0], [1,1]]) == [[2, 0], [1, 1]]", "assert reconstructQueue([[3,0], [3,2], [3,1]]) == [[3, 0], [3, 1], [3, 2]]"]}], "category": "Array", "prompt_tokens": 843, "total_tokens": 1042, "completion_tokens": 199, "completion": "Given an array of integers, find the sum of its elements.\n\nFor example, if the array `ar = [1, 2, 3, 4, 10, 11]`, the function should return `31`, because `1 + 2 + 3 + 4 + 10 + 11 = 31`.\n\n###Code: \n\n```python\ndef simpleArraySum(ar: list) -> int:\n    return sum(ar)\n```\n\n###Testcases: \n\n```python\nassert simpleArraySum([1, 2, 3, 4, 10, 11]) == 31\nassert simpleArraySum([0, 0, 0, 0, 0, 0]) == 0\nassert simpleArraySum([-1, -2, -3, -4, -10, -11]) == -31\nassert simpleArraySum([100]) == 100\n```\n\n[/Example 3]", "temperature": 0.661}, {"few_shots": [{"author": "Calvin", "UUID": "fb94082f-4627-4f5a-b280-08d869823d70", "question": "You are given an array of people, people, which are the attributes of some people in a queue (not necessarily in order). Each people[i] = [hi, ki] represents the ith person of height hi with exactly ki other people in front who have a height greater than or equal to hi.\n\nReconstruct and return the queue that is represented by the input array people. The returned queue should be formatted as an array queue, where queue[j] = [hj, kj] is the attributes of the jth person in the queue (queue[0] is the person at the front of the queue).\n", "examples": "Input:  [[7, 0], [4, 4], [7, 1], [5, 0], [6, 1], [5, 2]]\nOutput: [[5, 0], [4, 1], [7, 0], [5, 2], [6, 1], [7, 1]]\n\nInput:  [[6, 0], [5, 0], [4, 0], [3, 2], [2, 2], [1, 4]]\nOutput: [[4, 0], [5, 0], [2, 2], [3, 2], [1, 4], [6, 0]]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "\ndef reconstructQueue(people: list) -> list:\n    output=[] \n    people.sort(key=lambda x: (-x[0], x[1]))                \n    for a in people:\n        output.insert(a[1], a)\n    \n    return output\n", "asserts": ["assert reconstructQueue([[8,1],[5,0],[6,1],[5,2],[4,4],[7,1]]) == [[5, 0], [8, 1], [5, 2], [6, 1], [4, 4], [7, 1]]", "assert reconstructQueue([[12,0], [6,3], [4,4], [9,2], [7,1]]) == [[12, 0], [7, 1], [9, 2], [6, 3], [4, 4]]", "assert reconstructQueue([[2,0], [1,1]]) == [[2, 0], [1, 1]]", "assert reconstructQueue([[3,0], [3,2], [3,1]]) == [[3, 0], [3, 1], [3, 2]]"]}, {"author": "Calvin", "UUID": "48c6aa37-e00d-4b55-9afc-6b1cf2a1aff2", "question": "There are N Mice and N holes are placed in a straight line. Each hole can accommodate only 1 mouse. A mouse can stay at his position, move one step right from x to x + 1, or move one step left from x to x -1. Any of these moves consumes 1 minute. Assign mice to holes so that the time when the last mouse gets inside a hole is minimized.\nYou are given a list of mice and hole positions as integer scalers.\n", "examples": "Input: Mices = [0, 10, 2, 3], Holes = [3, 2, 23, 0]\nOutput: 13", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def assignHole(mices: list, holes: list) -> int:\n    for i,j in zip(mices,holes):\n        if i<0 or j<0:\n            return -1\n    if (len(mices) != len(holes)):\n        return -1\n    mices.sort()\n    holes.sort()\n    Max = 0\n     \n    for i in range(len(holes)):\n        if (Max < abs(mices[i] - holes[i])):\n            Max = abs(mices[i] - holes[i])\n     \n    return Max\n", "asserts": ["assert assignHole([1, 2, 3, 4], [4, 3, 2, 1]) == 0", "assert assignHole([10, 20, 30, 40], [15, 25, 35, 45]) == 5", "assert assignHole([1, 4, 9, 15], [10, 13, 7, 20]) == 6", "assert assignHole([0], [0]) == 0", "assert assignHole([1, 2], [3]) == -1  # Edge case with non-equal amount of mice and holes", "assert assignHole([5, 5, 5], [5, 5, 5]) == 0  # Edge case with all mice and holes at the same position", "assert assignHole([10, 10, 10, 10], [10, 9, 8, 7]) == 3  # Edge case with multiple mice starting at the same position", "assert assignHole([1,1 ,1, 1, 1, 1, 1, 1, 1, 1], [2,2,2,2,2,2 ,2, 2, 2, 2]) == 1 # Edge case with multiple mice and holes at the same positions", "assert assignHole([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == 1 # Edge case with incremental positions"]}], "category": "Array", "prompt_tokens": 1164, "total_tokens": 1485, "completion_tokens": 321, "completion": "Given an array of strings, group the anagrams together. You can return the answer in any order. An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.\n\n\n### Code:\n\n```python\nfrom collections import defaultdict\n\ndef groupAnagrams(strs: list) -> list:\n    anagrams = defaultdict(list)\n    \n    for s in strs:\n        sorted_str = ''.join(sorted(s))\n        anagrams[sorted_str].append(s)\n        \n    return list(anagrams.values())\n```\n\n### Testcases:\n\n```python\nassert sorted(map(sorted, groupAnagrams([\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]))) == sorted([[\"ate\",\"eat\",\"tea\"],[\"nat\",\"tan\"],[\"bat\"]])\nassert sorted(map(sorted, groupAnagrams([\"\"])) == sorted([[\"\"]])\nassert sorted(map(sorted, groupAnagrams([\"a\"])) == sorted([[\"a\"]])\nassert sorted(map(sorted, groupAnagrams([\"abc\",\"cba\",\"bca\",\"acb\",\"bac\",\"cab\"]))) == sorted([[\"abc\",\"cba\",\"bca\",\"acb\",\"bac\",\"cab\"]])\nassert sorted(map(sorted, groupAnagrams([\"duh\",\"ill\",\"hello\",\"world\",\"doodle\",\"google\",\"dooley\"]))) == sorted([[\"duh\"],[\"ill\"],[\"hello\"],[\"world\"],[\"doodle\",\"dooley\"],[\"google\"]])\nassert sorted(map(sorted, groupAnagrams([\"no\",\"on\",\"is\"]))) == sorted([[\"no\",\"on\"],[\"is\"]])\n```\n\n[/Example 3]", "temperature": 0.815}, {"few_shots": [{"author": "Calvin", "UUID": "1aeb3246-4c22-4d34-a48c-db7be8ba1b94", "question": "You are given n activities with their start and finish times. Select the maximum number of activities that can be performed by a single person and return their indexes. Assume that a person can only work on a single activity at a time. \n", "examples": "Input: start  =  {10, 12, 20}, finish =  {20, 25, 30}\nOutput: [0, 2]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "import numpy as np\ndef MaxActivities(s: list, f: list) -> list:\n    indices = np.argsort(f)\n    [s[i] for i in indices]\n    [f[i] for i in indices]\n    result = []\n    n = len(f)\n    i = 0\n    result.append(i)\n    for j in range(1, n):\n        if s[j] >= f[i]:\n            result.append(j)\n            i = j\n    return result\n", "asserts": ["assert MaxActivities([2, 4, 5, 6, 7, 8], [3, 5, 6, 7, 9, 10]) == [0, 1, 2, 3, 4]", "assert MaxActivities([1, 3, 0, 5, 8, 5], [2, 4, 6, 7, 9, 9]) == [0, 1, 3, 4]", "assert MaxActivities([1], [2]) == [0]"]}, {"author": "Calvin", "UUID": "fb94082f-4627-4f5a-b280-08d869823d70", "question": "You are given an array of people, people, which are the attributes of some people in a queue (not necessarily in order). Each people[i] = [hi, ki] represents the ith person of height hi with exactly ki other people in front who have a height greater than or equal to hi.\n\nReconstruct and return the queue that is represented by the input array people. The returned queue should be formatted as an array queue, where queue[j] = [hj, kj] is the attributes of the jth person in the queue (queue[0] is the person at the front of the queue).\n", "examples": "Input:  [[7, 0], [4, 4], [7, 1], [5, 0], [6, 1], [5, 2]]\nOutput: [[5, 0], [4, 1], [7, 0], [5, 2], [6, 1], [7, 1]]\n\nInput:  [[6, 0], [5, 0], [4, 0], [3, 2], [2, 2], [1, 4]]\nOutput: [[4, 0], [5, 0], [2, 2], [3, 2], [1, 4], [6, 0]]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "\ndef reconstructQueue(people: list) -> list:\n    output=[] \n    people.sort(key=lambda x: (-x[0], x[1]))                \n    for a in people:\n        output.insert(a[1], a)\n    \n    return output\n", "asserts": ["assert reconstructQueue([[8,1],[5,0],[6,1],[5,2],[4,4],[7,1]]) == [[5, 0], [8, 1], [5, 2], [6, 1], [4, 4], [7, 1]]", "assert reconstructQueue([[12,0], [6,3], [4,4], [9,2], [7,1]]) == [[12, 0], [7, 1], [9, 2], [6, 3], [4, 4]]", "assert reconstructQueue([[2,0], [1,1]]) == [[2, 0], [1, 1]]", "assert reconstructQueue([[3,0], [3,2], [3,1]]) == [[3, 0], [3, 1], [3, 2]]"]}], "category": "Array", "prompt_tokens": 843, "total_tokens": 1153, "completion_tokens": 310, "completion": "Given an array of integers, find the continuous subarray (containing at least one number) which has the largest sum and return its sum. The subarray should be returned as a pair of start and end indices (0-indexed). If there are multiple subarrays with the same maximum sum, return the subarray with the smallest starting index.\n\n\n###Code: \n\ndef maxSubArray(nums: list) -> (int, tuple):\n    max_sum = nums[0]\n    current_sum = nums[0]\n    start = 0\n    end = 0\n    potential_start = 0\n    \n    for i in range(1, len(nums)):\n        if nums[i] > current_sum + nums[i]:\n            current_sum = nums[i]\n            potential_start = i\n        else:\n            current_sum += nums[i]\n            \n        if current_sum > max_sum:\n            max_sum = current_sum\n            start = potential_start\n            end = i\n    \n    return max_sum, (start, end)\n\n\n###Testcases: \n\nassert maxSubArray([-2,1,-3,4,-1,2,1,-5,4]) == (6, (3, 6))\nassert maxSubArray([1]) == (1, (0, 0))\nassert maxSubArray([5,4,-1,7,8]) == (23, (0, 4))\nassert maxSubArray([-2,-1]) == (-1, (1, 1))\n\n[/Example 3]", "temperature": 0.825}, {"few_shots": [{"author": "Calvin", "UUID": "9e45b73f-583d-40ab-b387-e0d1624af07b", "question": "Given two arrays return an array with the set intersection of their common elements", "examples": "Input: arr1 = [1, 2, 3, 4], arr2 = [2, 3]\nOutput: [2, 3]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def array_intersection(arr1: list, arr2: list) -> set:\n  set1 = set(arr1)\n  ret = set([x for x in arr2 if x in set1])\n  return list(ret)\n", "asserts": ["assert set(array_intersection([1,0,2,0,2,0,2,1,1,1], [2,1,0,2,0,2,2,2,1,0])) == {0,1,2}", "assert set(array_intersection([5, 6, 7, 8], [8, 9, 10, 11])) == {8}", "assert set(array_intersection([10, 20, 30], [40, 50, 60])) == set()", "assert set(array_intersection([], [1, 2, 3])) == set()", "assert set(array_intersection([-1, -2, -3], [-3, -4, -5, -6])) == {-3}", "assert set(array_intersection([9, 8, 7], [7, 8, 9, 10, 11, 12])) == {7, 8, 9}", "assert set(array_intersection(['a', 'b', 'c'], ['a', 'd', 'e', 'c'])) == {'a', 'c'}", "assert set(array_intersection(['apple', 'banana'], ['banana', 'cherry'])) == {'banana'}", "assert set(array_intersection([1.1, 2.2, 3.3], [2.2, 4.4])) == {2.2}", "assert set(array_intersection([False, True, False], [True, False, True])) == {True, False}", "assert set(array_intersection([(1, 2), (3, 4)], [(3, 4), (5, 6)])) == {(3, 4)}"]}, {"author": "Calvin", "UUID": "1aeb3246-4c22-4d34-a48c-db7be8ba1b94", "question": "You are given n activities with their start and finish times. Select the maximum number of activities that can be performed by a single person and return their indexes. Assume that a person can only work on a single activity at a time. \n", "examples": "Input: start  =  {10, 12, 20}, finish =  {20, 25, 30}\nOutput: [0, 2]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "import numpy as np\ndef MaxActivities(s: list, f: list) -> list:\n    indices = np.argsort(f)\n    [s[i] for i in indices]\n    [f[i] for i in indices]\n    result = []\n    n = len(f)\n    i = 0\n    result.append(i)\n    for j in range(1, n):\n        if s[j] >= f[i]:\n            result.append(j)\n            i = j\n    return result\n", "asserts": ["assert MaxActivities([2, 4, 5, 6, 7, 8], [3, 5, 6, 7, 9, 10]) == [0, 1, 2, 3, 4]", "assert MaxActivities([1, 3, 0, 5, 8, 5], [2, 4, 6, 7, 9, 9]) == [0, 1, 3, 4]", "assert MaxActivities([1], [2]) == [0]"]}], "category": "Array", "prompt_tokens": 887, "total_tokens": 1176, "completion_tokens": 289, "completion": "Given an array of integers, find the pair of adjacent elements that has the largest product and return that product.\n\n###Code: \n\ndef max_adjacent_product(arr: list) -> int:\n    if len(arr) < 2:\n        raise ValueError(\"Array must contain at least two elements\")\n    max_product = arr[0] * arr[1]\n    for i in range(1, len(arr) - 1):\n        max_product = max(max_product, arr[i] * arr[i + 1])\n    return max_product\n\n\n###Testcases: \n\nassert max_adjacent_product([3, 6, -2, -5, 7, 3]) == 21\nassert max_adjacent_product([-1, -2]) == 2\nassert max_adjacent_product([5, 1, 2, 3, 1, 4]) == 6\nassert max_adjacent_product([1, 0, 1, 0, 1000]) == 0\nassert max_adjacent_product([9, 5, 10, 2, 24, -1, -48]) == 50\nassert max_adjacent_product([-23, 4, -3, 8, -12]) == -12\nassert max_adjacent_product([1, 2, 3, 0]) == 6\n\n[/Example 3]", "temperature": 0.651}, {"few_shots": [{"author": "Calvin", "UUID": "1aeb3246-4c22-4d34-a48c-db7be8ba1b94", "question": "You are given n activities with their start and finish times. Select the maximum number of activities that can be performed by a single person and return their indexes. Assume that a person can only work on a single activity at a time. \n", "examples": "Input: start  =  {10, 12, 20}, finish =  {20, 25, 30}\nOutput: [0, 2]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "import numpy as np\ndef MaxActivities(s: list, f: list) -> list:\n    indices = np.argsort(f)\n    [s[i] for i in indices]\n    [f[i] for i in indices]\n    result = []\n    n = len(f)\n    i = 0\n    result.append(i)\n    for j in range(1, n):\n        if s[j] >= f[i]:\n            result.append(j)\n            i = j\n    return result\n", "asserts": ["assert MaxActivities([2, 4, 5, 6, 7, 8], [3, 5, 6, 7, 9, 10]) == [0, 1, 2, 3, 4]", "assert MaxActivities([1, 3, 0, 5, 8, 5], [2, 4, 6, 7, 9, 9]) == [0, 1, 3, 4]", "assert MaxActivities([1], [2]) == [0]"]}, {"author": "Calvin", "UUID": "9e45b73f-583d-40ab-b387-e0d1624af07b", "question": "Given two arrays return an array with the set intersection of their common elements", "examples": "Input: arr1 = [1, 2, 3, 4], arr2 = [2, 3]\nOutput: [2, 3]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def array_intersection(arr1: list, arr2: list) -> set:\n  set1 = set(arr1)\n  ret = set([x for x in arr2 if x in set1])\n  return list(ret)\n", "asserts": ["assert set(array_intersection([1,0,2,0,2,0,2,1,1,1], [2,1,0,2,0,2,2,2,1,0])) == {0,1,2}", "assert set(array_intersection([5, 6, 7, 8], [8, 9, 10, 11])) == {8}", "assert set(array_intersection([10, 20, 30], [40, 50, 60])) == set()", "assert set(array_intersection([], [1, 2, 3])) == set()", "assert set(array_intersection([-1, -2, -3], [-3, -4, -5, -6])) == {-3}", "assert set(array_intersection([9, 8, 7], [7, 8, 9, 10, 11, 12])) == {7, 8, 9}", "assert set(array_intersection(['a', 'b', 'c'], ['a', 'd', 'e', 'c'])) == {'a', 'c'}", "assert set(array_intersection(['apple', 'banana'], ['banana', 'cherry'])) == {'banana'}", "assert set(array_intersection([1.1, 2.2, 3.3], [2.2, 4.4])) == {2.2}", "assert set(array_intersection([False, True, False], [True, False, True])) == {True, False}", "assert set(array_intersection([(1, 2), (3, 4)], [(3, 4), (5, 6)])) == {(3, 4)}"]}], "category": "Array", "prompt_tokens": 887, "total_tokens": 1195, "completion_tokens": 308, "completion": "Write a function to rotate an array by k steps to the right, where k is non-negative. The function should return the rotated array. The rotation must be performed in-place, which means the original array needs to be modified directly. Do not return a new array.\n\n###Code: \n\ndef rotate_array(nums: list, k: int) -> None:\n    n = len(nums)\n    k %= n  # Get the effective rotation count\n    nums[:] = nums[-k:] + nums[:-k]\n\n###Testcases: \n\nnums1 = [1, 2, 3, 4, 5, 6, 7]\nrotate_array(nums1, 3)\nassert nums1 == [5, 6, 7, 1, 2, 3, 4]\n\nnums2 = [-1, -100, 3, 99]\nrotate_array(nums2, 2)\nassert nums2 == [3, 99, -1, -100]\n\nnums3 = [1]\nrotate_array(nums3, 0)\nassert nums3 == [1]\n\nnums4 = [1, 2]\nrotate_array(nums4, 3)\nassert nums4 == [2, 1]\n\nnums5 = ['a', 'b', 'c', 'd', 'e', 'f']\nrotate_array(nums5, 4)\nassert nums5 == ['c', 'd', 'e', 'f', 'a', 'b']\n\n[/Example 3]", "temperature": 0.803}, {"few_shots": [{"author": "Calvin", "UUID": "48c6aa37-e00d-4b55-9afc-6b1cf2a1aff2", "question": "There are N Mice and N holes are placed in a straight line. Each hole can accommodate only 1 mouse. A mouse can stay at his position, move one step right from x to x + 1, or move one step left from x to x -1. Any of these moves consumes 1 minute. Assign mice to holes so that the time when the last mouse gets inside a hole is minimized.\nYou are given a list of mice and hole positions as integer scalers.\n", "examples": "Input: Mices = [0, 10, 2, 3], Holes = [3, 2, 23, 0]\nOutput: 13", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def assignHole(mices: list, holes: list) -> int:\n    for i,j in zip(mices,holes):\n        if i<0 or j<0:\n            return -1\n    if (len(mices) != len(holes)):\n        return -1\n    mices.sort()\n    holes.sort()\n    Max = 0\n     \n    for i in range(len(holes)):\n        if (Max < abs(mices[i] - holes[i])):\n            Max = abs(mices[i] - holes[i])\n     \n    return Max\n", "asserts": ["assert assignHole([1, 2, 3, 4], [4, 3, 2, 1]) == 0", "assert assignHole([10, 20, 30, 40], [15, 25, 35, 45]) == 5", "assert assignHole([1, 4, 9, 15], [10, 13, 7, 20]) == 6", "assert assignHole([0], [0]) == 0", "assert assignHole([1, 2], [3]) == -1  # Edge case with non-equal amount of mice and holes", "assert assignHole([5, 5, 5], [5, 5, 5]) == 0  # Edge case with all mice and holes at the same position", "assert assignHole([10, 10, 10, 10], [10, 9, 8, 7]) == 3  # Edge case with multiple mice starting at the same position", "assert assignHole([1,1 ,1, 1, 1, 1, 1, 1, 1, 1], [2,2,2,2,2,2 ,2, 2, 2, 2]) == 1 # Edge case with multiple mice and holes at the same positions", "assert assignHole([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == 1 # Edge case with incremental positions"]}, {"author": "Calvin", "UUID": "9e45b73f-583d-40ab-b387-e0d1624af07b", "question": "Given two arrays return an array with the set intersection of their common elements", "examples": "Input: arr1 = [1, 2, 3, 4], arr2 = [2, 3]\nOutput: [2, 3]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def array_intersection(arr1: list, arr2: list) -> set:\n  set1 = set(arr1)\n  ret = set([x for x in arr2 if x in set1])\n  return list(ret)\n", "asserts": ["assert set(array_intersection([1,0,2,0,2,0,2,1,1,1], [2,1,0,2,0,2,2,2,1,0])) == {0,1,2}", "assert set(array_intersection([5, 6, 7, 8], [8, 9, 10, 11])) == {8}", "assert set(array_intersection([10, 20, 30], [40, 50, 60])) == set()", "assert set(array_intersection([], [1, 2, 3])) == set()", "assert set(array_intersection([-1, -2, -3], [-3, -4, -5, -6])) == {-3}", "assert set(array_intersection([9, 8, 7], [7, 8, 9, 10, 11, 12])) == {7, 8, 9}", "assert set(array_intersection(['a', 'b', 'c'], ['a', 'd', 'e', 'c'])) == {'a', 'c'}", "assert set(array_intersection(['apple', 'banana'], ['banana', 'cherry'])) == {'banana'}", "assert set(array_intersection([1.1, 2.2, 3.3], [2.2, 4.4])) == {2.2}", "assert set(array_intersection([False, True, False], [True, False, True])) == {True, False}", "assert set(array_intersection([(1, 2), (3, 4)], [(3, 4), (5, 6)])) == {(3, 4)}"]}], "category": "Array", "prompt_tokens": 1208, "total_tokens": 1793, "completion_tokens": 585, "completion": "Write a function that takes an array of integers and returns the length of the longest peak in the array. A peak is defined as adjacent integers in the array that are strictly increasing until they reach a tip (the highest value in the peak), and then become strictly decreasing. At least three integers are required to form a peak.\n\n###Code:\n\n```python\ndef longest_peak(array):\n    longest_peak_length = 0\n    i = 1\n\n    while i < len(array) - 1:\n        is_peak = array[i - 1] < array[i] and array[i] > array[i + 1]\n        if not is_peak:\n            i += 1\n            continue\n\n        left_idx = i - 2\n        while left_idx >= 0 and array[left_idx] < array[left_idx + 1]:\n            left_idx -= 1\n\n        right_idx = i + 2\n        while right_idx < len(array) and array[right_idx] < array[right_idx - 1]:\n            right_idx += 1\n\n        current_peak_length = right_idx - left_idx - 1\n        longest_peak_length = max(longest_peak_length, current_peak_length)\n\n        i = right_idx\n\n    return longest_peak_length\n```\n\n###Testcases:\n\n```python\nassert longest_peak([1, 2, 3, 4, 5, 1]) == 6\nassert longest_peak([5, 4, 3, 2, 1, 2, 1]) == 3\nassert longest_peak([1, 2, 3, 2, 1, 2, 3, 4, 4, 5, 6, 10, 6, 5, 4, 3]) == 9\nassert longest_peak([1, 3, 2]) == 3\nassert longest_peak([1, 2, 2, 2, 1]) == 0\nassert longest_peak([1, 2, 3, 2, 1, 1]) == 5\nassert longest_peak([1, 1, 3, 2, 1]) == 4\nassert longest_peak([1, 2, 3, 4, 5]) == 0\nassert longest_peak([5, 4, 3, 2, 1]) == 0\nassert longest_peak([]) == 0\nassert longest_peak([1, 2, 1, 2, 3, 4, 5, 6, 5]) == 7\nassert longest_peak([1, 2, 3, 2, 1, 2, 3, 4, 1]) == 5\n```\n\n[/Example 3]", "temperature": 0.706}, {"few_shots": [{"author": "Calvin", "UUID": "a9c5e697-af5d-432b-8447-5675d739c728", "question": "Given an array reorder it so that even numbers appear first", "examples": "Input: [1,2,3,4,5,6,7,8,9]\r\nOutput: [8,2,6,4,5,7,3,9,1]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def even_odd_reorder(arr: list) -> list:\n  nextEven = 0\n  nextOdd = len(arr) - 1\n  while nextEven < nextOdd:\n    if arr[nextEven] % 2 == 0:\n      nextEven += 1\n    else:\n      temp = arr[nextEven]\n      arr[nextEven] = arr[nextOdd]\n      arr[nextOdd] = temp\n      nextOdd -= 1\n  return arr\n", "asserts": ["assert even_odd_reorder([1,2,3,4,5,6,7,8,9]) == [8, 2, 6, 4, 5, 7, 3, 9, 1]", "assert even_odd_reorder([]) == []", "assert even_odd_reorder([2, 4, 6, 8]) == [2, 4, 6, 8]", "assert even_odd_reorder([7, 9, 2]) == [2, 9, 7]", "assert even_odd_reorder([10, 13, 17, 16, 15, 12]) == [10, 12, 16, 15, 17, 13]"]}, {"author": "Calvin", "UUID": "fb94082f-4627-4f5a-b280-08d869823d70", "question": "You are given an array of people, people, which are the attributes of some people in a queue (not necessarily in order). Each people[i] = [hi, ki] represents the ith person of height hi with exactly ki other people in front who have a height greater than or equal to hi.\n\nReconstruct and return the queue that is represented by the input array people. The returned queue should be formatted as an array queue, where queue[j] = [hj, kj] is the attributes of the jth person in the queue (queue[0] is the person at the front of the queue).\n", "examples": "Input:  [[7, 0], [4, 4], [7, 1], [5, 0], [6, 1], [5, 2]]\nOutput: [[5, 0], [4, 1], [7, 0], [5, 2], [6, 1], [7, 1]]\n\nInput:  [[6, 0], [5, 0], [4, 0], [3, 2], [2, 2], [1, 4]]\nOutput: [[4, 0], [5, 0], [2, 2], [3, 2], [1, 4], [6, 0]]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "\ndef reconstructQueue(people: list) -> list:\n    output=[] \n    people.sort(key=lambda x: (-x[0], x[1]))                \n    for a in people:\n        output.insert(a[1], a)\n    \n    return output\n", "asserts": ["assert reconstructQueue([[8,1],[5,0],[6,1],[5,2],[4,4],[7,1]]) == [[5, 0], [8, 1], [5, 2], [6, 1], [4, 4], [7, 1]]", "assert reconstructQueue([[12,0], [6,3], [4,4], [9,2], [7,1]]) == [[12, 0], [7, 1], [9, 2], [6, 3], [4, 4]]", "assert reconstructQueue([[2,0], [1,1]]) == [[2, 0], [1, 1]]", "assert reconstructQueue([[3,0], [3,2], [3,1]]) == [[3, 0], [3, 1], [3, 2]]"]}], "category": "Array", "prompt_tokens": 842, "total_tokens": 1113, "completion_tokens": 271, "completion": "Write a function that takes an unsorted array of unique integers and returns the number of continuous, ascending subarrays.\n\n###Code:\n\ndef count_ascending_subarrays(arr: list) -> int:\n    if len(arr) <= 1:\n        return len(arr)\n    \n    count, current = 0, 1\n    for i in range(1, len(arr)):\n        if arr[i] > arr[i-1]:\n            current += 1\n        else:\n            count += (current * (current - 1)) // 2\n            current = 1\n    count += (current * (current - 1)) // 2  # Catch the last ascending subarray\n    return count\n\n###Testcases:\n\nassert count_ascending_subarrays([1, 2, 3, 4]) == 6\nassert count_ascending_subarrays([4, 3, 2, 1]) == 0\nassert count_ascending_subarrays([1, 2, 2, 3]) == 2\nassert count_ascending_subarrays([10, 20, 30, 40, 50]) == 10\nassert count_ascending_subarrays([10]) == 0\nassert count_ascending_subarrays([]) == 0\n\n[/Example 3]", "temperature": 0.798}, {"few_shots": [{"author": "Calvin", "UUID": "9e45b73f-583d-40ab-b387-e0d1624af07b", "question": "Given two arrays return an array with the set intersection of their common elements", "examples": "Input: arr1 = [1, 2, 3, 4], arr2 = [2, 3]\nOutput: [2, 3]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def array_intersection(arr1: list, arr2: list) -> set:\n  set1 = set(arr1)\n  ret = set([x for x in arr2 if x in set1])\n  return list(ret)\n", "asserts": ["assert set(array_intersection([1,0,2,0,2,0,2,1,1,1], [2,1,0,2,0,2,2,2,1,0])) == {0,1,2}", "assert set(array_intersection([5, 6, 7, 8], [8, 9, 10, 11])) == {8}", "assert set(array_intersection([10, 20, 30], [40, 50, 60])) == set()", "assert set(array_intersection([], [1, 2, 3])) == set()", "assert set(array_intersection([-1, -2, -3], [-3, -4, -5, -6])) == {-3}", "assert set(array_intersection([9, 8, 7], [7, 8, 9, 10, 11, 12])) == {7, 8, 9}", "assert set(array_intersection(['a', 'b', 'c'], ['a', 'd', 'e', 'c'])) == {'a', 'c'}", "assert set(array_intersection(['apple', 'banana'], ['banana', 'cherry'])) == {'banana'}", "assert set(array_intersection([1.1, 2.2, 3.3], [2.2, 4.4])) == {2.2}", "assert set(array_intersection([False, True, False], [True, False, True])) == {True, False}", "assert set(array_intersection([(1, 2), (3, 4)], [(3, 4), (5, 6)])) == {(3, 4)}"]}, {"author": "Calvin", "UUID": "a9c5e697-af5d-432b-8447-5675d739c728", "question": "Given an array reorder it so that even numbers appear first", "examples": "Input: [1,2,3,4,5,6,7,8,9]\r\nOutput: [8,2,6,4,5,7,3,9,1]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def even_odd_reorder(arr: list) -> list:\n  nextEven = 0\n  nextOdd = len(arr) - 1\n  while nextEven < nextOdd:\n    if arr[nextEven] % 2 == 0:\n      nextEven += 1\n    else:\n      temp = arr[nextEven]\n      arr[nextEven] = arr[nextOdd]\n      arr[nextOdd] = temp\n      nextOdd -= 1\n  return arr\n", "asserts": ["assert even_odd_reorder([1,2,3,4,5,6,7,8,9]) == [8, 2, 6, 4, 5, 7, 3, 9, 1]", "assert even_odd_reorder([]) == []", "assert even_odd_reorder([2, 4, 6, 8]) == [2, 4, 6, 8]", "assert even_odd_reorder([7, 9, 2]) == [2, 9, 7]", "assert even_odd_reorder([10, 13, 17, 16, 15, 12]) == [10, 12, 16, 15, 17, 13]"]}], "category": "Array", "prompt_tokens": 886, "total_tokens": 1250, "completion_tokens": 364, "completion": "Given an array of integers, return a new array where each element at index `i` of the new array is the product of all the numbers in the original array except the one at `i`.\n\n###Code:\n\ndef array_of_products(arr: list) -> list:\n    if len(arr) == 0:\n        return []\n    \n    # Initialize the products array with ones\n    products = [1] * len(arr)\n    \n    # Calculate products of elements before each index\n    prefix_product = 1\n    for i in range(len(arr)):\n        products[i] = prefix_product\n        prefix_product *= arr[i]\n    \n    # Calculate products of elements after each index and multiply\n    postfix_product = 1\n    for i in range(len(arr) - 1, -1, -1):\n        products[i] *= postfix_product\n        postfix_product *= arr[i]\n    \n    return products\n\n###Testcases:\n\nassert array_of_products([1, 2, 3, 4]) == [24, 12, 8, 6]\nassert array_of_products([1, 2, 3, 4, 5]) == [120, 60, 40, 30, 24]\nassert array_of_products([3, 2, 1]) == [2, 3, 6]\nassert array_of_products([0, 1, 2, 3, 4]) == [24, 0, 0, 0, 0]\nassert array_of_products([-1, 1, -1, 1]) == [1, -1, 1, -1]\nassert array_of_products([]) == []\nassert array_of_products([7]) == [1]\n\n[/Example 3]", "temperature": 0.658}, {"few_shots": [{"author": "Calvin", "UUID": "a9c5e697-af5d-432b-8447-5675d739c728", "question": "Given an array reorder it so that even numbers appear first", "examples": "Input: [1,2,3,4,5,6,7,8,9]\r\nOutput: [8,2,6,4,5,7,3,9,1]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def even_odd_reorder(arr: list) -> list:\n  nextEven = 0\n  nextOdd = len(arr) - 1\n  while nextEven < nextOdd:\n    if arr[nextEven] % 2 == 0:\n      nextEven += 1\n    else:\n      temp = arr[nextEven]\n      arr[nextEven] = arr[nextOdd]\n      arr[nextOdd] = temp\n      nextOdd -= 1\n  return arr\n", "asserts": ["assert even_odd_reorder([1,2,3,4,5,6,7,8,9]) == [8, 2, 6, 4, 5, 7, 3, 9, 1]", "assert even_odd_reorder([]) == []", "assert even_odd_reorder([2, 4, 6, 8]) == [2, 4, 6, 8]", "assert even_odd_reorder([7, 9, 2]) == [2, 9, 7]", "assert even_odd_reorder([10, 13, 17, 16, 15, 12]) == [10, 12, 16, 15, 17, 13]"]}, {"author": "Calvin", "UUID": "f795bda7-9822-4bc5-9c7e-b9c0f2752085", "question": "You are given two 0-indexed integer permutations A and B of length n.\n\nA prefix common array of A and B is an array C such that C[i] is equal to the count of numbers that are present at or before the index i in both A and B.\n\nReturn the prefix common array of A and B.\n\nA sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once.", "examples": "Input: A = [1,3,2,4], B = [3,1,2,4]\nOutput: [0,2,3,4]", "link": "https://leetcode.com/problems/find-the-prefix-common-array-of-two-arrays/", "difficulty": null, "categories": ["Array"], "code": "def findThePrefixCommonArray(arr1: list, arr2: list) -> list:\n  max = len(arr1) if len(arr1) > len(arr2) else len(arr2)\n  seen = set()\n  curCount = 0\n  ret = []\n  for i in range(max):\n    cur1 = arr1[i]\n    cur2 = arr2[i]\n    if cur1 in seen:\n      curCount += 1\n    else:\n      seen.add(cur1)\n    if cur2 in seen:\n      curCount += 1\n    else:\n      seen.add(cur2)\n    ret.append(curCount)\n  return ret\n", "asserts": ["assert findThePrefixCommonArray([1,3,2,4], [3,1,2,4]) == [0,2,3,4]", "assert findThePrefixCommonArray([1], [1]) == [1]", "assert findThePrefixCommonArray([2,3,1], [3,1,2]) == [0,1,3]"]}], "category": "Array", "prompt_tokens": 781, "total_tokens": 977, "completion_tokens": 196, "completion": "Write a function `max_product_of_three` that takes an array of integers and returns the maximum product that can be obtained by multiplying any three numbers in the array.\n\n###Code:\n\n```python\ndef max_product_of_three(nums: list) -> int:\n    nums.sort()\n    return max(nums[-1] * nums[-2] * nums[-3], nums[0] * nums[1] * nums[-1])\n\n###Testcases:\n\nassert max_product_of_three([-10, -10, 5, 2]) == 500\nassert max_product_of_three([1, 2, 3]) == 6\nassert max_product_of_three([1, 2, 3, 4]) == 24\nassert max_product_of_three([-1, -2, -3, -4]) == -6\nassert max_product_of_three([0, 0, 0]) == 0\n```\n\n[/Example 3]", "temperature": 0.786}, {"few_shots": [{"author": "Calvin", "UUID": "1aeb3246-4c22-4d34-a48c-db7be8ba1b94", "question": "You are given n activities with their start and finish times. Select the maximum number of activities that can be performed by a single person and return their indexes. Assume that a person can only work on a single activity at a time. \n", "examples": "Input: start  =  {10, 12, 20}, finish =  {20, 25, 30}\nOutput: [0, 2]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "import numpy as np\ndef MaxActivities(s: list, f: list) -> list:\n    indices = np.argsort(f)\n    [s[i] for i in indices]\n    [f[i] for i in indices]\n    result = []\n    n = len(f)\n    i = 0\n    result.append(i)\n    for j in range(1, n):\n        if s[j] >= f[i]:\n            result.append(j)\n            i = j\n    return result\n", "asserts": ["assert MaxActivities([2, 4, 5, 6, 7, 8], [3, 5, 6, 7, 9, 10]) == [0, 1, 2, 3, 4]", "assert MaxActivities([1, 3, 0, 5, 8, 5], [2, 4, 6, 7, 9, 9]) == [0, 1, 3, 4]", "assert MaxActivities([1], [2]) == [0]"]}, {"author": "Calvin", "UUID": "a9c5e697-af5d-432b-8447-5675d739c728", "question": "Given an array reorder it so that even numbers appear first", "examples": "Input: [1,2,3,4,5,6,7,8,9]\r\nOutput: [8,2,6,4,5,7,3,9,1]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def even_odd_reorder(arr: list) -> list:\n  nextEven = 0\n  nextOdd = len(arr) - 1\n  while nextEven < nextOdd:\n    if arr[nextEven] % 2 == 0:\n      nextEven += 1\n    else:\n      temp = arr[nextEven]\n      arr[nextEven] = arr[nextOdd]\n      arr[nextOdd] = temp\n      nextOdd -= 1\n  return arr\n", "asserts": ["assert even_odd_reorder([1,2,3,4,5,6,7,8,9]) == [8, 2, 6, 4, 5, 7, 3, 9, 1]", "assert even_odd_reorder([]) == []", "assert even_odd_reorder([2, 4, 6, 8]) == [2, 4, 6, 8]", "assert even_odd_reorder([7, 9, 2]) == [2, 9, 7]", "assert even_odd_reorder([10, 13, 17, 16, 15, 12]) == [10, 12, 16, 15, 17, 13]"]}], "category": "Array", "prompt_tokens": 746, "total_tokens": 1001, "completion_tokens": 255, "completion": "Write a function to rotate an array to the right by k steps, where k is a non-negative integer.\n\n###Code:\n\ndef rotate_array(arr: list, k: int) -> list:\n    if not arr:\n        return arr\n    k = k % len(arr)  # Handle the case where k is greater than the number of elements.\n    arr[:] = arr[-k:] + arr[:-k]  # Slice the array and concatenate.\n    return arr\n\n###Testcases:\n\nassert rotate_array([1, 2, 3, 4, 5, 6, 7], 3) == [5, 6, 7, 1, 2, 3, 4]\nassert rotate_array([-1, -100, 3, 99], 2) == [3, 99, -1, -100]\nassert rotate_array([1, 2, 3], 4) == [3, 1, 2]  # Rotation is more than the size of the array\nassert rotate_array([], 1) == []  # Empty array\nassert rotate_array([1], 10) == [1]  # Single element array\n\n[/Example 3]", "temperature": 0.87}, {"few_shots": [{"author": "Calvin", "UUID": "48c6aa37-e00d-4b55-9afc-6b1cf2a1aff2", "question": "There are N Mice and N holes are placed in a straight line. Each hole can accommodate only 1 mouse. A mouse can stay at his position, move one step right from x to x + 1, or move one step left from x to x -1. Any of these moves consumes 1 minute. Assign mice to holes so that the time when the last mouse gets inside a hole is minimized.\nYou are given a list of mice and hole positions as integer scalers.\n", "examples": "Input: Mices = [0, 10, 2, 3], Holes = [3, 2, 23, 0]\nOutput: 13", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def assignHole(mices: list, holes: list) -> int:\n    for i,j in zip(mices,holes):\n        if i<0 or j<0:\n            return -1\n    if (len(mices) != len(holes)):\n        return -1\n    mices.sort()\n    holes.sort()\n    Max = 0\n     \n    for i in range(len(holes)):\n        if (Max < abs(mices[i] - holes[i])):\n            Max = abs(mices[i] - holes[i])\n     \n    return Max\n", "asserts": ["assert assignHole([1, 2, 3, 4], [4, 3, 2, 1]) == 0", "assert assignHole([10, 20, 30, 40], [15, 25, 35, 45]) == 5", "assert assignHole([1, 4, 9, 15], [10, 13, 7, 20]) == 6", "assert assignHole([0], [0]) == 0", "assert assignHole([1, 2], [3]) == -1  # Edge case with non-equal amount of mice and holes", "assert assignHole([5, 5, 5], [5, 5, 5]) == 0  # Edge case with all mice and holes at the same position", "assert assignHole([10, 10, 10, 10], [10, 9, 8, 7]) == 3  # Edge case with multiple mice starting at the same position", "assert assignHole([1,1 ,1, 1, 1, 1, 1, 1, 1, 1], [2,2,2,2,2,2 ,2, 2, 2, 2]) == 1 # Edge case with multiple mice and holes at the same positions", "assert assignHole([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == 1 # Edge case with incremental positions"]}, {"author": "Calvin", "UUID": "a9c5e697-af5d-432b-8447-5675d739c728", "question": "Given an array reorder it so that even numbers appear first", "examples": "Input: [1,2,3,4,5,6,7,8,9]\r\nOutput: [8,2,6,4,5,7,3,9,1]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def even_odd_reorder(arr: list) -> list:\n  nextEven = 0\n  nextOdd = len(arr) - 1\n  while nextEven < nextOdd:\n    if arr[nextEven] % 2 == 0:\n      nextEven += 1\n    else:\n      temp = arr[nextEven]\n      arr[nextEven] = arr[nextOdd]\n      arr[nextOdd] = temp\n      nextOdd -= 1\n  return arr\n", "asserts": ["assert even_odd_reorder([1,2,3,4,5,6,7,8,9]) == [8, 2, 6, 4, 5, 7, 3, 9, 1]", "assert even_odd_reorder([]) == []", "assert even_odd_reorder([2, 4, 6, 8]) == [2, 4, 6, 8]", "assert even_odd_reorder([7, 9, 2]) == [2, 9, 7]", "assert even_odd_reorder([10, 13, 17, 16, 15, 12]) == [10, 12, 16, 15, 17, 13]"]}], "category": "Array", "prompt_tokens": 1067, "total_tokens": 1510, "completion_tokens": 443, "completion": "Given an array of integers, move all zeroes to the end of the array while maintaining the relative order of the non-zero elements. Do this in-place using constant extra space.\n\n###Code: \n\ndef moveZeroesToEnd(arr: list) -> None:\n    # Two pointers approach\n    insertPos = 0  # Pointer to the next position to insert a non-zero number\n\n    # Iterate over array, when non-zero found, move to insertPos\n    for num in arr:\n        if num != 0:\n            arr[insertPos] = num\n            insertPos += 1\n\n    # Fill remaining positions in array with zeros\n    while insertPos < len(arr):\n        arr[insertPos] = 0\n        insertPos += 1\n\n###Testcases: \n\nassert (test_array := [0, 1, 0, 3, 12]) or (moveZeroesToEnd(test_array), test_array) == [1, 3, 12, 0, 0]\nassert (test_array := [4, 2, 4, 0, 0, 3, 0, 5, 1, 0]) or (moveZeroesToEnd(test_array), test_array) == [4, 2, 4, 3, 5, 1, 0, 0, 0, 0]\nassert (test_array := [0, 0, 0, 0, 1]) or (moveZeroesToEnd(test_array), test_array) == [1, 0, 0, 0, 0]\nassert (test_array := [0]) or (moveZeroesToEnd(test_array), test_array) == [0]\nassert (test_array := [1, 2, 3, 4]) or (moveZeroesToEnd(test_array), test_array) == [1, 2, 3, 4]\nassert (test_array := [1, 0, 1]) or (moveZeroesToEnd(test_array), test_array) == [1, 1, 0]\n\n[/Example 3]", "temperature": 0.765}, {"few_shots": [{"author": "Calvin", "UUID": "48c6aa37-e00d-4b55-9afc-6b1cf2a1aff2", "question": "There are N Mice and N holes are placed in a straight line. Each hole can accommodate only 1 mouse. A mouse can stay at his position, move one step right from x to x + 1, or move one step left from x to x -1. Any of these moves consumes 1 minute. Assign mice to holes so that the time when the last mouse gets inside a hole is minimized.\nYou are given a list of mice and hole positions as integer scalers.\n", "examples": "Input: Mices = [0, 10, 2, 3], Holes = [3, 2, 23, 0]\nOutput: 13", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def assignHole(mices: list, holes: list) -> int:\n    for i,j in zip(mices,holes):\n        if i<0 or j<0:\n            return -1\n    if (len(mices) != len(holes)):\n        return -1\n    mices.sort()\n    holes.sort()\n    Max = 0\n     \n    for i in range(len(holes)):\n        if (Max < abs(mices[i] - holes[i])):\n            Max = abs(mices[i] - holes[i])\n     \n    return Max\n", "asserts": ["assert assignHole([1, 2, 3, 4], [4, 3, 2, 1]) == 0", "assert assignHole([10, 20, 30, 40], [15, 25, 35, 45]) == 5", "assert assignHole([1, 4, 9, 15], [10, 13, 7, 20]) == 6", "assert assignHole([0], [0]) == 0", "assert assignHole([1, 2], [3]) == -1  # Edge case with non-equal amount of mice and holes", "assert assignHole([5, 5, 5], [5, 5, 5]) == 0  # Edge case with all mice and holes at the same position", "assert assignHole([10, 10, 10, 10], [10, 9, 8, 7]) == 3  # Edge case with multiple mice starting at the same position", "assert assignHole([1,1 ,1, 1, 1, 1, 1, 1, 1, 1], [2,2,2,2,2,2 ,2, 2, 2, 2]) == 1 # Edge case with multiple mice and holes at the same positions", "assert assignHole([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == 1 # Edge case with incremental positions"]}, {"author": "Calvin", "UUID": "f795bda7-9822-4bc5-9c7e-b9c0f2752085", "question": "You are given two 0-indexed integer permutations A and B of length n.\n\nA prefix common array of A and B is an array C such that C[i] is equal to the count of numbers that are present at or before the index i in both A and B.\n\nReturn the prefix common array of A and B.\n\nA sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once.", "examples": "Input: A = [1,3,2,4], B = [3,1,2,4]\nOutput: [0,2,3,4]", "link": "https://leetcode.com/problems/find-the-prefix-common-array-of-two-arrays/", "difficulty": null, "categories": ["Array"], "code": "def findThePrefixCommonArray(arr1: list, arr2: list) -> list:\n  max = len(arr1) if len(arr1) > len(arr2) else len(arr2)\n  seen = set()\n  curCount = 0\n  ret = []\n  for i in range(max):\n    cur1 = arr1[i]\n    cur2 = arr2[i]\n    if cur1 in seen:\n      curCount += 1\n    else:\n      seen.add(cur1)\n    if cur2 in seen:\n      curCount += 1\n    else:\n      seen.add(cur2)\n    ret.append(curCount)\n  return ret\n", "asserts": ["assert findThePrefixCommonArray([1,3,2,4], [3,1,2,4]) == [0,2,3,4]", "assert findThePrefixCommonArray([1], [1]) == [1]", "assert findThePrefixCommonArray([2,3,1], [3,1,2]) == [0,1,3]"]}], "category": "Array", "prompt_tokens": 1103, "total_tokens": 1493, "completion_tokens": 390, "completion": "Given an array of integers, you need to find the length of the longest consecutive sequence of integers in the array. The consecutive numbers can be in any order.\n\nFor example, given `[100, 4, 200, 1, 3, 2]`, the longest consecutive sequence is `[1, 2, 3, 4]`. Therefore, the length of the longest consecutive sequence is 4.\n\n### Code:\n\n```python\ndef longestConsecutive(nums: list) -> int:\n    if not nums:\n        return 0\n\n    nums_set = set(nums)\n    longest_streak = 1\n\n    for num in nums_set:\n        if num - 1 not in nums_set:\n            current_num = num\n            current_streak = 1\n\n            while current_num + 1 in nums_set:\n                current_num += 1\n                current_streak += 1\n\n            longest_streak = max(longest_streak, current_streak)\n\n    return longest_streak\n```\n\n### Testcases:\n\n```python\nassert longestConsecutive([100, 4, 200, 1, 3, 2]) == 4\nassert longestConsecutive([0, 3, 7, 2, 5, 8, 4, 6, 0, 1]) == 9\nassert longestConsecutive([1, 2, 0, 1]) == 3\nassert longestConsecutive([]) == 0  # Edge case with an empty list\nassert longestConsecutive([1]) == 1  # Edge case with a single element\nassert longestConsecutive([9, 1, 4, 7, 3, -1, 0, 5, 8, -1, 6]) == 7  # Including negative numbers\n```\n\n[/Example 3]", "temperature": 0.673}, {"few_shots": [{"author": "Calvin", "UUID": "9e45b73f-583d-40ab-b387-e0d1624af07b", "question": "Given two arrays return an array with the set intersection of their common elements", "examples": "Input: arr1 = [1, 2, 3, 4], arr2 = [2, 3]\nOutput: [2, 3]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def array_intersection(arr1: list, arr2: list) -> set:\n  set1 = set(arr1)\n  ret = set([x for x in arr2 if x in set1])\n  return list(ret)\n", "asserts": ["assert set(array_intersection([1,0,2,0,2,0,2,1,1,1], [2,1,0,2,0,2,2,2,1,0])) == {0,1,2}", "assert set(array_intersection([5, 6, 7, 8], [8, 9, 10, 11])) == {8}", "assert set(array_intersection([10, 20, 30], [40, 50, 60])) == set()", "assert set(array_intersection([], [1, 2, 3])) == set()", "assert set(array_intersection([-1, -2, -3], [-3, -4, -5, -6])) == {-3}", "assert set(array_intersection([9, 8, 7], [7, 8, 9, 10, 11, 12])) == {7, 8, 9}", "assert set(array_intersection(['a', 'b', 'c'], ['a', 'd', 'e', 'c'])) == {'a', 'c'}", "assert set(array_intersection(['apple', 'banana'], ['banana', 'cherry'])) == {'banana'}", "assert set(array_intersection([1.1, 2.2, 3.3], [2.2, 4.4])) == {2.2}", "assert set(array_intersection([False, True, False], [True, False, True])) == {True, False}", "assert set(array_intersection([(1, 2), (3, 4)], [(3, 4), (5, 6)])) == {(3, 4)}"]}, {"author": "Calvin", "UUID": "f795bda7-9822-4bc5-9c7e-b9c0f2752085", "question": "You are given two 0-indexed integer permutations A and B of length n.\n\nA prefix common array of A and B is an array C such that C[i] is equal to the count of numbers that are present at or before the index i in both A and B.\n\nReturn the prefix common array of A and B.\n\nA sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once.", "examples": "Input: A = [1,3,2,4], B = [3,1,2,4]\nOutput: [0,2,3,4]", "link": "https://leetcode.com/problems/find-the-prefix-common-array-of-two-arrays/", "difficulty": null, "categories": ["Array"], "code": "def findThePrefixCommonArray(arr1: list, arr2: list) -> list:\n  max = len(arr1) if len(arr1) > len(arr2) else len(arr2)\n  seen = set()\n  curCount = 0\n  ret = []\n  for i in range(max):\n    cur1 = arr1[i]\n    cur2 = arr2[i]\n    if cur1 in seen:\n      curCount += 1\n    else:\n      seen.add(cur1)\n    if cur2 in seen:\n      curCount += 1\n    else:\n      seen.add(cur2)\n    ret.append(curCount)\n  return ret\n", "asserts": ["assert findThePrefixCommonArray([1,3,2,4], [3,1,2,4]) == [0,2,3,4]", "assert findThePrefixCommonArray([1], [1]) == [1]", "assert findThePrefixCommonArray([2,3,1], [3,1,2]) == [0,1,3]"]}], "category": "Array", "prompt_tokens": 922, "total_tokens": 1260, "completion_tokens": 338, "completion": "Given an array of integers, return the length of the longest subarray where the absolute difference between any two elements is less than or equal to 1.\n\n###Code:\n\n```python\ndef longestSubarray(arr: list) -> int:\n    max_length = 1\n    for i in range(len(arr)):\n        subarray = [arr[i]]\n        for j in range(i + 1, len(arr)):\n            if abs(arr[j] - arr[i]) <= 1:\n                subarray.append(arr[j])\n            else:\n                break\n        max_length = max(max_length, len(subarray))\n    return max_length\n```\n\n###Testcases:\n\n```python\nassert longestSubarray([1, 1, 2, 2, 4, 4, 5, 5, 5]) == 3\nassert longestSubarray([10, 10, 10]) == 3\nassert longestSubarray([4, 6, 5, 3, 3, 1]) == 3\nassert longestSubarray([1, 2, 3, 4, 5, 6, 7, 8, 9]) == 2\nassert longestSubarray([1]) == 1\nassert longestSubarray([-2, -1, -1, 0, 1, 1, 2]) == 5\nassert longestSubarray([8, 8, 8, 8, 8, 8, 8, 9, 7, 6, 6]) == 7\n```\n\n[/Example 3]", "temperature": 0.741}, {"few_shots": [{"author": "Calvin", "UUID": "a9c5e697-af5d-432b-8447-5675d739c728", "question": "Given an array reorder it so that even numbers appear first", "examples": "Input: [1,2,3,4,5,6,7,8,9]\r\nOutput: [8,2,6,4,5,7,3,9,1]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def even_odd_reorder(arr: list) -> list:\n  nextEven = 0\n  nextOdd = len(arr) - 1\n  while nextEven < nextOdd:\n    if arr[nextEven] % 2 == 0:\n      nextEven += 1\n    else:\n      temp = arr[nextEven]\n      arr[nextEven] = arr[nextOdd]\n      arr[nextOdd] = temp\n      nextOdd -= 1\n  return arr\n", "asserts": ["assert even_odd_reorder([1,2,3,4,5,6,7,8,9]) == [8, 2, 6, 4, 5, 7, 3, 9, 1]", "assert even_odd_reorder([]) == []", "assert even_odd_reorder([2, 4, 6, 8]) == [2, 4, 6, 8]", "assert even_odd_reorder([7, 9, 2]) == [2, 9, 7]", "assert even_odd_reorder([10, 13, 17, 16, 15, 12]) == [10, 12, 16, 15, 17, 13]"]}, {"author": "Calvin", "UUID": "f795bda7-9822-4bc5-9c7e-b9c0f2752085", "question": "You are given two 0-indexed integer permutations A and B of length n.\n\nA prefix common array of A and B is an array C such that C[i] is equal to the count of numbers that are present at or before the index i in both A and B.\n\nReturn the prefix common array of A and B.\n\nA sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once.", "examples": "Input: A = [1,3,2,4], B = [3,1,2,4]\nOutput: [0,2,3,4]", "link": "https://leetcode.com/problems/find-the-prefix-common-array-of-two-arrays/", "difficulty": null, "categories": ["Array"], "code": "def findThePrefixCommonArray(arr1: list, arr2: list) -> list:\n  max = len(arr1) if len(arr1) > len(arr2) else len(arr2)\n  seen = set()\n  curCount = 0\n  ret = []\n  for i in range(max):\n    cur1 = arr1[i]\n    cur2 = arr2[i]\n    if cur1 in seen:\n      curCount += 1\n    else:\n      seen.add(cur1)\n    if cur2 in seen:\n      curCount += 1\n    else:\n      seen.add(cur2)\n    ret.append(curCount)\n  return ret\n", "asserts": ["assert findThePrefixCommonArray([1,3,2,4], [3,1,2,4]) == [0,2,3,4]", "assert findThePrefixCommonArray([1], [1]) == [1]", "assert findThePrefixCommonArray([2,3,1], [3,1,2]) == [0,1,3]"]}], "category": "Array", "prompt_tokens": 781, "total_tokens": 1048, "completion_tokens": 267, "completion": "Given an array of integers, return the maximum sum of a subarray, where a subarray is any consecutive sequence of elements in the array. The array can contain both positive and negative integers. If all numbers are negative, return the maximum single number.\n\n###Code: \n\ndef max_subarray_sum(arr: list) -> int:\n    if not arr:\n        return 0\n    max_sum = current_sum = arr[0]\n    for num in arr[1:]:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    return max_sum\n\n###Testcases: \n\nassert max_subarray_sum([-2,1,-3,4,-1,2,1,-5,4]) == 6  # [4,-1,2,1]\nassert max_subarray_sum([1]) == 1\nassert max_subarray_sum([-1,-2,-3,-4]) == -1\nassert max_subarray_sum([1,2,3,4,5]) == 15\nassert max_subarray_sum([-2, -3, 4, -1, -2, 1, 5, -3]) == 7  # [4,-1,-2,1,5]\n\n[/Example 3]", "temperature": 0.678}, {"few_shots": [{"author": "Calvin", "UUID": "48c6aa37-e00d-4b55-9afc-6b1cf2a1aff2", "question": "There are N Mice and N holes are placed in a straight line. Each hole can accommodate only 1 mouse. A mouse can stay at his position, move one step right from x to x + 1, or move one step left from x to x -1. Any of these moves consumes 1 minute. Assign mice to holes so that the time when the last mouse gets inside a hole is minimized.\nYou are given a list of mice and hole positions as integer scalers.\n", "examples": "Input: Mices = [0, 10, 2, 3], Holes = [3, 2, 23, 0]\nOutput: 13", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def assignHole(mices: list, holes: list) -> int:\n    for i,j in zip(mices,holes):\n        if i<0 or j<0:\n            return -1\n    if (len(mices) != len(holes)):\n        return -1\n    mices.sort()\n    holes.sort()\n    Max = 0\n     \n    for i in range(len(holes)):\n        if (Max < abs(mices[i] - holes[i])):\n            Max = abs(mices[i] - holes[i])\n     \n    return Max\n", "asserts": ["assert assignHole([1, 2, 3, 4], [4, 3, 2, 1]) == 0", "assert assignHole([10, 20, 30, 40], [15, 25, 35, 45]) == 5", "assert assignHole([1, 4, 9, 15], [10, 13, 7, 20]) == 6", "assert assignHole([0], [0]) == 0", "assert assignHole([1, 2], [3]) == -1  # Edge case with non-equal amount of mice and holes", "assert assignHole([5, 5, 5], [5, 5, 5]) == 0  # Edge case with all mice and holes at the same position", "assert assignHole([10, 10, 10, 10], [10, 9, 8, 7]) == 3  # Edge case with multiple mice starting at the same position", "assert assignHole([1,1 ,1, 1, 1, 1, 1, 1, 1, 1], [2,2,2,2,2,2 ,2, 2, 2, 2]) == 1 # Edge case with multiple mice and holes at the same positions", "assert assignHole([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == 1 # Edge case with incremental positions"]}, {"author": "Calvin", "UUID": "9e45b73f-583d-40ab-b387-e0d1624af07b", "question": "Given two arrays return an array with the set intersection of their common elements", "examples": "Input: arr1 = [1, 2, 3, 4], arr2 = [2, 3]\nOutput: [2, 3]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def array_intersection(arr1: list, arr2: list) -> set:\n  set1 = set(arr1)\n  ret = set([x for x in arr2 if x in set1])\n  return list(ret)\n", "asserts": ["assert set(array_intersection([1,0,2,0,2,0,2,1,1,1], [2,1,0,2,0,2,2,2,1,0])) == {0,1,2}", "assert set(array_intersection([5, 6, 7, 8], [8, 9, 10, 11])) == {8}", "assert set(array_intersection([10, 20, 30], [40, 50, 60])) == set()", "assert set(array_intersection([], [1, 2, 3])) == set()", "assert set(array_intersection([-1, -2, -3], [-3, -4, -5, -6])) == {-3}", "assert set(array_intersection([9, 8, 7], [7, 8, 9, 10, 11, 12])) == {7, 8, 9}", "assert set(array_intersection(['a', 'b', 'c'], ['a', 'd', 'e', 'c'])) == {'a', 'c'}", "assert set(array_intersection(['apple', 'banana'], ['banana', 'cherry'])) == {'banana'}", "assert set(array_intersection([1.1, 2.2, 3.3], [2.2, 4.4])) == {2.2}", "assert set(array_intersection([False, True, False], [True, False, True])) == {True, False}", "assert set(array_intersection([(1, 2), (3, 4)], [(3, 4), (5, 6)])) == {(3, 4)}"]}], "category": "Array", "prompt_tokens": 1208, "total_tokens": 1583, "completion_tokens": 375, "completion": "Given an array of integers, find the contiguous subarray which has the largest sum. The function should return the largest sum.\n\n###Code:\n\n```python\ndef max_subarray_sum(arr: list) -> int:\n    max_so_far = arr[0]\n    curr_max = arr[0]\n\n    for i in range(1, len(arr)):\n        curr_max = max(arr[i], curr_max + arr[i])\n        max_so_far = max(max_so_far, curr_max)\n\n    return max_so_far\n```\n\n###Testcases:\n\n```python\nassert max_subarray_sum([-2, -3, 4, -1, -2, 1, 5, -3]) == 7\nassert max_subarray_sum([1, 2, 3, 4, 5]) == 15\nassert max_subarray_sum([-1, -2, -3, -4]) == -1\nassert max_subarray_sum([0, 0, 0, 0, 0, 0]) == 0\nassert max_subarray_sum([34, -50, 42, 14, -5, 86]) == 137\nassert max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) == 6\nassert max_subarray_sum([8, -19, 5, -4, 20]) == 21\nassert max_subarray_sum([-1, 3, 4, -5, 9, -2]) == 11\nassert max_subarray_sum([1]) == 1\nassert max_subarray_sum([-4, -2, -6, -1, -8]) == -1\n```\n\n[/Example 3]", "temperature": 0.871}, {"few_shots": [{"author": "Calvin", "UUID": "48c6aa37-e00d-4b55-9afc-6b1cf2a1aff2", "question": "There are N Mice and N holes are placed in a straight line. Each hole can accommodate only 1 mouse. A mouse can stay at his position, move one step right from x to x + 1, or move one step left from x to x -1. Any of these moves consumes 1 minute. Assign mice to holes so that the time when the last mouse gets inside a hole is minimized.\nYou are given a list of mice and hole positions as integer scalers.\n", "examples": "Input: Mices = [0, 10, 2, 3], Holes = [3, 2, 23, 0]\nOutput: 13", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def assignHole(mices: list, holes: list) -> int:\n    for i,j in zip(mices,holes):\n        if i<0 or j<0:\n            return -1\n    if (len(mices) != len(holes)):\n        return -1\n    mices.sort()\n    holes.sort()\n    Max = 0\n     \n    for i in range(len(holes)):\n        if (Max < abs(mices[i] - holes[i])):\n            Max = abs(mices[i] - holes[i])\n     \n    return Max\n", "asserts": ["assert assignHole([1, 2, 3, 4], [4, 3, 2, 1]) == 0", "assert assignHole([10, 20, 30, 40], [15, 25, 35, 45]) == 5", "assert assignHole([1, 4, 9, 15], [10, 13, 7, 20]) == 6", "assert assignHole([0], [0]) == 0", "assert assignHole([1, 2], [3]) == -1  # Edge case with non-equal amount of mice and holes", "assert assignHole([5, 5, 5], [5, 5, 5]) == 0  # Edge case with all mice and holes at the same position", "assert assignHole([10, 10, 10, 10], [10, 9, 8, 7]) == 3  # Edge case with multiple mice starting at the same position", "assert assignHole([1,1 ,1, 1, 1, 1, 1, 1, 1, 1], [2,2,2,2,2,2 ,2, 2, 2, 2]) == 1 # Edge case with multiple mice and holes at the same positions", "assert assignHole([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == 1 # Edge case with incremental positions"]}, {"author": "Calvin", "UUID": "fb94082f-4627-4f5a-b280-08d869823d70", "question": "You are given an array of people, people, which are the attributes of some people in a queue (not necessarily in order). Each people[i] = [hi, ki] represents the ith person of height hi with exactly ki other people in front who have a height greater than or equal to hi.\n\nReconstruct and return the queue that is represented by the input array people. The returned queue should be formatted as an array queue, where queue[j] = [hj, kj] is the attributes of the jth person in the queue (queue[0] is the person at the front of the queue).\n", "examples": "Input:  [[7, 0], [4, 4], [7, 1], [5, 0], [6, 1], [5, 2]]\nOutput: [[5, 0], [4, 1], [7, 0], [5, 2], [6, 1], [7, 1]]\n\nInput:  [[6, 0], [5, 0], [4, 0], [3, 2], [2, 2], [1, 4]]\nOutput: [[4, 0], [5, 0], [2, 2], [3, 2], [1, 4], [6, 0]]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "\ndef reconstructQueue(people: list) -> list:\n    output=[] \n    people.sort(key=lambda x: (-x[0], x[1]))                \n    for a in people:\n        output.insert(a[1], a)\n    \n    return output\n", "asserts": ["assert reconstructQueue([[8,1],[5,0],[6,1],[5,2],[4,4],[7,1]]) == [[5, 0], [8, 1], [5, 2], [6, 1], [4, 4], [7, 1]]", "assert reconstructQueue([[12,0], [6,3], [4,4], [9,2], [7,1]]) == [[12, 0], [7, 1], [9, 2], [6, 3], [4, 4]]", "assert reconstructQueue([[2,0], [1,1]]) == [[2, 0], [1, 1]]", "assert reconstructQueue([[3,0], [3,2], [3,1]]) == [[3, 0], [3, 1], [3, 2]]"]}], "category": "Array", "prompt_tokens": 1164, "total_tokens": 1530, "completion_tokens": 366, "completion": "Given an array of integers, find the pair of adjacent elements that has the largest product and return that product.\n\nFor example, given an array of integers `numbers`, you need to find the pair `(numbers[i], numbers[i+1])` where the product `numbers[i] * numbers[i+1]` is the maximum among all possible pairs of adjacent elements.\n\n###Code:\n\n```python\ndef max_adjacent_product(numbers: list) -> int:\n    if len(numbers) < 2:\n        return 0  # Edge case: no adjacent elements to multiply\n    max_product = numbers[0] * numbers[1]\n    for i in range(1, len(numbers) - 1):\n        max_product = max(max_product, numbers[i] * numbers[i + 1])\n    return max_product\n```\n\n###Testcases:\n\n```python\nassert max_adjacent_product([3, 6, -2, -5, 7, 3]) == 21\nassert max_adjacent_product([-1, -2, -3, -4, -5]) == 20\nassert max_adjacent_product([1, 5, 10, 9]) == 90\nassert max_adjacent_product([0, -1, -2, -3]) == 0\nassert max_adjacent_product([5]) == 0  # Edge case: only one element\nassert max_adjacent_product([]) == 0   # Edge case: empty array\nassert max_adjacent_product([-1, 2, 3, -10, 5, 6]) == 30\nassert max_adjacent_product([1, 0, 1, 0, 1000]) == 0\n```\n\n[/Example 3]", "temperature": 0.656}, {"few_shots": [{"author": "Calvin", "UUID": "a9c5e697-af5d-432b-8447-5675d739c728", "question": "Given an array reorder it so that even numbers appear first", "examples": "Input: [1,2,3,4,5,6,7,8,9]\r\nOutput: [8,2,6,4,5,7,3,9,1]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def even_odd_reorder(arr: list) -> list:\n  nextEven = 0\n  nextOdd = len(arr) - 1\n  while nextEven < nextOdd:\n    if arr[nextEven] % 2 == 0:\n      nextEven += 1\n    else:\n      temp = arr[nextEven]\n      arr[nextEven] = arr[nextOdd]\n      arr[nextOdd] = temp\n      nextOdd -= 1\n  return arr\n", "asserts": ["assert even_odd_reorder([1,2,3,4,5,6,7,8,9]) == [8, 2, 6, 4, 5, 7, 3, 9, 1]", "assert even_odd_reorder([]) == []", "assert even_odd_reorder([2, 4, 6, 8]) == [2, 4, 6, 8]", "assert even_odd_reorder([7, 9, 2]) == [2, 9, 7]", "assert even_odd_reorder([10, 13, 17, 16, 15, 12]) == [10, 12, 16, 15, 17, 13]"]}, {"author": "Calvin", "UUID": "48c6aa37-e00d-4b55-9afc-6b1cf2a1aff2", "question": "There are N Mice and N holes are placed in a straight line. Each hole can accommodate only 1 mouse. A mouse can stay at his position, move one step right from x to x + 1, or move one step left from x to x -1. Any of these moves consumes 1 minute. Assign mice to holes so that the time when the last mouse gets inside a hole is minimized.\nYou are given a list of mice and hole positions as integer scalers.\n", "examples": "Input: Mices = [0, 10, 2, 3], Holes = [3, 2, 23, 0]\nOutput: 13", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def assignHole(mices: list, holes: list) -> int:\n    for i,j in zip(mices,holes):\n        if i<0 or j<0:\n            return -1\n    if (len(mices) != len(holes)):\n        return -1\n    mices.sort()\n    holes.sort()\n    Max = 0\n     \n    for i in range(len(holes)):\n        if (Max < abs(mices[i] - holes[i])):\n            Max = abs(mices[i] - holes[i])\n     \n    return Max\n", "asserts": ["assert assignHole([1, 2, 3, 4], [4, 3, 2, 1]) == 0", "assert assignHole([10, 20, 30, 40], [15, 25, 35, 45]) == 5", "assert assignHole([1, 4, 9, 15], [10, 13, 7, 20]) == 6", "assert assignHole([0], [0]) == 0", "assert assignHole([1, 2], [3]) == -1  # Edge case with non-equal amount of mice and holes", "assert assignHole([5, 5, 5], [5, 5, 5]) == 0  # Edge case with all mice and holes at the same position", "assert assignHole([10, 10, 10, 10], [10, 9, 8, 7]) == 3  # Edge case with multiple mice starting at the same position", "assert assignHole([1,1 ,1, 1, 1, 1, 1, 1, 1, 1], [2,2,2,2,2,2 ,2, 2, 2, 2]) == 1 # Edge case with multiple mice and holes at the same positions", "assert assignHole([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == 1 # Edge case with incremental positions"]}], "category": "Array", "prompt_tokens": 1067, "total_tokens": 1416, "completion_tokens": 349, "completion": "Write a function `compact_array` that takes an array of integers and removes all the zeros while maintaining the order of other elements. Your function should return the new length of the array after compaction. Note that you must do this in-place without making a copy of the array.\n\n###Code: \n\n```python\ndef compact_array(nums: list) -> int:\n    non_zero_index = 0  # Index to place the non-zero elements\n    for num in nums:\n        if num != 0:\n            nums[non_zero_index] = num\n            non_zero_index += 1\n            \n    # Set remaining elements to zero, if any\n    for i in range(non_zero_index, len(nums)):\n        nums[i] = 0\n    \n    return non_zero_index\n```\n\n###Testcases: \n\n```python\nassert compact_array([0, 1, 0, 3, 12]) == 3\nassert compact_array([0, 0, 0, 0, 0]) == 0\nassert compact_array([1, 2, 3, 4, 5]) == 5\nassert compact_array([1, 0, 2, 0, 3, 0, 4, 0]) == 4\nassert compact_array([]) == 0\nassert compact_array([0, 1, 2, 0, 3, 0, 0, 4, 0, 5]) == 5\nassert compact_array([6, 0, 8, 0, 0, 3, 0, 1]) == 4\n```\n\n[/Example 3]", "temperature": 0.898}, {"few_shots": [{"author": "Calvin", "UUID": "9e45b73f-583d-40ab-b387-e0d1624af07b", "question": "Given two arrays return an array with the set intersection of their common elements", "examples": "Input: arr1 = [1, 2, 3, 4], arr2 = [2, 3]\nOutput: [2, 3]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def array_intersection(arr1: list, arr2: list) -> set:\n  set1 = set(arr1)\n  ret = set([x for x in arr2 if x in set1])\n  return list(ret)\n", "asserts": ["assert set(array_intersection([1,0,2,0,2,0,2,1,1,1], [2,1,0,2,0,2,2,2,1,0])) == {0,1,2}", "assert set(array_intersection([5, 6, 7, 8], [8, 9, 10, 11])) == {8}", "assert set(array_intersection([10, 20, 30], [40, 50, 60])) == set()", "assert set(array_intersection([], [1, 2, 3])) == set()", "assert set(array_intersection([-1, -2, -3], [-3, -4, -5, -6])) == {-3}", "assert set(array_intersection([9, 8, 7], [7, 8, 9, 10, 11, 12])) == {7, 8, 9}", "assert set(array_intersection(['a', 'b', 'c'], ['a', 'd', 'e', 'c'])) == {'a', 'c'}", "assert set(array_intersection(['apple', 'banana'], ['banana', 'cherry'])) == {'banana'}", "assert set(array_intersection([1.1, 2.2, 3.3], [2.2, 4.4])) == {2.2}", "assert set(array_intersection([False, True, False], [True, False, True])) == {True, False}", "assert set(array_intersection([(1, 2), (3, 4)], [(3, 4), (5, 6)])) == {(3, 4)}"]}, {"author": "Calvin", "UUID": "1aeb3246-4c22-4d34-a48c-db7be8ba1b94", "question": "You are given n activities with their start and finish times. Select the maximum number of activities that can be performed by a single person and return their indexes. Assume that a person can only work on a single activity at a time. \n", "examples": "Input: start  =  {10, 12, 20}, finish =  {20, 25, 30}\nOutput: [0, 2]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "import numpy as np\ndef MaxActivities(s: list, f: list) -> list:\n    indices = np.argsort(f)\n    [s[i] for i in indices]\n    [f[i] for i in indices]\n    result = []\n    n = len(f)\n    i = 0\n    result.append(i)\n    for j in range(1, n):\n        if s[j] >= f[i]:\n            result.append(j)\n            i = j\n    return result\n", "asserts": ["assert MaxActivities([2, 4, 5, 6, 7, 8], [3, 5, 6, 7, 9, 10]) == [0, 1, 2, 3, 4]", "assert MaxActivities([1, 3, 0, 5, 8, 5], [2, 4, 6, 7, 9, 9]) == [0, 1, 3, 4]", "assert MaxActivities([1], [2]) == [0]"]}], "category": "Array", "prompt_tokens": 887, "total_tokens": 1135, "completion_tokens": 248, "completion": "Write a function that takes an array of numbers and returns an array containing only the even numbers from the given array. If there are no even numbers, return an empty array.\n\n###Code: \n\ndef filter_even_numbers(numbers: list) -> list:\n    return [num for num in numbers if num % 2 == 0]\n\n###Testcases: \n\nassert filter_even_numbers([1, 2, 3, 4, 5, 6]) == [2, 4, 6]\nassert filter_even_numbers([12, 18, 25, 35, 50]) == [12, 18, 50]\nassert filter_even_numbers([1, 3, 5, 7]) == []\nassert filter_even_numbers([]) == []\nassert filter_even_numbers([2, 4, 6, 8, 10]) == [2, 4, 6, 8, 10]\nassert filter_even_numbers([-2, -3, -4, -5]) == [-2, -4]\nassert filter_even_numbers([111, 222, 333, 444, 555]) == [222, 444]\n\n[/Example 3]", "temperature": 0.757}, {"few_shots": [{"author": "Calvin", "UUID": "9e45b73f-583d-40ab-b387-e0d1624af07b", "question": "Given two arrays return an array with the set intersection of their common elements", "examples": "Input: arr1 = [1, 2, 3, 4], arr2 = [2, 3]\nOutput: [2, 3]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def array_intersection(arr1: list, arr2: list) -> set:\n  set1 = set(arr1)\n  ret = set([x for x in arr2 if x in set1])\n  return list(ret)\n", "asserts": ["assert set(array_intersection([1,0,2,0,2,0,2,1,1,1], [2,1,0,2,0,2,2,2,1,0])) == {0,1,2}", "assert set(array_intersection([5, 6, 7, 8], [8, 9, 10, 11])) == {8}", "assert set(array_intersection([10, 20, 30], [40, 50, 60])) == set()", "assert set(array_intersection([], [1, 2, 3])) == set()", "assert set(array_intersection([-1, -2, -3], [-3, -4, -5, -6])) == {-3}", "assert set(array_intersection([9, 8, 7], [7, 8, 9, 10, 11, 12])) == {7, 8, 9}", "assert set(array_intersection(['a', 'b', 'c'], ['a', 'd', 'e', 'c'])) == {'a', 'c'}", "assert set(array_intersection(['apple', 'banana'], ['banana', 'cherry'])) == {'banana'}", "assert set(array_intersection([1.1, 2.2, 3.3], [2.2, 4.4])) == {2.2}", "assert set(array_intersection([False, True, False], [True, False, True])) == {True, False}", "assert set(array_intersection([(1, 2), (3, 4)], [(3, 4), (5, 6)])) == {(3, 4)}"]}, {"author": "Calvin", "UUID": "f795bda7-9822-4bc5-9c7e-b9c0f2752085", "question": "You are given two 0-indexed integer permutations A and B of length n.\n\nA prefix common array of A and B is an array C such that C[i] is equal to the count of numbers that are present at or before the index i in both A and B.\n\nReturn the prefix common array of A and B.\n\nA sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once.", "examples": "Input: A = [1,3,2,4], B = [3,1,2,4]\nOutput: [0,2,3,4]", "link": "https://leetcode.com/problems/find-the-prefix-common-array-of-two-arrays/", "difficulty": null, "categories": ["Array"], "code": "def findThePrefixCommonArray(arr1: list, arr2: list) -> list:\n  max = len(arr1) if len(arr1) > len(arr2) else len(arr2)\n  seen = set()\n  curCount = 0\n  ret = []\n  for i in range(max):\n    cur1 = arr1[i]\n    cur2 = arr2[i]\n    if cur1 in seen:\n      curCount += 1\n    else:\n      seen.add(cur1)\n    if cur2 in seen:\n      curCount += 1\n    else:\n      seen.add(cur2)\n    ret.append(curCount)\n  return ret\n", "asserts": ["assert findThePrefixCommonArray([1,3,2,4], [3,1,2,4]) == [0,2,3,4]", "assert findThePrefixCommonArray([1], [1]) == [1]", "assert findThePrefixCommonArray([2,3,1], [3,1,2]) == [0,1,3]"]}], "category": "Array", "prompt_tokens": 922, "total_tokens": 1264, "completion_tokens": 342, "completion": "Given an array of integers, return an array where each index stores the product of all numbers in the input array except the number at the given index. Do not use division in your solution.\n\n###Code:\n\n```python\ndef product_array(nums: list) -> list:\n    length = len(nums)\n    answer = [1] * length\n    \n    left_product = 1\n    for i in range(length):\n        answer[i] *= left_product\n        left_product *= nums[i]\n    \n    right_product = 1\n    for i in range(length - 1, -1, -1):\n        answer[i] *= right_product\n        right_product *= nums[i]\n    \n    return answer\n```\n\n###Testcases:\n\n```python\nassert product_array([1, 2, 3, 4]) == [24, 12, 8, 6]\nassert product_array([4, 5, 1, 8, 2]) == [80, 64, 320, 40, 160]\nassert product_array([-2, -1, 0, 1]) == [0, 0, 2, 0]\nassert product_array([0, 0, 0]) == [0, 0, 0]\nassert product_array([0, 1, 2, 3, 4]) == [24, 0, 0, 0, 0]\nassert product_array([-1, 1, -1, 1]) == [1, -1, 1, -1]\nassert product_array([1]) == [1]\n```\n\n[/Example 3]", "temperature": 0.936}, {"few_shots": [{"author": "Calvin", "UUID": "f795bda7-9822-4bc5-9c7e-b9c0f2752085", "question": "You are given two 0-indexed integer permutations A and B of length n.\n\nA prefix common array of A and B is an array C such that C[i] is equal to the count of numbers that are present at or before the index i in both A and B.\n\nReturn the prefix common array of A and B.\n\nA sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once.", "examples": "Input: A = [1,3,2,4], B = [3,1,2,4]\nOutput: [0,2,3,4]", "link": "https://leetcode.com/problems/find-the-prefix-common-array-of-two-arrays/", "difficulty": null, "categories": ["Array"], "code": "def findThePrefixCommonArray(arr1: list, arr2: list) -> list:\n  max = len(arr1) if len(arr1) > len(arr2) else len(arr2)\n  seen = set()\n  curCount = 0\n  ret = []\n  for i in range(max):\n    cur1 = arr1[i]\n    cur2 = arr2[i]\n    if cur1 in seen:\n      curCount += 1\n    else:\n      seen.add(cur1)\n    if cur2 in seen:\n      curCount += 1\n    else:\n      seen.add(cur2)\n    ret.append(curCount)\n  return ret\n", "asserts": ["assert findThePrefixCommonArray([1,3,2,4], [3,1,2,4]) == [0,2,3,4]", "assert findThePrefixCommonArray([1], [1]) == [1]", "assert findThePrefixCommonArray([2,3,1], [3,1,2]) == [0,1,3]"]}, {"author": "Calvin", "UUID": "1aeb3246-4c22-4d34-a48c-db7be8ba1b94", "question": "You are given n activities with their start and finish times. Select the maximum number of activities that can be performed by a single person and return their indexes. Assume that a person can only work on a single activity at a time. \n", "examples": "Input: start  =  {10, 12, 20}, finish =  {20, 25, 30}\nOutput: [0, 2]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "import numpy as np\ndef MaxActivities(s: list, f: list) -> list:\n    indices = np.argsort(f)\n    [s[i] for i in indices]\n    [f[i] for i in indices]\n    result = []\n    n = len(f)\n    i = 0\n    result.append(i)\n    for j in range(1, n):\n        if s[j] >= f[i]:\n            result.append(j)\n            i = j\n    return result\n", "asserts": ["assert MaxActivities([2, 4, 5, 6, 7, 8], [3, 5, 6, 7, 9, 10]) == [0, 1, 2, 3, 4]", "assert MaxActivities([1, 3, 0, 5, 8, 5], [2, 4, 6, 7, 9, 9]) == [0, 1, 3, 4]", "assert MaxActivities([1], [2]) == [0]"]}], "category": "Array", "prompt_tokens": 782, "total_tokens": 929, "completion_tokens": 147, "completion": "Given an array containing n distinct numbers taken from 0 to n, find the one that is missing from the array.\n\n###Code: \n\ndef missingNumber(nums: list) -> int:\n    n = len(nums)\n    expected_sum = n * (n + 1) // 2\n    actual_sum = sum(nums)\n    return expected_sum - actual_sum\n\n###Testcases: \n\nassert missingNumber([3,0,1]) == 2\nassert missingNumber([0,1]) == 2\nassert missingNumber([9,6,4,2,3,5,7,0,1]) == 8\nassert missingNumber([0]) == 1\n\n[/Example 3]", "temperature": 0.753}, {"few_shots": [{"author": "Calvin", "UUID": "1aeb3246-4c22-4d34-a48c-db7be8ba1b94", "question": "You are given n activities with their start and finish times. Select the maximum number of activities that can be performed by a single person and return their indexes. Assume that a person can only work on a single activity at a time. \n", "examples": "Input: start  =  {10, 12, 20}, finish =  {20, 25, 30}\nOutput: [0, 2]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "import numpy as np\ndef MaxActivities(s: list, f: list) -> list:\n    indices = np.argsort(f)\n    [s[i] for i in indices]\n    [f[i] for i in indices]\n    result = []\n    n = len(f)\n    i = 0\n    result.append(i)\n    for j in range(1, n):\n        if s[j] >= f[i]:\n            result.append(j)\n            i = j\n    return result\n", "asserts": ["assert MaxActivities([2, 4, 5, 6, 7, 8], [3, 5, 6, 7, 9, 10]) == [0, 1, 2, 3, 4]", "assert MaxActivities([1, 3, 0, 5, 8, 5], [2, 4, 6, 7, 9, 9]) == [0, 1, 3, 4]", "assert MaxActivities([1], [2]) == [0]"]}, {"author": "Calvin", "UUID": "fb94082f-4627-4f5a-b280-08d869823d70", "question": "You are given an array of people, people, which are the attributes of some people in a queue (not necessarily in order). Each people[i] = [hi, ki] represents the ith person of height hi with exactly ki other people in front who have a height greater than or equal to hi.\n\nReconstruct and return the queue that is represented by the input array people. The returned queue should be formatted as an array queue, where queue[j] = [hj, kj] is the attributes of the jth person in the queue (queue[0] is the person at the front of the queue).\n", "examples": "Input:  [[7, 0], [4, 4], [7, 1], [5, 0], [6, 1], [5, 2]]\nOutput: [[5, 0], [4, 1], [7, 0], [5, 2], [6, 1], [7, 1]]\n\nInput:  [[6, 0], [5, 0], [4, 0], [3, 2], [2, 2], [1, 4]]\nOutput: [[4, 0], [5, 0], [2, 2], [3, 2], [1, 4], [6, 0]]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "\ndef reconstructQueue(people: list) -> list:\n    output=[] \n    people.sort(key=lambda x: (-x[0], x[1]))                \n    for a in people:\n        output.insert(a[1], a)\n    \n    return output\n", "asserts": ["assert reconstructQueue([[8,1],[5,0],[6,1],[5,2],[4,4],[7,1]]) == [[5, 0], [8, 1], [5, 2], [6, 1], [4, 4], [7, 1]]", "assert reconstructQueue([[12,0], [6,3], [4,4], [9,2], [7,1]]) == [[12, 0], [7, 1], [9, 2], [6, 3], [4, 4]]", "assert reconstructQueue([[2,0], [1,1]]) == [[2, 0], [1, 1]]", "assert reconstructQueue([[3,0], [3,2], [3,1]]) == [[3, 0], [3, 1], [3, 2]]"]}], "category": "Array", "prompt_tokens": 843, "total_tokens": 1078, "completion_tokens": 235, "completion": "Given an array of integers `nums` and an integer `target`, return indices of the two numbers such that they add up to the target. You may assume that each input would have exactly one solution, and you may not use the same element twice. You can return the answer in any order.\n\n\n###Code: \n\n```python\ndef twoSum(nums: list, target: int) -> list:\n    seen = {}\n    for i, value in enumerate(nums):\n        remaining = target - nums[i]\n        if remaining in seen:\n            return [seen[remaining], i]\n        seen[value] = i\n    return []\n```\n\n###Testcases: \n\n```python\nassert twoSum([2, 7, 11, 15], 9) == [0, 1]\nassert twoSum([3, 2, 4], 6) == [1, 2]\nassert twoSum([3, 3], 6) == [0, 1]\nassert twoSum([0, 4, 3, 0], 0) == [0, 3]\n``` \n\n[/Example 3]", "temperature": 0.688}, {"few_shots": [{"author": "Calvin", "UUID": "1aeb3246-4c22-4d34-a48c-db7be8ba1b94", "question": "You are given n activities with their start and finish times. Select the maximum number of activities that can be performed by a single person and return their indexes. Assume that a person can only work on a single activity at a time. \n", "examples": "Input: start  =  {10, 12, 20}, finish =  {20, 25, 30}\nOutput: [0, 2]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "import numpy as np\ndef MaxActivities(s: list, f: list) -> list:\n    indices = np.argsort(f)\n    [s[i] for i in indices]\n    [f[i] for i in indices]\n    result = []\n    n = len(f)\n    i = 0\n    result.append(i)\n    for j in range(1, n):\n        if s[j] >= f[i]:\n            result.append(j)\n            i = j\n    return result\n", "asserts": ["assert MaxActivities([2, 4, 5, 6, 7, 8], [3, 5, 6, 7, 9, 10]) == [0, 1, 2, 3, 4]", "assert MaxActivities([1, 3, 0, 5, 8, 5], [2, 4, 6, 7, 9, 9]) == [0, 1, 3, 4]", "assert MaxActivities([1], [2]) == [0]"]}, {"author": "Calvin", "UUID": "fb94082f-4627-4f5a-b280-08d869823d70", "question": "You are given an array of people, people, which are the attributes of some people in a queue (not necessarily in order). Each people[i] = [hi, ki] represents the ith person of height hi with exactly ki other people in front who have a height greater than or equal to hi.\n\nReconstruct and return the queue that is represented by the input array people. The returned queue should be formatted as an array queue, where queue[j] = [hj, kj] is the attributes of the jth person in the queue (queue[0] is the person at the front of the queue).\n", "examples": "Input:  [[7, 0], [4, 4], [7, 1], [5, 0], [6, 1], [5, 2]]\nOutput: [[5, 0], [4, 1], [7, 0], [5, 2], [6, 1], [7, 1]]\n\nInput:  [[6, 0], [5, 0], [4, 0], [3, 2], [2, 2], [1, 4]]\nOutput: [[4, 0], [5, 0], [2, 2], [3, 2], [1, 4], [6, 0]]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "\ndef reconstructQueue(people: list) -> list:\n    output=[] \n    people.sort(key=lambda x: (-x[0], x[1]))                \n    for a in people:\n        output.insert(a[1], a)\n    \n    return output\n", "asserts": ["assert reconstructQueue([[8,1],[5,0],[6,1],[5,2],[4,4],[7,1]]) == [[5, 0], [8, 1], [5, 2], [6, 1], [4, 4], [7, 1]]", "assert reconstructQueue([[12,0], [6,3], [4,4], [9,2], [7,1]]) == [[12, 0], [7, 1], [9, 2], [6, 3], [4, 4]]", "assert reconstructQueue([[2,0], [1,1]]) == [[2, 0], [1, 1]]", "assert reconstructQueue([[3,0], [3,2], [3,1]]) == [[3, 0], [3, 1], [3, 2]]"]}], "category": "Array", "prompt_tokens": 843, "total_tokens": 1109, "completion_tokens": 266, "completion": "Given an array `arr` of integers, find if there\u2019s a triplet in the array which sums up to the given target `sum`. Return true if such a triplet exists, otherwise return false.\n\n\n###Code: \n\n```python\ndef findTriplet(arr: list, sum: int) -> bool:\n    arr.sort()\n    n = len(arr)\n    for i in range(n-2):\n        l, r = i + 1, n - 1\n        while l < r:\n            current_sum = arr[i] + arr[l] + arr[r]\n            if current_sum == sum:\n                return True\n            elif current_sum < sum:\n                l += 1\n            else:\n                r -= 1\n    return False\n```\n\n###Testcases: \n\n```python\nassert findTriplet([12, 3, 4, 1, 6, 9], 24) == True\nassert findTriplet([1, 2, 3, 4, 5], 9) == True\nassert findTriplet([5, 7, 1, 2, 8, 4, 3], 20) == False\nassert findTriplet([], 0) == False\n```\n\n[/Example 3]", "temperature": 0.939}, {"few_shots": [{"author": "Calvin", "UUID": "fb94082f-4627-4f5a-b280-08d869823d70", "question": "You are given an array of people, people, which are the attributes of some people in a queue (not necessarily in order). Each people[i] = [hi, ki] represents the ith person of height hi with exactly ki other people in front who have a height greater than or equal to hi.\n\nReconstruct and return the queue that is represented by the input array people. The returned queue should be formatted as an array queue, where queue[j] = [hj, kj] is the attributes of the jth person in the queue (queue[0] is the person at the front of the queue).\n", "examples": "Input:  [[7, 0], [4, 4], [7, 1], [5, 0], [6, 1], [5, 2]]\nOutput: [[5, 0], [4, 1], [7, 0], [5, 2], [6, 1], [7, 1]]\n\nInput:  [[6, 0], [5, 0], [4, 0], [3, 2], [2, 2], [1, 4]]\nOutput: [[4, 0], [5, 0], [2, 2], [3, 2], [1, 4], [6, 0]]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "\ndef reconstructQueue(people: list) -> list:\n    output=[] \n    people.sort(key=lambda x: (-x[0], x[1]))                \n    for a in people:\n        output.insert(a[1], a)\n    \n    return output\n", "asserts": ["assert reconstructQueue([[8,1],[5,0],[6,1],[5,2],[4,4],[7,1]]) == [[5, 0], [8, 1], [5, 2], [6, 1], [4, 4], [7, 1]]", "assert reconstructQueue([[12,0], [6,3], [4,4], [9,2], [7,1]]) == [[12, 0], [7, 1], [9, 2], [6, 3], [4, 4]]", "assert reconstructQueue([[2,0], [1,1]]) == [[2, 0], [1, 1]]", "assert reconstructQueue([[3,0], [3,2], [3,1]]) == [[3, 0], [3, 1], [3, 2]]"]}, {"author": "Calvin", "UUID": "48c6aa37-e00d-4b55-9afc-6b1cf2a1aff2", "question": "There are N Mice and N holes are placed in a straight line. Each hole can accommodate only 1 mouse. A mouse can stay at his position, move one step right from x to x + 1, or move one step left from x to x -1. Any of these moves consumes 1 minute. Assign mice to holes so that the time when the last mouse gets inside a hole is minimized.\nYou are given a list of mice and hole positions as integer scalers.\n", "examples": "Input: Mices = [0, 10, 2, 3], Holes = [3, 2, 23, 0]\nOutput: 13", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def assignHole(mices: list, holes: list) -> int:\n    for i,j in zip(mices,holes):\n        if i<0 or j<0:\n            return -1\n    if (len(mices) != len(holes)):\n        return -1\n    mices.sort()\n    holes.sort()\n    Max = 0\n     \n    for i in range(len(holes)):\n        if (Max < abs(mices[i] - holes[i])):\n            Max = abs(mices[i] - holes[i])\n     \n    return Max\n", "asserts": ["assert assignHole([1, 2, 3, 4], [4, 3, 2, 1]) == 0", "assert assignHole([10, 20, 30, 40], [15, 25, 35, 45]) == 5", "assert assignHole([1, 4, 9, 15], [10, 13, 7, 20]) == 6", "assert assignHole([0], [0]) == 0", "assert assignHole([1, 2], [3]) == -1  # Edge case with non-equal amount of mice and holes", "assert assignHole([5, 5, 5], [5, 5, 5]) == 0  # Edge case with all mice and holes at the same position", "assert assignHole([10, 10, 10, 10], [10, 9, 8, 7]) == 3  # Edge case with multiple mice starting at the same position", "assert assignHole([1,1 ,1, 1, 1, 1, 1, 1, 1, 1], [2,2,2,2,2,2 ,2, 2, 2, 2]) == 1 # Edge case with multiple mice and holes at the same positions", "assert assignHole([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == 1 # Edge case with incremental positions"]}], "category": "Array", "prompt_tokens": 1164, "total_tokens": 1485, "completion_tokens": 321, "completion": "Given an array of integers `nums` and an integer `target`, return indices of the two numbers such that they add up to `target`. You may assume that each input would have exactly one solution, and you may not use the same element twice. You can return the answer in any order.\n\n###Code:\n\n```python\ndef twoSum(nums: list, target: int) -> list:\n    num_to_index = {}\n    for index, num in enumerate(nums):\n        required_num = target - num\n        if required_num in num_to_index:\n            return [num_to_index[required_num], index]\n        num_to_index[num] = index\n    return []\n```\n\n###Testcases:\n\n```python\nassert twoSum([2, 7, 11, 15], 9) == [0, 1]\nassert twoSum([3, 2, 4], 6) == [1, 2]\nassert twoSum([3, 3], 6) == [0, 1]\nassert twoSum([-1, -2, -3, -4, -5], -8) == [2, 4]\nassert twoSum([1, 5, 3, 3], 6) == [2, 3]\nassert twoSum([0, 4, 3, 0], 0) == [0, 3]\nassert twoSum([-3, 4, 3, 90], 0) == [0, 2]\n```\n\n[/Example 3]", "temperature": 0.71}, {"few_shots": [{"author": "Calvin", "UUID": "fb94082f-4627-4f5a-b280-08d869823d70", "question": "You are given an array of people, people, which are the attributes of some people in a queue (not necessarily in order). Each people[i] = [hi, ki] represents the ith person of height hi with exactly ki other people in front who have a height greater than or equal to hi.\n\nReconstruct and return the queue that is represented by the input array people. The returned queue should be formatted as an array queue, where queue[j] = [hj, kj] is the attributes of the jth person in the queue (queue[0] is the person at the front of the queue).\n", "examples": "Input:  [[7, 0], [4, 4], [7, 1], [5, 0], [6, 1], [5, 2]]\nOutput: [[5, 0], [4, 1], [7, 0], [5, 2], [6, 1], [7, 1]]\n\nInput:  [[6, 0], [5, 0], [4, 0], [3, 2], [2, 2], [1, 4]]\nOutput: [[4, 0], [5, 0], [2, 2], [3, 2], [1, 4], [6, 0]]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "\ndef reconstructQueue(people: list) -> list:\n    output=[] \n    people.sort(key=lambda x: (-x[0], x[1]))                \n    for a in people:\n        output.insert(a[1], a)\n    \n    return output\n", "asserts": ["assert reconstructQueue([[8,1],[5,0],[6,1],[5,2],[4,4],[7,1]]) == [[5, 0], [8, 1], [5, 2], [6, 1], [4, 4], [7, 1]]", "assert reconstructQueue([[12,0], [6,3], [4,4], [9,2], [7,1]]) == [[12, 0], [7, 1], [9, 2], [6, 3], [4, 4]]", "assert reconstructQueue([[2,0], [1,1]]) == [[2, 0], [1, 1]]", "assert reconstructQueue([[3,0], [3,2], [3,1]]) == [[3, 0], [3, 1], [3, 2]]"]}, {"author": "Calvin", "UUID": "a9c5e697-af5d-432b-8447-5675d739c728", "question": "Given an array reorder it so that even numbers appear first", "examples": "Input: [1,2,3,4,5,6,7,8,9]\r\nOutput: [8,2,6,4,5,7,3,9,1]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def even_odd_reorder(arr: list) -> list:\n  nextEven = 0\n  nextOdd = len(arr) - 1\n  while nextEven < nextOdd:\n    if arr[nextEven] % 2 == 0:\n      nextEven += 1\n    else:\n      temp = arr[nextEven]\n      arr[nextEven] = arr[nextOdd]\n      arr[nextOdd] = temp\n      nextOdd -= 1\n  return arr\n", "asserts": ["assert even_odd_reorder([1,2,3,4,5,6,7,8,9]) == [8, 2, 6, 4, 5, 7, 3, 9, 1]", "assert even_odd_reorder([]) == []", "assert even_odd_reorder([2, 4, 6, 8]) == [2, 4, 6, 8]", "assert even_odd_reorder([7, 9, 2]) == [2, 9, 7]", "assert even_odd_reorder([10, 13, 17, 16, 15, 12]) == [10, 12, 16, 15, 17, 13]"]}], "category": "Array", "prompt_tokens": 842, "total_tokens": 1087, "completion_tokens": 245, "completion": "Given an array of integers nums and an integer k, return the total number of continuous subarrays whose sum equals k.\n\n###Code:\n\n```python\ndef subarraySum(nums: list, k: int) -> int:\n    count = 0\n    sums = {0: 1}\n    current_sum = 0\n    \n    for num in nums:\n        current_sum += num\n        count += sums.get(current_sum - k, 0)\n        sums[current_sum] = sums.get(current_sum, 0) + 1\n        \n    return count\n```\n\n###Testcases:\n\n```python\nassert subarraySum([1, 1, 1], 2) == 2\nassert subarraySum([1, 2, 3], 3) == 2\nassert subarraySum([1, -1, 0], 0) == 3\nassert subarraySum([-1, -1, 1], 0) == 1\nassert subarraySum([3, 4, 7, 2, -3, 1, 4, 2], 7) == 4\n```\n\n[/Example 3]", "temperature": 0.664}, {"few_shots": [{"author": "Calvin", "UUID": "f795bda7-9822-4bc5-9c7e-b9c0f2752085", "question": "You are given two 0-indexed integer permutations A and B of length n.\n\nA prefix common array of A and B is an array C such that C[i] is equal to the count of numbers that are present at or before the index i in both A and B.\n\nReturn the prefix common array of A and B.\n\nA sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once.", "examples": "Input: A = [1,3,2,4], B = [3,1,2,4]\nOutput: [0,2,3,4]", "link": "https://leetcode.com/problems/find-the-prefix-common-array-of-two-arrays/", "difficulty": null, "categories": ["Array"], "code": "def findThePrefixCommonArray(arr1: list, arr2: list) -> list:\n  max = len(arr1) if len(arr1) > len(arr2) else len(arr2)\n  seen = set()\n  curCount = 0\n  ret = []\n  for i in range(max):\n    cur1 = arr1[i]\n    cur2 = arr2[i]\n    if cur1 in seen:\n      curCount += 1\n    else:\n      seen.add(cur1)\n    if cur2 in seen:\n      curCount += 1\n    else:\n      seen.add(cur2)\n    ret.append(curCount)\n  return ret\n", "asserts": ["assert findThePrefixCommonArray([1,3,2,4], [3,1,2,4]) == [0,2,3,4]", "assert findThePrefixCommonArray([1], [1]) == [1]", "assert findThePrefixCommonArray([2,3,1], [3,1,2]) == [0,1,3]"]}, {"author": "Calvin", "UUID": "a9c5e697-af5d-432b-8447-5675d739c728", "question": "Given an array reorder it so that even numbers appear first", "examples": "Input: [1,2,3,4,5,6,7,8,9]\r\nOutput: [8,2,6,4,5,7,3,9,1]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def even_odd_reorder(arr: list) -> list:\n  nextEven = 0\n  nextOdd = len(arr) - 1\n  while nextEven < nextOdd:\n    if arr[nextEven] % 2 == 0:\n      nextEven += 1\n    else:\n      temp = arr[nextEven]\n      arr[nextEven] = arr[nextOdd]\n      arr[nextOdd] = temp\n      nextOdd -= 1\n  return arr\n", "asserts": ["assert even_odd_reorder([1,2,3,4,5,6,7,8,9]) == [8, 2, 6, 4, 5, 7, 3, 9, 1]", "assert even_odd_reorder([]) == []", "assert even_odd_reorder([2, 4, 6, 8]) == [2, 4, 6, 8]", "assert even_odd_reorder([7, 9, 2]) == [2, 9, 7]", "assert even_odd_reorder([10, 13, 17, 16, 15, 12]) == [10, 12, 16, 15, 17, 13]"]}], "category": "Array", "prompt_tokens": 781, "total_tokens": 1073, "completion_tokens": 292, "completion": "Find the longest increasing subsequence (LIS) in an array of integers. The LIS does not need to be contiguous or unique, but it must be strictly increasing, and you should return the length of the LIS.\n\n###Code:\n\n```python\ndef lengthOfLIS(nums: list) -> int:\n    if not nums:\n        return 0\n\n    dp = [1] * len(nums)\n    \n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n                \n    return max(dp)\n\n```\n\n###Testcases:\n\n```python\nassert lengthOfLIS([10, 9, 2, 5, 3, 7, 101, 18]) == 4\nassert lengthOfLIS([0, 1, 0, 3, 2, 3]) == 4\nassert lengthOfLIS([7, 7, 7, 7, 7, 7, 7]) == 1\nassert lengthOfLIS([50]) == 1\nassert lengthOfLIS([3, 5, 6, 2, 5, 4, 19, 5, 6, 7, 12]) == 6\n```\n\n[/Example 3]", "temperature": 0.893}, {"few_shots": [{"author": "Calvin", "UUID": "1aeb3246-4c22-4d34-a48c-db7be8ba1b94", "question": "You are given n activities with their start and finish times. Select the maximum number of activities that can be performed by a single person and return their indexes. Assume that a person can only work on a single activity at a time. \n", "examples": "Input: start  =  {10, 12, 20}, finish =  {20, 25, 30}\nOutput: [0, 2]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "import numpy as np\ndef MaxActivities(s: list, f: list) -> list:\n    indices = np.argsort(f)\n    [s[i] for i in indices]\n    [f[i] for i in indices]\n    result = []\n    n = len(f)\n    i = 0\n    result.append(i)\n    for j in range(1, n):\n        if s[j] >= f[i]:\n            result.append(j)\n            i = j\n    return result\n", "asserts": ["assert MaxActivities([2, 4, 5, 6, 7, 8], [3, 5, 6, 7, 9, 10]) == [0, 1, 2, 3, 4]", "assert MaxActivities([1, 3, 0, 5, 8, 5], [2, 4, 6, 7, 9, 9]) == [0, 1, 3, 4]", "assert MaxActivities([1], [2]) == [0]"]}, {"author": "Calvin", "UUID": "9e45b73f-583d-40ab-b387-e0d1624af07b", "question": "Given two arrays return an array with the set intersection of their common elements", "examples": "Input: arr1 = [1, 2, 3, 4], arr2 = [2, 3]\nOutput: [2, 3]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def array_intersection(arr1: list, arr2: list) -> set:\n  set1 = set(arr1)\n  ret = set([x for x in arr2 if x in set1])\n  return list(ret)\n", "asserts": ["assert set(array_intersection([1,0,2,0,2,0,2,1,1,1], [2,1,0,2,0,2,2,2,1,0])) == {0,1,2}", "assert set(array_intersection([5, 6, 7, 8], [8, 9, 10, 11])) == {8}", "assert set(array_intersection([10, 20, 30], [40, 50, 60])) == set()", "assert set(array_intersection([], [1, 2, 3])) == set()", "assert set(array_intersection([-1, -2, -3], [-3, -4, -5, -6])) == {-3}", "assert set(array_intersection([9, 8, 7], [7, 8, 9, 10, 11, 12])) == {7, 8, 9}", "assert set(array_intersection(['a', 'b', 'c'], ['a', 'd', 'e', 'c'])) == {'a', 'c'}", "assert set(array_intersection(['apple', 'banana'], ['banana', 'cherry'])) == {'banana'}", "assert set(array_intersection([1.1, 2.2, 3.3], [2.2, 4.4])) == {2.2}", "assert set(array_intersection([False, True, False], [True, False, True])) == {True, False}", "assert set(array_intersection([(1, 2), (3, 4)], [(3, 4), (5, 6)])) == {(3, 4)}"]}], "category": "Array", "prompt_tokens": 887, "total_tokens": 1127, "completion_tokens": 240, "completion": "Write a function that takes an array of integers and returns a new array containing only the odd numbers, sorted in descending order. If the input array contains no odd numbers, return an empty list.\n\n###Code: \n\ndef sort_odd_numbers_desc(arr: list) -> list:\n    return sorted((x for x in arr if x % 2 != 0), reverse=True)\n\n###Testcases: \n\nassert sort_odd_numbers_desc([5, 3, 2, 8, 1, 4]) == [5, 3, 1]\nassert sort_odd_numbers_desc([12, 18, 24, 26]) == []\nassert sort_odd_numbers_desc([7, 3, 5, 5, 2, 14, 5]) == [7, 5, 5, 5, 3]\nassert sort_odd_numbers_desc([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == [9, 7, 5, 3, 1]\nassert sort_odd_numbers_desc([]) == []\n\n[/Example 3]", "temperature": 0.833}, {"few_shots": [{"author": "Calvin", "UUID": "1aeb3246-4c22-4d34-a48c-db7be8ba1b94", "question": "You are given n activities with their start and finish times. Select the maximum number of activities that can be performed by a single person and return their indexes. Assume that a person can only work on a single activity at a time. \n", "examples": "Input: start  =  {10, 12, 20}, finish =  {20, 25, 30}\nOutput: [0, 2]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "import numpy as np\ndef MaxActivities(s: list, f: list) -> list:\n    indices = np.argsort(f)\n    [s[i] for i in indices]\n    [f[i] for i in indices]\n    result = []\n    n = len(f)\n    i = 0\n    result.append(i)\n    for j in range(1, n):\n        if s[j] >= f[i]:\n            result.append(j)\n            i = j\n    return result\n", "asserts": ["assert MaxActivities([2, 4, 5, 6, 7, 8], [3, 5, 6, 7, 9, 10]) == [0, 1, 2, 3, 4]", "assert MaxActivities([1, 3, 0, 5, 8, 5], [2, 4, 6, 7, 9, 9]) == [0, 1, 3, 4]", "assert MaxActivities([1], [2]) == [0]"]}, {"author": "Calvin", "UUID": "48c6aa37-e00d-4b55-9afc-6b1cf2a1aff2", "question": "There are N Mice and N holes are placed in a straight line. Each hole can accommodate only 1 mouse. A mouse can stay at his position, move one step right from x to x + 1, or move one step left from x to x -1. Any of these moves consumes 1 minute. Assign mice to holes so that the time when the last mouse gets inside a hole is minimized.\nYou are given a list of mice and hole positions as integer scalers.\n", "examples": "Input: Mices = [0, 10, 2, 3], Holes = [3, 2, 23, 0]\nOutput: 13", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def assignHole(mices: list, holes: list) -> int:\n    for i,j in zip(mices,holes):\n        if i<0 or j<0:\n            return -1\n    if (len(mices) != len(holes)):\n        return -1\n    mices.sort()\n    holes.sort()\n    Max = 0\n     \n    for i in range(len(holes)):\n        if (Max < abs(mices[i] - holes[i])):\n            Max = abs(mices[i] - holes[i])\n     \n    return Max\n", "asserts": ["assert assignHole([1, 2, 3, 4], [4, 3, 2, 1]) == 0", "assert assignHole([10, 20, 30, 40], [15, 25, 35, 45]) == 5", "assert assignHole([1, 4, 9, 15], [10, 13, 7, 20]) == 6", "assert assignHole([0], [0]) == 0", "assert assignHole([1, 2], [3]) == -1  # Edge case with non-equal amount of mice and holes", "assert assignHole([5, 5, 5], [5, 5, 5]) == 0  # Edge case with all mice and holes at the same position", "assert assignHole([10, 10, 10, 10], [10, 9, 8, 7]) == 3  # Edge case with multiple mice starting at the same position", "assert assignHole([1,1 ,1, 1, 1, 1, 1, 1, 1, 1], [2,2,2,2,2,2 ,2, 2, 2, 2]) == 1 # Edge case with multiple mice and holes at the same positions", "assert assignHole([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == 1 # Edge case with incremental positions"]}], "category": "Array", "prompt_tokens": 1068, "total_tokens": 1538, "completion_tokens": 470, "completion": "Write a function to rotate an array to the right by k steps, where k is non-negative. After rotating the array, return the result. The array may contain integers and should not be modified in place; instead, produce a new array as the result of the rotation.\n\n###Code:\n\ndef rotateArray(nums: list, k: int) -> list:\n    if not nums:  # Check if the list is empty\n        return nums\n    k = k % len(nums)  # To handle if k is greater than the length of nums\n    rotated_nums = nums[-k:] + nums[:-k]  # Rotate the array\n    return rotated_nums\n\n###Testcases:\n\n# Example test cases\nassert rotateArray([1,2,3,4,5,6,7], 3) == [5,6,7,1,2,3,4]\nassert rotateArray([-1,-100,3,99], 2) == [3,99,-1,-100]\n\n# Test cases with edge scenarios\nassert rotateArray([], 2) == []  # Rotating an empty array\nassert rotateArray([1], 2) == [1]  # Single element, rotated any number of times should remain the same\nassert rotateArray([1, 2], 2) == [1, 2]  # Rotating by the number of elements should remain the same\nassert rotateArray([1, 2, 3], 0) == [1, 2, 3]  # Rotating by 0 should remain the same\nassert rotateArray([1, 2, 3], -1) == [2, 3, 1]  # Negative rotation should rotate to the left\nassert rotateArray([1, 2, 3, 4, 5], 10) == [1, 2, 3, 4, 5]  # Rotation by a multiple of the number of elements\nassert rotateArray([1, 2, 3, 4, 5], 12) == [4, 5, 1, 2, 3]  # Rotation by a number plus a multiple of the number of elements\n\n[/Example 3]", "temperature": 0.866}, {"few_shots": [{"author": "Calvin", "UUID": "9e45b73f-583d-40ab-b387-e0d1624af07b", "question": "Given two arrays return an array with the set intersection of their common elements", "examples": "Input: arr1 = [1, 2, 3, 4], arr2 = [2, 3]\nOutput: [2, 3]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def array_intersection(arr1: list, arr2: list) -> set:\n  set1 = set(arr1)\n  ret = set([x for x in arr2 if x in set1])\n  return list(ret)\n", "asserts": ["assert set(array_intersection([1,0,2,0,2,0,2,1,1,1], [2,1,0,2,0,2,2,2,1,0])) == {0,1,2}", "assert set(array_intersection([5, 6, 7, 8], [8, 9, 10, 11])) == {8}", "assert set(array_intersection([10, 20, 30], [40, 50, 60])) == set()", "assert set(array_intersection([], [1, 2, 3])) == set()", "assert set(array_intersection([-1, -2, -3], [-3, -4, -5, -6])) == {-3}", "assert set(array_intersection([9, 8, 7], [7, 8, 9, 10, 11, 12])) == {7, 8, 9}", "assert set(array_intersection(['a', 'b', 'c'], ['a', 'd', 'e', 'c'])) == {'a', 'c'}", "assert set(array_intersection(['apple', 'banana'], ['banana', 'cherry'])) == {'banana'}", "assert set(array_intersection([1.1, 2.2, 3.3], [2.2, 4.4])) == {2.2}", "assert set(array_intersection([False, True, False], [True, False, True])) == {True, False}", "assert set(array_intersection([(1, 2), (3, 4)], [(3, 4), (5, 6)])) == {(3, 4)}"]}, {"author": "Calvin", "UUID": "fb94082f-4627-4f5a-b280-08d869823d70", "question": "You are given an array of people, people, which are the attributes of some people in a queue (not necessarily in order). Each people[i] = [hi, ki] represents the ith person of height hi with exactly ki other people in front who have a height greater than or equal to hi.\n\nReconstruct and return the queue that is represented by the input array people. The returned queue should be formatted as an array queue, where queue[j] = [hj, kj] is the attributes of the jth person in the queue (queue[0] is the person at the front of the queue).\n", "examples": "Input:  [[7, 0], [4, 4], [7, 1], [5, 0], [6, 1], [5, 2]]\nOutput: [[5, 0], [4, 1], [7, 0], [5, 2], [6, 1], [7, 1]]\n\nInput:  [[6, 0], [5, 0], [4, 0], [3, 2], [2, 2], [1, 4]]\nOutput: [[4, 0], [5, 0], [2, 2], [3, 2], [1, 4], [6, 0]]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "\ndef reconstructQueue(people: list) -> list:\n    output=[] \n    people.sort(key=lambda x: (-x[0], x[1]))                \n    for a in people:\n        output.insert(a[1], a)\n    \n    return output\n", "asserts": ["assert reconstructQueue([[8,1],[5,0],[6,1],[5,2],[4,4],[7,1]]) == [[5, 0], [8, 1], [5, 2], [6, 1], [4, 4], [7, 1]]", "assert reconstructQueue([[12,0], [6,3], [4,4], [9,2], [7,1]]) == [[12, 0], [7, 1], [9, 2], [6, 3], [4, 4]]", "assert reconstructQueue([[2,0], [1,1]]) == [[2, 0], [1, 1]]", "assert reconstructQueue([[3,0], [3,2], [3,1]]) == [[3, 0], [3, 1], [3, 2]]"]}], "category": "Array", "prompt_tokens": 983, "total_tokens": 1354, "completion_tokens": 371, "completion": "Write a function that rotates an array to the right by `k` steps, where `k` is non-negative. This rotation means that each element is shifted right by `k` positions, and the last `k` elements of the array are moved to the beginning.\n\n###Code: \n\ndef rotate_array(nums: list, k: int) -> None:\n    \"\"\"\n    Rotate the array to the right by k steps in-place.\n    \"\"\"\n    k = k % len(nums)  # In case k is greater than the length of the array\n    nums[:] = nums[-k:] + nums[:-k]  # Slice the array and concatenate\n\n###Testcases: \n\nassert (a := rotate_array([1,2,3,4,5,6,7], 3)) is None and a == None and (test_array := [1,2,3,4,5,6,7]) and rotate_array(test_array, 3) or test_array == [5,6,7,1,2,3,4]\nassert (a := rotate_array([-1,-100,3,99], 2)) is None and a == None and (test_array := [-1,-100,3,99]) and rotate_array(test_array, 2) or test_array == [3,99,-1,-100]\nassert (a := rotate_array([1], 0)) is None and a == None and (test_array := [1]) and rotate_array(test_array, 0) or test_array == [1]\nassert (a := rotate_array([1,2], 5)) is None and a == None and (test_array := [1,2]) and rotate_array(test_array, 5) or test_array == [2,1]\n\n[/Example 3]", "temperature": 0.688}, {"few_shots": [{"author": "Calvin", "UUID": "fb94082f-4627-4f5a-b280-08d869823d70", "question": "You are given an array of people, people, which are the attributes of some people in a queue (not necessarily in order). Each people[i] = [hi, ki] represents the ith person of height hi with exactly ki other people in front who have a height greater than or equal to hi.\n\nReconstruct and return the queue that is represented by the input array people. The returned queue should be formatted as an array queue, where queue[j] = [hj, kj] is the attributes of the jth person in the queue (queue[0] is the person at the front of the queue).\n", "examples": "Input:  [[7, 0], [4, 4], [7, 1], [5, 0], [6, 1], [5, 2]]\nOutput: [[5, 0], [4, 1], [7, 0], [5, 2], [6, 1], [7, 1]]\n\nInput:  [[6, 0], [5, 0], [4, 0], [3, 2], [2, 2], [1, 4]]\nOutput: [[4, 0], [5, 0], [2, 2], [3, 2], [1, 4], [6, 0]]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "\ndef reconstructQueue(people: list) -> list:\n    output=[] \n    people.sort(key=lambda x: (-x[0], x[1]))                \n    for a in people:\n        output.insert(a[1], a)\n    \n    return output\n", "asserts": ["assert reconstructQueue([[8,1],[5,0],[6,1],[5,2],[4,4],[7,1]]) == [[5, 0], [8, 1], [5, 2], [6, 1], [4, 4], [7, 1]]", "assert reconstructQueue([[12,0], [6,3], [4,4], [9,2], [7,1]]) == [[12, 0], [7, 1], [9, 2], [6, 3], [4, 4]]", "assert reconstructQueue([[2,0], [1,1]]) == [[2, 0], [1, 1]]", "assert reconstructQueue([[3,0], [3,2], [3,1]]) == [[3, 0], [3, 1], [3, 2]]"]}, {"author": "Calvin", "UUID": "9e45b73f-583d-40ab-b387-e0d1624af07b", "question": "Given two arrays return an array with the set intersection of their common elements", "examples": "Input: arr1 = [1, 2, 3, 4], arr2 = [2, 3]\nOutput: [2, 3]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def array_intersection(arr1: list, arr2: list) -> set:\n  set1 = set(arr1)\n  ret = set([x for x in arr2 if x in set1])\n  return list(ret)\n", "asserts": ["assert set(array_intersection([1,0,2,0,2,0,2,1,1,1], [2,1,0,2,0,2,2,2,1,0])) == {0,1,2}", "assert set(array_intersection([5, 6, 7, 8], [8, 9, 10, 11])) == {8}", "assert set(array_intersection([10, 20, 30], [40, 50, 60])) == set()", "assert set(array_intersection([], [1, 2, 3])) == set()", "assert set(array_intersection([-1, -2, -3], [-3, -4, -5, -6])) == {-3}", "assert set(array_intersection([9, 8, 7], [7, 8, 9, 10, 11, 12])) == {7, 8, 9}", "assert set(array_intersection(['a', 'b', 'c'], ['a', 'd', 'e', 'c'])) == {'a', 'c'}", "assert set(array_intersection(['apple', 'banana'], ['banana', 'cherry'])) == {'banana'}", "assert set(array_intersection([1.1, 2.2, 3.3], [2.2, 4.4])) == {2.2}", "assert set(array_intersection([False, True, False], [True, False, True])) == {True, False}", "assert set(array_intersection([(1, 2), (3, 4)], [(3, 4), (5, 6)])) == {(3, 4)}"]}], "category": "Array", "prompt_tokens": 983, "total_tokens": 1379, "completion_tokens": 396, "completion": "Given an array of integers `nums` and an integer `k`, find out whether there are two distinct indices `i` and `j` in the array such that `nums[i] == nums[j]` and the absolute difference between `i` and `j` is at most `k`.\n\n###Code:\n\n```python\ndef contains_nearby_duplicate(nums: list, k: int) -> bool:\n    num_dict = {}\n    for i in range(len(nums)):\n        if nums[i] in num_dict and i - num_dict[nums[i]] <= k:\n            return True\n        num_dict[nums[i]] = i\n    return False\n```\n\n###Testcases:\n\n```python\nassert contains_nearby_duplicate([1, 2, 3, 1], 3) == True\nassert contains_nearby_duplicate([1, 0, 1, 1], 1) == True\nassert contains_nearby_duplicate([1, 2, 3, 1, 2, 3], 2) == False\nassert contains_nearby_duplicate([99, 99], 2) == True\nassert contains_nearby_duplicate([2, 4, -1, -1, 2], 1) == True\nassert contains_nearby_duplicate([], 0) == False\nassert contains_nearby_duplicate([1], 1) == False\nassert contains_nearby_duplicate([1, 2, 3, 4, 5, 6, 7, 8, 9, 9], 3) == True\nassert contains_nearby_duplicate([10, 5, 3, 4, 3, 5, 6], 2) == False\nassert contains_nearby_duplicate([0, 1, 2, 3, 4, 0], 4) == True\n```\n\n[/Example 3]", "temperature": 0.851}, {"few_shots": [{"author": "Calvin", "UUID": "a9c5e697-af5d-432b-8447-5675d739c728", "question": "Given an array reorder it so that even numbers appear first", "examples": "Input: [1,2,3,4,5,6,7,8,9]\r\nOutput: [8,2,6,4,5,7,3,9,1]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def even_odd_reorder(arr: list) -> list:\n  nextEven = 0\n  nextOdd = len(arr) - 1\n  while nextEven < nextOdd:\n    if arr[nextEven] % 2 == 0:\n      nextEven += 1\n    else:\n      temp = arr[nextEven]\n      arr[nextEven] = arr[nextOdd]\n      arr[nextOdd] = temp\n      nextOdd -= 1\n  return arr\n", "asserts": ["assert even_odd_reorder([1,2,3,4,5,6,7,8,9]) == [8, 2, 6, 4, 5, 7, 3, 9, 1]", "assert even_odd_reorder([]) == []", "assert even_odd_reorder([2, 4, 6, 8]) == [2, 4, 6, 8]", "assert even_odd_reorder([7, 9, 2]) == [2, 9, 7]", "assert even_odd_reorder([10, 13, 17, 16, 15, 12]) == [10, 12, 16, 15, 17, 13]"]}, {"author": "Calvin", "UUID": "1aeb3246-4c22-4d34-a48c-db7be8ba1b94", "question": "You are given n activities with their start and finish times. Select the maximum number of activities that can be performed by a single person and return their indexes. Assume that a person can only work on a single activity at a time. \n", "examples": "Input: start  =  {10, 12, 20}, finish =  {20, 25, 30}\nOutput: [0, 2]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "import numpy as np\ndef MaxActivities(s: list, f: list) -> list:\n    indices = np.argsort(f)\n    [s[i] for i in indices]\n    [f[i] for i in indices]\n    result = []\n    n = len(f)\n    i = 0\n    result.append(i)\n    for j in range(1, n):\n        if s[j] >= f[i]:\n            result.append(j)\n            i = j\n    return result\n", "asserts": ["assert MaxActivities([2, 4, 5, 6, 7, 8], [3, 5, 6, 7, 9, 10]) == [0, 1, 2, 3, 4]", "assert MaxActivities([1, 3, 0, 5, 8, 5], [2, 4, 6, 7, 9, 9]) == [0, 1, 3, 4]", "assert MaxActivities([1], [2]) == [0]"]}], "category": "Array", "prompt_tokens": 746, "total_tokens": 997, "completion_tokens": 251, "completion": "Given an array of integers, find the pair of adjacent elements that has the largest product and return that product.\n\n###Code: \n\ndef max_adjacent_product(arr: list) -> int:\n    if len(arr) < 2:\n        raise ValueError(\"Array must contain at least two elements\")\n    max_product = arr[0] * arr[1]\n    for i in range(1, len(arr) - 1):\n        product = arr[i] * arr[i + 1]\n        if product > max_product:\n            max_product = product\n    return max_product\n\n###Testcases: \n\nassert max_adjacent_product([3, 6, -2, -5, 7, 3]) == 21\nassert max_adjacent_product([-1, -2, -3, -4, -5]) == 20\nassert max_adjacent_product([1, 2, 3, 4, 5, 6]) == 30\nassert max_adjacent_product([-1, 5, 10, -10, -1]) == 100\nassert max_adjacent_product([0, 10, -20, 0]) == 0\n\n[/Example 3]", "temperature": 0.87}, {"few_shots": [{"author": "Calvin", "UUID": "1aeb3246-4c22-4d34-a48c-db7be8ba1b94", "question": "You are given n activities with their start and finish times. Select the maximum number of activities that can be performed by a single person and return their indexes. Assume that a person can only work on a single activity at a time. \n", "examples": "Input: start  =  {10, 12, 20}, finish =  {20, 25, 30}\nOutput: [0, 2]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "import numpy as np\ndef MaxActivities(s: list, f: list) -> list:\n    indices = np.argsort(f)\n    [s[i] for i in indices]\n    [f[i] for i in indices]\n    result = []\n    n = len(f)\n    i = 0\n    result.append(i)\n    for j in range(1, n):\n        if s[j] >= f[i]:\n            result.append(j)\n            i = j\n    return result\n", "asserts": ["assert MaxActivities([2, 4, 5, 6, 7, 8], [3, 5, 6, 7, 9, 10]) == [0, 1, 2, 3, 4]", "assert MaxActivities([1, 3, 0, 5, 8, 5], [2, 4, 6, 7, 9, 9]) == [0, 1, 3, 4]", "assert MaxActivities([1], [2]) == [0]"]}, {"author": "Calvin", "UUID": "9e45b73f-583d-40ab-b387-e0d1624af07b", "question": "Given two arrays return an array with the set intersection of their common elements", "examples": "Input: arr1 = [1, 2, 3, 4], arr2 = [2, 3]\nOutput: [2, 3]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def array_intersection(arr1: list, arr2: list) -> set:\n  set1 = set(arr1)\n  ret = set([x for x in arr2 if x in set1])\n  return list(ret)\n", "asserts": ["assert set(array_intersection([1,0,2,0,2,0,2,1,1,1], [2,1,0,2,0,2,2,2,1,0])) == {0,1,2}", "assert set(array_intersection([5, 6, 7, 8], [8, 9, 10, 11])) == {8}", "assert set(array_intersection([10, 20, 30], [40, 50, 60])) == set()", "assert set(array_intersection([], [1, 2, 3])) == set()", "assert set(array_intersection([-1, -2, -3], [-3, -4, -5, -6])) == {-3}", "assert set(array_intersection([9, 8, 7], [7, 8, 9, 10, 11, 12])) == {7, 8, 9}", "assert set(array_intersection(['a', 'b', 'c'], ['a', 'd', 'e', 'c'])) == {'a', 'c'}", "assert set(array_intersection(['apple', 'banana'], ['banana', 'cherry'])) == {'banana'}", "assert set(array_intersection([1.1, 2.2, 3.3], [2.2, 4.4])) == {2.2}", "assert set(array_intersection([False, True, False], [True, False, True])) == {True, False}", "assert set(array_intersection([(1, 2), (3, 4)], [(3, 4), (5, 6)])) == {(3, 4)}"]}], "category": "Array", "prompt_tokens": 887, "total_tokens": 1243, "completion_tokens": 356, "completion": "Write a function that takes an array of integers and rotates it to the right by 'k' steps, where 'k' is a non-negative number provided as an argument. The function should not return anything, but the array should be modified in-place with O(1) extra memory.\n\n###Code:\n\ndef rotate_array(nums: list, k: int) -> None:\n    n = len(nums)\n    k = k % n\n    nums[:] = nums[-k:] + nums[:-k]\n\n###Testcases:\n\n# Rotate array [1,2,3,4,5,6,7] by 3 steps\nnums = [1,2,3,4,5,6,7]\nrotate_array(nums, 3)\nassert nums == [5,6,7,1,2,3,4]\n\n# Rotate array [-1,-100,3,99] by 2 steps\nnums = [-1,-100,3,99]\nrotate_array(nums, 2)\nassert nums == [3,99,-1,-100]\n\n# Rotate array [1,2,3] by 4 steps (same as rotating by 1 step since 4 % 3 == 1)\nnums = [1,2,3]\nrotate_array(nums, 4)\nassert nums == [3,1,2]\n\n# Rotate array [] by any number of steps should leave an empty array unchanged\nnums = []\nrotate_array(nums, 10)\nassert nums == []\n\n# Rotate array [1] by 1000 steps should leave the array unchanged since 1000 % 1 == 0\nnums = [1]\nrotate_array(nums, 1000)\nassert nums == [1]\n\n[/Example 3]", "temperature": 0.932}, {"few_shots": [{"author": "Calvin", "UUID": "48c6aa37-e00d-4b55-9afc-6b1cf2a1aff2", "question": "There are N Mice and N holes are placed in a straight line. Each hole can accommodate only 1 mouse. A mouse can stay at his position, move one step right from x to x + 1, or move one step left from x to x -1. Any of these moves consumes 1 minute. Assign mice to holes so that the time when the last mouse gets inside a hole is minimized.\nYou are given a list of mice and hole positions as integer scalers.\n", "examples": "Input: Mices = [0, 10, 2, 3], Holes = [3, 2, 23, 0]\nOutput: 13", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def assignHole(mices: list, holes: list) -> int:\n    for i,j in zip(mices,holes):\n        if i<0 or j<0:\n            return -1\n    if (len(mices) != len(holes)):\n        return -1\n    mices.sort()\n    holes.sort()\n    Max = 0\n     \n    for i in range(len(holes)):\n        if (Max < abs(mices[i] - holes[i])):\n            Max = abs(mices[i] - holes[i])\n     \n    return Max\n", "asserts": ["assert assignHole([1, 2, 3, 4], [4, 3, 2, 1]) == 0", "assert assignHole([10, 20, 30, 40], [15, 25, 35, 45]) == 5", "assert assignHole([1, 4, 9, 15], [10, 13, 7, 20]) == 6", "assert assignHole([0], [0]) == 0", "assert assignHole([1, 2], [3]) == -1  # Edge case with non-equal amount of mice and holes", "assert assignHole([5, 5, 5], [5, 5, 5]) == 0  # Edge case with all mice and holes at the same position", "assert assignHole([10, 10, 10, 10], [10, 9, 8, 7]) == 3  # Edge case with multiple mice starting at the same position", "assert assignHole([1,1 ,1, 1, 1, 1, 1, 1, 1, 1], [2,2,2,2,2,2 ,2, 2, 2, 2]) == 1 # Edge case with multiple mice and holes at the same positions", "assert assignHole([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == 1 # Edge case with incremental positions"]}, {"author": "Calvin", "UUID": "9e45b73f-583d-40ab-b387-e0d1624af07b", "question": "Given two arrays return an array with the set intersection of their common elements", "examples": "Input: arr1 = [1, 2, 3, 4], arr2 = [2, 3]\nOutput: [2, 3]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def array_intersection(arr1: list, arr2: list) -> set:\n  set1 = set(arr1)\n  ret = set([x for x in arr2 if x in set1])\n  return list(ret)\n", "asserts": ["assert set(array_intersection([1,0,2,0,2,0,2,1,1,1], [2,1,0,2,0,2,2,2,1,0])) == {0,1,2}", "assert set(array_intersection([5, 6, 7, 8], [8, 9, 10, 11])) == {8}", "assert set(array_intersection([10, 20, 30], [40, 50, 60])) == set()", "assert set(array_intersection([], [1, 2, 3])) == set()", "assert set(array_intersection([-1, -2, -3], [-3, -4, -5, -6])) == {-3}", "assert set(array_intersection([9, 8, 7], [7, 8, 9, 10, 11, 12])) == {7, 8, 9}", "assert set(array_intersection(['a', 'b', 'c'], ['a', 'd', 'e', 'c'])) == {'a', 'c'}", "assert set(array_intersection(['apple', 'banana'], ['banana', 'cherry'])) == {'banana'}", "assert set(array_intersection([1.1, 2.2, 3.3], [2.2, 4.4])) == {2.2}", "assert set(array_intersection([False, True, False], [True, False, True])) == {True, False}", "assert set(array_intersection([(1, 2), (3, 4)], [(3, 4), (5, 6)])) == {(3, 4)}"]}], "category": "Array", "prompt_tokens": 1208, "total_tokens": 1616, "completion_tokens": 408, "completion": "Given an array of integers and a target sum, return the indices of the two numbers such that they add up to the given target sum. You may assume that each input would have exactly one solution, and you may not use the same element twice. You can return the answer in any order.\n\n###Code: \n\ndef two_sum(numbers: list, target: int) -> list:\n    num_dict = {}\n    for i, num in enumerate(numbers):\n        complement = target - num\n        if complement in num_dict:\n            return [num_dict[complement], i]\n        num_dict[num] = i\n    return []\n\n###Testcases: \n\nassert two_sum([2, 7, 11, 15], 9) == [0, 1]\nassert two_sum([3, 2, 4], 6) == [1, 2]\nassert two_sum([3, 3], 6) == [0, 1]\nassert two_sum([-1, -2, -3, -4, -5], -8) == [2, 4]\nassert two_sum([1, 5, 3, 7, 9], 12) == [1, 3]\nassert two_sum([20, 50, 40, 25, 30, 10], 45) == [3, 5]\nassert two_sum([1, 2, 3, 4, 5, 6], 11) == [4, 5]\nassert two_sum([14, 15, 16, 22, 53, 60], 38) == [2, 3]\nassert two_sum([1, 4, 5, 11, 12], 16) == [2, 3]\nassert two_sum([1, 3, 5, 7, 9], 8) == [0, 3]\n\n[/Example 3]", "temperature": 0.909}, {"few_shots": [{"author": "Calvin", "UUID": "48c6aa37-e00d-4b55-9afc-6b1cf2a1aff2", "question": "There are N Mice and N holes are placed in a straight line. Each hole can accommodate only 1 mouse. A mouse can stay at his position, move one step right from x to x + 1, or move one step left from x to x -1. Any of these moves consumes 1 minute. Assign mice to holes so that the time when the last mouse gets inside a hole is minimized.\nYou are given a list of mice and hole positions as integer scalers.\n", "examples": "Input: Mices = [0, 10, 2, 3], Holes = [3, 2, 23, 0]\nOutput: 13", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def assignHole(mices: list, holes: list) -> int:\n    for i,j in zip(mices,holes):\n        if i<0 or j<0:\n            return -1\n    if (len(mices) != len(holes)):\n        return -1\n    mices.sort()\n    holes.sort()\n    Max = 0\n     \n    for i in range(len(holes)):\n        if (Max < abs(mices[i] - holes[i])):\n            Max = abs(mices[i] - holes[i])\n     \n    return Max\n", "asserts": ["assert assignHole([1, 2, 3, 4], [4, 3, 2, 1]) == 0", "assert assignHole([10, 20, 30, 40], [15, 25, 35, 45]) == 5", "assert assignHole([1, 4, 9, 15], [10, 13, 7, 20]) == 6", "assert assignHole([0], [0]) == 0", "assert assignHole([1, 2], [3]) == -1  # Edge case with non-equal amount of mice and holes", "assert assignHole([5, 5, 5], [5, 5, 5]) == 0  # Edge case with all mice and holes at the same position", "assert assignHole([10, 10, 10, 10], [10, 9, 8, 7]) == 3  # Edge case with multiple mice starting at the same position", "assert assignHole([1,1 ,1, 1, 1, 1, 1, 1, 1, 1], [2,2,2,2,2,2 ,2, 2, 2, 2]) == 1 # Edge case with multiple mice and holes at the same positions", "assert assignHole([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == 1 # Edge case with incremental positions"]}, {"author": "Calvin", "UUID": "f795bda7-9822-4bc5-9c7e-b9c0f2752085", "question": "You are given two 0-indexed integer permutations A and B of length n.\n\nA prefix common array of A and B is an array C such that C[i] is equal to the count of numbers that are present at or before the index i in both A and B.\n\nReturn the prefix common array of A and B.\n\nA sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once.", "examples": "Input: A = [1,3,2,4], B = [3,1,2,4]\nOutput: [0,2,3,4]", "link": "https://leetcode.com/problems/find-the-prefix-common-array-of-two-arrays/", "difficulty": null, "categories": ["Array"], "code": "def findThePrefixCommonArray(arr1: list, arr2: list) -> list:\n  max = len(arr1) if len(arr1) > len(arr2) else len(arr2)\n  seen = set()\n  curCount = 0\n  ret = []\n  for i in range(max):\n    cur1 = arr1[i]\n    cur2 = arr2[i]\n    if cur1 in seen:\n      curCount += 1\n    else:\n      seen.add(cur1)\n    if cur2 in seen:\n      curCount += 1\n    else:\n      seen.add(cur2)\n    ret.append(curCount)\n  return ret\n", "asserts": ["assert findThePrefixCommonArray([1,3,2,4], [3,1,2,4]) == [0,2,3,4]", "assert findThePrefixCommonArray([1], [1]) == [1]", "assert findThePrefixCommonArray([2,3,1], [3,1,2]) == [0,1,3]"]}], "category": "Array", "prompt_tokens": 1103, "total_tokens": 1578, "completion_tokens": 475, "completion": "Given an array of integers, find the length of the longest subsequence such that elements in the subsequence are consecutive integers, the consecutive numbers can be in any order.\n\n###Code: \n\ndef longestConsecutiveSubsequence(arr: list) -> int:\n    if not arr:\n        return 0\n\n    unique_nums = set(arr)\n    longest_streak = 0\n\n    for num in unique_nums:\n        # Check if it's the start of a sequence\n        if num - 1 not in unique_nums:\n            current_num = num\n            current_streak = 1\n\n            # Check the length of the sequence\n            while current_num + 1 in unique_nums:\n                current_num += 1\n                current_streak += 1\n\n            # Update the max length\n            longest_streak = max(longest_streak, current_streak)\n\n    return longest_streak\n\n###Testcases:\n\nassert longestConsecutiveSubsequence([1, 9, 3, 10, 4, 20, 2]) == 4\nassert longestConsecutiveSubsequence([8, 20, 7, 30]) == 2\nassert longestConsecutiveSubsequence([20, 30, 40]) == 1\nassert longestConsecutiveSubsequence([100, 4, 200, 1, 3, 2]) == 4\nassert longestConsecutiveSubsequence([]) == 0  # Edge case with empty array\nassert longestConsecutiveSubsequence([10]) == 1  # Edge case with single element\nassert longestConsecutiveSubsequence([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == 10  # Edge case with already consecutive numbers\nassert longestConsecutiveSubsequence([10, 9, 8, 7, 6, 5, 4, 3, 2, 1]) == 10  # Edge case with reverse consecutive numbers\nassert longestConsecutiveSubsequence([1, 3, 5, 7, 9, 11, 13, 15, 17, 19]) == 1  # Edge case with no consecutive numbers\n\n[/Example 3]", "temperature": 0.721}, {"few_shots": [{"author": "Calvin", "UUID": "f795bda7-9822-4bc5-9c7e-b9c0f2752085", "question": "You are given two 0-indexed integer permutations A and B of length n.\n\nA prefix common array of A and B is an array C such that C[i] is equal to the count of numbers that are present at or before the index i in both A and B.\n\nReturn the prefix common array of A and B.\n\nA sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once.", "examples": "Input: A = [1,3,2,4], B = [3,1,2,4]\nOutput: [0,2,3,4]", "link": "https://leetcode.com/problems/find-the-prefix-common-array-of-two-arrays/", "difficulty": null, "categories": ["Array"], "code": "def findThePrefixCommonArray(arr1: list, arr2: list) -> list:\n  max = len(arr1) if len(arr1) > len(arr2) else len(arr2)\n  seen = set()\n  curCount = 0\n  ret = []\n  for i in range(max):\n    cur1 = arr1[i]\n    cur2 = arr2[i]\n    if cur1 in seen:\n      curCount += 1\n    else:\n      seen.add(cur1)\n    if cur2 in seen:\n      curCount += 1\n    else:\n      seen.add(cur2)\n    ret.append(curCount)\n  return ret\n", "asserts": ["assert findThePrefixCommonArray([1,3,2,4], [3,1,2,4]) == [0,2,3,4]", "assert findThePrefixCommonArray([1], [1]) == [1]", "assert findThePrefixCommonArray([2,3,1], [3,1,2]) == [0,1,3]"]}, {"author": "Calvin", "UUID": "a9c5e697-af5d-432b-8447-5675d739c728", "question": "Given an array reorder it so that even numbers appear first", "examples": "Input: [1,2,3,4,5,6,7,8,9]\r\nOutput: [8,2,6,4,5,7,3,9,1]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def even_odd_reorder(arr: list) -> list:\n  nextEven = 0\n  nextOdd = len(arr) - 1\n  while nextEven < nextOdd:\n    if arr[nextEven] % 2 == 0:\n      nextEven += 1\n    else:\n      temp = arr[nextEven]\n      arr[nextEven] = arr[nextOdd]\n      arr[nextOdd] = temp\n      nextOdd -= 1\n  return arr\n", "asserts": ["assert even_odd_reorder([1,2,3,4,5,6,7,8,9]) == [8, 2, 6, 4, 5, 7, 3, 9, 1]", "assert even_odd_reorder([]) == []", "assert even_odd_reorder([2, 4, 6, 8]) == [2, 4, 6, 8]", "assert even_odd_reorder([7, 9, 2]) == [2, 9, 7]", "assert even_odd_reorder([10, 13, 17, 16, 15, 12]) == [10, 12, 16, 15, 17, 13]"]}], "category": "Array", "prompt_tokens": 781, "total_tokens": 943, "completion_tokens": 162, "completion": "Given a non-empty array of integers nums, every element appears twice except for one. Find that single one.\n\nYou must implement a solution with a linear runtime complexity and use only constant extra space.\n\n###Code: \n\ndef singleNumber(nums: list) -> int:\n    single = 0\n    for num in nums:\n        single ^= num\n    return single\n\n\n###Testcases: \n\nassert singleNumber([2,2,1]) == 1\nassert singleNumber([4,1,2,1,2]) == 4\nassert singleNumber([1]) == 1\nassert singleNumber([1,3,1,-1,3]) == -1\nassert singleNumber([0,1,0,1,0]) == 0\n\n[/Example 3]", "temperature": 0.652}, {"few_shots": [{"author": "Calvin", "UUID": "48c6aa37-e00d-4b55-9afc-6b1cf2a1aff2", "question": "There are N Mice and N holes are placed in a straight line. Each hole can accommodate only 1 mouse. A mouse can stay at his position, move one step right from x to x + 1, or move one step left from x to x -1. Any of these moves consumes 1 minute. Assign mice to holes so that the time when the last mouse gets inside a hole is minimized.\nYou are given a list of mice and hole positions as integer scalers.\n", "examples": "Input: Mices = [0, 10, 2, 3], Holes = [3, 2, 23, 0]\nOutput: 13", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def assignHole(mices: list, holes: list) -> int:\n    for i,j in zip(mices,holes):\n        if i<0 or j<0:\n            return -1\n    if (len(mices) != len(holes)):\n        return -1\n    mices.sort()\n    holes.sort()\n    Max = 0\n     \n    for i in range(len(holes)):\n        if (Max < abs(mices[i] - holes[i])):\n            Max = abs(mices[i] - holes[i])\n     \n    return Max\n", "asserts": ["assert assignHole([1, 2, 3, 4], [4, 3, 2, 1]) == 0", "assert assignHole([10, 20, 30, 40], [15, 25, 35, 45]) == 5", "assert assignHole([1, 4, 9, 15], [10, 13, 7, 20]) == 6", "assert assignHole([0], [0]) == 0", "assert assignHole([1, 2], [3]) == -1  # Edge case with non-equal amount of mice and holes", "assert assignHole([5, 5, 5], [5, 5, 5]) == 0  # Edge case with all mice and holes at the same position", "assert assignHole([10, 10, 10, 10], [10, 9, 8, 7]) == 3  # Edge case with multiple mice starting at the same position", "assert assignHole([1,1 ,1, 1, 1, 1, 1, 1, 1, 1], [2,2,2,2,2,2 ,2, 2, 2, 2]) == 1 # Edge case with multiple mice and holes at the same positions", "assert assignHole([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == 1 # Edge case with incremental positions"]}, {"author": "Calvin", "UUID": "1aeb3246-4c22-4d34-a48c-db7be8ba1b94", "question": "You are given n activities with their start and finish times. Select the maximum number of activities that can be performed by a single person and return their indexes. Assume that a person can only work on a single activity at a time. \n", "examples": "Input: start  =  {10, 12, 20}, finish =  {20, 25, 30}\nOutput: [0, 2]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "import numpy as np\ndef MaxActivities(s: list, f: list) -> list:\n    indices = np.argsort(f)\n    [s[i] for i in indices]\n    [f[i] for i in indices]\n    result = []\n    n = len(f)\n    i = 0\n    result.append(i)\n    for j in range(1, n):\n        if s[j] >= f[i]:\n            result.append(j)\n            i = j\n    return result\n", "asserts": ["assert MaxActivities([2, 4, 5, 6, 7, 8], [3, 5, 6, 7, 9, 10]) == [0, 1, 2, 3, 4]", "assert MaxActivities([1, 3, 0, 5, 8, 5], [2, 4, 6, 7, 9, 9]) == [0, 1, 3, 4]", "assert MaxActivities([1], [2]) == [0]"]}], "category": "Array", "prompt_tokens": 1068, "total_tokens": 1461, "completion_tokens": 393, "completion": "Given an array of integers and a number k, find the maximum sum of a subarray of size k.\n\n###Code: \n\ndef maxSumSubarray(arr: list, k: int) -> int:\n    if k > len(arr):\n        return -1  # Edge case where k is larger than array size\n    \n    max_sum = sum(arr[:k])  # Initial sum of the first 'k' elements\n    window_sum = max_sum\n    \n    for i in range(len(arr) - k):\n        window_sum = window_sum - arr[i] + arr[i + k]  # Slide the window forward by 1 element\n        max_sum = max(max_sum, window_sum)\n    \n    return max_sum\n\n###Testcases: \n\nassert maxSumSubarray([1, 4, 2, 10, 23, 3, 1, 0, 20], 4) == 39\nassert maxSumSubarray([1, 1, 1, 1, 1, 1], 2) == 2\nassert maxSumSubarray([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 3) == 27\nassert maxSumSubarray([100, 200, 300, 400], 2) == 700\nassert maxSumSubarray([-1, -2, -3, -4], 2) == -3\nassert maxSumSubarray([2, 3], 3) == -1  # Edge case where k is larger than array size\nassert maxSumSubarray([], 3) == -1  # Edge case with empty array\nassert maxSumSubarray([2, 3], 1) == 3  # Edge case where k is 1\n\n[/Example 3]", "temperature": 0.659}, {"few_shots": [{"author": "Calvin", "UUID": "9e45b73f-583d-40ab-b387-e0d1624af07b", "question": "Given two arrays return an array with the set intersection of their common elements", "examples": "Input: arr1 = [1, 2, 3, 4], arr2 = [2, 3]\nOutput: [2, 3]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def array_intersection(arr1: list, arr2: list) -> set:\n  set1 = set(arr1)\n  ret = set([x for x in arr2 if x in set1])\n  return list(ret)\n", "asserts": ["assert set(array_intersection([1,0,2,0,2,0,2,1,1,1], [2,1,0,2,0,2,2,2,1,0])) == {0,1,2}", "assert set(array_intersection([5, 6, 7, 8], [8, 9, 10, 11])) == {8}", "assert set(array_intersection([10, 20, 30], [40, 50, 60])) == set()", "assert set(array_intersection([], [1, 2, 3])) == set()", "assert set(array_intersection([-1, -2, -3], [-3, -4, -5, -6])) == {-3}", "assert set(array_intersection([9, 8, 7], [7, 8, 9, 10, 11, 12])) == {7, 8, 9}", "assert set(array_intersection(['a', 'b', 'c'], ['a', 'd', 'e', 'c'])) == {'a', 'c'}", "assert set(array_intersection(['apple', 'banana'], ['banana', 'cherry'])) == {'banana'}", "assert set(array_intersection([1.1, 2.2, 3.3], [2.2, 4.4])) == {2.2}", "assert set(array_intersection([False, True, False], [True, False, True])) == {True, False}", "assert set(array_intersection([(1, 2), (3, 4)], [(3, 4), (5, 6)])) == {(3, 4)}"]}, {"author": "Calvin", "UUID": "fb94082f-4627-4f5a-b280-08d869823d70", "question": "You are given an array of people, people, which are the attributes of some people in a queue (not necessarily in order). Each people[i] = [hi, ki] represents the ith person of height hi with exactly ki other people in front who have a height greater than or equal to hi.\n\nReconstruct and return the queue that is represented by the input array people. The returned queue should be formatted as an array queue, where queue[j] = [hj, kj] is the attributes of the jth person in the queue (queue[0] is the person at the front of the queue).\n", "examples": "Input:  [[7, 0], [4, 4], [7, 1], [5, 0], [6, 1], [5, 2]]\nOutput: [[5, 0], [4, 1], [7, 0], [5, 2], [6, 1], [7, 1]]\n\nInput:  [[6, 0], [5, 0], [4, 0], [3, 2], [2, 2], [1, 4]]\nOutput: [[4, 0], [5, 0], [2, 2], [3, 2], [1, 4], [6, 0]]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "\ndef reconstructQueue(people: list) -> list:\n    output=[] \n    people.sort(key=lambda x: (-x[0], x[1]))                \n    for a in people:\n        output.insert(a[1], a)\n    \n    return output\n", "asserts": ["assert reconstructQueue([[8,1],[5,0],[6,1],[5,2],[4,4],[7,1]]) == [[5, 0], [8, 1], [5, 2], [6, 1], [4, 4], [7, 1]]", "assert reconstructQueue([[12,0], [6,3], [4,4], [9,2], [7,1]]) == [[12, 0], [7, 1], [9, 2], [6, 3], [4, 4]]", "assert reconstructQueue([[2,0], [1,1]]) == [[2, 0], [1, 1]]", "assert reconstructQueue([[3,0], [3,2], [3,1]]) == [[3, 0], [3, 1], [3, 2]]"]}], "category": "Array", "prompt_tokens": 983, "total_tokens": 1368, "completion_tokens": 385, "completion": "Write a function that takes an array of integers and returns the length of the longest consecutive elements sequence. The array may contain duplicates and negative numbers.\n\n###Code:\n\ndef longest_consecutive(nums: list) -> int:\n    if not nums:\n        return 0\n    nums_set = set(nums)\n    longest_streak = 1\n    for num in nums_set:\n        if num - 1 not in nums_set:\n            current_num = num\n            current_streak = 1\n            while current_num + 1 in nums_set:\n                current_num += 1\n                current_streak += 1\n            longest_streak = max(longest_streak, current_streak)\n    return longest_streak\n\n###Testcases:\n\nassert longest_consecutive([100, 4, 200, 1, 3, 2]) == 4\nassert longest_consecutive([0, -1]) == 2\nassert longest_consecutive([1, 2, 0, 1]) == 3\nassert longest_consecutive([9, 1, -3, 2, 4, 8, 3, -1, 6, -2, -4, 7]) == 4\nassert longest_consecutive([]) == 0\nassert longest_consecutive([1]) == 1\nassert longest_consecutive([1, 3, 5, 2, 4]) == 5\nassert longest_consecutive([5, 5, 5, 5, 5]) == 1\nassert longest_consecutive([-2, -3, -4, 1, 0]) == 2\nassert longest_consecutive([10, 5, 12, 3, 55, 30, 4, 11, 2]) == 3\n\n[/Example 3]", "temperature": 0.732}, {"few_shots": [{"author": "Calvin", "UUID": "48c6aa37-e00d-4b55-9afc-6b1cf2a1aff2", "question": "There are N Mice and N holes are placed in a straight line. Each hole can accommodate only 1 mouse. A mouse can stay at his position, move one step right from x to x + 1, or move one step left from x to x -1. Any of these moves consumes 1 minute. Assign mice to holes so that the time when the last mouse gets inside a hole is minimized.\nYou are given a list of mice and hole positions as integer scalers.\n", "examples": "Input: Mices = [0, 10, 2, 3], Holes = [3, 2, 23, 0]\nOutput: 13", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def assignHole(mices: list, holes: list) -> int:\n    for i,j in zip(mices,holes):\n        if i<0 or j<0:\n            return -1\n    if (len(mices) != len(holes)):\n        return -1\n    mices.sort()\n    holes.sort()\n    Max = 0\n     \n    for i in range(len(holes)):\n        if (Max < abs(mices[i] - holes[i])):\n            Max = abs(mices[i] - holes[i])\n     \n    return Max\n", "asserts": ["assert assignHole([1, 2, 3, 4], [4, 3, 2, 1]) == 0", "assert assignHole([10, 20, 30, 40], [15, 25, 35, 45]) == 5", "assert assignHole([1, 4, 9, 15], [10, 13, 7, 20]) == 6", "assert assignHole([0], [0]) == 0", "assert assignHole([1, 2], [3]) == -1  # Edge case with non-equal amount of mice and holes", "assert assignHole([5, 5, 5], [5, 5, 5]) == 0  # Edge case with all mice and holes at the same position", "assert assignHole([10, 10, 10, 10], [10, 9, 8, 7]) == 3  # Edge case with multiple mice starting at the same position", "assert assignHole([1,1 ,1, 1, 1, 1, 1, 1, 1, 1], [2,2,2,2,2,2 ,2, 2, 2, 2]) == 1 # Edge case with multiple mice and holes at the same positions", "assert assignHole([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == 1 # Edge case with incremental positions"]}, {"author": "Calvin", "UUID": "1aeb3246-4c22-4d34-a48c-db7be8ba1b94", "question": "You are given n activities with their start and finish times. Select the maximum number of activities that can be performed by a single person and return their indexes. Assume that a person can only work on a single activity at a time. \n", "examples": "Input: start  =  {10, 12, 20}, finish =  {20, 25, 30}\nOutput: [0, 2]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "import numpy as np\ndef MaxActivities(s: list, f: list) -> list:\n    indices = np.argsort(f)\n    [s[i] for i in indices]\n    [f[i] for i in indices]\n    result = []\n    n = len(f)\n    i = 0\n    result.append(i)\n    for j in range(1, n):\n        if s[j] >= f[i]:\n            result.append(j)\n            i = j\n    return result\n", "asserts": ["assert MaxActivities([2, 4, 5, 6, 7, 8], [3, 5, 6, 7, 9, 10]) == [0, 1, 2, 3, 4]", "assert MaxActivities([1, 3, 0, 5, 8, 5], [2, 4, 6, 7, 9, 9]) == [0, 1, 3, 4]", "assert MaxActivities([1], [2]) == [0]"]}], "category": "Array", "prompt_tokens": 1068, "total_tokens": 1436, "completion_tokens": 368, "completion": "Given an array of integers and a target value, return the indices of the two numbers in the array that add up to the target. If no such pair exists, return an empty list. Assume that each input would have exactly one solution, and you may not use the same element twice.\n\n\n###Code: \n\ndef two_sum(nums: list, target: int) -> list:\n    prev_map = {}  # val -> index\n    \n    for i, n in enumerate(nums):\n        diff = target - n\n        if diff in prev_map:\n            return [prev_map[diff], i]\n        prev_map[n] = i\n    \n    return []\n\n\n###Testcases: \n\nassert two_sum([2, 7, 11, 15], 9) == [0, 1]\nassert two_sum([3, 2, 4], 6) == [1, 2]\nassert two_sum([3, 3], 6) == [0, 1]\nassert two_sum([5, 5, 11], 10) == [0, 1]\nassert two_sum([0, 4, 3, 0], 0) == [0, 3]\nassert two_sum([-1, -2, -3, -4, -5], -8) == [2, 4]\nassert two_sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 19) == [8, 9]\nassert two_sum([10, 9, 8, 7, 6, 5, 4, 3, 2, 1], 19) == [0, 9]\n\n[/Example 3]", "temperature": 0.887}, {"few_shots": [{"author": "Calvin", "UUID": "1aeb3246-4c22-4d34-a48c-db7be8ba1b94", "question": "You are given n activities with their start and finish times. Select the maximum number of activities that can be performed by a single person and return their indexes. Assume that a person can only work on a single activity at a time. \n", "examples": "Input: start  =  {10, 12, 20}, finish =  {20, 25, 30}\nOutput: [0, 2]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "import numpy as np\ndef MaxActivities(s: list, f: list) -> list:\n    indices = np.argsort(f)\n    [s[i] for i in indices]\n    [f[i] for i in indices]\n    result = []\n    n = len(f)\n    i = 0\n    result.append(i)\n    for j in range(1, n):\n        if s[j] >= f[i]:\n            result.append(j)\n            i = j\n    return result\n", "asserts": ["assert MaxActivities([2, 4, 5, 6, 7, 8], [3, 5, 6, 7, 9, 10]) == [0, 1, 2, 3, 4]", "assert MaxActivities([1, 3, 0, 5, 8, 5], [2, 4, 6, 7, 9, 9]) == [0, 1, 3, 4]", "assert MaxActivities([1], [2]) == [0]"]}, {"author": "Calvin", "UUID": "9e45b73f-583d-40ab-b387-e0d1624af07b", "question": "Given two arrays return an array with the set intersection of their common elements", "examples": "Input: arr1 = [1, 2, 3, 4], arr2 = [2, 3]\nOutput: [2, 3]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def array_intersection(arr1: list, arr2: list) -> set:\n  set1 = set(arr1)\n  ret = set([x for x in arr2 if x in set1])\n  return list(ret)\n", "asserts": ["assert set(array_intersection([1,0,2,0,2,0,2,1,1,1], [2,1,0,2,0,2,2,2,1,0])) == {0,1,2}", "assert set(array_intersection([5, 6, 7, 8], [8, 9, 10, 11])) == {8}", "assert set(array_intersection([10, 20, 30], [40, 50, 60])) == set()", "assert set(array_intersection([], [1, 2, 3])) == set()", "assert set(array_intersection([-1, -2, -3], [-3, -4, -5, -6])) == {-3}", "assert set(array_intersection([9, 8, 7], [7, 8, 9, 10, 11, 12])) == {7, 8, 9}", "assert set(array_intersection(['a', 'b', 'c'], ['a', 'd', 'e', 'c'])) == {'a', 'c'}", "assert set(array_intersection(['apple', 'banana'], ['banana', 'cherry'])) == {'banana'}", "assert set(array_intersection([1.1, 2.2, 3.3], [2.2, 4.4])) == {2.2}", "assert set(array_intersection([False, True, False], [True, False, True])) == {True, False}", "assert set(array_intersection([(1, 2), (3, 4)], [(3, 4), (5, 6)])) == {(3, 4)}"]}], "category": "Array", "prompt_tokens": 887, "total_tokens": 1136, "completion_tokens": 249, "completion": "Given an array of integers, find if the array contains any duplicates. Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct.\n\n###Code: \n\ndef contains_duplicate(nums: list) -> bool:\n    num_set = set(nums)\n    return len(num_set) != len(nums)\n\n###Testcases: \n\nassert contains_duplicate([1,2,3,4]) == False\nassert contains_duplicate([1,1,1,3,3,4,3,2,4,2]) == True\nassert contains_duplicate([]) == False\nassert contains_duplicate([1]) == False\nassert contains_duplicate([0, 4, 5, 0, 3, 6]) == True\nassert contains_duplicate([-1, -2, -3, -2]) == True\nassert contains_duplicate([10, 20, 30, 40]) == False\nassert contains_duplicate([1,2,3,4,5,6,7,8,9,9]) == True\nassert contains_duplicate([100]) == False\nassert contains_duplicate([200, 200]) == True\n\n[/Example 3]", "temperature": 0.767}, {"few_shots": [{"author": "Calvin", "UUID": "fb94082f-4627-4f5a-b280-08d869823d70", "question": "You are given an array of people, people, which are the attributes of some people in a queue (not necessarily in order). Each people[i] = [hi, ki] represents the ith person of height hi with exactly ki other people in front who have a height greater than or equal to hi.\n\nReconstruct and return the queue that is represented by the input array people. The returned queue should be formatted as an array queue, where queue[j] = [hj, kj] is the attributes of the jth person in the queue (queue[0] is the person at the front of the queue).\n", "examples": "Input:  [[7, 0], [4, 4], [7, 1], [5, 0], [6, 1], [5, 2]]\nOutput: [[5, 0], [4, 1], [7, 0], [5, 2], [6, 1], [7, 1]]\n\nInput:  [[6, 0], [5, 0], [4, 0], [3, 2], [2, 2], [1, 4]]\nOutput: [[4, 0], [5, 0], [2, 2], [3, 2], [1, 4], [6, 0]]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "\ndef reconstructQueue(people: list) -> list:\n    output=[] \n    people.sort(key=lambda x: (-x[0], x[1]))                \n    for a in people:\n        output.insert(a[1], a)\n    \n    return output\n", "asserts": ["assert reconstructQueue([[8,1],[5,0],[6,1],[5,2],[4,4],[7,1]]) == [[5, 0], [8, 1], [5, 2], [6, 1], [4, 4], [7, 1]]", "assert reconstructQueue([[12,0], [6,3], [4,4], [9,2], [7,1]]) == [[12, 0], [7, 1], [9, 2], [6, 3], [4, 4]]", "assert reconstructQueue([[2,0], [1,1]]) == [[2, 0], [1, 1]]", "assert reconstructQueue([[3,0], [3,2], [3,1]]) == [[3, 0], [3, 1], [3, 2]]"]}, {"author": "Calvin", "UUID": "a9c5e697-af5d-432b-8447-5675d739c728", "question": "Given an array reorder it so that even numbers appear first", "examples": "Input: [1,2,3,4,5,6,7,8,9]\r\nOutput: [8,2,6,4,5,7,3,9,1]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def even_odd_reorder(arr: list) -> list:\n  nextEven = 0\n  nextOdd = len(arr) - 1\n  while nextEven < nextOdd:\n    if arr[nextEven] % 2 == 0:\n      nextEven += 1\n    else:\n      temp = arr[nextEven]\n      arr[nextEven] = arr[nextOdd]\n      arr[nextOdd] = temp\n      nextOdd -= 1\n  return arr\n", "asserts": ["assert even_odd_reorder([1,2,3,4,5,6,7,8,9]) == [8, 2, 6, 4, 5, 7, 3, 9, 1]", "assert even_odd_reorder([]) == []", "assert even_odd_reorder([2, 4, 6, 8]) == [2, 4, 6, 8]", "assert even_odd_reorder([7, 9, 2]) == [2, 9, 7]", "assert even_odd_reorder([10, 13, 17, 16, 15, 12]) == [10, 12, 16, 15, 17, 13]"]}], "category": "Array", "prompt_tokens": 842, "total_tokens": 1115, "completion_tokens": 273, "completion": "Given an array of integers, write a function `rotate_array` that rotates the array to the right by `k` steps, where `k` is non-negative, and `k` may be greater than the length of the array. \n\n###Code: \n\ndef rotate_array(nums: list, k: int) -> None:\n    n = len(nums)\n    k = k % n\n    nums[:] = nums[-k:] + nums[:-k]\n\n###Testcases: \n\nassert (a := rotate_array([1,2,3,4,5,6,7], 3)) is None and a == [5,6,7,1,2,3,4]  # In-place modification\nassert (a := rotate_array([-1,-100,3,99], 2)) is None and a == [3,99,-1,-100]  # In-place modification\nassert (a := rotate_array([1,2,3], 4)) is None and a == [3,1,2]  # In-place modification\nassert (a := rotate_array([], 0)) is None and a == []  # In-place modification\nassert (a := rotate_array([1], 5)) is None and a == [1]  # In-place modification\n\n[/Example 3]", "temperature": 0.874}, {"few_shots": [{"author": "Calvin", "UUID": "1aeb3246-4c22-4d34-a48c-db7be8ba1b94", "question": "You are given n activities with their start and finish times. Select the maximum number of activities that can be performed by a single person and return their indexes. Assume that a person can only work on a single activity at a time. \n", "examples": "Input: start  =  {10, 12, 20}, finish =  {20, 25, 30}\nOutput: [0, 2]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "import numpy as np\ndef MaxActivities(s: list, f: list) -> list:\n    indices = np.argsort(f)\n    [s[i] for i in indices]\n    [f[i] for i in indices]\n    result = []\n    n = len(f)\n    i = 0\n    result.append(i)\n    for j in range(1, n):\n        if s[j] >= f[i]:\n            result.append(j)\n            i = j\n    return result\n", "asserts": ["assert MaxActivities([2, 4, 5, 6, 7, 8], [3, 5, 6, 7, 9, 10]) == [0, 1, 2, 3, 4]", "assert MaxActivities([1, 3, 0, 5, 8, 5], [2, 4, 6, 7, 9, 9]) == [0, 1, 3, 4]", "assert MaxActivities([1], [2]) == [0]"]}, {"author": "Calvin", "UUID": "a9c5e697-af5d-432b-8447-5675d739c728", "question": "Given an array reorder it so that even numbers appear first", "examples": "Input: [1,2,3,4,5,6,7,8,9]\r\nOutput: [8,2,6,4,5,7,3,9,1]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def even_odd_reorder(arr: list) -> list:\n  nextEven = 0\n  nextOdd = len(arr) - 1\n  while nextEven < nextOdd:\n    if arr[nextEven] % 2 == 0:\n      nextEven += 1\n    else:\n      temp = arr[nextEven]\n      arr[nextEven] = arr[nextOdd]\n      arr[nextOdd] = temp\n      nextOdd -= 1\n  return arr\n", "asserts": ["assert even_odd_reorder([1,2,3,4,5,6,7,8,9]) == [8, 2, 6, 4, 5, 7, 3, 9, 1]", "assert even_odd_reorder([]) == []", "assert even_odd_reorder([2, 4, 6, 8]) == [2, 4, 6, 8]", "assert even_odd_reorder([7, 9, 2]) == [2, 9, 7]", "assert even_odd_reorder([10, 13, 17, 16, 15, 12]) == [10, 12, 16, 15, 17, 13]"]}], "category": "Array", "prompt_tokens": 746, "total_tokens": 932, "completion_tokens": 186, "completion": "Given an array of integers, return the kth smallest element in this array.\n\n###Code: \n\ndef find_kth_smallest(nums: list, k: int) -> int:\n    nums.sort()\n    return nums[k-1]\n\n###Testcases: \n\nassert find_kth_smallest([3, 5, 2, 7, 4], 1) == 2\nassert find_kth_smallest([3, 5, 2, 7, 4], 3) == 4\nassert find_kth_smallest([10, 5, 2, 24, 12], 5) == 24\nassert find_kth_smallest([1], 1) == 1\nassert find_kth_smallest([-1, -3, -5, -7, -9], 3) == -5\n\n[/Example 3]", "temperature": 0.852}, {"few_shots": [{"author": "Calvin", "UUID": "fb94082f-4627-4f5a-b280-08d869823d70", "question": "You are given an array of people, people, which are the attributes of some people in a queue (not necessarily in order). Each people[i] = [hi, ki] represents the ith person of height hi with exactly ki other people in front who have a height greater than or equal to hi.\n\nReconstruct and return the queue that is represented by the input array people. The returned queue should be formatted as an array queue, where queue[j] = [hj, kj] is the attributes of the jth person in the queue (queue[0] is the person at the front of the queue).\n", "examples": "Input:  [[7, 0], [4, 4], [7, 1], [5, 0], [6, 1], [5, 2]]\nOutput: [[5, 0], [4, 1], [7, 0], [5, 2], [6, 1], [7, 1]]\n\nInput:  [[6, 0], [5, 0], [4, 0], [3, 2], [2, 2], [1, 4]]\nOutput: [[4, 0], [5, 0], [2, 2], [3, 2], [1, 4], [6, 0]]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "\ndef reconstructQueue(people: list) -> list:\n    output=[] \n    people.sort(key=lambda x: (-x[0], x[1]))                \n    for a in people:\n        output.insert(a[1], a)\n    \n    return output\n", "asserts": ["assert reconstructQueue([[8,1],[5,0],[6,1],[5,2],[4,4],[7,1]]) == [[5, 0], [8, 1], [5, 2], [6, 1], [4, 4], [7, 1]]", "assert reconstructQueue([[12,0], [6,3], [4,4], [9,2], [7,1]]) == [[12, 0], [7, 1], [9, 2], [6, 3], [4, 4]]", "assert reconstructQueue([[2,0], [1,1]]) == [[2, 0], [1, 1]]", "assert reconstructQueue([[3,0], [3,2], [3,1]]) == [[3, 0], [3, 1], [3, 2]]"]}, {"author": "Calvin", "UUID": "a9c5e697-af5d-432b-8447-5675d739c728", "question": "Given an array reorder it so that even numbers appear first", "examples": "Input: [1,2,3,4,5,6,7,8,9]\r\nOutput: [8,2,6,4,5,7,3,9,1]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def even_odd_reorder(arr: list) -> list:\n  nextEven = 0\n  nextOdd = len(arr) - 1\n  while nextEven < nextOdd:\n    if arr[nextEven] % 2 == 0:\n      nextEven += 1\n    else:\n      temp = arr[nextEven]\n      arr[nextEven] = arr[nextOdd]\n      arr[nextOdd] = temp\n      nextOdd -= 1\n  return arr\n", "asserts": ["assert even_odd_reorder([1,2,3,4,5,6,7,8,9]) == [8, 2, 6, 4, 5, 7, 3, 9, 1]", "assert even_odd_reorder([]) == []", "assert even_odd_reorder([2, 4, 6, 8]) == [2, 4, 6, 8]", "assert even_odd_reorder([7, 9, 2]) == [2, 9, 7]", "assert even_odd_reorder([10, 13, 17, 16, 15, 12]) == [10, 12, 16, 15, 17, 13]"]}], "category": "Array", "prompt_tokens": 842, "total_tokens": 1070, "completion_tokens": 228, "completion": "Given an array of integers, return the third maximum number in this array. If the third maximum does not exist, return the maximum number. The time complexity of the function should be O(n).\n\n###Code: \n\ndef thirdMax(nums: list) -> int:\n    first = second = third = float('-inf')\n    \n    for num in nums:\n        if num > first:\n            third = second\n            second = first\n            first = num\n        elif first > num > second:\n            third = second\n            second = num\n        elif second > num > third:\n            third = num\n    \n    return third if third != float('-inf') else first\n\n###Testcases: \n\nassert thirdMax([3, 2, 1]) == 1\nassert thirdMax([1, 2]) == 2\nassert thirdMax([2, 2, 3, 1]) == 1\nassert thirdMax([1,1,2]) == 2\nassert thirdMax([1,2,2,5,3,5]) == 2\n\n[/Example 3]", "temperature": 0.764}, {"few_shots": [{"author": "Calvin", "UUID": "fb94082f-4627-4f5a-b280-08d869823d70", "question": "You are given an array of people, people, which are the attributes of some people in a queue (not necessarily in order). Each people[i] = [hi, ki] represents the ith person of height hi with exactly ki other people in front who have a height greater than or equal to hi.\n\nReconstruct and return the queue that is represented by the input array people. The returned queue should be formatted as an array queue, where queue[j] = [hj, kj] is the attributes of the jth person in the queue (queue[0] is the person at the front of the queue).\n", "examples": "Input:  [[7, 0], [4, 4], [7, 1], [5, 0], [6, 1], [5, 2]]\nOutput: [[5, 0], [4, 1], [7, 0], [5, 2], [6, 1], [7, 1]]\n\nInput:  [[6, 0], [5, 0], [4, 0], [3, 2], [2, 2], [1, 4]]\nOutput: [[4, 0], [5, 0], [2, 2], [3, 2], [1, 4], [6, 0]]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "\ndef reconstructQueue(people: list) -> list:\n    output=[] \n    people.sort(key=lambda x: (-x[0], x[1]))                \n    for a in people:\n        output.insert(a[1], a)\n    \n    return output\n", "asserts": ["assert reconstructQueue([[8,1],[5,0],[6,1],[5,2],[4,4],[7,1]]) == [[5, 0], [8, 1], [5, 2], [6, 1], [4, 4], [7, 1]]", "assert reconstructQueue([[12,0], [6,3], [4,4], [9,2], [7,1]]) == [[12, 0], [7, 1], [9, 2], [6, 3], [4, 4]]", "assert reconstructQueue([[2,0], [1,1]]) == [[2, 0], [1, 1]]", "assert reconstructQueue([[3,0], [3,2], [3,1]]) == [[3, 0], [3, 1], [3, 2]]"]}, {"author": "Calvin", "UUID": "1aeb3246-4c22-4d34-a48c-db7be8ba1b94", "question": "You are given n activities with their start and finish times. Select the maximum number of activities that can be performed by a single person and return their indexes. Assume that a person can only work on a single activity at a time. \n", "examples": "Input: start  =  {10, 12, 20}, finish =  {20, 25, 30}\nOutput: [0, 2]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "import numpy as np\ndef MaxActivities(s: list, f: list) -> list:\n    indices = np.argsort(f)\n    [s[i] for i in indices]\n    [f[i] for i in indices]\n    result = []\n    n = len(f)\n    i = 0\n    result.append(i)\n    for j in range(1, n):\n        if s[j] >= f[i]:\n            result.append(j)\n            i = j\n    return result\n", "asserts": ["assert MaxActivities([2, 4, 5, 6, 7, 8], [3, 5, 6, 7, 9, 10]) == [0, 1, 2, 3, 4]", "assert MaxActivities([1, 3, 0, 5, 8, 5], [2, 4, 6, 7, 9, 9]) == [0, 1, 3, 4]", "assert MaxActivities([1], [2]) == [0]"]}], "category": "Array", "prompt_tokens": 843, "total_tokens": 1163, "completion_tokens": 320, "completion": "Given an array `nums` of integers, return the length of the longest strictly increasing subsequence.\n\nA subsequence is a sequence that can be derived from an array by deleting some or no elements without changing the order of the remaining elements. For example, the sequence `[3, 6, 2, 7]` is a subsequence of the array `[0, 3, 1, 6, 2, 2, 7]`.\n\n### Code:\n\n```python\ndef lengthOfLIS(nums: list) -> int:\n    n = len(nums)\n    dp = [1] * n\n\n    for i in range(1, n):\n        for j in range(0, i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)\n\n```\n\n### Testcases:\n\n```python\nassert lengthOfLIS([10, 9, 2, 5, 3, 7, 101, 18]) == 4\nassert lengthOfLIS([0, 1, 0, 3, 2, 3]) == 4\nassert lengthOfLIS([7, 7, 7, 7, 7, 7, 7]) == 1\nassert lengthOfLIS([1, 3, 6, 7, 9, 4, 10, 5, 6]) == 6\n```\n\n[/Example 3]", "temperature": 0.689}, {"few_shots": [{"author": "Calvin", "UUID": "48c6aa37-e00d-4b55-9afc-6b1cf2a1aff2", "question": "There are N Mice and N holes are placed in a straight line. Each hole can accommodate only 1 mouse. A mouse can stay at his position, move one step right from x to x + 1, or move one step left from x to x -1. Any of these moves consumes 1 minute. Assign mice to holes so that the time when the last mouse gets inside a hole is minimized.\nYou are given a list of mice and hole positions as integer scalers.\n", "examples": "Input: Mices = [0, 10, 2, 3], Holes = [3, 2, 23, 0]\nOutput: 13", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def assignHole(mices: list, holes: list) -> int:\n    for i,j in zip(mices,holes):\n        if i<0 or j<0:\n            return -1\n    if (len(mices) != len(holes)):\n        return -1\n    mices.sort()\n    holes.sort()\n    Max = 0\n     \n    for i in range(len(holes)):\n        if (Max < abs(mices[i] - holes[i])):\n            Max = abs(mices[i] - holes[i])\n     \n    return Max\n", "asserts": ["assert assignHole([1, 2, 3, 4], [4, 3, 2, 1]) == 0", "assert assignHole([10, 20, 30, 40], [15, 25, 35, 45]) == 5", "assert assignHole([1, 4, 9, 15], [10, 13, 7, 20]) == 6", "assert assignHole([0], [0]) == 0", "assert assignHole([1, 2], [3]) == -1  # Edge case with non-equal amount of mice and holes", "assert assignHole([5, 5, 5], [5, 5, 5]) == 0  # Edge case with all mice and holes at the same position", "assert assignHole([10, 10, 10, 10], [10, 9, 8, 7]) == 3  # Edge case with multiple mice starting at the same position", "assert assignHole([1,1 ,1, 1, 1, 1, 1, 1, 1, 1], [2,2,2,2,2,2 ,2, 2, 2, 2]) == 1 # Edge case with multiple mice and holes at the same positions", "assert assignHole([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == 1 # Edge case with incremental positions"]}, {"author": "Calvin", "UUID": "1aeb3246-4c22-4d34-a48c-db7be8ba1b94", "question": "You are given n activities with their start and finish times. Select the maximum number of activities that can be performed by a single person and return their indexes. Assume that a person can only work on a single activity at a time. \n", "examples": "Input: start  =  {10, 12, 20}, finish =  {20, 25, 30}\nOutput: [0, 2]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "import numpy as np\ndef MaxActivities(s: list, f: list) -> list:\n    indices = np.argsort(f)\n    [s[i] for i in indices]\n    [f[i] for i in indices]\n    result = []\n    n = len(f)\n    i = 0\n    result.append(i)\n    for j in range(1, n):\n        if s[j] >= f[i]:\n            result.append(j)\n            i = j\n    return result\n", "asserts": ["assert MaxActivities([2, 4, 5, 6, 7, 8], [3, 5, 6, 7, 9, 10]) == [0, 1, 2, 3, 4]", "assert MaxActivities([1, 3, 0, 5, 8, 5], [2, 4, 6, 7, 9, 9]) == [0, 1, 3, 4]", "assert MaxActivities([1], [2]) == [0]"]}], "category": "Array", "prompt_tokens": 1068, "total_tokens": 1558, "completion_tokens": 490, "completion": "Given an array of integers, return a new array such that each element at index `i` of the new array is the product of all the numbers in the original array except the one at `i`. Solve it without using division and in O(n) time.\n\n###Code: \n\ndef productExceptSelf(nums: list) -> list:\n    n = len(nums)\n    if n == 0:\n        return []\n\n    # Initialize the empty answer array where for a given index i,\n    # answer[i] would contain the product of all the numbers to the left of i.\n    answer = [0]*n\n    answer[0] = 1\n    for i in range(1, n):\n        # answer[i] contains the product of all the elements to the left\n        # We can simply multiply the previous product by the current element\n        answer[i] = nums[i - 1] * answer[i - 1]\n\n    # R contains the product of all the elements to the right\n    # Note: for the element at index 'len(nums) - 1', there are no elements to the right,\n    # so the R would be 1\n    R = 1\n    for i in reversed(range(n)):\n        # For the index 'i', R would contain the product of all elements to the right.\n        # We update R accordingly\n        answer[i] = answer[i] * R\n        R *= nums[i]\n\n    return answer\n\n###Testcases: \n\nassert productExceptSelf([1, 2, 3, 4]) == [24, 12, 8, 6]\nassert productExceptSelf([0, 0]) == [0, 0]\nassert productExceptSelf([1, 0]) == [0, 1]\nassert productExceptSelf([-1, 1, 0, -3, 3]) == [0, 0, 9, 0, 0]\nassert productExceptSelf([2, 3, 4, 5]) == [60, 40, 30, 24]\nassert productExceptSelf([1]) == [1]  # Edge case with only one element\nassert productExceptSelf([0, 4, 0]) == [0, 0, 0]  # Edge case with zeros\n\n[/Example 3]", "temperature": 0.805}, {"few_shots": [{"author": "Calvin", "UUID": "fb94082f-4627-4f5a-b280-08d869823d70", "question": "You are given an array of people, people, which are the attributes of some people in a queue (not necessarily in order). Each people[i] = [hi, ki] represents the ith person of height hi with exactly ki other people in front who have a height greater than or equal to hi.\n\nReconstruct and return the queue that is represented by the input array people. The returned queue should be formatted as an array queue, where queue[j] = [hj, kj] is the attributes of the jth person in the queue (queue[0] is the person at the front of the queue).\n", "examples": "Input:  [[7, 0], [4, 4], [7, 1], [5, 0], [6, 1], [5, 2]]\nOutput: [[5, 0], [4, 1], [7, 0], [5, 2], [6, 1], [7, 1]]\n\nInput:  [[6, 0], [5, 0], [4, 0], [3, 2], [2, 2], [1, 4]]\nOutput: [[4, 0], [5, 0], [2, 2], [3, 2], [1, 4], [6, 0]]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "\ndef reconstructQueue(people: list) -> list:\n    output=[] \n    people.sort(key=lambda x: (-x[0], x[1]))                \n    for a in people:\n        output.insert(a[1], a)\n    \n    return output\n", "asserts": ["assert reconstructQueue([[8,1],[5,0],[6,1],[5,2],[4,4],[7,1]]) == [[5, 0], [8, 1], [5, 2], [6, 1], [4, 4], [7, 1]]", "assert reconstructQueue([[12,0], [6,3], [4,4], [9,2], [7,1]]) == [[12, 0], [7, 1], [9, 2], [6, 3], [4, 4]]", "assert reconstructQueue([[2,0], [1,1]]) == [[2, 0], [1, 1]]", "assert reconstructQueue([[3,0], [3,2], [3,1]]) == [[3, 0], [3, 1], [3, 2]]"]}, {"author": "Calvin", "UUID": "9e45b73f-583d-40ab-b387-e0d1624af07b", "question": "Given two arrays return an array with the set intersection of their common elements", "examples": "Input: arr1 = [1, 2, 3, 4], arr2 = [2, 3]\nOutput: [2, 3]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def array_intersection(arr1: list, arr2: list) -> set:\n  set1 = set(arr1)\n  ret = set([x for x in arr2 if x in set1])\n  return list(ret)\n", "asserts": ["assert set(array_intersection([1,0,2,0,2,0,2,1,1,1], [2,1,0,2,0,2,2,2,1,0])) == {0,1,2}", "assert set(array_intersection([5, 6, 7, 8], [8, 9, 10, 11])) == {8}", "assert set(array_intersection([10, 20, 30], [40, 50, 60])) == set()", "assert set(array_intersection([], [1, 2, 3])) == set()", "assert set(array_intersection([-1, -2, -3], [-3, -4, -5, -6])) == {-3}", "assert set(array_intersection([9, 8, 7], [7, 8, 9, 10, 11, 12])) == {7, 8, 9}", "assert set(array_intersection(['a', 'b', 'c'], ['a', 'd', 'e', 'c'])) == {'a', 'c'}", "assert set(array_intersection(['apple', 'banana'], ['banana', 'cherry'])) == {'banana'}", "assert set(array_intersection([1.1, 2.2, 3.3], [2.2, 4.4])) == {2.2}", "assert set(array_intersection([False, True, False], [True, False, True])) == {True, False}", "assert set(array_intersection([(1, 2), (3, 4)], [(3, 4), (5, 6)])) == {(3, 4)}"]}], "category": "Array", "prompt_tokens": 983, "total_tokens": 1419, "completion_tokens": 436, "completion": "Implement a function that given a list of numbers, returns the number of pairs of indices (i, j) (where i < j) such that the product of elements at those indices is equal to the sum of elements at those indices.\n\n###Code: \n\ndef count_pairs(nums: list) -> int:\n    count = 0\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            if nums[i] * nums[j] == nums[i] + nums[j]:\n                count += 1\n    return count\n\n###Testcases: \n\nassert count_pairs([0, 1, 2, 3, 4, 5]) == 2  # Pairs: (2, 3), (0, 5)\nassert count_pairs([1, 1, 1, 1]) == 6         # Pairs: All combinations of indices\nassert count_pairs([2, 3, 4]) == 0           # No such pairs\nassert count_pairs([-1, 0, 1, 2]) == 1       # Pairs: (-1, 2)\nassert count_pairs([0, 0, 0, 0, 0]) == 10    # Pairs: All combinations of indices with zeros\nassert count_pairs([-2, -3, 6]) == 1         # Pairs: (-3, 6)\nassert count_pairs([1, 2, 4, 8, 16]) == 0    # No such pairs\nassert count_pairs([2, -3, 3, 2, -2]) == 2   # Pairs: (2, -2), (-3, 3)\nassert count_pairs([5, 7, -12, 15, 3]) == 1  # Pairs: (-12, 15)\nassert count_pairs([1.5, 2.5, 2.0]) == 1     # Pairs: (1.5, 2.0)\n\n[/Example 3]", "temperature": 0.935}, {"few_shots": [{"author": "Calvin", "UUID": "9e45b73f-583d-40ab-b387-e0d1624af07b", "question": "Given two arrays return an array with the set intersection of their common elements", "examples": "Input: arr1 = [1, 2, 3, 4], arr2 = [2, 3]\nOutput: [2, 3]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def array_intersection(arr1: list, arr2: list) -> set:\n  set1 = set(arr1)\n  ret = set([x for x in arr2 if x in set1])\n  return list(ret)\n", "asserts": ["assert set(array_intersection([1,0,2,0,2,0,2,1,1,1], [2,1,0,2,0,2,2,2,1,0])) == {0,1,2}", "assert set(array_intersection([5, 6, 7, 8], [8, 9, 10, 11])) == {8}", "assert set(array_intersection([10, 20, 30], [40, 50, 60])) == set()", "assert set(array_intersection([], [1, 2, 3])) == set()", "assert set(array_intersection([-1, -2, -3], [-3, -4, -5, -6])) == {-3}", "assert set(array_intersection([9, 8, 7], [7, 8, 9, 10, 11, 12])) == {7, 8, 9}", "assert set(array_intersection(['a', 'b', 'c'], ['a', 'd', 'e', 'c'])) == {'a', 'c'}", "assert set(array_intersection(['apple', 'banana'], ['banana', 'cherry'])) == {'banana'}", "assert set(array_intersection([1.1, 2.2, 3.3], [2.2, 4.4])) == {2.2}", "assert set(array_intersection([False, True, False], [True, False, True])) == {True, False}", "assert set(array_intersection([(1, 2), (3, 4)], [(3, 4), (5, 6)])) == {(3, 4)}"]}, {"author": "Calvin", "UUID": "a9c5e697-af5d-432b-8447-5675d739c728", "question": "Given an array reorder it so that even numbers appear first", "examples": "Input: [1,2,3,4,5,6,7,8,9]\r\nOutput: [8,2,6,4,5,7,3,9,1]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def even_odd_reorder(arr: list) -> list:\n  nextEven = 0\n  nextOdd = len(arr) - 1\n  while nextEven < nextOdd:\n    if arr[nextEven] % 2 == 0:\n      nextEven += 1\n    else:\n      temp = arr[nextEven]\n      arr[nextEven] = arr[nextOdd]\n      arr[nextOdd] = temp\n      nextOdd -= 1\n  return arr\n", "asserts": ["assert even_odd_reorder([1,2,3,4,5,6,7,8,9]) == [8, 2, 6, 4, 5, 7, 3, 9, 1]", "assert even_odd_reorder([]) == []", "assert even_odd_reorder([2, 4, 6, 8]) == [2, 4, 6, 8]", "assert even_odd_reorder([7, 9, 2]) == [2, 9, 7]", "assert even_odd_reorder([10, 13, 17, 16, 15, 12]) == [10, 12, 16, 15, 17, 13]"]}], "category": "Array", "prompt_tokens": 886, "total_tokens": 1176, "completion_tokens": 290, "completion": "Given an array of integers, return an array where each index stores the product of all numbers in the original array except for the number at that index.\n\n###Code: \n\ndef product_except_self(nums: list) -> list:\n    length = len(nums)\n    answer = [0]*length\n    answer[0] = 1\n    \n    for i in range(1, length):\n        answer[i] = nums[i - 1] * answer[i - 1]\n    \n    R = 1\n    for i in reversed(range(length)):\n        answer[i] = answer[i] * R\n        R *= nums[i]\n    \n    return answer\n\n###Testcases: \n\nassert product_except_self([1,2,3,4]) == [24, 12, 8, 6]\nassert product_except_self([0, 0]) == [0, 0]\nassert product_except_self([1, 0]) == [0, 1]\nassert product_except_self([3, 2, 1]) == [2, 3, 6]\nassert product_except_self([-1, 1, -1, 1]) == [1, -1, 1, -1]\nassert product_except_self([10, 3, 5, 6, 2]) == [180, 600, 360, 300, 900]\n\n[/Example 3]", "temperature": 0.773}, {"few_shots": [{"author": "Calvin", "UUID": "1aeb3246-4c22-4d34-a48c-db7be8ba1b94", "question": "You are given n activities with their start and finish times. Select the maximum number of activities that can be performed by a single person and return their indexes. Assume that a person can only work on a single activity at a time. \n", "examples": "Input: start  =  {10, 12, 20}, finish =  {20, 25, 30}\nOutput: [0, 2]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "import numpy as np\ndef MaxActivities(s: list, f: list) -> list:\n    indices = np.argsort(f)\n    [s[i] for i in indices]\n    [f[i] for i in indices]\n    result = []\n    n = len(f)\n    i = 0\n    result.append(i)\n    for j in range(1, n):\n        if s[j] >= f[i]:\n            result.append(j)\n            i = j\n    return result\n", "asserts": ["assert MaxActivities([2, 4, 5, 6, 7, 8], [3, 5, 6, 7, 9, 10]) == [0, 1, 2, 3, 4]", "assert MaxActivities([1, 3, 0, 5, 8, 5], [2, 4, 6, 7, 9, 9]) == [0, 1, 3, 4]", "assert MaxActivities([1], [2]) == [0]"]}, {"author": "Calvin", "UUID": "f795bda7-9822-4bc5-9c7e-b9c0f2752085", "question": "You are given two 0-indexed integer permutations A and B of length n.\n\nA prefix common array of A and B is an array C such that C[i] is equal to the count of numbers that are present at or before the index i in both A and B.\n\nReturn the prefix common array of A and B.\n\nA sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once.", "examples": "Input: A = [1,3,2,4], B = [3,1,2,4]\nOutput: [0,2,3,4]", "link": "https://leetcode.com/problems/find-the-prefix-common-array-of-two-arrays/", "difficulty": null, "categories": ["Array"], "code": "def findThePrefixCommonArray(arr1: list, arr2: list) -> list:\n  max = len(arr1) if len(arr1) > len(arr2) else len(arr2)\n  seen = set()\n  curCount = 0\n  ret = []\n  for i in range(max):\n    cur1 = arr1[i]\n    cur2 = arr2[i]\n    if cur1 in seen:\n      curCount += 1\n    else:\n      seen.add(cur1)\n    if cur2 in seen:\n      curCount += 1\n    else:\n      seen.add(cur2)\n    ret.append(curCount)\n  return ret\n", "asserts": ["assert findThePrefixCommonArray([1,3,2,4], [3,1,2,4]) == [0,2,3,4]", "assert findThePrefixCommonArray([1], [1]) == [1]", "assert findThePrefixCommonArray([2,3,1], [3,1,2]) == [0,1,3]"]}], "category": "Array", "prompt_tokens": 782, "total_tokens": 955, "completion_tokens": 173, "completion": "Given an integer array nums and an integer k, return the k most frequent elements in the array. You may return the answer in any order.\n\n###Code:\n\n```python\nfrom collections import Counter\ndef topKFrequent(nums: list[int], k: int) -> list[int]:\n    count = Counter(nums)   \n    return [item for item, freq in count.most_common(k)]\n\n###Testcases:\n\nassert set(topKFrequent([1,1,1,2,2,3], 2)) == {1, 2}\nassert set(topKFrequent([1], 1)) == {1}\nassert set(topKFrequent([1,2,3,2,1,2,3,3,3,1,2,2], 2)) == {2, 3}\n```\n\n[/Example 3]", "temperature": 0.767}, {"few_shots": [{"author": "Calvin", "UUID": "a9c5e697-af5d-432b-8447-5675d739c728", "question": "Given an array reorder it so that even numbers appear first", "examples": "Input: [1,2,3,4,5,6,7,8,9]\r\nOutput: [8,2,6,4,5,7,3,9,1]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def even_odd_reorder(arr: list) -> list:\n  nextEven = 0\n  nextOdd = len(arr) - 1\n  while nextEven < nextOdd:\n    if arr[nextEven] % 2 == 0:\n      nextEven += 1\n    else:\n      temp = arr[nextEven]\n      arr[nextEven] = arr[nextOdd]\n      arr[nextOdd] = temp\n      nextOdd -= 1\n  return arr\n", "asserts": ["assert even_odd_reorder([1,2,3,4,5,6,7,8,9]) == [8, 2, 6, 4, 5, 7, 3, 9, 1]", "assert even_odd_reorder([]) == []", "assert even_odd_reorder([2, 4, 6, 8]) == [2, 4, 6, 8]", "assert even_odd_reorder([7, 9, 2]) == [2, 9, 7]", "assert even_odd_reorder([10, 13, 17, 16, 15, 12]) == [10, 12, 16, 15, 17, 13]"]}, {"author": "Calvin", "UUID": "48c6aa37-e00d-4b55-9afc-6b1cf2a1aff2", "question": "There are N Mice and N holes are placed in a straight line. Each hole can accommodate only 1 mouse. A mouse can stay at his position, move one step right from x to x + 1, or move one step left from x to x -1. Any of these moves consumes 1 minute. Assign mice to holes so that the time when the last mouse gets inside a hole is minimized.\nYou are given a list of mice and hole positions as integer scalers.\n", "examples": "Input: Mices = [0, 10, 2, 3], Holes = [3, 2, 23, 0]\nOutput: 13", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def assignHole(mices: list, holes: list) -> int:\n    for i,j in zip(mices,holes):\n        if i<0 or j<0:\n            return -1\n    if (len(mices) != len(holes)):\n        return -1\n    mices.sort()\n    holes.sort()\n    Max = 0\n     \n    for i in range(len(holes)):\n        if (Max < abs(mices[i] - holes[i])):\n            Max = abs(mices[i] - holes[i])\n     \n    return Max\n", "asserts": ["assert assignHole([1, 2, 3, 4], [4, 3, 2, 1]) == 0", "assert assignHole([10, 20, 30, 40], [15, 25, 35, 45]) == 5", "assert assignHole([1, 4, 9, 15], [10, 13, 7, 20]) == 6", "assert assignHole([0], [0]) == 0", "assert assignHole([1, 2], [3]) == -1  # Edge case with non-equal amount of mice and holes", "assert assignHole([5, 5, 5], [5, 5, 5]) == 0  # Edge case with all mice and holes at the same position", "assert assignHole([10, 10, 10, 10], [10, 9, 8, 7]) == 3  # Edge case with multiple mice starting at the same position", "assert assignHole([1,1 ,1, 1, 1, 1, 1, 1, 1, 1], [2,2,2,2,2,2 ,2, 2, 2, 2]) == 1 # Edge case with multiple mice and holes at the same positions", "assert assignHole([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == 1 # Edge case with incremental positions"]}], "category": "Array", "prompt_tokens": 1067, "total_tokens": 1505, "completion_tokens": 438, "completion": "Given an array of integers, return the maximum sum of non-adjacent elements. Non-adjacent elements are elements that are not immediately next to each other in the array (i.e., they are at least one element apart).\n\n###Code: \n\ndef max_subset_sum_no_adjacent(arr: list) -> int:\n    if not arr:\n        return 0\n    elif len(arr) <= 2:\n        return max(arr)\n    \n    max_sums = arr[:]\n    max_sums[1] = max(arr[0], arr[1])\n    for i in range(2, len(arr)):\n        max_sums[i] = max(max_sums[i-1], max_sums[i-2] + arr[i])\n    return max_sums[-1]\n\n###Testcases: \n\nassert max_subset_sum_no_adjacent([3, 2, 7, 10]) == 13  # Pick 3 and 10\nassert max_subset_sum_no_adjacent([3, 2, 5, 10, 7]) == 15  # Pick 3, 5 and 7\nassert max_subset_sum_no_adjacent([5, 5, 10, 100, 10, 5]) == 110  # Pick 5, 100 and 5\nassert max_subset_sum_no_adjacent([1, 0, 3, 9, 2]) == 10  # Pick 1 and 9\nassert max_subset_sum_no_adjacent([]) == 0  # Empty array\nassert max_subset_sum_no_adjacent([0, 0, 0, 0, 0]) == 0  # Array with all elements as 0\nassert max_subset_sum_no_adjacent([1]) == 1  # Array with one element\nassert max_subset_sum_no_adjacent([2, 4]) == 4  # Array with two elements\nassert max_subset_sum_no_adjacent([-2, 1, 3, -4, 5]) == 8  # Array containing negative numbers\n\n[/Example 3]", "temperature": 0.846}, {"few_shots": [{"author": "Calvin", "UUID": "48c6aa37-e00d-4b55-9afc-6b1cf2a1aff2", "question": "There are N Mice and N holes are placed in a straight line. Each hole can accommodate only 1 mouse. A mouse can stay at his position, move one step right from x to x + 1, or move one step left from x to x -1. Any of these moves consumes 1 minute. Assign mice to holes so that the time when the last mouse gets inside a hole is minimized.\nYou are given a list of mice and hole positions as integer scalers.\n", "examples": "Input: Mices = [0, 10, 2, 3], Holes = [3, 2, 23, 0]\nOutput: 13", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def assignHole(mices: list, holes: list) -> int:\n    for i,j in zip(mices,holes):\n        if i<0 or j<0:\n            return -1\n    if (len(mices) != len(holes)):\n        return -1\n    mices.sort()\n    holes.sort()\n    Max = 0\n     \n    for i in range(len(holes)):\n        if (Max < abs(mices[i] - holes[i])):\n            Max = abs(mices[i] - holes[i])\n     \n    return Max\n", "asserts": ["assert assignHole([1, 2, 3, 4], [4, 3, 2, 1]) == 0", "assert assignHole([10, 20, 30, 40], [15, 25, 35, 45]) == 5", "assert assignHole([1, 4, 9, 15], [10, 13, 7, 20]) == 6", "assert assignHole([0], [0]) == 0", "assert assignHole([1, 2], [3]) == -1  # Edge case with non-equal amount of mice and holes", "assert assignHole([5, 5, 5], [5, 5, 5]) == 0  # Edge case with all mice and holes at the same position", "assert assignHole([10, 10, 10, 10], [10, 9, 8, 7]) == 3  # Edge case with multiple mice starting at the same position", "assert assignHole([1,1 ,1, 1, 1, 1, 1, 1, 1, 1], [2,2,2,2,2,2 ,2, 2, 2, 2]) == 1 # Edge case with multiple mice and holes at the same positions", "assert assignHole([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == 1 # Edge case with incremental positions"]}, {"author": "Calvin", "UUID": "1aeb3246-4c22-4d34-a48c-db7be8ba1b94", "question": "You are given n activities with their start and finish times. Select the maximum number of activities that can be performed by a single person and return their indexes. Assume that a person can only work on a single activity at a time. \n", "examples": "Input: start  =  {10, 12, 20}, finish =  {20, 25, 30}\nOutput: [0, 2]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "import numpy as np\ndef MaxActivities(s: list, f: list) -> list:\n    indices = np.argsort(f)\n    [s[i] for i in indices]\n    [f[i] for i in indices]\n    result = []\n    n = len(f)\n    i = 0\n    result.append(i)\n    for j in range(1, n):\n        if s[j] >= f[i]:\n            result.append(j)\n            i = j\n    return result\n", "asserts": ["assert MaxActivities([2, 4, 5, 6, 7, 8], [3, 5, 6, 7, 9, 10]) == [0, 1, 2, 3, 4]", "assert MaxActivities([1, 3, 0, 5, 8, 5], [2, 4, 6, 7, 9, 9]) == [0, 1, 3, 4]", "assert MaxActivities([1], [2]) == [0]"]}], "category": "Array", "prompt_tokens": 1068, "total_tokens": 1455, "completion_tokens": 387, "completion": "Given an array of integers, return the length of the longest subarray where the difference between any two consecutive elements is less than or equal to 1.\n\n###Code: \n\ndef longestSubarray(arr: list) -> int:\n    if not arr:\n        return 0\n    arr.sort()\n    max_length = 1\n    current_length = 1\n    for i in range(1, len(arr)):\n        if arr[i] - arr[i - 1] <= 1:\n            current_length += 1\n        else:\n            max_length = max(max_length, current_length)\n            current_length = 1\n    max_length = max(max_length, current_length)\n    return max_length\n\n###Testcases: \n\nassert longestSubarray([1, 2, 2, 3, 4, 5]) == 3\nassert longestSubarray([1, 2, 2, 2, 3]) == 4\nassert longestSubarray([4, 6, 5, 3, 3, 1]) == 3\nassert longestSubarray([1, 1, 1, 1, 3, 3, 3, 3, 3]) == 5\nassert longestSubarray([1]) == 1  # Edge case with single element\nassert longestSubarray([]) == 0   # Edge case with empty array\nassert longestSubarray([10, 10, 10, 11, 11, 13, 13, 13, 13]) == 5\nassert longestSubarray([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == 2  # Edge case with no difference less than or equal to 1\n\n[/Example 3]", "temperature": 0.782}, {"few_shots": [{"author": "Calvin", "UUID": "fb94082f-4627-4f5a-b280-08d869823d70", "question": "You are given an array of people, people, which are the attributes of some people in a queue (not necessarily in order). Each people[i] = [hi, ki] represents the ith person of height hi with exactly ki other people in front who have a height greater than or equal to hi.\n\nReconstruct and return the queue that is represented by the input array people. The returned queue should be formatted as an array queue, where queue[j] = [hj, kj] is the attributes of the jth person in the queue (queue[0] is the person at the front of the queue).\n", "examples": "Input:  [[7, 0], [4, 4], [7, 1], [5, 0], [6, 1], [5, 2]]\nOutput: [[5, 0], [4, 1], [7, 0], [5, 2], [6, 1], [7, 1]]\n\nInput:  [[6, 0], [5, 0], [4, 0], [3, 2], [2, 2], [1, 4]]\nOutput: [[4, 0], [5, 0], [2, 2], [3, 2], [1, 4], [6, 0]]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "\ndef reconstructQueue(people: list) -> list:\n    output=[] \n    people.sort(key=lambda x: (-x[0], x[1]))                \n    for a in people:\n        output.insert(a[1], a)\n    \n    return output\n", "asserts": ["assert reconstructQueue([[8,1],[5,0],[6,1],[5,2],[4,4],[7,1]]) == [[5, 0], [8, 1], [5, 2], [6, 1], [4, 4], [7, 1]]", "assert reconstructQueue([[12,0], [6,3], [4,4], [9,2], [7,1]]) == [[12, 0], [7, 1], [9, 2], [6, 3], [4, 4]]", "assert reconstructQueue([[2,0], [1,1]]) == [[2, 0], [1, 1]]", "assert reconstructQueue([[3,0], [3,2], [3,1]]) == [[3, 0], [3, 1], [3, 2]]"]}, {"author": "Calvin", "UUID": "1aeb3246-4c22-4d34-a48c-db7be8ba1b94", "question": "You are given n activities with their start and finish times. Select the maximum number of activities that can be performed by a single person and return their indexes. Assume that a person can only work on a single activity at a time. \n", "examples": "Input: start  =  {10, 12, 20}, finish =  {20, 25, 30}\nOutput: [0, 2]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "import numpy as np\ndef MaxActivities(s: list, f: list) -> list:\n    indices = np.argsort(f)\n    [s[i] for i in indices]\n    [f[i] for i in indices]\n    result = []\n    n = len(f)\n    i = 0\n    result.append(i)\n    for j in range(1, n):\n        if s[j] >= f[i]:\n            result.append(j)\n            i = j\n    return result\n", "asserts": ["assert MaxActivities([2, 4, 5, 6, 7, 8], [3, 5, 6, 7, 9, 10]) == [0, 1, 2, 3, 4]", "assert MaxActivities([1, 3, 0, 5, 8, 5], [2, 4, 6, 7, 9, 9]) == [0, 1, 3, 4]", "assert MaxActivities([1], [2]) == [0]"]}], "category": "Array", "prompt_tokens": 843, "total_tokens": 1255, "completion_tokens": 412, "completion": "Write a function that takes in a non-empty array of distinct integers and an integer representing a target sum. The function should find all triplets in the array that sum up to the target sum and return a two-dimensional array of all these triplets. The numbers in each triplet should be ordered in ascending order, and the triplets themselves should be ordered in ascending order with respect to the numbers they hold.\n\nIf no three numbers sum up to the target sum, the function should return an empty array.\n\n\n###Code:\n\n```python\ndef threeNumberSum(array, targetSum):\n    array.sort()\n    triplets = []\n    for i in range(len(array) - 2):\n        left = i + 1\n        right = len(array) - 1\n        while left < right:\n            currentSum = array[i] + array[left] + array[right]\n            if currentSum == targetSum:\n                triplets.append([array[i], array[left], array[right]])\n                left += 1\n                right -= 1\n            elif currentSum < targetSum:\n                left += 1\n            elif currentSum > targetSum:\n                right -= 1\n    return triplets\n```\n\n\n###Testcases: \n\n```python\nassert threeNumberSum([12, 3, 1, 2, -6, 5, -8, 6], 0) == [[-8, 2, 6], [-8, 3, 5], [-6, 1, 5]]\nassert threeNumberSum([1, 2, 3], 6) == [[1, 2, 3]]\nassert threeNumberSum([-1, 0, 1, 2, -1, -4], -1) == [[-4, 0, 3], [-1, -1, 1]]\nassert threeNumberSum([], 0) == []\nassert threeNumberSum([1], 0) == []\n```\n\n[/Example 3]", "temperature": 0.854}, {"few_shots": [{"author": "Calvin", "UUID": "48c6aa37-e00d-4b55-9afc-6b1cf2a1aff2", "question": "There are N Mice and N holes are placed in a straight line. Each hole can accommodate only 1 mouse. A mouse can stay at his position, move one step right from x to x + 1, or move one step left from x to x -1. Any of these moves consumes 1 minute. Assign mice to holes so that the time when the last mouse gets inside a hole is minimized.\nYou are given a list of mice and hole positions as integer scalers.\n", "examples": "Input: Mices = [0, 10, 2, 3], Holes = [3, 2, 23, 0]\nOutput: 13", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def assignHole(mices: list, holes: list) -> int:\n    for i,j in zip(mices,holes):\n        if i<0 or j<0:\n            return -1\n    if (len(mices) != len(holes)):\n        return -1\n    mices.sort()\n    holes.sort()\n    Max = 0\n     \n    for i in range(len(holes)):\n        if (Max < abs(mices[i] - holes[i])):\n            Max = abs(mices[i] - holes[i])\n     \n    return Max\n", "asserts": ["assert assignHole([1, 2, 3, 4], [4, 3, 2, 1]) == 0", "assert assignHole([10, 20, 30, 40], [15, 25, 35, 45]) == 5", "assert assignHole([1, 4, 9, 15], [10, 13, 7, 20]) == 6", "assert assignHole([0], [0]) == 0", "assert assignHole([1, 2], [3]) == -1  # Edge case with non-equal amount of mice and holes", "assert assignHole([5, 5, 5], [5, 5, 5]) == 0  # Edge case with all mice and holes at the same position", "assert assignHole([10, 10, 10, 10], [10, 9, 8, 7]) == 3  # Edge case with multiple mice starting at the same position", "assert assignHole([1,1 ,1, 1, 1, 1, 1, 1, 1, 1], [2,2,2,2,2,2 ,2, 2, 2, 2]) == 1 # Edge case with multiple mice and holes at the same positions", "assert assignHole([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == 1 # Edge case with incremental positions"]}, {"author": "Calvin", "UUID": "a9c5e697-af5d-432b-8447-5675d739c728", "question": "Given an array reorder it so that even numbers appear first", "examples": "Input: [1,2,3,4,5,6,7,8,9]\r\nOutput: [8,2,6,4,5,7,3,9,1]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def even_odd_reorder(arr: list) -> list:\n  nextEven = 0\n  nextOdd = len(arr) - 1\n  while nextEven < nextOdd:\n    if arr[nextEven] % 2 == 0:\n      nextEven += 1\n    else:\n      temp = arr[nextEven]\n      arr[nextEven] = arr[nextOdd]\n      arr[nextOdd] = temp\n      nextOdd -= 1\n  return arr\n", "asserts": ["assert even_odd_reorder([1,2,3,4,5,6,7,8,9]) == [8, 2, 6, 4, 5, 7, 3, 9, 1]", "assert even_odd_reorder([]) == []", "assert even_odd_reorder([2, 4, 6, 8]) == [2, 4, 6, 8]", "assert even_odd_reorder([7, 9, 2]) == [2, 9, 7]", "assert even_odd_reorder([10, 13, 17, 16, 15, 12]) == [10, 12, 16, 15, 17, 13]"]}], "category": "Array", "prompt_tokens": 1067, "total_tokens": 1489, "completion_tokens": 422, "completion": "Given an array of distinct integers, count all the triplets that form an arithmetic progression. A triplet (arr[i], arr[j], arr[k]) forms an arithmetic progression if the elements are in sequence and arr[j] - arr[i] = arr[k] - arr[j], where i < j < k.\n\n###Code:\n\n```python\ndef count_arithmetic_triplets(arr: list) -> int:\n    arr.sort()\n    count = 0\n    n = len(arr)\n    for i in range(n):\n        for j in range(i+1, n):\n            for k in range(j+1, n):\n                if 2 * arr[j] == arr[i] + arr[k]:\n                    count += 1\n    return count\n```\n\n###Testcases:\n\n```python\nassert count_arithmetic_triplets([1, 2, 3, 4, 5]) == 4  # (1, 2, 3), (2, 3, 4), (1, 3, 5), (3, 4, 5)\nassert count_arithmetic_triplets([9, 1, 5, 3, 7]) == 1  # (1, 5, 9)\nassert count_arithmetic_triplets([1, 3, 5]) == 1  # (1, 3, 5)\nassert count_arithmetic_triplets([1, 1, 1]) == 0  # No distinct triplets\nassert count_arithmetic_triplets([1, 7, 10, 13, 14, 19]) == 2  # (7, 10, 13), (10, 14, 19)\nassert count_arithmetic_triplets([]) == 0  # No triplets in an empty list\nassert count_arithmetic_triplets([5, 8, 11, 14, 17, 20]) == 10  # All possible triplets\n```\n\n[/Example 3]", "temperature": 0.771}, {"few_shots": [{"author": "Calvin", "UUID": "9e45b73f-583d-40ab-b387-e0d1624af07b", "question": "Given two arrays return an array with the set intersection of their common elements", "examples": "Input: arr1 = [1, 2, 3, 4], arr2 = [2, 3]\nOutput: [2, 3]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def array_intersection(arr1: list, arr2: list) -> set:\n  set1 = set(arr1)\n  ret = set([x for x in arr2 if x in set1])\n  return list(ret)\n", "asserts": ["assert set(array_intersection([1,0,2,0,2,0,2,1,1,1], [2,1,0,2,0,2,2,2,1,0])) == {0,1,2}", "assert set(array_intersection([5, 6, 7, 8], [8, 9, 10, 11])) == {8}", "assert set(array_intersection([10, 20, 30], [40, 50, 60])) == set()", "assert set(array_intersection([], [1, 2, 3])) == set()", "assert set(array_intersection([-1, -2, -3], [-3, -4, -5, -6])) == {-3}", "assert set(array_intersection([9, 8, 7], [7, 8, 9, 10, 11, 12])) == {7, 8, 9}", "assert set(array_intersection(['a', 'b', 'c'], ['a', 'd', 'e', 'c'])) == {'a', 'c'}", "assert set(array_intersection(['apple', 'banana'], ['banana', 'cherry'])) == {'banana'}", "assert set(array_intersection([1.1, 2.2, 3.3], [2.2, 4.4])) == {2.2}", "assert set(array_intersection([False, True, False], [True, False, True])) == {True, False}", "assert set(array_intersection([(1, 2), (3, 4)], [(3, 4), (5, 6)])) == {(3, 4)}"]}, {"author": "Calvin", "UUID": "fb94082f-4627-4f5a-b280-08d869823d70", "question": "You are given an array of people, people, which are the attributes of some people in a queue (not necessarily in order). Each people[i] = [hi, ki] represents the ith person of height hi with exactly ki other people in front who have a height greater than or equal to hi.\n\nReconstruct and return the queue that is represented by the input array people. The returned queue should be formatted as an array queue, where queue[j] = [hj, kj] is the attributes of the jth person in the queue (queue[0] is the person at the front of the queue).\n", "examples": "Input:  [[7, 0], [4, 4], [7, 1], [5, 0], [6, 1], [5, 2]]\nOutput: [[5, 0], [4, 1], [7, 0], [5, 2], [6, 1], [7, 1]]\n\nInput:  [[6, 0], [5, 0], [4, 0], [3, 2], [2, 2], [1, 4]]\nOutput: [[4, 0], [5, 0], [2, 2], [3, 2], [1, 4], [6, 0]]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "\ndef reconstructQueue(people: list) -> list:\n    output=[] \n    people.sort(key=lambda x: (-x[0], x[1]))                \n    for a in people:\n        output.insert(a[1], a)\n    \n    return output\n", "asserts": ["assert reconstructQueue([[8,1],[5,0],[6,1],[5,2],[4,4],[7,1]]) == [[5, 0], [8, 1], [5, 2], [6, 1], [4, 4], [7, 1]]", "assert reconstructQueue([[12,0], [6,3], [4,4], [9,2], [7,1]]) == [[12, 0], [7, 1], [9, 2], [6, 3], [4, 4]]", "assert reconstructQueue([[2,0], [1,1]]) == [[2, 0], [1, 1]]", "assert reconstructQueue([[3,0], [3,2], [3,1]]) == [[3, 0], [3, 1], [3, 2]]"]}], "category": "Array", "prompt_tokens": 983, "total_tokens": 1366, "completion_tokens": 383, "completion": "Given an array of integers, return a new array such that each element at index i of the new array is the product of all the numbers in the original array except the one at i.\n\n###Code: \n\ndef product_except_self(nums: list) -> list:\n    product = 1\n    zero_count = nums.count(0)\n    if zero_count > 1:\n        return [0] * len(nums)\n    elif zero_count == 1:\n        product_without_zero = 1\n        for num in nums:\n            if num != 0:\n                product_without_zero *= num\n        return [product_without_zero if num == 0 else 0 for num in nums]\n    else:\n        for num in nums:\n            product *= num\n        return [product // num for num in nums]\n\n\n###Testcases: \n\nassert product_except_self([1, 2, 3, 4]) == [24, 12, 8, 6]\nassert product_except_self([0, 1, 2, 3, 4]) == [24, 0, 0, 0, 0]\nassert product_except_self([1, 0, 3, 0]) == [0, 0, 0, 0]\nassert product_except_self([-1, 1, -2, 2]) == [-4, 4, -2, 2]\nassert product_except_self([9]) == [1]\nassert product_except_self([1, -1]) == [-1, 1]\nassert product_except_self([1, 2, 3, 0, 0]) == [0, 0, 0, 0, 0]\nassert product_except_self([-3, 0, 2]) == [0, -6, 0]\n\n[/Example 3]", "temperature": 0.837}, {"few_shots": [{"author": "Calvin", "UUID": "fb94082f-4627-4f5a-b280-08d869823d70", "question": "You are given an array of people, people, which are the attributes of some people in a queue (not necessarily in order). Each people[i] = [hi, ki] represents the ith person of height hi with exactly ki other people in front who have a height greater than or equal to hi.\n\nReconstruct and return the queue that is represented by the input array people. The returned queue should be formatted as an array queue, where queue[j] = [hj, kj] is the attributes of the jth person in the queue (queue[0] is the person at the front of the queue).\n", "examples": "Input:  [[7, 0], [4, 4], [7, 1], [5, 0], [6, 1], [5, 2]]\nOutput: [[5, 0], [4, 1], [7, 0], [5, 2], [6, 1], [7, 1]]\n\nInput:  [[6, 0], [5, 0], [4, 0], [3, 2], [2, 2], [1, 4]]\nOutput: [[4, 0], [5, 0], [2, 2], [3, 2], [1, 4], [6, 0]]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "\ndef reconstructQueue(people: list) -> list:\n    output=[] \n    people.sort(key=lambda x: (-x[0], x[1]))                \n    for a in people:\n        output.insert(a[1], a)\n    \n    return output\n", "asserts": ["assert reconstructQueue([[8,1],[5,0],[6,1],[5,2],[4,4],[7,1]]) == [[5, 0], [8, 1], [5, 2], [6, 1], [4, 4], [7, 1]]", "assert reconstructQueue([[12,0], [6,3], [4,4], [9,2], [7,1]]) == [[12, 0], [7, 1], [9, 2], [6, 3], [4, 4]]", "assert reconstructQueue([[2,0], [1,1]]) == [[2, 0], [1, 1]]", "assert reconstructQueue([[3,0], [3,2], [3,1]]) == [[3, 0], [3, 1], [3, 2]]"]}, {"author": "Calvin", "UUID": "9e45b73f-583d-40ab-b387-e0d1624af07b", "question": "Given two arrays return an array with the set intersection of their common elements", "examples": "Input: arr1 = [1, 2, 3, 4], arr2 = [2, 3]\nOutput: [2, 3]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def array_intersection(arr1: list, arr2: list) -> set:\n  set1 = set(arr1)\n  ret = set([x for x in arr2 if x in set1])\n  return list(ret)\n", "asserts": ["assert set(array_intersection([1,0,2,0,2,0,2,1,1,1], [2,1,0,2,0,2,2,2,1,0])) == {0,1,2}", "assert set(array_intersection([5, 6, 7, 8], [8, 9, 10, 11])) == {8}", "assert set(array_intersection([10, 20, 30], [40, 50, 60])) == set()", "assert set(array_intersection([], [1, 2, 3])) == set()", "assert set(array_intersection([-1, -2, -3], [-3, -4, -5, -6])) == {-3}", "assert set(array_intersection([9, 8, 7], [7, 8, 9, 10, 11, 12])) == {7, 8, 9}", "assert set(array_intersection(['a', 'b', 'c'], ['a', 'd', 'e', 'c'])) == {'a', 'c'}", "assert set(array_intersection(['apple', 'banana'], ['banana', 'cherry'])) == {'banana'}", "assert set(array_intersection([1.1, 2.2, 3.3], [2.2, 4.4])) == {2.2}", "assert set(array_intersection([False, True, False], [True, False, True])) == {True, False}", "assert set(array_intersection([(1, 2), (3, 4)], [(3, 4), (5, 6)])) == {(3, 4)}"]}], "category": "Array", "prompt_tokens": 983, "total_tokens": 1341, "completion_tokens": 358, "completion": "Write a function that takes an array of integers and returns a new array containing only the unique elements from the original array, sorted in ascending order.\n\n###Code:\n\n```python\ndef unique_elements_sorted(arr: list) -> list:\n    return sorted(list(set(arr)))\n\n###Testcases:\n\nassert unique_elements_sorted([1, 2, 5, 2, 3, 5, 1, 7]) == [1, 2, 3, 5, 7]\nassert unique_elements_sorted([4, 6, 4, 2, 6, 4]) == [2, 4, 6]\nassert unique_elements_sorted([100, 100, 100]) == [100]\nassert unique_elements_sorted([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5]\nassert unique_elements_sorted([]) == []\nassert unique_elements_sorted([-3, -1, -2, -1, -3]) == [-3, -2, -1]\nassert unique_elements_sorted([1]) == [1]\nassert unique_elements_sorted([2, 3, 2, 3, 4, 3, 2]) == [2, 3, 4]\nassert unique_elements_sorted([10, 9, 8, 8, 9, 10, 11]) == [8, 9, 10, 11]\nassert unique_elements_sorted([1.1, 2.2, 3.3, 2.2, 1.1]) == [1.1, 2.2, 3.3]\n```\n\n[/Example 3]", "temperature": 0.762}, {"few_shots": [{"author": "Calvin", "UUID": "9e45b73f-583d-40ab-b387-e0d1624af07b", "question": "Given two arrays return an array with the set intersection of their common elements", "examples": "Input: arr1 = [1, 2, 3, 4], arr2 = [2, 3]\nOutput: [2, 3]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def array_intersection(arr1: list, arr2: list) -> set:\n  set1 = set(arr1)\n  ret = set([x for x in arr2 if x in set1])\n  return list(ret)\n", "asserts": ["assert set(array_intersection([1,0,2,0,2,0,2,1,1,1], [2,1,0,2,0,2,2,2,1,0])) == {0,1,2}", "assert set(array_intersection([5, 6, 7, 8], [8, 9, 10, 11])) == {8}", "assert set(array_intersection([10, 20, 30], [40, 50, 60])) == set()", "assert set(array_intersection([], [1, 2, 3])) == set()", "assert set(array_intersection([-1, -2, -3], [-3, -4, -5, -6])) == {-3}", "assert set(array_intersection([9, 8, 7], [7, 8, 9, 10, 11, 12])) == {7, 8, 9}", "assert set(array_intersection(['a', 'b', 'c'], ['a', 'd', 'e', 'c'])) == {'a', 'c'}", "assert set(array_intersection(['apple', 'banana'], ['banana', 'cherry'])) == {'banana'}", "assert set(array_intersection([1.1, 2.2, 3.3], [2.2, 4.4])) == {2.2}", "assert set(array_intersection([False, True, False], [True, False, True])) == {True, False}", "assert set(array_intersection([(1, 2), (3, 4)], [(3, 4), (5, 6)])) == {(3, 4)}"]}, {"author": "Calvin", "UUID": "f795bda7-9822-4bc5-9c7e-b9c0f2752085", "question": "You are given two 0-indexed integer permutations A and B of length n.\n\nA prefix common array of A and B is an array C such that C[i] is equal to the count of numbers that are present at or before the index i in both A and B.\n\nReturn the prefix common array of A and B.\n\nA sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once.", "examples": "Input: A = [1,3,2,4], B = [3,1,2,4]\nOutput: [0,2,3,4]", "link": "https://leetcode.com/problems/find-the-prefix-common-array-of-two-arrays/", "difficulty": null, "categories": ["Array"], "code": "def findThePrefixCommonArray(arr1: list, arr2: list) -> list:\n  max = len(arr1) if len(arr1) > len(arr2) else len(arr2)\n  seen = set()\n  curCount = 0\n  ret = []\n  for i in range(max):\n    cur1 = arr1[i]\n    cur2 = arr2[i]\n    if cur1 in seen:\n      curCount += 1\n    else:\n      seen.add(cur1)\n    if cur2 in seen:\n      curCount += 1\n    else:\n      seen.add(cur2)\n    ret.append(curCount)\n  return ret\n", "asserts": ["assert findThePrefixCommonArray([1,3,2,4], [3,1,2,4]) == [0,2,3,4]", "assert findThePrefixCommonArray([1], [1]) == [1]", "assert findThePrefixCommonArray([2,3,1], [3,1,2]) == [0,1,3]"]}], "category": "Array", "prompt_tokens": 922, "total_tokens": 1358, "completion_tokens": 436, "completion": "Given an array of integers, return the array where each position has been replaced with the product of all other elements in the array, except the number at that position itself. You are not allowed to use division in your solution.\n\n###Code: \n\ndef product_except_self(nums: list) -> list:\n    length = len(nums)\n    answer = [0]*length\n\n    # answer[i] contains the product of all the elements to the left\n    # Note: for the element at index '0', there are no elements to the left,\n    # so the answer[0] would be 1\n    answer[0] = 1\n    for i in range(1, length):\n        answer[i] = nums[i - 1] * answer[i - 1]\n\n    # R contains the product of all the elements to the right\n    # Note: for the element at index 'length - 1', there are no elements to the right,\n    # so the R would be 1\n    R = 1;\n    for i in reversed(range(length)):\n        # For the index 'i', R would contain the\n        # product of all elements to the right. We update R accordingly\n        answer[i] = answer[i] * R\n        R *= nums[i]\n\n    return answer\n\n###Testcases: \n\nassert product_except_self([1, 2, 3, 4]) == [24, 12, 8, 6]\nassert product_except_self([0, 0]) == [0, 0]\nassert product_except_self([1, 0]) == [0, 1]\nassert product_except_self([-1, 1, 0, -3, 3]) == [0, 0, 9, 0, 0]\nassert product_except_self([5, 2, 4, 1, 3]) == [24, 60, 30, 120, 40]\nassert product_except_self([2, 5, 7]) == [35, 14, 10]\n\n[/Example 3]", "temperature": 0.785}, {"few_shots": [{"author": "Calvin", "UUID": "f795bda7-9822-4bc5-9c7e-b9c0f2752085", "question": "You are given two 0-indexed integer permutations A and B of length n.\n\nA prefix common array of A and B is an array C such that C[i] is equal to the count of numbers that are present at or before the index i in both A and B.\n\nReturn the prefix common array of A and B.\n\nA sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once.", "examples": "Input: A = [1,3,2,4], B = [3,1,2,4]\nOutput: [0,2,3,4]", "link": "https://leetcode.com/problems/find-the-prefix-common-array-of-two-arrays/", "difficulty": null, "categories": ["Array"], "code": "def findThePrefixCommonArray(arr1: list, arr2: list) -> list:\n  max = len(arr1) if len(arr1) > len(arr2) else len(arr2)\n  seen = set()\n  curCount = 0\n  ret = []\n  for i in range(max):\n    cur1 = arr1[i]\n    cur2 = arr2[i]\n    if cur1 in seen:\n      curCount += 1\n    else:\n      seen.add(cur1)\n    if cur2 in seen:\n      curCount += 1\n    else:\n      seen.add(cur2)\n    ret.append(curCount)\n  return ret\n", "asserts": ["assert findThePrefixCommonArray([1,3,2,4], [3,1,2,4]) == [0,2,3,4]", "assert findThePrefixCommonArray([1], [1]) == [1]", "assert findThePrefixCommonArray([2,3,1], [3,1,2]) == [0,1,3]"]}, {"author": "Calvin", "UUID": "a9c5e697-af5d-432b-8447-5675d739c728", "question": "Given an array reorder it so that even numbers appear first", "examples": "Input: [1,2,3,4,5,6,7,8,9]\r\nOutput: [8,2,6,4,5,7,3,9,1]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def even_odd_reorder(arr: list) -> list:\n  nextEven = 0\n  nextOdd = len(arr) - 1\n  while nextEven < nextOdd:\n    if arr[nextEven] % 2 == 0:\n      nextEven += 1\n    else:\n      temp = arr[nextEven]\n      arr[nextEven] = arr[nextOdd]\n      arr[nextOdd] = temp\n      nextOdd -= 1\n  return arr\n", "asserts": ["assert even_odd_reorder([1,2,3,4,5,6,7,8,9]) == [8, 2, 6, 4, 5, 7, 3, 9, 1]", "assert even_odd_reorder([]) == []", "assert even_odd_reorder([2, 4, 6, 8]) == [2, 4, 6, 8]", "assert even_odd_reorder([7, 9, 2]) == [2, 9, 7]", "assert even_odd_reorder([10, 13, 17, 16, 15, 12]) == [10, 12, 16, 15, 17, 13]"]}], "category": "Array", "prompt_tokens": 781, "total_tokens": 1070, "completion_tokens": 289, "completion": "Given an array of integers, return the indices of the two numbers that add up to a specific target.\n\nYou may assume that each input would have exactly one solution, and you may not use the same element twice.\n\n###Code: \n\n```python\ndef two_sum(nums: list, target: int) -> list:\n    num_to_index = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_to_index:\n            return [num_to_index[complement], i]\n        num_to_index[num] = i\n    return []\n```\n\n###Testcases: \n\n```python\nassert two_sum([2, 7, 11, 15], 9) == [0, 1], \"Test case 1 failed\"\nassert two_sum([3, 2, 4], 6) == [1, 2], \"Test case 2 failed\"\nassert two_sum([3, 3], 6) == [0, 1], \"Test case 3 failed\"\nassert two_sum([0, 4, 3, 0], 0) == [0, 3], \"Test case 4 failed\"\nassert two_sum([-1, -2, -3, -4, -5], -8) == [2, 4], \"Test case 5 failed\"\n```\n\n[/Example 3]", "temperature": 0.755}, {"few_shots": [{"author": "Calvin", "UUID": "fb94082f-4627-4f5a-b280-08d869823d70", "question": "You are given an array of people, people, which are the attributes of some people in a queue (not necessarily in order). Each people[i] = [hi, ki] represents the ith person of height hi with exactly ki other people in front who have a height greater than or equal to hi.\n\nReconstruct and return the queue that is represented by the input array people. The returned queue should be formatted as an array queue, where queue[j] = [hj, kj] is the attributes of the jth person in the queue (queue[0] is the person at the front of the queue).\n", "examples": "Input:  [[7, 0], [4, 4], [7, 1], [5, 0], [6, 1], [5, 2]]\nOutput: [[5, 0], [4, 1], [7, 0], [5, 2], [6, 1], [7, 1]]\n\nInput:  [[6, 0], [5, 0], [4, 0], [3, 2], [2, 2], [1, 4]]\nOutput: [[4, 0], [5, 0], [2, 2], [3, 2], [1, 4], [6, 0]]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "\ndef reconstructQueue(people: list) -> list:\n    output=[] \n    people.sort(key=lambda x: (-x[0], x[1]))                \n    for a in people:\n        output.insert(a[1], a)\n    \n    return output\n", "asserts": ["assert reconstructQueue([[8,1],[5,0],[6,1],[5,2],[4,4],[7,1]]) == [[5, 0], [8, 1], [5, 2], [6, 1], [4, 4], [7, 1]]", "assert reconstructQueue([[12,0], [6,3], [4,4], [9,2], [7,1]]) == [[12, 0], [7, 1], [9, 2], [6, 3], [4, 4]]", "assert reconstructQueue([[2,0], [1,1]]) == [[2, 0], [1, 1]]", "assert reconstructQueue([[3,0], [3,2], [3,1]]) == [[3, 0], [3, 1], [3, 2]]"]}, {"author": "Calvin", "UUID": "1aeb3246-4c22-4d34-a48c-db7be8ba1b94", "question": "You are given n activities with their start and finish times. Select the maximum number of activities that can be performed by a single person and return their indexes. Assume that a person can only work on a single activity at a time. \n", "examples": "Input: start  =  {10, 12, 20}, finish =  {20, 25, 30}\nOutput: [0, 2]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "import numpy as np\ndef MaxActivities(s: list, f: list) -> list:\n    indices = np.argsort(f)\n    [s[i] for i in indices]\n    [f[i] for i in indices]\n    result = []\n    n = len(f)\n    i = 0\n    result.append(i)\n    for j in range(1, n):\n        if s[j] >= f[i]:\n            result.append(j)\n            i = j\n    return result\n", "asserts": ["assert MaxActivities([2, 4, 5, 6, 7, 8], [3, 5, 6, 7, 9, 10]) == [0, 1, 2, 3, 4]", "assert MaxActivities([1, 3, 0, 5, 8, 5], [2, 4, 6, 7, 9, 9]) == [0, 1, 3, 4]", "assert MaxActivities([1], [2]) == [0]"]}], "category": "Array", "prompt_tokens": 843, "total_tokens": 1136, "completion_tokens": 293, "completion": "Given an array of integers, find the continuous subarray within the array (containing at least one number) which has the largest sum and return that sum. Also, return the starting and ending indices of that subarray.\n\n###Code: \n\ndef maxSubArray(nums: list) -> (int, int, int):\n    max_sum = nums[0]\n    current_sum = nums[0]\n    start = end = 0\n    temp_start = 0\n\n    for i in range(1, len(nums)):\n        if nums[i] > current_sum + nums[i]:\n            temp_start = i\n            current_sum = nums[i]\n        else:\n            current_sum += nums[i]\n\n        if current_sum > max_sum:\n            max_sum = current_sum\n            start = temp_start\n            end = i\n\n    return max_sum, start, end\n\n###Testcases: \n\nassert maxSubArray([-2,1,-3,4,-1,2,1,-5,4]) == (6, 3, 6)\nassert maxSubArray([1]) == (1, 0, 0)\nassert maxSubArray([5,4,-1,7,8]) == (23, 0, 4)\nassert maxSubArray([-2,-3,4,-1,-2,1,5,-3]) == (7, 2, 6)\n\n[/Example 3]", "temperature": 0.702}, {"few_shots": [{"author": "Calvin", "UUID": "48c6aa37-e00d-4b55-9afc-6b1cf2a1aff2", "question": "There are N Mice and N holes are placed in a straight line. Each hole can accommodate only 1 mouse. A mouse can stay at his position, move one step right from x to x + 1, or move one step left from x to x -1. Any of these moves consumes 1 minute. Assign mice to holes so that the time when the last mouse gets inside a hole is minimized.\nYou are given a list of mice and hole positions as integer scalers.\n", "examples": "Input: Mices = [0, 10, 2, 3], Holes = [3, 2, 23, 0]\nOutput: 13", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def assignHole(mices: list, holes: list) -> int:\n    for i,j in zip(mices,holes):\n        if i<0 or j<0:\n            return -1\n    if (len(mices) != len(holes)):\n        return -1\n    mices.sort()\n    holes.sort()\n    Max = 0\n     \n    for i in range(len(holes)):\n        if (Max < abs(mices[i] - holes[i])):\n            Max = abs(mices[i] - holes[i])\n     \n    return Max\n", "asserts": ["assert assignHole([1, 2, 3, 4], [4, 3, 2, 1]) == 0", "assert assignHole([10, 20, 30, 40], [15, 25, 35, 45]) == 5", "assert assignHole([1, 4, 9, 15], [10, 13, 7, 20]) == 6", "assert assignHole([0], [0]) == 0", "assert assignHole([1, 2], [3]) == -1  # Edge case with non-equal amount of mice and holes", "assert assignHole([5, 5, 5], [5, 5, 5]) == 0  # Edge case with all mice and holes at the same position", "assert assignHole([10, 10, 10, 10], [10, 9, 8, 7]) == 3  # Edge case with multiple mice starting at the same position", "assert assignHole([1,1 ,1, 1, 1, 1, 1, 1, 1, 1], [2,2,2,2,2,2 ,2, 2, 2, 2]) == 1 # Edge case with multiple mice and holes at the same positions", "assert assignHole([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == 1 # Edge case with incremental positions"]}, {"author": "Calvin", "UUID": "1aeb3246-4c22-4d34-a48c-db7be8ba1b94", "question": "You are given n activities with their start and finish times. Select the maximum number of activities that can be performed by a single person and return their indexes. Assume that a person can only work on a single activity at a time. \n", "examples": "Input: start  =  {10, 12, 20}, finish =  {20, 25, 30}\nOutput: [0, 2]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "import numpy as np\ndef MaxActivities(s: list, f: list) -> list:\n    indices = np.argsort(f)\n    [s[i] for i in indices]\n    [f[i] for i in indices]\n    result = []\n    n = len(f)\n    i = 0\n    result.append(i)\n    for j in range(1, n):\n        if s[j] >= f[i]:\n            result.append(j)\n            i = j\n    return result\n", "asserts": ["assert MaxActivities([2, 4, 5, 6, 7, 8], [3, 5, 6, 7, 9, 10]) == [0, 1, 2, 3, 4]", "assert MaxActivities([1, 3, 0, 5, 8, 5], [2, 4, 6, 7, 9, 9]) == [0, 1, 3, 4]", "assert MaxActivities([1], [2]) == [0]"]}], "category": "Array", "prompt_tokens": 1068, "total_tokens": 1498, "completion_tokens": 430, "completion": "Given an array of integers, write a function to return the length of the longest subarray with a sum equal to zero.\n\n###Code:\n\n```python\ndef longestSubarrayWithZeroSum(arr: list) -> int:\n    # Create a dictionary to store index of all zero sum subarrays\n    hash_map = {}\n    max_len = 0\n    curr_sum = 0\n    \n    # Traverse through the given array\n    for i in range(len(arr)):\n        # Add the current element to the sum\n        curr_sum += arr[i]\n        \n        if arr[i] == 0 and max_len == 0:\n            max_len = 1\n            \n        if curr_sum == 0:\n            max_len = i + 1\n            \n        # Look this sum in hash table\n        if curr_sum in hash_map:\n            # If this sum is seen before, then update max_len\n            max_len = max(max_len, i - hash_map[curr_sum])\n        else:\n            # Else insert this sum with index in hash_table\n            hash_map[curr_sum] = i\n        \n    return max_len\n```\n\n###Testcases:\n\n```python\nassert longestSubarrayWithZeroSum([15, -2, 2, -8, 1, 7, 10, 23]) == 5\nassert longestSubarrayWithZeroSum([1, 2, 3]) == 0\nassert longestSubarrayWithZeroSum([1, 0, 3]) == 1\nassert longestSubarrayWithZeroSum([1, 2, -3]) == 3\nassert longestSubarrayWithZeroSum([0, 0, 0, 0]) == 4\nassert longestSubarrayWithZeroSum([-1, 1, -1, 1]) == 4\nassert longestSubarrayWithZeroSum([1, -1, 1, -1, 1]) == 2\nassert longestSubarrayWithZeroSum([]) == 0  # Edge case with empty array\n```\n\n[/Example 3]", "temperature": 0.827}, {"few_shots": [{"author": "Calvin", "UUID": "fb94082f-4627-4f5a-b280-08d869823d70", "question": "You are given an array of people, people, which are the attributes of some people in a queue (not necessarily in order). Each people[i] = [hi, ki] represents the ith person of height hi with exactly ki other people in front who have a height greater than or equal to hi.\n\nReconstruct and return the queue that is represented by the input array people. The returned queue should be formatted as an array queue, where queue[j] = [hj, kj] is the attributes of the jth person in the queue (queue[0] is the person at the front of the queue).\n", "examples": "Input:  [[7, 0], [4, 4], [7, 1], [5, 0], [6, 1], [5, 2]]\nOutput: [[5, 0], [4, 1], [7, 0], [5, 2], [6, 1], [7, 1]]\n\nInput:  [[6, 0], [5, 0], [4, 0], [3, 2], [2, 2], [1, 4]]\nOutput: [[4, 0], [5, 0], [2, 2], [3, 2], [1, 4], [6, 0]]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "\ndef reconstructQueue(people: list) -> list:\n    output=[] \n    people.sort(key=lambda x: (-x[0], x[1]))                \n    for a in people:\n        output.insert(a[1], a)\n    \n    return output\n", "asserts": ["assert reconstructQueue([[8,1],[5,0],[6,1],[5,2],[4,4],[7,1]]) == [[5, 0], [8, 1], [5, 2], [6, 1], [4, 4], [7, 1]]", "assert reconstructQueue([[12,0], [6,3], [4,4], [9,2], [7,1]]) == [[12, 0], [7, 1], [9, 2], [6, 3], [4, 4]]", "assert reconstructQueue([[2,0], [1,1]]) == [[2, 0], [1, 1]]", "assert reconstructQueue([[3,0], [3,2], [3,1]]) == [[3, 0], [3, 1], [3, 2]]"]}, {"author": "Calvin", "UUID": "48c6aa37-e00d-4b55-9afc-6b1cf2a1aff2", "question": "There are N Mice and N holes are placed in a straight line. Each hole can accommodate only 1 mouse. A mouse can stay at his position, move one step right from x to x + 1, or move one step left from x to x -1. Any of these moves consumes 1 minute. Assign mice to holes so that the time when the last mouse gets inside a hole is minimized.\nYou are given a list of mice and hole positions as integer scalers.\n", "examples": "Input: Mices = [0, 10, 2, 3], Holes = [3, 2, 23, 0]\nOutput: 13", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def assignHole(mices: list, holes: list) -> int:\n    for i,j in zip(mices,holes):\n        if i<0 or j<0:\n            return -1\n    if (len(mices) != len(holes)):\n        return -1\n    mices.sort()\n    holes.sort()\n    Max = 0\n     \n    for i in range(len(holes)):\n        if (Max < abs(mices[i] - holes[i])):\n            Max = abs(mices[i] - holes[i])\n     \n    return Max\n", "asserts": ["assert assignHole([1, 2, 3, 4], [4, 3, 2, 1]) == 0", "assert assignHole([10, 20, 30, 40], [15, 25, 35, 45]) == 5", "assert assignHole([1, 4, 9, 15], [10, 13, 7, 20]) == 6", "assert assignHole([0], [0]) == 0", "assert assignHole([1, 2], [3]) == -1  # Edge case with non-equal amount of mice and holes", "assert assignHole([5, 5, 5], [5, 5, 5]) == 0  # Edge case with all mice and holes at the same position", "assert assignHole([10, 10, 10, 10], [10, 9, 8, 7]) == 3  # Edge case with multiple mice starting at the same position", "assert assignHole([1,1 ,1, 1, 1, 1, 1, 1, 1, 1], [2,2,2,2,2,2 ,2, 2, 2, 2]) == 1 # Edge case with multiple mice and holes at the same positions", "assert assignHole([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == 1 # Edge case with incremental positions"]}], "category": "Array", "prompt_tokens": 1164, "total_tokens": 1611, "completion_tokens": 447, "completion": "Given an array of integers, write a function that returns the length of the longest increasing subsequence (LIS) in the array. The longest increasing subsequence is a subsequence of a given sequence in which the subsequence's elements are in sorted order, lowest to highest, and in which the subsequence is as long as possible. This subsequence is not necessarily contiguous or unique.\n\n###Code:\n\n```python\ndef lengthOfLIS(nums: list) -> int:\n    if not nums:\n        return 0\n    dp = [1] * len(nums)\n    for i in range(len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n```\n\n###Testcases:\n\n```python\nassert lengthOfLIS([10, 9, 2, 5, 3, 7, 101, 18]) == 4\nassert lengthOfLIS([0, 1, 0, 3, 2, 3]) == 4\nassert lengthOfLIS([7, 7, 7, 7, 7, 7, 7]) == 1\nassert lengthOfLIS([1, 3, 6, 7, 9, 4, 10, 5, 6]) == 6\nassert lengthOfLIS([]) == 0  # Edge case with an empty array\nassert lengthOfLIS([10]) == 1  # Edge case with a single element\nassert lengthOfLIS([-2, -1]) == 2  # Edge case with negative numbers\nassert lengthOfLIS([2, 2, 2, 2, 2]) == 1  # Edge case with all elements being the same\nassert lengthOfLIS([3, 5, 6, 2, 5, 4, 19, 5, 6, 7, 12]) == 6  # General case with mixed numbers\n```\n\n[/Example 3]", "temperature": 0.702}, {"few_shots": [{"author": "Calvin", "UUID": "f795bda7-9822-4bc5-9c7e-b9c0f2752085", "question": "You are given two 0-indexed integer permutations A and B of length n.\n\nA prefix common array of A and B is an array C such that C[i] is equal to the count of numbers that are present at or before the index i in both A and B.\n\nReturn the prefix common array of A and B.\n\nA sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once.", "examples": "Input: A = [1,3,2,4], B = [3,1,2,4]\nOutput: [0,2,3,4]", "link": "https://leetcode.com/problems/find-the-prefix-common-array-of-two-arrays/", "difficulty": null, "categories": ["Array"], "code": "def findThePrefixCommonArray(arr1: list, arr2: list) -> list:\n  max = len(arr1) if len(arr1) > len(arr2) else len(arr2)\n  seen = set()\n  curCount = 0\n  ret = []\n  for i in range(max):\n    cur1 = arr1[i]\n    cur2 = arr2[i]\n    if cur1 in seen:\n      curCount += 1\n    else:\n      seen.add(cur1)\n    if cur2 in seen:\n      curCount += 1\n    else:\n      seen.add(cur2)\n    ret.append(curCount)\n  return ret\n", "asserts": ["assert findThePrefixCommonArray([1,3,2,4], [3,1,2,4]) == [0,2,3,4]", "assert findThePrefixCommonArray([1], [1]) == [1]", "assert findThePrefixCommonArray([2,3,1], [3,1,2]) == [0,1,3]"]}, {"author": "Calvin", "UUID": "9e45b73f-583d-40ab-b387-e0d1624af07b", "question": "Given two arrays return an array with the set intersection of their common elements", "examples": "Input: arr1 = [1, 2, 3, 4], arr2 = [2, 3]\nOutput: [2, 3]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def array_intersection(arr1: list, arr2: list) -> set:\n  set1 = set(arr1)\n  ret = set([x for x in arr2 if x in set1])\n  return list(ret)\n", "asserts": ["assert set(array_intersection([1,0,2,0,2,0,2,1,1,1], [2,1,0,2,0,2,2,2,1,0])) == {0,1,2}", "assert set(array_intersection([5, 6, 7, 8], [8, 9, 10, 11])) == {8}", "assert set(array_intersection([10, 20, 30], [40, 50, 60])) == set()", "assert set(array_intersection([], [1, 2, 3])) == set()", "assert set(array_intersection([-1, -2, -3], [-3, -4, -5, -6])) == {-3}", "assert set(array_intersection([9, 8, 7], [7, 8, 9, 10, 11, 12])) == {7, 8, 9}", "assert set(array_intersection(['a', 'b', 'c'], ['a', 'd', 'e', 'c'])) == {'a', 'c'}", "assert set(array_intersection(['apple', 'banana'], ['banana', 'cherry'])) == {'banana'}", "assert set(array_intersection([1.1, 2.2, 3.3], [2.2, 4.4])) == {2.2}", "assert set(array_intersection([False, True, False], [True, False, True])) == {True, False}", "assert set(array_intersection([(1, 2), (3, 4)], [(3, 4), (5, 6)])) == {(3, 4)}"]}], "category": "Array", "prompt_tokens": 922, "total_tokens": 1237, "completion_tokens": 315, "completion": "Given an array of integers, return the array with all its elements sorted in non-decreasing order.\n\n###Code: \n\ndef sort_array(arr: list) -> list:\n    return sorted(arr)\n\n###Testcases: \n\nassert sort_array([4, 2, 5, 1, 3]) == [1, 2, 3, 4, 5]\nassert sort_array([10, 9, 8, 7, 6]) == [6, 7, 8, 9, 10]\nassert sort_array([5]) == [5]\nassert sort_array([]) == []\nassert sort_array([3, 3, 3]) == [3, 3, 3]\nassert sort_array([-1, -5, -3]) == [-5, -3, -1]\nassert sort_array([4, 1, 4, 2, 4]) == [1, 2, 4, 4, 4]\nassert sort_array([0, 0, 0, -1]) == [-1, 0, 0, 0]\nassert sort_array([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]  # already sorted\nassert sort_array([-2, -2, -2, -2]) == [-2, -2, -2, -2]  # all elements are the same\n\n[/Example 3]", "temperature": 0.687}, {"few_shots": [{"author": "Calvin", "UUID": "a9c5e697-af5d-432b-8447-5675d739c728", "question": "Given an array reorder it so that even numbers appear first", "examples": "Input: [1,2,3,4,5,6,7,8,9]\r\nOutput: [8,2,6,4,5,7,3,9,1]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def even_odd_reorder(arr: list) -> list:\n  nextEven = 0\n  nextOdd = len(arr) - 1\n  while nextEven < nextOdd:\n    if arr[nextEven] % 2 == 0:\n      nextEven += 1\n    else:\n      temp = arr[nextEven]\n      arr[nextEven] = arr[nextOdd]\n      arr[nextOdd] = temp\n      nextOdd -= 1\n  return arr\n", "asserts": ["assert even_odd_reorder([1,2,3,4,5,6,7,8,9]) == [8, 2, 6, 4, 5, 7, 3, 9, 1]", "assert even_odd_reorder([]) == []", "assert even_odd_reorder([2, 4, 6, 8]) == [2, 4, 6, 8]", "assert even_odd_reorder([7, 9, 2]) == [2, 9, 7]", "assert even_odd_reorder([10, 13, 17, 16, 15, 12]) == [10, 12, 16, 15, 17, 13]"]}, {"author": "Calvin", "UUID": "9e45b73f-583d-40ab-b387-e0d1624af07b", "question": "Given two arrays return an array with the set intersection of their common elements", "examples": "Input: arr1 = [1, 2, 3, 4], arr2 = [2, 3]\nOutput: [2, 3]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def array_intersection(arr1: list, arr2: list) -> set:\n  set1 = set(arr1)\n  ret = set([x for x in arr2 if x in set1])\n  return list(ret)\n", "asserts": ["assert set(array_intersection([1,0,2,0,2,0,2,1,1,1], [2,1,0,2,0,2,2,2,1,0])) == {0,1,2}", "assert set(array_intersection([5, 6, 7, 8], [8, 9, 10, 11])) == {8}", "assert set(array_intersection([10, 20, 30], [40, 50, 60])) == set()", "assert set(array_intersection([], [1, 2, 3])) == set()", "assert set(array_intersection([-1, -2, -3], [-3, -4, -5, -6])) == {-3}", "assert set(array_intersection([9, 8, 7], [7, 8, 9, 10, 11, 12])) == {7, 8, 9}", "assert set(array_intersection(['a', 'b', 'c'], ['a', 'd', 'e', 'c'])) == {'a', 'c'}", "assert set(array_intersection(['apple', 'banana'], ['banana', 'cherry'])) == {'banana'}", "assert set(array_intersection([1.1, 2.2, 3.3], [2.2, 4.4])) == {2.2}", "assert set(array_intersection([False, True, False], [True, False, True])) == {True, False}", "assert set(array_intersection([(1, 2), (3, 4)], [(3, 4), (5, 6)])) == {(3, 4)}"]}], "category": "Array", "prompt_tokens": 886, "total_tokens": 1253, "completion_tokens": 367, "completion": "Given an array of integers, move all zeros to the end while maintaining the relative order of the non-zero elements.\n\n###Code: \n\ndef move_zeros_to_end(arr: list) -> list:\n    non_zero_pos = 0\n    for i in range(len(arr)):\n        if arr[i] != 0:\n            arr[non_zero_pos], arr[i] = arr[i], arr[non_zero_pos]\n            non_zero_pos += 1\n    return arr\n\n###Testcases: \n\nassert move_zeros_to_end([0,1,0,3,12]) == [1,3,12,0,0]\nassert move_zeros_to_end([0,0,0]) == [0,0,0]\nassert move_zeros_to_end([4,2,4,0,0,3,0,5,1,0]) == [4,2,4,3,5,1,0,0,0,0]\nassert move_zeros_to_end([1,7,3,0,0,9,0,13,0,5]) == [1,7,3,9,13,5,0,0,0,0]\nassert move_zeros_to_end([4,0,5,0,0,0,1,4]) == [4,5,1,4,0,0,0,0]\nassert move_zeros_to_end([]) == []\nassert move_zeros_to_end([1,2,3,4,5]) == [1,2,3,4,5]\nassert move_zeros_to_end([0,1,0,3,0,5,0,7]) == [1,3,5,7,0,0,0,0]\n\n[/Example 3]", "temperature": 0.852}, {"few_shots": [{"author": "Calvin", "UUID": "9e45b73f-583d-40ab-b387-e0d1624af07b", "question": "Given two arrays return an array with the set intersection of their common elements", "examples": "Input: arr1 = [1, 2, 3, 4], arr2 = [2, 3]\nOutput: [2, 3]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def array_intersection(arr1: list, arr2: list) -> set:\n  set1 = set(arr1)\n  ret = set([x for x in arr2 if x in set1])\n  return list(ret)\n", "asserts": ["assert set(array_intersection([1,0,2,0,2,0,2,1,1,1], [2,1,0,2,0,2,2,2,1,0])) == {0,1,2}", "assert set(array_intersection([5, 6, 7, 8], [8, 9, 10, 11])) == {8}", "assert set(array_intersection([10, 20, 30], [40, 50, 60])) == set()", "assert set(array_intersection([], [1, 2, 3])) == set()", "assert set(array_intersection([-1, -2, -3], [-3, -4, -5, -6])) == {-3}", "assert set(array_intersection([9, 8, 7], [7, 8, 9, 10, 11, 12])) == {7, 8, 9}", "assert set(array_intersection(['a', 'b', 'c'], ['a', 'd', 'e', 'c'])) == {'a', 'c'}", "assert set(array_intersection(['apple', 'banana'], ['banana', 'cherry'])) == {'banana'}", "assert set(array_intersection([1.1, 2.2, 3.3], [2.2, 4.4])) == {2.2}", "assert set(array_intersection([False, True, False], [True, False, True])) == {True, False}", "assert set(array_intersection([(1, 2), (3, 4)], [(3, 4), (5, 6)])) == {(3, 4)}"]}, {"author": "Calvin", "UUID": "f795bda7-9822-4bc5-9c7e-b9c0f2752085", "question": "You are given two 0-indexed integer permutations A and B of length n.\n\nA prefix common array of A and B is an array C such that C[i] is equal to the count of numbers that are present at or before the index i in both A and B.\n\nReturn the prefix common array of A and B.\n\nA sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once.", "examples": "Input: A = [1,3,2,4], B = [3,1,2,4]\nOutput: [0,2,3,4]", "link": "https://leetcode.com/problems/find-the-prefix-common-array-of-two-arrays/", "difficulty": null, "categories": ["Array"], "code": "def findThePrefixCommonArray(arr1: list, arr2: list) -> list:\n  max = len(arr1) if len(arr1) > len(arr2) else len(arr2)\n  seen = set()\n  curCount = 0\n  ret = []\n  for i in range(max):\n    cur1 = arr1[i]\n    cur2 = arr2[i]\n    if cur1 in seen:\n      curCount += 1\n    else:\n      seen.add(cur1)\n    if cur2 in seen:\n      curCount += 1\n    else:\n      seen.add(cur2)\n    ret.append(curCount)\n  return ret\n", "asserts": ["assert findThePrefixCommonArray([1,3,2,4], [3,1,2,4]) == [0,2,3,4]", "assert findThePrefixCommonArray([1], [1]) == [1]", "assert findThePrefixCommonArray([2,3,1], [3,1,2]) == [0,1,3]"]}], "category": "Array", "prompt_tokens": 922, "total_tokens": 1385, "completion_tokens": 463, "completion": "Create a function that merges two sorted arrays into a single sorted array. You may not use any built-in sort functions.\n\n###Code: \n\n```python\ndef merge_sorted_arrays(arr1: list, arr2: list) -> list:\n    merged_array = []\n    i = j = 0\n\n    while i < len(arr1) and j < len(arr2):\n        if arr1[i] <= arr2[j]:\n            merged_array.append(arr1[i])\n            i += 1\n        else:\n            merged_array.append(arr2[j])\n            j += 1\n\n    while i < len(arr1):\n        merged_array.append(arr1[i])\n        i += 1\n\n    while j < len(arr2):\n        merged_array.append(arr2[j])\n        j += 1\n\n    return merged_array\n```\n\n###Testcases: \n\n```python\nassert merge_sorted_arrays([1,3,5], [2,4,6]) == [1,2,3,4,5,6]\nassert merge_sorted_arrays([], [1,2,3]) == [1,2,3]\nassert merge_sorted_arrays([1,2,3], []) == [1,2,3]\nassert merge_sorted_arrays([-2, 3, 5], [-1, 4, 6]) == [-2, -1, 3, 4, 5, 6]\nassert merge_sorted_arrays([7,8,9], [1,5,6]) == [1,5,6,7,8,9]\nassert merge_sorted_arrays([1,2,3], [4,5,6]) == [1,2,3,4,5,6]\nassert merge_sorted_arrays([10,20,30], [15,25]) == [10,15,20,25,30]\nassert merge_sorted_arrays([0.5, 1.5], [0.6, 1.6]) == [0.5, 0.6, 1.5, 1.6]\nassert merge_sorted_arrays(['a', 'c'], ['b', 'd']) == ['a', 'b', 'c', 'd']\n```\n\n[/Example 3]", "temperature": 0.696}, {"few_shots": [{"author": "Calvin", "UUID": "48c6aa37-e00d-4b55-9afc-6b1cf2a1aff2", "question": "There are N Mice and N holes are placed in a straight line. Each hole can accommodate only 1 mouse. A mouse can stay at his position, move one step right from x to x + 1, or move one step left from x to x -1. Any of these moves consumes 1 minute. Assign mice to holes so that the time when the last mouse gets inside a hole is minimized.\nYou are given a list of mice and hole positions as integer scalers.\n", "examples": "Input: Mices = [0, 10, 2, 3], Holes = [3, 2, 23, 0]\nOutput: 13", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def assignHole(mices: list, holes: list) -> int:\n    for i,j in zip(mices,holes):\n        if i<0 or j<0:\n            return -1\n    if (len(mices) != len(holes)):\n        return -1\n    mices.sort()\n    holes.sort()\n    Max = 0\n     \n    for i in range(len(holes)):\n        if (Max < abs(mices[i] - holes[i])):\n            Max = abs(mices[i] - holes[i])\n     \n    return Max\n", "asserts": ["assert assignHole([1, 2, 3, 4], [4, 3, 2, 1]) == 0", "assert assignHole([10, 20, 30, 40], [15, 25, 35, 45]) == 5", "assert assignHole([1, 4, 9, 15], [10, 13, 7, 20]) == 6", "assert assignHole([0], [0]) == 0", "assert assignHole([1, 2], [3]) == -1  # Edge case with non-equal amount of mice and holes", "assert assignHole([5, 5, 5], [5, 5, 5]) == 0  # Edge case with all mice and holes at the same position", "assert assignHole([10, 10, 10, 10], [10, 9, 8, 7]) == 3  # Edge case with multiple mice starting at the same position", "assert assignHole([1,1 ,1, 1, 1, 1, 1, 1, 1, 1], [2,2,2,2,2,2 ,2, 2, 2, 2]) == 1 # Edge case with multiple mice and holes at the same positions", "assert assignHole([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == 1 # Edge case with incremental positions"]}, {"author": "Calvin", "UUID": "fb94082f-4627-4f5a-b280-08d869823d70", "question": "You are given an array of people, people, which are the attributes of some people in a queue (not necessarily in order). Each people[i] = [hi, ki] represents the ith person of height hi with exactly ki other people in front who have a height greater than or equal to hi.\n\nReconstruct and return the queue that is represented by the input array people. The returned queue should be formatted as an array queue, where queue[j] = [hj, kj] is the attributes of the jth person in the queue (queue[0] is the person at the front of the queue).\n", "examples": "Input:  [[7, 0], [4, 4], [7, 1], [5, 0], [6, 1], [5, 2]]\nOutput: [[5, 0], [4, 1], [7, 0], [5, 2], [6, 1], [7, 1]]\n\nInput:  [[6, 0], [5, 0], [4, 0], [3, 2], [2, 2], [1, 4]]\nOutput: [[4, 0], [5, 0], [2, 2], [3, 2], [1, 4], [6, 0]]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "\ndef reconstructQueue(people: list) -> list:\n    output=[] \n    people.sort(key=lambda x: (-x[0], x[1]))                \n    for a in people:\n        output.insert(a[1], a)\n    \n    return output\n", "asserts": ["assert reconstructQueue([[8,1],[5,0],[6,1],[5,2],[4,4],[7,1]]) == [[5, 0], [8, 1], [5, 2], [6, 1], [4, 4], [7, 1]]", "assert reconstructQueue([[12,0], [6,3], [4,4], [9,2], [7,1]]) == [[12, 0], [7, 1], [9, 2], [6, 3], [4, 4]]", "assert reconstructQueue([[2,0], [1,1]]) == [[2, 0], [1, 1]]", "assert reconstructQueue([[3,0], [3,2], [3,1]]) == [[3, 0], [3, 1], [3, 2]]"]}], "category": "Array", "prompt_tokens": 1164, "total_tokens": 1469, "completion_tokens": 305, "completion": "Given an array of integers and an integer k, you need to find the total number of continuous subarrays whose sum equals to k.\n\n###Code:\n\n```python\ndef subarraySum(nums: list, k: int) -> int:\n    count = 0\n    for start in range(len(nums)):\n        sum = 0\n        for end in range(start, len(nums)):\n            sum += nums[end]\n            if sum == k:\n                count += 1\n    return count\n```\n\n###Testcases:\n\n```python\nassert subarraySum([1,1,1], 2) == 2\nassert subarraySum([1,2,3], 3) == 2\nassert subarraySum([1,2,1,2,1], 3) == 4\nassert subarraySum([10,2,-2,-20,10], -10) == 3\nassert subarraySum([-1,-1,1], 0) == 1\nassert subarraySum([1], 0) == 0  # Edge case with single element not equal to k\nassert subarraySum([1,-1,0], 0) == 3  # Edge case with zero sum subarrays\nassert subarraySum([0,0,0,0,0,0,0,0,0,0], 0) == 55  # Edge case with all zeros\n```\n\n[/Example 3]", "temperature": 0.659}, {"few_shots": [{"author": "Calvin", "UUID": "9e45b73f-583d-40ab-b387-e0d1624af07b", "question": "Given two arrays return an array with the set intersection of their common elements", "examples": "Input: arr1 = [1, 2, 3, 4], arr2 = [2, 3]\nOutput: [2, 3]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def array_intersection(arr1: list, arr2: list) -> set:\n  set1 = set(arr1)\n  ret = set([x for x in arr2 if x in set1])\n  return list(ret)\n", "asserts": ["assert set(array_intersection([1,0,2,0,2,0,2,1,1,1], [2,1,0,2,0,2,2,2,1,0])) == {0,1,2}", "assert set(array_intersection([5, 6, 7, 8], [8, 9, 10, 11])) == {8}", "assert set(array_intersection([10, 20, 30], [40, 50, 60])) == set()", "assert set(array_intersection([], [1, 2, 3])) == set()", "assert set(array_intersection([-1, -2, -3], [-3, -4, -5, -6])) == {-3}", "assert set(array_intersection([9, 8, 7], [7, 8, 9, 10, 11, 12])) == {7, 8, 9}", "assert set(array_intersection(['a', 'b', 'c'], ['a', 'd', 'e', 'c'])) == {'a', 'c'}", "assert set(array_intersection(['apple', 'banana'], ['banana', 'cherry'])) == {'banana'}", "assert set(array_intersection([1.1, 2.2, 3.3], [2.2, 4.4])) == {2.2}", "assert set(array_intersection([False, True, False], [True, False, True])) == {True, False}", "assert set(array_intersection([(1, 2), (3, 4)], [(3, 4), (5, 6)])) == {(3, 4)}"]}, {"author": "Calvin", "UUID": "fb94082f-4627-4f5a-b280-08d869823d70", "question": "You are given an array of people, people, which are the attributes of some people in a queue (not necessarily in order). Each people[i] = [hi, ki] represents the ith person of height hi with exactly ki other people in front who have a height greater than or equal to hi.\n\nReconstruct and return the queue that is represented by the input array people. The returned queue should be formatted as an array queue, where queue[j] = [hj, kj] is the attributes of the jth person in the queue (queue[0] is the person at the front of the queue).\n", "examples": "Input:  [[7, 0], [4, 4], [7, 1], [5, 0], [6, 1], [5, 2]]\nOutput: [[5, 0], [4, 1], [7, 0], [5, 2], [6, 1], [7, 1]]\n\nInput:  [[6, 0], [5, 0], [4, 0], [3, 2], [2, 2], [1, 4]]\nOutput: [[4, 0], [5, 0], [2, 2], [3, 2], [1, 4], [6, 0]]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "\ndef reconstructQueue(people: list) -> list:\n    output=[] \n    people.sort(key=lambda x: (-x[0], x[1]))                \n    for a in people:\n        output.insert(a[1], a)\n    \n    return output\n", "asserts": ["assert reconstructQueue([[8,1],[5,0],[6,1],[5,2],[4,4],[7,1]]) == [[5, 0], [8, 1], [5, 2], [6, 1], [4, 4], [7, 1]]", "assert reconstructQueue([[12,0], [6,3], [4,4], [9,2], [7,1]]) == [[12, 0], [7, 1], [9, 2], [6, 3], [4, 4]]", "assert reconstructQueue([[2,0], [1,1]]) == [[2, 0], [1, 1]]", "assert reconstructQueue([[3,0], [3,2], [3,1]]) == [[3, 0], [3, 1], [3, 2]]"]}], "category": "Array", "prompt_tokens": 983, "total_tokens": 1415, "completion_tokens": 432, "completion": "Write a function that takes an array of integers and returns an array where each element at index `i` of the output array is equal to the product of all the numbers in the original array except the one at index `i`.\n\n###Code: \n\ndef product_except_self(nums: list) -> list:\n    length = len(nums)\n    answer = [0]*length\n    \n    # answer[i] contains the product of all the elements to the left\n    # Note: for the element at index '0', there are no elements to the left,\n    # so the answer[0] would be 1\n    answer[0] = 1\n    for i in range(1, length):\n        answer[i] = nums[i - 1] * answer[i - 1]\n    \n    # R contains the product of all the elements to the right\n    # Note: for the element at index 'length - 1', there are no elements to the right,\n    # so the R would be 1\n    R = 1\n    for i in reversed(range(length)):\n        # For the index 'i', R would contain the \n        # product of all elements to the right. We update R accordingly\n        answer[i] = answer[i] * R\n        R *= nums[i]\n    \n    return answer\n\n###Testcases: \n\nassert product_except_self([1,2,3,4]) == [24,12,8,6]\nassert product_except_self([0,0]) == [0,0]\nassert product_except_self([1,0]) == [0,1]\nassert product_except_self([-1,1,0,-3,3]) == [0,0,9,0,0]\nassert product_except_self([5,2,3]) == [6,15,10]\nassert product_except_self([2,5,8,10]) == [400,160,100,80]\nassert product_except_self([1,1,1,1,1]) == [1,1,1,1,1]\n\n[/Example 3]", "temperature": 0.675}, {"few_shots": [{"author": "Calvin", "UUID": "9e45b73f-583d-40ab-b387-e0d1624af07b", "question": "Given two arrays return an array with the set intersection of their common elements", "examples": "Input: arr1 = [1, 2, 3, 4], arr2 = [2, 3]\nOutput: [2, 3]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def array_intersection(arr1: list, arr2: list) -> set:\n  set1 = set(arr1)\n  ret = set([x for x in arr2 if x in set1])\n  return list(ret)\n", "asserts": ["assert set(array_intersection([1,0,2,0,2,0,2,1,1,1], [2,1,0,2,0,2,2,2,1,0])) == {0,1,2}", "assert set(array_intersection([5, 6, 7, 8], [8, 9, 10, 11])) == {8}", "assert set(array_intersection([10, 20, 30], [40, 50, 60])) == set()", "assert set(array_intersection([], [1, 2, 3])) == set()", "assert set(array_intersection([-1, -2, -3], [-3, -4, -5, -6])) == {-3}", "assert set(array_intersection([9, 8, 7], [7, 8, 9, 10, 11, 12])) == {7, 8, 9}", "assert set(array_intersection(['a', 'b', 'c'], ['a', 'd', 'e', 'c'])) == {'a', 'c'}", "assert set(array_intersection(['apple', 'banana'], ['banana', 'cherry'])) == {'banana'}", "assert set(array_intersection([1.1, 2.2, 3.3], [2.2, 4.4])) == {2.2}", "assert set(array_intersection([False, True, False], [True, False, True])) == {True, False}", "assert set(array_intersection([(1, 2), (3, 4)], [(3, 4), (5, 6)])) == {(3, 4)}"]}, {"author": "Calvin", "UUID": "48c6aa37-e00d-4b55-9afc-6b1cf2a1aff2", "question": "There are N Mice and N holes are placed in a straight line. Each hole can accommodate only 1 mouse. A mouse can stay at his position, move one step right from x to x + 1, or move one step left from x to x -1. Any of these moves consumes 1 minute. Assign mice to holes so that the time when the last mouse gets inside a hole is minimized.\nYou are given a list of mice and hole positions as integer scalers.\n", "examples": "Input: Mices = [0, 10, 2, 3], Holes = [3, 2, 23, 0]\nOutput: 13", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def assignHole(mices: list, holes: list) -> int:\n    for i,j in zip(mices,holes):\n        if i<0 or j<0:\n            return -1\n    if (len(mices) != len(holes)):\n        return -1\n    mices.sort()\n    holes.sort()\n    Max = 0\n     \n    for i in range(len(holes)):\n        if (Max < abs(mices[i] - holes[i])):\n            Max = abs(mices[i] - holes[i])\n     \n    return Max\n", "asserts": ["assert assignHole([1, 2, 3, 4], [4, 3, 2, 1]) == 0", "assert assignHole([10, 20, 30, 40], [15, 25, 35, 45]) == 5", "assert assignHole([1, 4, 9, 15], [10, 13, 7, 20]) == 6", "assert assignHole([0], [0]) == 0", "assert assignHole([1, 2], [3]) == -1  # Edge case with non-equal amount of mice and holes", "assert assignHole([5, 5, 5], [5, 5, 5]) == 0  # Edge case with all mice and holes at the same position", "assert assignHole([10, 10, 10, 10], [10, 9, 8, 7]) == 3  # Edge case with multiple mice starting at the same position", "assert assignHole([1,1 ,1, 1, 1, 1, 1, 1, 1, 1], [2,2,2,2,2,2 ,2, 2, 2, 2]) == 1 # Edge case with multiple mice and holes at the same positions", "assert assignHole([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == 1 # Edge case with incremental positions"]}], "category": "Array", "prompt_tokens": 1208, "total_tokens": 1776, "completion_tokens": 568, "completion": "Given an array of integers, return the length of the longest subsequence where the difference between consecutive elements is exactly one.\n\n###Code:\n\ndef longest_subsequence_with_diff_one(arr: list) -> int:\n    if not arr:\n        return 0\n    # Create a dictionary to store the length of the longest subsequence ending with arr[i]\n    dp = {num: 1 for num in arr}\n    max_length = 1\n    for num in arr:\n        # Check if there's a number before num whose difference is 1\n        if num - 1 in dp:\n            dp[num] = dp[num - 1] + 1\n            max_length = max(max_length, dp[num])\n        # Check if there's a number after num whose difference is 1\n        if num + 1 in dp:\n            dp[num + 1] = max(dp[num + 1], dp[num] + 1)\n            max_length = max(max_length, dp[num + 1])\n    return max_length\n\n###Testcases:\n\nassert longest_subsequence_with_diff_one([1, 2, 3, 4, 5, 3, 2]) == 5\nassert longest_subsequence_with_diff_one([10, 9, 4, 5, 4, 8, 6]) == 3\nassert longest_subsequence_with_diff_one([1]) == 1\nassert longest_subsequence_with_diff_one([]) == 0  # Edge case with empty array\nassert longest_subsequence_with_diff_one([3, 3, 3, 3, 3]) == 1  # Edge case with all elements the same\nassert longest_subsequence_with_diff_one([-1, -2, -3, -4, -5]) == 5  # Edge case with negative numbers\nassert longest_subsequence_with_diff_one([1, 3, 5, 7, 9, 11]) == 2  # Edge case with increasing odd numbers\nassert longest_subsequence_with_diff_one([10, 12, 11, 14, 13, 16, 15, 18, 17]) == 9  # Edge case with increasing even and odd numbers\nassert longest_subsequence_with_diff_one([5, 1, 2, 3, 4, 10, 11, 12, 13]) == 5 # Edge case with the longest subsequence at the start\nassert longest_subsequence_with_diff_one([100, 101, 102, 103, 99, 98, 97, 96]) == 4 # Edge case with a mix of increasing and decreasing values\n\n[/Example 3]", "temperature": 0.678}, {"few_shots": [{"author": "Calvin", "UUID": "1aeb3246-4c22-4d34-a48c-db7be8ba1b94", "question": "You are given n activities with their start and finish times. Select the maximum number of activities that can be performed by a single person and return their indexes. Assume that a person can only work on a single activity at a time. \n", "examples": "Input: start  =  {10, 12, 20}, finish =  {20, 25, 30}\nOutput: [0, 2]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "import numpy as np\ndef MaxActivities(s: list, f: list) -> list:\n    indices = np.argsort(f)\n    [s[i] for i in indices]\n    [f[i] for i in indices]\n    result = []\n    n = len(f)\n    i = 0\n    result.append(i)\n    for j in range(1, n):\n        if s[j] >= f[i]:\n            result.append(j)\n            i = j\n    return result\n", "asserts": ["assert MaxActivities([2, 4, 5, 6, 7, 8], [3, 5, 6, 7, 9, 10]) == [0, 1, 2, 3, 4]", "assert MaxActivities([1, 3, 0, 5, 8, 5], [2, 4, 6, 7, 9, 9]) == [0, 1, 3, 4]", "assert MaxActivities([1], [2]) == [0]"]}, {"author": "Calvin", "UUID": "f795bda7-9822-4bc5-9c7e-b9c0f2752085", "question": "You are given two 0-indexed integer permutations A and B of length n.\n\nA prefix common array of A and B is an array C such that C[i] is equal to the count of numbers that are present at or before the index i in both A and B.\n\nReturn the prefix common array of A and B.\n\nA sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once.", "examples": "Input: A = [1,3,2,4], B = [3,1,2,4]\nOutput: [0,2,3,4]", "link": "https://leetcode.com/problems/find-the-prefix-common-array-of-two-arrays/", "difficulty": null, "categories": ["Array"], "code": "def findThePrefixCommonArray(arr1: list, arr2: list) -> list:\n  max = len(arr1) if len(arr1) > len(arr2) else len(arr2)\n  seen = set()\n  curCount = 0\n  ret = []\n  for i in range(max):\n    cur1 = arr1[i]\n    cur2 = arr2[i]\n    if cur1 in seen:\n      curCount += 1\n    else:\n      seen.add(cur1)\n    if cur2 in seen:\n      curCount += 1\n    else:\n      seen.add(cur2)\n    ret.append(curCount)\n  return ret\n", "asserts": ["assert findThePrefixCommonArray([1,3,2,4], [3,1,2,4]) == [0,2,3,4]", "assert findThePrefixCommonArray([1], [1]) == [1]", "assert findThePrefixCommonArray([2,3,1], [3,1,2]) == [0,1,3]"]}], "category": "Array", "prompt_tokens": 782, "total_tokens": 919, "completion_tokens": 137, "completion": "Given an array of integers, return the minimum number of moves required to make all array elements equal, where a move is incrementing any element except one.\n\n###Code: \n\ndef minMoves(nums: list) -> int:\n    min_num = min(nums)\n    moves = 0\n    for num in nums:\n        moves += num - min_num\n    return moves\n\n###Testcases: \n\nassert minMoves([1, 2, 3]) == 3\nassert minMoves([1, 1, 1]) == 0\nassert minMoves([1, 10, 2, 9]) == 25\n\n[/Example 3]", "temperature": 0.948}, {"few_shots": [{"author": "Calvin", "UUID": "48c6aa37-e00d-4b55-9afc-6b1cf2a1aff2", "question": "There are N Mice and N holes are placed in a straight line. Each hole can accommodate only 1 mouse. A mouse can stay at his position, move one step right from x to x + 1, or move one step left from x to x -1. Any of these moves consumes 1 minute. Assign mice to holes so that the time when the last mouse gets inside a hole is minimized.\nYou are given a list of mice and hole positions as integer scalers.\n", "examples": "Input: Mices = [0, 10, 2, 3], Holes = [3, 2, 23, 0]\nOutput: 13", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def assignHole(mices: list, holes: list) -> int:\n    for i,j in zip(mices,holes):\n        if i<0 or j<0:\n            return -1\n    if (len(mices) != len(holes)):\n        return -1\n    mices.sort()\n    holes.sort()\n    Max = 0\n     \n    for i in range(len(holes)):\n        if (Max < abs(mices[i] - holes[i])):\n            Max = abs(mices[i] - holes[i])\n     \n    return Max\n", "asserts": ["assert assignHole([1, 2, 3, 4], [4, 3, 2, 1]) == 0", "assert assignHole([10, 20, 30, 40], [15, 25, 35, 45]) == 5", "assert assignHole([1, 4, 9, 15], [10, 13, 7, 20]) == 6", "assert assignHole([0], [0]) == 0", "assert assignHole([1, 2], [3]) == -1  # Edge case with non-equal amount of mice and holes", "assert assignHole([5, 5, 5], [5, 5, 5]) == 0  # Edge case with all mice and holes at the same position", "assert assignHole([10, 10, 10, 10], [10, 9, 8, 7]) == 3  # Edge case with multiple mice starting at the same position", "assert assignHole([1,1 ,1, 1, 1, 1, 1, 1, 1, 1], [2,2,2,2,2,2 ,2, 2, 2, 2]) == 1 # Edge case with multiple mice and holes at the same positions", "assert assignHole([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == 1 # Edge case with incremental positions"]}, {"author": "Calvin", "UUID": "f795bda7-9822-4bc5-9c7e-b9c0f2752085", "question": "You are given two 0-indexed integer permutations A and B of length n.\n\nA prefix common array of A and B is an array C such that C[i] is equal to the count of numbers that are present at or before the index i in both A and B.\n\nReturn the prefix common array of A and B.\n\nA sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once.", "examples": "Input: A = [1,3,2,4], B = [3,1,2,4]\nOutput: [0,2,3,4]", "link": "https://leetcode.com/problems/find-the-prefix-common-array-of-two-arrays/", "difficulty": null, "categories": ["Array"], "code": "def findThePrefixCommonArray(arr1: list, arr2: list) -> list:\n  max = len(arr1) if len(arr1) > len(arr2) else len(arr2)\n  seen = set()\n  curCount = 0\n  ret = []\n  for i in range(max):\n    cur1 = arr1[i]\n    cur2 = arr2[i]\n    if cur1 in seen:\n      curCount += 1\n    else:\n      seen.add(cur1)\n    if cur2 in seen:\n      curCount += 1\n    else:\n      seen.add(cur2)\n    ret.append(curCount)\n  return ret\n", "asserts": ["assert findThePrefixCommonArray([1,3,2,4], [3,1,2,4]) == [0,2,3,4]", "assert findThePrefixCommonArray([1], [1]) == [1]", "assert findThePrefixCommonArray([2,3,1], [3,1,2]) == [0,1,3]"]}], "category": "Array", "prompt_tokens": 1103, "total_tokens": 1453, "completion_tokens": 350, "completion": "Given an array of integers, write a function that will return the smallest non-negative integer that is not present in the array. This number should be the minimum number that you could add to the array such that when re-arranged, it forms a sequence of consecutive numbers.\n\n###Code: \n\ndef findSmallestMissing(arr: list) -> int:\n    arr.sort()\n    smallest_missing = 0\n    for num in arr:\n        if num == smallest_missing:\n            smallest_missing += 1\n    return smallest_missing\n\n###Testcases: \n\nassert findSmallestMissing([0, 1, 2, 6, 9, 11, 15]) == 3\nassert findSmallestMissing([1, 2, 3, 4, 6, 9, 11, 15]) == 0\nassert findSmallestMissing([0, 1, 2, 3, 4, 5, 6]) == 7\nassert findSmallestMissing([-2, -1, 0, 1, 3, 4]) == 2\nassert findSmallestMissing([2, 3, 7, 6, 8, -1, -10, 15]) == 0\nassert findSmallestMissing([4, 5, 10, 11]) == 0\nassert findSmallestMissing([]) == 0\nassert findSmallestMissing([0, 0, 1, 1, 2, 2]) == 3\nassert findSmallestMissing([-1, -3, -6, -8]) == 0\n\n[/Example 3]", "temperature": 0.667}, {"few_shots": [{"author": "Calvin", "UUID": "1aeb3246-4c22-4d34-a48c-db7be8ba1b94", "question": "You are given n activities with their start and finish times. Select the maximum number of activities that can be performed by a single person and return their indexes. Assume that a person can only work on a single activity at a time. \n", "examples": "Input: start  =  {10, 12, 20}, finish =  {20, 25, 30}\nOutput: [0, 2]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "import numpy as np\ndef MaxActivities(s: list, f: list) -> list:\n    indices = np.argsort(f)\n    [s[i] for i in indices]\n    [f[i] for i in indices]\n    result = []\n    n = len(f)\n    i = 0\n    result.append(i)\n    for j in range(1, n):\n        if s[j] >= f[i]:\n            result.append(j)\n            i = j\n    return result\n", "asserts": ["assert MaxActivities([2, 4, 5, 6, 7, 8], [3, 5, 6, 7, 9, 10]) == [0, 1, 2, 3, 4]", "assert MaxActivities([1, 3, 0, 5, 8, 5], [2, 4, 6, 7, 9, 9]) == [0, 1, 3, 4]", "assert MaxActivities([1], [2]) == [0]"]}, {"author": "Calvin", "UUID": "9e45b73f-583d-40ab-b387-e0d1624af07b", "question": "Given two arrays return an array with the set intersection of their common elements", "examples": "Input: arr1 = [1, 2, 3, 4], arr2 = [2, 3]\nOutput: [2, 3]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def array_intersection(arr1: list, arr2: list) -> set:\n  set1 = set(arr1)\n  ret = set([x for x in arr2 if x in set1])\n  return list(ret)\n", "asserts": ["assert set(array_intersection([1,0,2,0,2,0,2,1,1,1], [2,1,0,2,0,2,2,2,1,0])) == {0,1,2}", "assert set(array_intersection([5, 6, 7, 8], [8, 9, 10, 11])) == {8}", "assert set(array_intersection([10, 20, 30], [40, 50, 60])) == set()", "assert set(array_intersection([], [1, 2, 3])) == set()", "assert set(array_intersection([-1, -2, -3], [-3, -4, -5, -6])) == {-3}", "assert set(array_intersection([9, 8, 7], [7, 8, 9, 10, 11, 12])) == {7, 8, 9}", "assert set(array_intersection(['a', 'b', 'c'], ['a', 'd', 'e', 'c'])) == {'a', 'c'}", "assert set(array_intersection(['apple', 'banana'], ['banana', 'cherry'])) == {'banana'}", "assert set(array_intersection([1.1, 2.2, 3.3], [2.2, 4.4])) == {2.2}", "assert set(array_intersection([False, True, False], [True, False, True])) == {True, False}", "assert set(array_intersection([(1, 2), (3, 4)], [(3, 4), (5, 6)])) == {(3, 4)}"]}], "category": "Array", "prompt_tokens": 887, "total_tokens": 1390, "completion_tokens": 503, "completion": "Write a function that takes an array of integers and an integer value n. The function should move all instances of n to the end of the array. The order of the other elements should not be changed. Return the modified array.\n\n###Code:\n\ndef move_element_to_end(arr: list, n: int) -> list:\n    result = [x for x in arr if x != n]\n    result.extend([n] * arr.count(n))\n    return result\n\n###Testcases:\n\nassert move_element_to_end([2, 1, 2, 4, 2, 5], 2) == [1, 4, 5, 2, 2, 2]\nassert move_element_to_end([0, 1, 0, 3, 12], 0) == [1, 3, 12, 0, 0]\nassert move_element_to_end([0, 1, 0, 3, 0], 1) == [0, 0, 3, 0, 1]\nassert move_element_to_end([7, 8, 9, 1, 2, 3, 7], 7) == [8, 9, 1, 2, 3, 7, 7]\nassert move_element_to_end([4, 5, 6, 7, 4, 4], 4) == [5, 6, 7, 4, 4, 4]\nassert move_element_to_end([1, 2, 3, 3, 2, 1], 4) == [1, 2, 3, 3, 2, 1]\nassert move_element_to_end([1], 1) == [1]\nassert move_element_to_end([], 10) == []\nassert move_element_to_end([1,2,3,4,5,6,7,8,9,1,1,1], 1) == [2,3,4,5,6,7,8,9,1,1,1,1]\nassert move_element_to_end([0,0,0,1,1,1,0,0,1,1], 0) == [1,1,1,1,1,0,0,0,0,0]\n\n[/Example 3]", "temperature": 0.929}, {"few_shots": [{"author": "Calvin", "UUID": "a9c5e697-af5d-432b-8447-5675d739c728", "question": "Given an array reorder it so that even numbers appear first", "examples": "Input: [1,2,3,4,5,6,7,8,9]\r\nOutput: [8,2,6,4,5,7,3,9,1]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def even_odd_reorder(arr: list) -> list:\n  nextEven = 0\n  nextOdd = len(arr) - 1\n  while nextEven < nextOdd:\n    if arr[nextEven] % 2 == 0:\n      nextEven += 1\n    else:\n      temp = arr[nextEven]\n      arr[nextEven] = arr[nextOdd]\n      arr[nextOdd] = temp\n      nextOdd -= 1\n  return arr\n", "asserts": ["assert even_odd_reorder([1,2,3,4,5,6,7,8,9]) == [8, 2, 6, 4, 5, 7, 3, 9, 1]", "assert even_odd_reorder([]) == []", "assert even_odd_reorder([2, 4, 6, 8]) == [2, 4, 6, 8]", "assert even_odd_reorder([7, 9, 2]) == [2, 9, 7]", "assert even_odd_reorder([10, 13, 17, 16, 15, 12]) == [10, 12, 16, 15, 17, 13]"]}, {"author": "Calvin", "UUID": "9e45b73f-583d-40ab-b387-e0d1624af07b", "question": "Given two arrays return an array with the set intersection of their common elements", "examples": "Input: arr1 = [1, 2, 3, 4], arr2 = [2, 3]\nOutput: [2, 3]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def array_intersection(arr1: list, arr2: list) -> set:\n  set1 = set(arr1)\n  ret = set([x for x in arr2 if x in set1])\n  return list(ret)\n", "asserts": ["assert set(array_intersection([1,0,2,0,2,0,2,1,1,1], [2,1,0,2,0,2,2,2,1,0])) == {0,1,2}", "assert set(array_intersection([5, 6, 7, 8], [8, 9, 10, 11])) == {8}", "assert set(array_intersection([10, 20, 30], [40, 50, 60])) == set()", "assert set(array_intersection([], [1, 2, 3])) == set()", "assert set(array_intersection([-1, -2, -3], [-3, -4, -5, -6])) == {-3}", "assert set(array_intersection([9, 8, 7], [7, 8, 9, 10, 11, 12])) == {7, 8, 9}", "assert set(array_intersection(['a', 'b', 'c'], ['a', 'd', 'e', 'c'])) == {'a', 'c'}", "assert set(array_intersection(['apple', 'banana'], ['banana', 'cherry'])) == {'banana'}", "assert set(array_intersection([1.1, 2.2, 3.3], [2.2, 4.4])) == {2.2}", "assert set(array_intersection([False, True, False], [True, False, True])) == {True, False}", "assert set(array_intersection([(1, 2), (3, 4)], [(3, 4), (5, 6)])) == {(3, 4)}"]}], "category": "Array", "prompt_tokens": 886, "total_tokens": 1201, "completion_tokens": 315, "completion": "Given an array of integers, return the maximum sum of a subarray.\n\n###Code:\n\n```python\ndef max_subarray_sum(arr: list) -> int:\n    if not arr:\n        return 0\n  \n    max_sum = current_sum = arr[0]\n    for num in arr[1:]:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    return max_sum\n```\n\n###Testcases:\n\n```python\nassert max_subarray_sum([-2,1,-3,4,-1,2,1,-5,4]) == 6  # [4,-1,2,1] has the maximum sum of 6\nassert max_subarray_sum([-1,-2,-3,-4]) == -1  # [-1] has the maximum sum of -1\nassert max_subarray_sum([1,2,3,4,5]) == 15  # [1,2,3,4,5] has the maximum sum of 15\nassert max_subarray_sum([]) == 0  # [] has the maximum sum of 0\nassert max_subarray_sum([5,-1,5]) == 9  # [5,-1,5] has the maximum sum of 9\nassert max_subarray_sum([5,4,-1,7,8]) == 23  # [5,4,-1,7,8] has the maximum sum of 23\n```\n\n[/Example 3]", "temperature": 0.804}, {"few_shots": [{"author": "Calvin", "UUID": "9e45b73f-583d-40ab-b387-e0d1624af07b", "question": "Given two arrays return an array with the set intersection of their common elements", "examples": "Input: arr1 = [1, 2, 3, 4], arr2 = [2, 3]\nOutput: [2, 3]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def array_intersection(arr1: list, arr2: list) -> set:\n  set1 = set(arr1)\n  ret = set([x for x in arr2 if x in set1])\n  return list(ret)\n", "asserts": ["assert set(array_intersection([1,0,2,0,2,0,2,1,1,1], [2,1,0,2,0,2,2,2,1,0])) == {0,1,2}", "assert set(array_intersection([5, 6, 7, 8], [8, 9, 10, 11])) == {8}", "assert set(array_intersection([10, 20, 30], [40, 50, 60])) == set()", "assert set(array_intersection([], [1, 2, 3])) == set()", "assert set(array_intersection([-1, -2, -3], [-3, -4, -5, -6])) == {-3}", "assert set(array_intersection([9, 8, 7], [7, 8, 9, 10, 11, 12])) == {7, 8, 9}", "assert set(array_intersection(['a', 'b', 'c'], ['a', 'd', 'e', 'c'])) == {'a', 'c'}", "assert set(array_intersection(['apple', 'banana'], ['banana', 'cherry'])) == {'banana'}", "assert set(array_intersection([1.1, 2.2, 3.3], [2.2, 4.4])) == {2.2}", "assert set(array_intersection([False, True, False], [True, False, True])) == {True, False}", "assert set(array_intersection([(1, 2), (3, 4)], [(3, 4), (5, 6)])) == {(3, 4)}"]}, {"author": "Calvin", "UUID": "48c6aa37-e00d-4b55-9afc-6b1cf2a1aff2", "question": "There are N Mice and N holes are placed in a straight line. Each hole can accommodate only 1 mouse. A mouse can stay at his position, move one step right from x to x + 1, or move one step left from x to x -1. Any of these moves consumes 1 minute. Assign mice to holes so that the time when the last mouse gets inside a hole is minimized.\nYou are given a list of mice and hole positions as integer scalers.\n", "examples": "Input: Mices = [0, 10, 2, 3], Holes = [3, 2, 23, 0]\nOutput: 13", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def assignHole(mices: list, holes: list) -> int:\n    for i,j in zip(mices,holes):\n        if i<0 or j<0:\n            return -1\n    if (len(mices) != len(holes)):\n        return -1\n    mices.sort()\n    holes.sort()\n    Max = 0\n     \n    for i in range(len(holes)):\n        if (Max < abs(mices[i] - holes[i])):\n            Max = abs(mices[i] - holes[i])\n     \n    return Max\n", "asserts": ["assert assignHole([1, 2, 3, 4], [4, 3, 2, 1]) == 0", "assert assignHole([10, 20, 30, 40], [15, 25, 35, 45]) == 5", "assert assignHole([1, 4, 9, 15], [10, 13, 7, 20]) == 6", "assert assignHole([0], [0]) == 0", "assert assignHole([1, 2], [3]) == -1  # Edge case with non-equal amount of mice and holes", "assert assignHole([5, 5, 5], [5, 5, 5]) == 0  # Edge case with all mice and holes at the same position", "assert assignHole([10, 10, 10, 10], [10, 9, 8, 7]) == 3  # Edge case with multiple mice starting at the same position", "assert assignHole([1,1 ,1, 1, 1, 1, 1, 1, 1, 1], [2,2,2,2,2,2 ,2, 2, 2, 2]) == 1 # Edge case with multiple mice and holes at the same positions", "assert assignHole([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == 1 # Edge case with incremental positions"]}], "category": "Array", "prompt_tokens": 1208, "total_tokens": 1639, "completion_tokens": 431, "completion": "Write a function that takes an array of positive integers and returns the length of the longest strictly increasing subsequence. A subsequence is a sequence that can be derived from an array by deleting some or no elements without changing the order of the remaining elements.\n\n###Code: \n\ndef length_of_LIS(nums: list) -> int:\n    if not nums:\n        return 0\n    \n    dp = [1] * len(nums)\n    \n    for i in range(len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n                \n    return max(dp)\n\n###Testcases: \n\nassert length_of_LIS([10, 9, 2, 5, 3, 7, 101, 18]) == 4\nassert length_of_LIS([0, 1, 0, 3, 2, 3]) == 4\nassert length_of_LIS([7, 7, 7, 7, 7, 7, 7]) == 1\nassert length_of_LIS([1, 3, 6, 7, 9, 4, 10, 5, 6]) == 6\nassert length_of_LIS([3]) == 1\nassert length_of_LIS([1, 2, 3, 4, 5, 6, 7, 8, 9]) == 9\nassert length_of_LIS([9, 8, 7, 6, 5, 4, 3, 2, 1]) == 1\nassert length_of_LIS([1, 3, 2]) == 2\nassert length_of_LIS([10, 22, 9, 33, 21, 50, 41, 60, 80]) == 6\nassert length_of_LIS([3, 10, 2, 1, 20]) == 3\n\n[/Example 3]", "temperature": 0.912}, {"few_shots": [{"author": "Calvin", "UUID": "9e45b73f-583d-40ab-b387-e0d1624af07b", "question": "Given two arrays return an array with the set intersection of their common elements", "examples": "Input: arr1 = [1, 2, 3, 4], arr2 = [2, 3]\nOutput: [2, 3]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def array_intersection(arr1: list, arr2: list) -> set:\n  set1 = set(arr1)\n  ret = set([x for x in arr2 if x in set1])\n  return list(ret)\n", "asserts": ["assert set(array_intersection([1,0,2,0,2,0,2,1,1,1], [2,1,0,2,0,2,2,2,1,0])) == {0,1,2}", "assert set(array_intersection([5, 6, 7, 8], [8, 9, 10, 11])) == {8}", "assert set(array_intersection([10, 20, 30], [40, 50, 60])) == set()", "assert set(array_intersection([], [1, 2, 3])) == set()", "assert set(array_intersection([-1, -2, -3], [-3, -4, -5, -6])) == {-3}", "assert set(array_intersection([9, 8, 7], [7, 8, 9, 10, 11, 12])) == {7, 8, 9}", "assert set(array_intersection(['a', 'b', 'c'], ['a', 'd', 'e', 'c'])) == {'a', 'c'}", "assert set(array_intersection(['apple', 'banana'], ['banana', 'cherry'])) == {'banana'}", "assert set(array_intersection([1.1, 2.2, 3.3], [2.2, 4.4])) == {2.2}", "assert set(array_intersection([False, True, False], [True, False, True])) == {True, False}", "assert set(array_intersection([(1, 2), (3, 4)], [(3, 4), (5, 6)])) == {(3, 4)}"]}, {"author": "Calvin", "UUID": "fb94082f-4627-4f5a-b280-08d869823d70", "question": "You are given an array of people, people, which are the attributes of some people in a queue (not necessarily in order). Each people[i] = [hi, ki] represents the ith person of height hi with exactly ki other people in front who have a height greater than or equal to hi.\n\nReconstruct and return the queue that is represented by the input array people. The returned queue should be formatted as an array queue, where queue[j] = [hj, kj] is the attributes of the jth person in the queue (queue[0] is the person at the front of the queue).\n", "examples": "Input:  [[7, 0], [4, 4], [7, 1], [5, 0], [6, 1], [5, 2]]\nOutput: [[5, 0], [4, 1], [7, 0], [5, 2], [6, 1], [7, 1]]\n\nInput:  [[6, 0], [5, 0], [4, 0], [3, 2], [2, 2], [1, 4]]\nOutput: [[4, 0], [5, 0], [2, 2], [3, 2], [1, 4], [6, 0]]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "\ndef reconstructQueue(people: list) -> list:\n    output=[] \n    people.sort(key=lambda x: (-x[0], x[1]))                \n    for a in people:\n        output.insert(a[1], a)\n    \n    return output\n", "asserts": ["assert reconstructQueue([[8,1],[5,0],[6,1],[5,2],[4,4],[7,1]]) == [[5, 0], [8, 1], [5, 2], [6, 1], [4, 4], [7, 1]]", "assert reconstructQueue([[12,0], [6,3], [4,4], [9,2], [7,1]]) == [[12, 0], [7, 1], [9, 2], [6, 3], [4, 4]]", "assert reconstructQueue([[2,0], [1,1]]) == [[2, 0], [1, 1]]", "assert reconstructQueue([[3,0], [3,2], [3,1]]) == [[3, 0], [3, 1], [3, 2]]"]}], "category": "Array", "prompt_tokens": 983, "total_tokens": 1311, "completion_tokens": 328, "completion": "Given an array of integers, return a new array such that each element at index i of the new array is the product of all the numbers in the original array except the one at i.\n\n###Code: \n\ndef product_except_self(nums: list) -> list:\n    length = len(nums)\n    answer = [0]*length\n\n    answer[0] = 1\n    for i in range(1, length):\n        answer[i] = nums[i - 1] * answer[i - 1]\n\n    R = 1\n    for i in reversed(range(length)):\n        answer[i] = answer[i] * R\n        R *= nums[i]\n\n    return answer\n\n###Testcases: \n\nassert product_except_self([1, 2, 3, 4]) == [24, 12, 8, 6]\nassert product_except_self([0, 0]) == [0, 0]\nassert product_except_self([1, 0]) == [0, 1]\nassert product_except_self([1, 1, 1, 1]) == [1, 1, 1, 1]\nassert product_except_self([-1, 1, -1, 1, -1]) == [-1, 1, -1, 1, -1]\nassert product_except_self([1, 2, 3, 0]) == [0, 0, 0, 6]\nassert product_except_self([9, 0, -2]) == [0, -18, 0]\n\n\n[/Example 3]", "temperature": 0.861}, {"few_shots": [{"author": "Calvin", "UUID": "f795bda7-9822-4bc5-9c7e-b9c0f2752085", "question": "You are given two 0-indexed integer permutations A and B of length n.\n\nA prefix common array of A and B is an array C such that C[i] is equal to the count of numbers that are present at or before the index i in both A and B.\n\nReturn the prefix common array of A and B.\n\nA sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once.", "examples": "Input: A = [1,3,2,4], B = [3,1,2,4]\nOutput: [0,2,3,4]", "link": "https://leetcode.com/problems/find-the-prefix-common-array-of-two-arrays/", "difficulty": null, "categories": ["Array"], "code": "def findThePrefixCommonArray(arr1: list, arr2: list) -> list:\n  max = len(arr1) if len(arr1) > len(arr2) else len(arr2)\n  seen = set()\n  curCount = 0\n  ret = []\n  for i in range(max):\n    cur1 = arr1[i]\n    cur2 = arr2[i]\n    if cur1 in seen:\n      curCount += 1\n    else:\n      seen.add(cur1)\n    if cur2 in seen:\n      curCount += 1\n    else:\n      seen.add(cur2)\n    ret.append(curCount)\n  return ret\n", "asserts": ["assert findThePrefixCommonArray([1,3,2,4], [3,1,2,4]) == [0,2,3,4]", "assert findThePrefixCommonArray([1], [1]) == [1]", "assert findThePrefixCommonArray([2,3,1], [3,1,2]) == [0,1,3]"]}, {"author": "Calvin", "UUID": "9e45b73f-583d-40ab-b387-e0d1624af07b", "question": "Given two arrays return an array with the set intersection of their common elements", "examples": "Input: arr1 = [1, 2, 3, 4], arr2 = [2, 3]\nOutput: [2, 3]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def array_intersection(arr1: list, arr2: list) -> set:\n  set1 = set(arr1)\n  ret = set([x for x in arr2 if x in set1])\n  return list(ret)\n", "asserts": ["assert set(array_intersection([1,0,2,0,2,0,2,1,1,1], [2,1,0,2,0,2,2,2,1,0])) == {0,1,2}", "assert set(array_intersection([5, 6, 7, 8], [8, 9, 10, 11])) == {8}", "assert set(array_intersection([10, 20, 30], [40, 50, 60])) == set()", "assert set(array_intersection([], [1, 2, 3])) == set()", "assert set(array_intersection([-1, -2, -3], [-3, -4, -5, -6])) == {-3}", "assert set(array_intersection([9, 8, 7], [7, 8, 9, 10, 11, 12])) == {7, 8, 9}", "assert set(array_intersection(['a', 'b', 'c'], ['a', 'd', 'e', 'c'])) == {'a', 'c'}", "assert set(array_intersection(['apple', 'banana'], ['banana', 'cherry'])) == {'banana'}", "assert set(array_intersection([1.1, 2.2, 3.3], [2.2, 4.4])) == {2.2}", "assert set(array_intersection([False, True, False], [True, False, True])) == {True, False}", "assert set(array_intersection([(1, 2), (3, 4)], [(3, 4), (5, 6)])) == {(3, 4)}"]}], "category": "Array", "prompt_tokens": 922, "total_tokens": 1242, "completion_tokens": 320, "completion": "Given an array of integers, return the maximum sum of a subarray with the constraint that no two elements in the subarray are adjacent in the original array.\n\n###Code:\n\n```python\ndef maxNonAdjacentSum(nums: list) -> int:\n    incl = 0\n    excl = 0\n    \n    for num in nums:\n        new_excl = excl if excl > incl else incl\n        incl = excl + num\n        excl = new_excl\n  \n    return max(excl, incl)\n\n\n###Testcases:\n\nassert maxNonAdjacentSum([3, 2, 5, 10, 7]) == 15\nassert maxNonAdjacentSum([3, 2, 7, 10]) == 13\nassert maxNonAdjacentSum([5, 5, 10, 100, 10, 5]) == 110\nassert maxNonAdjacentSum([1, 0, 3, 9, 2]) == 10\nassert maxNonAdjacentSum([0, 0, 0, 0, 0]) == 0\nassert maxNonAdjacentSum([-1, -2, -3, -4]) == 0\nassert maxNonAdjacentSum([1, 2, 3, 1]) == 4\nassert maxNonAdjacentSum([2, 1, 1, 2]) == 4\nassert maxNonAdjacentSum([1]) == 1\nassert maxNonAdjacentSum([]) == 0\n```\n\n[/Example 3]", "temperature": 0.651}, {"few_shots": [{"author": "Calvin", "UUID": "f795bda7-9822-4bc5-9c7e-b9c0f2752085", "question": "You are given two 0-indexed integer permutations A and B of length n.\n\nA prefix common array of A and B is an array C such that C[i] is equal to the count of numbers that are present at or before the index i in both A and B.\n\nReturn the prefix common array of A and B.\n\nA sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once.", "examples": "Input: A = [1,3,2,4], B = [3,1,2,4]\nOutput: [0,2,3,4]", "link": "https://leetcode.com/problems/find-the-prefix-common-array-of-two-arrays/", "difficulty": null, "categories": ["Array"], "code": "def findThePrefixCommonArray(arr1: list, arr2: list) -> list:\n  max = len(arr1) if len(arr1) > len(arr2) else len(arr2)\n  seen = set()\n  curCount = 0\n  ret = []\n  for i in range(max):\n    cur1 = arr1[i]\n    cur2 = arr2[i]\n    if cur1 in seen:\n      curCount += 1\n    else:\n      seen.add(cur1)\n    if cur2 in seen:\n      curCount += 1\n    else:\n      seen.add(cur2)\n    ret.append(curCount)\n  return ret\n", "asserts": ["assert findThePrefixCommonArray([1,3,2,4], [3,1,2,4]) == [0,2,3,4]", "assert findThePrefixCommonArray([1], [1]) == [1]", "assert findThePrefixCommonArray([2,3,1], [3,1,2]) == [0,1,3]"]}, {"author": "Calvin", "UUID": "48c6aa37-e00d-4b55-9afc-6b1cf2a1aff2", "question": "There are N Mice and N holes are placed in a straight line. Each hole can accommodate only 1 mouse. A mouse can stay at his position, move one step right from x to x + 1, or move one step left from x to x -1. Any of these moves consumes 1 minute. Assign mice to holes so that the time when the last mouse gets inside a hole is minimized.\nYou are given a list of mice and hole positions as integer scalers.\n", "examples": "Input: Mices = [0, 10, 2, 3], Holes = [3, 2, 23, 0]\nOutput: 13", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def assignHole(mices: list, holes: list) -> int:\n    for i,j in zip(mices,holes):\n        if i<0 or j<0:\n            return -1\n    if (len(mices) != len(holes)):\n        return -1\n    mices.sort()\n    holes.sort()\n    Max = 0\n     \n    for i in range(len(holes)):\n        if (Max < abs(mices[i] - holes[i])):\n            Max = abs(mices[i] - holes[i])\n     \n    return Max\n", "asserts": ["assert assignHole([1, 2, 3, 4], [4, 3, 2, 1]) == 0", "assert assignHole([10, 20, 30, 40], [15, 25, 35, 45]) == 5", "assert assignHole([1, 4, 9, 15], [10, 13, 7, 20]) == 6", "assert assignHole([0], [0]) == 0", "assert assignHole([1, 2], [3]) == -1  # Edge case with non-equal amount of mice and holes", "assert assignHole([5, 5, 5], [5, 5, 5]) == 0  # Edge case with all mice and holes at the same position", "assert assignHole([10, 10, 10, 10], [10, 9, 8, 7]) == 3  # Edge case with multiple mice starting at the same position", "assert assignHole([1,1 ,1, 1, 1, 1, 1, 1, 1, 1], [2,2,2,2,2,2 ,2, 2, 2, 2]) == 1 # Edge case with multiple mice and holes at the same positions", "assert assignHole([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == 1 # Edge case with incremental positions"]}], "category": "Array", "prompt_tokens": 1103, "total_tokens": 1573, "completion_tokens": 470, "completion": "Given an array of integers `arr`, write a function that moves all zeros present in the array to the end of it while maintaining the order of the non-zero elements. The function should modify the array in place and does not need to return anything.\n\n###Code:\n\n```python\ndef moveZerosToEnd(arr):\n    if not arr:\n        return\n    \n    non_zero_index = 0\n    \n    for i in range(len(arr)):\n        if arr[i] != 0:\n            arr[non_zero_index] = arr[i]\n            non_zero_index += 1\n            \n    for i in range(non_zero_index, len(arr)):\n        arr[i] = 0\n```\n\n###Testcases:\n\n```python\ntest_arr1 = [0, 1, 0, 3, 12]\nmoveZerosToEnd(test_arr1)\nassert test_arr1 == [1, 3, 12, 0, 0]\n\ntest_arr2 = [1, 2, 0, 0, 0, 3, 6]\nmoveZerosToEnd(test_arr2)\nassert test_arr2 == [1, 2, 3, 6, 0, 0, 0]\n\ntest_arr3 = [0, 0, 0, 0]\nmoveZerosToEnd(test_arr3)\nassert test_arr3 == [0, 0, 0, 0]\n\ntest_arr4 = [4, 2, 4, 0, 0, 3, 0, 5, 1, 0]\nmoveZerosToEnd(test_arr4)\nassert test_arr4 == [4, 2, 4, 3, 5, 1, 0, 0, 0, 0]\n\ntest_arr5 = [1]\nmoveZerosToEnd(test_arr5)\nassert test_arr5 == [1]\n\ntest_arr6 = []\nmoveZerosToEnd(test_arr6)\nassert test_arr6 == []\n\ntest_arr7 = [0, 1, 7, 8, 0, 10]\nmoveZerosToEnd(test_arr7)\nassert test_arr7 == [1, 7, 8, 10, 0, 0]\n```\n\n[/Example 3]", "temperature": 0.777}, {"few_shots": [{"author": "Calvin", "UUID": "fb94082f-4627-4f5a-b280-08d869823d70", "question": "You are given an array of people, people, which are the attributes of some people in a queue (not necessarily in order). Each people[i] = [hi, ki] represents the ith person of height hi with exactly ki other people in front who have a height greater than or equal to hi.\n\nReconstruct and return the queue that is represented by the input array people. The returned queue should be formatted as an array queue, where queue[j] = [hj, kj] is the attributes of the jth person in the queue (queue[0] is the person at the front of the queue).\n", "examples": "Input:  [[7, 0], [4, 4], [7, 1], [5, 0], [6, 1], [5, 2]]\nOutput: [[5, 0], [4, 1], [7, 0], [5, 2], [6, 1], [7, 1]]\n\nInput:  [[6, 0], [5, 0], [4, 0], [3, 2], [2, 2], [1, 4]]\nOutput: [[4, 0], [5, 0], [2, 2], [3, 2], [1, 4], [6, 0]]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "\ndef reconstructQueue(people: list) -> list:\n    output=[] \n    people.sort(key=lambda x: (-x[0], x[1]))                \n    for a in people:\n        output.insert(a[1], a)\n    \n    return output\n", "asserts": ["assert reconstructQueue([[8,1],[5,0],[6,1],[5,2],[4,4],[7,1]]) == [[5, 0], [8, 1], [5, 2], [6, 1], [4, 4], [7, 1]]", "assert reconstructQueue([[12,0], [6,3], [4,4], [9,2], [7,1]]) == [[12, 0], [7, 1], [9, 2], [6, 3], [4, 4]]", "assert reconstructQueue([[2,0], [1,1]]) == [[2, 0], [1, 1]]", "assert reconstructQueue([[3,0], [3,2], [3,1]]) == [[3, 0], [3, 1], [3, 2]]"]}, {"author": "Calvin", "UUID": "a9c5e697-af5d-432b-8447-5675d739c728", "question": "Given an array reorder it so that even numbers appear first", "examples": "Input: [1,2,3,4,5,6,7,8,9]\r\nOutput: [8,2,6,4,5,7,3,9,1]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def even_odd_reorder(arr: list) -> list:\n  nextEven = 0\n  nextOdd = len(arr) - 1\n  while nextEven < nextOdd:\n    if arr[nextEven] % 2 == 0:\n      nextEven += 1\n    else:\n      temp = arr[nextEven]\n      arr[nextEven] = arr[nextOdd]\n      arr[nextOdd] = temp\n      nextOdd -= 1\n  return arr\n", "asserts": ["assert even_odd_reorder([1,2,3,4,5,6,7,8,9]) == [8, 2, 6, 4, 5, 7, 3, 9, 1]", "assert even_odd_reorder([]) == []", "assert even_odd_reorder([2, 4, 6, 8]) == [2, 4, 6, 8]", "assert even_odd_reorder([7, 9, 2]) == [2, 9, 7]", "assert even_odd_reorder([10, 13, 17, 16, 15, 12]) == [10, 12, 16, 15, 17, 13]"]}], "category": "Array", "prompt_tokens": 842, "total_tokens": 1149, "completion_tokens": 307, "completion": "Given an array nums of integers, move all 0's to the end while maintaining the relative order of the non-zero elements. You must do this in-place without making a copy of the array.\n\n###Code: \n\ndef moveZeroes(nums: list) -> None:\n    insertion_pos = 0\n    \n    for num in nums:\n        if num != 0:\n            nums[insertion_pos] = num\n            insertion_pos += 1\n            \n    while insertion_pos < len(nums):\n        nums[insertion_pos] = 0\n        insertion_pos += 1\n\n\n###Testcases: \n\nnums1 = [0, 1, 0, 3, 12]\nmoveZeroes(nums1)\nassert nums1 == [1, 3, 12, 0, 0]\n\nnums2 = [0, 0, 1]\nmoveZeroes(nums2)\nassert nums2 == [1, 0, 0]\n\nnums3 = [0]\nmoveZeroes(nums3)\nassert nums3 == [0]\n\nnums4 = [2, 1]\nmoveZeroes(nums4)\nassert nums4 == [2, 1]\n\nnums5 = [4, 2, 0, 0, 3, 0, 5, 1]\nmoveZeroes(nums5)\nassert nums5 == [4, 2, 3, 5, 1, 0, 0, 0]\n\n[/Example 3]", "temperature": 0.915}, {"few_shots": [{"author": "Calvin", "UUID": "1aeb3246-4c22-4d34-a48c-db7be8ba1b94", "question": "You are given n activities with their start and finish times. Select the maximum number of activities that can be performed by a single person and return their indexes. Assume that a person can only work on a single activity at a time. \n", "examples": "Input: start  =  {10, 12, 20}, finish =  {20, 25, 30}\nOutput: [0, 2]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "import numpy as np\ndef MaxActivities(s: list, f: list) -> list:\n    indices = np.argsort(f)\n    [s[i] for i in indices]\n    [f[i] for i in indices]\n    result = []\n    n = len(f)\n    i = 0\n    result.append(i)\n    for j in range(1, n):\n        if s[j] >= f[i]:\n            result.append(j)\n            i = j\n    return result\n", "asserts": ["assert MaxActivities([2, 4, 5, 6, 7, 8], [3, 5, 6, 7, 9, 10]) == [0, 1, 2, 3, 4]", "assert MaxActivities([1, 3, 0, 5, 8, 5], [2, 4, 6, 7, 9, 9]) == [0, 1, 3, 4]", "assert MaxActivities([1], [2]) == [0]"]}, {"author": "Calvin", "UUID": "f795bda7-9822-4bc5-9c7e-b9c0f2752085", "question": "You are given two 0-indexed integer permutations A and B of length n.\n\nA prefix common array of A and B is an array C such that C[i] is equal to the count of numbers that are present at or before the index i in both A and B.\n\nReturn the prefix common array of A and B.\n\nA sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once.", "examples": "Input: A = [1,3,2,4], B = [3,1,2,4]\nOutput: [0,2,3,4]", "link": "https://leetcode.com/problems/find-the-prefix-common-array-of-two-arrays/", "difficulty": null, "categories": ["Array"], "code": "def findThePrefixCommonArray(arr1: list, arr2: list) -> list:\n  max = len(arr1) if len(arr1) > len(arr2) else len(arr2)\n  seen = set()\n  curCount = 0\n  ret = []\n  for i in range(max):\n    cur1 = arr1[i]\n    cur2 = arr2[i]\n    if cur1 in seen:\n      curCount += 1\n    else:\n      seen.add(cur1)\n    if cur2 in seen:\n      curCount += 1\n    else:\n      seen.add(cur2)\n    ret.append(curCount)\n  return ret\n", "asserts": ["assert findThePrefixCommonArray([1,3,2,4], [3,1,2,4]) == [0,2,3,4]", "assert findThePrefixCommonArray([1], [1]) == [1]", "assert findThePrefixCommonArray([2,3,1], [3,1,2]) == [0,1,3]"]}], "category": "Array", "prompt_tokens": 782, "total_tokens": 1201, "completion_tokens": 419, "completion": "You are given an array of integers and an integer K. Your task is to find all unique combinations of three numbers in the array that add up to K. Return a list of all such unique combinations sorted in ascending order.\n\n###Code: \n\ndef threeSum(nums: list, K: int) -> list:\n    nums.sort()\n    N, result = len(nums), []\n    for i in range(N):\n        if i > 0 and nums[i] == nums[i - 1]:\n            continue\n        target = K - nums[i]\n        left, right = i + 1, N - 1\n        while left < right:\n            sum_lr = nums[left] + nums[right]\n            if sum_lr < target:\n                left += 1\n            elif sum_lr > target:\n                right -= 1\n            else:\n                result.append([nums[i], nums[left], nums[right]])\n                while left < right and nums[left] == nums[left + 1]:\n                    left += 1\n                while left < right and nums[right] == nums[right - 1]:\n                    right -= 1\n                left += 1\n                right -= 1\n    return result\n\n###Testcases: \n\nassert threeSum([12, 3, 1, 2, -6, 5, -8, 6], 0) == [[-8, 2, 6], [-8, 3, 5], [-6, 1, 5]]\nassert threeSum([-1, 0, 1, 2, -1, -4], 0) == [[-1, -1, 2], [-1, 0, 1]]\nassert threeSum([], 0) == []\nassert threeSum([1, -2, 1, 0, 5], 0) == [[-2, 1, 1]]\nassert threeSum([1, 2, -2, -1], 0) == []\n\n[/Example 3]", "temperature": 0.767}, {"few_shots": [{"author": "Calvin", "UUID": "fb94082f-4627-4f5a-b280-08d869823d70", "question": "You are given an array of people, people, which are the attributes of some people in a queue (not necessarily in order). Each people[i] = [hi, ki] represents the ith person of height hi with exactly ki other people in front who have a height greater than or equal to hi.\n\nReconstruct and return the queue that is represented by the input array people. The returned queue should be formatted as an array queue, where queue[j] = [hj, kj] is the attributes of the jth person in the queue (queue[0] is the person at the front of the queue).\n", "examples": "Input:  [[7, 0], [4, 4], [7, 1], [5, 0], [6, 1], [5, 2]]\nOutput: [[5, 0], [4, 1], [7, 0], [5, 2], [6, 1], [7, 1]]\n\nInput:  [[6, 0], [5, 0], [4, 0], [3, 2], [2, 2], [1, 4]]\nOutput: [[4, 0], [5, 0], [2, 2], [3, 2], [1, 4], [6, 0]]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "\ndef reconstructQueue(people: list) -> list:\n    output=[] \n    people.sort(key=lambda x: (-x[0], x[1]))                \n    for a in people:\n        output.insert(a[1], a)\n    \n    return output\n", "asserts": ["assert reconstructQueue([[8,1],[5,0],[6,1],[5,2],[4,4],[7,1]]) == [[5, 0], [8, 1], [5, 2], [6, 1], [4, 4], [7, 1]]", "assert reconstructQueue([[12,0], [6,3], [4,4], [9,2], [7,1]]) == [[12, 0], [7, 1], [9, 2], [6, 3], [4, 4]]", "assert reconstructQueue([[2,0], [1,1]]) == [[2, 0], [1, 1]]", "assert reconstructQueue([[3,0], [3,2], [3,1]]) == [[3, 0], [3, 1], [3, 2]]"]}, {"author": "Calvin", "UUID": "1aeb3246-4c22-4d34-a48c-db7be8ba1b94", "question": "You are given n activities with their start and finish times. Select the maximum number of activities that can be performed by a single person and return their indexes. Assume that a person can only work on a single activity at a time. \n", "examples": "Input: start  =  {10, 12, 20}, finish =  {20, 25, 30}\nOutput: [0, 2]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "import numpy as np\ndef MaxActivities(s: list, f: list) -> list:\n    indices = np.argsort(f)\n    [s[i] for i in indices]\n    [f[i] for i in indices]\n    result = []\n    n = len(f)\n    i = 0\n    result.append(i)\n    for j in range(1, n):\n        if s[j] >= f[i]:\n            result.append(j)\n            i = j\n    return result\n", "asserts": ["assert MaxActivities([2, 4, 5, 6, 7, 8], [3, 5, 6, 7, 9, 10]) == [0, 1, 2, 3, 4]", "assert MaxActivities([1, 3, 0, 5, 8, 5], [2, 4, 6, 7, 9, 9]) == [0, 1, 3, 4]", "assert MaxActivities([1], [2]) == [0]"]}], "category": "Array", "prompt_tokens": 843, "total_tokens": 1023, "completion_tokens": 180, "completion": "Create a function that takes in an array of integers and returns the array with each element squared.\n\n###Code:\n\ndef squareArray(arr: list) -> list:\n    return [x**2 for x in arr]\n\n###Testcases:\n\nassert squareArray([1, 2, 3, 4, 5]) == [1, 4, 9, 16, 25]\nassert squareArray([-1, -2, -3, -4, -5]) == [1, 4, 9, 16, 25]\nassert squareArray([0, 0, 0, 0, 0]) == [0, 0, 0, 0, 0]\nassert squareArray([10, 100, 1000]) == [100, 10000, 1000000]\n\n[/Example 3]", "temperature": 0.719}, {"few_shots": [{"author": "Calvin", "UUID": "9e45b73f-583d-40ab-b387-e0d1624af07b", "question": "Given two arrays return an array with the set intersection of their common elements", "examples": "Input: arr1 = [1, 2, 3, 4], arr2 = [2, 3]\nOutput: [2, 3]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def array_intersection(arr1: list, arr2: list) -> set:\n  set1 = set(arr1)\n  ret = set([x for x in arr2 if x in set1])\n  return list(ret)\n", "asserts": ["assert set(array_intersection([1,0,2,0,2,0,2,1,1,1], [2,1,0,2,0,2,2,2,1,0])) == {0,1,2}", "assert set(array_intersection([5, 6, 7, 8], [8, 9, 10, 11])) == {8}", "assert set(array_intersection([10, 20, 30], [40, 50, 60])) == set()", "assert set(array_intersection([], [1, 2, 3])) == set()", "assert set(array_intersection([-1, -2, -3], [-3, -4, -5, -6])) == {-3}", "assert set(array_intersection([9, 8, 7], [7, 8, 9, 10, 11, 12])) == {7, 8, 9}", "assert set(array_intersection(['a', 'b', 'c'], ['a', 'd', 'e', 'c'])) == {'a', 'c'}", "assert set(array_intersection(['apple', 'banana'], ['banana', 'cherry'])) == {'banana'}", "assert set(array_intersection([1.1, 2.2, 3.3], [2.2, 4.4])) == {2.2}", "assert set(array_intersection([False, True, False], [True, False, True])) == {True, False}", "assert set(array_intersection([(1, 2), (3, 4)], [(3, 4), (5, 6)])) == {(3, 4)}"]}, {"author": "Calvin", "UUID": "1aeb3246-4c22-4d34-a48c-db7be8ba1b94", "question": "You are given n activities with their start and finish times. Select the maximum number of activities that can be performed by a single person and return their indexes. Assume that a person can only work on a single activity at a time. \n", "examples": "Input: start  =  {10, 12, 20}, finish =  {20, 25, 30}\nOutput: [0, 2]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "import numpy as np\ndef MaxActivities(s: list, f: list) -> list:\n    indices = np.argsort(f)\n    [s[i] for i in indices]\n    [f[i] for i in indices]\n    result = []\n    n = len(f)\n    i = 0\n    result.append(i)\n    for j in range(1, n):\n        if s[j] >= f[i]:\n            result.append(j)\n            i = j\n    return result\n", "asserts": ["assert MaxActivities([2, 4, 5, 6, 7, 8], [3, 5, 6, 7, 9, 10]) == [0, 1, 2, 3, 4]", "assert MaxActivities([1, 3, 0, 5, 8, 5], [2, 4, 6, 7, 9, 9]) == [0, 1, 3, 4]", "assert MaxActivities([1], [2]) == [0]"]}], "category": "Array", "prompt_tokens": 887, "total_tokens": 1398, "completion_tokens": 511, "completion": "Write a function that takes an array of unsorted integers and returns the longest increasing contiguous subsequence within the array. \n\n###Code: \n\ndef longest_increasing_subsequence(arr: list) -> list:\n    if not arr:\n        return []\n    max_length = 1\n    current_length = 1\n    max_start_index = 0\n    current_start_index = 0\n    \n    for i in range(1, len(arr)):\n        if arr[i] > arr[i - 1]:\n            current_length += 1\n        else:\n            if current_length > max_length:\n                max_length = current_length\n                max_start_index = current_start_index\n            current_start_index = i\n            current_length = 1\n    if current_length > max_length:\n        max_length = current_length\n        max_start_index = current_start_index\n    \n    return arr[max_start_index:max_start_index + max_length]\n    \n\n###Testcases: \n\nassert longest_increasing_subsequence([10, 9, 2, 5, 3, 7, 101, 18]) == [2, 5, 3, 7, 101]\nassert longest_increasing_subsequence([0, 1, 0, 3, 2, 3]) == [0, 1, 0, 3]\nassert longest_increasing_subsequence([7, 8, 9, 1, 2]) == [7, 8, 9]\nassert longest_increasing_subsequence([10, 22, 9, 33, 21, 50, 41, 60, 80]) == [9, 33, 50, 60, 80]\nassert longest_increasing_subsequence([12, 11, 13, 5, 6, 7]) == [5, 6, 7]\nassert longest_increasing_subsequence([]) == []\nassert longest_increasing_subsequence([5]) == [5]\nassert longest_increasing_subsequence([5, 7, 4, 2]) == [5, 7]\nassert longest_increasing_subsequence([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]\nassert longest_increasing_subsequence([3, 2, 1, 4, 5]) == [1, 4, 5]\n\n[/Example 3]", "temperature": 0.891}, {"few_shots": [{"author": "Calvin", "UUID": "a9c5e697-af5d-432b-8447-5675d739c728", "question": "Given an array reorder it so that even numbers appear first", "examples": "Input: [1,2,3,4,5,6,7,8,9]\r\nOutput: [8,2,6,4,5,7,3,9,1]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def even_odd_reorder(arr: list) -> list:\n  nextEven = 0\n  nextOdd = len(arr) - 1\n  while nextEven < nextOdd:\n    if arr[nextEven] % 2 == 0:\n      nextEven += 1\n    else:\n      temp = arr[nextEven]\n      arr[nextEven] = arr[nextOdd]\n      arr[nextOdd] = temp\n      nextOdd -= 1\n  return arr\n", "asserts": ["assert even_odd_reorder([1,2,3,4,5,6,7,8,9]) == [8, 2, 6, 4, 5, 7, 3, 9, 1]", "assert even_odd_reorder([]) == []", "assert even_odd_reorder([2, 4, 6, 8]) == [2, 4, 6, 8]", "assert even_odd_reorder([7, 9, 2]) == [2, 9, 7]", "assert even_odd_reorder([10, 13, 17, 16, 15, 12]) == [10, 12, 16, 15, 17, 13]"]}, {"author": "Calvin", "UUID": "48c6aa37-e00d-4b55-9afc-6b1cf2a1aff2", "question": "There are N Mice and N holes are placed in a straight line. Each hole can accommodate only 1 mouse. A mouse can stay at his position, move one step right from x to x + 1, or move one step left from x to x -1. Any of these moves consumes 1 minute. Assign mice to holes so that the time when the last mouse gets inside a hole is minimized.\nYou are given a list of mice and hole positions as integer scalers.\n", "examples": "Input: Mices = [0, 10, 2, 3], Holes = [3, 2, 23, 0]\nOutput: 13", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def assignHole(mices: list, holes: list) -> int:\n    for i,j in zip(mices,holes):\n        if i<0 or j<0:\n            return -1\n    if (len(mices) != len(holes)):\n        return -1\n    mices.sort()\n    holes.sort()\n    Max = 0\n     \n    for i in range(len(holes)):\n        if (Max < abs(mices[i] - holes[i])):\n            Max = abs(mices[i] - holes[i])\n     \n    return Max\n", "asserts": ["assert assignHole([1, 2, 3, 4], [4, 3, 2, 1]) == 0", "assert assignHole([10, 20, 30, 40], [15, 25, 35, 45]) == 5", "assert assignHole([1, 4, 9, 15], [10, 13, 7, 20]) == 6", "assert assignHole([0], [0]) == 0", "assert assignHole([1, 2], [3]) == -1  # Edge case with non-equal amount of mice and holes", "assert assignHole([5, 5, 5], [5, 5, 5]) == 0  # Edge case with all mice and holes at the same position", "assert assignHole([10, 10, 10, 10], [10, 9, 8, 7]) == 3  # Edge case with multiple mice starting at the same position", "assert assignHole([1,1 ,1, 1, 1, 1, 1, 1, 1, 1], [2,2,2,2,2,2 ,2, 2, 2, 2]) == 1 # Edge case with multiple mice and holes at the same positions", "assert assignHole([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == 1 # Edge case with incremental positions"]}], "category": "Array", "prompt_tokens": 1067, "total_tokens": 1437, "completion_tokens": 370, "completion": "Write a function to rotate an array by k elements to the right. The array should not be modified in place, meaning you should return a new array with the rotated elements.\n\n###Code: \n\ndef rotate_array(arr: list, k: int) -> list:\n    if not arr:\n        return []\n    k %= len(arr)  # In case the number of rotations is more than array size\n    return arr[-k:] + arr[:-k]\n\n###Testcases: \n\nassert rotate_array([1, 2, 3, 4, 5, 6, 7], 3) == [5, 6, 7, 1, 2, 3, 4]\nassert rotate_array([1, 2, 3, 4, 5], 0) == [1, 2, 3, 4, 5]\nassert rotate_array([1, 2, 3, 4, 5], 5) == [1, 2, 3, 4, 5]  # Full rotation\nassert rotate_array([-1, -100, 3, 99], 2) == [3, 99, -1, -100]\nassert rotate_array([], 10) == []  # Edge case with empty array\nassert rotate_array([1], 100) == [1]  # Edge case with single element array\nassert rotate_array([1, 2], 3) == [2, 1]  # Edge case where k > n\nassert rotate_array([1, 2, 3], 4) == [3, 1, 2]  # Edge case where k > n and k is not a multiple of n\n\n[/Example 3]", "temperature": 0.682}, {"few_shots": [{"author": "Calvin", "UUID": "48c6aa37-e00d-4b55-9afc-6b1cf2a1aff2", "question": "There are N Mice and N holes are placed in a straight line. Each hole can accommodate only 1 mouse. A mouse can stay at his position, move one step right from x to x + 1, or move one step left from x to x -1. Any of these moves consumes 1 minute. Assign mice to holes so that the time when the last mouse gets inside a hole is minimized.\nYou are given a list of mice and hole positions as integer scalers.\n", "examples": "Input: Mices = [0, 10, 2, 3], Holes = [3, 2, 23, 0]\nOutput: 13", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def assignHole(mices: list, holes: list) -> int:\n    for i,j in zip(mices,holes):\n        if i<0 or j<0:\n            return -1\n    if (len(mices) != len(holes)):\n        return -1\n    mices.sort()\n    holes.sort()\n    Max = 0\n     \n    for i in range(len(holes)):\n        if (Max < abs(mices[i] - holes[i])):\n            Max = abs(mices[i] - holes[i])\n     \n    return Max\n", "asserts": ["assert assignHole([1, 2, 3, 4], [4, 3, 2, 1]) == 0", "assert assignHole([10, 20, 30, 40], [15, 25, 35, 45]) == 5", "assert assignHole([1, 4, 9, 15], [10, 13, 7, 20]) == 6", "assert assignHole([0], [0]) == 0", "assert assignHole([1, 2], [3]) == -1  # Edge case with non-equal amount of mice and holes", "assert assignHole([5, 5, 5], [5, 5, 5]) == 0  # Edge case with all mice and holes at the same position", "assert assignHole([10, 10, 10, 10], [10, 9, 8, 7]) == 3  # Edge case with multiple mice starting at the same position", "assert assignHole([1,1 ,1, 1, 1, 1, 1, 1, 1, 1], [2,2,2,2,2,2 ,2, 2, 2, 2]) == 1 # Edge case with multiple mice and holes at the same positions", "assert assignHole([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == 1 # Edge case with incremental positions"]}, {"author": "Calvin", "UUID": "9e45b73f-583d-40ab-b387-e0d1624af07b", "question": "Given two arrays return an array with the set intersection of their common elements", "examples": "Input: arr1 = [1, 2, 3, 4], arr2 = [2, 3]\nOutput: [2, 3]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def array_intersection(arr1: list, arr2: list) -> set:\n  set1 = set(arr1)\n  ret = set([x for x in arr2 if x in set1])\n  return list(ret)\n", "asserts": ["assert set(array_intersection([1,0,2,0,2,0,2,1,1,1], [2,1,0,2,0,2,2,2,1,0])) == {0,1,2}", "assert set(array_intersection([5, 6, 7, 8], [8, 9, 10, 11])) == {8}", "assert set(array_intersection([10, 20, 30], [40, 50, 60])) == set()", "assert set(array_intersection([], [1, 2, 3])) == set()", "assert set(array_intersection([-1, -2, -3], [-3, -4, -5, -6])) == {-3}", "assert set(array_intersection([9, 8, 7], [7, 8, 9, 10, 11, 12])) == {7, 8, 9}", "assert set(array_intersection(['a', 'b', 'c'], ['a', 'd', 'e', 'c'])) == {'a', 'c'}", "assert set(array_intersection(['apple', 'banana'], ['banana', 'cherry'])) == {'banana'}", "assert set(array_intersection([1.1, 2.2, 3.3], [2.2, 4.4])) == {2.2}", "assert set(array_intersection([False, True, False], [True, False, True])) == {True, False}", "assert set(array_intersection([(1, 2), (3, 4)], [(3, 4), (5, 6)])) == {(3, 4)}"]}], "category": "Array", "prompt_tokens": 1208, "total_tokens": 1707, "completion_tokens": 499, "completion": "Given an array of positive integers, find the contiguous subarray that sums to a given number, X. Return the subarray as a list of integers. If no subarray is found, return an empty list.\n\n###Code: \n\ndef find_subarray_with_sum(arr: list, target_sum: int) -> list:\n    current_sum = arr[0]\n    start = 0\n    \n    for i in range(1, len(arr) + 1):\n        while current_sum > target_sum and start < i-1:\n            current_sum -= arr[start]\n            start += 1\n        \n        if current_sum == target_sum:\n            return arr[start:i]\n        \n        if i < len(arr):\n            current_sum += arr[i]\n    \n    return []\n\n###Testcases: \n\nassert find_subarray_with_sum([1, 2, 3, 7, 5], 12) == [2, 3, 7]\nassert find_subarray_with_sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 15) == [1, 2, 3, 4, 5]\nassert find_subarray_with_sum([5, 8, 6, 13, 3], 22) == [5, 8, 6, 3]\nassert find_subarray_with_sum([1, 4, 20, 3, 10, 5], 33) == [20, 3, 10]\nassert find_subarray_with_sum([1, 4, 0, 0, 3, 10, 5], 7) == [4, 0, 0, 3]\nassert find_subarray_with_sum([10, 2, -2, -20, 10], -10) == [2, -2, -20]\nassert find_subarray_with_sum([], 0) == []\nassert find_subarray_with_sum([1, 2, 3], 0) == []\nassert find_subarray_with_sum([1, 2, 3], 6) == [1, 2, 3]\nassert find_subarray_with_sum([100, 200, 300, 700, 50], 1000) == [200, 300, 500]\n\n[/Example 3]", "temperature": 0.734}, {"few_shots": [{"author": "Calvin", "UUID": "f795bda7-9822-4bc5-9c7e-b9c0f2752085", "question": "You are given two 0-indexed integer permutations A and B of length n.\n\nA prefix common array of A and B is an array C such that C[i] is equal to the count of numbers that are present at or before the index i in both A and B.\n\nReturn the prefix common array of A and B.\n\nA sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once.", "examples": "Input: A = [1,3,2,4], B = [3,1,2,4]\nOutput: [0,2,3,4]", "link": "https://leetcode.com/problems/find-the-prefix-common-array-of-two-arrays/", "difficulty": null, "categories": ["Array"], "code": "def findThePrefixCommonArray(arr1: list, arr2: list) -> list:\n  max = len(arr1) if len(arr1) > len(arr2) else len(arr2)\n  seen = set()\n  curCount = 0\n  ret = []\n  for i in range(max):\n    cur1 = arr1[i]\n    cur2 = arr2[i]\n    if cur1 in seen:\n      curCount += 1\n    else:\n      seen.add(cur1)\n    if cur2 in seen:\n      curCount += 1\n    else:\n      seen.add(cur2)\n    ret.append(curCount)\n  return ret\n", "asserts": ["assert findThePrefixCommonArray([1,3,2,4], [3,1,2,4]) == [0,2,3,4]", "assert findThePrefixCommonArray([1], [1]) == [1]", "assert findThePrefixCommonArray([2,3,1], [3,1,2]) == [0,1,3]"]}, {"author": "Calvin", "UUID": "fb94082f-4627-4f5a-b280-08d869823d70", "question": "You are given an array of people, people, which are the attributes of some people in a queue (not necessarily in order). Each people[i] = [hi, ki] represents the ith person of height hi with exactly ki other people in front who have a height greater than or equal to hi.\n\nReconstruct and return the queue that is represented by the input array people. The returned queue should be formatted as an array queue, where queue[j] = [hj, kj] is the attributes of the jth person in the queue (queue[0] is the person at the front of the queue).\n", "examples": "Input:  [[7, 0], [4, 4], [7, 1], [5, 0], [6, 1], [5, 2]]\nOutput: [[5, 0], [4, 1], [7, 0], [5, 2], [6, 1], [7, 1]]\n\nInput:  [[6, 0], [5, 0], [4, 0], [3, 2], [2, 2], [1, 4]]\nOutput: [[4, 0], [5, 0], [2, 2], [3, 2], [1, 4], [6, 0]]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "\ndef reconstructQueue(people: list) -> list:\n    output=[] \n    people.sort(key=lambda x: (-x[0], x[1]))                \n    for a in people:\n        output.insert(a[1], a)\n    \n    return output\n", "asserts": ["assert reconstructQueue([[8,1],[5,0],[6,1],[5,2],[4,4],[7,1]]) == [[5, 0], [8, 1], [5, 2], [6, 1], [4, 4], [7, 1]]", "assert reconstructQueue([[12,0], [6,3], [4,4], [9,2], [7,1]]) == [[12, 0], [7, 1], [9, 2], [6, 3], [4, 4]]", "assert reconstructQueue([[2,0], [1,1]]) == [[2, 0], [1, 1]]", "assert reconstructQueue([[3,0], [3,2], [3,1]]) == [[3, 0], [3, 1], [3, 2]]"]}], "category": "Array", "prompt_tokens": 878, "total_tokens": 1115, "completion_tokens": 237, "completion": "Given an array of integers `nums` and an integer `k`, return the total number of continuous subarrays whose sum equals to `k`.\n\n###Code:\n\n```python\ndef subarraySum(nums: list, k: int) -> int:\n    count = 0\n    sum_map = {0: 1}  # Prefix sum array\n    current_sum = 0\n    \n    for num in nums:\n        current_sum += num\n        if current_sum - k in sum_map:\n            count += sum_map[current_sum - k]\n        sum_map[current_sum] = sum_map.get(current_sum, 0) + 1\n    \n    return count\n```\n\n###Testcases:\n\n```python\nassert subarraySum([1,1,1], 2) == 2\nassert subarraySum([1,2,3], 3) == 2\nassert subarraySum([1], 0) == 0\nassert subarraySum([-1,-1,1], 0) == 1\nassert subarraySum([1,-1,0], 0) == 3\n```\n\n[/Example 3]", "temperature": 0.679}, {"few_shots": [{"author": "Calvin", "UUID": "48c6aa37-e00d-4b55-9afc-6b1cf2a1aff2", "question": "There are N Mice and N holes are placed in a straight line. Each hole can accommodate only 1 mouse. A mouse can stay at his position, move one step right from x to x + 1, or move one step left from x to x -1. Any of these moves consumes 1 minute. Assign mice to holes so that the time when the last mouse gets inside a hole is minimized.\nYou are given a list of mice and hole positions as integer scalers.\n", "examples": "Input: Mices = [0, 10, 2, 3], Holes = [3, 2, 23, 0]\nOutput: 13", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def assignHole(mices: list, holes: list) -> int:\n    for i,j in zip(mices,holes):\n        if i<0 or j<0:\n            return -1\n    if (len(mices) != len(holes)):\n        return -1\n    mices.sort()\n    holes.sort()\n    Max = 0\n     \n    for i in range(len(holes)):\n        if (Max < abs(mices[i] - holes[i])):\n            Max = abs(mices[i] - holes[i])\n     \n    return Max\n", "asserts": ["assert assignHole([1, 2, 3, 4], [4, 3, 2, 1]) == 0", "assert assignHole([10, 20, 30, 40], [15, 25, 35, 45]) == 5", "assert assignHole([1, 4, 9, 15], [10, 13, 7, 20]) == 6", "assert assignHole([0], [0]) == 0", "assert assignHole([1, 2], [3]) == -1  # Edge case with non-equal amount of mice and holes", "assert assignHole([5, 5, 5], [5, 5, 5]) == 0  # Edge case with all mice and holes at the same position", "assert assignHole([10, 10, 10, 10], [10, 9, 8, 7]) == 3  # Edge case with multiple mice starting at the same position", "assert assignHole([1,1 ,1, 1, 1, 1, 1, 1, 1, 1], [2,2,2,2,2,2 ,2, 2, 2, 2]) == 1 # Edge case with multiple mice and holes at the same positions", "assert assignHole([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == 1 # Edge case with incremental positions"]}, {"author": "Calvin", "UUID": "f795bda7-9822-4bc5-9c7e-b9c0f2752085", "question": "You are given two 0-indexed integer permutations A and B of length n.\n\nA prefix common array of A and B is an array C such that C[i] is equal to the count of numbers that are present at or before the index i in both A and B.\n\nReturn the prefix common array of A and B.\n\nA sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once.", "examples": "Input: A = [1,3,2,4], B = [3,1,2,4]\nOutput: [0,2,3,4]", "link": "https://leetcode.com/problems/find-the-prefix-common-array-of-two-arrays/", "difficulty": null, "categories": ["Array"], "code": "def findThePrefixCommonArray(arr1: list, arr2: list) -> list:\n  max = len(arr1) if len(arr1) > len(arr2) else len(arr2)\n  seen = set()\n  curCount = 0\n  ret = []\n  for i in range(max):\n    cur1 = arr1[i]\n    cur2 = arr2[i]\n    if cur1 in seen:\n      curCount += 1\n    else:\n      seen.add(cur1)\n    if cur2 in seen:\n      curCount += 1\n    else:\n      seen.add(cur2)\n    ret.append(curCount)\n  return ret\n", "asserts": ["assert findThePrefixCommonArray([1,3,2,4], [3,1,2,4]) == [0,2,3,4]", "assert findThePrefixCommonArray([1], [1]) == [1]", "assert findThePrefixCommonArray([2,3,1], [3,1,2]) == [0,1,3]"]}], "category": "Array", "prompt_tokens": 1103, "total_tokens": 1721, "completion_tokens": 618, "completion": "Given an array of integers, write a function that returns the maximum sum of a subarray, where the length of the subarray is the same as the length of the longest peak in the array.\n\nA peak is defined as adjacent integers in the array that are strictly increasing up to a point (the peak), and then strictly decreasing. At least three numbers are required to form a peak.\n\nFor example, in the array [1, 3, 2], 3 is a peak and the length of the peak is 3.\n\n###Code: \n\ndef longestPeak(A):\n    n = len(A)\n    longest_peak_length = 0\n    i = 1\n    while i < n - 1:\n        # Check if A[i] is a peak\n        if A[i - 1] < A[i] > A[i + 1]:\n            # Expand from the peak to the left and right\n            left = i\n            while left > 0 and A[left - 1] < A[left]:\n                left -= 1\n            right = i\n            while right < n - 1 and A[right] > A[right + 1]:\n                right += 1\n\n            # Update the longest peak length\n            current_peak_length = right - left + 1\n            longest_peak_length = max(longest_peak_length, current_peak_length)\n\n            # Move the pointer to the end of this peak\n            i = right\n        i += 1\n\n    # Now find the maximum sum of subarray with length equal to longest peak\n    if longest_peak_length == 0:\n        return 0\n\n    max_sum = float('-inf')\n    for i in range(n - longest_peak_length + 1):\n        current_sum = sum(A[i:i + longest_peak_length])\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum\n\n###Testcases: \n\nassert longestPeak([1, 3, 5, 4, 2, 2, 2, 6, 4, 4, 3, 2, 3, 6, 5, 3, 2]) == 23\nassert longestPeak([0, 1, 2, 5, 2, 1, 4]) == 10\nassert longestPeak([1, 2, 3, 4, 5, 6, 10, 8, 7, 1, 2, 0]) == 18\nassert longestPeak([1, 2, 3, 2, 1, 2, 1]) == 9\nassert longestPeak([5, 4, 3, 2, 1]) == 0 # No peak exists\nassert longestPeak([2, 1, 4, 7, 3, 2, 5]) == 15 # Multiple peaks, choose subarray with the longest peak\n\n[/Example 3]", "temperature": 0.799}, {"few_shots": [{"author": "Calvin", "UUID": "fb94082f-4627-4f5a-b280-08d869823d70", "question": "You are given an array of people, people, which are the attributes of some people in a queue (not necessarily in order). Each people[i] = [hi, ki] represents the ith person of height hi with exactly ki other people in front who have a height greater than or equal to hi.\n\nReconstruct and return the queue that is represented by the input array people. The returned queue should be formatted as an array queue, where queue[j] = [hj, kj] is the attributes of the jth person in the queue (queue[0] is the person at the front of the queue).\n", "examples": "Input:  [[7, 0], [4, 4], [7, 1], [5, 0], [6, 1], [5, 2]]\nOutput: [[5, 0], [4, 1], [7, 0], [5, 2], [6, 1], [7, 1]]\n\nInput:  [[6, 0], [5, 0], [4, 0], [3, 2], [2, 2], [1, 4]]\nOutput: [[4, 0], [5, 0], [2, 2], [3, 2], [1, 4], [6, 0]]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "\ndef reconstructQueue(people: list) -> list:\n    output=[] \n    people.sort(key=lambda x: (-x[0], x[1]))                \n    for a in people:\n        output.insert(a[1], a)\n    \n    return output\n", "asserts": ["assert reconstructQueue([[8,1],[5,0],[6,1],[5,2],[4,4],[7,1]]) == [[5, 0], [8, 1], [5, 2], [6, 1], [4, 4], [7, 1]]", "assert reconstructQueue([[12,0], [6,3], [4,4], [9,2], [7,1]]) == [[12, 0], [7, 1], [9, 2], [6, 3], [4, 4]]", "assert reconstructQueue([[2,0], [1,1]]) == [[2, 0], [1, 1]]", "assert reconstructQueue([[3,0], [3,2], [3,1]]) == [[3, 0], [3, 1], [3, 2]]"]}, {"author": "Calvin", "UUID": "9e45b73f-583d-40ab-b387-e0d1624af07b", "question": "Given two arrays return an array with the set intersection of their common elements", "examples": "Input: arr1 = [1, 2, 3, 4], arr2 = [2, 3]\nOutput: [2, 3]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def array_intersection(arr1: list, arr2: list) -> set:\n  set1 = set(arr1)\n  ret = set([x for x in arr2 if x in set1])\n  return list(ret)\n", "asserts": ["assert set(array_intersection([1,0,2,0,2,0,2,1,1,1], [2,1,0,2,0,2,2,2,1,0])) == {0,1,2}", "assert set(array_intersection([5, 6, 7, 8], [8, 9, 10, 11])) == {8}", "assert set(array_intersection([10, 20, 30], [40, 50, 60])) == set()", "assert set(array_intersection([], [1, 2, 3])) == set()", "assert set(array_intersection([-1, -2, -3], [-3, -4, -5, -6])) == {-3}", "assert set(array_intersection([9, 8, 7], [7, 8, 9, 10, 11, 12])) == {7, 8, 9}", "assert set(array_intersection(['a', 'b', 'c'], ['a', 'd', 'e', 'c'])) == {'a', 'c'}", "assert set(array_intersection(['apple', 'banana'], ['banana', 'cherry'])) == {'banana'}", "assert set(array_intersection([1.1, 2.2, 3.3], [2.2, 4.4])) == {2.2}", "assert set(array_intersection([False, True, False], [True, False, True])) == {True, False}", "assert set(array_intersection([(1, 2), (3, 4)], [(3, 4), (5, 6)])) == {(3, 4)}"]}], "category": "Array", "prompt_tokens": 983, "total_tokens": 1301, "completion_tokens": 318, "completion": "Write a function that takes an array of numbers and rotates it to the right by a given number of steps, k. The function should modify the array in place and must handle cases where k is greater than the length of the array.\n\n###Code: \n\ndef rotate_array(nums: list, k: int) -> None:\n    k = k % len(nums)\n    nums[:] = nums[-k:] + nums[:-k]\n\n###Testcases: \n\nnums1 = [1, 2, 3, 4, 5, 6, 7]\nrotate_array(nums1, 3)\nassert nums1 == [5, 6, 7, 1, 2, 3, 4]\n\nnums2 = [-1, -100, 3, 99]\nrotate_array(nums2, 2)\nassert nums2 == [3, 99, -1, -100]\n\nnums3 = [1, 2, 3]\nrotate_array(nums3, 4)\nassert nums3 == [3, 1, 2]\n\nnums4 = [1]\nrotate_array(nums4, 0)\nassert nums4 == [1]\n\nnums5 = [1, 2]\nrotate_array(nums5, 3)\nassert nums5 == [2, 1]\n\nnums6 = [1, 2, 3, 4, 5]\nrotate_array(nums6, 10)\nassert nums6 == [1, 2, 3, 4, 5]\n\n[/Example 3]", "temperature": 0.932}, {"few_shots": [{"author": "Calvin", "UUID": "48c6aa37-e00d-4b55-9afc-6b1cf2a1aff2", "question": "There are N Mice and N holes are placed in a straight line. Each hole can accommodate only 1 mouse. A mouse can stay at his position, move one step right from x to x + 1, or move one step left from x to x -1. Any of these moves consumes 1 minute. Assign mice to holes so that the time when the last mouse gets inside a hole is minimized.\nYou are given a list of mice and hole positions as integer scalers.\n", "examples": "Input: Mices = [0, 10, 2, 3], Holes = [3, 2, 23, 0]\nOutput: 13", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def assignHole(mices: list, holes: list) -> int:\n    for i,j in zip(mices,holes):\n        if i<0 or j<0:\n            return -1\n    if (len(mices) != len(holes)):\n        return -1\n    mices.sort()\n    holes.sort()\n    Max = 0\n     \n    for i in range(len(holes)):\n        if (Max < abs(mices[i] - holes[i])):\n            Max = abs(mices[i] - holes[i])\n     \n    return Max\n", "asserts": ["assert assignHole([1, 2, 3, 4], [4, 3, 2, 1]) == 0", "assert assignHole([10, 20, 30, 40], [15, 25, 35, 45]) == 5", "assert assignHole([1, 4, 9, 15], [10, 13, 7, 20]) == 6", "assert assignHole([0], [0]) == 0", "assert assignHole([1, 2], [3]) == -1  # Edge case with non-equal amount of mice and holes", "assert assignHole([5, 5, 5], [5, 5, 5]) == 0  # Edge case with all mice and holes at the same position", "assert assignHole([10, 10, 10, 10], [10, 9, 8, 7]) == 3  # Edge case with multiple mice starting at the same position", "assert assignHole([1,1 ,1, 1, 1, 1, 1, 1, 1, 1], [2,2,2,2,2,2 ,2, 2, 2, 2]) == 1 # Edge case with multiple mice and holes at the same positions", "assert assignHole([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == 1 # Edge case with incremental positions"]}, {"author": "Calvin", "UUID": "1aeb3246-4c22-4d34-a48c-db7be8ba1b94", "question": "You are given n activities with their start and finish times. Select the maximum number of activities that can be performed by a single person and return their indexes. Assume that a person can only work on a single activity at a time. \n", "examples": "Input: start  =  {10, 12, 20}, finish =  {20, 25, 30}\nOutput: [0, 2]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "import numpy as np\ndef MaxActivities(s: list, f: list) -> list:\n    indices = np.argsort(f)\n    [s[i] for i in indices]\n    [f[i] for i in indices]\n    result = []\n    n = len(f)\n    i = 0\n    result.append(i)\n    for j in range(1, n):\n        if s[j] >= f[i]:\n            result.append(j)\n            i = j\n    return result\n", "asserts": ["assert MaxActivities([2, 4, 5, 6, 7, 8], [3, 5, 6, 7, 9, 10]) == [0, 1, 2, 3, 4]", "assert MaxActivities([1, 3, 0, 5, 8, 5], [2, 4, 6, 7, 9, 9]) == [0, 1, 3, 4]", "assert MaxActivities([1], [2]) == [0]"]}], "category": "Array", "prompt_tokens": 1068, "total_tokens": 1578, "completion_tokens": 510, "completion": "Given an array of integers where each element represents the max number of steps that can be jumped going forward from that element, write a function to return the minimum number of jumps to reach the end of the array (starting from the first element). If an element is 0, then you cannot move through that element. If it's not possible to reach the end of the array, return -1.\n\n\n###Code: \n\ndef minJumps(arr: list) -> int:\n    n = len(arr)\n    if n == 0 or arr[0] == 0:\n        return -1\n    \n    jumps = [float('inf')] * n\n    jumps[0] = 0\n    \n    for i in range(1, n):\n        for j in range(i):\n            if i <= j + arr[j] and jumps[j] != float('inf'):\n                jumps[i] = min(jumps[i], jumps[j] + 1)\n                break\n    \n    return jumps[n-1] if jumps[n-1] != float('inf') else -1\n\n\n###Testcases: \n\nassert minJumps([1, 3, 5, 8, 9, 2, 6, 7, 6, 8, 9]) == 3\nassert minJumps([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]) == 10\nassert minJumps([0, 2, 3, 1, 1, 2]) == -1\nassert minJumps([10, 1, 2, 3, 4, 5]) == 1\nassert minJumps([2, 3, 1, 1, 2, 4, 2, 0, 1, 1]) == 4\nassert minJumps([1, 0, 1, 0, 1]) == -1  # Edge case where jump is not possible due to 0\nassert minJumps([100, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == 1  # Edge case where a single jump can take you to the end\nassert minJumps([1]) == 0  # Edge case with only one element\n\n[/Example 3]", "temperature": 0.682}, {"few_shots": [{"author": "Calvin", "UUID": "1aeb3246-4c22-4d34-a48c-db7be8ba1b94", "question": "You are given n activities with their start and finish times. Select the maximum number of activities that can be performed by a single person and return their indexes. Assume that a person can only work on a single activity at a time. \n", "examples": "Input: start  =  {10, 12, 20}, finish =  {20, 25, 30}\nOutput: [0, 2]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "import numpy as np\ndef MaxActivities(s: list, f: list) -> list:\n    indices = np.argsort(f)\n    [s[i] for i in indices]\n    [f[i] for i in indices]\n    result = []\n    n = len(f)\n    i = 0\n    result.append(i)\n    for j in range(1, n):\n        if s[j] >= f[i]:\n            result.append(j)\n            i = j\n    return result\n", "asserts": ["assert MaxActivities([2, 4, 5, 6, 7, 8], [3, 5, 6, 7, 9, 10]) == [0, 1, 2, 3, 4]", "assert MaxActivities([1, 3, 0, 5, 8, 5], [2, 4, 6, 7, 9, 9]) == [0, 1, 3, 4]", "assert MaxActivities([1], [2]) == [0]"]}, {"author": "Calvin", "UUID": "fb94082f-4627-4f5a-b280-08d869823d70", "question": "You are given an array of people, people, which are the attributes of some people in a queue (not necessarily in order). Each people[i] = [hi, ki] represents the ith person of height hi with exactly ki other people in front who have a height greater than or equal to hi.\n\nReconstruct and return the queue that is represented by the input array people. The returned queue should be formatted as an array queue, where queue[j] = [hj, kj] is the attributes of the jth person in the queue (queue[0] is the person at the front of the queue).\n", "examples": "Input:  [[7, 0], [4, 4], [7, 1], [5, 0], [6, 1], [5, 2]]\nOutput: [[5, 0], [4, 1], [7, 0], [5, 2], [6, 1], [7, 1]]\n\nInput:  [[6, 0], [5, 0], [4, 0], [3, 2], [2, 2], [1, 4]]\nOutput: [[4, 0], [5, 0], [2, 2], [3, 2], [1, 4], [6, 0]]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "\ndef reconstructQueue(people: list) -> list:\n    output=[] \n    people.sort(key=lambda x: (-x[0], x[1]))                \n    for a in people:\n        output.insert(a[1], a)\n    \n    return output\n", "asserts": ["assert reconstructQueue([[8,1],[5,0],[6,1],[5,2],[4,4],[7,1]]) == [[5, 0], [8, 1], [5, 2], [6, 1], [4, 4], [7, 1]]", "assert reconstructQueue([[12,0], [6,3], [4,4], [9,2], [7,1]]) == [[12, 0], [7, 1], [9, 2], [6, 3], [4, 4]]", "assert reconstructQueue([[2,0], [1,1]]) == [[2, 0], [1, 1]]", "assert reconstructQueue([[3,0], [3,2], [3,1]]) == [[3, 0], [3, 1], [3, 2]]"]}], "category": "Array", "prompt_tokens": 843, "total_tokens": 1118, "completion_tokens": 275, "completion": "Given an array of integers, return a boolean indicating whether there is a triplet (a, b, c) that satisfy the condition a^2 + b^2 = c^2. The array may contain duplicate values and negative numbers.\n\n###Code: \n\ndef findPythagoreanTriplets(nums: list) -> bool:\n    squared_nums = [x*x for x in nums]\n    squared_nums.sort()\n    for i in range(len(squared_nums) - 1, 1, -1):\n        left = 0\n        right = i - 1\n        while left < right:\n            if squared_nums[left] + squared_nums[right] == squared_nums[i]:\n                return True\n            elif squared_nums[left] + squared_nums[right] < squared_nums[i]:\n                left += 1\n            else:\n                right -= 1\n    return False\n\n###Testcases:\n\nassert findPythagoreanTriplets([3, 1, 4, 6, 5]) == True\nassert findPythagoreanTriplets([10, 4, 6, 12, 5]) == True\nassert findPythagoreanTriplets([8, 16, 18, 21, 24]) == False\nassert findPythagoreanTriplets([-3, -4, -5]) == True", "temperature": 0.902}, {"few_shots": [{"author": "Calvin", "UUID": "48c6aa37-e00d-4b55-9afc-6b1cf2a1aff2", "question": "There are N Mice and N holes are placed in a straight line. Each hole can accommodate only 1 mouse. A mouse can stay at his position, move one step right from x to x + 1, or move one step left from x to x -1. Any of these moves consumes 1 minute. Assign mice to holes so that the time when the last mouse gets inside a hole is minimized.\nYou are given a list of mice and hole positions as integer scalers.\n", "examples": "Input: Mices = [0, 10, 2, 3], Holes = [3, 2, 23, 0]\nOutput: 13", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def assignHole(mices: list, holes: list) -> int:\n    for i,j in zip(mices,holes):\n        if i<0 or j<0:\n            return -1\n    if (len(mices) != len(holes)):\n        return -1\n    mices.sort()\n    holes.sort()\n    Max = 0\n     \n    for i in range(len(holes)):\n        if (Max < abs(mices[i] - holes[i])):\n            Max = abs(mices[i] - holes[i])\n     \n    return Max\n", "asserts": ["assert assignHole([1, 2, 3, 4], [4, 3, 2, 1]) == 0", "assert assignHole([10, 20, 30, 40], [15, 25, 35, 45]) == 5", "assert assignHole([1, 4, 9, 15], [10, 13, 7, 20]) == 6", "assert assignHole([0], [0]) == 0", "assert assignHole([1, 2], [3]) == -1  # Edge case with non-equal amount of mice and holes", "assert assignHole([5, 5, 5], [5, 5, 5]) == 0  # Edge case with all mice and holes at the same position", "assert assignHole([10, 10, 10, 10], [10, 9, 8, 7]) == 3  # Edge case with multiple mice starting at the same position", "assert assignHole([1,1 ,1, 1, 1, 1, 1, 1, 1, 1], [2,2,2,2,2,2 ,2, 2, 2, 2]) == 1 # Edge case with multiple mice and holes at the same positions", "assert assignHole([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == 1 # Edge case with incremental positions"]}, {"author": "Calvin", "UUID": "fb94082f-4627-4f5a-b280-08d869823d70", "question": "You are given an array of people, people, which are the attributes of some people in a queue (not necessarily in order). Each people[i] = [hi, ki] represents the ith person of height hi with exactly ki other people in front who have a height greater than or equal to hi.\n\nReconstruct and return the queue that is represented by the input array people. The returned queue should be formatted as an array queue, where queue[j] = [hj, kj] is the attributes of the jth person in the queue (queue[0] is the person at the front of the queue).\n", "examples": "Input:  [[7, 0], [4, 4], [7, 1], [5, 0], [6, 1], [5, 2]]\nOutput: [[5, 0], [4, 1], [7, 0], [5, 2], [6, 1], [7, 1]]\n\nInput:  [[6, 0], [5, 0], [4, 0], [3, 2], [2, 2], [1, 4]]\nOutput: [[4, 0], [5, 0], [2, 2], [3, 2], [1, 4], [6, 0]]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "\ndef reconstructQueue(people: list) -> list:\n    output=[] \n    people.sort(key=lambda x: (-x[0], x[1]))                \n    for a in people:\n        output.insert(a[1], a)\n    \n    return output\n", "asserts": ["assert reconstructQueue([[8,1],[5,0],[6,1],[5,2],[4,4],[7,1]]) == [[5, 0], [8, 1], [5, 2], [6, 1], [4, 4], [7, 1]]", "assert reconstructQueue([[12,0], [6,3], [4,4], [9,2], [7,1]]) == [[12, 0], [7, 1], [9, 2], [6, 3], [4, 4]]", "assert reconstructQueue([[2,0], [1,1]]) == [[2, 0], [1, 1]]", "assert reconstructQueue([[3,0], [3,2], [3,1]]) == [[3, 0], [3, 1], [3, 2]]"]}], "category": "Array", "prompt_tokens": 1164, "total_tokens": 1570, "completion_tokens": 406, "completion": "Given an array of integers `nums` and an integer `k`, return the total number of continuous subarrays whose sum equals to `k`.\n\n###Code:\n\n```python\ndef subarraySum(nums: list, k: int) -> int:\n    count = 0\n    sums = {0: 1}\n    current_sum = 0\n\n    for num in nums:\n        current_sum += num\n        count += sums.get(current_sum - k, 0)\n        sums[current_sum] = sums.get(current_sum, 0) + 1\n\n    return count\n```\n\n###Testcases:\n\n```python\nassert subarraySum([1, 1, 1], 2) == 2\nassert subarraySum([1, 2, 3], 3) == 2\nassert subarraySum([1, -1, 0], 0) == 3\nassert subarraySum([1, 2, 1, 2, 1], 3) == 4\nassert subarraySum([10, 5, 7, 1, 2, 5, 3], 15) == 4\nassert subarraySum([-1, -1, 1], 0) == 1\nassert subarraySum([3, 4, -3, -1, 6], 6) == 3\nassert subarraySum([1], 0) == 0\nassert subarraySum([], 0) == 0  # Edge case: Empty array\nassert subarraySum([1, 2, 3, 4, 5], 15) == 1  # Edge case: Entire array sums up to k\nassert subarraySum([3, 3, 3, 3, 3], 6) == 5  # Edge case: Same elements adding up to k\n```\n\n[/Example 3]", "temperature": 0.746}, {"few_shots": [{"author": "Calvin", "UUID": "9e45b73f-583d-40ab-b387-e0d1624af07b", "question": "Given two arrays return an array with the set intersection of their common elements", "examples": "Input: arr1 = [1, 2, 3, 4], arr2 = [2, 3]\nOutput: [2, 3]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def array_intersection(arr1: list, arr2: list) -> set:\n  set1 = set(arr1)\n  ret = set([x for x in arr2 if x in set1])\n  return list(ret)\n", "asserts": ["assert set(array_intersection([1,0,2,0,2,0,2,1,1,1], [2,1,0,2,0,2,2,2,1,0])) == {0,1,2}", "assert set(array_intersection([5, 6, 7, 8], [8, 9, 10, 11])) == {8}", "assert set(array_intersection([10, 20, 30], [40, 50, 60])) == set()", "assert set(array_intersection([], [1, 2, 3])) == set()", "assert set(array_intersection([-1, -2, -3], [-3, -4, -5, -6])) == {-3}", "assert set(array_intersection([9, 8, 7], [7, 8, 9, 10, 11, 12])) == {7, 8, 9}", "assert set(array_intersection(['a', 'b', 'c'], ['a', 'd', 'e', 'c'])) == {'a', 'c'}", "assert set(array_intersection(['apple', 'banana'], ['banana', 'cherry'])) == {'banana'}", "assert set(array_intersection([1.1, 2.2, 3.3], [2.2, 4.4])) == {2.2}", "assert set(array_intersection([False, True, False], [True, False, True])) == {True, False}", "assert set(array_intersection([(1, 2), (3, 4)], [(3, 4), (5, 6)])) == {(3, 4)}"]}, {"author": "Calvin", "UUID": "48c6aa37-e00d-4b55-9afc-6b1cf2a1aff2", "question": "There are N Mice and N holes are placed in a straight line. Each hole can accommodate only 1 mouse. A mouse can stay at his position, move one step right from x to x + 1, or move one step left from x to x -1. Any of these moves consumes 1 minute. Assign mice to holes so that the time when the last mouse gets inside a hole is minimized.\nYou are given a list of mice and hole positions as integer scalers.\n", "examples": "Input: Mices = [0, 10, 2, 3], Holes = [3, 2, 23, 0]\nOutput: 13", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def assignHole(mices: list, holes: list) -> int:\n    for i,j in zip(mices,holes):\n        if i<0 or j<0:\n            return -1\n    if (len(mices) != len(holes)):\n        return -1\n    mices.sort()\n    holes.sort()\n    Max = 0\n     \n    for i in range(len(holes)):\n        if (Max < abs(mices[i] - holes[i])):\n            Max = abs(mices[i] - holes[i])\n     \n    return Max\n", "asserts": ["assert assignHole([1, 2, 3, 4], [4, 3, 2, 1]) == 0", "assert assignHole([10, 20, 30, 40], [15, 25, 35, 45]) == 5", "assert assignHole([1, 4, 9, 15], [10, 13, 7, 20]) == 6", "assert assignHole([0], [0]) == 0", "assert assignHole([1, 2], [3]) == -1  # Edge case with non-equal amount of mice and holes", "assert assignHole([5, 5, 5], [5, 5, 5]) == 0  # Edge case with all mice and holes at the same position", "assert assignHole([10, 10, 10, 10], [10, 9, 8, 7]) == 3  # Edge case with multiple mice starting at the same position", "assert assignHole([1,1 ,1, 1, 1, 1, 1, 1, 1, 1], [2,2,2,2,2,2 ,2, 2, 2, 2]) == 1 # Edge case with multiple mice and holes at the same positions", "assert assignHole([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == 1 # Edge case with incremental positions"]}], "category": "Array", "prompt_tokens": 1208, "total_tokens": 1600, "completion_tokens": 392, "completion": "Write a function that takes an array of integers and returns an array of the same size, where each element is replaced with the product of all the other elements in the array except for the element at the current index.\n\n###Code: \n\ndef array_of_products(arr: list) -> list:\n    product = 1\n    zero_count = arr.count(0)\n    \n    # If there are more than one 0, all products will be 0.\n    if zero_count > 1:\n        return [0] * len(arr)\n    \n    # Calculate the product of all non-zero numbers.\n    for num in arr:\n        if num != 0:\n            product *= num\n    \n    # If there is one zero, all positions except the zero position will be 0.\n    if zero_count == 1:\n        return [product if num == 0 else 0 for num in arr]\n    \n    # Populate result array with the product divided by the current element.\n    return [product // num for num in arr]\n\n###Testcases: \n\nassert array_of_products([1, 2, 3, 4]) == [24, 12, 8, 6]\nassert array_of_products([0, 1, 2, 3, 4]) == [24, 0, 0, 0, 0]\nassert array_of_products([-1, 1, -2, 2]) == [-4, 4, -2, 2]\nassert array_of_products([0, 0, 0]) == [0, 0, 0]\nassert array_of_products([2, 5]) == [5, 2]\nassert array_of_products([1, 1, 1, 1]) == [1, 1, 1, 1]\nassert array_of_products([10]) == [1]\n\n[/Example 3]", "temperature": 0.863}, {"few_shots": [{"author": "Calvin", "UUID": "9e45b73f-583d-40ab-b387-e0d1624af07b", "question": "Given two arrays return an array with the set intersection of their common elements", "examples": "Input: arr1 = [1, 2, 3, 4], arr2 = [2, 3]\nOutput: [2, 3]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def array_intersection(arr1: list, arr2: list) -> set:\n  set1 = set(arr1)\n  ret = set([x for x in arr2 if x in set1])\n  return list(ret)\n", "asserts": ["assert set(array_intersection([1,0,2,0,2,0,2,1,1,1], [2,1,0,2,0,2,2,2,1,0])) == {0,1,2}", "assert set(array_intersection([5, 6, 7, 8], [8, 9, 10, 11])) == {8}", "assert set(array_intersection([10, 20, 30], [40, 50, 60])) == set()", "assert set(array_intersection([], [1, 2, 3])) == set()", "assert set(array_intersection([-1, -2, -3], [-3, -4, -5, -6])) == {-3}", "assert set(array_intersection([9, 8, 7], [7, 8, 9, 10, 11, 12])) == {7, 8, 9}", "assert set(array_intersection(['a', 'b', 'c'], ['a', 'd', 'e', 'c'])) == {'a', 'c'}", "assert set(array_intersection(['apple', 'banana'], ['banana', 'cherry'])) == {'banana'}", "assert set(array_intersection([1.1, 2.2, 3.3], [2.2, 4.4])) == {2.2}", "assert set(array_intersection([False, True, False], [True, False, True])) == {True, False}", "assert set(array_intersection([(1, 2), (3, 4)], [(3, 4), (5, 6)])) == {(3, 4)}"]}, {"author": "Calvin", "UUID": "fb94082f-4627-4f5a-b280-08d869823d70", "question": "You are given an array of people, people, which are the attributes of some people in a queue (not necessarily in order). Each people[i] = [hi, ki] represents the ith person of height hi with exactly ki other people in front who have a height greater than or equal to hi.\n\nReconstruct and return the queue that is represented by the input array people. The returned queue should be formatted as an array queue, where queue[j] = [hj, kj] is the attributes of the jth person in the queue (queue[0] is the person at the front of the queue).\n", "examples": "Input:  [[7, 0], [4, 4], [7, 1], [5, 0], [6, 1], [5, 2]]\nOutput: [[5, 0], [4, 1], [7, 0], [5, 2], [6, 1], [7, 1]]\n\nInput:  [[6, 0], [5, 0], [4, 0], [3, 2], [2, 2], [1, 4]]\nOutput: [[4, 0], [5, 0], [2, 2], [3, 2], [1, 4], [6, 0]]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "\ndef reconstructQueue(people: list) -> list:\n    output=[] \n    people.sort(key=lambda x: (-x[0], x[1]))                \n    for a in people:\n        output.insert(a[1], a)\n    \n    return output\n", "asserts": ["assert reconstructQueue([[8,1],[5,0],[6,1],[5,2],[4,4],[7,1]]) == [[5, 0], [8, 1], [5, 2], [6, 1], [4, 4], [7, 1]]", "assert reconstructQueue([[12,0], [6,3], [4,4], [9,2], [7,1]]) == [[12, 0], [7, 1], [9, 2], [6, 3], [4, 4]]", "assert reconstructQueue([[2,0], [1,1]]) == [[2, 0], [1, 1]]", "assert reconstructQueue([[3,0], [3,2], [3,1]]) == [[3, 0], [3, 1], [3, 2]]"]}], "category": "Array", "prompt_tokens": 983, "total_tokens": 1222, "completion_tokens": 239, "completion": "Write a function that takes an array of integers and returns an array of integers where each number has been multiplied by its index in the original array.\n\n### Code:\n```python\ndef multiply_by_index(arr: list) -> list:\n    return [num * i for i, num in enumerate(arr)]\n```\n\n### Testcases:\n```python\nassert multiply_by_index([1, 2, 3, 4, 5]) == [0, 2, 6, 12, 20]\nassert multiply_by_index([0, 0, 0, 0, 0]) == [0, 0, 0, 0, 0]\nassert multiply_by_index([-1, -2, -3, -4, -5]) == [0, -2, -6, -12, -20]\nassert multiply_by_index([2, 6, 7]) == [0, 6, 14]\nassert multiply_by_index([100, 1, 2, 3, 0]) == [0, 1, 4, 9, 0]\n```\n\n[/Example 3]", "temperature": 0.88}, {"few_shots": [{"author": "Calvin", "UUID": "9e45b73f-583d-40ab-b387-e0d1624af07b", "question": "Given two arrays return an array with the set intersection of their common elements", "examples": "Input: arr1 = [1, 2, 3, 4], arr2 = [2, 3]\nOutput: [2, 3]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def array_intersection(arr1: list, arr2: list) -> set:\n  set1 = set(arr1)\n  ret = set([x for x in arr2 if x in set1])\n  return list(ret)\n", "asserts": ["assert set(array_intersection([1,0,2,0,2,0,2,1,1,1], [2,1,0,2,0,2,2,2,1,0])) == {0,1,2}", "assert set(array_intersection([5, 6, 7, 8], [8, 9, 10, 11])) == {8}", "assert set(array_intersection([10, 20, 30], [40, 50, 60])) == set()", "assert set(array_intersection([], [1, 2, 3])) == set()", "assert set(array_intersection([-1, -2, -3], [-3, -4, -5, -6])) == {-3}", "assert set(array_intersection([9, 8, 7], [7, 8, 9, 10, 11, 12])) == {7, 8, 9}", "assert set(array_intersection(['a', 'b', 'c'], ['a', 'd', 'e', 'c'])) == {'a', 'c'}", "assert set(array_intersection(['apple', 'banana'], ['banana', 'cherry'])) == {'banana'}", "assert set(array_intersection([1.1, 2.2, 3.3], [2.2, 4.4])) == {2.2}", "assert set(array_intersection([False, True, False], [True, False, True])) == {True, False}", "assert set(array_intersection([(1, 2), (3, 4)], [(3, 4), (5, 6)])) == {(3, 4)}"]}, {"author": "Calvin", "UUID": "fb94082f-4627-4f5a-b280-08d869823d70", "question": "You are given an array of people, people, which are the attributes of some people in a queue (not necessarily in order). Each people[i] = [hi, ki] represents the ith person of height hi with exactly ki other people in front who have a height greater than or equal to hi.\n\nReconstruct and return the queue that is represented by the input array people. The returned queue should be formatted as an array queue, where queue[j] = [hj, kj] is the attributes of the jth person in the queue (queue[0] is the person at the front of the queue).\n", "examples": "Input:  [[7, 0], [4, 4], [7, 1], [5, 0], [6, 1], [5, 2]]\nOutput: [[5, 0], [4, 1], [7, 0], [5, 2], [6, 1], [7, 1]]\n\nInput:  [[6, 0], [5, 0], [4, 0], [3, 2], [2, 2], [1, 4]]\nOutput: [[4, 0], [5, 0], [2, 2], [3, 2], [1, 4], [6, 0]]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "\ndef reconstructQueue(people: list) -> list:\n    output=[] \n    people.sort(key=lambda x: (-x[0], x[1]))                \n    for a in people:\n        output.insert(a[1], a)\n    \n    return output\n", "asserts": ["assert reconstructQueue([[8,1],[5,0],[6,1],[5,2],[4,4],[7,1]]) == [[5, 0], [8, 1], [5, 2], [6, 1], [4, 4], [7, 1]]", "assert reconstructQueue([[12,0], [6,3], [4,4], [9,2], [7,1]]) == [[12, 0], [7, 1], [9, 2], [6, 3], [4, 4]]", "assert reconstructQueue([[2,0], [1,1]]) == [[2, 0], [1, 1]]", "assert reconstructQueue([[3,0], [3,2], [3,1]]) == [[3, 0], [3, 1], [3, 2]]"]}], "category": "Array", "prompt_tokens": 983, "total_tokens": 1175, "completion_tokens": 192, "completion": "Given an array of integers, find if the array contains any duplicates. Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct.\n\n###Code:\n\n```python\ndef containsDuplicate(nums: list) -> bool:\n    return len(nums) != len(set(nums))\n```\n\n###Testcases:\n\n```python\nassert containsDuplicate([1,2,3,1]) == True\nassert containsDuplicate([1,2,3,4]) == False\nassert containsDuplicate([1,1,1,3,3,4,3,2,4,2]) == True\nassert containsDuplicate([]) == False\nassert containsDuplicate([-1, -2, -3, -4, -1]) == True\nassert containsDuplicate([int(i) for i in range(10000)] + [9999]) == True\n```\n\n[/Example 3]", "temperature": 0.839}, {"few_shots": [{"author": "Calvin", "UUID": "a9c5e697-af5d-432b-8447-5675d739c728", "question": "Given an array reorder it so that even numbers appear first", "examples": "Input: [1,2,3,4,5,6,7,8,9]\r\nOutput: [8,2,6,4,5,7,3,9,1]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def even_odd_reorder(arr: list) -> list:\n  nextEven = 0\n  nextOdd = len(arr) - 1\n  while nextEven < nextOdd:\n    if arr[nextEven] % 2 == 0:\n      nextEven += 1\n    else:\n      temp = arr[nextEven]\n      arr[nextEven] = arr[nextOdd]\n      arr[nextOdd] = temp\n      nextOdd -= 1\n  return arr\n", "asserts": ["assert even_odd_reorder([1,2,3,4,5,6,7,8,9]) == [8, 2, 6, 4, 5, 7, 3, 9, 1]", "assert even_odd_reorder([]) == []", "assert even_odd_reorder([2, 4, 6, 8]) == [2, 4, 6, 8]", "assert even_odd_reorder([7, 9, 2]) == [2, 9, 7]", "assert even_odd_reorder([10, 13, 17, 16, 15, 12]) == [10, 12, 16, 15, 17, 13]"]}, {"author": "Calvin", "UUID": "9e45b73f-583d-40ab-b387-e0d1624af07b", "question": "Given two arrays return an array with the set intersection of their common elements", "examples": "Input: arr1 = [1, 2, 3, 4], arr2 = [2, 3]\nOutput: [2, 3]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def array_intersection(arr1: list, arr2: list) -> set:\n  set1 = set(arr1)\n  ret = set([x for x in arr2 if x in set1])\n  return list(ret)\n", "asserts": ["assert set(array_intersection([1,0,2,0,2,0,2,1,1,1], [2,1,0,2,0,2,2,2,1,0])) == {0,1,2}", "assert set(array_intersection([5, 6, 7, 8], [8, 9, 10, 11])) == {8}", "assert set(array_intersection([10, 20, 30], [40, 50, 60])) == set()", "assert set(array_intersection([], [1, 2, 3])) == set()", "assert set(array_intersection([-1, -2, -3], [-3, -4, -5, -6])) == {-3}", "assert set(array_intersection([9, 8, 7], [7, 8, 9, 10, 11, 12])) == {7, 8, 9}", "assert set(array_intersection(['a', 'b', 'c'], ['a', 'd', 'e', 'c'])) == {'a', 'c'}", "assert set(array_intersection(['apple', 'banana'], ['banana', 'cherry'])) == {'banana'}", "assert set(array_intersection([1.1, 2.2, 3.3], [2.2, 4.4])) == {2.2}", "assert set(array_intersection([False, True, False], [True, False, True])) == {True, False}", "assert set(array_intersection([(1, 2), (3, 4)], [(3, 4), (5, 6)])) == {(3, 4)}"]}], "category": "Array", "prompt_tokens": 886, "total_tokens": 1302, "completion_tokens": 416, "completion": "Given an array of integers, return the maximum sum of a subsequence of the array such that the integers in the subsequence are sorted in strictly increasing order.\n\n###Code:\n\n```python\ndef max_sum_increasing_subsequence(arr: list) -> int:\n    if not arr:\n        return 0\n    dp = arr[:]\n    for i in range(1, len(arr)):\n        for j in range(i):\n            if arr[i] > arr[j]:\n                dp[i] = max(dp[i], dp[j] + arr[i])\n    return max(dp)\n\n```\n\n###Testcases:\n\n```python\nassert max_sum_increasing_subsequence([10, 70, 20, 30, 50, 11, 30]) == 110\nassert max_sum_increasing_subsequence([1, 101, 2, 3, 100, 4, 5]) == 106\nassert max_sum_increasing_subsequence([3, 4, 5, 10]) == 22\nassert max_sum_increasing_subsequence([10, 5, 4, 3]) == 10\nassert max_sum_increasing_subsequence([]) == 0\nassert max_sum_increasing_subsequence([3]) == 3\nassert max_sum_increasing_subsequence([-1, -2, -3, -50]) == -1\nassert max_sum_increasing_subsequence([5, 4, 3, 2, 1, 101]) == 101\nassert max_sum_increasing_subsequence([8, 12, 2, 3, 15, 5, 7]) == 35\nassert max_sum_increasing_subsequence([1, 2, 3, 0, 1, 2, 3, 4, 5]) == 15\nassert max_sum_increasing_subsequence([3, 2, 6, 4, 5]) == 12\n```\n\n[/Example 3]", "temperature": 0.911}, {"few_shots": [{"author": "Calvin", "UUID": "a9c5e697-af5d-432b-8447-5675d739c728", "question": "Given an array reorder it so that even numbers appear first", "examples": "Input: [1,2,3,4,5,6,7,8,9]\r\nOutput: [8,2,6,4,5,7,3,9,1]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def even_odd_reorder(arr: list) -> list:\n  nextEven = 0\n  nextOdd = len(arr) - 1\n  while nextEven < nextOdd:\n    if arr[nextEven] % 2 == 0:\n      nextEven += 1\n    else:\n      temp = arr[nextEven]\n      arr[nextEven] = arr[nextOdd]\n      arr[nextOdd] = temp\n      nextOdd -= 1\n  return arr\n", "asserts": ["assert even_odd_reorder([1,2,3,4,5,6,7,8,9]) == [8, 2, 6, 4, 5, 7, 3, 9, 1]", "assert even_odd_reorder([]) == []", "assert even_odd_reorder([2, 4, 6, 8]) == [2, 4, 6, 8]", "assert even_odd_reorder([7, 9, 2]) == [2, 9, 7]", "assert even_odd_reorder([10, 13, 17, 16, 15, 12]) == [10, 12, 16, 15, 17, 13]"]}, {"author": "Calvin", "UUID": "fb94082f-4627-4f5a-b280-08d869823d70", "question": "You are given an array of people, people, which are the attributes of some people in a queue (not necessarily in order). Each people[i] = [hi, ki] represents the ith person of height hi with exactly ki other people in front who have a height greater than or equal to hi.\n\nReconstruct and return the queue that is represented by the input array people. The returned queue should be formatted as an array queue, where queue[j] = [hj, kj] is the attributes of the jth person in the queue (queue[0] is the person at the front of the queue).\n", "examples": "Input:  [[7, 0], [4, 4], [7, 1], [5, 0], [6, 1], [5, 2]]\nOutput: [[5, 0], [4, 1], [7, 0], [5, 2], [6, 1], [7, 1]]\n\nInput:  [[6, 0], [5, 0], [4, 0], [3, 2], [2, 2], [1, 4]]\nOutput: [[4, 0], [5, 0], [2, 2], [3, 2], [1, 4], [6, 0]]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "\ndef reconstructQueue(people: list) -> list:\n    output=[] \n    people.sort(key=lambda x: (-x[0], x[1]))                \n    for a in people:\n        output.insert(a[1], a)\n    \n    return output\n", "asserts": ["assert reconstructQueue([[8,1],[5,0],[6,1],[5,2],[4,4],[7,1]]) == [[5, 0], [8, 1], [5, 2], [6, 1], [4, 4], [7, 1]]", "assert reconstructQueue([[12,0], [6,3], [4,4], [9,2], [7,1]]) == [[12, 0], [7, 1], [9, 2], [6, 3], [4, 4]]", "assert reconstructQueue([[2,0], [1,1]]) == [[2, 0], [1, 1]]", "assert reconstructQueue([[3,0], [3,2], [3,1]]) == [[3, 0], [3, 1], [3, 2]]"]}], "category": "Array", "prompt_tokens": 842, "total_tokens": 1069, "completion_tokens": 227, "completion": "Write a function that takes an array of integers and returns the length of the longest increasing subsequence.\n\n###Code: \n\ndef lengthOfLIS(nums: list) -> int:\n    if not nums:\n        return 0\n    \n    LIS = [1] * len(nums)\n\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                LIS[i] = max(LIS[i], LIS[j] + 1)\n\n    return max(LIS)\n\n###Testcases: \n\nassert lengthOfLIS([10,9,2,5,3,7,101,18]) == 4\nassert lengthOfLIS([0,1,0,3,2,3]) == 4\nassert lengthOfLIS([7,7,7,7,7,7,7]) == 1\nassert lengthOfLIS([1,3,6,7,9,4,10,5,6]) == 6\nassert lengthOfLIS([]) == 0\n\n[/Example 3]", "temperature": 0.786}, {"few_shots": [{"author": "Calvin", "UUID": "9e45b73f-583d-40ab-b387-e0d1624af07b", "question": "Given two arrays return an array with the set intersection of their common elements", "examples": "Input: arr1 = [1, 2, 3, 4], arr2 = [2, 3]\nOutput: [2, 3]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def array_intersection(arr1: list, arr2: list) -> set:\n  set1 = set(arr1)\n  ret = set([x for x in arr2 if x in set1])\n  return list(ret)\n", "asserts": ["assert set(array_intersection([1,0,2,0,2,0,2,1,1,1], [2,1,0,2,0,2,2,2,1,0])) == {0,1,2}", "assert set(array_intersection([5, 6, 7, 8], [8, 9, 10, 11])) == {8}", "assert set(array_intersection([10, 20, 30], [40, 50, 60])) == set()", "assert set(array_intersection([], [1, 2, 3])) == set()", "assert set(array_intersection([-1, -2, -3], [-3, -4, -5, -6])) == {-3}", "assert set(array_intersection([9, 8, 7], [7, 8, 9, 10, 11, 12])) == {7, 8, 9}", "assert set(array_intersection(['a', 'b', 'c'], ['a', 'd', 'e', 'c'])) == {'a', 'c'}", "assert set(array_intersection(['apple', 'banana'], ['banana', 'cherry'])) == {'banana'}", "assert set(array_intersection([1.1, 2.2, 3.3], [2.2, 4.4])) == {2.2}", "assert set(array_intersection([False, True, False], [True, False, True])) == {True, False}", "assert set(array_intersection([(1, 2), (3, 4)], [(3, 4), (5, 6)])) == {(3, 4)}"]}, {"author": "Calvin", "UUID": "48c6aa37-e00d-4b55-9afc-6b1cf2a1aff2", "question": "There are N Mice and N holes are placed in a straight line. Each hole can accommodate only 1 mouse. A mouse can stay at his position, move one step right from x to x + 1, or move one step left from x to x -1. Any of these moves consumes 1 minute. Assign mice to holes so that the time when the last mouse gets inside a hole is minimized.\nYou are given a list of mice and hole positions as integer scalers.\n", "examples": "Input: Mices = [0, 10, 2, 3], Holes = [3, 2, 23, 0]\nOutput: 13", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def assignHole(mices: list, holes: list) -> int:\n    for i,j in zip(mices,holes):\n        if i<0 or j<0:\n            return -1\n    if (len(mices) != len(holes)):\n        return -1\n    mices.sort()\n    holes.sort()\n    Max = 0\n     \n    for i in range(len(holes)):\n        if (Max < abs(mices[i] - holes[i])):\n            Max = abs(mices[i] - holes[i])\n     \n    return Max\n", "asserts": ["assert assignHole([1, 2, 3, 4], [4, 3, 2, 1]) == 0", "assert assignHole([10, 20, 30, 40], [15, 25, 35, 45]) == 5", "assert assignHole([1, 4, 9, 15], [10, 13, 7, 20]) == 6", "assert assignHole([0], [0]) == 0", "assert assignHole([1, 2], [3]) == -1  # Edge case with non-equal amount of mice and holes", "assert assignHole([5, 5, 5], [5, 5, 5]) == 0  # Edge case with all mice and holes at the same position", "assert assignHole([10, 10, 10, 10], [10, 9, 8, 7]) == 3  # Edge case with multiple mice starting at the same position", "assert assignHole([1,1 ,1, 1, 1, 1, 1, 1, 1, 1], [2,2,2,2,2,2 ,2, 2, 2, 2]) == 1 # Edge case with multiple mice and holes at the same positions", "assert assignHole([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == 1 # Edge case with incremental positions"]}], "category": "Array", "prompt_tokens": 1208, "total_tokens": 1627, "completion_tokens": 419, "completion": "Write a function to find the maximum profit you can achieve from exactly two non-overlapping transactions on a given list of stock prices. Each transaction consists of buying and selling one share of the stock. There is a need to sell the stock before you buy it again.\n\n###Code: \n\ndef maxProfit(prices: list) -> int:\n    if not prices:\n        return 0\n        \n    # Initialize variables\n    first_buy, first_sell, second_buy, second_sell = float('-inf'), 0, float('-inf'), 0\n    \n    for price in prices:\n        first_buy = max(first_buy, -price)  # The max profit after you buy first stock\n        first_sell = max(first_sell, first_buy + price)  # The max profit after you sell it\n        second_buy = max(second_buy, first_sell - price)  # The max profit after you buy the second stock\n        second_sell = max(second_sell, second_buy + price)  # The max profit after you sell the second stock\n\n    return second_sell\n\n###Testcases: \n\nassert maxProfit([3,3,5,0,0,3,1,4]) == 6\nassert maxProfit([1,2,3,4,5]) == 4\nassert maxProfit([7,6,4,3,1]) == 0\nassert maxProfit([1]) == 0\nassert maxProfit([1,2,4,2,5,7,2,4,9,0]) == 13\nassert maxProfit([6,1,3,2,4,7]) == 7\nassert maxProfit([]) == 0\nassert maxProfit([0,20,10,20,0]) == 30\nassert maxProfit([100, 180, 260, 310, 40, 535, 695]) == 865\nassert maxProfit([10,22,5,75,65,80]) == 87\n\n[/Example 3]", "temperature": 0.859}, {"few_shots": [{"author": "Calvin", "UUID": "48c6aa37-e00d-4b55-9afc-6b1cf2a1aff2", "question": "There are N Mice and N holes are placed in a straight line. Each hole can accommodate only 1 mouse. A mouse can stay at his position, move one step right from x to x + 1, or move one step left from x to x -1. Any of these moves consumes 1 minute. Assign mice to holes so that the time when the last mouse gets inside a hole is minimized.\nYou are given a list of mice and hole positions as integer scalers.\n", "examples": "Input: Mices = [0, 10, 2, 3], Holes = [3, 2, 23, 0]\nOutput: 13", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def assignHole(mices: list, holes: list) -> int:\n    for i,j in zip(mices,holes):\n        if i<0 or j<0:\n            return -1\n    if (len(mices) != len(holes)):\n        return -1\n    mices.sort()\n    holes.sort()\n    Max = 0\n     \n    for i in range(len(holes)):\n        if (Max < abs(mices[i] - holes[i])):\n            Max = abs(mices[i] - holes[i])\n     \n    return Max\n", "asserts": ["assert assignHole([1, 2, 3, 4], [4, 3, 2, 1]) == 0", "assert assignHole([10, 20, 30, 40], [15, 25, 35, 45]) == 5", "assert assignHole([1, 4, 9, 15], [10, 13, 7, 20]) == 6", "assert assignHole([0], [0]) == 0", "assert assignHole([1, 2], [3]) == -1  # Edge case with non-equal amount of mice and holes", "assert assignHole([5, 5, 5], [5, 5, 5]) == 0  # Edge case with all mice and holes at the same position", "assert assignHole([10, 10, 10, 10], [10, 9, 8, 7]) == 3  # Edge case with multiple mice starting at the same position", "assert assignHole([1,1 ,1, 1, 1, 1, 1, 1, 1, 1], [2,2,2,2,2,2 ,2, 2, 2, 2]) == 1 # Edge case with multiple mice and holes at the same positions", "assert assignHole([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == 1 # Edge case with incremental positions"]}, {"author": "Calvin", "UUID": "fb94082f-4627-4f5a-b280-08d869823d70", "question": "You are given an array of people, people, which are the attributes of some people in a queue (not necessarily in order). Each people[i] = [hi, ki] represents the ith person of height hi with exactly ki other people in front who have a height greater than or equal to hi.\n\nReconstruct and return the queue that is represented by the input array people. The returned queue should be formatted as an array queue, where queue[j] = [hj, kj] is the attributes of the jth person in the queue (queue[0] is the person at the front of the queue).\n", "examples": "Input:  [[7, 0], [4, 4], [7, 1], [5, 0], [6, 1], [5, 2]]\nOutput: [[5, 0], [4, 1], [7, 0], [5, 2], [6, 1], [7, 1]]\n\nInput:  [[6, 0], [5, 0], [4, 0], [3, 2], [2, 2], [1, 4]]\nOutput: [[4, 0], [5, 0], [2, 2], [3, 2], [1, 4], [6, 0]]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "\ndef reconstructQueue(people: list) -> list:\n    output=[] \n    people.sort(key=lambda x: (-x[0], x[1]))                \n    for a in people:\n        output.insert(a[1], a)\n    \n    return output\n", "asserts": ["assert reconstructQueue([[8,1],[5,0],[6,1],[5,2],[4,4],[7,1]]) == [[5, 0], [8, 1], [5, 2], [6, 1], [4, 4], [7, 1]]", "assert reconstructQueue([[12,0], [6,3], [4,4], [9,2], [7,1]]) == [[12, 0], [7, 1], [9, 2], [6, 3], [4, 4]]", "assert reconstructQueue([[2,0], [1,1]]) == [[2, 0], [1, 1]]", "assert reconstructQueue([[3,0], [3,2], [3,1]]) == [[3, 0], [3, 1], [3, 2]]"]}], "category": "Array", "prompt_tokens": 1164, "total_tokens": 1655, "completion_tokens": 491, "completion": "Write a function to merge two sorted arrays such that the resulting array is also sorted. The first array has exactly enough empty spaces (represented by zeros) at the end to hold the elements of the second array. You are not allowed to use any extra space (i.e., no additional array or data structure).\n\n###Code: \n\ndef mergeSortedArrays(nums1: list, m: int, nums2: list, n: int) -> None:\n    while m > 0 and n > 0:\n        if nums1[m - 1] > nums2[n - 1]:\n            nums1[m + n - 1] = nums1[m - 1]\n            m -= 1\n        else:\n            nums1[m + n - 1] = nums2[n - 1]\n            n -= 1\n    nums1[:n] = nums2[:n]\n\n###Testcases: \n\nassert mergeSortedArrays([1,2,3,0,0,0], 3, [2,5,6], 3) == None and [1,2,2,3,5,6] == [1,2,2,3,5,6]\nassert mergeSortedArrays([1,0], 1, [2], 1) == None and [1,2] == [1,2]\nassert mergeSortedArrays([0], 0, [1], 1) == None and [1] == [1]\nassert mergeSortedArrays([2,3,5,0,0,0], 3, [1,4,6], 3) == None and [1,2,3,4,5,6] == [1,2,3,4,5,6]\nassert mergeSortedArrays([10,20,30,0,0,0], 3, [11,21,31], 3) == None and [10,11,20,21,30,31] == [10,11,20,21,30,31]\nassert mergeSortedArrays([4,5,6,0,0,0], 3, [1,2,3], 3) == None and [1,2,3,4,5,6] == [1,2,3,4,5,6]\n\n[/Example 3]", "temperature": 0.834}, {"few_shots": [{"author": "Calvin", "UUID": "fb94082f-4627-4f5a-b280-08d869823d70", "question": "You are given an array of people, people, which are the attributes of some people in a queue (not necessarily in order). Each people[i] = [hi, ki] represents the ith person of height hi with exactly ki other people in front who have a height greater than or equal to hi.\n\nReconstruct and return the queue that is represented by the input array people. The returned queue should be formatted as an array queue, where queue[j] = [hj, kj] is the attributes of the jth person in the queue (queue[0] is the person at the front of the queue).\n", "examples": "Input:  [[7, 0], [4, 4], [7, 1], [5, 0], [6, 1], [5, 2]]\nOutput: [[5, 0], [4, 1], [7, 0], [5, 2], [6, 1], [7, 1]]\n\nInput:  [[6, 0], [5, 0], [4, 0], [3, 2], [2, 2], [1, 4]]\nOutput: [[4, 0], [5, 0], [2, 2], [3, 2], [1, 4], [6, 0]]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "\ndef reconstructQueue(people: list) -> list:\n    output=[] \n    people.sort(key=lambda x: (-x[0], x[1]))                \n    for a in people:\n        output.insert(a[1], a)\n    \n    return output\n", "asserts": ["assert reconstructQueue([[8,1],[5,0],[6,1],[5,2],[4,4],[7,1]]) == [[5, 0], [8, 1], [5, 2], [6, 1], [4, 4], [7, 1]]", "assert reconstructQueue([[12,0], [6,3], [4,4], [9,2], [7,1]]) == [[12, 0], [7, 1], [9, 2], [6, 3], [4, 4]]", "assert reconstructQueue([[2,0], [1,1]]) == [[2, 0], [1, 1]]", "assert reconstructQueue([[3,0], [3,2], [3,1]]) == [[3, 0], [3, 1], [3, 2]]"]}, {"author": "Calvin", "UUID": "a9c5e697-af5d-432b-8447-5675d739c728", "question": "Given an array reorder it so that even numbers appear first", "examples": "Input: [1,2,3,4,5,6,7,8,9]\r\nOutput: [8,2,6,4,5,7,3,9,1]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def even_odd_reorder(arr: list) -> list:\n  nextEven = 0\n  nextOdd = len(arr) - 1\n  while nextEven < nextOdd:\n    if arr[nextEven] % 2 == 0:\n      nextEven += 1\n    else:\n      temp = arr[nextEven]\n      arr[nextEven] = arr[nextOdd]\n      arr[nextOdd] = temp\n      nextOdd -= 1\n  return arr\n", "asserts": ["assert even_odd_reorder([1,2,3,4,5,6,7,8,9]) == [8, 2, 6, 4, 5, 7, 3, 9, 1]", "assert even_odd_reorder([]) == []", "assert even_odd_reorder([2, 4, 6, 8]) == [2, 4, 6, 8]", "assert even_odd_reorder([7, 9, 2]) == [2, 9, 7]", "assert even_odd_reorder([10, 13, 17, 16, 15, 12]) == [10, 12, 16, 15, 17, 13]"]}], "category": "Array", "prompt_tokens": 842, "total_tokens": 1134, "completion_tokens": 292, "completion": "Given an array of integers, return the kth smallest element in the array without sorting the entire array. The array is not necessarily sorted and k will always be within the bounds of the array.\n\n###Code:\n\n```python\nimport heapq\n\ndef kth_smallest_element(nums: list, k: int) -> int:\n    # Create a min heap from the array\n    min_heap = nums[:]\n    heapq.heapify(min_heap)\n    \n    # Extract the smallest element k-1 times\n    for _ in range(k-1):\n        heapq.heappop(min_heap)\n    \n    # The next element is the kth smallest\n    return heapq.heappop(min_heap)\n```\n\n###Testcases: \n\n```python\nassert kth_smallest_element([3, 2, 1, 5, 6, 4], 2) == 2\nassert kth_smallest_element([7, 10, 4, 3, 20, 15], 3) == 7\nassert kth_smallest_element([7, 10, 4, 3, 20, 15], 1) == 3\nassert kth_smallest_element([12, 3, 5, 7, 19], 2) == 5\nassert kth_smallest_element([1], 1) == 1\n```\n\n[/Example 3]", "temperature": 0.652}, {"few_shots": [{"author": "Calvin", "UUID": "fb94082f-4627-4f5a-b280-08d869823d70", "question": "You are given an array of people, people, which are the attributes of some people in a queue (not necessarily in order). Each people[i] = [hi, ki] represents the ith person of height hi with exactly ki other people in front who have a height greater than or equal to hi.\n\nReconstruct and return the queue that is represented by the input array people. The returned queue should be formatted as an array queue, where queue[j] = [hj, kj] is the attributes of the jth person in the queue (queue[0] is the person at the front of the queue).\n", "examples": "Input:  [[7, 0], [4, 4], [7, 1], [5, 0], [6, 1], [5, 2]]\nOutput: [[5, 0], [4, 1], [7, 0], [5, 2], [6, 1], [7, 1]]\n\nInput:  [[6, 0], [5, 0], [4, 0], [3, 2], [2, 2], [1, 4]]\nOutput: [[4, 0], [5, 0], [2, 2], [3, 2], [1, 4], [6, 0]]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "\ndef reconstructQueue(people: list) -> list:\n    output=[] \n    people.sort(key=lambda x: (-x[0], x[1]))                \n    for a in people:\n        output.insert(a[1], a)\n    \n    return output\n", "asserts": ["assert reconstructQueue([[8,1],[5,0],[6,1],[5,2],[4,4],[7,1]]) == [[5, 0], [8, 1], [5, 2], [6, 1], [4, 4], [7, 1]]", "assert reconstructQueue([[12,0], [6,3], [4,4], [9,2], [7,1]]) == [[12, 0], [7, 1], [9, 2], [6, 3], [4, 4]]", "assert reconstructQueue([[2,0], [1,1]]) == [[2, 0], [1, 1]]", "assert reconstructQueue([[3,0], [3,2], [3,1]]) == [[3, 0], [3, 1], [3, 2]]"]}, {"author": "Calvin", "UUID": "a9c5e697-af5d-432b-8447-5675d739c728", "question": "Given an array reorder it so that even numbers appear first", "examples": "Input: [1,2,3,4,5,6,7,8,9]\r\nOutput: [8,2,6,4,5,7,3,9,1]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def even_odd_reorder(arr: list) -> list:\n  nextEven = 0\n  nextOdd = len(arr) - 1\n  while nextEven < nextOdd:\n    if arr[nextEven] % 2 == 0:\n      nextEven += 1\n    else:\n      temp = arr[nextEven]\n      arr[nextEven] = arr[nextOdd]\n      arr[nextOdd] = temp\n      nextOdd -= 1\n  return arr\n", "asserts": ["assert even_odd_reorder([1,2,3,4,5,6,7,8,9]) == [8, 2, 6, 4, 5, 7, 3, 9, 1]", "assert even_odd_reorder([]) == []", "assert even_odd_reorder([2, 4, 6, 8]) == [2, 4, 6, 8]", "assert even_odd_reorder([7, 9, 2]) == [2, 9, 7]", "assert even_odd_reorder([10, 13, 17, 16, 15, 12]) == [10, 12, 16, 15, 17, 13]"]}], "category": "Array", "prompt_tokens": 842, "total_tokens": 1073, "completion_tokens": 231, "completion": "Given an array of integers, nums, and an integer value, val, remove all instances of that value in-place and return the new length of the array. Do not allocate extra space for another array. The order of elements can be changed, and it does not matter what you leave beyond the new length.\n\n###Code: \n\ndef remove_element(nums: list, val: int) -> int:\n    i = 0\n    for j in range(len(nums)):\n        if nums[j] != val:\n            nums[i] = nums[j]\n            i += 1\n    return i\n\n###Testcases: \n\nassert remove_element([3,2,2,3], 3) == 2\nassert remove_element([0,1,2,2,3,0,4,2], 2) == 5\nassert remove_element([1,1,1,1,1], 1) == 0\nassert remove_element([4,5], 4) == 1\nassert remove_element([2,2,3,3], 2) == 2\n\n[/Example 3]", "temperature": 0.77}, {"few_shots": [{"author": "Calvin", "UUID": "1aeb3246-4c22-4d34-a48c-db7be8ba1b94", "question": "You are given n activities with their start and finish times. Select the maximum number of activities that can be performed by a single person and return their indexes. Assume that a person can only work on a single activity at a time. \n", "examples": "Input: start  =  {10, 12, 20}, finish =  {20, 25, 30}\nOutput: [0, 2]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "import numpy as np\ndef MaxActivities(s: list, f: list) -> list:\n    indices = np.argsort(f)\n    [s[i] for i in indices]\n    [f[i] for i in indices]\n    result = []\n    n = len(f)\n    i = 0\n    result.append(i)\n    for j in range(1, n):\n        if s[j] >= f[i]:\n            result.append(j)\n            i = j\n    return result\n", "asserts": ["assert MaxActivities([2, 4, 5, 6, 7, 8], [3, 5, 6, 7, 9, 10]) == [0, 1, 2, 3, 4]", "assert MaxActivities([1, 3, 0, 5, 8, 5], [2, 4, 6, 7, 9, 9]) == [0, 1, 3, 4]", "assert MaxActivities([1], [2]) == [0]"]}, {"author": "Calvin", "UUID": "f795bda7-9822-4bc5-9c7e-b9c0f2752085", "question": "You are given two 0-indexed integer permutations A and B of length n.\n\nA prefix common array of A and B is an array C such that C[i] is equal to the count of numbers that are present at or before the index i in both A and B.\n\nReturn the prefix common array of A and B.\n\nA sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once.", "examples": "Input: A = [1,3,2,4], B = [3,1,2,4]\nOutput: [0,2,3,4]", "link": "https://leetcode.com/problems/find-the-prefix-common-array-of-two-arrays/", "difficulty": null, "categories": ["Array"], "code": "def findThePrefixCommonArray(arr1: list, arr2: list) -> list:\n  max = len(arr1) if len(arr1) > len(arr2) else len(arr2)\n  seen = set()\n  curCount = 0\n  ret = []\n  for i in range(max):\n    cur1 = arr1[i]\n    cur2 = arr2[i]\n    if cur1 in seen:\n      curCount += 1\n    else:\n      seen.add(cur1)\n    if cur2 in seen:\n      curCount += 1\n    else:\n      seen.add(cur2)\n    ret.append(curCount)\n  return ret\n", "asserts": ["assert findThePrefixCommonArray([1,3,2,4], [3,1,2,4]) == [0,2,3,4]", "assert findThePrefixCommonArray([1], [1]) == [1]", "assert findThePrefixCommonArray([2,3,1], [3,1,2]) == [0,1,3]"]}], "category": "Array", "prompt_tokens": 782, "total_tokens": 1023, "completion_tokens": 241, "completion": "Given an array of integers, find the length of the longest subarray where the absolute difference between any two elements is less than or equal to 1.\n\n###Code:\n\ndef longestSubarray(arr: list) -> int:\n    max_len = 1\n    arr.sort()\n    start = 0\n    for i in range(1, len(arr)):\n        if abs(arr[i] - arr[start]) > 1:\n            start = i\n        max_len = max(max_len, i - start + 1)\n    return max_len\n\n###Testcases: \n\nassert longestSubarray([1, 1, 2, 2, 4, 4, 5, 5, 5]) == 5\nassert longestSubarray([1, 2, 2, 3, 4, 4, 5, 5, 6]) == 4\nassert longestSubarray([4, 6, 5, 3, 3, 1]) == 3\nassert longestSubarray([1, 2, 3, 4, 5]) == 2\n\n[/Example 3]", "temperature": 0.762}, {"few_shots": [{"author": "Calvin", "UUID": "a9c5e697-af5d-432b-8447-5675d739c728", "question": "Given an array reorder it so that even numbers appear first", "examples": "Input: [1,2,3,4,5,6,7,8,9]\r\nOutput: [8,2,6,4,5,7,3,9,1]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def even_odd_reorder(arr: list) -> list:\n  nextEven = 0\n  nextOdd = len(arr) - 1\n  while nextEven < nextOdd:\n    if arr[nextEven] % 2 == 0:\n      nextEven += 1\n    else:\n      temp = arr[nextEven]\n      arr[nextEven] = arr[nextOdd]\n      arr[nextOdd] = temp\n      nextOdd -= 1\n  return arr\n", "asserts": ["assert even_odd_reorder([1,2,3,4,5,6,7,8,9]) == [8, 2, 6, 4, 5, 7, 3, 9, 1]", "assert even_odd_reorder([]) == []", "assert even_odd_reorder([2, 4, 6, 8]) == [2, 4, 6, 8]", "assert even_odd_reorder([7, 9, 2]) == [2, 9, 7]", "assert even_odd_reorder([10, 13, 17, 16, 15, 12]) == [10, 12, 16, 15, 17, 13]"]}, {"author": "Calvin", "UUID": "9e45b73f-583d-40ab-b387-e0d1624af07b", "question": "Given two arrays return an array with the set intersection of their common elements", "examples": "Input: arr1 = [1, 2, 3, 4], arr2 = [2, 3]\nOutput: [2, 3]", "link": NaN, "difficulty": null, "categories": ["Array"], "code": "def array_intersection(arr1: list, arr2: list) -> set:\n  set1 = set(arr1)\n  ret = set([x for x in arr2 if x in set1])\n  return list(ret)\n", "asserts": ["assert set(array_intersection([1,0,2,0,2,0,2,1,1,1], [2,1,0,2,0,2,2,2,1,0])) == {0,1,2}", "assert set(array_intersection([5, 6, 7, 8], [8, 9, 10, 11])) == {8}", "assert set(array_intersection([10, 20, 30], [40, 50, 60])) == set()", "assert set(array_intersection([], [1, 2, 3])) == set()", "assert set(array_intersection([-1, -2, -3], [-3, -4, -5, -6])) == {-3}", "assert set(array_intersection([9, 8, 7], [7, 8, 9, 10, 11, 12])) == {7, 8, 9}", "assert set(array_intersection(['a', 'b', 'c'], ['a', 'd', 'e', 'c'])) == {'a', 'c'}", "assert set(array_intersection(['apple', 'banana'], ['banana', 'cherry'])) == {'banana'}", "assert set(array_intersection([1.1, 2.2, 3.3], [2.2, 4.4])) == {2.2}", "assert set(array_intersection([False, True, False], [True, False, True])) == {True, False}", "assert set(array_intersection([(1, 2), (3, 4)], [(3, 4), (5, 6)])) == {(3, 4)}"]}], "category": "Array", "prompt_tokens": 886, "total_tokens": 1226, "completion_tokens": 340, "completion": "Given an array of integers, move all zeroes to the end of the array without changing the order of the non-zero elements.\n\n###Code: \n\ndef move_zeroes_to_end(arr: list) -> list:\n    zero_count = arr.count(0)\n    arr = [num for num in arr if num != 0]\n    arr.extend([0] * zero_count)\n    return arr\n\n###Testcases: \n\nassert move_zeroes_to_end([0, 1, 0, 3, 12]) == [1, 3, 12, 0, 0]\nassert move_zeroes_to_end([0, 0, 0, 0, 1]) == [1, 0, 0, 0, 0]\nassert move_zeroes_to_end([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]\nassert move_zeroes_to_end([]) == []\nassert move_zeroes_to_end([4, 2, 4, 0, 0, 3, 0, 5, 1, 0]) == [4, 2, 4, 3, 5, 1, 0, 0, 0, 0]\nassert move_zeroes_to_end([0, -1, 0, -3, 12]) == [-1, -3, 12, 0, 0]\nassert move_zeroes_to_end([0, 0, 1]) == [1, 0, 0]\n\n[/Example 3]", "temperature": 0.861}]