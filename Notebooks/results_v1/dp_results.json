[{"few_shots": [{"author": "Hafeez", "UUID": "38dca76c-ee6c-4c71-83a9-89240828a3b7", "question": "Best Time to Buy and Sell Stock II: You are given an integer array prices where prices[i] is the price of a given stock on the ith day.\n\nOn each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day.\n\nFind and return the maximum profit you can achieve.", "examples": "Input: prices = [7,1,5,3,6,4]\nOutput: 7\nExplanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\nThen buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.\nTotal profit is 4 + 3 = 7.\nInput: prices = [7,6,4,3,1]\nOutput: 0\nExplanation: There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0.", "link": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/", "difficulty": "Medium", "categories": ["Dynamic_programming"], "code": "from typing import List\ndef maxProfit(prices: List[int]) -> int:\n    cur_hold, cur_not_hold = -float('inf'), 0\n    \n    for stock_price in prices:\n        \n        prev_hold, prev_not_hold = cur_hold, cur_not_hold\n        cur_hold = max( prev_hold, prev_not_hold - stock_price )\n        cur_not_hold = max( prev_not_hold, prev_hold + stock_price )\n    return cur_not_hold", "asserts": ["assert maxProfit([1,2,3,4,5])==4", "assert maxProfit([1,2,100,2,1]) == 99"]}, {"author": "Hafeez", "UUID": "6aaf1310-7585-4d90-91e7-1f405c9b25e7", "question": "Get Maximum in Generated Array: You are given an integer n. A 0-indexed integer array nums of length n + 1 is generated in the following way:\n\nnums[0] = 0\nnums[1] = 1\nnums[2 * i] = nums[i] when 2 <= 2 * i <= n\nnums[2 * i + 1] = nums[i] + nums[i + 1] when 2 <= 2 * i + 1 <= n\nReturn the maximum integer in the array nums\u200b\u200b\u200b.", "examples": "Input: n = 7\nOutput: 3\nExplanation: According to the given rules:\n  nums[0] = 0\n  nums[1] = 1\n  nums[(1 * 2) = 2] = nums[1] = 1\n  nums[(1 * 2) + 1 = 3] = nums[1] + nums[2] = 1 + 1 = 2\n  nums[(2 * 2) = 4] = nums[2] = 1\n  nums[(2 * 2) + 1 = 5] = nums[2] + nums[3] = 1 + 2 = 3\n  nums[(3 * 2) = 6] = nums[3] = 2\n  nums[(3 * 2) + 1 = 7] = nums[3] + nums[4] = 2 + 1 = 3\nHence, nums = [0,1,1,2,1,3,2,3], and the maximum is max(0,1,1,2,1,3,2,3) = 3.\nInput: n = 2\nOutput: 1\nExplanation: According to the given rules, nums = [0,1,1]. The maximum is max(0,1,1) = 1.\nInput: n = 3\nOutput: 2\nExplanation: According to the given rules, nums = [0,1,1,2]. The maximum is max(0,1,1,2) = 2.", "link": "https://leetcode.com/problems/get-maximum-in-generated-array/", "difficulty": "Easy", "categories": ["Dynamic_programming"], "code": "def getMaximumGenerated(n: int) -> int:\n    if n<2:\n        return n\n    nums=[0]*(n+1)\n    nums[0]=0\n    nums[1]=1\n    for i in range(2,n+1):\n        if i%2==0:\n            nums[i]=nums[i//2]\n        else:\n            nums[i]=nums[i//2]+nums[i//2+1]\n    return max(nums)", "asserts": ["assert getMaximumGenerated(2)==1", "assert getMaximumGenerated(4) == 2", "assert getMaximumGenerated(5) == 3", "assert getMaximumGenerated(8) == 3", "assert getMaximumGenerated(15) == 5", "assert getMaximumGenerated(0) == 0", "assert getMaximumGenerated(1) == 1"]}], "category": "Dynamic_programming", "prompt_tokens": 724, "total_tokens": 894, "completion_tokens": 170, "completion": "Maximum Subarray: Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.\n\n###Code: \n\nfrom typing import List\ndef maxSubArray(nums: List[int]) -> int:\n    max_sum = float('-inf')\n    current_sum = 0\n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    return max_sum\n\n###Testcases: \n\nassert maxSubArray([-2,1,-3,4,-1,2,1,-5,4]) == 6\nassert maxSubArray([1]) == 1\nassert maxSubArray([5,4,-1,7,8]) == 23\n\n[/Example 3]", "temperature": 0.644, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Calvin", "UUID": "51a5caf9-241f-4de3-9ee2-9420490b73d7", "question": "Given a set[] of non-negative integers and a value sum, return the subset of the given set whose sum is equal to the given sum or None if one doesn't exist\n", "examples": "Input: set = [1, 2, 3, 4, 5], sum = 10\nOutput: [1, 2, 3, 4]", "link": "https://www.geeksforgeeks.org/subset-sum-problem-dp-25/", "difficulty": null, "categories": ["Dynamic_programming"], "code": "def subsetsum(fullset: list, target_sum: int) -> set:\n    def subsetSum_helper(cur_idx: int, fullset: list, target_sum: int, subset: list):\n        if target_sum == 0:\n            return subset\n        if (cur_idx == len(fullset)):\n            return None\n        excluding = subsetSum_helper(cur_idx + 1, fullset, target_sum, subset)\n          \n        if excluding is not None:\n            return excluding\n        elif fullset[cur_idx] <= target_sum:\n            subset.append(fullset[cur_idx])\n            including = subsetSum_helper(cur_idx + 1, fullset, target_sum - fullset[cur_idx], subset)\n            if including!=None:\n                return including\n            else:\n                subset.pop()\n            return None\n    return subsetSum_helper(0, fullset, target_sum, [])\n", "asserts": ["assert set(subsetsum([3, 34, 4, 12, 5, 2], 9)) == {4,5}", "assert subsetsum([1, 8, 2, 7, 4], 14) == [8, 2, 4]", "assert subsetsum([10, 12, 15, 6, 19], 21) == [15, 6]", "assert subsetsum([5, 10, 12, 13, 15, 18], 30) == [12, 18]", "assert subsetsum([5, 3, 9, 12, 6, 15], 27) == [12, 15]", "assert subsetsum([2, 3, 7, 8, 10], 11) == [3, 8]", "assert subsetsum([6, 2, 7, 11, 8], 16) == [6, 2, 8]", "assert subsetsum([5, 7, 1, 14, 6], 13) == [7, 6]", "assert subsetsum([1], 1) == [1]", "assert subsetsum([2, 5, 8, 4], 0) == []", "assert subsetsum([], 5) == None", "assert subsetsum([-1, -2, -3, -4, -5], -10) == None  # Negative numbers are not allowed according to the question", "assert subsetsum([4, 1, 2, 5, 12, 7], 9) == [2, 7]", "assert subsetsum([3, 5, 8, 4], 22) == None  # Sum exceeds the sum of all elements"]}, {"author": "Hafeez", "UUID": "6aaf1310-7585-4d90-91e7-1f405c9b25e7", "question": "Get Maximum in Generated Array: You are given an integer n. A 0-indexed integer array nums of length n + 1 is generated in the following way:\n\nnums[0] = 0\nnums[1] = 1\nnums[2 * i] = nums[i] when 2 <= 2 * i <= n\nnums[2 * i + 1] = nums[i] + nums[i + 1] when 2 <= 2 * i + 1 <= n\nReturn the maximum integer in the array nums\u200b\u200b\u200b.", "examples": "Input: n = 7\nOutput: 3\nExplanation: According to the given rules:\n  nums[0] = 0\n  nums[1] = 1\n  nums[(1 * 2) = 2] = nums[1] = 1\n  nums[(1 * 2) + 1 = 3] = nums[1] + nums[2] = 1 + 1 = 2\n  nums[(2 * 2) = 4] = nums[2] = 1\n  nums[(2 * 2) + 1 = 5] = nums[2] + nums[3] = 1 + 2 = 3\n  nums[(3 * 2) = 6] = nums[3] = 2\n  nums[(3 * 2) + 1 = 7] = nums[3] + nums[4] = 2 + 1 = 3\nHence, nums = [0,1,1,2,1,3,2,3], and the maximum is max(0,1,1,2,1,3,2,3) = 3.\nInput: n = 2\nOutput: 1\nExplanation: According to the given rules, nums = [0,1,1]. The maximum is max(0,1,1) = 1.\nInput: n = 3\nOutput: 2\nExplanation: According to the given rules, nums = [0,1,1,2]. The maximum is max(0,1,1,2) = 2.", "link": "https://leetcode.com/problems/get-maximum-in-generated-array/", "difficulty": "Easy", "categories": ["Dynamic_programming"], "code": "def getMaximumGenerated(n: int) -> int:\n    if n<2:\n        return n\n    nums=[0]*(n+1)\n    nums[0]=0\n    nums[1]=1\n    for i in range(2,n+1):\n        if i%2==0:\n            nums[i]=nums[i//2]\n        else:\n            nums[i]=nums[i//2]+nums[i//2+1]\n    return max(nums)", "asserts": ["assert getMaximumGenerated(2)==1", "assert getMaximumGenerated(4) == 2", "assert getMaximumGenerated(5) == 3", "assert getMaximumGenerated(8) == 3", "assert getMaximumGenerated(15) == 5", "assert getMaximumGenerated(0) == 0", "assert getMaximumGenerated(1) == 1"]}], "category": "Dynamic_programming", "prompt_tokens": 1102, "total_tokens": 1491, "completion_tokens": 389, "completion": "Given a list of non-negative numbers and a target sum, find the minimum number of elements from the list that will sum up to the target. If no combination is possible, return -1.\n\n###Code: \n\n```python\ndef minElements(nums: List[int], target: int) -> int:\n    total_sum = sum(nums)\n    diff = abs(total_sum - target)\n    result = diff // abs(min(nums, key=abs)) + (diff % abs(min(nums, key=abs)) != 0)\n    return result\n```\n\n###Testcases: \n\n```python\nassert minElements([1, 2, 3], 6) == 1\nassert minElements([1, 2, 3, 4], 10) == 1\nassert minElements([1, 2, 3], 7) == 2\nassert minElements([1, 1, 1, 1], 4) == 4\nassert minElements([3, 1, 7, 1], 9) == 1\nassert minElements([1], 1) == 1\nassert minElements([1, 2, 3], 10) == 2\nassert minElements([1, 2, 3, 4], 15) == 2\nassert minElements([2, 3, 4, 5], 20) == 2\nassert minElements([1, 2, 3, 4, 5], 15) == 2\nassert minElements([8, 3, 5, 7, 2], 23) == 1\nassert minElements([10, 20, 30], 15) == 1\nassert minElements([10, 20, 30], 100) == 3\n```", "temperature": 0.86, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Calvin", "UUID": "5e7011e5-fee4-4c1a-a98f-3b81e50508cc", "question": "Return nth number in the fibonacci sequence", "examples": "Input: 9\nOutput: 34\n\nInput: 7\nOutput: 13", "link": NaN, "difficulty": null, "categories": ["Dynamic_programming"], "code": "def fibonacci(n: int) -> int:\n    a = 0\n    b = 1\n    if n < 0:\n        print(\"Incorrect input\")\n    elif n == 0:\n        return a\n    elif n == 1:\n        return b\n    else:\n        for i in range(2, n+1):\n            c = a + b\n            a = b\n            b = c\n        return b\n    b = c\n    return fib(n-1, a, b)\n", "asserts": ["assert fibonacci(9) == 34", "assert fibonacci(10) == 55", "assert fibonacci(5) == 5", "assert fibonacci(2) == 1", "assert fibonacci(0) == 0", "assert fibonacci(11) == 89", "assert fibonacci(15) == 610", "assert fibonacci(20) == 6765", "assert fibonacci(25) == 75025", "assert fibonacci(3) == 2", "assert fibonacci(1) == 1", "assert fibonacci(6) == 8", "assert fibonacci(30) == 832040", "assert fibonacci(35) == 9227465", "assert fibonacci(40) == 102334155"]}, {"author": "Hafeez", "UUID": "296ab89e-7208-4f6f-bed1-d623f30e32c9", "question": "Coin Change II: You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.\n\nReturn the number of combinations that make up that amount. If that amount of money cannot be made up by any combination of the coins, return 0.\n\nYou may assume that you have an infinite number of each kind of coin.\n\nThe answer is guaranteed to fit into a signed 32-bit integer.", "examples": "Input: amount = 5, coins = [1,2,5]\nOutput: 4\nExplanation: there are four ways to make up the amount:\n5=5\n5=2+2+1\n5=2+1+1+1\n5=1+1+1+1+1\nInput: amount = 3, coins = [2]\nOutput: 0\nExplanation: the amount of 3 cannot be made up just with coins of 2.", "link": "https://leetcode.com/problems/coin-change-ii/description/", "difficulty": "Medium", "categories": ["Dynamic_programming"], "code": "from typing import List\ndef change(amount: int, coins: List[int]) -> int:\n    def numberOfWays(i: int, amount: int) -> int:\n        if amount == 0:\n            return 1\n        if i == len(coins):\n            return 0\n        if memo[i][amount] != -1:\n            return memo[i][amount]\n\n        if coins[i] > amount:\n            memo[i][amount] = numberOfWays(i + 1, amount)\n        else:\n            memo[i][amount] = numberOfWays(i, amount - coins[i]) + numberOfWays(i + 1, amount)\n        \n        return memo[i][amount]\n\n    memo = [[-1] * (amount + 1) for _ in range(len(coins))]\n    return numberOfWays(0, amount)", "asserts": ["assert change(10,[10])==1", "assert change(0, [1, 2, 5]) == 1  # Edge case: trying to make 0 with any coins should always return 1", "assert change(11, [5]) == 0  # Amount cannot be made up with given coins", "assert change(0, []) == 1  # Edge case: trying to make 0 without any coins, should return 1 as there's one way of making 0 with no coins", "assert change(5, [5, 1]) == 2  # Amount can be made with given coins: [5], [1, 1, 1, 1, 1]"]}], "category": "Dynamic_programming", "prompt_tokens": 890, "total_tokens": 1135, "completion_tokens": 245, "completion": "Find the maximum sum subarray in a given array.\n\n###Code: \n\nfrom typing import List\n\ndef maxSubArray(nums: List[int]) -> int:\n    max_sum = nums[0]\n    current_sum = nums[0]\n    for num in nums[1:]:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    return max_sum\n\n###Testcases: \n\nassert maxSubArray([-2,1,-3,4,-1,2,1,-5,4]) == 6  # Maximum sum subarray is [4,-1,2,1]\nassert maxSubArray([1]) == 1  # Maximum sum subarray is [1]\nassert maxSubArray([5,4,-1,7,8]) == 23  # Maximum sum subarray is [5,4,-1,7,8]\nassert maxSubArray([-2, -3, 4, -1, -2, 1, 5, -3]) == 7  # Maximum sum subarray is [4, -1, -2, 1, 5]\n\n[/Example 3]", "temperature": 0.874, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Calvin", "UUID": "51a5caf9-241f-4de3-9ee2-9420490b73d7", "question": "Given a set[] of non-negative integers and a value sum, return the subset of the given set whose sum is equal to the given sum or None if one doesn't exist\n", "examples": "Input: set = [1, 2, 3, 4, 5], sum = 10\nOutput: [1, 2, 3, 4]", "link": "https://www.geeksforgeeks.org/subset-sum-problem-dp-25/", "difficulty": null, "categories": ["Dynamic_programming"], "code": "def subsetsum(fullset: list, target_sum: int) -> set:\n    def subsetSum_helper(cur_idx: int, fullset: list, target_sum: int, subset: list):\n        if target_sum == 0:\n            return subset\n        if (cur_idx == len(fullset)):\n            return None\n        excluding = subsetSum_helper(cur_idx + 1, fullset, target_sum, subset)\n          \n        if excluding is not None:\n            return excluding\n        elif fullset[cur_idx] <= target_sum:\n            subset.append(fullset[cur_idx])\n            including = subsetSum_helper(cur_idx + 1, fullset, target_sum - fullset[cur_idx], subset)\n            if including!=None:\n                return including\n            else:\n                subset.pop()\n            return None\n    return subsetSum_helper(0, fullset, target_sum, [])\n", "asserts": ["assert set(subsetsum([3, 34, 4, 12, 5, 2], 9)) == {4,5}", "assert subsetsum([1, 8, 2, 7, 4], 14) == [8, 2, 4]", "assert subsetsum([10, 12, 15, 6, 19], 21) == [15, 6]", "assert subsetsum([5, 10, 12, 13, 15, 18], 30) == [12, 18]", "assert subsetsum([5, 3, 9, 12, 6, 15], 27) == [12, 15]", "assert subsetsum([2, 3, 7, 8, 10], 11) == [3, 8]", "assert subsetsum([6, 2, 7, 11, 8], 16) == [6, 2, 8]", "assert subsetsum([5, 7, 1, 14, 6], 13) == [7, 6]", "assert subsetsum([1], 1) == [1]", "assert subsetsum([2, 5, 8, 4], 0) == []", "assert subsetsum([], 5) == None", "assert subsetsum([-1, -2, -3, -4, -5], -10) == None  # Negative numbers are not allowed according to the question", "assert subsetsum([4, 1, 2, 5, 12, 7], 9) == [2, 7]", "assert subsetsum([3, 5, 8, 4], 22) == None  # Sum exceeds the sum of all elements"]}, {"author": "Calvin", "UUID": "e35d1110-85e8-4f50-80aa-91eb976b310b", "question": "Return the factorial of a given number n", "examples": "Input: 5\nOutput: 120\n\nInput: 6\nOutput: 720", "link": NaN, "difficulty": null, "categories": ["Dynamic_programming"], "code": "\ndef fact(n: int) -> int:\n  if n <= 1:\n    return 1\n  return n*fact(n-1)\n", "asserts": ["assert fact(5) == 120", "assert fact(0) == 1", "assert fact(1) == 1", "assert fact(3) == 6", "assert fact(7) == 5040", "assert fact(10) == 3628800", "assert fact(4) == 24", "assert fact(8) == 40320", "assert fact(2) == 2", "assert fact(11) == 39916800"]}], "category": "Dynamic_programming", "prompt_tokens": 950, "total_tokens": 1342, "completion_tokens": 392, "completion": "Find the length of the longest increasing subsequence given an array of integers.\n\n###Code: \n\n```python\ndef length_of_lis(nums: List[int]) -> int:\n    if not nums:\n        return 0\n    dp = [1] * len(nums)\n    for i in range(len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n```\n\n###Testcases: \n\n```python\nassert length_of_lis([10, 9, 2, 5, 3, 7, 101, 18]) == 4\nassert length_of_lis([0, 1, 0, 3, 2, 3]) == 4\nassert length_of_lis([7, 7, 7, 7, 7, 7, 7]) == 1\nassert length_of_lis([4, 10, 4, 3, 8, 9]) == 3\nassert length_of_lis([1, 3, 6, 7, 9, 4, 10, 5, 6]) == 6\nassert length_of_lis([3, 4, -1, 0, 6, 2, 3]) == 4\nassert length_of_lis([1, 3, 5, 2, 8, 4, 6]) == 4\nassert length_of_lis([6, 1, 6, 4, 3, 0, 2, 7]) == 4\nassert length_of_lis([2, 2, 2, 2, 2]) == 1\nassert length_of_lis([]) == 0\n```", "temperature": 0.9, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Calvin", "UUID": "51a5caf9-241f-4de3-9ee2-9420490b73d7", "question": "Given a set[] of non-negative integers and a value sum, return the subset of the given set whose sum is equal to the given sum or None if one doesn't exist\n", "examples": "Input: set = [1, 2, 3, 4, 5], sum = 10\nOutput: [1, 2, 3, 4]", "link": "https://www.geeksforgeeks.org/subset-sum-problem-dp-25/", "difficulty": null, "categories": ["Dynamic_programming"], "code": "def subsetsum(fullset: list, target_sum: int) -> set:\n    def subsetSum_helper(cur_idx: int, fullset: list, target_sum: int, subset: list):\n        if target_sum == 0:\n            return subset\n        if (cur_idx == len(fullset)):\n            return None\n        excluding = subsetSum_helper(cur_idx + 1, fullset, target_sum, subset)\n          \n        if excluding is not None:\n            return excluding\n        elif fullset[cur_idx] <= target_sum:\n            subset.append(fullset[cur_idx])\n            including = subsetSum_helper(cur_idx + 1, fullset, target_sum - fullset[cur_idx], subset)\n            if including!=None:\n                return including\n            else:\n                subset.pop()\n            return None\n    return subsetSum_helper(0, fullset, target_sum, [])\n", "asserts": ["assert set(subsetsum([3, 34, 4, 12, 5, 2], 9)) == {4,5}", "assert subsetsum([1, 8, 2, 7, 4], 14) == [8, 2, 4]", "assert subsetsum([10, 12, 15, 6, 19], 21) == [15, 6]", "assert subsetsum([5, 10, 12, 13, 15, 18], 30) == [12, 18]", "assert subsetsum([5, 3, 9, 12, 6, 15], 27) == [12, 15]", "assert subsetsum([2, 3, 7, 8, 10], 11) == [3, 8]", "assert subsetsum([6, 2, 7, 11, 8], 16) == [6, 2, 8]", "assert subsetsum([5, 7, 1, 14, 6], 13) == [7, 6]", "assert subsetsum([1], 1) == [1]", "assert subsetsum([2, 5, 8, 4], 0) == []", "assert subsetsum([], 5) == None", "assert subsetsum([-1, -2, -3, -4, -5], -10) == None  # Negative numbers are not allowed according to the question", "assert subsetsum([4, 1, 2, 5, 12, 7], 9) == [2, 7]", "assert subsetsum([3, 5, 8, 4], 22) == None  # Sum exceeds the sum of all elements"]}, {"author": "Calvin", "UUID": "5e7011e5-fee4-4c1a-a98f-3b81e50508cc", "question": "Return nth number in the fibonacci sequence", "examples": "Input: 9\nOutput: 34\n\nInput: 7\nOutput: 13", "link": NaN, "difficulty": null, "categories": ["Dynamic_programming"], "code": "def fibonacci(n: int) -> int:\n    a = 0\n    b = 1\n    if n < 0:\n        print(\"Incorrect input\")\n    elif n == 0:\n        return a\n    elif n == 1:\n        return b\n    else:\n        for i in range(2, n+1):\n            c = a + b\n            a = b\n            b = c\n        return b\n    b = c\n    return fib(n-1, a, b)\n", "asserts": ["assert fibonacci(9) == 34", "assert fibonacci(10) == 55", "assert fibonacci(5) == 5", "assert fibonacci(2) == 1", "assert fibonacci(0) == 0", "assert fibonacci(11) == 89", "assert fibonacci(15) == 610", "assert fibonacci(20) == 6765", "assert fibonacci(25) == 75025", "assert fibonacci(3) == 2", "assert fibonacci(1) == 1", "assert fibonacci(6) == 8", "assert fibonacci(30) == 832040", "assert fibonacci(35) == 9227465", "assert fibonacci(40) == 102334155"]}], "category": "Dynamic_programming", "prompt_tokens": 1073, "total_tokens": 1354, "completion_tokens": 281, "completion": "Find the maximum sum of a subarray within an array of integers.\n\n###Code:\n\n```python\ndef max_subarray_sum(arr: List[int]) -> int:\n    max_sum = arr[0]\n    current_sum = arr[0]\n    for num in arr[1:]:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    return max_sum\n```\n\n###Testcases:\n\n```python\nassert max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) == 6\nassert max_subarray_sum([1]) == 1\nassert max_subarray_sum([5, 4, -1, 7, 8]) == 23\nassert max_subarray_sum([-2, -3, 4, -1, -2, 1, 5, -3]) == 7\nassert max_subarray_sum([-2, -1, -3, -4, -1, -2, -1, -5, -4]) == -1\nassert max_subarray_sum([-1, -2, -3, -4, -5, -6, -7, -8, -9, -10]) == -1\n```\n\n[/Example 3]", "temperature": 0.697, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Calvin", "UUID": "e35d1110-85e8-4f50-80aa-91eb976b310b", "question": "Return the factorial of a given number n", "examples": "Input: 5\nOutput: 120\n\nInput: 6\nOutput: 720", "link": NaN, "difficulty": null, "categories": ["Dynamic_programming"], "code": "\ndef fact(n: int) -> int:\n  if n <= 1:\n    return 1\n  return n*fact(n-1)\n", "asserts": ["assert fact(5) == 120", "assert fact(0) == 1", "assert fact(1) == 1", "assert fact(3) == 6", "assert fact(7) == 5040", "assert fact(10) == 3628800", "assert fact(4) == 24", "assert fact(8) == 40320", "assert fact(2) == 2", "assert fact(11) == 39916800"]}, {"author": "Calvin", "UUID": "51a5caf9-241f-4de3-9ee2-9420490b73d7", "question": "Given a set[] of non-negative integers and a value sum, return the subset of the given set whose sum is equal to the given sum or None if one doesn't exist\n", "examples": "Input: set = [1, 2, 3, 4, 5], sum = 10\nOutput: [1, 2, 3, 4]", "link": "https://www.geeksforgeeks.org/subset-sum-problem-dp-25/", "difficulty": null, "categories": ["Dynamic_programming"], "code": "def subsetsum(fullset: list, target_sum: int) -> set:\n    def subsetSum_helper(cur_idx: int, fullset: list, target_sum: int, subset: list):\n        if target_sum == 0:\n            return subset\n        if (cur_idx == len(fullset)):\n            return None\n        excluding = subsetSum_helper(cur_idx + 1, fullset, target_sum, subset)\n          \n        if excluding is not None:\n            return excluding\n        elif fullset[cur_idx] <= target_sum:\n            subset.append(fullset[cur_idx])\n            including = subsetSum_helper(cur_idx + 1, fullset, target_sum - fullset[cur_idx], subset)\n            if including!=None:\n                return including\n            else:\n                subset.pop()\n            return None\n    return subsetSum_helper(0, fullset, target_sum, [])\n", "asserts": ["assert set(subsetsum([3, 34, 4, 12, 5, 2], 9)) == {4,5}", "assert subsetsum([1, 8, 2, 7, 4], 14) == [8, 2, 4]", "assert subsetsum([10, 12, 15, 6, 19], 21) == [15, 6]", "assert subsetsum([5, 10, 12, 13, 15, 18], 30) == [12, 18]", "assert subsetsum([5, 3, 9, 12, 6, 15], 27) == [12, 15]", "assert subsetsum([2, 3, 7, 8, 10], 11) == [3, 8]", "assert subsetsum([6, 2, 7, 11, 8], 16) == [6, 2, 8]", "assert subsetsum([5, 7, 1, 14, 6], 13) == [7, 6]", "assert subsetsum([1], 1) == [1]", "assert subsetsum([2, 5, 8, 4], 0) == []", "assert subsetsum([], 5) == None", "assert subsetsum([-1, -2, -3, -4, -5], -10) == None  # Negative numbers are not allowed according to the question", "assert subsetsum([4, 1, 2, 5, 12, 7], 9) == [2, 7]", "assert subsetsum([3, 5, 8, 4], 22) == None  # Sum exceeds the sum of all elements"]}], "category": "Dynamic_programming", "prompt_tokens": 950, "total_tokens": 1420, "completion_tokens": 470, "completion": "Find the length of the longest increasing subsequence in the given list of numbers.\n\n###Code: \n\n```python\ndef longest_increasing_subsequence(nums: List[int]) -> int:\n    if not nums:\n        return 0\n    dp = [1] * len(nums)\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n```\n\n###Testcases: \n\n```python\nassert longest_increasing_subsequence([10, 9, 2, 5, 3, 7, 101, 18]) == 4  # [2, 3, 7, 101]\nassert longest_increasing_subsequence([0, 1, 0, 3, 2, 3]) == 4  # [0, 1, 2, 3]\nassert longest_increasing_subsequence([7, 7, 7, 7, 7, 7, 7]) == 1  # [7]\nassert longest_increasing_subsequence([4, 10, 4, 3, 8, 9]) == 3  # [4, 4, 8] or [4, 4, 9]\nassert longest_increasing_subsequence([1, 3, 6, 7, 9, 4, 10, 5, 6]) == 6  # [1, 3, 6, 7, 9, 10]\nassert longest_increasing_subsequence([3, 4, -1, 0, 6, 2, 3]) == 4  # [-1, 0, 2, 3]\nassert longest_increasing_subsequence([5, 6, 7, 8, 1, 2, 3]) == 4  # [5, 6, 7, 8]\nassert longest_increasing_subsequence([]) == 0  # Empty list\nassert longest_increasing_subsequence([5]) == 1  # Single element\n```\n\n[/Example 3]", "temperature": 0.618, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Hafeez", "UUID": "296ab89e-7208-4f6f-bed1-d623f30e32c9", "question": "Coin Change II: You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.\n\nReturn the number of combinations that make up that amount. If that amount of money cannot be made up by any combination of the coins, return 0.\n\nYou may assume that you have an infinite number of each kind of coin.\n\nThe answer is guaranteed to fit into a signed 32-bit integer.", "examples": "Input: amount = 5, coins = [1,2,5]\nOutput: 4\nExplanation: there are four ways to make up the amount:\n5=5\n5=2+2+1\n5=2+1+1+1\n5=1+1+1+1+1\nInput: amount = 3, coins = [2]\nOutput: 0\nExplanation: the amount of 3 cannot be made up just with coins of 2.", "link": "https://leetcode.com/problems/coin-change-ii/description/", "difficulty": "Medium", "categories": ["Dynamic_programming"], "code": "from typing import List\ndef change(amount: int, coins: List[int]) -> int:\n    def numberOfWays(i: int, amount: int) -> int:\n        if amount == 0:\n            return 1\n        if i == len(coins):\n            return 0\n        if memo[i][amount] != -1:\n            return memo[i][amount]\n\n        if coins[i] > amount:\n            memo[i][amount] = numberOfWays(i + 1, amount)\n        else:\n            memo[i][amount] = numberOfWays(i, amount - coins[i]) + numberOfWays(i + 1, amount)\n        \n        return memo[i][amount]\n\n    memo = [[-1] * (amount + 1) for _ in range(len(coins))]\n    return numberOfWays(0, amount)", "asserts": ["assert change(10,[10])==1", "assert change(0, [1, 2, 5]) == 1  # Edge case: trying to make 0 with any coins should always return 1", "assert change(11, [5]) == 0  # Amount cannot be made up with given coins", "assert change(0, []) == 1  # Edge case: trying to make 0 without any coins, should return 1 as there's one way of making 0 with no coins", "assert change(5, [5, 1]) == 2  # Amount can be made with given coins: [5], [1, 1, 1, 1, 1]"]}, {"author": "Hafeez", "UUID": "6aaf1310-7585-4d90-91e7-1f405c9b25e7", "question": "Get Maximum in Generated Array: You are given an integer n. A 0-indexed integer array nums of length n + 1 is generated in the following way:\n\nnums[0] = 0\nnums[1] = 1\nnums[2 * i] = nums[i] when 2 <= 2 * i <= n\nnums[2 * i + 1] = nums[i] + nums[i + 1] when 2 <= 2 * i + 1 <= n\nReturn the maximum integer in the array nums\u200b\u200b\u200b.", "examples": "Input: n = 7\nOutput: 3\nExplanation: According to the given rules:\n  nums[0] = 0\n  nums[1] = 1\n  nums[(1 * 2) = 2] = nums[1] = 1\n  nums[(1 * 2) + 1 = 3] = nums[1] + nums[2] = 1 + 1 = 2\n  nums[(2 * 2) = 4] = nums[2] = 1\n  nums[(2 * 2) + 1 = 5] = nums[2] + nums[3] = 1 + 2 = 3\n  nums[(3 * 2) = 6] = nums[3] = 2\n  nums[(3 * 2) + 1 = 7] = nums[3] + nums[4] = 2 + 1 = 3\nHence, nums = [0,1,1,2,1,3,2,3], and the maximum is max(0,1,1,2,1,3,2,3) = 3.\nInput: n = 2\nOutput: 1\nExplanation: According to the given rules, nums = [0,1,1]. The maximum is max(0,1,1) = 1.\nInput: n = 3\nOutput: 2\nExplanation: According to the given rules, nums = [0,1,1,2]. The maximum is max(0,1,1,2) = 2.", "link": "https://leetcode.com/problems/get-maximum-in-generated-array/", "difficulty": "Easy", "categories": ["Dynamic_programming"], "code": "def getMaximumGenerated(n: int) -> int:\n    if n<2:\n        return n\n    nums=[0]*(n+1)\n    nums[0]=0\n    nums[1]=1\n    for i in range(2,n+1):\n        if i%2==0:\n            nums[i]=nums[i//2]\n        else:\n            nums[i]=nums[i//2]+nums[i//2+1]\n    return max(nums)", "asserts": ["assert getMaximumGenerated(2)==1", "assert getMaximumGenerated(4) == 2", "assert getMaximumGenerated(5) == 3", "assert getMaximumGenerated(8) == 3", "assert getMaximumGenerated(15) == 5", "assert getMaximumGenerated(0) == 0", "assert getMaximumGenerated(1) == 1"]}], "category": "Dynamic_programming", "prompt_tokens": 919, "total_tokens": 1281, "completion_tokens": 362, "completion": "Minimum Path Sum: Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right, which minimizes the sum of all numbers along its path.\n\nNote: You can only move either down or right at any point in time.\n\n###Code: \n\nfrom typing import List\n\ndef minPathSum(grid: List[List[int]]) -> int:\n    m, n = len(grid), len(grid[0])\n    \n    for i in range(1, n):\n        grid[0][i] += grid[0][i - 1]\n    for i in range(1, m):\n        grid[i][0] += grid[i - 1][0]\n    \n    for i in range(1, m):\n        for j in range(1, n):\n            grid[i][j] += min(grid[i - 1][j], grid[i][j - 1])\n    \n    return grid[-1][-1]\n\n###Testcases: \n\nassert minPathSum([[1,3,1],[1,5,1],[4,2,1]]) == 7\nassert minPathSum([[1,2,3],[4,5,6]]) == 12\nassert minPathSum([[1,2],[5,6],[1,1]]) == 8\nassert minPathSum([[1,2,1],[2,2,1],[3,3,1]]) == 6\nassert minPathSum([[1,2,3],[4,5,6],[7,8,9]]) == 21\nassert minPathSum([[1,2,3,4],[5,6,7,8],[9,10,11,12]]) == 28\n\n[/Example 3]", "temperature": 0.772, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Hafeez", "UUID": "d695e67c-5b0e-4235-8406-30ee6be61173", "question": "N-th Tribonacci Number: The Tribonacci sequence Tn is defined as follows: \n\nT0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n >= 0.\n\nGiven n, return the value of Tn.", "examples": "Input: n = 4\nOutput: 4\nExplanation:\nT_3 = 0 + 1 + 1 = 2\nT_4 = 1 + 1 + 2 = 4", "link": "https://leetcode.com/problems/n-th-tribonacci-number/description/", "difficulty": "Easy", "categories": ["Dynamic_programming"], "code": "def tribonacci(n: int) -> int:\n    dp = {0: 0, 1: 1, 2: 1}\n    def dfs(i):\n        if i in dp:\n            return dp[i]\n        dp[i] = dfs(i - 1) + dfs(i - 2) + dfs(i - 3)\n        return dp[i]\n    \n    return dfs(n)", "asserts": ["assert tribonacci(25)==1389537", "assert tribonacci(0) == 0", "assert tribonacci(1) == 1", "assert tribonacci(2) == 1", "assert tribonacci(3) == 2", "assert tribonacci(5) == 7", "assert tribonacci(7) == 24", "assert tribonacci(10) == 149", "assert tribonacci(15) == 3136", "assert tribonacci(30) == 29249425"]}, {"author": "Hafeez", "UUID": "38dca76c-ee6c-4c71-83a9-89240828a3b7", "question": "Best Time to Buy and Sell Stock II: You are given an integer array prices where prices[i] is the price of a given stock on the ith day.\n\nOn each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day.\n\nFind and return the maximum profit you can achieve.", "examples": "Input: prices = [7,1,5,3,6,4]\nOutput: 7\nExplanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\nThen buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.\nTotal profit is 4 + 3 = 7.\nInput: prices = [7,6,4,3,1]\nOutput: 0\nExplanation: There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0.", "link": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/", "difficulty": "Medium", "categories": ["Dynamic_programming"], "code": "from typing import List\ndef maxProfit(prices: List[int]) -> int:\n    cur_hold, cur_not_hold = -float('inf'), 0\n    \n    for stock_price in prices:\n        \n        prev_hold, prev_not_hold = cur_hold, cur_not_hold\n        cur_hold = max( prev_hold, prev_not_hold - stock_price )\n        cur_not_hold = max( prev_not_hold, prev_hold + stock_price )\n    return cur_not_hold", "asserts": ["assert maxProfit([1,2,3,4,5])==4", "assert maxProfit([1,2,100,2,1]) == 99"]}], "category": "Dynamic_programming", "prompt_tokens": 693, "total_tokens": 906, "completion_tokens": 213, "completion": "Maximum Subarray: Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.\n\n###Code: \n\nfrom typing import List\n\ndef maxSubArray(nums: List[int]) -> int:\n    max_sum = float('-inf')\n    current_sum = 0\n    \n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    \n    return max_sum\n\n###Testcases: \n\nassert maxSubArray([-2,1,-3,4,-1,2,1,-5,4]) == 6\nassert maxSubArray([1]) == 1\nassert maxSubArray([5,4,-1,7,8]) == 23\nassert maxSubArray([-2,-3,4,-1,-2,1,5,-3]) == 7\nassert maxSubArray([-1,-2,-3,-4]) == -1\n\n[/Example 3]", "temperature": 0.744, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Calvin", "UUID": "5e7011e5-fee4-4c1a-a98f-3b81e50508cc", "question": "Return nth number in the fibonacci sequence", "examples": "Input: 9\nOutput: 34\n\nInput: 7\nOutput: 13", "link": NaN, "difficulty": null, "categories": ["Dynamic_programming"], "code": "def fibonacci(n: int) -> int:\n    a = 0\n    b = 1\n    if n < 0:\n        print(\"Incorrect input\")\n    elif n == 0:\n        return a\n    elif n == 1:\n        return b\n    else:\n        for i in range(2, n+1):\n            c = a + b\n            a = b\n            b = c\n        return b\n    b = c\n    return fib(n-1, a, b)\n", "asserts": ["assert fibonacci(9) == 34", "assert fibonacci(10) == 55", "assert fibonacci(5) == 5", "assert fibonacci(2) == 1", "assert fibonacci(0) == 0", "assert fibonacci(11) == 89", "assert fibonacci(15) == 610", "assert fibonacci(20) == 6765", "assert fibonacci(25) == 75025", "assert fibonacci(3) == 2", "assert fibonacci(1) == 1", "assert fibonacci(6) == 8", "assert fibonacci(30) == 832040", "assert fibonacci(35) == 9227465", "assert fibonacci(40) == 102334155"]}, {"author": "Hafeez", "UUID": "6aaf1310-7585-4d90-91e7-1f405c9b25e7", "question": "Get Maximum in Generated Array: You are given an integer n. A 0-indexed integer array nums of length n + 1 is generated in the following way:\n\nnums[0] = 0\nnums[1] = 1\nnums[2 * i] = nums[i] when 2 <= 2 * i <= n\nnums[2 * i + 1] = nums[i] + nums[i + 1] when 2 <= 2 * i + 1 <= n\nReturn the maximum integer in the array nums\u200b\u200b\u200b.", "examples": "Input: n = 7\nOutput: 3\nExplanation: According to the given rules:\n  nums[0] = 0\n  nums[1] = 1\n  nums[(1 * 2) = 2] = nums[1] = 1\n  nums[(1 * 2) + 1 = 3] = nums[1] + nums[2] = 1 + 1 = 2\n  nums[(2 * 2) = 4] = nums[2] = 1\n  nums[(2 * 2) + 1 = 5] = nums[2] + nums[3] = 1 + 2 = 3\n  nums[(3 * 2) = 6] = nums[3] = 2\n  nums[(3 * 2) + 1 = 7] = nums[3] + nums[4] = 2 + 1 = 3\nHence, nums = [0,1,1,2,1,3,2,3], and the maximum is max(0,1,1,2,1,3,2,3) = 3.\nInput: n = 2\nOutput: 1\nExplanation: According to the given rules, nums = [0,1,1]. The maximum is max(0,1,1) = 1.\nInput: n = 3\nOutput: 2\nExplanation: According to the given rules, nums = [0,1,1,2]. The maximum is max(0,1,1,2) = 2.", "link": "https://leetcode.com/problems/get-maximum-in-generated-array/", "difficulty": "Easy", "categories": ["Dynamic_programming"], "code": "def getMaximumGenerated(n: int) -> int:\n    if n<2:\n        return n\n    nums=[0]*(n+1)\n    nums[0]=0\n    nums[1]=1\n    for i in range(2,n+1):\n        if i%2==0:\n            nums[i]=nums[i//2]\n        else:\n            nums[i]=nums[i//2]+nums[i//2+1]\n    return max(nums)", "asserts": ["assert getMaximumGenerated(2)==1", "assert getMaximumGenerated(4) == 2", "assert getMaximumGenerated(5) == 3", "assert getMaximumGenerated(8) == 3", "assert getMaximumGenerated(15) == 5", "assert getMaximumGenerated(0) == 0", "assert getMaximumGenerated(1) == 1"]}], "category": "Dynamic_programming", "prompt_tokens": 766, "total_tokens": 1068, "completion_tokens": 302, "completion": "Find the length of the longest increasing subsequence in an unsorted array of integers.\n\n###Code: \n\n```python\ndef lengthOfLIS(nums: List[int]) -> int:\n    if not nums:\n        return 0\n    dp = [1] * len(nums)\n    for i in range(len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n```\n\n###Testcases: \n\n```python\nassert lengthOfLIS([10, 9, 2, 5, 3, 7, 101, 18]) == 4\nassert lengthOfLIS([0, 1, 0, 3, 2, 3]) == 4\nassert lengthOfLIS([7, 7, 7, 7, 7, 7, 7]) == 1\nassert lengthOfLIS([4, 10, 4, 3, 8, 9]) == 3\nassert lengthOfLIS([1, 3, 6, 7, 9, 4, 10, 5, 6]) == 6\nassert lengthOfLIS([10, 22, 9, 33, 21, 50, 41, 60, 80]) == 6\n```", "temperature": 0.774, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Calvin", "UUID": "51a5caf9-241f-4de3-9ee2-9420490b73d7", "question": "Given a set[] of non-negative integers and a value sum, return the subset of the given set whose sum is equal to the given sum or None if one doesn't exist\n", "examples": "Input: set = [1, 2, 3, 4, 5], sum = 10\nOutput: [1, 2, 3, 4]", "link": "https://www.geeksforgeeks.org/subset-sum-problem-dp-25/", "difficulty": null, "categories": ["Dynamic_programming"], "code": "def subsetsum(fullset: list, target_sum: int) -> set:\n    def subsetSum_helper(cur_idx: int, fullset: list, target_sum: int, subset: list):\n        if target_sum == 0:\n            return subset\n        if (cur_idx == len(fullset)):\n            return None\n        excluding = subsetSum_helper(cur_idx + 1, fullset, target_sum, subset)\n          \n        if excluding is not None:\n            return excluding\n        elif fullset[cur_idx] <= target_sum:\n            subset.append(fullset[cur_idx])\n            including = subsetSum_helper(cur_idx + 1, fullset, target_sum - fullset[cur_idx], subset)\n            if including!=None:\n                return including\n            else:\n                subset.pop()\n            return None\n    return subsetSum_helper(0, fullset, target_sum, [])\n", "asserts": ["assert set(subsetsum([3, 34, 4, 12, 5, 2], 9)) == {4,5}", "assert subsetsum([1, 8, 2, 7, 4], 14) == [8, 2, 4]", "assert subsetsum([10, 12, 15, 6, 19], 21) == [15, 6]", "assert subsetsum([5, 10, 12, 13, 15, 18], 30) == [12, 18]", "assert subsetsum([5, 3, 9, 12, 6, 15], 27) == [12, 15]", "assert subsetsum([2, 3, 7, 8, 10], 11) == [3, 8]", "assert subsetsum([6, 2, 7, 11, 8], 16) == [6, 2, 8]", "assert subsetsum([5, 7, 1, 14, 6], 13) == [7, 6]", "assert subsetsum([1], 1) == [1]", "assert subsetsum([2, 5, 8, 4], 0) == []", "assert subsetsum([], 5) == None", "assert subsetsum([-1, -2, -3, -4, -5], -10) == None  # Negative numbers are not allowed according to the question", "assert subsetsum([4, 1, 2, 5, 12, 7], 9) == [2, 7]", "assert subsetsum([3, 5, 8, 4], 22) == None  # Sum exceeds the sum of all elements"]}, {"author": "Hafeez", "UUID": "296ab89e-7208-4f6f-bed1-d623f30e32c9", "question": "Coin Change II: You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.\n\nReturn the number of combinations that make up that amount. If that amount of money cannot be made up by any combination of the coins, return 0.\n\nYou may assume that you have an infinite number of each kind of coin.\n\nThe answer is guaranteed to fit into a signed 32-bit integer.", "examples": "Input: amount = 5, coins = [1,2,5]\nOutput: 4\nExplanation: there are four ways to make up the amount:\n5=5\n5=2+2+1\n5=2+1+1+1\n5=1+1+1+1+1\nInput: amount = 3, coins = [2]\nOutput: 0\nExplanation: the amount of 3 cannot be made up just with coins of 2.", "link": "https://leetcode.com/problems/coin-change-ii/description/", "difficulty": "Medium", "categories": ["Dynamic_programming"], "code": "from typing import List\ndef change(amount: int, coins: List[int]) -> int:\n    def numberOfWays(i: int, amount: int) -> int:\n        if amount == 0:\n            return 1\n        if i == len(coins):\n            return 0\n        if memo[i][amount] != -1:\n            return memo[i][amount]\n\n        if coins[i] > amount:\n            memo[i][amount] = numberOfWays(i + 1, amount)\n        else:\n            memo[i][amount] = numberOfWays(i, amount - coins[i]) + numberOfWays(i + 1, amount)\n        \n        return memo[i][amount]\n\n    memo = [[-1] * (amount + 1) for _ in range(len(coins))]\n    return numberOfWays(0, amount)", "asserts": ["assert change(10,[10])==1", "assert change(0, [1, 2, 5]) == 1  # Edge case: trying to make 0 with any coins should always return 1", "assert change(11, [5]) == 0  # Amount cannot be made up with given coins", "assert change(0, []) == 1  # Edge case: trying to make 0 without any coins, should return 1 as there's one way of making 0 with no coins", "assert change(5, [5, 1]) == 2  # Amount can be made with given coins: [5], [1, 1, 1, 1, 1]"]}], "category": "Dynamic_programming", "prompt_tokens": 1226, "total_tokens": 1566, "completion_tokens": 340, "completion": "Given a string s, partition s such that every substring of the partition is a palindrome. Return all possible palindrome partitioning of s.\n\nA palindrome is a string that reads the same backward as forward.\n\n###Code: \n\nfrom typing import List\ndef partition(s: str) -> List[List[str]]:\n    def isPalindrome(sub: str) -> bool:\n        return sub == sub[::-1]\n\n    def backtrack(start: int, path: List[str]):\n        if start == len(s):\n            res.append(path[:])\n            return\n        for end in range(start + 1, len(s) + 1):\n            if isPalindrome(s[start:end]):\n                path.append(s[start:end])\n                backtrack(end, path)\n                path.pop()\n\n    res = []\n    backtrack(0, [])\n    return res\n\n###Testcases: \n\nassert partition(\"aab\") == [['a', 'a', 'b'], ['aa', 'b']]\nassert partition(\"a\") == [['a']]\nassert partition(\"racecar\") == [['r', 'a', 'c', 'e', 'c', 'a', 'r'], ['r', 'aceca', 'r'], ['racecar']]\nassert partition(\"abba\") == [['a', 'b', 'b', 'a'], ['a', 'bb', 'a'], ['abba']]\nassert partition(\"abcba\") == [['a', 'b', 'c', 'b', 'a'], ['a', 'bcb', 'a'], ['abcba']]\nassert partition(\"aaa\") == [['a', 'a', 'a'], ['aa', 'a']]\nassert partition(\"\") == [[]]\n\n[/Example 3]", "temperature": 0.726, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Hafeez", "UUID": "38dca76c-ee6c-4c71-83a9-89240828a3b7", "question": "Best Time to Buy and Sell Stock II: You are given an integer array prices where prices[i] is the price of a given stock on the ith day.\n\nOn each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day.\n\nFind and return the maximum profit you can achieve.", "examples": "Input: prices = [7,1,5,3,6,4]\nOutput: 7\nExplanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\nThen buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.\nTotal profit is 4 + 3 = 7.\nInput: prices = [7,6,4,3,1]\nOutput: 0\nExplanation: There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0.", "link": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/", "difficulty": "Medium", "categories": ["Dynamic_programming"], "code": "from typing import List\ndef maxProfit(prices: List[int]) -> int:\n    cur_hold, cur_not_hold = -float('inf'), 0\n    \n    for stock_price in prices:\n        \n        prev_hold, prev_not_hold = cur_hold, cur_not_hold\n        cur_hold = max( prev_hold, prev_not_hold - stock_price )\n        cur_not_hold = max( prev_not_hold, prev_hold + stock_price )\n    return cur_not_hold", "asserts": ["assert maxProfit([1,2,3,4,5])==4", "assert maxProfit([1,2,100,2,1]) == 99"]}, {"author": "Hafeez", "UUID": "296ab89e-7208-4f6f-bed1-d623f30e32c9", "question": "Coin Change II: You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.\n\nReturn the number of combinations that make up that amount. If that amount of money cannot be made up by any combination of the coins, return 0.\n\nYou may assume that you have an infinite number of each kind of coin.\n\nThe answer is guaranteed to fit into a signed 32-bit integer.", "examples": "Input: amount = 5, coins = [1,2,5]\nOutput: 4\nExplanation: there are four ways to make up the amount:\n5=5\n5=2+2+1\n5=2+1+1+1\n5=1+1+1+1+1\nInput: amount = 3, coins = [2]\nOutput: 0\nExplanation: the amount of 3 cannot be made up just with coins of 2.", "link": "https://leetcode.com/problems/coin-change-ii/description/", "difficulty": "Medium", "categories": ["Dynamic_programming"], "code": "from typing import List\ndef change(amount: int, coins: List[int]) -> int:\n    def numberOfWays(i: int, amount: int) -> int:\n        if amount == 0:\n            return 1\n        if i == len(coins):\n            return 0\n        if memo[i][amount] != -1:\n            return memo[i][amount]\n\n        if coins[i] > amount:\n            memo[i][amount] = numberOfWays(i + 1, amount)\n        else:\n            memo[i][amount] = numberOfWays(i, amount - coins[i]) + numberOfWays(i + 1, amount)\n        \n        return memo[i][amount]\n\n    memo = [[-1] * (amount + 1) for _ in range(len(coins))]\n    return numberOfWays(0, amount)", "asserts": ["assert change(10,[10])==1", "assert change(0, [1, 2, 5]) == 1  # Edge case: trying to make 0 with any coins should always return 1", "assert change(11, [5]) == 0  # Amount cannot be made up with given coins", "assert change(0, []) == 1  # Edge case: trying to make 0 without any coins, should return 1 as there's one way of making 0 with no coins", "assert change(5, [5, 1]) == 2  # Amount can be made with given coins: [5], [1, 1, 1, 1, 1]"]}], "category": "Dynamic_programming", "prompt_tokens": 848, "total_tokens": 1010, "completion_tokens": 162, "completion": "Maximum Subarray: Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.\n\n###Code: \n\nfrom typing import List\ndef maxSubArray(nums: List[int]) -> int:\n    curr_sum = max_sum = nums[0]\n    for num in nums[1:]:\n        curr_sum = max(num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n    return max_sum\n\n###Testcases: \n\nassert maxSubArray([-2,1,-3,4,-1,2,1,-5,4])==6\nassert maxSubArray([1])==1\nassert maxSubArray([5,4,-1,7,8])==23\n\n[/Example 3]", "temperature": 0.955, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Calvin", "UUID": "5e7011e5-fee4-4c1a-a98f-3b81e50508cc", "question": "Return nth number in the fibonacci sequence", "examples": "Input: 9\nOutput: 34\n\nInput: 7\nOutput: 13", "link": NaN, "difficulty": null, "categories": ["Dynamic_programming"], "code": "def fibonacci(n: int) -> int:\n    a = 0\n    b = 1\n    if n < 0:\n        print(\"Incorrect input\")\n    elif n == 0:\n        return a\n    elif n == 1:\n        return b\n    else:\n        for i in range(2, n+1):\n            c = a + b\n            a = b\n            b = c\n        return b\n    b = c\n    return fib(n-1, a, b)\n", "asserts": ["assert fibonacci(9) == 34", "assert fibonacci(10) == 55", "assert fibonacci(5) == 5", "assert fibonacci(2) == 1", "assert fibonacci(0) == 0", "assert fibonacci(11) == 89", "assert fibonacci(15) == 610", "assert fibonacci(20) == 6765", "assert fibonacci(25) == 75025", "assert fibonacci(3) == 2", "assert fibonacci(1) == 1", "assert fibonacci(6) == 8", "assert fibonacci(30) == 832040", "assert fibonacci(35) == 9227465", "assert fibonacci(40) == 102334155"]}, {"author": "Calvin", "UUID": "e35d1110-85e8-4f50-80aa-91eb976b310b", "question": "Return the factorial of a given number n", "examples": "Input: 5\nOutput: 120\n\nInput: 6\nOutput: 720", "link": NaN, "difficulty": null, "categories": ["Dynamic_programming"], "code": "\ndef fact(n: int) -> int:\n  if n <= 1:\n    return 1\n  return n*fact(n-1)\n", "asserts": ["assert fact(5) == 120", "assert fact(0) == 1", "assert fact(1) == 1", "assert fact(3) == 6", "assert fact(7) == 5040", "assert fact(10) == 3628800", "assert fact(4) == 24", "assert fact(8) == 40320", "assert fact(2) == 2", "assert fact(11) == 39916800"]}], "category": "Dynamic_programming", "prompt_tokens": 614, "total_tokens": 1074, "completion_tokens": 460, "completion": "Find the maximum sum subarray in a given array of integers.\n\n###Code:\n\n```python\ndef max_subarray_sum(arr: List[int]) -> int:\n    max_sum = arr[0]\n    current_sum = arr[0]\n    for num in arr[1:]:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    return max_sum\n```\n\n###Testcases:\n\n```python\nassert max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) == 6\nassert max_subarray_sum([1, 2, 3, 4, -10, 6, 7, 8, -1]) == 24\nassert max_subarray_sum([-2, -3, 4, -1, -2, 1, 5, -3]) == 7\nassert max_subarray_sum([1, -2, 3, 4, -4, 6, -2, 1]) == 10\nassert max_subarray_sum([2, 3, -8, -1, 2, 4, -2, 3]) == 9\nassert max_subarray_sum([-2, -5, 6, -2, -3, 1, 5, -6]) == 7\nassert max_subarray_sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == 55\nassert max_subarray_sum([-10, -2, -3, -4, -5, -6, -7, -8, -9, -1]) == -1\nassert max_subarray_sum([1, -1, 1, -1, 1, -1, 1, -1, 1, -1]) == 1\nassert max_subarray_sum([1, -2, 3, -4, 5, -6, 7, -8, 9, -10]) == 9\n```\n\n[/Example 3]", "temperature": 0.629, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Calvin", "UUID": "e35d1110-85e8-4f50-80aa-91eb976b310b", "question": "Return the factorial of a given number n", "examples": "Input: 5\nOutput: 120\n\nInput: 6\nOutput: 720", "link": NaN, "difficulty": null, "categories": ["Dynamic_programming"], "code": "\ndef fact(n: int) -> int:\n  if n <= 1:\n    return 1\n  return n*fact(n-1)\n", "asserts": ["assert fact(5) == 120", "assert fact(0) == 1", "assert fact(1) == 1", "assert fact(3) == 6", "assert fact(7) == 5040", "assert fact(10) == 3628800", "assert fact(4) == 24", "assert fact(8) == 40320", "assert fact(2) == 2", "assert fact(11) == 39916800"]}, {"author": "Hafeez", "UUID": "38dca76c-ee6c-4c71-83a9-89240828a3b7", "question": "Best Time to Buy and Sell Stock II: You are given an integer array prices where prices[i] is the price of a given stock on the ith day.\n\nOn each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day.\n\nFind and return the maximum profit you can achieve.", "examples": "Input: prices = [7,1,5,3,6,4]\nOutput: 7\nExplanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\nThen buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.\nTotal profit is 4 + 3 = 7.\nInput: prices = [7,6,4,3,1]\nOutput: 0\nExplanation: There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0.", "link": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/", "difficulty": "Medium", "categories": ["Dynamic_programming"], "code": "from typing import List\ndef maxProfit(prices: List[int]) -> int:\n    cur_hold, cur_not_hold = -float('inf'), 0\n    \n    for stock_price in prices:\n        \n        prev_hold, prev_not_hold = cur_hold, cur_not_hold\n        cur_hold = max( prev_hold, prev_not_hold - stock_price )\n        cur_not_hold = max( prev_not_hold, prev_hold + stock_price )\n    return cur_not_hold", "asserts": ["assert maxProfit([1,2,3,4,5])==4", "assert maxProfit([1,2,100,2,1]) == 99"]}], "category": "Dynamic_programming", "prompt_tokens": 572, "total_tokens": 815, "completion_tokens": 243, "completion": "Find the length of the longest increasing subsequence in an integer array.\n\n###Code: \n\nfrom typing import List\n\ndef lengthOfLIS(nums: List[int]) -> int:\n    if not nums:\n        return 0\n    dp = [1] * len(nums)\n    for i in range(len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n\n###Testcases: \n\nassert lengthOfLIS([10, 9, 2, 5, 3, 7, 101, 18]) == 4\nassert lengthOfLIS([0, 1, 0, 3, 2, 3]) == 4\nassert lengthOfLIS([7, 7, 7, 7, 7, 7, 7]) == 1\nassert lengthOfLIS([4, 10, 4, 3, 8, 9]) == 3\nassert lengthOfLIS([2, 2]) == 1\n\n[/Example 3]", "temperature": 0.733, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Hafeez", "UUID": "d695e67c-5b0e-4235-8406-30ee6be61173", "question": "N-th Tribonacci Number: The Tribonacci sequence Tn is defined as follows: \n\nT0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n >= 0.\n\nGiven n, return the value of Tn.", "examples": "Input: n = 4\nOutput: 4\nExplanation:\nT_3 = 0 + 1 + 1 = 2\nT_4 = 1 + 1 + 2 = 4", "link": "https://leetcode.com/problems/n-th-tribonacci-number/description/", "difficulty": "Easy", "categories": ["Dynamic_programming"], "code": "def tribonacci(n: int) -> int:\n    dp = {0: 0, 1: 1, 2: 1}\n    def dfs(i):\n        if i in dp:\n            return dp[i]\n        dp[i] = dfs(i - 1) + dfs(i - 2) + dfs(i - 3)\n        return dp[i]\n    \n    return dfs(n)", "asserts": ["assert tribonacci(25)==1389537", "assert tribonacci(0) == 0", "assert tribonacci(1) == 1", "assert tribonacci(2) == 1", "assert tribonacci(3) == 2", "assert tribonacci(5) == 7", "assert tribonacci(7) == 24", "assert tribonacci(10) == 149", "assert tribonacci(15) == 3136", "assert tribonacci(30) == 29249425"]}, {"author": "Hafeez", "UUID": "38dca76c-ee6c-4c71-83a9-89240828a3b7", "question": "Best Time to Buy and Sell Stock II: You are given an integer array prices where prices[i] is the price of a given stock on the ith day.\n\nOn each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day.\n\nFind and return the maximum profit you can achieve.", "examples": "Input: prices = [7,1,5,3,6,4]\nOutput: 7\nExplanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\nThen buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.\nTotal profit is 4 + 3 = 7.\nInput: prices = [7,6,4,3,1]\nOutput: 0\nExplanation: There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0.", "link": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/", "difficulty": "Medium", "categories": ["Dynamic_programming"], "code": "from typing import List\ndef maxProfit(prices: List[int]) -> int:\n    cur_hold, cur_not_hold = -float('inf'), 0\n    \n    for stock_price in prices:\n        \n        prev_hold, prev_not_hold = cur_hold, cur_not_hold\n        cur_hold = max( prev_hold, prev_not_hold - stock_price )\n        cur_not_hold = max( prev_not_hold, prev_hold + stock_price )\n    return cur_not_hold", "asserts": ["assert maxProfit([1,2,3,4,5])==4", "assert maxProfit([1,2,100,2,1]) == 99"]}], "category": "Dynamic_programming", "prompt_tokens": 693, "total_tokens": 922, "completion_tokens": 229, "completion": "Maximum Subarray: Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.\n\n###Code:\n\nfrom typing import List\n\ndef maxSubArray(nums: List[int]) -> int:\n    max_sum = current_sum = nums[0]\n    \n    for num in nums[1:]:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    \n    return max_sum\n\n###Testcases:\n\nassert maxSubArray([-2,1,-3,4,-1,2,1,-5,4]) == 6\nassert maxSubArray([1]) == 1\nassert maxSubArray([5,4,-1,7,8]) == 23\nassert maxSubArray([-2, -1, -3, -4, -1, -2, -1, -5, -4]) == -1\nassert maxSubArray([-1, -2, -3, -4, -5, -6]) == -1\n\n[/Example 3]", "temperature": 0.965, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Calvin", "UUID": "5e7011e5-fee4-4c1a-a98f-3b81e50508cc", "question": "Return nth number in the fibonacci sequence", "examples": "Input: 9\nOutput: 34\n\nInput: 7\nOutput: 13", "link": NaN, "difficulty": null, "categories": ["Dynamic_programming"], "code": "def fibonacci(n: int) -> int:\n    a = 0\n    b = 1\n    if n < 0:\n        print(\"Incorrect input\")\n    elif n == 0:\n        return a\n    elif n == 1:\n        return b\n    else:\n        for i in range(2, n+1):\n            c = a + b\n            a = b\n            b = c\n        return b\n    b = c\n    return fib(n-1, a, b)\n", "asserts": ["assert fibonacci(9) == 34", "assert fibonacci(10) == 55", "assert fibonacci(5) == 5", "assert fibonacci(2) == 1", "assert fibonacci(0) == 0", "assert fibonacci(11) == 89", "assert fibonacci(15) == 610", "assert fibonacci(20) == 6765", "assert fibonacci(25) == 75025", "assert fibonacci(3) == 2", "assert fibonacci(1) == 1", "assert fibonacci(6) == 8", "assert fibonacci(30) == 832040", "assert fibonacci(35) == 9227465", "assert fibonacci(40) == 102334155"]}, {"author": "Hafeez", "UUID": "d695e67c-5b0e-4235-8406-30ee6be61173", "question": "N-th Tribonacci Number: The Tribonacci sequence Tn is defined as follows: \n\nT0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n >= 0.\n\nGiven n, return the value of Tn.", "examples": "Input: n = 4\nOutput: 4\nExplanation:\nT_3 = 0 + 1 + 1 = 2\nT_4 = 1 + 1 + 2 = 4", "link": "https://leetcode.com/problems/n-th-tribonacci-number/description/", "difficulty": "Easy", "categories": ["Dynamic_programming"], "code": "def tribonacci(n: int) -> int:\n    dp = {0: 0, 1: 1, 2: 1}\n    def dfs(i):\n        if i in dp:\n            return dp[i]\n        dp[i] = dfs(i - 1) + dfs(i - 2) + dfs(i - 3)\n        return dp[i]\n    \n    return dfs(n)", "asserts": ["assert tribonacci(25)==1389537", "assert tribonacci(0) == 0", "assert tribonacci(1) == 1", "assert tribonacci(2) == 1", "assert tribonacci(3) == 2", "assert tribonacci(5) == 7", "assert tribonacci(7) == 24", "assert tribonacci(10) == 149", "assert tribonacci(15) == 3136", "assert tribonacci(30) == 29249425"]}], "category": "Dynamic_programming", "prompt_tokens": 735, "total_tokens": 1137, "completion_tokens": 402, "completion": "Find the minimum cost to reach the end of an array. You can move to the right or jump over elements where the cost of jumping is the absolute difference between the elements.\n\n###Code: \n\n```python\ndef minCostClimbingStairs(cost) -> int:\n    n = len(cost)\n    if n == 0:\n        return 0\n    if n == 1:\n        return cost[0]\n    dp = [0] * n\n    dp[0] = cost[0]\n    dp[1] = cost[1]\n    for i in range(2, n):\n        dp[i] = cost[i] + min(dp[i - 1], dp[i - 2])\n    return min(dp[-1], dp[-2])\n```\n\n###Testcases: \n\n```python\nassert minCostClimbingStairs([10, 15, 20]) == 15\nassert minCostClimbingStairs([1, 100, 1, 1, 1, 100, 1, 1, 100, 1]) == 6\nassert minCostClimbingStairs([1, 1, 10, 1, 10, 100]) == 12\nassert minCostClimbingStairs([1, 20, 10, 20, 10, 100]) == 51\nassert minCostClimbingStairs([15, 20, 30]) == 35\nassert minCostClimbingStairs([5, 10, 15, 20]) == 30\nassert minCostClimbingStairs([10]) == 10\nassert minCostClimbingStairs([]) == 0\nassert minCostClimbingStairs([0, 0, 0, 0, 0, 0]) == 0\n``` \n\n[/Example 3]", "temperature": 0.988, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Hafeez", "UUID": "d695e67c-5b0e-4235-8406-30ee6be61173", "question": "N-th Tribonacci Number: The Tribonacci sequence Tn is defined as follows: \n\nT0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n >= 0.\n\nGiven n, return the value of Tn.", "examples": "Input: n = 4\nOutput: 4\nExplanation:\nT_3 = 0 + 1 + 1 = 2\nT_4 = 1 + 1 + 2 = 4", "link": "https://leetcode.com/problems/n-th-tribonacci-number/description/", "difficulty": "Easy", "categories": ["Dynamic_programming"], "code": "def tribonacci(n: int) -> int:\n    dp = {0: 0, 1: 1, 2: 1}\n    def dfs(i):\n        if i in dp:\n            return dp[i]\n        dp[i] = dfs(i - 1) + dfs(i - 2) + dfs(i - 3)\n        return dp[i]\n    \n    return dfs(n)", "asserts": ["assert tribonacci(25)==1389537", "assert tribonacci(0) == 0", "assert tribonacci(1) == 1", "assert tribonacci(2) == 1", "assert tribonacci(3) == 2", "assert tribonacci(5) == 7", "assert tribonacci(7) == 24", "assert tribonacci(10) == 149", "assert tribonacci(15) == 3136", "assert tribonacci(30) == 29249425"]}, {"author": "Calvin", "UUID": "e35d1110-85e8-4f50-80aa-91eb976b310b", "question": "Return the factorial of a given number n", "examples": "Input: 5\nOutput: 120\n\nInput: 6\nOutput: 720", "link": NaN, "difficulty": null, "categories": ["Dynamic_programming"], "code": "\ndef fact(n: int) -> int:\n  if n <= 1:\n    return 1\n  return n*fact(n-1)\n", "asserts": ["assert fact(5) == 120", "assert fact(0) == 1", "assert fact(1) == 1", "assert fact(3) == 6", "assert fact(7) == 5040", "assert fact(10) == 3628800", "assert fact(4) == 24", "assert fact(8) == 40320", "assert fact(2) == 2", "assert fact(11) == 39916800"]}], "category": "Dynamic_programming", "prompt_tokens": 612, "total_tokens": 925, "completion_tokens": 313, "completion": "Find the maximum sum of a subarray within a given array of integers.\n\n###Code:\n\n```python\ndef maxSubArray(nums: List[int]) -> int:\n    for i in range(1, len(nums)):\n        if nums[i-1] > 0:\n            nums[i] += nums[i-1]\n    return max(nums)\n```\n\n###Testcases:\n\n```python\nassert maxSubArray([-2,1,-3,4,-1,2,1,-5,4]) == 6\nassert maxSubArray([1]) == 1\nassert maxSubArray([5,4,-1,7,8]) == 23\nassert maxSubArray([-2, -3, 4, -1, -2, 1, 5, -3]) == 7\nassert maxSubArray([-1, -1, -2, -2]) == -1\nassert maxSubArray([1, -1, 1, -1]) == 1\nassert maxSubArray([-2, -1, -3, -4, -1, -2, -1, -5, -4]) == -1\nassert maxSubArray([1, 2, 3, 4, 5]) == 15\nassert maxSubArray([-1, -2, -3, -4, -5]) == -1\nassert maxSubArray([2, 3, -1, -20, 10]) == 12\n```", "temperature": 0.865, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Hafeez", "UUID": "6aaf1310-7585-4d90-91e7-1f405c9b25e7", "question": "Get Maximum in Generated Array: You are given an integer n. A 0-indexed integer array nums of length n + 1 is generated in the following way:\n\nnums[0] = 0\nnums[1] = 1\nnums[2 * i] = nums[i] when 2 <= 2 * i <= n\nnums[2 * i + 1] = nums[i] + nums[i + 1] when 2 <= 2 * i + 1 <= n\nReturn the maximum integer in the array nums\u200b\u200b\u200b.", "examples": "Input: n = 7\nOutput: 3\nExplanation: According to the given rules:\n  nums[0] = 0\n  nums[1] = 1\n  nums[(1 * 2) = 2] = nums[1] = 1\n  nums[(1 * 2) + 1 = 3] = nums[1] + nums[2] = 1 + 1 = 2\n  nums[(2 * 2) = 4] = nums[2] = 1\n  nums[(2 * 2) + 1 = 5] = nums[2] + nums[3] = 1 + 2 = 3\n  nums[(3 * 2) = 6] = nums[3] = 2\n  nums[(3 * 2) + 1 = 7] = nums[3] + nums[4] = 2 + 1 = 3\nHence, nums = [0,1,1,2,1,3,2,3], and the maximum is max(0,1,1,2,1,3,2,3) = 3.\nInput: n = 2\nOutput: 1\nExplanation: According to the given rules, nums = [0,1,1]. The maximum is max(0,1,1) = 1.\nInput: n = 3\nOutput: 2\nExplanation: According to the given rules, nums = [0,1,1,2]. The maximum is max(0,1,1,2) = 2.", "link": "https://leetcode.com/problems/get-maximum-in-generated-array/", "difficulty": "Easy", "categories": ["Dynamic_programming"], "code": "def getMaximumGenerated(n: int) -> int:\n    if n<2:\n        return n\n    nums=[0]*(n+1)\n    nums[0]=0\n    nums[1]=1\n    for i in range(2,n+1):\n        if i%2==0:\n            nums[i]=nums[i//2]\n        else:\n            nums[i]=nums[i//2]+nums[i//2+1]\n    return max(nums)", "asserts": ["assert getMaximumGenerated(2)==1", "assert getMaximumGenerated(4) == 2", "assert getMaximumGenerated(5) == 3", "assert getMaximumGenerated(8) == 3", "assert getMaximumGenerated(15) == 5", "assert getMaximumGenerated(0) == 0", "assert getMaximumGenerated(1) == 1"]}, {"author": "Calvin", "UUID": "51a5caf9-241f-4de3-9ee2-9420490b73d7", "question": "Given a set[] of non-negative integers and a value sum, return the subset of the given set whose sum is equal to the given sum or None if one doesn't exist\n", "examples": "Input: set = [1, 2, 3, 4, 5], sum = 10\nOutput: [1, 2, 3, 4]", "link": "https://www.geeksforgeeks.org/subset-sum-problem-dp-25/", "difficulty": null, "categories": ["Dynamic_programming"], "code": "def subsetsum(fullset: list, target_sum: int) -> set:\n    def subsetSum_helper(cur_idx: int, fullset: list, target_sum: int, subset: list):\n        if target_sum == 0:\n            return subset\n        if (cur_idx == len(fullset)):\n            return None\n        excluding = subsetSum_helper(cur_idx + 1, fullset, target_sum, subset)\n          \n        if excluding is not None:\n            return excluding\n        elif fullset[cur_idx] <= target_sum:\n            subset.append(fullset[cur_idx])\n            including = subsetSum_helper(cur_idx + 1, fullset, target_sum - fullset[cur_idx], subset)\n            if including!=None:\n                return including\n            else:\n                subset.pop()\n            return None\n    return subsetSum_helper(0, fullset, target_sum, [])\n", "asserts": ["assert set(subsetsum([3, 34, 4, 12, 5, 2], 9)) == {4,5}", "assert subsetsum([1, 8, 2, 7, 4], 14) == [8, 2, 4]", "assert subsetsum([10, 12, 15, 6, 19], 21) == [15, 6]", "assert subsetsum([5, 10, 12, 13, 15, 18], 30) == [12, 18]", "assert subsetsum([5, 3, 9, 12, 6, 15], 27) == [12, 15]", "assert subsetsum([2, 3, 7, 8, 10], 11) == [3, 8]", "assert subsetsum([6, 2, 7, 11, 8], 16) == [6, 2, 8]", "assert subsetsum([5, 7, 1, 14, 6], 13) == [7, 6]", "assert subsetsum([1], 1) == [1]", "assert subsetsum([2, 5, 8, 4], 0) == []", "assert subsetsum([], 5) == None", "assert subsetsum([-1, -2, -3, -4, -5], -10) == None  # Negative numbers are not allowed according to the question", "assert subsetsum([4, 1, 2, 5, 12, 7], 9) == [2, 7]", "assert subsetsum([3, 5, 8, 4], 22) == None  # Sum exceeds the sum of all elements"]}], "category": "Dynamic_programming", "prompt_tokens": 1102, "total_tokens": 1413, "completion_tokens": 311, "completion": "Find the length of the longest increasing subsequence in the given list of integers.\n\n###Code: \n\ndef lengthOfLIS(nums: list) -> int:\n    if not nums:\n        return 0\n    dp = [1] * len(nums)\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n\n###Testcases: \n\nassert lengthOfLIS([10, 9, 2, 5, 3, 7, 101, 18]) == 4\nassert lengthOfLIS([0, 1, 0, 3, 2, 3]) == 4\nassert lengthOfLIS([7, 7, 7, 7, 7, 7, 7]) == 1\nassert lengthOfLIS([4, 10, 4, 3, 8, 9]) == 3\nassert lengthOfLIS([1, 3, 6, 7, 9, 4, 10, 5, 6]) == 6\nassert lengthOfLIS([1, 2, 3, 4, 5]) == 5\nassert lengthOfLIS([5, 4, 3, 2, 1]) == 1\n\n[/Example 3]", "temperature": 0.668, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Hafeez", "UUID": "38dca76c-ee6c-4c71-83a9-89240828a3b7", "question": "Best Time to Buy and Sell Stock II: You are given an integer array prices where prices[i] is the price of a given stock on the ith day.\n\nOn each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day.\n\nFind and return the maximum profit you can achieve.", "examples": "Input: prices = [7,1,5,3,6,4]\nOutput: 7\nExplanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\nThen buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.\nTotal profit is 4 + 3 = 7.\nInput: prices = [7,6,4,3,1]\nOutput: 0\nExplanation: There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0.", "link": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/", "difficulty": "Medium", "categories": ["Dynamic_programming"], "code": "from typing import List\ndef maxProfit(prices: List[int]) -> int:\n    cur_hold, cur_not_hold = -float('inf'), 0\n    \n    for stock_price in prices:\n        \n        prev_hold, prev_not_hold = cur_hold, cur_not_hold\n        cur_hold = max( prev_hold, prev_not_hold - stock_price )\n        cur_not_hold = max( prev_not_hold, prev_hold + stock_price )\n    return cur_not_hold", "asserts": ["assert maxProfit([1,2,3,4,5])==4", "assert maxProfit([1,2,100,2,1]) == 99"]}, {"author": "Calvin", "UUID": "51a5caf9-241f-4de3-9ee2-9420490b73d7", "question": "Given a set[] of non-negative integers and a value sum, return the subset of the given set whose sum is equal to the given sum or None if one doesn't exist\n", "examples": "Input: set = [1, 2, 3, 4, 5], sum = 10\nOutput: [1, 2, 3, 4]", "link": "https://www.geeksforgeeks.org/subset-sum-problem-dp-25/", "difficulty": null, "categories": ["Dynamic_programming"], "code": "def subsetsum(fullset: list, target_sum: int) -> set:\n    def subsetSum_helper(cur_idx: int, fullset: list, target_sum: int, subset: list):\n        if target_sum == 0:\n            return subset\n        if (cur_idx == len(fullset)):\n            return None\n        excluding = subsetSum_helper(cur_idx + 1, fullset, target_sum, subset)\n          \n        if excluding is not None:\n            return excluding\n        elif fullset[cur_idx] <= target_sum:\n            subset.append(fullset[cur_idx])\n            including = subsetSum_helper(cur_idx + 1, fullset, target_sum - fullset[cur_idx], subset)\n            if including!=None:\n                return including\n            else:\n                subset.pop()\n            return None\n    return subsetSum_helper(0, fullset, target_sum, [])\n", "asserts": ["assert set(subsetsum([3, 34, 4, 12, 5, 2], 9)) == {4,5}", "assert subsetsum([1, 8, 2, 7, 4], 14) == [8, 2, 4]", "assert subsetsum([10, 12, 15, 6, 19], 21) == [15, 6]", "assert subsetsum([5, 10, 12, 13, 15, 18], 30) == [12, 18]", "assert subsetsum([5, 3, 9, 12, 6, 15], 27) == [12, 15]", "assert subsetsum([2, 3, 7, 8, 10], 11) == [3, 8]", "assert subsetsum([6, 2, 7, 11, 8], 16) == [6, 2, 8]", "assert subsetsum([5, 7, 1, 14, 6], 13) == [7, 6]", "assert subsetsum([1], 1) == [1]", "assert subsetsum([2, 5, 8, 4], 0) == []", "assert subsetsum([], 5) == None", "assert subsetsum([-1, -2, -3, -4, -5], -10) == None  # Negative numbers are not allowed according to the question", "assert subsetsum([4, 1, 2, 5, 12, 7], 9) == [2, 7]", "assert subsetsum([3, 5, 8, 4], 22) == None  # Sum exceeds the sum of all elements"]}], "category": "Dynamic_programming", "prompt_tokens": 1031, "total_tokens": 1660, "completion_tokens": 629, "completion": "Given a string s, partition s such that every substring of the partition is a palindrome. Return all possible palindrome partitioning of s.\n\nA palindrome is a string that reads the same forward and backward.\n\n###Code: \n\nfrom typing import List\ndef partition(s: str) -> List[List[str]]:\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n    \n    def backtrack(start: int, path: List[str]):\n        if start == len(s):\n            result.append(path[:])\n        \n        for end in range(start + 1, len(s) + 1):\n            if is_palindrome(s[start:end]):\n                path.append(s[start:end])\n                backtrack(end, path)\n                path.pop()\n    \n    result = []\n    backtrack(0, [])\n    return result\n\n###Testcases: \n\nassert partition(\"aab\") == [['a', 'a', 'b'], ['aa', 'b']]\nassert partition(\"a\") == [['a']]\nassert partition(\"racecar\") == [['r', 'a', 'c', 'e', 'c', 'a', 'r'], ['r', 'aceca', 'r'], ['racecar']]\nassert partition(\"abba\") == [['a', 'b', 'b', 'a'], ['a', 'bb', 'a'], ['abba']]\nassert partition(\"aabba\") == [['a', 'a', 'b', 'b', 'a'], ['a', 'a', 'bb', 'a'], ['a', 'abba'], ['aa', 'b', 'b', 'a'], ['aa', 'bb', 'a']]\nassert partition(\"abcba\") == [['a', 'b', 'c', 'b', 'a'], ['a', 'bcb', 'a'], ['abcba']]\nassert partition(\"aaa\") == [['a', 'a', 'a'], ['a', 'aa'], ['aaa']]\nassert partition(\"aaaaa\") == [['a', 'a', 'a', 'a', 'a'], ['a', 'a', 'a', 'aa'], ['a', 'a', 'aa', 'a'], ['a', 'aa', 'a', 'a'], ['a', 'aa', 'aa'], ['aa', 'a', 'a', 'a'], ['aa', 'a', 'aa'], ['aa', 'aa', 'a'], ['aaaa', 'a'], ['aaaaa']]\nassert partition(\"apple\") == [['a', 'p', 'p', 'l', 'e'], ['a', 'pp', 'l', 'e'], ['ap', 'p', 'l', 'e'], ['app', 'l', 'e']]\nassert partition(\"banana\") == [['b', 'a', 'n', 'a', 'n', 'a'], ['b', 'ana', 'n', 'a'], ['b', 'anana'], ['banan', 'a', 'n', 'a'], ['banan', 'ana'], ['banana']]\n\n[/Example 3]", "temperature": 0.837, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Hafeez", "UUID": "296ab89e-7208-4f6f-bed1-d623f30e32c9", "question": "Coin Change II: You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.\n\nReturn the number of combinations that make up that amount. If that amount of money cannot be made up by any combination of the coins, return 0.\n\nYou may assume that you have an infinite number of each kind of coin.\n\nThe answer is guaranteed to fit into a signed 32-bit integer.", "examples": "Input: amount = 5, coins = [1,2,5]\nOutput: 4\nExplanation: there are four ways to make up the amount:\n5=5\n5=2+2+1\n5=2+1+1+1\n5=1+1+1+1+1\nInput: amount = 3, coins = [2]\nOutput: 0\nExplanation: the amount of 3 cannot be made up just with coins of 2.", "link": "https://leetcode.com/problems/coin-change-ii/description/", "difficulty": "Medium", "categories": ["Dynamic_programming"], "code": "from typing import List\ndef change(amount: int, coins: List[int]) -> int:\n    def numberOfWays(i: int, amount: int) -> int:\n        if amount == 0:\n            return 1\n        if i == len(coins):\n            return 0\n        if memo[i][amount] != -1:\n            return memo[i][amount]\n\n        if coins[i] > amount:\n            memo[i][amount] = numberOfWays(i + 1, amount)\n        else:\n            memo[i][amount] = numberOfWays(i, amount - coins[i]) + numberOfWays(i + 1, amount)\n        \n        return memo[i][amount]\n\n    memo = [[-1] * (amount + 1) for _ in range(len(coins))]\n    return numberOfWays(0, amount)", "asserts": ["assert change(10,[10])==1", "assert change(0, [1, 2, 5]) == 1  # Edge case: trying to make 0 with any coins should always return 1", "assert change(11, [5]) == 0  # Amount cannot be made up with given coins", "assert change(0, []) == 1  # Edge case: trying to make 0 without any coins, should return 1 as there's one way of making 0 with no coins", "assert change(5, [5, 1]) == 2  # Amount can be made with given coins: [5], [1, 1, 1, 1, 1]"]}, {"author": "Calvin", "UUID": "51a5caf9-241f-4de3-9ee2-9420490b73d7", "question": "Given a set[] of non-negative integers and a value sum, return the subset of the given set whose sum is equal to the given sum or None if one doesn't exist\n", "examples": "Input: set = [1, 2, 3, 4, 5], sum = 10\nOutput: [1, 2, 3, 4]", "link": "https://www.geeksforgeeks.org/subset-sum-problem-dp-25/", "difficulty": null, "categories": ["Dynamic_programming"], "code": "def subsetsum(fullset: list, target_sum: int) -> set:\n    def subsetSum_helper(cur_idx: int, fullset: list, target_sum: int, subset: list):\n        if target_sum == 0:\n            return subset\n        if (cur_idx == len(fullset)):\n            return None\n        excluding = subsetSum_helper(cur_idx + 1, fullset, target_sum, subset)\n          \n        if excluding is not None:\n            return excluding\n        elif fullset[cur_idx] <= target_sum:\n            subset.append(fullset[cur_idx])\n            including = subsetSum_helper(cur_idx + 1, fullset, target_sum - fullset[cur_idx], subset)\n            if including!=None:\n                return including\n            else:\n                subset.pop()\n            return None\n    return subsetSum_helper(0, fullset, target_sum, [])\n", "asserts": ["assert set(subsetsum([3, 34, 4, 12, 5, 2], 9)) == {4,5}", "assert subsetsum([1, 8, 2, 7, 4], 14) == [8, 2, 4]", "assert subsetsum([10, 12, 15, 6, 19], 21) == [15, 6]", "assert subsetsum([5, 10, 12, 13, 15, 18], 30) == [12, 18]", "assert subsetsum([5, 3, 9, 12, 6, 15], 27) == [12, 15]", "assert subsetsum([2, 3, 7, 8, 10], 11) == [3, 8]", "assert subsetsum([6, 2, 7, 11, 8], 16) == [6, 2, 8]", "assert subsetsum([5, 7, 1, 14, 6], 13) == [7, 6]", "assert subsetsum([1], 1) == [1]", "assert subsetsum([2, 5, 8, 4], 0) == []", "assert subsetsum([], 5) == None", "assert subsetsum([-1, -2, -3, -4, -5], -10) == None  # Negative numbers are not allowed according to the question", "assert subsetsum([4, 1, 2, 5, 12, 7], 9) == [2, 7]", "assert subsetsum([3, 5, 8, 4], 22) == None  # Sum exceeds the sum of all elements"]}], "category": "Dynamic_programming", "prompt_tokens": 1226, "total_tokens": 1643, "completion_tokens": 417, "completion": "Find the length of the longest increasing subsequence of a given array of integers.\n\n###Code:\n\n```python\nfrom typing import List\ndef lengthOfLIS(nums: List[int]) -> int:\n    if not nums:\n        return 0\n    \n    dp = [1] * len(nums)\n    \n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    \n    return max(dp)\n```\n\n###Testcases:\n\n```python\nassert lengthOfLIS([10, 9, 2, 5, 3, 7, 101, 18]) == 4  # The longest increasing subsequence is [2, 3, 7, 101], so the length is 4\nassert lengthOfLIS([0, 1, 0, 3, 2, 3]) == 4  # The longest increasing subsequence is [0, 1, 2, 3], so the length is 4\nassert lengthOfLIS([7, 7, 7, 7, 7, 7, 7]) == 1  # The longest increasing subsequence is [7], so the length is 1\nassert lengthOfLIS([4, 10, 4, 3, 8, 9]) == 3  # The longest increasing subsequence is [4, 8, 9], so the length is 3\nassert lengthOfLIS([]) == 0  # Empty array\nassert lengthOfLIS([5]) == 1  # Only one element\nassert lengthOfLIS([5, 8, 3, 7, 9, 1]) == 3  # The longest increasing subsequence is [5, 7, 9], so the length is 3\n```\n\n[/Example 3]", "temperature": 0.959, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Calvin", "UUID": "5e7011e5-fee4-4c1a-a98f-3b81e50508cc", "question": "Return nth number in the fibonacci sequence", "examples": "Input: 9\nOutput: 34\n\nInput: 7\nOutput: 13", "link": NaN, "difficulty": null, "categories": ["Dynamic_programming"], "code": "def fibonacci(n: int) -> int:\n    a = 0\n    b = 1\n    if n < 0:\n        print(\"Incorrect input\")\n    elif n == 0:\n        return a\n    elif n == 1:\n        return b\n    else:\n        for i in range(2, n+1):\n            c = a + b\n            a = b\n            b = c\n        return b\n    b = c\n    return fib(n-1, a, b)\n", "asserts": ["assert fibonacci(9) == 34", "assert fibonacci(10) == 55", "assert fibonacci(5) == 5", "assert fibonacci(2) == 1", "assert fibonacci(0) == 0", "assert fibonacci(11) == 89", "assert fibonacci(15) == 610", "assert fibonacci(20) == 6765", "assert fibonacci(25) == 75025", "assert fibonacci(3) == 2", "assert fibonacci(1) == 1", "assert fibonacci(6) == 8", "assert fibonacci(30) == 832040", "assert fibonacci(35) == 9227465", "assert fibonacci(40) == 102334155"]}, {"author": "Calvin", "UUID": "e35d1110-85e8-4f50-80aa-91eb976b310b", "question": "Return the factorial of a given number n", "examples": "Input: 5\nOutput: 120\n\nInput: 6\nOutput: 720", "link": NaN, "difficulty": null, "categories": ["Dynamic_programming"], "code": "\ndef fact(n: int) -> int:\n  if n <= 1:\n    return 1\n  return n*fact(n-1)\n", "asserts": ["assert fact(5) == 120", "assert fact(0) == 1", "assert fact(1) == 1", "assert fact(3) == 6", "assert fact(7) == 5040", "assert fact(10) == 3628800", "assert fact(4) == 24", "assert fact(8) == 40320", "assert fact(2) == 2", "assert fact(11) == 39916800"]}], "category": "Dynamic_programming", "prompt_tokens": 614, "total_tokens": 1001, "completion_tokens": 387, "completion": "Find the maximum sum of a subarray within an array of integers\n\n###Code: \n\n```python\ndef max_subarray_sum(arr: List[int]) -> int:\n    max_sum = arr[0]\n    current_sum = arr[0]\n    \n    for num in arr[1:]:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n        \n    return max_sum\n```\n\n###Testcases: \n\n```python\nassert max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) == 6\nassert max_subarray_sum([1]) == 1\nassert max_subarray_sum([5, 4, -1, 7, 8]) == 23\nassert max_subarray_sum([-2, -3, 4, -1, -2, 1, 5, -3]) == 7\nassert max_subarray_sum([-2, -1, -3, -4, -1, -2, -1, -5, -4]) == -1\nassert max_subarray_sum([1, 2, 3, 4, 5]) == 15\nassert max_subarray_sum([-1, -2, -3, -4, -5]) == -1\nassert max_subarray_sum([2, 3, -1, -20, 5, 10]) == 15\nassert max_subarray_sum([-1, 3, -5, 4, 6, -1, 2, -7, 13, -3]) == 19\nassert max_subarray_sum([5, -2, 7, -3, 2, 8, -4, -5]) == 16\n```", "temperature": 0.701, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Calvin", "UUID": "e35d1110-85e8-4f50-80aa-91eb976b310b", "question": "Return the factorial of a given number n", "examples": "Input: 5\nOutput: 120\n\nInput: 6\nOutput: 720", "link": NaN, "difficulty": null, "categories": ["Dynamic_programming"], "code": "\ndef fact(n: int) -> int:\n  if n <= 1:\n    return 1\n  return n*fact(n-1)\n", "asserts": ["assert fact(5) == 120", "assert fact(0) == 1", "assert fact(1) == 1", "assert fact(3) == 6", "assert fact(7) == 5040", "assert fact(10) == 3628800", "assert fact(4) == 24", "assert fact(8) == 40320", "assert fact(2) == 2", "assert fact(11) == 39916800"]}, {"author": "Hafeez", "UUID": "296ab89e-7208-4f6f-bed1-d623f30e32c9", "question": "Coin Change II: You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.\n\nReturn the number of combinations that make up that amount. If that amount of money cannot be made up by any combination of the coins, return 0.\n\nYou may assume that you have an infinite number of each kind of coin.\n\nThe answer is guaranteed to fit into a signed 32-bit integer.", "examples": "Input: amount = 5, coins = [1,2,5]\nOutput: 4\nExplanation: there are four ways to make up the amount:\n5=5\n5=2+2+1\n5=2+1+1+1\n5=1+1+1+1+1\nInput: amount = 3, coins = [2]\nOutput: 0\nExplanation: the amount of 3 cannot be made up just with coins of 2.", "link": "https://leetcode.com/problems/coin-change-ii/description/", "difficulty": "Medium", "categories": ["Dynamic_programming"], "code": "from typing import List\ndef change(amount: int, coins: List[int]) -> int:\n    def numberOfWays(i: int, amount: int) -> int:\n        if amount == 0:\n            return 1\n        if i == len(coins):\n            return 0\n        if memo[i][amount] != -1:\n            return memo[i][amount]\n\n        if coins[i] > amount:\n            memo[i][amount] = numberOfWays(i + 1, amount)\n        else:\n            memo[i][amount] = numberOfWays(i, amount - coins[i]) + numberOfWays(i + 1, amount)\n        \n        return memo[i][amount]\n\n    memo = [[-1] * (amount + 1) for _ in range(len(coins))]\n    return numberOfWays(0, amount)", "asserts": ["assert change(10,[10])==1", "assert change(0, [1, 2, 5]) == 1  # Edge case: trying to make 0 with any coins should always return 1", "assert change(11, [5]) == 0  # Amount cannot be made up with given coins", "assert change(0, []) == 1  # Edge case: trying to make 0 without any coins, should return 1 as there's one way of making 0 with no coins", "assert change(5, [5, 1]) == 2  # Amount can be made with given coins: [5], [1, 1, 1, 1, 1]"]}], "category": "Dynamic_programming", "prompt_tokens": 767, "total_tokens": 1048, "completion_tokens": 281, "completion": "Return the minimum number of coins required to make up a given amount. You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.\n\n###Code: \n\nfrom typing import List\n\ndef minCoins(amount: int, coins: List[int]) -> int:\n    dp = [float('inf')] * (amount + 1)\n    dp[0] = 0\n\n    for coin in coins:\n        for i in range(coin, amount + 1):\n            dp[i] = min(dp[i], dp[i - coin] + 1)\n\n    return dp[amount]\n\n###Testcases: \n\nassert minCoins(11, [1, 2, 5]) == 3  # For amount 11, we need 1 coin of 5 and 3 coins of 2.\nassert minCoins(0, [1, 2, 5]) == 0  # Minimum coins required for amount 0 is 0.\nassert minCoins(3, [2]) == -1  # As no combination of coins can make 3, expected output is -1.\nassert minCoins(5, [1, 2, 5]) == 1  # For amount 5, we can directly use 1 coin of 5 to make it up.\n\n[/Example 3]", "temperature": 0.922, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Calvin", "UUID": "5e7011e5-fee4-4c1a-a98f-3b81e50508cc", "question": "Return nth number in the fibonacci sequence", "examples": "Input: 9\nOutput: 34\n\nInput: 7\nOutput: 13", "link": NaN, "difficulty": null, "categories": ["Dynamic_programming"], "code": "def fibonacci(n: int) -> int:\n    a = 0\n    b = 1\n    if n < 0:\n        print(\"Incorrect input\")\n    elif n == 0:\n        return a\n    elif n == 1:\n        return b\n    else:\n        for i in range(2, n+1):\n            c = a + b\n            a = b\n            b = c\n        return b\n    b = c\n    return fib(n-1, a, b)\n", "asserts": ["assert fibonacci(9) == 34", "assert fibonacci(10) == 55", "assert fibonacci(5) == 5", "assert fibonacci(2) == 1", "assert fibonacci(0) == 0", "assert fibonacci(11) == 89", "assert fibonacci(15) == 610", "assert fibonacci(20) == 6765", "assert fibonacci(25) == 75025", "assert fibonacci(3) == 2", "assert fibonacci(1) == 1", "assert fibonacci(6) == 8", "assert fibonacci(30) == 832040", "assert fibonacci(35) == 9227465", "assert fibonacci(40) == 102334155"]}, {"author": "Hafeez", "UUID": "6aaf1310-7585-4d90-91e7-1f405c9b25e7", "question": "Get Maximum in Generated Array: You are given an integer n. A 0-indexed integer array nums of length n + 1 is generated in the following way:\n\nnums[0] = 0\nnums[1] = 1\nnums[2 * i] = nums[i] when 2 <= 2 * i <= n\nnums[2 * i + 1] = nums[i] + nums[i + 1] when 2 <= 2 * i + 1 <= n\nReturn the maximum integer in the array nums\u200b\u200b\u200b.", "examples": "Input: n = 7\nOutput: 3\nExplanation: According to the given rules:\n  nums[0] = 0\n  nums[1] = 1\n  nums[(1 * 2) = 2] = nums[1] = 1\n  nums[(1 * 2) + 1 = 3] = nums[1] + nums[2] = 1 + 1 = 2\n  nums[(2 * 2) = 4] = nums[2] = 1\n  nums[(2 * 2) + 1 = 5] = nums[2] + nums[3] = 1 + 2 = 3\n  nums[(3 * 2) = 6] = nums[3] = 2\n  nums[(3 * 2) + 1 = 7] = nums[3] + nums[4] = 2 + 1 = 3\nHence, nums = [0,1,1,2,1,3,2,3], and the maximum is max(0,1,1,2,1,3,2,3) = 3.\nInput: n = 2\nOutput: 1\nExplanation: According to the given rules, nums = [0,1,1]. The maximum is max(0,1,1) = 1.\nInput: n = 3\nOutput: 2\nExplanation: According to the given rules, nums = [0,1,1,2]. The maximum is max(0,1,1,2) = 2.", "link": "https://leetcode.com/problems/get-maximum-in-generated-array/", "difficulty": "Easy", "categories": ["Dynamic_programming"], "code": "def getMaximumGenerated(n: int) -> int:\n    if n<2:\n        return n\n    nums=[0]*(n+1)\n    nums[0]=0\n    nums[1]=1\n    for i in range(2,n+1):\n        if i%2==0:\n            nums[i]=nums[i//2]\n        else:\n            nums[i]=nums[i//2]+nums[i//2+1]\n    return max(nums)", "asserts": ["assert getMaximumGenerated(2)==1", "assert getMaximumGenerated(4) == 2", "assert getMaximumGenerated(5) == 3", "assert getMaximumGenerated(8) == 3", "assert getMaximumGenerated(15) == 5", "assert getMaximumGenerated(0) == 0", "assert getMaximumGenerated(1) == 1"]}], "category": "Dynamic_programming", "prompt_tokens": 766, "total_tokens": 1173, "completion_tokens": 407, "completion": "Calculate the minimum cost to reach the last cell of a grid, starting from the top-left cell. You can only move either down or right at any point in time.\n\n###Code:\n\n```python\ndef minCost(grid: List[List[int]]) -> int:\n    m, n = len(grid), len(grid[0])\n    \n    # Initialize a cost grid with 0s\n    cost = [[0] * n for _ in range(m)]\n    \n    # Initialize the first cell's cost\n    cost[0][0] = grid[0][0]\n    \n    # Calculate the cost for the first row\n    for i in range(1, n):\n        cost[0][i] = cost[0][i-1] + grid[0][i]\n        \n    # Calculate the cost for the first column\n    for i in range(1, m):\n        cost[i][0] = cost[i-1][0] + grid[i][0]\n        \n    # Calculate the cost for the rest of the cells\n    for i in range(1, m):\n        for j in range(1, n):\n            cost[i][j] = min(cost[i-1][j], cost[i][j-1]) + grid[i][j]\n            \n    return cost[m-1][n-1]\n```\n\n###Testcases:\n\n```python\nassert minCost([[1,3,1],[1,5,1],[4,2,1]]) == 7\nassert minCost([[1,2,3],[4,5,6]]) == 12\nassert minCost([[1,2],[3,4]]) == 7\nassert minCost([[1,2,3],[4,5,6],[7,8,9]]) == 21\nassert minCost([[1]]) == 1\nassert minCost([[1,2,5],[3,2,1]]) == 6\n```\n\n[/Example 3]", "temperature": 0.941, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Hafeez", "UUID": "6aaf1310-7585-4d90-91e7-1f405c9b25e7", "question": "Get Maximum in Generated Array: You are given an integer n. A 0-indexed integer array nums of length n + 1 is generated in the following way:\n\nnums[0] = 0\nnums[1] = 1\nnums[2 * i] = nums[i] when 2 <= 2 * i <= n\nnums[2 * i + 1] = nums[i] + nums[i + 1] when 2 <= 2 * i + 1 <= n\nReturn the maximum integer in the array nums\u200b\u200b\u200b.", "examples": "Input: n = 7\nOutput: 3\nExplanation: According to the given rules:\n  nums[0] = 0\n  nums[1] = 1\n  nums[(1 * 2) = 2] = nums[1] = 1\n  nums[(1 * 2) + 1 = 3] = nums[1] + nums[2] = 1 + 1 = 2\n  nums[(2 * 2) = 4] = nums[2] = 1\n  nums[(2 * 2) + 1 = 5] = nums[2] + nums[3] = 1 + 2 = 3\n  nums[(3 * 2) = 6] = nums[3] = 2\n  nums[(3 * 2) + 1 = 7] = nums[3] + nums[4] = 2 + 1 = 3\nHence, nums = [0,1,1,2,1,3,2,3], and the maximum is max(0,1,1,2,1,3,2,3) = 3.\nInput: n = 2\nOutput: 1\nExplanation: According to the given rules, nums = [0,1,1]. The maximum is max(0,1,1) = 1.\nInput: n = 3\nOutput: 2\nExplanation: According to the given rules, nums = [0,1,1,2]. The maximum is max(0,1,1,2) = 2.", "link": "https://leetcode.com/problems/get-maximum-in-generated-array/", "difficulty": "Easy", "categories": ["Dynamic_programming"], "code": "def getMaximumGenerated(n: int) -> int:\n    if n<2:\n        return n\n    nums=[0]*(n+1)\n    nums[0]=0\n    nums[1]=1\n    for i in range(2,n+1):\n        if i%2==0:\n            nums[i]=nums[i//2]\n        else:\n            nums[i]=nums[i//2]+nums[i//2+1]\n    return max(nums)", "asserts": ["assert getMaximumGenerated(2)==1", "assert getMaximumGenerated(4) == 2", "assert getMaximumGenerated(5) == 3", "assert getMaximumGenerated(8) == 3", "assert getMaximumGenerated(15) == 5", "assert getMaximumGenerated(0) == 0", "assert getMaximumGenerated(1) == 1"]}, {"author": "Hafeez", "UUID": "d695e67c-5b0e-4235-8406-30ee6be61173", "question": "N-th Tribonacci Number: The Tribonacci sequence Tn is defined as follows: \n\nT0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n >= 0.\n\nGiven n, return the value of Tn.", "examples": "Input: n = 4\nOutput: 4\nExplanation:\nT_3 = 0 + 1 + 1 = 2\nT_4 = 1 + 1 + 2 = 4", "link": "https://leetcode.com/problems/n-th-tribonacci-number/description/", "difficulty": "Easy", "categories": ["Dynamic_programming"], "code": "def tribonacci(n: int) -> int:\n    dp = {0: 0, 1: 1, 2: 1}\n    def dfs(i):\n        if i in dp:\n            return dp[i]\n        dp[i] = dfs(i - 1) + dfs(i - 2) + dfs(i - 3)\n        return dp[i]\n    \n    return dfs(n)", "asserts": ["assert tribonacci(25)==1389537", "assert tribonacci(0) == 0", "assert tribonacci(1) == 1", "assert tribonacci(2) == 1", "assert tribonacci(3) == 2", "assert tribonacci(5) == 7", "assert tribonacci(7) == 24", "assert tribonacci(10) == 149", "assert tribonacci(15) == 3136", "assert tribonacci(30) == 29249425"]}], "category": "Dynamic_programming", "prompt_tokens": 764, "total_tokens": 964, "completion_tokens": 200, "completion": "Maximum Subarray: Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.\n\n###Code: \n\n```python\ndef maxSubArray(nums: List[int]) -> int:\n    max_sum = current_sum = nums[0]\n    for num in nums[1:]:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    return max_sum\n```\n\n###Testcases: \n\n```python\nassert maxSubArray([-2,1,-3,4,-1,2,1,-5,4]) == 6\nassert maxSubArray([1]) == 1\nassert maxSubArray([5,4,-1,7,8]) == 23\nassert maxSubArray([-2,-1,-3,-4,-1,-2,-1,-5,-4]) == -1\n```\n\n[/Example 3]", "temperature": 0.814, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Calvin", "UUID": "51a5caf9-241f-4de3-9ee2-9420490b73d7", "question": "Given a set[] of non-negative integers and a value sum, return the subset of the given set whose sum is equal to the given sum or None if one doesn't exist\n", "examples": "Input: set = [1, 2, 3, 4, 5], sum = 10\nOutput: [1, 2, 3, 4]", "link": "https://www.geeksforgeeks.org/subset-sum-problem-dp-25/", "difficulty": null, "categories": ["Dynamic_programming"], "code": "def subsetsum(fullset: list, target_sum: int) -> set:\n    def subsetSum_helper(cur_idx: int, fullset: list, target_sum: int, subset: list):\n        if target_sum == 0:\n            return subset\n        if (cur_idx == len(fullset)):\n            return None\n        excluding = subsetSum_helper(cur_idx + 1, fullset, target_sum, subset)\n          \n        if excluding is not None:\n            return excluding\n        elif fullset[cur_idx] <= target_sum:\n            subset.append(fullset[cur_idx])\n            including = subsetSum_helper(cur_idx + 1, fullset, target_sum - fullset[cur_idx], subset)\n            if including!=None:\n                return including\n            else:\n                subset.pop()\n            return None\n    return subsetSum_helper(0, fullset, target_sum, [])\n", "asserts": ["assert set(subsetsum([3, 34, 4, 12, 5, 2], 9)) == {4,5}", "assert subsetsum([1, 8, 2, 7, 4], 14) == [8, 2, 4]", "assert subsetsum([10, 12, 15, 6, 19], 21) == [15, 6]", "assert subsetsum([5, 10, 12, 13, 15, 18], 30) == [12, 18]", "assert subsetsum([5, 3, 9, 12, 6, 15], 27) == [12, 15]", "assert subsetsum([2, 3, 7, 8, 10], 11) == [3, 8]", "assert subsetsum([6, 2, 7, 11, 8], 16) == [6, 2, 8]", "assert subsetsum([5, 7, 1, 14, 6], 13) == [7, 6]", "assert subsetsum([1], 1) == [1]", "assert subsetsum([2, 5, 8, 4], 0) == []", "assert subsetsum([], 5) == None", "assert subsetsum([-1, -2, -3, -4, -5], -10) == None  # Negative numbers are not allowed according to the question", "assert subsetsum([4, 1, 2, 5, 12, 7], 9) == [2, 7]", "assert subsetsum([3, 5, 8, 4], 22) == None  # Sum exceeds the sum of all elements"]}, {"author": "Calvin", "UUID": "5e7011e5-fee4-4c1a-a98f-3b81e50508cc", "question": "Return nth number in the fibonacci sequence", "examples": "Input: 9\nOutput: 34\n\nInput: 7\nOutput: 13", "link": NaN, "difficulty": null, "categories": ["Dynamic_programming"], "code": "def fibonacci(n: int) -> int:\n    a = 0\n    b = 1\n    if n < 0:\n        print(\"Incorrect input\")\n    elif n == 0:\n        return a\n    elif n == 1:\n        return b\n    else:\n        for i in range(2, n+1):\n            c = a + b\n            a = b\n            b = c\n        return b\n    b = c\n    return fib(n-1, a, b)\n", "asserts": ["assert fibonacci(9) == 34", "assert fibonacci(10) == 55", "assert fibonacci(5) == 5", "assert fibonacci(2) == 1", "assert fibonacci(0) == 0", "assert fibonacci(11) == 89", "assert fibonacci(15) == 610", "assert fibonacci(20) == 6765", "assert fibonacci(25) == 75025", "assert fibonacci(3) == 2", "assert fibonacci(1) == 1", "assert fibonacci(6) == 8", "assert fibonacci(30) == 832040", "assert fibonacci(35) == 9227465", "assert fibonacci(40) == 102334155"]}], "category": "Dynamic_programming", "prompt_tokens": 1073, "total_tokens": 1473, "completion_tokens": 400, "completion": "Find the minimum number of operations required to transform one string into another, where each operation can be either insertion, deletion, or substitution of a single character.\n\n###Code: \n\ndef min_edit_distance(word1: str, word2: str) -> int:\n    m, n = len(word1), len(word2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    \n    for i in range(m + 1):\n        dp[i][0] = i\n        \n    for j in range(n + 1):\n        dp[0][j] = j\n        \n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if word1[i - 1] == word2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1]\n            else:\n                dp[i][j] = 1 + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])\n    \n    return dp[m][n]\n\n\n###Testcases: \n\nassert min_edit_distance(\"kitten\", \"sitting\") == 3\nassert min_edit_distance(\"intention\", \"execution\") == 5\nassert min_edit_distance(\"horse\", \"ros\") == 3\nassert min_edit_distance(\"abc\", \"def\") == 3\nassert min_edit_distance(\"aaa\", \"bbb\") == 3\nassert min_edit_distance(\"abc\", \"abc\") == 0\nassert min_edit_distance(\"abc\", \"abcd\") == 1\nassert min_edit_distance(\"abc\", \"ab\") == 1\nassert min_edit_distance(\"abc\", \"a\") == 2\nassert min_edit_distance(\"\", \"abc\") == 3\nassert min_edit_distance(\"abc\", \"\") == 3\n\n[/Example 3]", "temperature": 0.646, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Hafeez", "UUID": "6aaf1310-7585-4d90-91e7-1f405c9b25e7", "question": "Get Maximum in Generated Array: You are given an integer n. A 0-indexed integer array nums of length n + 1 is generated in the following way:\n\nnums[0] = 0\nnums[1] = 1\nnums[2 * i] = nums[i] when 2 <= 2 * i <= n\nnums[2 * i + 1] = nums[i] + nums[i + 1] when 2 <= 2 * i + 1 <= n\nReturn the maximum integer in the array nums\u200b\u200b\u200b.", "examples": "Input: n = 7\nOutput: 3\nExplanation: According to the given rules:\n  nums[0] = 0\n  nums[1] = 1\n  nums[(1 * 2) = 2] = nums[1] = 1\n  nums[(1 * 2) + 1 = 3] = nums[1] + nums[2] = 1 + 1 = 2\n  nums[(2 * 2) = 4] = nums[2] = 1\n  nums[(2 * 2) + 1 = 5] = nums[2] + nums[3] = 1 + 2 = 3\n  nums[(3 * 2) = 6] = nums[3] = 2\n  nums[(3 * 2) + 1 = 7] = nums[3] + nums[4] = 2 + 1 = 3\nHence, nums = [0,1,1,2,1,3,2,3], and the maximum is max(0,1,1,2,1,3,2,3) = 3.\nInput: n = 2\nOutput: 1\nExplanation: According to the given rules, nums = [0,1,1]. The maximum is max(0,1,1) = 1.\nInput: n = 3\nOutput: 2\nExplanation: According to the given rules, nums = [0,1,1,2]. The maximum is max(0,1,1,2) = 2.", "link": "https://leetcode.com/problems/get-maximum-in-generated-array/", "difficulty": "Easy", "categories": ["Dynamic_programming"], "code": "def getMaximumGenerated(n: int) -> int:\n    if n<2:\n        return n\n    nums=[0]*(n+1)\n    nums[0]=0\n    nums[1]=1\n    for i in range(2,n+1):\n        if i%2==0:\n            nums[i]=nums[i//2]\n        else:\n            nums[i]=nums[i//2]+nums[i//2+1]\n    return max(nums)", "asserts": ["assert getMaximumGenerated(2)==1", "assert getMaximumGenerated(4) == 2", "assert getMaximumGenerated(5) == 3", "assert getMaximumGenerated(8) == 3", "assert getMaximumGenerated(15) == 5", "assert getMaximumGenerated(0) == 0", "assert getMaximumGenerated(1) == 1"]}, {"author": "Hafeez", "UUID": "296ab89e-7208-4f6f-bed1-d623f30e32c9", "question": "Coin Change II: You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.\n\nReturn the number of combinations that make up that amount. If that amount of money cannot be made up by any combination of the coins, return 0.\n\nYou may assume that you have an infinite number of each kind of coin.\n\nThe answer is guaranteed to fit into a signed 32-bit integer.", "examples": "Input: amount = 5, coins = [1,2,5]\nOutput: 4\nExplanation: there are four ways to make up the amount:\n5=5\n5=2+2+1\n5=2+1+1+1\n5=1+1+1+1+1\nInput: amount = 3, coins = [2]\nOutput: 0\nExplanation: the amount of 3 cannot be made up just with coins of 2.", "link": "https://leetcode.com/problems/coin-change-ii/description/", "difficulty": "Medium", "categories": ["Dynamic_programming"], "code": "from typing import List\ndef change(amount: int, coins: List[int]) -> int:\n    def numberOfWays(i: int, amount: int) -> int:\n        if amount == 0:\n            return 1\n        if i == len(coins):\n            return 0\n        if memo[i][amount] != -1:\n            return memo[i][amount]\n\n        if coins[i] > amount:\n            memo[i][amount] = numberOfWays(i + 1, amount)\n        else:\n            memo[i][amount] = numberOfWays(i, amount - coins[i]) + numberOfWays(i + 1, amount)\n        \n        return memo[i][amount]\n\n    memo = [[-1] * (amount + 1) for _ in range(len(coins))]\n    return numberOfWays(0, amount)", "asserts": ["assert change(10,[10])==1", "assert change(0, [1, 2, 5]) == 1  # Edge case: trying to make 0 with any coins should always return 1", "assert change(11, [5]) == 0  # Amount cannot be made up with given coins", "assert change(0, []) == 1  # Edge case: trying to make 0 without any coins, should return 1 as there's one way of making 0 with no coins", "assert change(5, [5, 1]) == 2  # Amount can be made with given coins: [5], [1, 1, 1, 1, 1]"]}], "category": "Dynamic_programming", "prompt_tokens": 919, "total_tokens": 1123, "completion_tokens": 204, "completion": "Maximum Subarray: Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.\n\n###Code: \n\nfrom typing import List\n\ndef maxSubArray(nums: List[int]) -> int:\n    max_sum = current_sum = nums[0]\n    for num in nums[1:]:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    return max_sum\n\n###Testcases: \n\nassert maxSubArray([-2,1,-3,4,-1,2,1,-5,4]) == 6\nassert maxSubArray([1]) == 1\nassert maxSubArray([5,4,-1,7,8]) == 23\nassert maxSubArray([-2,-3,4,-1,-2,1,5,-3]) == 7\nassert maxSubArray([-1]) == -1\n\n[/Example 3]", "temperature": 0.749, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Hafeez", "UUID": "38dca76c-ee6c-4c71-83a9-89240828a3b7", "question": "Best Time to Buy and Sell Stock II: You are given an integer array prices where prices[i] is the price of a given stock on the ith day.\n\nOn each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day.\n\nFind and return the maximum profit you can achieve.", "examples": "Input: prices = [7,1,5,3,6,4]\nOutput: 7\nExplanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\nThen buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.\nTotal profit is 4 + 3 = 7.\nInput: prices = [7,6,4,3,1]\nOutput: 0\nExplanation: There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0.", "link": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/", "difficulty": "Medium", "categories": ["Dynamic_programming"], "code": "from typing import List\ndef maxProfit(prices: List[int]) -> int:\n    cur_hold, cur_not_hold = -float('inf'), 0\n    \n    for stock_price in prices:\n        \n        prev_hold, prev_not_hold = cur_hold, cur_not_hold\n        cur_hold = max( prev_hold, prev_not_hold - stock_price )\n        cur_not_hold = max( prev_not_hold, prev_hold + stock_price )\n    return cur_not_hold", "asserts": ["assert maxProfit([1,2,3,4,5])==4", "assert maxProfit([1,2,100,2,1]) == 99"]}, {"author": "Calvin", "UUID": "51a5caf9-241f-4de3-9ee2-9420490b73d7", "question": "Given a set[] of non-negative integers and a value sum, return the subset of the given set whose sum is equal to the given sum or None if one doesn't exist\n", "examples": "Input: set = [1, 2, 3, 4, 5], sum = 10\nOutput: [1, 2, 3, 4]", "link": "https://www.geeksforgeeks.org/subset-sum-problem-dp-25/", "difficulty": null, "categories": ["Dynamic_programming"], "code": "def subsetsum(fullset: list, target_sum: int) -> set:\n    def subsetSum_helper(cur_idx: int, fullset: list, target_sum: int, subset: list):\n        if target_sum == 0:\n            return subset\n        if (cur_idx == len(fullset)):\n            return None\n        excluding = subsetSum_helper(cur_idx + 1, fullset, target_sum, subset)\n          \n        if excluding is not None:\n            return excluding\n        elif fullset[cur_idx] <= target_sum:\n            subset.append(fullset[cur_idx])\n            including = subsetSum_helper(cur_idx + 1, fullset, target_sum - fullset[cur_idx], subset)\n            if including!=None:\n                return including\n            else:\n                subset.pop()\n            return None\n    return subsetSum_helper(0, fullset, target_sum, [])\n", "asserts": ["assert set(subsetsum([3, 34, 4, 12, 5, 2], 9)) == {4,5}", "assert subsetsum([1, 8, 2, 7, 4], 14) == [8, 2, 4]", "assert subsetsum([10, 12, 15, 6, 19], 21) == [15, 6]", "assert subsetsum([5, 10, 12, 13, 15, 18], 30) == [12, 18]", "assert subsetsum([5, 3, 9, 12, 6, 15], 27) == [12, 15]", "assert subsetsum([2, 3, 7, 8, 10], 11) == [3, 8]", "assert subsetsum([6, 2, 7, 11, 8], 16) == [6, 2, 8]", "assert subsetsum([5, 7, 1, 14, 6], 13) == [7, 6]", "assert subsetsum([1], 1) == [1]", "assert subsetsum([2, 5, 8, 4], 0) == []", "assert subsetsum([], 5) == None", "assert subsetsum([-1, -2, -3, -4, -5], -10) == None  # Negative numbers are not allowed according to the question", "assert subsetsum([4, 1, 2, 5, 12, 7], 9) == [2, 7]", "assert subsetsum([3, 5, 8, 4], 22) == None  # Sum exceeds the sum of all elements"]}], "category": "Dynamic_programming", "prompt_tokens": 1031, "total_tokens": 1241, "completion_tokens": 210, "completion": "You are given a list of non-negative integers representing the amount of money of each house. Write a function to determine the maximum amount of money you can rob tonight without alerting the police. It is known that the houses are arranged in a circle.\n\n\n###Code: \n\ndef rob(nums: List[int]) -> int:\n    def rob_linear(nums):\n        prev_max, curr_max = 0, 0\n        for num in nums:\n            temp = curr_max\n            curr_max = max(prev_max + num, curr_max)\n            prev_max = temp\n        return curr_max\n\n    n = len(nums)\n    if n == 1:\n        return nums[0]\n    return max(rob_linear(nums[1:]), rob_linear(nums[:-1]))\n\n\n###Testcases: \n\nassert rob([2,3,2])==3\nassert rob([1,2,3,1])==4\nassert rob([0])==0\nassert rob([1,2,1,1])==3\n\n[/Example 3]", "temperature": 0.981, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Hafeez", "UUID": "d695e67c-5b0e-4235-8406-30ee6be61173", "question": "N-th Tribonacci Number: The Tribonacci sequence Tn is defined as follows: \n\nT0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n >= 0.\n\nGiven n, return the value of Tn.", "examples": "Input: n = 4\nOutput: 4\nExplanation:\nT_3 = 0 + 1 + 1 = 2\nT_4 = 1 + 1 + 2 = 4", "link": "https://leetcode.com/problems/n-th-tribonacci-number/description/", "difficulty": "Easy", "categories": ["Dynamic_programming"], "code": "def tribonacci(n: int) -> int:\n    dp = {0: 0, 1: 1, 2: 1}\n    def dfs(i):\n        if i in dp:\n            return dp[i]\n        dp[i] = dfs(i - 1) + dfs(i - 2) + dfs(i - 3)\n        return dp[i]\n    \n    return dfs(n)", "asserts": ["assert tribonacci(25)==1389537", "assert tribonacci(0) == 0", "assert tribonacci(1) == 1", "assert tribonacci(2) == 1", "assert tribonacci(3) == 2", "assert tribonacci(5) == 7", "assert tribonacci(7) == 24", "assert tribonacci(10) == 149", "assert tribonacci(15) == 3136", "assert tribonacci(30) == 29249425"]}, {"author": "Calvin", "UUID": "51a5caf9-241f-4de3-9ee2-9420490b73d7", "question": "Given a set[] of non-negative integers and a value sum, return the subset of the given set whose sum is equal to the given sum or None if one doesn't exist\n", "examples": "Input: set = [1, 2, 3, 4, 5], sum = 10\nOutput: [1, 2, 3, 4]", "link": "https://www.geeksforgeeks.org/subset-sum-problem-dp-25/", "difficulty": null, "categories": ["Dynamic_programming"], "code": "def subsetsum(fullset: list, target_sum: int) -> set:\n    def subsetSum_helper(cur_idx: int, fullset: list, target_sum: int, subset: list):\n        if target_sum == 0:\n            return subset\n        if (cur_idx == len(fullset)):\n            return None\n        excluding = subsetSum_helper(cur_idx + 1, fullset, target_sum, subset)\n          \n        if excluding is not None:\n            return excluding\n        elif fullset[cur_idx] <= target_sum:\n            subset.append(fullset[cur_idx])\n            including = subsetSum_helper(cur_idx + 1, fullset, target_sum - fullset[cur_idx], subset)\n            if including!=None:\n                return including\n            else:\n                subset.pop()\n            return None\n    return subsetSum_helper(0, fullset, target_sum, [])\n", "asserts": ["assert set(subsetsum([3, 34, 4, 12, 5, 2], 9)) == {4,5}", "assert subsetsum([1, 8, 2, 7, 4], 14) == [8, 2, 4]", "assert subsetsum([10, 12, 15, 6, 19], 21) == [15, 6]", "assert subsetsum([5, 10, 12, 13, 15, 18], 30) == [12, 18]", "assert subsetsum([5, 3, 9, 12, 6, 15], 27) == [12, 15]", "assert subsetsum([2, 3, 7, 8, 10], 11) == [3, 8]", "assert subsetsum([6, 2, 7, 11, 8], 16) == [6, 2, 8]", "assert subsetsum([5, 7, 1, 14, 6], 13) == [7, 6]", "assert subsetsum([1], 1) == [1]", "assert subsetsum([2, 5, 8, 4], 0) == []", "assert subsetsum([], 5) == None", "assert subsetsum([-1, -2, -3, -4, -5], -10) == None  # Negative numbers are not allowed according to the question", "assert subsetsum([4, 1, 2, 5, 12, 7], 9) == [2, 7]", "assert subsetsum([3, 5, 8, 4], 22) == None  # Sum exceeds the sum of all elements"]}], "category": "Dynamic_programming", "prompt_tokens": 1071, "total_tokens": 1563, "completion_tokens": 492, "completion": "You are given an array of integers. Find the length of the longest increasing subsequence (LIS).\n\n###Code:\n\n```python\ndef lengthOfLIS(nums: List[int]) -> int:\n    if not nums:\n        return 0\n    dp = [1] * len(nums)\n    for i in range(len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n```\n\n###Testcases:\n\n```python\nassert lengthOfLIS([10, 9, 2, 5, 3, 7, 101, 18]) == 4  # The longest increasing subsequence is [2, 3, 7, 101]\nassert lengthOfLIS([0, 1, 0, 3, 2, 3]) == 4  # The longest increasing subsequence is [0, 1, 2, 3]\nassert lengthOfLIS([7, 7, 7, 7, 7, 7, 7]) == 1  # The longest increasing subsequence is [7]\nassert lengthOfLIS([4, 10, 4, 3, 8, 9]) == 3  # The longest increasing subsequence is [4, 8, 9]\nassert lengthOfLIS([1, 3, 6, 7, 9, 4, 10, 5, 6]) == 6  # The longest increasing subsequence is [1, 3, 6, 7, 9, 10]\nassert lengthOfLIS([10, 9, 2, 5, 3, 4]) == 3  # The longest increasing subsequence is [2, 3, 4]\nassert lengthOfLIS([3, 4, -1, 0, 6, 2, 3]) == 4  # The longest increasing subsequence is [-1, 0, 2, 3]\nassert lengthOfLIS([3, 2, 1, 0]) == 1  # The longest increasing subsequence is [3] or [2] or [1] or [0]\n```", "temperature": 0.826, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Hafeez", "UUID": "296ab89e-7208-4f6f-bed1-d623f30e32c9", "question": "Coin Change II: You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.\n\nReturn the number of combinations that make up that amount. If that amount of money cannot be made up by any combination of the coins, return 0.\n\nYou may assume that you have an infinite number of each kind of coin.\n\nThe answer is guaranteed to fit into a signed 32-bit integer.", "examples": "Input: amount = 5, coins = [1,2,5]\nOutput: 4\nExplanation: there are four ways to make up the amount:\n5=5\n5=2+2+1\n5=2+1+1+1\n5=1+1+1+1+1\nInput: amount = 3, coins = [2]\nOutput: 0\nExplanation: the amount of 3 cannot be made up just with coins of 2.", "link": "https://leetcode.com/problems/coin-change-ii/description/", "difficulty": "Medium", "categories": ["Dynamic_programming"], "code": "from typing import List\ndef change(amount: int, coins: List[int]) -> int:\n    def numberOfWays(i: int, amount: int) -> int:\n        if amount == 0:\n            return 1\n        if i == len(coins):\n            return 0\n        if memo[i][amount] != -1:\n            return memo[i][amount]\n\n        if coins[i] > amount:\n            memo[i][amount] = numberOfWays(i + 1, amount)\n        else:\n            memo[i][amount] = numberOfWays(i, amount - coins[i]) + numberOfWays(i + 1, amount)\n        \n        return memo[i][amount]\n\n    memo = [[-1] * (amount + 1) for _ in range(len(coins))]\n    return numberOfWays(0, amount)", "asserts": ["assert change(10,[10])==1", "assert change(0, [1, 2, 5]) == 1  # Edge case: trying to make 0 with any coins should always return 1", "assert change(11, [5]) == 0  # Amount cannot be made up with given coins", "assert change(0, []) == 1  # Edge case: trying to make 0 without any coins, should return 1 as there's one way of making 0 with no coins", "assert change(5, [5, 1]) == 2  # Amount can be made with given coins: [5], [1, 1, 1, 1, 1]"]}, {"author": "Hafeez", "UUID": "6aaf1310-7585-4d90-91e7-1f405c9b25e7", "question": "Get Maximum in Generated Array: You are given an integer n. A 0-indexed integer array nums of length n + 1 is generated in the following way:\n\nnums[0] = 0\nnums[1] = 1\nnums[2 * i] = nums[i] when 2 <= 2 * i <= n\nnums[2 * i + 1] = nums[i] + nums[i + 1] when 2 <= 2 * i + 1 <= n\nReturn the maximum integer in the array nums\u200b\u200b\u200b.", "examples": "Input: n = 7\nOutput: 3\nExplanation: According to the given rules:\n  nums[0] = 0\n  nums[1] = 1\n  nums[(1 * 2) = 2] = nums[1] = 1\n  nums[(1 * 2) + 1 = 3] = nums[1] + nums[2] = 1 + 1 = 2\n  nums[(2 * 2) = 4] = nums[2] = 1\n  nums[(2 * 2) + 1 = 5] = nums[2] + nums[3] = 1 + 2 = 3\n  nums[(3 * 2) = 6] = nums[3] = 2\n  nums[(3 * 2) + 1 = 7] = nums[3] + nums[4] = 2 + 1 = 3\nHence, nums = [0,1,1,2,1,3,2,3], and the maximum is max(0,1,1,2,1,3,2,3) = 3.\nInput: n = 2\nOutput: 1\nExplanation: According to the given rules, nums = [0,1,1]. The maximum is max(0,1,1) = 1.\nInput: n = 3\nOutput: 2\nExplanation: According to the given rules, nums = [0,1,1,2]. The maximum is max(0,1,1,2) = 2.", "link": "https://leetcode.com/problems/get-maximum-in-generated-array/", "difficulty": "Easy", "categories": ["Dynamic_programming"], "code": "def getMaximumGenerated(n: int) -> int:\n    if n<2:\n        return n\n    nums=[0]*(n+1)\n    nums[0]=0\n    nums[1]=1\n    for i in range(2,n+1):\n        if i%2==0:\n            nums[i]=nums[i//2]\n        else:\n            nums[i]=nums[i//2]+nums[i//2+1]\n    return max(nums)", "asserts": ["assert getMaximumGenerated(2)==1", "assert getMaximumGenerated(4) == 2", "assert getMaximumGenerated(5) == 3", "assert getMaximumGenerated(8) == 3", "assert getMaximumGenerated(15) == 5", "assert getMaximumGenerated(0) == 0", "assert getMaximumGenerated(1) == 1"]}], "category": "Dynamic_programming", "prompt_tokens": 919, "total_tokens": 1223, "completion_tokens": 304, "completion": "Minimum Path Sum: Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right, which minimizes the sum of all numbers along its path.\n\n###Code: \n\nfrom typing import List\ndef minPathSum(grid: List[List[int]]) -> int:\n    m, n = len(grid), len(grid[0])\n    for i in range(m):\n        for j in range(n):\n            if i == 0 and j == 0:\n                continue\n            elif i == 0:\n                grid[i][j] += grid[i][j - 1]\n            elif j == 0:\n                grid[i][j] += grid[i - 1][j]\n            else:\n                grid[i][j] += min(grid[i - 1][j], grid[i][j - 1])\n    return grid[m - 1][n - 1]\n\n###Testcases: \n\nassert minPathSum([[1,3,1],[1,5,1],[4,2,1]])==7\nassert minPathSum([[1,2,3],[4,5,6]])==12\nassert minPathSum([[1,2],[3,4]])==7\nassert minPathSum([[1,2,5],[3,2,1]])==6\nassert minPathSum([[1,2,3],[4,5,6],[7,8,9]])==21\n\n[/Example 3]", "temperature": 0.963, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Hafeez", "UUID": "296ab89e-7208-4f6f-bed1-d623f30e32c9", "question": "Coin Change II: You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.\n\nReturn the number of combinations that make up that amount. If that amount of money cannot be made up by any combination of the coins, return 0.\n\nYou may assume that you have an infinite number of each kind of coin.\n\nThe answer is guaranteed to fit into a signed 32-bit integer.", "examples": "Input: amount = 5, coins = [1,2,5]\nOutput: 4\nExplanation: there are four ways to make up the amount:\n5=5\n5=2+2+1\n5=2+1+1+1\n5=1+1+1+1+1\nInput: amount = 3, coins = [2]\nOutput: 0\nExplanation: the amount of 3 cannot be made up just with coins of 2.", "link": "https://leetcode.com/problems/coin-change-ii/description/", "difficulty": "Medium", "categories": ["Dynamic_programming"], "code": "from typing import List\ndef change(amount: int, coins: List[int]) -> int:\n    def numberOfWays(i: int, amount: int) -> int:\n        if amount == 0:\n            return 1\n        if i == len(coins):\n            return 0\n        if memo[i][amount] != -1:\n            return memo[i][amount]\n\n        if coins[i] > amount:\n            memo[i][amount] = numberOfWays(i + 1, amount)\n        else:\n            memo[i][amount] = numberOfWays(i, amount - coins[i]) + numberOfWays(i + 1, amount)\n        \n        return memo[i][amount]\n\n    memo = [[-1] * (amount + 1) for _ in range(len(coins))]\n    return numberOfWays(0, amount)", "asserts": ["assert change(10,[10])==1", "assert change(0, [1, 2, 5]) == 1  # Edge case: trying to make 0 with any coins should always return 1", "assert change(11, [5]) == 0  # Amount cannot be made up with given coins", "assert change(0, []) == 1  # Edge case: trying to make 0 without any coins, should return 1 as there's one way of making 0 with no coins", "assert change(5, [5, 1]) == 2  # Amount can be made with given coins: [5], [1, 1, 1, 1, 1]"]}, {"author": "Calvin", "UUID": "e35d1110-85e8-4f50-80aa-91eb976b310b", "question": "Return the factorial of a given number n", "examples": "Input: 5\nOutput: 120\n\nInput: 6\nOutput: 720", "link": NaN, "difficulty": null, "categories": ["Dynamic_programming"], "code": "\ndef fact(n: int) -> int:\n  if n <= 1:\n    return 1\n  return n*fact(n-1)\n", "asserts": ["assert fact(5) == 120", "assert fact(0) == 1", "assert fact(1) == 1", "assert fact(3) == 6", "assert fact(7) == 5040", "assert fact(10) == 3628800", "assert fact(4) == 24", "assert fact(8) == 40320", "assert fact(2) == 2", "assert fact(11) == 39916800"]}], "category": "Dynamic_programming", "prompt_tokens": 767, "total_tokens": 1109, "completion_tokens": 342, "completion": "Find the length of the longest increasing subsequence in an integer array.\n\n###Code: \n\nfrom typing import List\n\ndef lengthOfLIS(nums: List[int]) -> int:\n    if not nums:\n        return 0\n\n    dp = [1] * len(nums)\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    \n    return max(dp)\n\n###Testcases: \n\nassert lengthOfLIS([10, 9, 2, 5, 3, 7, 101, 18]) == 4  # The longest increasing subsequence is [2, 3, 7, 101], so the length is 4\nassert lengthOfLIS([0, 1, 0, 3, 2, 3]) == 4  # The longest increasing subsequence is [0, 1, 2, 3], so the length is 4\nassert lengthOfLIS([7, 7, 7, 7, 7, 7, 7]) == 1  # All elements are same, so the length of LIS is 1\nassert lengthOfLIS([4, 10, 4, 3, 8, 9]) == 3  # The longest increasing subsequence is [4, 4, 8] or [4, 3, 8] or [4, 3, 9], so the length is 3\n\n[/Example 3]", "temperature": 0.667, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Calvin", "UUID": "51a5caf9-241f-4de3-9ee2-9420490b73d7", "question": "Given a set[] of non-negative integers and a value sum, return the subset of the given set whose sum is equal to the given sum or None if one doesn't exist\n", "examples": "Input: set = [1, 2, 3, 4, 5], sum = 10\nOutput: [1, 2, 3, 4]", "link": "https://www.geeksforgeeks.org/subset-sum-problem-dp-25/", "difficulty": null, "categories": ["Dynamic_programming"], "code": "def subsetsum(fullset: list, target_sum: int) -> set:\n    def subsetSum_helper(cur_idx: int, fullset: list, target_sum: int, subset: list):\n        if target_sum == 0:\n            return subset\n        if (cur_idx == len(fullset)):\n            return None\n        excluding = subsetSum_helper(cur_idx + 1, fullset, target_sum, subset)\n          \n        if excluding is not None:\n            return excluding\n        elif fullset[cur_idx] <= target_sum:\n            subset.append(fullset[cur_idx])\n            including = subsetSum_helper(cur_idx + 1, fullset, target_sum - fullset[cur_idx], subset)\n            if including!=None:\n                return including\n            else:\n                subset.pop()\n            return None\n    return subsetSum_helper(0, fullset, target_sum, [])\n", "asserts": ["assert set(subsetsum([3, 34, 4, 12, 5, 2], 9)) == {4,5}", "assert subsetsum([1, 8, 2, 7, 4], 14) == [8, 2, 4]", "assert subsetsum([10, 12, 15, 6, 19], 21) == [15, 6]", "assert subsetsum([5, 10, 12, 13, 15, 18], 30) == [12, 18]", "assert subsetsum([5, 3, 9, 12, 6, 15], 27) == [12, 15]", "assert subsetsum([2, 3, 7, 8, 10], 11) == [3, 8]", "assert subsetsum([6, 2, 7, 11, 8], 16) == [6, 2, 8]", "assert subsetsum([5, 7, 1, 14, 6], 13) == [7, 6]", "assert subsetsum([1], 1) == [1]", "assert subsetsum([2, 5, 8, 4], 0) == []", "assert subsetsum([], 5) == None", "assert subsetsum([-1, -2, -3, -4, -5], -10) == None  # Negative numbers are not allowed according to the question", "assert subsetsum([4, 1, 2, 5, 12, 7], 9) == [2, 7]", "assert subsetsum([3, 5, 8, 4], 22) == None  # Sum exceeds the sum of all elements"]}, {"author": "Hafeez", "UUID": "38dca76c-ee6c-4c71-83a9-89240828a3b7", "question": "Best Time to Buy and Sell Stock II: You are given an integer array prices where prices[i] is the price of a given stock on the ith day.\n\nOn each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day.\n\nFind and return the maximum profit you can achieve.", "examples": "Input: prices = [7,1,5,3,6,4]\nOutput: 7\nExplanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\nThen buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.\nTotal profit is 4 + 3 = 7.\nInput: prices = [7,6,4,3,1]\nOutput: 0\nExplanation: There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0.", "link": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/", "difficulty": "Medium", "categories": ["Dynamic_programming"], "code": "from typing import List\ndef maxProfit(prices: List[int]) -> int:\n    cur_hold, cur_not_hold = -float('inf'), 0\n    \n    for stock_price in prices:\n        \n        prev_hold, prev_not_hold = cur_hold, cur_not_hold\n        cur_hold = max( prev_hold, prev_not_hold - stock_price )\n        cur_not_hold = max( prev_not_hold, prev_hold + stock_price )\n    return cur_not_hold", "asserts": ["assert maxProfit([1,2,3,4,5])==4", "assert maxProfit([1,2,100,2,1]) == 99"]}], "category": "Dynamic_programming", "prompt_tokens": 1031, "total_tokens": 1310, "completion_tokens": 279, "completion": "Given an array of integers, find the length of the longest increasing subsequence.\n\n###Code: \n\ndef lengthOfLIS(nums: List[int]) -> int:\n    if not nums:\n        return 0\n    dp = [1] * len(nums)\n    for i in range(len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n\n###Testcases: \n\nassert lengthOfLIS([10, 9, 2, 5, 3, 7, 101, 18])==4\nassert lengthOfLIS([0, 1, 0, 3, 2, 3])==4\nassert lengthOfLIS([7, 7, 7, 7, 7, 7, 7])==1\nassert lengthOfLIS([4, 10, 4, 3, 8, 9])==3\nassert lengthOfLIS([2, 2])==1\nassert lengthOfLIS([10, 9, 2, 5, 3, 7, 101, 18, 20, 21, 22, 23, 24, 25])==8\n\n[/Example 3]", "temperature": 0.779, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Calvin", "UUID": "5e7011e5-fee4-4c1a-a98f-3b81e50508cc", "question": "Return nth number in the fibonacci sequence", "examples": "Input: 9\nOutput: 34\n\nInput: 7\nOutput: 13", "link": NaN, "difficulty": null, "categories": ["Dynamic_programming"], "code": "def fibonacci(n: int) -> int:\n    a = 0\n    b = 1\n    if n < 0:\n        print(\"Incorrect input\")\n    elif n == 0:\n        return a\n    elif n == 1:\n        return b\n    else:\n        for i in range(2, n+1):\n            c = a + b\n            a = b\n            b = c\n        return b\n    b = c\n    return fib(n-1, a, b)\n", "asserts": ["assert fibonacci(9) == 34", "assert fibonacci(10) == 55", "assert fibonacci(5) == 5", "assert fibonacci(2) == 1", "assert fibonacci(0) == 0", "assert fibonacci(11) == 89", "assert fibonacci(15) == 610", "assert fibonacci(20) == 6765", "assert fibonacci(25) == 75025", "assert fibonacci(3) == 2", "assert fibonacci(1) == 1", "assert fibonacci(6) == 8", "assert fibonacci(30) == 832040", "assert fibonacci(35) == 9227465", "assert fibonacci(40) == 102334155"]}, {"author": "Hafeez", "UUID": "296ab89e-7208-4f6f-bed1-d623f30e32c9", "question": "Coin Change II: You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.\n\nReturn the number of combinations that make up that amount. If that amount of money cannot be made up by any combination of the coins, return 0.\n\nYou may assume that you have an infinite number of each kind of coin.\n\nThe answer is guaranteed to fit into a signed 32-bit integer.", "examples": "Input: amount = 5, coins = [1,2,5]\nOutput: 4\nExplanation: there are four ways to make up the amount:\n5=5\n5=2+2+1\n5=2+1+1+1\n5=1+1+1+1+1\nInput: amount = 3, coins = [2]\nOutput: 0\nExplanation: the amount of 3 cannot be made up just with coins of 2.", "link": "https://leetcode.com/problems/coin-change-ii/description/", "difficulty": "Medium", "categories": ["Dynamic_programming"], "code": "from typing import List\ndef change(amount: int, coins: List[int]) -> int:\n    def numberOfWays(i: int, amount: int) -> int:\n        if amount == 0:\n            return 1\n        if i == len(coins):\n            return 0\n        if memo[i][amount] != -1:\n            return memo[i][amount]\n\n        if coins[i] > amount:\n            memo[i][amount] = numberOfWays(i + 1, amount)\n        else:\n            memo[i][amount] = numberOfWays(i, amount - coins[i]) + numberOfWays(i + 1, amount)\n        \n        return memo[i][amount]\n\n    memo = [[-1] * (amount + 1) for _ in range(len(coins))]\n    return numberOfWays(0, amount)", "asserts": ["assert change(10,[10])==1", "assert change(0, [1, 2, 5]) == 1  # Edge case: trying to make 0 with any coins should always return 1", "assert change(11, [5]) == 0  # Amount cannot be made up with given coins", "assert change(0, []) == 1  # Edge case: trying to make 0 without any coins, should return 1 as there's one way of making 0 with no coins", "assert change(5, [5, 1]) == 2  # Amount can be made with given coins: [5], [1, 1, 1, 1, 1]"]}], "category": "Dynamic_programming", "prompt_tokens": 890, "total_tokens": 1297, "completion_tokens": 407, "completion": "Find the length of the longest increasing subsequence in an integer array.\n\n###Code: \n\nfrom typing import List\n\ndef lengthOfLIS(nums: List[int]) -> int:\n    if not nums:\n        return 0\n    dp = [1] * len(nums)\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n\n###Testcases: \n\nassert lengthOfLIS([10, 9, 2, 5, 3, 7, 101, 18]) == 4  # The longest increasing subsequence is [2, 3, 7, 101], therefore the length is 4\nassert lengthOfLIS([0, 1, 0, 3, 2, 3]) == 4  # The longest increasing subsequence is [0, 1, 2, 3], therefore the length is 4\nassert lengthOfLIS([7, 7, 7, 7, 7, 7, 7]) == 1  # The longest increasing subsequence is [7], therefore the length is 1\nassert lengthOfLIS([1, 3, 6, 7, 9, 4, 10, 5, 6]) == 6  # The longest increasing subsequence is [1, 3, 6, 7, 9, 10], therefore the length is 6\nassert lengthOfLIS([3, 10, 2, 1, 20]) == 3  # The longest increasing subsequence is [3, 10, 20], therefore the length is 3\nassert lengthOfLIS([]) == 0  # Empty array should return 0\n\n[/Example 3]", "temperature": 0.863, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Hafeez", "UUID": "6aaf1310-7585-4d90-91e7-1f405c9b25e7", "question": "Get Maximum in Generated Array: You are given an integer n. A 0-indexed integer array nums of length n + 1 is generated in the following way:\n\nnums[0] = 0\nnums[1] = 1\nnums[2 * i] = nums[i] when 2 <= 2 * i <= n\nnums[2 * i + 1] = nums[i] + nums[i + 1] when 2 <= 2 * i + 1 <= n\nReturn the maximum integer in the array nums\u200b\u200b\u200b.", "examples": "Input: n = 7\nOutput: 3\nExplanation: According to the given rules:\n  nums[0] = 0\n  nums[1] = 1\n  nums[(1 * 2) = 2] = nums[1] = 1\n  nums[(1 * 2) + 1 = 3] = nums[1] + nums[2] = 1 + 1 = 2\n  nums[(2 * 2) = 4] = nums[2] = 1\n  nums[(2 * 2) + 1 = 5] = nums[2] + nums[3] = 1 + 2 = 3\n  nums[(3 * 2) = 6] = nums[3] = 2\n  nums[(3 * 2) + 1 = 7] = nums[3] + nums[4] = 2 + 1 = 3\nHence, nums = [0,1,1,2,1,3,2,3], and the maximum is max(0,1,1,2,1,3,2,3) = 3.\nInput: n = 2\nOutput: 1\nExplanation: According to the given rules, nums = [0,1,1]. The maximum is max(0,1,1) = 1.\nInput: n = 3\nOutput: 2\nExplanation: According to the given rules, nums = [0,1,1,2]. The maximum is max(0,1,1,2) = 2.", "link": "https://leetcode.com/problems/get-maximum-in-generated-array/", "difficulty": "Easy", "categories": ["Dynamic_programming"], "code": "def getMaximumGenerated(n: int) -> int:\n    if n<2:\n        return n\n    nums=[0]*(n+1)\n    nums[0]=0\n    nums[1]=1\n    for i in range(2,n+1):\n        if i%2==0:\n            nums[i]=nums[i//2]\n        else:\n            nums[i]=nums[i//2]+nums[i//2+1]\n    return max(nums)", "asserts": ["assert getMaximumGenerated(2)==1", "assert getMaximumGenerated(4) == 2", "assert getMaximumGenerated(5) == 3", "assert getMaximumGenerated(8) == 3", "assert getMaximumGenerated(15) == 5", "assert getMaximumGenerated(0) == 0", "assert getMaximumGenerated(1) == 1"]}, {"author": "Hafeez", "UUID": "d695e67c-5b0e-4235-8406-30ee6be61173", "question": "N-th Tribonacci Number: The Tribonacci sequence Tn is defined as follows: \n\nT0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n >= 0.\n\nGiven n, return the value of Tn.", "examples": "Input: n = 4\nOutput: 4\nExplanation:\nT_3 = 0 + 1 + 1 = 2\nT_4 = 1 + 1 + 2 = 4", "link": "https://leetcode.com/problems/n-th-tribonacci-number/description/", "difficulty": "Easy", "categories": ["Dynamic_programming"], "code": "def tribonacci(n: int) -> int:\n    dp = {0: 0, 1: 1, 2: 1}\n    def dfs(i):\n        if i in dp:\n            return dp[i]\n        dp[i] = dfs(i - 1) + dfs(i - 2) + dfs(i - 3)\n        return dp[i]\n    \n    return dfs(n)", "asserts": ["assert tribonacci(25)==1389537", "assert tribonacci(0) == 0", "assert tribonacci(1) == 1", "assert tribonacci(2) == 1", "assert tribonacci(3) == 2", "assert tribonacci(5) == 7", "assert tribonacci(7) == 24", "assert tribonacci(10) == 149", "assert tribonacci(15) == 3136", "assert tribonacci(30) == 29249425"]}], "category": "Dynamic_programming", "prompt_tokens": 764, "total_tokens": 1017, "completion_tokens": 253, "completion": "Maximum Subarray: Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.\n\n###Code: \n\ndef maxSubArray(nums: List[int]) -> int:\n    max_sum = nums[0]\n    current_sum = nums[0]\n    for num in nums[1:]:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    return max_sum\n\n###Testcases: \n\nassert maxSubArray([-2,1,-3,4,-1,2,1,-5,4]) == 6\nassert maxSubArray([1]) == 1\nassert maxSubArray([5,4,-1,7,8]) == 23\nassert maxSubArray([-2,1,-3,4,-1,2,1,-5,4]) == 6\nassert maxSubArray([-2,-1,-3,-4,-1,-2,-1,-5,-4]) == -1\nassert maxSubArray([1,2,-1,-2,2,1,-2,1,4,-5,4]) == 6\n\n[/Example 3]", "temperature": 0.735, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Hafeez", "UUID": "296ab89e-7208-4f6f-bed1-d623f30e32c9", "question": "Coin Change II: You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.\n\nReturn the number of combinations that make up that amount. If that amount of money cannot be made up by any combination of the coins, return 0.\n\nYou may assume that you have an infinite number of each kind of coin.\n\nThe answer is guaranteed to fit into a signed 32-bit integer.", "examples": "Input: amount = 5, coins = [1,2,5]\nOutput: 4\nExplanation: there are four ways to make up the amount:\n5=5\n5=2+2+1\n5=2+1+1+1\n5=1+1+1+1+1\nInput: amount = 3, coins = [2]\nOutput: 0\nExplanation: the amount of 3 cannot be made up just with coins of 2.", "link": "https://leetcode.com/problems/coin-change-ii/description/", "difficulty": "Medium", "categories": ["Dynamic_programming"], "code": "from typing import List\ndef change(amount: int, coins: List[int]) -> int:\n    def numberOfWays(i: int, amount: int) -> int:\n        if amount == 0:\n            return 1\n        if i == len(coins):\n            return 0\n        if memo[i][amount] != -1:\n            return memo[i][amount]\n\n        if coins[i] > amount:\n            memo[i][amount] = numberOfWays(i + 1, amount)\n        else:\n            memo[i][amount] = numberOfWays(i, amount - coins[i]) + numberOfWays(i + 1, amount)\n        \n        return memo[i][amount]\n\n    memo = [[-1] * (amount + 1) for _ in range(len(coins))]\n    return numberOfWays(0, amount)", "asserts": ["assert change(10,[10])==1", "assert change(0, [1, 2, 5]) == 1  # Edge case: trying to make 0 with any coins should always return 1", "assert change(11, [5]) == 0  # Amount cannot be made up with given coins", "assert change(0, []) == 1  # Edge case: trying to make 0 without any coins, should return 1 as there's one way of making 0 with no coins", "assert change(5, [5, 1]) == 2  # Amount can be made with given coins: [5], [1, 1, 1, 1, 1]"]}, {"author": "Calvin", "UUID": "e35d1110-85e8-4f50-80aa-91eb976b310b", "question": "Return the factorial of a given number n", "examples": "Input: 5\nOutput: 120\n\nInput: 6\nOutput: 720", "link": NaN, "difficulty": null, "categories": ["Dynamic_programming"], "code": "\ndef fact(n: int) -> int:\n  if n <= 1:\n    return 1\n  return n*fact(n-1)\n", "asserts": ["assert fact(5) == 120", "assert fact(0) == 1", "assert fact(1) == 1", "assert fact(3) == 6", "assert fact(7) == 5040", "assert fact(10) == 3628800", "assert fact(4) == 24", "assert fact(8) == 40320", "assert fact(2) == 2", "assert fact(11) == 39916800"]}], "category": "Dynamic_programming", "prompt_tokens": 767, "total_tokens": 1172, "completion_tokens": 405, "completion": "Find the maximum sum of a subarray within an array of integers.\n\n###Code:\n\n```python\nfrom typing import List\n\ndef maxSubArray(nums: List[int]) -> int:\n    max_sum = float('-inf')\n    current_sum = 0\n    \n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    \n    return max_sum\n```\n\n###Testcases:\n\n```python\nassert maxSubArray([-2, 1, -3, 4, -1, 2, 1, -5, 4]) == 6  # Subarray [4,-1,2,1] has the largest sum = 6\nassert maxSubArray([1]) == 1  # Single element array, so the max sum is the element itself\nassert maxSubArray([5, 4, -1, 7, 8]) == 23  # Subarray [5, 4, -1, 7, 8] has the largest sum = 23\nassert maxSubArray([-2, -1, -3, -4, -1, -2, -1, -5, -4]) == -1  # All negative numbers, so the max sum is the largest number itself\nassert maxSubArray([-1, -2, -3, -4, -5, -6, -7, -8, -9]) == -1  # All negative numbers, so the max sum is the largest number itself\nassert maxSubArray([1, 2, 3, 4, 5, 6, 7, 8, 9]) == 45  # Subarray [1, 2, 3, 4, 5, 6, 7, 8, 9] has the largest sum = 45\n```\n\n[/Example 3]", "temperature": 0.779, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Hafeez", "UUID": "38dca76c-ee6c-4c71-83a9-89240828a3b7", "question": "Best Time to Buy and Sell Stock II: You are given an integer array prices where prices[i] is the price of a given stock on the ith day.\n\nOn each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day.\n\nFind and return the maximum profit you can achieve.", "examples": "Input: prices = [7,1,5,3,6,4]\nOutput: 7\nExplanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\nThen buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.\nTotal profit is 4 + 3 = 7.\nInput: prices = [7,6,4,3,1]\nOutput: 0\nExplanation: There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0.", "link": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/", "difficulty": "Medium", "categories": ["Dynamic_programming"], "code": "from typing import List\ndef maxProfit(prices: List[int]) -> int:\n    cur_hold, cur_not_hold = -float('inf'), 0\n    \n    for stock_price in prices:\n        \n        prev_hold, prev_not_hold = cur_hold, cur_not_hold\n        cur_hold = max( prev_hold, prev_not_hold - stock_price )\n        cur_not_hold = max( prev_not_hold, prev_hold + stock_price )\n    return cur_not_hold", "asserts": ["assert maxProfit([1,2,3,4,5])==4", "assert maxProfit([1,2,100,2,1]) == 99"]}, {"author": "Calvin", "UUID": "e35d1110-85e8-4f50-80aa-91eb976b310b", "question": "Return the factorial of a given number n", "examples": "Input: 5\nOutput: 120\n\nInput: 6\nOutput: 720", "link": NaN, "difficulty": null, "categories": ["Dynamic_programming"], "code": "\ndef fact(n: int) -> int:\n  if n <= 1:\n    return 1\n  return n*fact(n-1)\n", "asserts": ["assert fact(5) == 120", "assert fact(0) == 1", "assert fact(1) == 1", "assert fact(3) == 6", "assert fact(7) == 5040", "assert fact(10) == 3628800", "assert fact(4) == 24", "assert fact(8) == 40320", "assert fact(2) == 2", "assert fact(11) == 39916800"]}], "category": "Dynamic_programming", "prompt_tokens": 572, "total_tokens": 838, "completion_tokens": 266, "completion": "Find the maximum sum subarray in a given array of integers.\n\n###Code: \n\nfrom typing import List\ndef maxSubArray(nums: List[int]) -> int:\n    max_sum = float('-inf')\n    current_sum = 0\n    \n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    \n    return max_sum\n\n###Testcases: \n\nassert maxSubArray([-2,1,-3,4,-1,2,1,-5,4]) == 6\nassert maxSubArray([1]) == 1\nassert maxSubArray([5,4,-1,7,8]) == 23\nassert maxSubArray([-2,1,-3,4,-1,2,1,-5,4]) == 6\nassert maxSubArray([1,2,3,4,5]) == 15\nassert maxSubArray([-1,-2,-3,-4,-5,-6,-7]) == -1\nassert maxSubArray([-1,0,-2]) == 0\nassert maxSubArray([1,2,-1,-2,2,1,-2,1,4,-5,4]) == 7\n\n[/Example 3]", "temperature": 0.665, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Hafeez", "UUID": "296ab89e-7208-4f6f-bed1-d623f30e32c9", "question": "Coin Change II: You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.\n\nReturn the number of combinations that make up that amount. If that amount of money cannot be made up by any combination of the coins, return 0.\n\nYou may assume that you have an infinite number of each kind of coin.\n\nThe answer is guaranteed to fit into a signed 32-bit integer.", "examples": "Input: amount = 5, coins = [1,2,5]\nOutput: 4\nExplanation: there are four ways to make up the amount:\n5=5\n5=2+2+1\n5=2+1+1+1\n5=1+1+1+1+1\nInput: amount = 3, coins = [2]\nOutput: 0\nExplanation: the amount of 3 cannot be made up just with coins of 2.", "link": "https://leetcode.com/problems/coin-change-ii/description/", "difficulty": "Medium", "categories": ["Dynamic_programming"], "code": "from typing import List\ndef change(amount: int, coins: List[int]) -> int:\n    def numberOfWays(i: int, amount: int) -> int:\n        if amount == 0:\n            return 1\n        if i == len(coins):\n            return 0\n        if memo[i][amount] != -1:\n            return memo[i][amount]\n\n        if coins[i] > amount:\n            memo[i][amount] = numberOfWays(i + 1, amount)\n        else:\n            memo[i][amount] = numberOfWays(i, amount - coins[i]) + numberOfWays(i + 1, amount)\n        \n        return memo[i][amount]\n\n    memo = [[-1] * (amount + 1) for _ in range(len(coins))]\n    return numberOfWays(0, amount)", "asserts": ["assert change(10,[10])==1", "assert change(0, [1, 2, 5]) == 1  # Edge case: trying to make 0 with any coins should always return 1", "assert change(11, [5]) == 0  # Amount cannot be made up with given coins", "assert change(0, []) == 1  # Edge case: trying to make 0 without any coins, should return 1 as there's one way of making 0 with no coins", "assert change(5, [5, 1]) == 2  # Amount can be made with given coins: [5], [1, 1, 1, 1, 1]"]}, {"author": "Hafeez", "UUID": "d695e67c-5b0e-4235-8406-30ee6be61173", "question": "N-th Tribonacci Number: The Tribonacci sequence Tn is defined as follows: \n\nT0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n >= 0.\n\nGiven n, return the value of Tn.", "examples": "Input: n = 4\nOutput: 4\nExplanation:\nT_3 = 0 + 1 + 1 = 2\nT_4 = 1 + 1 + 2 = 4", "link": "https://leetcode.com/problems/n-th-tribonacci-number/description/", "difficulty": "Easy", "categories": ["Dynamic_programming"], "code": "def tribonacci(n: int) -> int:\n    dp = {0: 0, 1: 1, 2: 1}\n    def dfs(i):\n        if i in dp:\n            return dp[i]\n        dp[i] = dfs(i - 1) + dfs(i - 2) + dfs(i - 3)\n        return dp[i]\n    \n    return dfs(n)", "asserts": ["assert tribonacci(25)==1389537", "assert tribonacci(0) == 0", "assert tribonacci(1) == 1", "assert tribonacci(2) == 1", "assert tribonacci(3) == 2", "assert tribonacci(5) == 7", "assert tribonacci(7) == 24", "assert tribonacci(10) == 149", "assert tribonacci(15) == 3136", "assert tribonacci(30) == 29249425"]}], "category": "Dynamic_programming", "prompt_tokens": 888, "total_tokens": 1221, "completion_tokens": 333, "completion": "Longest Increasing Subsequence: Given an unsorted array of integers, find the length of longest increasing subsequence.\n\n###Code: \n\nfrom typing import List\n\ndef lengthOfLIS(nums: List[int]) -> int:\n    if not nums:\n        return 0\n    \n    dp = [1] * len(nums)\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    \n    return max(dp)\n\n###Testcases: \n\nassert lengthOfLIS([10, 9, 2, 5, 3, 7, 101, 18]) == 4  # The longest increasing subsequence is [2, 3, 7, 101], therefore the length is 4\nassert lengthOfLIS([0, 1, 0, 3, 2, 3]) == 4  # The longest increasing subsequence is [0, 1, 2, 3], therefore the length is 4\nassert lengthOfLIS([7, 7, 7, 7, 7, 7, 7]) == 1  # The longest increasing subsequence is [7], therefore the length is 1\nassert lengthOfLIS([4, 10, 4, 3, 8, 9]) == 3  # The longest increasing subsequence is [4, 8, 9], therefore the length is 3\n\n[/Example 3]", "temperature": 0.843, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Hafeez", "UUID": "38dca76c-ee6c-4c71-83a9-89240828a3b7", "question": "Best Time to Buy and Sell Stock II: You are given an integer array prices where prices[i] is the price of a given stock on the ith day.\n\nOn each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day.\n\nFind and return the maximum profit you can achieve.", "examples": "Input: prices = [7,1,5,3,6,4]\nOutput: 7\nExplanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\nThen buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.\nTotal profit is 4 + 3 = 7.\nInput: prices = [7,6,4,3,1]\nOutput: 0\nExplanation: There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0.", "link": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/", "difficulty": "Medium", "categories": ["Dynamic_programming"], "code": "from typing import List\ndef maxProfit(prices: List[int]) -> int:\n    cur_hold, cur_not_hold = -float('inf'), 0\n    \n    for stock_price in prices:\n        \n        prev_hold, prev_not_hold = cur_hold, cur_not_hold\n        cur_hold = max( prev_hold, prev_not_hold - stock_price )\n        cur_not_hold = max( prev_not_hold, prev_hold + stock_price )\n    return cur_not_hold", "asserts": ["assert maxProfit([1,2,3,4,5])==4", "assert maxProfit([1,2,100,2,1]) == 99"]}, {"author": "Calvin", "UUID": "e35d1110-85e8-4f50-80aa-91eb976b310b", "question": "Return the factorial of a given number n", "examples": "Input: 5\nOutput: 120\n\nInput: 6\nOutput: 720", "link": NaN, "difficulty": null, "categories": ["Dynamic_programming"], "code": "\ndef fact(n: int) -> int:\n  if n <= 1:\n    return 1\n  return n*fact(n-1)\n", "asserts": ["assert fact(5) == 120", "assert fact(0) == 1", "assert fact(1) == 1", "assert fact(3) == 6", "assert fact(7) == 5040", "assert fact(10) == 3628800", "assert fact(4) == 24", "assert fact(8) == 40320", "assert fact(2) == 2", "assert fact(11) == 39916800"]}], "category": "Dynamic_programming", "prompt_tokens": 572, "total_tokens": 883, "completion_tokens": 311, "completion": "Given an array of integers, find the length of the longest increasing subsequence.\n\n###Code: \n\nfrom typing import List\n\ndef lengthOfLIS(nums: List[int]) -> int:\n    if not nums:\n        return 0\n    dp = [1] * len(nums)\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n\n###Testcases: \n\nassert lengthOfLIS([10, 9, 2, 5, 3, 7, 101, 18]) == 4\nassert lengthOfLIS([0, 1, 0, 3, 2, 3]) == 4\nassert lengthOfLIS([7, 7, 7, 7, 7, 7, 7]) == 1\nassert lengthOfLIS([4, 10, 4, 3, 8, 9]) == 3\nassert lengthOfLIS([1, 3, 6, 7, 9, 4, 10, 5, 6]) == 6\nassert lengthOfLIS([3, 5, 6, 2, 5, 4, 19, 5, 6, 7, 12]) == 6\n\n[/Example 3]", "temperature": 0.777, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Calvin", "UUID": "5e7011e5-fee4-4c1a-a98f-3b81e50508cc", "question": "Return nth number in the fibonacci sequence", "examples": "Input: 9\nOutput: 34\n\nInput: 7\nOutput: 13", "link": NaN, "difficulty": null, "categories": ["Dynamic_programming"], "code": "def fibonacci(n: int) -> int:\n    a = 0\n    b = 1\n    if n < 0:\n        print(\"Incorrect input\")\n    elif n == 0:\n        return a\n    elif n == 1:\n        return b\n    else:\n        for i in range(2, n+1):\n            c = a + b\n            a = b\n            b = c\n        return b\n    b = c\n    return fib(n-1, a, b)\n", "asserts": ["assert fibonacci(9) == 34", "assert fibonacci(10) == 55", "assert fibonacci(5) == 5", "assert fibonacci(2) == 1", "assert fibonacci(0) == 0", "assert fibonacci(11) == 89", "assert fibonacci(15) == 610", "assert fibonacci(20) == 6765", "assert fibonacci(25) == 75025", "assert fibonacci(3) == 2", "assert fibonacci(1) == 1", "assert fibonacci(6) == 8", "assert fibonacci(30) == 832040", "assert fibonacci(35) == 9227465", "assert fibonacci(40) == 102334155"]}, {"author": "Hafeez", "UUID": "d695e67c-5b0e-4235-8406-30ee6be61173", "question": "N-th Tribonacci Number: The Tribonacci sequence Tn is defined as follows: \n\nT0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n >= 0.\n\nGiven n, return the value of Tn.", "examples": "Input: n = 4\nOutput: 4\nExplanation:\nT_3 = 0 + 1 + 1 = 2\nT_4 = 1 + 1 + 2 = 4", "link": "https://leetcode.com/problems/n-th-tribonacci-number/description/", "difficulty": "Easy", "categories": ["Dynamic_programming"], "code": "def tribonacci(n: int) -> int:\n    dp = {0: 0, 1: 1, 2: 1}\n    def dfs(i):\n        if i in dp:\n            return dp[i]\n        dp[i] = dfs(i - 1) + dfs(i - 2) + dfs(i - 3)\n        return dp[i]\n    \n    return dfs(n)", "asserts": ["assert tribonacci(25)==1389537", "assert tribonacci(0) == 0", "assert tribonacci(1) == 1", "assert tribonacci(2) == 1", "assert tribonacci(3) == 2", "assert tribonacci(5) == 7", "assert tribonacci(7) == 24", "assert tribonacci(10) == 149", "assert tribonacci(15) == 3136", "assert tribonacci(30) == 29249425"]}], "category": "Dynamic_programming", "prompt_tokens": 735, "total_tokens": 1096, "completion_tokens": 361, "completion": "Find the minimum number of operations needed to transform a string \"s\" into a string \"t\", where the only operations allowed are insertion, deletion, and substitution of a single character.\n\n###Code: \n\ndef minDistance(s: str, t: str) -> int:\n    m, n = len(s), len(t)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    \n    for i in range(m + 1):\n        for j in range(n + 1):\n            if i == 0:\n                dp[i][j] = j\n            elif j == 0:\n                dp[i][j] = i\n            elif s[i - 1] == t[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1]\n            else:\n                dp[i][j] = 1 + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])\n    \n    return dp[m][n]\n\n###Testcases: \n\nassert minDistance(\"horse\", \"ros\") == 3\nassert minDistance(\"intention\", \"execution\") == 5\nassert minDistance(\"kitten\", \"sitting\") == 3\nassert minDistance(\"plasma\", \"altruism\") == 6\nassert minDistance(\"abc\", \"def\") == 3\nassert minDistance(\"abc\", \"abc\") == 0\nassert minDistance(\"abcdef\", \"abcdef\") == 0\nassert minDistance(\"\", \"abc\") == 3\nassert minDistance(\"abc\", \"\") == 3\nassert minDistance(\"\", \"\") == 0\n\n[/Example 3]", "temperature": 0.64, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Calvin", "UUID": "5e7011e5-fee4-4c1a-a98f-3b81e50508cc", "question": "Return nth number in the fibonacci sequence", "examples": "Input: 9\nOutput: 34\n\nInput: 7\nOutput: 13", "link": NaN, "difficulty": null, "categories": ["Dynamic_programming"], "code": "def fibonacci(n: int) -> int:\n    a = 0\n    b = 1\n    if n < 0:\n        print(\"Incorrect input\")\n    elif n == 0:\n        return a\n    elif n == 1:\n        return b\n    else:\n        for i in range(2, n+1):\n            c = a + b\n            a = b\n            b = c\n        return b\n    b = c\n    return fib(n-1, a, b)\n", "asserts": ["assert fibonacci(9) == 34", "assert fibonacci(10) == 55", "assert fibonacci(5) == 5", "assert fibonacci(2) == 1", "assert fibonacci(0) == 0", "assert fibonacci(11) == 89", "assert fibonacci(15) == 610", "assert fibonacci(20) == 6765", "assert fibonacci(25) == 75025", "assert fibonacci(3) == 2", "assert fibonacci(1) == 1", "assert fibonacci(6) == 8", "assert fibonacci(30) == 832040", "assert fibonacci(35) == 9227465", "assert fibonacci(40) == 102334155"]}, {"author": "Hafeez", "UUID": "38dca76c-ee6c-4c71-83a9-89240828a3b7", "question": "Best Time to Buy and Sell Stock II: You are given an integer array prices where prices[i] is the price of a given stock on the ith day.\n\nOn each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day.\n\nFind and return the maximum profit you can achieve.", "examples": "Input: prices = [7,1,5,3,6,4]\nOutput: 7\nExplanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\nThen buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.\nTotal profit is 4 + 3 = 7.\nInput: prices = [7,6,4,3,1]\nOutput: 0\nExplanation: There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0.", "link": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/", "difficulty": "Medium", "categories": ["Dynamic_programming"], "code": "from typing import List\ndef maxProfit(prices: List[int]) -> int:\n    cur_hold, cur_not_hold = -float('inf'), 0\n    \n    for stock_price in prices:\n        \n        prev_hold, prev_not_hold = cur_hold, cur_not_hold\n        cur_hold = max( prev_hold, prev_not_hold - stock_price )\n        cur_not_hold = max( prev_not_hold, prev_hold + stock_price )\n    return cur_not_hold", "asserts": ["assert maxProfit([1,2,3,4,5])==4", "assert maxProfit([1,2,100,2,1]) == 99"]}], "category": "Dynamic_programming", "prompt_tokens": 695, "total_tokens": 958, "completion_tokens": 263, "completion": "Return the length of the longest increasing subsequence in an array.\n\n###Code: \n\nfrom typing import List\n\ndef lengthOfLIS(nums: List[int]) -> int:\n    if not nums:\n        return 0\n    dp = [1] * len(nums)\n    for i in range(len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n\n###Testcases: \n\nassert lengthOfLIS([10, 9, 2, 5, 3, 7, 101, 18]) == 4\nassert lengthOfLIS([0, 1, 0, 3, 2, 3]) == 4\nassert lengthOfLIS([7, 7, 7, 7, 7, 7, 7]) == 1\nassert lengthOfLIS([4, 10, 4, 3, 8, 9]) == 3\nassert lengthOfLIS([1, 3, 6, 7, 9, 4, 10, 5, 6]) == 6\n\n[/Example 3]", "temperature": 0.884, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Hafeez", "UUID": "d695e67c-5b0e-4235-8406-30ee6be61173", "question": "N-th Tribonacci Number: The Tribonacci sequence Tn is defined as follows: \n\nT0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n >= 0.\n\nGiven n, return the value of Tn.", "examples": "Input: n = 4\nOutput: 4\nExplanation:\nT_3 = 0 + 1 + 1 = 2\nT_4 = 1 + 1 + 2 = 4", "link": "https://leetcode.com/problems/n-th-tribonacci-number/description/", "difficulty": "Easy", "categories": ["Dynamic_programming"], "code": "def tribonacci(n: int) -> int:\n    dp = {0: 0, 1: 1, 2: 1}\n    def dfs(i):\n        if i in dp:\n            return dp[i]\n        dp[i] = dfs(i - 1) + dfs(i - 2) + dfs(i - 3)\n        return dp[i]\n    \n    return dfs(n)", "asserts": ["assert tribonacci(25)==1389537", "assert tribonacci(0) == 0", "assert tribonacci(1) == 1", "assert tribonacci(2) == 1", "assert tribonacci(3) == 2", "assert tribonacci(5) == 7", "assert tribonacci(7) == 24", "assert tribonacci(10) == 149", "assert tribonacci(15) == 3136", "assert tribonacci(30) == 29249425"]}, {"author": "Hafeez", "UUID": "6aaf1310-7585-4d90-91e7-1f405c9b25e7", "question": "Get Maximum in Generated Array: You are given an integer n. A 0-indexed integer array nums of length n + 1 is generated in the following way:\n\nnums[0] = 0\nnums[1] = 1\nnums[2 * i] = nums[i] when 2 <= 2 * i <= n\nnums[2 * i + 1] = nums[i] + nums[i + 1] when 2 <= 2 * i + 1 <= n\nReturn the maximum integer in the array nums\u200b\u200b\u200b.", "examples": "Input: n = 7\nOutput: 3\nExplanation: According to the given rules:\n  nums[0] = 0\n  nums[1] = 1\n  nums[(1 * 2) = 2] = nums[1] = 1\n  nums[(1 * 2) + 1 = 3] = nums[1] + nums[2] = 1 + 1 = 2\n  nums[(2 * 2) = 4] = nums[2] = 1\n  nums[(2 * 2) + 1 = 5] = nums[2] + nums[3] = 1 + 2 = 3\n  nums[(3 * 2) = 6] = nums[3] = 2\n  nums[(3 * 2) + 1 = 7] = nums[3] + nums[4] = 2 + 1 = 3\nHence, nums = [0,1,1,2,1,3,2,3], and the maximum is max(0,1,1,2,1,3,2,3) = 3.\nInput: n = 2\nOutput: 1\nExplanation: According to the given rules, nums = [0,1,1]. The maximum is max(0,1,1) = 1.\nInput: n = 3\nOutput: 2\nExplanation: According to the given rules, nums = [0,1,1,2]. The maximum is max(0,1,1,2) = 2.", "link": "https://leetcode.com/problems/get-maximum-in-generated-array/", "difficulty": "Easy", "categories": ["Dynamic_programming"], "code": "def getMaximumGenerated(n: int) -> int:\n    if n<2:\n        return n\n    nums=[0]*(n+1)\n    nums[0]=0\n    nums[1]=1\n    for i in range(2,n+1):\n        if i%2==0:\n            nums[i]=nums[i//2]\n        else:\n            nums[i]=nums[i//2]+nums[i//2+1]\n    return max(nums)", "asserts": ["assert getMaximumGenerated(2)==1", "assert getMaximumGenerated(4) == 2", "assert getMaximumGenerated(5) == 3", "assert getMaximumGenerated(8) == 3", "assert getMaximumGenerated(15) == 5", "assert getMaximumGenerated(0) == 0", "assert getMaximumGenerated(1) == 1"]}], "category": "Dynamic_programming", "prompt_tokens": 764, "total_tokens": 1049, "completion_tokens": 285, "completion": "Maximum Subarray: Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.\n\n###Code: \n\ndef maxSubArray(nums: List[int]) -> int:\n    max_sum = nums[0]\n    current_sum = nums[0]\n    \n    for num in nums[1:]:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    \n    return max_sum\n\n###Testcases: \n\nassert maxSubArray([-2,1,-3,4,-1,2,1,-5,4]) == 6\nassert maxSubArray([1]) == 1\nassert maxSubArray([5,4,-1,7,8]) == 23\nassert maxSubArray([-2,1,-3,4,-1,2,1,-5,4]) == 6\nassert maxSubArray([1,2]) == 3\nassert maxSubArray([-2, -1]) == -1\nassert maxSubArray([-2, -3, 4, -1, -2, 1, 5, -3]) == 7\nassert maxSubArray([-1, -2, -3, -4, -5, -6, -7]) == -1\n\n[/Example 3]", "temperature": 0.764, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Hafeez", "UUID": "296ab89e-7208-4f6f-bed1-d623f30e32c9", "question": "Coin Change II: You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.\n\nReturn the number of combinations that make up that amount. If that amount of money cannot be made up by any combination of the coins, return 0.\n\nYou may assume that you have an infinite number of each kind of coin.\n\nThe answer is guaranteed to fit into a signed 32-bit integer.", "examples": "Input: amount = 5, coins = [1,2,5]\nOutput: 4\nExplanation: there are four ways to make up the amount:\n5=5\n5=2+2+1\n5=2+1+1+1\n5=1+1+1+1+1\nInput: amount = 3, coins = [2]\nOutput: 0\nExplanation: the amount of 3 cannot be made up just with coins of 2.", "link": "https://leetcode.com/problems/coin-change-ii/description/", "difficulty": "Medium", "categories": ["Dynamic_programming"], "code": "from typing import List\ndef change(amount: int, coins: List[int]) -> int:\n    def numberOfWays(i: int, amount: int) -> int:\n        if amount == 0:\n            return 1\n        if i == len(coins):\n            return 0\n        if memo[i][amount] != -1:\n            return memo[i][amount]\n\n        if coins[i] > amount:\n            memo[i][amount] = numberOfWays(i + 1, amount)\n        else:\n            memo[i][amount] = numberOfWays(i, amount - coins[i]) + numberOfWays(i + 1, amount)\n        \n        return memo[i][amount]\n\n    memo = [[-1] * (amount + 1) for _ in range(len(coins))]\n    return numberOfWays(0, amount)", "asserts": ["assert change(10,[10])==1", "assert change(0, [1, 2, 5]) == 1  # Edge case: trying to make 0 with any coins should always return 1", "assert change(11, [5]) == 0  # Amount cannot be made up with given coins", "assert change(0, []) == 1  # Edge case: trying to make 0 without any coins, should return 1 as there's one way of making 0 with no coins", "assert change(5, [5, 1]) == 2  # Amount can be made with given coins: [5], [1, 1, 1, 1, 1]"]}, {"author": "Hafeez", "UUID": "d695e67c-5b0e-4235-8406-30ee6be61173", "question": "N-th Tribonacci Number: The Tribonacci sequence Tn is defined as follows: \n\nT0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n >= 0.\n\nGiven n, return the value of Tn.", "examples": "Input: n = 4\nOutput: 4\nExplanation:\nT_3 = 0 + 1 + 1 = 2\nT_4 = 1 + 1 + 2 = 4", "link": "https://leetcode.com/problems/n-th-tribonacci-number/description/", "difficulty": "Easy", "categories": ["Dynamic_programming"], "code": "def tribonacci(n: int) -> int:\n    dp = {0: 0, 1: 1, 2: 1}\n    def dfs(i):\n        if i in dp:\n            return dp[i]\n        dp[i] = dfs(i - 1) + dfs(i - 2) + dfs(i - 3)\n        return dp[i]\n    \n    return dfs(n)", "asserts": ["assert tribonacci(25)==1389537", "assert tribonacci(0) == 0", "assert tribonacci(1) == 1", "assert tribonacci(2) == 1", "assert tribonacci(3) == 2", "assert tribonacci(5) == 7", "assert tribonacci(7) == 24", "assert tribonacci(10) == 149", "assert tribonacci(15) == 3136", "assert tribonacci(30) == 29249425"]}], "category": "Dynamic_programming", "prompt_tokens": 888, "total_tokens": 1151, "completion_tokens": 263, "completion": "Maximum Subarray: Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.\n\n###Code: \n\nfrom typing import List\ndef maxSubArray(nums: List[int]) -> int:\n    max_sum = float('-inf')\n    current_sum = 0\n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    return max_sum\n\n###Testcases: \n\nassert maxSubArray([-2,1,-3,4,-1,2,1,-5,4]) == 6  # Subarray [4,-1,2,1] has the largest sum 6\nassert maxSubArray([1]) == 1  # Subarray [1] has the largest sum 1\nassert maxSubArray([5,4,-1,7,8]) == 23  # Subarray [5,4,-1,7,8] has the largest sum 23\nassert maxSubArray([-2,-1,-3,-4,-1,-2,-1,-5,-4]) == -1  # Subarray [-1] has the largest sum -1\n\n[/Example 3]", "temperature": 0.815, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Hafeez", "UUID": "6aaf1310-7585-4d90-91e7-1f405c9b25e7", "question": "Get Maximum in Generated Array: You are given an integer n. A 0-indexed integer array nums of length n + 1 is generated in the following way:\n\nnums[0] = 0\nnums[1] = 1\nnums[2 * i] = nums[i] when 2 <= 2 * i <= n\nnums[2 * i + 1] = nums[i] + nums[i + 1] when 2 <= 2 * i + 1 <= n\nReturn the maximum integer in the array nums\u200b\u200b\u200b.", "examples": "Input: n = 7\nOutput: 3\nExplanation: According to the given rules:\n  nums[0] = 0\n  nums[1] = 1\n  nums[(1 * 2) = 2] = nums[1] = 1\n  nums[(1 * 2) + 1 = 3] = nums[1] + nums[2] = 1 + 1 = 2\n  nums[(2 * 2) = 4] = nums[2] = 1\n  nums[(2 * 2) + 1 = 5] = nums[2] + nums[3] = 1 + 2 = 3\n  nums[(3 * 2) = 6] = nums[3] = 2\n  nums[(3 * 2) + 1 = 7] = nums[3] + nums[4] = 2 + 1 = 3\nHence, nums = [0,1,1,2,1,3,2,3], and the maximum is max(0,1,1,2,1,3,2,3) = 3.\nInput: n = 2\nOutput: 1\nExplanation: According to the given rules, nums = [0,1,1]. The maximum is max(0,1,1) = 1.\nInput: n = 3\nOutput: 2\nExplanation: According to the given rules, nums = [0,1,1,2]. The maximum is max(0,1,1,2) = 2.", "link": "https://leetcode.com/problems/get-maximum-in-generated-array/", "difficulty": "Easy", "categories": ["Dynamic_programming"], "code": "def getMaximumGenerated(n: int) -> int:\n    if n<2:\n        return n\n    nums=[0]*(n+1)\n    nums[0]=0\n    nums[1]=1\n    for i in range(2,n+1):\n        if i%2==0:\n            nums[i]=nums[i//2]\n        else:\n            nums[i]=nums[i//2]+nums[i//2+1]\n    return max(nums)", "asserts": ["assert getMaximumGenerated(2)==1", "assert getMaximumGenerated(4) == 2", "assert getMaximumGenerated(5) == 3", "assert getMaximumGenerated(8) == 3", "assert getMaximumGenerated(15) == 5", "assert getMaximumGenerated(0) == 0", "assert getMaximumGenerated(1) == 1"]}, {"author": "Calvin", "UUID": "51a5caf9-241f-4de3-9ee2-9420490b73d7", "question": "Given a set[] of non-negative integers and a value sum, return the subset of the given set whose sum is equal to the given sum or None if one doesn't exist\n", "examples": "Input: set = [1, 2, 3, 4, 5], sum = 10\nOutput: [1, 2, 3, 4]", "link": "https://www.geeksforgeeks.org/subset-sum-problem-dp-25/", "difficulty": null, "categories": ["Dynamic_programming"], "code": "def subsetsum(fullset: list, target_sum: int) -> set:\n    def subsetSum_helper(cur_idx: int, fullset: list, target_sum: int, subset: list):\n        if target_sum == 0:\n            return subset\n        if (cur_idx == len(fullset)):\n            return None\n        excluding = subsetSum_helper(cur_idx + 1, fullset, target_sum, subset)\n          \n        if excluding is not None:\n            return excluding\n        elif fullset[cur_idx] <= target_sum:\n            subset.append(fullset[cur_idx])\n            including = subsetSum_helper(cur_idx + 1, fullset, target_sum - fullset[cur_idx], subset)\n            if including!=None:\n                return including\n            else:\n                subset.pop()\n            return None\n    return subsetSum_helper(0, fullset, target_sum, [])\n", "asserts": ["assert set(subsetsum([3, 34, 4, 12, 5, 2], 9)) == {4,5}", "assert subsetsum([1, 8, 2, 7, 4], 14) == [8, 2, 4]", "assert subsetsum([10, 12, 15, 6, 19], 21) == [15, 6]", "assert subsetsum([5, 10, 12, 13, 15, 18], 30) == [12, 18]", "assert subsetsum([5, 3, 9, 12, 6, 15], 27) == [12, 15]", "assert subsetsum([2, 3, 7, 8, 10], 11) == [3, 8]", "assert subsetsum([6, 2, 7, 11, 8], 16) == [6, 2, 8]", "assert subsetsum([5, 7, 1, 14, 6], 13) == [7, 6]", "assert subsetsum([1], 1) == [1]", "assert subsetsum([2, 5, 8, 4], 0) == []", "assert subsetsum([], 5) == None", "assert subsetsum([-1, -2, -3, -4, -5], -10) == None  # Negative numbers are not allowed according to the question", "assert subsetsum([4, 1, 2, 5, 12, 7], 9) == [2, 7]", "assert subsetsum([3, 5, 8, 4], 22) == None  # Sum exceeds the sum of all elements"]}], "category": "Dynamic_programming", "prompt_tokens": 1102, "total_tokens": 1528, "completion_tokens": 426, "completion": "Find the length of the longest increasing subsequence in a given array of integers.\n\n###Code:\n\n```python\ndef lengthOfLIS(nums: List[int]) -> int:\n    if not nums:\n        return 0\n    dp = [1] * len(nums)\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n```\n\n###Testcases:\n\n```python\nassert lengthOfLIS([10, 9, 2, 5, 3, 7, 101, 18]) == 4  # The longest increasing subsequence is [2, 3, 7, 101]\nassert lengthOfLIS([0, 1, 0, 3, 2, 3]) == 4  # The longest increasing subsequence is [0, 1, 2, 3]\nassert lengthOfLIS([7, 7, 7, 7, 7, 7, 7]) == 1  # The longest increasing subsequence is [7]\nassert lengthOfLIS([4, 10, 4, 3, 8, 9]) == 3  # The longest increasing subsequence is [4, 8, 9]\nassert lengthOfLIS([1, 3, 6, 7, 9, 4, 10, 5, 6]) == 6  # The longest increasing subsequence is [1, 3, 6, 7, 9, 10]\nassert lengthOfLIS([1, 3, 2]) == 2  # The longest increasing subsequence is [1, 3] or [1, 2]\nassert lengthOfLIS([]) == 0  # Empty array\nassert lengthOfLIS([5]) == 1  # Single element array\n```\n\n", "temperature": 0.661, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Calvin", "UUID": "e35d1110-85e8-4f50-80aa-91eb976b310b", "question": "Return the factorial of a given number n", "examples": "Input: 5\nOutput: 120\n\nInput: 6\nOutput: 720", "link": NaN, "difficulty": null, "categories": ["Dynamic_programming"], "code": "\ndef fact(n: int) -> int:\n  if n <= 1:\n    return 1\n  return n*fact(n-1)\n", "asserts": ["assert fact(5) == 120", "assert fact(0) == 1", "assert fact(1) == 1", "assert fact(3) == 6", "assert fact(7) == 5040", "assert fact(10) == 3628800", "assert fact(4) == 24", "assert fact(8) == 40320", "assert fact(2) == 2", "assert fact(11) == 39916800"]}, {"author": "Calvin", "UUID": "51a5caf9-241f-4de3-9ee2-9420490b73d7", "question": "Given a set[] of non-negative integers and a value sum, return the subset of the given set whose sum is equal to the given sum or None if one doesn't exist\n", "examples": "Input: set = [1, 2, 3, 4, 5], sum = 10\nOutput: [1, 2, 3, 4]", "link": "https://www.geeksforgeeks.org/subset-sum-problem-dp-25/", "difficulty": null, "categories": ["Dynamic_programming"], "code": "def subsetsum(fullset: list, target_sum: int) -> set:\n    def subsetSum_helper(cur_idx: int, fullset: list, target_sum: int, subset: list):\n        if target_sum == 0:\n            return subset\n        if (cur_idx == len(fullset)):\n            return None\n        excluding = subsetSum_helper(cur_idx + 1, fullset, target_sum, subset)\n          \n        if excluding is not None:\n            return excluding\n        elif fullset[cur_idx] <= target_sum:\n            subset.append(fullset[cur_idx])\n            including = subsetSum_helper(cur_idx + 1, fullset, target_sum - fullset[cur_idx], subset)\n            if including!=None:\n                return including\n            else:\n                subset.pop()\n            return None\n    return subsetSum_helper(0, fullset, target_sum, [])\n", "asserts": ["assert set(subsetsum([3, 34, 4, 12, 5, 2], 9)) == {4,5}", "assert subsetsum([1, 8, 2, 7, 4], 14) == [8, 2, 4]", "assert subsetsum([10, 12, 15, 6, 19], 21) == [15, 6]", "assert subsetsum([5, 10, 12, 13, 15, 18], 30) == [12, 18]", "assert subsetsum([5, 3, 9, 12, 6, 15], 27) == [12, 15]", "assert subsetsum([2, 3, 7, 8, 10], 11) == [3, 8]", "assert subsetsum([6, 2, 7, 11, 8], 16) == [6, 2, 8]", "assert subsetsum([5, 7, 1, 14, 6], 13) == [7, 6]", "assert subsetsum([1], 1) == [1]", "assert subsetsum([2, 5, 8, 4], 0) == []", "assert subsetsum([], 5) == None", "assert subsetsum([-1, -2, -3, -4, -5], -10) == None  # Negative numbers are not allowed according to the question", "assert subsetsum([4, 1, 2, 5, 12, 7], 9) == [2, 7]", "assert subsetsum([3, 5, 8, 4], 22) == None  # Sum exceeds the sum of all elements"]}], "category": "Dynamic_programming", "prompt_tokens": 950, "total_tokens": 1345, "completion_tokens": 395, "completion": "Return the maximum sum subarray of a given array using Kadane's algorithm\n\n###Code: \n\n\ndef kadane_max_subarray(arr: list) -> int:\n    max_ending_here = max_so_far = arr[0]\n    for x in arr[1:]:\n        max_ending_here = max(x, max_ending_here + x)\n        max_so_far = max(max_so_far, max_ending_here)\n    return max_so_far\n\n\n###Testcases: \n\nassert kadane_max_subarray([-2, 1, -3, 4, -1, 2, 1, -5, 4]) == 6\nassert kadane_max_subarray([-2, -3, 4, -1, -2, 1, 5, -3]) == 7\nassert kadane_max_subarray([1, 2, 3, -2, 5]) == 9\nassert kadane_max_subarray([-2, -1, -3, -4, -1, -2, -1, -5, -4]) == -1\nassert kadane_max_subarray([-1, -2, -3, -4, -5]) == -1\nassert kadane_max_subarray([-5, -4, -3, -2, -1]) == -1\nassert kadane_max_subarray([2, 3, 4, 5, 6]) == 20\nassert kadane_max_subarray([-2, -5, 6, -2, -3, 1, 5, -6]) == 7\nassert kadane_max_subarray([1]) == 1\nassert kadane_max_subarray([-1]) == -1\nassert kadane_max_subarray([0, 0, 0, 0, 0]) == 0\n\n[/Example 3]", "temperature": 0.928, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Calvin", "UUID": "e35d1110-85e8-4f50-80aa-91eb976b310b", "question": "Return the factorial of a given number n", "examples": "Input: 5\nOutput: 120\n\nInput: 6\nOutput: 720", "link": NaN, "difficulty": null, "categories": ["Dynamic_programming"], "code": "\ndef fact(n: int) -> int:\n  if n <= 1:\n    return 1\n  return n*fact(n-1)\n", "asserts": ["assert fact(5) == 120", "assert fact(0) == 1", "assert fact(1) == 1", "assert fact(3) == 6", "assert fact(7) == 5040", "assert fact(10) == 3628800", "assert fact(4) == 24", "assert fact(8) == 40320", "assert fact(2) == 2", "assert fact(11) == 39916800"]}, {"author": "Hafeez", "UUID": "38dca76c-ee6c-4c71-83a9-89240828a3b7", "question": "Best Time to Buy and Sell Stock II: You are given an integer array prices where prices[i] is the price of a given stock on the ith day.\n\nOn each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day.\n\nFind and return the maximum profit you can achieve.", "examples": "Input: prices = [7,1,5,3,6,4]\nOutput: 7\nExplanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\nThen buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.\nTotal profit is 4 + 3 = 7.\nInput: prices = [7,6,4,3,1]\nOutput: 0\nExplanation: There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0.", "link": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/", "difficulty": "Medium", "categories": ["Dynamic_programming"], "code": "from typing import List\ndef maxProfit(prices: List[int]) -> int:\n    cur_hold, cur_not_hold = -float('inf'), 0\n    \n    for stock_price in prices:\n        \n        prev_hold, prev_not_hold = cur_hold, cur_not_hold\n        cur_hold = max( prev_hold, prev_not_hold - stock_price )\n        cur_not_hold = max( prev_not_hold, prev_hold + stock_price )\n    return cur_not_hold", "asserts": ["assert maxProfit([1,2,3,4,5])==4", "assert maxProfit([1,2,100,2,1]) == 99"]}], "category": "Dynamic_programming", "prompt_tokens": 572, "total_tokens": 917, "completion_tokens": 345, "completion": "Find the minimum number of coins required to make up a given amount. You have an infinite supply of each coin denomination.\n\n###Code: \n\ndef minCoins(coins, amount):\n    dp = [float('inf')] * (amount + 1)\n    dp[0] = 0\n    for coin in coins:\n        for i in range(coin, amount + 1):\n            dp[i] = min(dp[i], dp[i - coin] + 1)\n    return dp[amount]\n\n###Testcases: \n\nassert minCoins([1, 2, 5], 11) == 3\nassert minCoins([1, 2, 5, 10], 13) == 2\nassert minCoins([1, 3, 4], 6) == 2\nassert minCoins([1, 2, 5, 10, 20, 50, 100], 99) == 6\nassert minCoins([1, 3, 4, 7, 10], 12) == 2\nassert minCoins([1, 5, 10, 25, 50], 30) == 2\nassert minCoins([1, 2, 5], 8) == 2\nassert minCoins([1, 2, 5, 10, 20], 13) == 2\nassert minCoins([1, 3, 4, 9], 10) == 2\nassert minCoins([1, 2, 3, 6, 10], 12) == 2\n\n[/Example 3]", "temperature": 0.868, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Calvin", "UUID": "51a5caf9-241f-4de3-9ee2-9420490b73d7", "question": "Given a set[] of non-negative integers and a value sum, return the subset of the given set whose sum is equal to the given sum or None if one doesn't exist\n", "examples": "Input: set = [1, 2, 3, 4, 5], sum = 10\nOutput: [1, 2, 3, 4]", "link": "https://www.geeksforgeeks.org/subset-sum-problem-dp-25/", "difficulty": null, "categories": ["Dynamic_programming"], "code": "def subsetsum(fullset: list, target_sum: int) -> set:\n    def subsetSum_helper(cur_idx: int, fullset: list, target_sum: int, subset: list):\n        if target_sum == 0:\n            return subset\n        if (cur_idx == len(fullset)):\n            return None\n        excluding = subsetSum_helper(cur_idx + 1, fullset, target_sum, subset)\n          \n        if excluding is not None:\n            return excluding\n        elif fullset[cur_idx] <= target_sum:\n            subset.append(fullset[cur_idx])\n            including = subsetSum_helper(cur_idx + 1, fullset, target_sum - fullset[cur_idx], subset)\n            if including!=None:\n                return including\n            else:\n                subset.pop()\n            return None\n    return subsetSum_helper(0, fullset, target_sum, [])\n", "asserts": ["assert set(subsetsum([3, 34, 4, 12, 5, 2], 9)) == {4,5}", "assert subsetsum([1, 8, 2, 7, 4], 14) == [8, 2, 4]", "assert subsetsum([10, 12, 15, 6, 19], 21) == [15, 6]", "assert subsetsum([5, 10, 12, 13, 15, 18], 30) == [12, 18]", "assert subsetsum([5, 3, 9, 12, 6, 15], 27) == [12, 15]", "assert subsetsum([2, 3, 7, 8, 10], 11) == [3, 8]", "assert subsetsum([6, 2, 7, 11, 8], 16) == [6, 2, 8]", "assert subsetsum([5, 7, 1, 14, 6], 13) == [7, 6]", "assert subsetsum([1], 1) == [1]", "assert subsetsum([2, 5, 8, 4], 0) == []", "assert subsetsum([], 5) == None", "assert subsetsum([-1, -2, -3, -4, -5], -10) == None  # Negative numbers are not allowed according to the question", "assert subsetsum([4, 1, 2, 5, 12, 7], 9) == [2, 7]", "assert subsetsum([3, 5, 8, 4], 22) == None  # Sum exceeds the sum of all elements"]}, {"author": "Hafeez", "UUID": "d695e67c-5b0e-4235-8406-30ee6be61173", "question": "N-th Tribonacci Number: The Tribonacci sequence Tn is defined as follows: \n\nT0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n >= 0.\n\nGiven n, return the value of Tn.", "examples": "Input: n = 4\nOutput: 4\nExplanation:\nT_3 = 0 + 1 + 1 = 2\nT_4 = 1 + 1 + 2 = 4", "link": "https://leetcode.com/problems/n-th-tribonacci-number/description/", "difficulty": "Easy", "categories": ["Dynamic_programming"], "code": "def tribonacci(n: int) -> int:\n    dp = {0: 0, 1: 1, 2: 1}\n    def dfs(i):\n        if i in dp:\n            return dp[i]\n        dp[i] = dfs(i - 1) + dfs(i - 2) + dfs(i - 3)\n        return dp[i]\n    \n    return dfs(n)", "asserts": ["assert tribonacci(25)==1389537", "assert tribonacci(0) == 0", "assert tribonacci(1) == 1", "assert tribonacci(2) == 1", "assert tribonacci(3) == 2", "assert tribonacci(5) == 7", "assert tribonacci(7) == 24", "assert tribonacci(10) == 149", "assert tribonacci(15) == 3136", "assert tribonacci(30) == 29249425"]}], "category": "Dynamic_programming", "prompt_tokens": 1071, "total_tokens": 1436, "completion_tokens": 365, "completion": "Given a non-empty array of integers, return the maximum product that can be obtained by multiplying any subset of the array.\n\n###Code: \n\ndef max_product_subset(nums: List[int]) -> int:\n        max_product = min_product = result = nums[0]\n\n        for i in range(1, len(nums)):\n            if nums[i] < 0:\n                max_product, min_product = min_product, max_product\n\n            max_product = max(nums[i], max_product * nums[i])\n            min_product = min(nums[i], min_product * nums[i])\n\n            result = max(result, max_product)\n\n        return result\n\n###Testcases: \n\nassert max_product_subset([2, 3, -2, 4]) == 6\nassert max_product_subset([-2, 0, -1]) == 0\nassert max_product_subset([2, -5, -2, -4, 3]) == 24\nassert max_product_subset([5, -3, 4, 2, 1, -1, 0, 5]) == 240\nassert max_product_subset([5, 3, 4, 2, 1, 0, 5]) == 240\nassert max_product_subset([5, 3, 4, 2, 1, 5]) == 600\nassert max_product_subset([1, 2, 3, 4, 5, 6]) == 720\nassert max_product_subset([-1, -2, -3, -4, -5, -6]) == 720\nassert max_product_subset([-1, -2, -3, 0, -4, -5, -6]) == 120\n\n[/Example 3]", "temperature": 0.814, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Hafeez", "UUID": "296ab89e-7208-4f6f-bed1-d623f30e32c9", "question": "Coin Change II: You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.\n\nReturn the number of combinations that make up that amount. If that amount of money cannot be made up by any combination of the coins, return 0.\n\nYou may assume that you have an infinite number of each kind of coin.\n\nThe answer is guaranteed to fit into a signed 32-bit integer.", "examples": "Input: amount = 5, coins = [1,2,5]\nOutput: 4\nExplanation: there are four ways to make up the amount:\n5=5\n5=2+2+1\n5=2+1+1+1\n5=1+1+1+1+1\nInput: amount = 3, coins = [2]\nOutput: 0\nExplanation: the amount of 3 cannot be made up just with coins of 2.", "link": "https://leetcode.com/problems/coin-change-ii/description/", "difficulty": "Medium", "categories": ["Dynamic_programming"], "code": "from typing import List\ndef change(amount: int, coins: List[int]) -> int:\n    def numberOfWays(i: int, amount: int) -> int:\n        if amount == 0:\n            return 1\n        if i == len(coins):\n            return 0\n        if memo[i][amount] != -1:\n            return memo[i][amount]\n\n        if coins[i] > amount:\n            memo[i][amount] = numberOfWays(i + 1, amount)\n        else:\n            memo[i][amount] = numberOfWays(i, amount - coins[i]) + numberOfWays(i + 1, amount)\n        \n        return memo[i][amount]\n\n    memo = [[-1] * (amount + 1) for _ in range(len(coins))]\n    return numberOfWays(0, amount)", "asserts": ["assert change(10,[10])==1", "assert change(0, [1, 2, 5]) == 1  # Edge case: trying to make 0 with any coins should always return 1", "assert change(11, [5]) == 0  # Amount cannot be made up with given coins", "assert change(0, []) == 1  # Edge case: trying to make 0 without any coins, should return 1 as there's one way of making 0 with no coins", "assert change(5, [5, 1]) == 2  # Amount can be made with given coins: [5], [1, 1, 1, 1, 1]"]}, {"author": "Calvin", "UUID": "5e7011e5-fee4-4c1a-a98f-3b81e50508cc", "question": "Return nth number in the fibonacci sequence", "examples": "Input: 9\nOutput: 34\n\nInput: 7\nOutput: 13", "link": NaN, "difficulty": null, "categories": ["Dynamic_programming"], "code": "def fibonacci(n: int) -> int:\n    a = 0\n    b = 1\n    if n < 0:\n        print(\"Incorrect input\")\n    elif n == 0:\n        return a\n    elif n == 1:\n        return b\n    else:\n        for i in range(2, n+1):\n            c = a + b\n            a = b\n            b = c\n        return b\n    b = c\n    return fib(n-1, a, b)\n", "asserts": ["assert fibonacci(9) == 34", "assert fibonacci(10) == 55", "assert fibonacci(5) == 5", "assert fibonacci(2) == 1", "assert fibonacci(0) == 0", "assert fibonacci(11) == 89", "assert fibonacci(15) == 610", "assert fibonacci(20) == 6765", "assert fibonacci(25) == 75025", "assert fibonacci(3) == 2", "assert fibonacci(1) == 1", "assert fibonacci(6) == 8", "assert fibonacci(30) == 832040", "assert fibonacci(35) == 9227465", "assert fibonacci(40) == 102334155"]}], "category": "Dynamic_programming", "prompt_tokens": 890, "total_tokens": 1239, "completion_tokens": 349, "completion": "Find the length of the longest increasing subsequence in an array of integers.\n\n###Code: \n\ndef lengthOfLIS(nums: List[int]) -> int:\n    if not nums:\n        return 0\n    dp = [1] * len(nums)\n    for i in range(len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n\n###Testcases: \n\nassert lengthOfLIS([10, 9, 2, 5, 3, 7, 101, 18]) == 4  # The longest increasing subsequence is [2, 3, 7, 101]\nassert lengthOfLIS([0, 1, 0, 3, 2, 3]) == 4  # The longest increasing subsequence is [0, 1, 2, 3]\nassert lengthOfLIS([7, 7, 7, 7, 7, 7, 7]) == 1  # The longest increasing subsequence is [7]\nassert lengthOfLIS([4, 10, 4, 3, 8, 9]) == 3  # The longest increasing subsequence is [4, 8, 9]\nassert lengthOfLIS([1, 3, 6, 7, 9, 4, 10, 5, 6]) == 6  # The longest increasing subsequence is [1, 3, 6, 7, 9, 10]\n\n[/Example 3]", "temperature": 0.936, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Calvin", "UUID": "51a5caf9-241f-4de3-9ee2-9420490b73d7", "question": "Given a set[] of non-negative integers and a value sum, return the subset of the given set whose sum is equal to the given sum or None if one doesn't exist\n", "examples": "Input: set = [1, 2, 3, 4, 5], sum = 10\nOutput: [1, 2, 3, 4]", "link": "https://www.geeksforgeeks.org/subset-sum-problem-dp-25/", "difficulty": null, "categories": ["Dynamic_programming"], "code": "def subsetsum(fullset: list, target_sum: int) -> set:\n    def subsetSum_helper(cur_idx: int, fullset: list, target_sum: int, subset: list):\n        if target_sum == 0:\n            return subset\n        if (cur_idx == len(fullset)):\n            return None\n        excluding = subsetSum_helper(cur_idx + 1, fullset, target_sum, subset)\n          \n        if excluding is not None:\n            return excluding\n        elif fullset[cur_idx] <= target_sum:\n            subset.append(fullset[cur_idx])\n            including = subsetSum_helper(cur_idx + 1, fullset, target_sum - fullset[cur_idx], subset)\n            if including!=None:\n                return including\n            else:\n                subset.pop()\n            return None\n    return subsetSum_helper(0, fullset, target_sum, [])\n", "asserts": ["assert set(subsetsum([3, 34, 4, 12, 5, 2], 9)) == {4,5}", "assert subsetsum([1, 8, 2, 7, 4], 14) == [8, 2, 4]", "assert subsetsum([10, 12, 15, 6, 19], 21) == [15, 6]", "assert subsetsum([5, 10, 12, 13, 15, 18], 30) == [12, 18]", "assert subsetsum([5, 3, 9, 12, 6, 15], 27) == [12, 15]", "assert subsetsum([2, 3, 7, 8, 10], 11) == [3, 8]", "assert subsetsum([6, 2, 7, 11, 8], 16) == [6, 2, 8]", "assert subsetsum([5, 7, 1, 14, 6], 13) == [7, 6]", "assert subsetsum([1], 1) == [1]", "assert subsetsum([2, 5, 8, 4], 0) == []", "assert subsetsum([], 5) == None", "assert subsetsum([-1, -2, -3, -4, -5], -10) == None  # Negative numbers are not allowed according to the question", "assert subsetsum([4, 1, 2, 5, 12, 7], 9) == [2, 7]", "assert subsetsum([3, 5, 8, 4], 22) == None  # Sum exceeds the sum of all elements"]}, {"author": "Hafeez", "UUID": "6aaf1310-7585-4d90-91e7-1f405c9b25e7", "question": "Get Maximum in Generated Array: You are given an integer n. A 0-indexed integer array nums of length n + 1 is generated in the following way:\n\nnums[0] = 0\nnums[1] = 1\nnums[2 * i] = nums[i] when 2 <= 2 * i <= n\nnums[2 * i + 1] = nums[i] + nums[i + 1] when 2 <= 2 * i + 1 <= n\nReturn the maximum integer in the array nums\u200b\u200b\u200b.", "examples": "Input: n = 7\nOutput: 3\nExplanation: According to the given rules:\n  nums[0] = 0\n  nums[1] = 1\n  nums[(1 * 2) = 2] = nums[1] = 1\n  nums[(1 * 2) + 1 = 3] = nums[1] + nums[2] = 1 + 1 = 2\n  nums[(2 * 2) = 4] = nums[2] = 1\n  nums[(2 * 2) + 1 = 5] = nums[2] + nums[3] = 1 + 2 = 3\n  nums[(3 * 2) = 6] = nums[3] = 2\n  nums[(3 * 2) + 1 = 7] = nums[3] + nums[4] = 2 + 1 = 3\nHence, nums = [0,1,1,2,1,3,2,3], and the maximum is max(0,1,1,2,1,3,2,3) = 3.\nInput: n = 2\nOutput: 1\nExplanation: According to the given rules, nums = [0,1,1]. The maximum is max(0,1,1) = 1.\nInput: n = 3\nOutput: 2\nExplanation: According to the given rules, nums = [0,1,1,2]. The maximum is max(0,1,1,2) = 2.", "link": "https://leetcode.com/problems/get-maximum-in-generated-array/", "difficulty": "Easy", "categories": ["Dynamic_programming"], "code": "def getMaximumGenerated(n: int) -> int:\n    if n<2:\n        return n\n    nums=[0]*(n+1)\n    nums[0]=0\n    nums[1]=1\n    for i in range(2,n+1):\n        if i%2==0:\n            nums[i]=nums[i//2]\n        else:\n            nums[i]=nums[i//2]+nums[i//2+1]\n    return max(nums)", "asserts": ["assert getMaximumGenerated(2)==1", "assert getMaximumGenerated(4) == 2", "assert getMaximumGenerated(5) == 3", "assert getMaximumGenerated(8) == 3", "assert getMaximumGenerated(15) == 5", "assert getMaximumGenerated(0) == 0", "assert getMaximumGenerated(1) == 1"]}], "category": "Dynamic_programming", "prompt_tokens": 1102, "total_tokens": 1561, "completion_tokens": 459, "completion": "Find the minimum number of coins required to make up a given amount using the denominations provided.\n\n###Code:\n\n```python\ndef minCoins(coins, amount):\n    dp = [float('inf')] * (amount + 1)\n    dp[0] = 0\n    for coin in coins:\n        for i in range(coin, amount + 1):\n            dp[i] = min(dp[i], dp[i - coin] + 1)\n    return dp[amount] if dp[amount] != float('inf') else -1\n```\n\n###Testcases:\n\n```python\nassert minCoins([1, 2, 5], 11) == 3  # 11 = 5 + 5 + 1\nassert minCoins([1, 2, 5, 10, 20, 50, 100], 23) == 5  # 23 = 10 + 10 + 2 + 1\nassert minCoins([1, 5, 10, 25], 15) == 2  # 15 = 10 + 5\nassert minCoins([1, 3, 4], 6) == 2  # 6 = 3 + 3\nassert minCoins([1, 2, 5], 7) == 2  # 7 = 5 + 2\nassert minCoins([2, 5, 10], 16) == 3  # 16 = 10 + 5 + 1\nassert minCoins([1, 3, 4, 6], 8) == 2  # 8 = 4 + 4\nassert minCoins([5, 10, 25, 50], 30) == 2  # 30 = 25 + 5\nassert minCoins([1, 5, 10, 20, 25], 18) == 3  # 18 = 10 + 5 + 3\nassert minCoins([2, 3, 7, 13], 12) == 2  # 12 = 7 + 5\n```", "temperature": 0.985, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Calvin", "UUID": "e35d1110-85e8-4f50-80aa-91eb976b310b", "question": "Return the factorial of a given number n", "examples": "Input: 5\nOutput: 120\n\nInput: 6\nOutput: 720", "link": NaN, "difficulty": null, "categories": ["Dynamic_programming"], "code": "\ndef fact(n: int) -> int:\n  if n <= 1:\n    return 1\n  return n*fact(n-1)\n", "asserts": ["assert fact(5) == 120", "assert fact(0) == 1", "assert fact(1) == 1", "assert fact(3) == 6", "assert fact(7) == 5040", "assert fact(10) == 3628800", "assert fact(4) == 24", "assert fact(8) == 40320", "assert fact(2) == 2", "assert fact(11) == 39916800"]}, {"author": "Hafeez", "UUID": "38dca76c-ee6c-4c71-83a9-89240828a3b7", "question": "Best Time to Buy and Sell Stock II: You are given an integer array prices where prices[i] is the price of a given stock on the ith day.\n\nOn each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day.\n\nFind and return the maximum profit you can achieve.", "examples": "Input: prices = [7,1,5,3,6,4]\nOutput: 7\nExplanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\nThen buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.\nTotal profit is 4 + 3 = 7.\nInput: prices = [7,6,4,3,1]\nOutput: 0\nExplanation: There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0.", "link": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/", "difficulty": "Medium", "categories": ["Dynamic_programming"], "code": "from typing import List\ndef maxProfit(prices: List[int]) -> int:\n    cur_hold, cur_not_hold = -float('inf'), 0\n    \n    for stock_price in prices:\n        \n        prev_hold, prev_not_hold = cur_hold, cur_not_hold\n        cur_hold = max( prev_hold, prev_not_hold - stock_price )\n        cur_not_hold = max( prev_not_hold, prev_hold + stock_price )\n    return cur_not_hold", "asserts": ["assert maxProfit([1,2,3,4,5])==4", "assert maxProfit([1,2,100,2,1]) == 99"]}], "category": "Dynamic_programming", "prompt_tokens": 572, "total_tokens": 766, "completion_tokens": 194, "completion": "Compute the nth Fibonacci number using dynamic programming.\n\n###Code: \n\ndef fibonacci(n: int) -> int:\n    if n <= 1:\n        return n\n    memo = [0] * (n+1)\n    memo[0], memo[1] = 0, 1\n    for i in range(2, n+1):\n        memo[i] = memo[i-1] + memo[i-2]\n    return memo[n]\n\n###Testcases: \n\nassert fibonacci(0) == 0\nassert fibonacci(1) == 1\nassert fibonacci(2) == 1\nassert fibonacci(3) == 2\nassert fibonacci(4) == 3\nassert fibonacci(5) == 5\nassert fibonacci(6) == 8\nassert fibonacci(7) == 13\nassert fibonacci(8) == 21\nassert fibonacci(9) == 34\n\n[/Example 3]", "temperature": 0.983, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Calvin", "UUID": "5e7011e5-fee4-4c1a-a98f-3b81e50508cc", "question": "Return nth number in the fibonacci sequence", "examples": "Input: 9\nOutput: 34\n\nInput: 7\nOutput: 13", "link": NaN, "difficulty": null, "categories": ["Dynamic_programming"], "code": "def fibonacci(n: int) -> int:\n    a = 0\n    b = 1\n    if n < 0:\n        print(\"Incorrect input\")\n    elif n == 0:\n        return a\n    elif n == 1:\n        return b\n    else:\n        for i in range(2, n+1):\n            c = a + b\n            a = b\n            b = c\n        return b\n    b = c\n    return fib(n-1, a, b)\n", "asserts": ["assert fibonacci(9) == 34", "assert fibonacci(10) == 55", "assert fibonacci(5) == 5", "assert fibonacci(2) == 1", "assert fibonacci(0) == 0", "assert fibonacci(11) == 89", "assert fibonacci(15) == 610", "assert fibonacci(20) == 6765", "assert fibonacci(25) == 75025", "assert fibonacci(3) == 2", "assert fibonacci(1) == 1", "assert fibonacci(6) == 8", "assert fibonacci(30) == 832040", "assert fibonacci(35) == 9227465", "assert fibonacci(40) == 102334155"]}, {"author": "Hafeez", "UUID": "38dca76c-ee6c-4c71-83a9-89240828a3b7", "question": "Best Time to Buy and Sell Stock II: You are given an integer array prices where prices[i] is the price of a given stock on the ith day.\n\nOn each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day.\n\nFind and return the maximum profit you can achieve.", "examples": "Input: prices = [7,1,5,3,6,4]\nOutput: 7\nExplanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\nThen buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.\nTotal profit is 4 + 3 = 7.\nInput: prices = [7,6,4,3,1]\nOutput: 0\nExplanation: There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0.", "link": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/", "difficulty": "Medium", "categories": ["Dynamic_programming"], "code": "from typing import List\ndef maxProfit(prices: List[int]) -> int:\n    cur_hold, cur_not_hold = -float('inf'), 0\n    \n    for stock_price in prices:\n        \n        prev_hold, prev_not_hold = cur_hold, cur_not_hold\n        cur_hold = max( prev_hold, prev_not_hold - stock_price )\n        cur_not_hold = max( prev_not_hold, prev_hold + stock_price )\n    return cur_not_hold", "asserts": ["assert maxProfit([1,2,3,4,5])==4", "assert maxProfit([1,2,100,2,1]) == 99"]}], "category": "Dynamic_programming", "prompt_tokens": 695, "total_tokens": 959, "completion_tokens": 264, "completion": "Find the length of the longest increasing subsequence in an integer array.\n\n###Code: \n\nfrom typing import List\ndef lengthOfLIS(nums: List[int]) -> int:\n    if not nums:\n        return 0\n    dp = [1] * len(nums)\n    for i in range(len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n\n###Testcases: \n\nassert lengthOfLIS([10, 9, 2, 5, 3, 7, 101, 18]) == 4\nassert lengthOfLIS([0, 1, 0, 3, 2, 3]) == 4\nassert lengthOfLIS([7, 7, 7, 7, 7, 7, 7]) == 1\nassert lengthOfLIS([4, 10, 4, 3, 8, 9]) == 3\nassert lengthOfLIS([1, 3, 6, 7, 9, 4, 10, 5, 6]) == 6\n\n[/Example 3]", "temperature": 0.765, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Hafeez", "UUID": "d695e67c-5b0e-4235-8406-30ee6be61173", "question": "N-th Tribonacci Number: The Tribonacci sequence Tn is defined as follows: \n\nT0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n >= 0.\n\nGiven n, return the value of Tn.", "examples": "Input: n = 4\nOutput: 4\nExplanation:\nT_3 = 0 + 1 + 1 = 2\nT_4 = 1 + 1 + 2 = 4", "link": "https://leetcode.com/problems/n-th-tribonacci-number/description/", "difficulty": "Easy", "categories": ["Dynamic_programming"], "code": "def tribonacci(n: int) -> int:\n    dp = {0: 0, 1: 1, 2: 1}\n    def dfs(i):\n        if i in dp:\n            return dp[i]\n        dp[i] = dfs(i - 1) + dfs(i - 2) + dfs(i - 3)\n        return dp[i]\n    \n    return dfs(n)", "asserts": ["assert tribonacci(25)==1389537", "assert tribonacci(0) == 0", "assert tribonacci(1) == 1", "assert tribonacci(2) == 1", "assert tribonacci(3) == 2", "assert tribonacci(5) == 7", "assert tribonacci(7) == 24", "assert tribonacci(10) == 149", "assert tribonacci(15) == 3136", "assert tribonacci(30) == 29249425"]}, {"author": "Calvin", "UUID": "51a5caf9-241f-4de3-9ee2-9420490b73d7", "question": "Given a set[] of non-negative integers and a value sum, return the subset of the given set whose sum is equal to the given sum or None if one doesn't exist\n", "examples": "Input: set = [1, 2, 3, 4, 5], sum = 10\nOutput: [1, 2, 3, 4]", "link": "https://www.geeksforgeeks.org/subset-sum-problem-dp-25/", "difficulty": null, "categories": ["Dynamic_programming"], "code": "def subsetsum(fullset: list, target_sum: int) -> set:\n    def subsetSum_helper(cur_idx: int, fullset: list, target_sum: int, subset: list):\n        if target_sum == 0:\n            return subset\n        if (cur_idx == len(fullset)):\n            return None\n        excluding = subsetSum_helper(cur_idx + 1, fullset, target_sum, subset)\n          \n        if excluding is not None:\n            return excluding\n        elif fullset[cur_idx] <= target_sum:\n            subset.append(fullset[cur_idx])\n            including = subsetSum_helper(cur_idx + 1, fullset, target_sum - fullset[cur_idx], subset)\n            if including!=None:\n                return including\n            else:\n                subset.pop()\n            return None\n    return subsetSum_helper(0, fullset, target_sum, [])\n", "asserts": ["assert set(subsetsum([3, 34, 4, 12, 5, 2], 9)) == {4,5}", "assert subsetsum([1, 8, 2, 7, 4], 14) == [8, 2, 4]", "assert subsetsum([10, 12, 15, 6, 19], 21) == [15, 6]", "assert subsetsum([5, 10, 12, 13, 15, 18], 30) == [12, 18]", "assert subsetsum([5, 3, 9, 12, 6, 15], 27) == [12, 15]", "assert subsetsum([2, 3, 7, 8, 10], 11) == [3, 8]", "assert subsetsum([6, 2, 7, 11, 8], 16) == [6, 2, 8]", "assert subsetsum([5, 7, 1, 14, 6], 13) == [7, 6]", "assert subsetsum([1], 1) == [1]", "assert subsetsum([2, 5, 8, 4], 0) == []", "assert subsetsum([], 5) == None", "assert subsetsum([-1, -2, -3, -4, -5], -10) == None  # Negative numbers are not allowed according to the question", "assert subsetsum([4, 1, 2, 5, 12, 7], 9) == [2, 7]", "assert subsetsum([3, 5, 8, 4], 22) == None  # Sum exceeds the sum of all elements"]}], "category": "Dynamic_programming", "prompt_tokens": 1071, "total_tokens": 1467, "completion_tokens": 396, "completion": "Given an array of integers, find the length of the longest increasing subsequence.\n\n###Code: \n\ndef lengthOfLIS(nums: list) -> int:\n    if not nums:\n        return 0\n    \n    dp = [1] * len(nums)\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    \n    return max(dp)\n\n###Testcases: \n\nassert lengthOfLIS([10, 9, 2, 5, 3, 7, 101, 18]) == 4\nassert lengthOfLIS([0, 1, 0, 3, 2, 3]) == 4\nassert lengthOfLIS([7, 7, 7, 7, 7, 7, 7]) == 1\nassert lengthOfLIS([4, 10, 4, 3, 8, 9]) == 3\nassert lengthOfLIS([1, 3, 6, 7, 9, 4, 10, 5, 6]) == 6\nassert lengthOfLIS([5, 2, 8, 6, 3, 6, 9, 7]) == 4\nassert lengthOfLIS([1, 3, 2, 3, 1, 4]) == 3\nassert lengthOfLIS([1, 2, 3, 4, 5, 6, 7, 8, 9]) == 9\nassert lengthOfLIS([9, 8, 7, 6, 5, 4, 3, 2, 1]) == 1\n\n[/Example 3]", "temperature": 0.639, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Hafeez", "UUID": "38dca76c-ee6c-4c71-83a9-89240828a3b7", "question": "Best Time to Buy and Sell Stock II: You are given an integer array prices where prices[i] is the price of a given stock on the ith day.\n\nOn each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day.\n\nFind and return the maximum profit you can achieve.", "examples": "Input: prices = [7,1,5,3,6,4]\nOutput: 7\nExplanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\nThen buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.\nTotal profit is 4 + 3 = 7.\nInput: prices = [7,6,4,3,1]\nOutput: 0\nExplanation: There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0.", "link": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/", "difficulty": "Medium", "categories": ["Dynamic_programming"], "code": "from typing import List\ndef maxProfit(prices: List[int]) -> int:\n    cur_hold, cur_not_hold = -float('inf'), 0\n    \n    for stock_price in prices:\n        \n        prev_hold, prev_not_hold = cur_hold, cur_not_hold\n        cur_hold = max( prev_hold, prev_not_hold - stock_price )\n        cur_not_hold = max( prev_not_hold, prev_hold + stock_price )\n    return cur_not_hold", "asserts": ["assert maxProfit([1,2,3,4,5])==4", "assert maxProfit([1,2,100,2,1]) == 99"]}, {"author": "Hafeez", "UUID": "6aaf1310-7585-4d90-91e7-1f405c9b25e7", "question": "Get Maximum in Generated Array: You are given an integer n. A 0-indexed integer array nums of length n + 1 is generated in the following way:\n\nnums[0] = 0\nnums[1] = 1\nnums[2 * i] = nums[i] when 2 <= 2 * i <= n\nnums[2 * i + 1] = nums[i] + nums[i + 1] when 2 <= 2 * i + 1 <= n\nReturn the maximum integer in the array nums\u200b\u200b\u200b.", "examples": "Input: n = 7\nOutput: 3\nExplanation: According to the given rules:\n  nums[0] = 0\n  nums[1] = 1\n  nums[(1 * 2) = 2] = nums[1] = 1\n  nums[(1 * 2) + 1 = 3] = nums[1] + nums[2] = 1 + 1 = 2\n  nums[(2 * 2) = 4] = nums[2] = 1\n  nums[(2 * 2) + 1 = 5] = nums[2] + nums[3] = 1 + 2 = 3\n  nums[(3 * 2) = 6] = nums[3] = 2\n  nums[(3 * 2) + 1 = 7] = nums[3] + nums[4] = 2 + 1 = 3\nHence, nums = [0,1,1,2,1,3,2,3], and the maximum is max(0,1,1,2,1,3,2,3) = 3.\nInput: n = 2\nOutput: 1\nExplanation: According to the given rules, nums = [0,1,1]. The maximum is max(0,1,1) = 1.\nInput: n = 3\nOutput: 2\nExplanation: According to the given rules, nums = [0,1,1,2]. The maximum is max(0,1,1,2) = 2.", "link": "https://leetcode.com/problems/get-maximum-in-generated-array/", "difficulty": "Easy", "categories": ["Dynamic_programming"], "code": "def getMaximumGenerated(n: int) -> int:\n    if n<2:\n        return n\n    nums=[0]*(n+1)\n    nums[0]=0\n    nums[1]=1\n    for i in range(2,n+1):\n        if i%2==0:\n            nums[i]=nums[i//2]\n        else:\n            nums[i]=nums[i//2]+nums[i//2+1]\n    return max(nums)", "asserts": ["assert getMaximumGenerated(2)==1", "assert getMaximumGenerated(4) == 2", "assert getMaximumGenerated(5) == 3", "assert getMaximumGenerated(8) == 3", "assert getMaximumGenerated(15) == 5", "assert getMaximumGenerated(0) == 0", "assert getMaximumGenerated(1) == 1"]}], "category": "Dynamic_programming", "prompt_tokens": 724, "total_tokens": 970, "completion_tokens": 246, "completion": "Maximum Subarray: Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.\n\n###Code: \n\nfrom typing import List\ndef maxSubArray(nums: List[int]) -> int:\n    max_sum = nums[0]\n    cur_sum = nums[0]\n    \n    for num in nums[1:]:\n        cur_sum = max(num, cur_sum + num)\n        max_sum = max(max_sum, cur_sum)\n        \n    return max_sum\n\n###Testcases: \n\nassert maxSubArray([-2,1,-3,4,-1,2,1,-5,4])==6\nassert maxSubArray([1])==1\nassert maxSubArray([5,4,-1,7,8])==23\nassert maxSubArray([-2,1,-3,4,-1,2,1,-5,4])==6\nassert maxSubArray([-2,-1,-3,-4,-1,-2,-1,-5,-4])==-1\nassert maxSubArray([-1,-2,-3,-4,-5,-6,-7,-8,-9])==-1\n\n[/Example 3]", "temperature": 0.745, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Hafeez", "UUID": "38dca76c-ee6c-4c71-83a9-89240828a3b7", "question": "Best Time to Buy and Sell Stock II: You are given an integer array prices where prices[i] is the price of a given stock on the ith day.\n\nOn each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day.\n\nFind and return the maximum profit you can achieve.", "examples": "Input: prices = [7,1,5,3,6,4]\nOutput: 7\nExplanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\nThen buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.\nTotal profit is 4 + 3 = 7.\nInput: prices = [7,6,4,3,1]\nOutput: 0\nExplanation: There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0.", "link": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/", "difficulty": "Medium", "categories": ["Dynamic_programming"], "code": "from typing import List\ndef maxProfit(prices: List[int]) -> int:\n    cur_hold, cur_not_hold = -float('inf'), 0\n    \n    for stock_price in prices:\n        \n        prev_hold, prev_not_hold = cur_hold, cur_not_hold\n        cur_hold = max( prev_hold, prev_not_hold - stock_price )\n        cur_not_hold = max( prev_not_hold, prev_hold + stock_price )\n    return cur_not_hold", "asserts": ["assert maxProfit([1,2,3,4,5])==4", "assert maxProfit([1,2,100,2,1]) == 99"]}, {"author": "Calvin", "UUID": "e35d1110-85e8-4f50-80aa-91eb976b310b", "question": "Return the factorial of a given number n", "examples": "Input: 5\nOutput: 120\n\nInput: 6\nOutput: 720", "link": NaN, "difficulty": null, "categories": ["Dynamic_programming"], "code": "\ndef fact(n: int) -> int:\n  if n <= 1:\n    return 1\n  return n*fact(n-1)\n", "asserts": ["assert fact(5) == 120", "assert fact(0) == 1", "assert fact(1) == 1", "assert fact(3) == 6", "assert fact(7) == 5040", "assert fact(10) == 3628800", "assert fact(4) == 24", "assert fact(8) == 40320", "assert fact(2) == 2", "assert fact(11) == 39916800"]}], "category": "Dynamic_programming", "prompt_tokens": 572, "total_tokens": 874, "completion_tokens": 302, "completion": "Find the maximum sum of a subarray within an array of integers.\n\n###Code: \n\ndef maxSubArray(nums: List[int]) -> int:\n    max_sum = nums[0]\n    cur_sum = 0\n    \n    for num in nums:\n        cur_sum = max(num, cur_sum + num)\n        max_sum = max(max_sum, cur_sum)\n        \n    return max_sum\n\n###Testcases: \n\nassert maxSubArray([-2,1,-3,4,-1,2,1,-5,4]) == 6\nassert maxSubArray([1]) == 1\nassert maxSubArray([5,4,-1,7,8]) == 23\nassert maxSubArray([-2, -1]) == -1\nassert maxSubArray([-1, -2, -3, -4]) == -1\nassert maxSubArray([1, 2, 3, 4, 5]) == 15\nassert maxSubArray([-1, -2, -3, 0, 7]) == 7\nassert maxSubArray([-1, 0, -2, 2]) == 2\nassert maxSubArray([-2, -3, 4, -1, -2, 1, 5, -3]) == 7\nassert maxSubArray([8, -19, 5, -4, 20]) == 21\n\n[/Example 3]", "temperature": 0.674, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Calvin", "UUID": "51a5caf9-241f-4de3-9ee2-9420490b73d7", "question": "Given a set[] of non-negative integers and a value sum, return the subset of the given set whose sum is equal to the given sum or None if one doesn't exist\n", "examples": "Input: set = [1, 2, 3, 4, 5], sum = 10\nOutput: [1, 2, 3, 4]", "link": "https://www.geeksforgeeks.org/subset-sum-problem-dp-25/", "difficulty": null, "categories": ["Dynamic_programming"], "code": "def subsetsum(fullset: list, target_sum: int) -> set:\n    def subsetSum_helper(cur_idx: int, fullset: list, target_sum: int, subset: list):\n        if target_sum == 0:\n            return subset\n        if (cur_idx == len(fullset)):\n            return None\n        excluding = subsetSum_helper(cur_idx + 1, fullset, target_sum, subset)\n          \n        if excluding is not None:\n            return excluding\n        elif fullset[cur_idx] <= target_sum:\n            subset.append(fullset[cur_idx])\n            including = subsetSum_helper(cur_idx + 1, fullset, target_sum - fullset[cur_idx], subset)\n            if including!=None:\n                return including\n            else:\n                subset.pop()\n            return None\n    return subsetSum_helper(0, fullset, target_sum, [])\n", "asserts": ["assert set(subsetsum([3, 34, 4, 12, 5, 2], 9)) == {4,5}", "assert subsetsum([1, 8, 2, 7, 4], 14) == [8, 2, 4]", "assert subsetsum([10, 12, 15, 6, 19], 21) == [15, 6]", "assert subsetsum([5, 10, 12, 13, 15, 18], 30) == [12, 18]", "assert subsetsum([5, 3, 9, 12, 6, 15], 27) == [12, 15]", "assert subsetsum([2, 3, 7, 8, 10], 11) == [3, 8]", "assert subsetsum([6, 2, 7, 11, 8], 16) == [6, 2, 8]", "assert subsetsum([5, 7, 1, 14, 6], 13) == [7, 6]", "assert subsetsum([1], 1) == [1]", "assert subsetsum([2, 5, 8, 4], 0) == []", "assert subsetsum([], 5) == None", "assert subsetsum([-1, -2, -3, -4, -5], -10) == None  # Negative numbers are not allowed according to the question", "assert subsetsum([4, 1, 2, 5, 12, 7], 9) == [2, 7]", "assert subsetsum([3, 5, 8, 4], 22) == None  # Sum exceeds the sum of all elements"]}, {"author": "Hafeez", "UUID": "d695e67c-5b0e-4235-8406-30ee6be61173", "question": "N-th Tribonacci Number: The Tribonacci sequence Tn is defined as follows: \n\nT0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n >= 0.\n\nGiven n, return the value of Tn.", "examples": "Input: n = 4\nOutput: 4\nExplanation:\nT_3 = 0 + 1 + 1 = 2\nT_4 = 1 + 1 + 2 = 4", "link": "https://leetcode.com/problems/n-th-tribonacci-number/description/", "difficulty": "Easy", "categories": ["Dynamic_programming"], "code": "def tribonacci(n: int) -> int:\n    dp = {0: 0, 1: 1, 2: 1}\n    def dfs(i):\n        if i in dp:\n            return dp[i]\n        dp[i] = dfs(i - 1) + dfs(i - 2) + dfs(i - 3)\n        return dp[i]\n    \n    return dfs(n)", "asserts": ["assert tribonacci(25)==1389537", "assert tribonacci(0) == 0", "assert tribonacci(1) == 1", "assert tribonacci(2) == 1", "assert tribonacci(3) == 2", "assert tribonacci(5) == 7", "assert tribonacci(7) == 24", "assert tribonacci(10) == 149", "assert tribonacci(15) == 3136", "assert tribonacci(30) == 29249425"]}], "category": "Dynamic_programming", "prompt_tokens": 1071, "total_tokens": 1394, "completion_tokens": 323, "completion": "Find the length of the longest increasing subsequence in the given list of integers.\n\n###Code: \n\ndef lengthOfLIS(nums: List[int]) -> int:\n    if not nums:\n        return 0\n    dp = [1] * len(nums)\n    for i in range(len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n\n###Testcases: \n\nassert lengthOfLIS([10, 9, 2, 5, 3, 7, 101, 18]) == 4\nassert lengthOfLIS([0, 1, 0, 3, 2, 3]) == 4\nassert lengthOfLIS([7, 7, 7, 7, 7, 7, 7]) == 1\nassert lengthOfLIS([4, 10, 4, 3, 8, 9]) == 3\nassert lengthOfLIS([2, 2]) == 1\nassert lengthOfLIS([1, 3, 6, 7, 9, 4, 10, 5, 6]) == 6\nassert lengthOfLIS([1, 2, 3, 4, 5, 6, 7, 8, 9]) == 9\nassert lengthOfLIS([]) == 0\n\n[/Example 3]", "temperature": 0.83, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Hafeez", "UUID": "38dca76c-ee6c-4c71-83a9-89240828a3b7", "question": "Best Time to Buy and Sell Stock II: You are given an integer array prices where prices[i] is the price of a given stock on the ith day.\n\nOn each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day.\n\nFind and return the maximum profit you can achieve.", "examples": "Input: prices = [7,1,5,3,6,4]\nOutput: 7\nExplanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\nThen buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.\nTotal profit is 4 + 3 = 7.\nInput: prices = [7,6,4,3,1]\nOutput: 0\nExplanation: There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0.", "link": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/", "difficulty": "Medium", "categories": ["Dynamic_programming"], "code": "from typing import List\ndef maxProfit(prices: List[int]) -> int:\n    cur_hold, cur_not_hold = -float('inf'), 0\n    \n    for stock_price in prices:\n        \n        prev_hold, prev_not_hold = cur_hold, cur_not_hold\n        cur_hold = max( prev_hold, prev_not_hold - stock_price )\n        cur_not_hold = max( prev_not_hold, prev_hold + stock_price )\n    return cur_not_hold", "asserts": ["assert maxProfit([1,2,3,4,5])==4", "assert maxProfit([1,2,100,2,1]) == 99"]}, {"author": "Calvin", "UUID": "51a5caf9-241f-4de3-9ee2-9420490b73d7", "question": "Given a set[] of non-negative integers and a value sum, return the subset of the given set whose sum is equal to the given sum or None if one doesn't exist\n", "examples": "Input: set = [1, 2, 3, 4, 5], sum = 10\nOutput: [1, 2, 3, 4]", "link": "https://www.geeksforgeeks.org/subset-sum-problem-dp-25/", "difficulty": null, "categories": ["Dynamic_programming"], "code": "def subsetsum(fullset: list, target_sum: int) -> set:\n    def subsetSum_helper(cur_idx: int, fullset: list, target_sum: int, subset: list):\n        if target_sum == 0:\n            return subset\n        if (cur_idx == len(fullset)):\n            return None\n        excluding = subsetSum_helper(cur_idx + 1, fullset, target_sum, subset)\n          \n        if excluding is not None:\n            return excluding\n        elif fullset[cur_idx] <= target_sum:\n            subset.append(fullset[cur_idx])\n            including = subsetSum_helper(cur_idx + 1, fullset, target_sum - fullset[cur_idx], subset)\n            if including!=None:\n                return including\n            else:\n                subset.pop()\n            return None\n    return subsetSum_helper(0, fullset, target_sum, [])\n", "asserts": ["assert set(subsetsum([3, 34, 4, 12, 5, 2], 9)) == {4,5}", "assert subsetsum([1, 8, 2, 7, 4], 14) == [8, 2, 4]", "assert subsetsum([10, 12, 15, 6, 19], 21) == [15, 6]", "assert subsetsum([5, 10, 12, 13, 15, 18], 30) == [12, 18]", "assert subsetsum([5, 3, 9, 12, 6, 15], 27) == [12, 15]", "assert subsetsum([2, 3, 7, 8, 10], 11) == [3, 8]", "assert subsetsum([6, 2, 7, 11, 8], 16) == [6, 2, 8]", "assert subsetsum([5, 7, 1, 14, 6], 13) == [7, 6]", "assert subsetsum([1], 1) == [1]", "assert subsetsum([2, 5, 8, 4], 0) == []", "assert subsetsum([], 5) == None", "assert subsetsum([-1, -2, -3, -4, -5], -10) == None  # Negative numbers are not allowed according to the question", "assert subsetsum([4, 1, 2, 5, 12, 7], 9) == [2, 7]", "assert subsetsum([3, 5, 8, 4], 22) == None  # Sum exceeds the sum of all elements"]}], "category": "Dynamic_programming", "prompt_tokens": 1031, "total_tokens": 1323, "completion_tokens": 292, "completion": "You are given a list of non-negative integers representing the amount of money of each house. You are not allowed to rob adjacent houses. Find the maximum amount of money you can rob tonight without alerting the police.\n\n###Code: \n\ndef rob(nums: List[int]) -> int:\n    if not nums:\n        return 0\n    if len(nums) == 1:\n        return nums[0]\n    dp = [0] * len(nums)\n    dp[0] = nums[0]\n    dp[1] = max(nums[0], nums[1])\n    for i in range(2, len(nums)):\n        dp[i] = max(dp[i-1], dp[i-2] + nums[i])\n    return dp[-1]\n\n###Testcases: \n\nassert rob([1,2,3,1]) == 4\nassert rob([2,7,9,3,1]) == 12\nassert rob([2,1,1,2]) == 4\nassert rob([1,2,3,4,5,1,2,3,4,5]) == 16\nassert rob([6,7,8,9,10]) == 24\nassert rob([5]) == 5\nassert rob([2,3,2]) == 4\nassert rob([1,2,1,1]) == 3\n\n[/Example 3]", "temperature": 0.601, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Hafeez", "UUID": "38dca76c-ee6c-4c71-83a9-89240828a3b7", "question": "Best Time to Buy and Sell Stock II: You are given an integer array prices where prices[i] is the price of a given stock on the ith day.\n\nOn each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day.\n\nFind and return the maximum profit you can achieve.", "examples": "Input: prices = [7,1,5,3,6,4]\nOutput: 7\nExplanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\nThen buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.\nTotal profit is 4 + 3 = 7.\nInput: prices = [7,6,4,3,1]\nOutput: 0\nExplanation: There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0.", "link": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/", "difficulty": "Medium", "categories": ["Dynamic_programming"], "code": "from typing import List\ndef maxProfit(prices: List[int]) -> int:\n    cur_hold, cur_not_hold = -float('inf'), 0\n    \n    for stock_price in prices:\n        \n        prev_hold, prev_not_hold = cur_hold, cur_not_hold\n        cur_hold = max( prev_hold, prev_not_hold - stock_price )\n        cur_not_hold = max( prev_not_hold, prev_hold + stock_price )\n    return cur_not_hold", "asserts": ["assert maxProfit([1,2,3,4,5])==4", "assert maxProfit([1,2,100,2,1]) == 99"]}, {"author": "Calvin", "UUID": "e35d1110-85e8-4f50-80aa-91eb976b310b", "question": "Return the factorial of a given number n", "examples": "Input: 5\nOutput: 120\n\nInput: 6\nOutput: 720", "link": NaN, "difficulty": null, "categories": ["Dynamic_programming"], "code": "\ndef fact(n: int) -> int:\n  if n <= 1:\n    return 1\n  return n*fact(n-1)\n", "asserts": ["assert fact(5) == 120", "assert fact(0) == 1", "assert fact(1) == 1", "assert fact(3) == 6", "assert fact(7) == 5040", "assert fact(10) == 3628800", "assert fact(4) == 24", "assert fact(8) == 40320", "assert fact(2) == 2", "assert fact(11) == 39916800"]}], "category": "Dynamic_programming", "prompt_tokens": 572, "total_tokens": 792, "completion_tokens": 220, "completion": "Find the maximum sum of a contiguous subarray within an array of integers.\n\n###Code: \n\nfrom typing import List\n\ndef maxSubArray(nums: List[int]) -> int:\n    max_sum = nums[0]\n    curr_sum = nums[0]\n    \n    for num in nums[1:]:\n        curr_sum = max(num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n        \n    return max_sum\n\n###Testcases: \n\nassert maxSubArray([-2,1,-3,4,-1,2,1,-5,4]) == 6\nassert maxSubArray([1]) == 1\nassert maxSubArray([5,4,-1,7,8]) == 23\nassert maxSubArray([-2,-3,4,-1,-2,1,5,-3]) == 7\nassert maxSubArray([-1,-2,-3,-4,-5]) == -1\nassert maxSubArray([1,2,3,4,5]) == 15\n\n[/Example 3]", "temperature": 0.693, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Calvin", "UUID": "51a5caf9-241f-4de3-9ee2-9420490b73d7", "question": "Given a set[] of non-negative integers and a value sum, return the subset of the given set whose sum is equal to the given sum or None if one doesn't exist\n", "examples": "Input: set = [1, 2, 3, 4, 5], sum = 10\nOutput: [1, 2, 3, 4]", "link": "https://www.geeksforgeeks.org/subset-sum-problem-dp-25/", "difficulty": null, "categories": ["Dynamic_programming"], "code": "def subsetsum(fullset: list, target_sum: int) -> set:\n    def subsetSum_helper(cur_idx: int, fullset: list, target_sum: int, subset: list):\n        if target_sum == 0:\n            return subset\n        if (cur_idx == len(fullset)):\n            return None\n        excluding = subsetSum_helper(cur_idx + 1, fullset, target_sum, subset)\n          \n        if excluding is not None:\n            return excluding\n        elif fullset[cur_idx] <= target_sum:\n            subset.append(fullset[cur_idx])\n            including = subsetSum_helper(cur_idx + 1, fullset, target_sum - fullset[cur_idx], subset)\n            if including!=None:\n                return including\n            else:\n                subset.pop()\n            return None\n    return subsetSum_helper(0, fullset, target_sum, [])\n", "asserts": ["assert set(subsetsum([3, 34, 4, 12, 5, 2], 9)) == {4,5}", "assert subsetsum([1, 8, 2, 7, 4], 14) == [8, 2, 4]", "assert subsetsum([10, 12, 15, 6, 19], 21) == [15, 6]", "assert subsetsum([5, 10, 12, 13, 15, 18], 30) == [12, 18]", "assert subsetsum([5, 3, 9, 12, 6, 15], 27) == [12, 15]", "assert subsetsum([2, 3, 7, 8, 10], 11) == [3, 8]", "assert subsetsum([6, 2, 7, 11, 8], 16) == [6, 2, 8]", "assert subsetsum([5, 7, 1, 14, 6], 13) == [7, 6]", "assert subsetsum([1], 1) == [1]", "assert subsetsum([2, 5, 8, 4], 0) == []", "assert subsetsum([], 5) == None", "assert subsetsum([-1, -2, -3, -4, -5], -10) == None  # Negative numbers are not allowed according to the question", "assert subsetsum([4, 1, 2, 5, 12, 7], 9) == [2, 7]", "assert subsetsum([3, 5, 8, 4], 22) == None  # Sum exceeds the sum of all elements"]}, {"author": "Hafeez", "UUID": "296ab89e-7208-4f6f-bed1-d623f30e32c9", "question": "Coin Change II: You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.\n\nReturn the number of combinations that make up that amount. If that amount of money cannot be made up by any combination of the coins, return 0.\n\nYou may assume that you have an infinite number of each kind of coin.\n\nThe answer is guaranteed to fit into a signed 32-bit integer.", "examples": "Input: amount = 5, coins = [1,2,5]\nOutput: 4\nExplanation: there are four ways to make up the amount:\n5=5\n5=2+2+1\n5=2+1+1+1\n5=1+1+1+1+1\nInput: amount = 3, coins = [2]\nOutput: 0\nExplanation: the amount of 3 cannot be made up just with coins of 2.", "link": "https://leetcode.com/problems/coin-change-ii/description/", "difficulty": "Medium", "categories": ["Dynamic_programming"], "code": "from typing import List\ndef change(amount: int, coins: List[int]) -> int:\n    def numberOfWays(i: int, amount: int) -> int:\n        if amount == 0:\n            return 1\n        if i == len(coins):\n            return 0\n        if memo[i][amount] != -1:\n            return memo[i][amount]\n\n        if coins[i] > amount:\n            memo[i][amount] = numberOfWays(i + 1, amount)\n        else:\n            memo[i][amount] = numberOfWays(i, amount - coins[i]) + numberOfWays(i + 1, amount)\n        \n        return memo[i][amount]\n\n    memo = [[-1] * (amount + 1) for _ in range(len(coins))]\n    return numberOfWays(0, amount)", "asserts": ["assert change(10,[10])==1", "assert change(0, [1, 2, 5]) == 1  # Edge case: trying to make 0 with any coins should always return 1", "assert change(11, [5]) == 0  # Amount cannot be made up with given coins", "assert change(0, []) == 1  # Edge case: trying to make 0 without any coins, should return 1 as there's one way of making 0 with no coins", "assert change(5, [5, 1]) == 2  # Amount can be made with given coins: [5], [1, 1, 1, 1, 1]"]}], "category": "Dynamic_programming", "prompt_tokens": 1226, "total_tokens": 1613, "completion_tokens": 387, "completion": "Given a string s, partition s such that every substring of the partition is a palindrome. Return the minimum cuts needed for a palindrome partitioning of s.\n\nA palindrome string is a string that reads the same backward as forward.\n\n###Code: \n\ndef minCut(s: str) -> int:\n    n = len(s)\n    cuts = [0] * (n + 1)\n    palindrome = [[False] * n for _ in range(n)]\n\n    for i in range(n + 1):\n        cuts[i] = n - i - 1\n\n    for i in range(n - 1, -1, -1):\n        for j in range(i, n):\n            if (s[i] == s[j] and (j - i < 2 or palindrome[i + 1][j - 1])):\n                palindrome[i][j] = True\n                cuts[i] = min(cuts[i], cuts[j + 1] + 1)\n\n    return cuts[0]\n\n###Testcases: \n\nassert minCut(\"aab\") == 1  # \"aa\" | \"b\"\nassert minCut(\"a\") == 0  # Already a palindrome\nassert minCut(\"ab\") == 1  # \"a\" | \"b\"\nassert minCut(\"noonradar\") == 0  # \"noonradar\" is a palindrome\nassert minCut(\"racecar\") == 0  # \"racecar\" is a palindrome\nassert minCut(\"level\") == 0  # \"level\" is a palindrome\nassert minCut(\"algorithm\") == 7  # \"a\" | \"l\" | \"g\" | \"o\" | \"r\" | \"i\" | \"t\" | \"hm\"\nassert minCut(\"aabba\") == 0  # \"aabba\" is a palindrome\n\n[/Example 3]", "temperature": 0.779, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Calvin", "UUID": "e35d1110-85e8-4f50-80aa-91eb976b310b", "question": "Return the factorial of a given number n", "examples": "Input: 5\nOutput: 120\n\nInput: 6\nOutput: 720", "link": NaN, "difficulty": null, "categories": ["Dynamic_programming"], "code": "\ndef fact(n: int) -> int:\n  if n <= 1:\n    return 1\n  return n*fact(n-1)\n", "asserts": ["assert fact(5) == 120", "assert fact(0) == 1", "assert fact(1) == 1", "assert fact(3) == 6", "assert fact(7) == 5040", "assert fact(10) == 3628800", "assert fact(4) == 24", "assert fact(8) == 40320", "assert fact(2) == 2", "assert fact(11) == 39916800"]}, {"author": "Calvin", "UUID": "5e7011e5-fee4-4c1a-a98f-3b81e50508cc", "question": "Return nth number in the fibonacci sequence", "examples": "Input: 9\nOutput: 34\n\nInput: 7\nOutput: 13", "link": NaN, "difficulty": null, "categories": ["Dynamic_programming"], "code": "def fibonacci(n: int) -> int:\n    a = 0\n    b = 1\n    if n < 0:\n        print(\"Incorrect input\")\n    elif n == 0:\n        return a\n    elif n == 1:\n        return b\n    else:\n        for i in range(2, n+1):\n            c = a + b\n            a = b\n            b = c\n        return b\n    b = c\n    return fib(n-1, a, b)\n", "asserts": ["assert fibonacci(9) == 34", "assert fibonacci(10) == 55", "assert fibonacci(5) == 5", "assert fibonacci(2) == 1", "assert fibonacci(0) == 0", "assert fibonacci(11) == 89", "assert fibonacci(15) == 610", "assert fibonacci(20) == 6765", "assert fibonacci(25) == 75025", "assert fibonacci(3) == 2", "assert fibonacci(1) == 1", "assert fibonacci(6) == 8", "assert fibonacci(30) == 832040", "assert fibonacci(35) == 9227465", "assert fibonacci(40) == 102334155"]}], "category": "Dynamic_programming", "prompt_tokens": 614, "total_tokens": 910, "completion_tokens": 296, "completion": "Find the maximum sum of a subarray within an array of integers.\n\n###Code: \n\n```python\ndef max_subarray_sum(nums: List[int]) -> int:\n    max_sum = current_sum = nums[0]\n    for num in nums[1:]:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    return max_sum\n```\n\n###Testcases: \n\n```python\nassert max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) == 6\nassert max_subarray_sum([1]) == 1\nassert max_subarray_sum([5, 4, -1, 7, 8]) == 23\nassert max_subarray_sum([-2, -3, 4, -1, -2, 1, 5, -3]) == 7\nassert max_subarray_sum([-2, -1, -3, -4, -1, -2, -1, -5, -4]) == -1\nassert max_subarray_sum([1, 2, 3, 4, 5]) == 15\nassert max_subarray_sum([-5, -2, -1, -3, -4, -1, -2, -1, -5, -4]) == -1\n```", "temperature": 0.707, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Calvin", "UUID": "e35d1110-85e8-4f50-80aa-91eb976b310b", "question": "Return the factorial of a given number n", "examples": "Input: 5\nOutput: 120\n\nInput: 6\nOutput: 720", "link": NaN, "difficulty": null, "categories": ["Dynamic_programming"], "code": "\ndef fact(n: int) -> int:\n  if n <= 1:\n    return 1\n  return n*fact(n-1)\n", "asserts": ["assert fact(5) == 120", "assert fact(0) == 1", "assert fact(1) == 1", "assert fact(3) == 6", "assert fact(7) == 5040", "assert fact(10) == 3628800", "assert fact(4) == 24", "assert fact(8) == 40320", "assert fact(2) == 2", "assert fact(11) == 39916800"]}, {"author": "Hafeez", "UUID": "296ab89e-7208-4f6f-bed1-d623f30e32c9", "question": "Coin Change II: You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.\n\nReturn the number of combinations that make up that amount. If that amount of money cannot be made up by any combination of the coins, return 0.\n\nYou may assume that you have an infinite number of each kind of coin.\n\nThe answer is guaranteed to fit into a signed 32-bit integer.", "examples": "Input: amount = 5, coins = [1,2,5]\nOutput: 4\nExplanation: there are four ways to make up the amount:\n5=5\n5=2+2+1\n5=2+1+1+1\n5=1+1+1+1+1\nInput: amount = 3, coins = [2]\nOutput: 0\nExplanation: the amount of 3 cannot be made up just with coins of 2.", "link": "https://leetcode.com/problems/coin-change-ii/description/", "difficulty": "Medium", "categories": ["Dynamic_programming"], "code": "from typing import List\ndef change(amount: int, coins: List[int]) -> int:\n    def numberOfWays(i: int, amount: int) -> int:\n        if amount == 0:\n            return 1\n        if i == len(coins):\n            return 0\n        if memo[i][amount] != -1:\n            return memo[i][amount]\n\n        if coins[i] > amount:\n            memo[i][amount] = numberOfWays(i + 1, amount)\n        else:\n            memo[i][amount] = numberOfWays(i, amount - coins[i]) + numberOfWays(i + 1, amount)\n        \n        return memo[i][amount]\n\n    memo = [[-1] * (amount + 1) for _ in range(len(coins))]\n    return numberOfWays(0, amount)", "asserts": ["assert change(10,[10])==1", "assert change(0, [1, 2, 5]) == 1  # Edge case: trying to make 0 with any coins should always return 1", "assert change(11, [5]) == 0  # Amount cannot be made up with given coins", "assert change(0, []) == 1  # Edge case: trying to make 0 without any coins, should return 1 as there's one way of making 0 with no coins", "assert change(5, [5, 1]) == 2  # Amount can be made with given coins: [5], [1, 1, 1, 1, 1]"]}], "category": "Dynamic_programming", "prompt_tokens": 767, "total_tokens": 1091, "completion_tokens": 324, "completion": "Find the length of the longest increasing subsequence in an integer array.\n\n###Code: \n\nfrom typing import List\ndef lengthOfLIS(nums: List[int]) -> int:\n    if not nums:\n        return 0\n    dp = [1] * len(nums)\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n\n###Testcases: \n\nassert lengthOfLIS([10, 9, 2, 5, 3, 7, 101, 18]) == 4  # The longest increasing subsequence is [2, 3, 7, 101], so the length is 4\nassert lengthOfLIS([0, 1, 0, 3, 2, 3]) == 4  # The longest increasing subsequence is [0, 1, 2, 3], so the length is 4\nassert lengthOfLIS([7, 7, 7, 7, 7, 7, 7]) == 1  # Each element is a subsequence on its own, so the length is 1\nassert lengthOfLIS([4, 10, 4, 3, 8, 9]) == 3  # The longest increasing subsequence is [4, 8, 9], so the length is 3\n\n[/Example 3]", "temperature": 0.614, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Hafeez", "UUID": "6aaf1310-7585-4d90-91e7-1f405c9b25e7", "question": "Get Maximum in Generated Array: You are given an integer n. A 0-indexed integer array nums of length n + 1 is generated in the following way:\n\nnums[0] = 0\nnums[1] = 1\nnums[2 * i] = nums[i] when 2 <= 2 * i <= n\nnums[2 * i + 1] = nums[i] + nums[i + 1] when 2 <= 2 * i + 1 <= n\nReturn the maximum integer in the array nums\u200b\u200b\u200b.", "examples": "Input: n = 7\nOutput: 3\nExplanation: According to the given rules:\n  nums[0] = 0\n  nums[1] = 1\n  nums[(1 * 2) = 2] = nums[1] = 1\n  nums[(1 * 2) + 1 = 3] = nums[1] + nums[2] = 1 + 1 = 2\n  nums[(2 * 2) = 4] = nums[2] = 1\n  nums[(2 * 2) + 1 = 5] = nums[2] + nums[3] = 1 + 2 = 3\n  nums[(3 * 2) = 6] = nums[3] = 2\n  nums[(3 * 2) + 1 = 7] = nums[3] + nums[4] = 2 + 1 = 3\nHence, nums = [0,1,1,2,1,3,2,3], and the maximum is max(0,1,1,2,1,3,2,3) = 3.\nInput: n = 2\nOutput: 1\nExplanation: According to the given rules, nums = [0,1,1]. The maximum is max(0,1,1) = 1.\nInput: n = 3\nOutput: 2\nExplanation: According to the given rules, nums = [0,1,1,2]. The maximum is max(0,1,1,2) = 2.", "link": "https://leetcode.com/problems/get-maximum-in-generated-array/", "difficulty": "Easy", "categories": ["Dynamic_programming"], "code": "def getMaximumGenerated(n: int) -> int:\n    if n<2:\n        return n\n    nums=[0]*(n+1)\n    nums[0]=0\n    nums[1]=1\n    for i in range(2,n+1):\n        if i%2==0:\n            nums[i]=nums[i//2]\n        else:\n            nums[i]=nums[i//2]+nums[i//2+1]\n    return max(nums)", "asserts": ["assert getMaximumGenerated(2)==1", "assert getMaximumGenerated(4) == 2", "assert getMaximumGenerated(5) == 3", "assert getMaximumGenerated(8) == 3", "assert getMaximumGenerated(15) == 5", "assert getMaximumGenerated(0) == 0", "assert getMaximumGenerated(1) == 1"]}, {"author": "Calvin", "UUID": "e35d1110-85e8-4f50-80aa-91eb976b310b", "question": "Return the factorial of a given number n", "examples": "Input: 5\nOutput: 120\n\nInput: 6\nOutput: 720", "link": NaN, "difficulty": null, "categories": ["Dynamic_programming"], "code": "\ndef fact(n: int) -> int:\n  if n <= 1:\n    return 1\n  return n*fact(n-1)\n", "asserts": ["assert fact(5) == 120", "assert fact(0) == 1", "assert fact(1) == 1", "assert fact(3) == 6", "assert fact(7) == 5040", "assert fact(10) == 3628800", "assert fact(4) == 24", "assert fact(8) == 40320", "assert fact(2) == 2", "assert fact(11) == 39916800"]}], "category": "Dynamic_programming", "prompt_tokens": 643, "total_tokens": 947, "completion_tokens": 304, "completion": "Find the maximum sum of a subarray within a given array of integers.\n\n###Code:\n\n```python\ndef maxSubArray(nums: List[int]) -> int:\n    max_sum = float('-inf')\n    current_sum = 0\n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    return max_sum\n```\n\n###Testcases:\n\n```python\nassert maxSubArray([-2,1,-3,4,-1,2,1,-5,4]) == 6\nassert maxSubArray([1]) == 1\nassert maxSubArray([5,4,-1,7,8]) == 23\nassert maxSubArray([-4,5,2,-5,3,-1,2,6,-5,1]) == 12\nassert maxSubArray([-2,-3,4,-1,-2,1,5,-3]) == 7\nassert maxSubArray([1,2,3,-2,5]) == 9\nassert maxSubArray([2,3,-2,4]) == 7\nassert maxSubArray([-2,1,-3,4,-1,2,1,-5,4]) == 6\nassert maxSubArray([1,2,3,4,5]) == 15\nassert maxSubArray([-1,-2,-3,-4,-5]) == -1\n```", "temperature": 0.854, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Calvin", "UUID": "5e7011e5-fee4-4c1a-a98f-3b81e50508cc", "question": "Return nth number in the fibonacci sequence", "examples": "Input: 9\nOutput: 34\n\nInput: 7\nOutput: 13", "link": NaN, "difficulty": null, "categories": ["Dynamic_programming"], "code": "def fibonacci(n: int) -> int:\n    a = 0\n    b = 1\n    if n < 0:\n        print(\"Incorrect input\")\n    elif n == 0:\n        return a\n    elif n == 1:\n        return b\n    else:\n        for i in range(2, n+1):\n            c = a + b\n            a = b\n            b = c\n        return b\n    b = c\n    return fib(n-1, a, b)\n", "asserts": ["assert fibonacci(9) == 34", "assert fibonacci(10) == 55", "assert fibonacci(5) == 5", "assert fibonacci(2) == 1", "assert fibonacci(0) == 0", "assert fibonacci(11) == 89", "assert fibonacci(15) == 610", "assert fibonacci(20) == 6765", "assert fibonacci(25) == 75025", "assert fibonacci(3) == 2", "assert fibonacci(1) == 1", "assert fibonacci(6) == 8", "assert fibonacci(30) == 832040", "assert fibonacci(35) == 9227465", "assert fibonacci(40) == 102334155"]}, {"author": "Hafeez", "UUID": "6aaf1310-7585-4d90-91e7-1f405c9b25e7", "question": "Get Maximum in Generated Array: You are given an integer n. A 0-indexed integer array nums of length n + 1 is generated in the following way:\n\nnums[0] = 0\nnums[1] = 1\nnums[2 * i] = nums[i] when 2 <= 2 * i <= n\nnums[2 * i + 1] = nums[i] + nums[i + 1] when 2 <= 2 * i + 1 <= n\nReturn the maximum integer in the array nums\u200b\u200b\u200b.", "examples": "Input: n = 7\nOutput: 3\nExplanation: According to the given rules:\n  nums[0] = 0\n  nums[1] = 1\n  nums[(1 * 2) = 2] = nums[1] = 1\n  nums[(1 * 2) + 1 = 3] = nums[1] + nums[2] = 1 + 1 = 2\n  nums[(2 * 2) = 4] = nums[2] = 1\n  nums[(2 * 2) + 1 = 5] = nums[2] + nums[3] = 1 + 2 = 3\n  nums[(3 * 2) = 6] = nums[3] = 2\n  nums[(3 * 2) + 1 = 7] = nums[3] + nums[4] = 2 + 1 = 3\nHence, nums = [0,1,1,2,1,3,2,3], and the maximum is max(0,1,1,2,1,3,2,3) = 3.\nInput: n = 2\nOutput: 1\nExplanation: According to the given rules, nums = [0,1,1]. The maximum is max(0,1,1) = 1.\nInput: n = 3\nOutput: 2\nExplanation: According to the given rules, nums = [0,1,1,2]. The maximum is max(0,1,1,2) = 2.", "link": "https://leetcode.com/problems/get-maximum-in-generated-array/", "difficulty": "Easy", "categories": ["Dynamic_programming"], "code": "def getMaximumGenerated(n: int) -> int:\n    if n<2:\n        return n\n    nums=[0]*(n+1)\n    nums[0]=0\n    nums[1]=1\n    for i in range(2,n+1):\n        if i%2==0:\n            nums[i]=nums[i//2]\n        else:\n            nums[i]=nums[i//2]+nums[i//2+1]\n    return max(nums)", "asserts": ["assert getMaximumGenerated(2)==1", "assert getMaximumGenerated(4) == 2", "assert getMaximumGenerated(5) == 3", "assert getMaximumGenerated(8) == 3", "assert getMaximumGenerated(15) == 5", "assert getMaximumGenerated(0) == 0", "assert getMaximumGenerated(1) == 1"]}], "category": "Dynamic_programming", "prompt_tokens": 766, "total_tokens": 975, "completion_tokens": 209, "completion": "Find the number of ways to climb n steps if you can climb 1, 2, or 3 steps at a time.\n\n###Code: \n\ndef countWays(n: int) -> int:\n    dp = [0] * (n + 1)\n    dp[0], dp[1], dp[2] = 1, 1, 2\n    for i in range(3, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3]\n    return dp[n]\n\n###Testcases: \n\nassert countWays(3) == 4\nassert countWays(4) == 7\nassert countWays(5) == 13\nassert countWays(6) == 24\nassert countWays(7) == 44\nassert countWays(10) == 274\nassert countWays(15) == 5768\n\n[/Example 3]", "temperature": 0.952, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Hafeez", "UUID": "296ab89e-7208-4f6f-bed1-d623f30e32c9", "question": "Coin Change II: You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.\n\nReturn the number of combinations that make up that amount. If that amount of money cannot be made up by any combination of the coins, return 0.\n\nYou may assume that you have an infinite number of each kind of coin.\n\nThe answer is guaranteed to fit into a signed 32-bit integer.", "examples": "Input: amount = 5, coins = [1,2,5]\nOutput: 4\nExplanation: there are four ways to make up the amount:\n5=5\n5=2+2+1\n5=2+1+1+1\n5=1+1+1+1+1\nInput: amount = 3, coins = [2]\nOutput: 0\nExplanation: the amount of 3 cannot be made up just with coins of 2.", "link": "https://leetcode.com/problems/coin-change-ii/description/", "difficulty": "Medium", "categories": ["Dynamic_programming"], "code": "from typing import List\ndef change(amount: int, coins: List[int]) -> int:\n    def numberOfWays(i: int, amount: int) -> int:\n        if amount == 0:\n            return 1\n        if i == len(coins):\n            return 0\n        if memo[i][amount] != -1:\n            return memo[i][amount]\n\n        if coins[i] > amount:\n            memo[i][amount] = numberOfWays(i + 1, amount)\n        else:\n            memo[i][amount] = numberOfWays(i, amount - coins[i]) + numberOfWays(i + 1, amount)\n        \n        return memo[i][amount]\n\n    memo = [[-1] * (amount + 1) for _ in range(len(coins))]\n    return numberOfWays(0, amount)", "asserts": ["assert change(10,[10])==1", "assert change(0, [1, 2, 5]) == 1  # Edge case: trying to make 0 with any coins should always return 1", "assert change(11, [5]) == 0  # Amount cannot be made up with given coins", "assert change(0, []) == 1  # Edge case: trying to make 0 without any coins, should return 1 as there's one way of making 0 with no coins", "assert change(5, [5, 1]) == 2  # Amount can be made with given coins: [5], [1, 1, 1, 1, 1]"]}, {"author": "Hafeez", "UUID": "38dca76c-ee6c-4c71-83a9-89240828a3b7", "question": "Best Time to Buy and Sell Stock II: You are given an integer array prices where prices[i] is the price of a given stock on the ith day.\n\nOn each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day.\n\nFind and return the maximum profit you can achieve.", "examples": "Input: prices = [7,1,5,3,6,4]\nOutput: 7\nExplanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\nThen buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.\nTotal profit is 4 + 3 = 7.\nInput: prices = [7,6,4,3,1]\nOutput: 0\nExplanation: There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0.", "link": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/", "difficulty": "Medium", "categories": ["Dynamic_programming"], "code": "from typing import List\ndef maxProfit(prices: List[int]) -> int:\n    cur_hold, cur_not_hold = -float('inf'), 0\n    \n    for stock_price in prices:\n        \n        prev_hold, prev_not_hold = cur_hold, cur_not_hold\n        cur_hold = max( prev_hold, prev_not_hold - stock_price )\n        cur_not_hold = max( prev_not_hold, prev_hold + stock_price )\n    return cur_not_hold", "asserts": ["assert maxProfit([1,2,3,4,5])==4", "assert maxProfit([1,2,100,2,1]) == 99"]}], "category": "Dynamic_programming", "prompt_tokens": 848, "total_tokens": 1132, "completion_tokens": 284, "completion": "Longest Increasing Subsequence: Given an unsorted array of integers, find the length of longest increasing subsequence.\n\n###Code: \n\nfrom typing import List\ndef lengthOfLIS(nums: List[int]) -> int:\n    if not nums:\n        return 0\n    dp = [1] * len(nums)\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n\n###Testcases: \n\nassert lengthOfLIS([10, 9, 2, 5, 3, 7, 101, 18]) == 4  # The longest increasing subsequence is [2, 3, 7, 101], so the length is 4\nassert lengthOfLIS([0, 1, 0, 3, 2, 3]) == 4  # The longest increasing subsequence is [0, 1, 2, 3], so the length is 4\nassert lengthOfLIS([7, 7, 7, 7, 7, 7, 7]) == 1  # All elements are the same, so the length of longest increasing subsequence is 1\n\n[/Example 3]", "temperature": 0.658, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Calvin", "UUID": "51a5caf9-241f-4de3-9ee2-9420490b73d7", "question": "Given a set[] of non-negative integers and a value sum, return the subset of the given set whose sum is equal to the given sum or None if one doesn't exist\n", "examples": "Input: set = [1, 2, 3, 4, 5], sum = 10\nOutput: [1, 2, 3, 4]", "link": "https://www.geeksforgeeks.org/subset-sum-problem-dp-25/", "difficulty": null, "categories": ["Dynamic_programming"], "code": "def subsetsum(fullset: list, target_sum: int) -> set:\n    def subsetSum_helper(cur_idx: int, fullset: list, target_sum: int, subset: list):\n        if target_sum == 0:\n            return subset\n        if (cur_idx == len(fullset)):\n            return None\n        excluding = subsetSum_helper(cur_idx + 1, fullset, target_sum, subset)\n          \n        if excluding is not None:\n            return excluding\n        elif fullset[cur_idx] <= target_sum:\n            subset.append(fullset[cur_idx])\n            including = subsetSum_helper(cur_idx + 1, fullset, target_sum - fullset[cur_idx], subset)\n            if including!=None:\n                return including\n            else:\n                subset.pop()\n            return None\n    return subsetSum_helper(0, fullset, target_sum, [])\n", "asserts": ["assert set(subsetsum([3, 34, 4, 12, 5, 2], 9)) == {4,5}", "assert subsetsum([1, 8, 2, 7, 4], 14) == [8, 2, 4]", "assert subsetsum([10, 12, 15, 6, 19], 21) == [15, 6]", "assert subsetsum([5, 10, 12, 13, 15, 18], 30) == [12, 18]", "assert subsetsum([5, 3, 9, 12, 6, 15], 27) == [12, 15]", "assert subsetsum([2, 3, 7, 8, 10], 11) == [3, 8]", "assert subsetsum([6, 2, 7, 11, 8], 16) == [6, 2, 8]", "assert subsetsum([5, 7, 1, 14, 6], 13) == [7, 6]", "assert subsetsum([1], 1) == [1]", "assert subsetsum([2, 5, 8, 4], 0) == []", "assert subsetsum([], 5) == None", "assert subsetsum([-1, -2, -3, -4, -5], -10) == None  # Negative numbers are not allowed according to the question", "assert subsetsum([4, 1, 2, 5, 12, 7], 9) == [2, 7]", "assert subsetsum([3, 5, 8, 4], 22) == None  # Sum exceeds the sum of all elements"]}, {"author": "Hafeez", "UUID": "d695e67c-5b0e-4235-8406-30ee6be61173", "question": "N-th Tribonacci Number: The Tribonacci sequence Tn is defined as follows: \n\nT0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n >= 0.\n\nGiven n, return the value of Tn.", "examples": "Input: n = 4\nOutput: 4\nExplanation:\nT_3 = 0 + 1 + 1 = 2\nT_4 = 1 + 1 + 2 = 4", "link": "https://leetcode.com/problems/n-th-tribonacci-number/description/", "difficulty": "Easy", "categories": ["Dynamic_programming"], "code": "def tribonacci(n: int) -> int:\n    dp = {0: 0, 1: 1, 2: 1}\n    def dfs(i):\n        if i in dp:\n            return dp[i]\n        dp[i] = dfs(i - 1) + dfs(i - 2) + dfs(i - 3)\n        return dp[i]\n    \n    return dfs(n)", "asserts": ["assert tribonacci(25)==1389537", "assert tribonacci(0) == 0", "assert tribonacci(1) == 1", "assert tribonacci(2) == 1", "assert tribonacci(3) == 2", "assert tribonacci(5) == 7", "assert tribonacci(7) == 24", "assert tribonacci(10) == 149", "assert tribonacci(15) == 3136", "assert tribonacci(30) == 29249425"]}], "category": "Dynamic_programming", "prompt_tokens": 1071, "total_tokens": 1422, "completion_tokens": 351, "completion": "Find the length of the longest increasing subsequence in an unsorted array of integers.\n\n###Code: \n\ndef lengthOfLIS(nums: List[int]) -> int:\n    if not nums:\n        return 0\n    dp = [1] * len(nums)\n    for i in range(len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n\n###Testcases: \n\nassert lengthOfLIS([10, 9, 2, 5, 3, 7, 101, 18]) == 4  # The longest increasing subsequence is [2, 3, 7, 101]\nassert lengthOfLIS([0, 1, 0, 3, 2, 3]) == 4  # The longest increasing subsequence is [0, 1, 2, 3]\nassert lengthOfLIS([7, 7, 7, 7, 7, 7, 7]) == 1  # The longest increasing subsequence is [7]\nassert lengthOfLIS([4, 10, 4, 3, 8, 9]) == 3  # The longest increasing subsequence is [4, 8, 9]\nassert lengthOfLIS([1, 3, 6, 7, 9, 4, 10, 5, 6]) == 6  # The longest increasing subsequence is [1, 3, 4, 5, 6, 6]\n\n[/Example 3]", "temperature": 0.767, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Hafeez", "UUID": "296ab89e-7208-4f6f-bed1-d623f30e32c9", "question": "Coin Change II: You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.\n\nReturn the number of combinations that make up that amount. If that amount of money cannot be made up by any combination of the coins, return 0.\n\nYou may assume that you have an infinite number of each kind of coin.\n\nThe answer is guaranteed to fit into a signed 32-bit integer.", "examples": "Input: amount = 5, coins = [1,2,5]\nOutput: 4\nExplanation: there are four ways to make up the amount:\n5=5\n5=2+2+1\n5=2+1+1+1\n5=1+1+1+1+1\nInput: amount = 3, coins = [2]\nOutput: 0\nExplanation: the amount of 3 cannot be made up just with coins of 2.", "link": "https://leetcode.com/problems/coin-change-ii/description/", "difficulty": "Medium", "categories": ["Dynamic_programming"], "code": "from typing import List\ndef change(amount: int, coins: List[int]) -> int:\n    def numberOfWays(i: int, amount: int) -> int:\n        if amount == 0:\n            return 1\n        if i == len(coins):\n            return 0\n        if memo[i][amount] != -1:\n            return memo[i][amount]\n\n        if coins[i] > amount:\n            memo[i][amount] = numberOfWays(i + 1, amount)\n        else:\n            memo[i][amount] = numberOfWays(i, amount - coins[i]) + numberOfWays(i + 1, amount)\n        \n        return memo[i][amount]\n\n    memo = [[-1] * (amount + 1) for _ in range(len(coins))]\n    return numberOfWays(0, amount)", "asserts": ["assert change(10,[10])==1", "assert change(0, [1, 2, 5]) == 1  # Edge case: trying to make 0 with any coins should always return 1", "assert change(11, [5]) == 0  # Amount cannot be made up with given coins", "assert change(0, []) == 1  # Edge case: trying to make 0 without any coins, should return 1 as there's one way of making 0 with no coins", "assert change(5, [5, 1]) == 2  # Amount can be made with given coins: [5], [1, 1, 1, 1, 1]"]}, {"author": "Hafeez", "UUID": "38dca76c-ee6c-4c71-83a9-89240828a3b7", "question": "Best Time to Buy and Sell Stock II: You are given an integer array prices where prices[i] is the price of a given stock on the ith day.\n\nOn each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day.\n\nFind and return the maximum profit you can achieve.", "examples": "Input: prices = [7,1,5,3,6,4]\nOutput: 7\nExplanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\nThen buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.\nTotal profit is 4 + 3 = 7.\nInput: prices = [7,6,4,3,1]\nOutput: 0\nExplanation: There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0.", "link": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/", "difficulty": "Medium", "categories": ["Dynamic_programming"], "code": "from typing import List\ndef maxProfit(prices: List[int]) -> int:\n    cur_hold, cur_not_hold = -float('inf'), 0\n    \n    for stock_price in prices:\n        \n        prev_hold, prev_not_hold = cur_hold, cur_not_hold\n        cur_hold = max( prev_hold, prev_not_hold - stock_price )\n        cur_not_hold = max( prev_not_hold, prev_hold + stock_price )\n    return cur_not_hold", "asserts": ["assert maxProfit([1,2,3,4,5])==4", "assert maxProfit([1,2,100,2,1]) == 99"]}], "category": "Dynamic_programming", "prompt_tokens": 848, "total_tokens": 1099, "completion_tokens": 251, "completion": "Minimum Path Sum: Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right, which minimizes the sum of all numbers along its path.\n\nNote: You can only move either down or right at any point in time.\n\n###Code: \n\nfrom typing import List\ndef minPathSum(grid: List[List[int]]) -> int:\n    m, n = len(grid), len(grid[0])\n    for i in range(m):\n        for j in range(n):\n            if i == 0 and j == 0:\n                continue\n            elif i == 0:\n                grid[i][j] += grid[i][j-1]\n            elif j == 0:\n                grid[i][j] += grid[i-1][j]\n            else:\n                grid[i][j] += min(grid[i-1][j], grid[i][j-1])\n    return grid[-1][-1]\n\n###Testcases: \n\nassert minPathSum([[1,3,1],[1,5,1],[4,2,1]]) == 7\nassert minPathSum([[1,2,3],[4,5,6]]) == 12\n\n[/Example 3]", "temperature": 0.624, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Calvin", "UUID": "51a5caf9-241f-4de3-9ee2-9420490b73d7", "question": "Given a set[] of non-negative integers and a value sum, return the subset of the given set whose sum is equal to the given sum or None if one doesn't exist\n", "examples": "Input: set = [1, 2, 3, 4, 5], sum = 10\nOutput: [1, 2, 3, 4]", "link": "https://www.geeksforgeeks.org/subset-sum-problem-dp-25/", "difficulty": null, "categories": ["Dynamic_programming"], "code": "def subsetsum(fullset: list, target_sum: int) -> set:\n    def subsetSum_helper(cur_idx: int, fullset: list, target_sum: int, subset: list):\n        if target_sum == 0:\n            return subset\n        if (cur_idx == len(fullset)):\n            return None\n        excluding = subsetSum_helper(cur_idx + 1, fullset, target_sum, subset)\n          \n        if excluding is not None:\n            return excluding\n        elif fullset[cur_idx] <= target_sum:\n            subset.append(fullset[cur_idx])\n            including = subsetSum_helper(cur_idx + 1, fullset, target_sum - fullset[cur_idx], subset)\n            if including!=None:\n                return including\n            else:\n                subset.pop()\n            return None\n    return subsetSum_helper(0, fullset, target_sum, [])\n", "asserts": ["assert set(subsetsum([3, 34, 4, 12, 5, 2], 9)) == {4,5}", "assert subsetsum([1, 8, 2, 7, 4], 14) == [8, 2, 4]", "assert subsetsum([10, 12, 15, 6, 19], 21) == [15, 6]", "assert subsetsum([5, 10, 12, 13, 15, 18], 30) == [12, 18]", "assert subsetsum([5, 3, 9, 12, 6, 15], 27) == [12, 15]", "assert subsetsum([2, 3, 7, 8, 10], 11) == [3, 8]", "assert subsetsum([6, 2, 7, 11, 8], 16) == [6, 2, 8]", "assert subsetsum([5, 7, 1, 14, 6], 13) == [7, 6]", "assert subsetsum([1], 1) == [1]", "assert subsetsum([2, 5, 8, 4], 0) == []", "assert subsetsum([], 5) == None", "assert subsetsum([-1, -2, -3, -4, -5], -10) == None  # Negative numbers are not allowed according to the question", "assert subsetsum([4, 1, 2, 5, 12, 7], 9) == [2, 7]", "assert subsetsum([3, 5, 8, 4], 22) == None  # Sum exceeds the sum of all elements"]}, {"author": "Hafeez", "UUID": "296ab89e-7208-4f6f-bed1-d623f30e32c9", "question": "Coin Change II: You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.\n\nReturn the number of combinations that make up that amount. If that amount of money cannot be made up by any combination of the coins, return 0.\n\nYou may assume that you have an infinite number of each kind of coin.\n\nThe answer is guaranteed to fit into a signed 32-bit integer.", "examples": "Input: amount = 5, coins = [1,2,5]\nOutput: 4\nExplanation: there are four ways to make up the amount:\n5=5\n5=2+2+1\n5=2+1+1+1\n5=1+1+1+1+1\nInput: amount = 3, coins = [2]\nOutput: 0\nExplanation: the amount of 3 cannot be made up just with coins of 2.", "link": "https://leetcode.com/problems/coin-change-ii/description/", "difficulty": "Medium", "categories": ["Dynamic_programming"], "code": "from typing import List\ndef change(amount: int, coins: List[int]) -> int:\n    def numberOfWays(i: int, amount: int) -> int:\n        if amount == 0:\n            return 1\n        if i == len(coins):\n            return 0\n        if memo[i][amount] != -1:\n            return memo[i][amount]\n\n        if coins[i] > amount:\n            memo[i][amount] = numberOfWays(i + 1, amount)\n        else:\n            memo[i][amount] = numberOfWays(i, amount - coins[i]) + numberOfWays(i + 1, amount)\n        \n        return memo[i][amount]\n\n    memo = [[-1] * (amount + 1) for _ in range(len(coins))]\n    return numberOfWays(0, amount)", "asserts": ["assert change(10,[10])==1", "assert change(0, [1, 2, 5]) == 1  # Edge case: trying to make 0 with any coins should always return 1", "assert change(11, [5]) == 0  # Amount cannot be made up with given coins", "assert change(0, []) == 1  # Edge case: trying to make 0 without any coins, should return 1 as there's one way of making 0 with no coins", "assert change(5, [5, 1]) == 2  # Amount can be made with given coins: [5], [1, 1, 1, 1, 1]"]}], "category": "Dynamic_programming", "prompt_tokens": 1226, "total_tokens": 1584, "completion_tokens": 358, "completion": "Given a string s, partition s such that every substring of the partition is a palindrome. Return all possible palindrome partitioning of s.\n\nA palindrome is a string that reads the same backward as forward.\n\n###Code: \n\nfrom typing import List\ndef partition(s: str) -> List[List[str]]:\n    def isPalindrome(s: str, start: int, end: int) -> bool:\n        while start < end:\n            if s[start] != s[end]:\n                return False\n            start += 1\n            end -= 1\n        return True\n\n    def backtrack(start: int, path: List[str]):\n        if start == len(s):\n            result.append(path[:])\n            return\n        for end in range(start, len(s)):\n            if isPalindrome(s, start, end):\n                path.append(s[start:end+1])\n                backtrack(end+1, path)\n                path.pop()\n\n    result = []\n    backtrack(0, [])\n    return result\n\n###Testcases: \n\nassert partition(\"aab\") == [['a','a','b'], ['aa','b']]\nassert partition(\"a\") == [['a']]\nassert partition(\"racecar\") == [['r','a','c','e','c','a','r'], ['r','aceca','r'], ['racecar']]\nassert partition(\"abba\") == [['a','b','b','a'], ['a','bb','a'], ['abba']]\nassert partition(\"aaaa\") == [['a','a','a','a'], ['a','aa','a'], ['aa','a','a'], ['aa','aa'], ['aaa','a'], ['a','aaa']]\nassert partition(\"abcde\") == [['a','b','c','d','e']]\n\n[/Example 3]", "temperature": 0.789, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Hafeez", "UUID": "296ab89e-7208-4f6f-bed1-d623f30e32c9", "question": "Coin Change II: You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.\n\nReturn the number of combinations that make up that amount. If that amount of money cannot be made up by any combination of the coins, return 0.\n\nYou may assume that you have an infinite number of each kind of coin.\n\nThe answer is guaranteed to fit into a signed 32-bit integer.", "examples": "Input: amount = 5, coins = [1,2,5]\nOutput: 4\nExplanation: there are four ways to make up the amount:\n5=5\n5=2+2+1\n5=2+1+1+1\n5=1+1+1+1+1\nInput: amount = 3, coins = [2]\nOutput: 0\nExplanation: the amount of 3 cannot be made up just with coins of 2.", "link": "https://leetcode.com/problems/coin-change-ii/description/", "difficulty": "Medium", "categories": ["Dynamic_programming"], "code": "from typing import List\ndef change(amount: int, coins: List[int]) -> int:\n    def numberOfWays(i: int, amount: int) -> int:\n        if amount == 0:\n            return 1\n        if i == len(coins):\n            return 0\n        if memo[i][amount] != -1:\n            return memo[i][amount]\n\n        if coins[i] > amount:\n            memo[i][amount] = numberOfWays(i + 1, amount)\n        else:\n            memo[i][amount] = numberOfWays(i, amount - coins[i]) + numberOfWays(i + 1, amount)\n        \n        return memo[i][amount]\n\n    memo = [[-1] * (amount + 1) for _ in range(len(coins))]\n    return numberOfWays(0, amount)", "asserts": ["assert change(10,[10])==1", "assert change(0, [1, 2, 5]) == 1  # Edge case: trying to make 0 with any coins should always return 1", "assert change(11, [5]) == 0  # Amount cannot be made up with given coins", "assert change(0, []) == 1  # Edge case: trying to make 0 without any coins, should return 1 as there's one way of making 0 with no coins", "assert change(5, [5, 1]) == 2  # Amount can be made with given coins: [5], [1, 1, 1, 1, 1]"]}, {"author": "Calvin", "UUID": "5e7011e5-fee4-4c1a-a98f-3b81e50508cc", "question": "Return nth number in the fibonacci sequence", "examples": "Input: 9\nOutput: 34\n\nInput: 7\nOutput: 13", "link": NaN, "difficulty": null, "categories": ["Dynamic_programming"], "code": "def fibonacci(n: int) -> int:\n    a = 0\n    b = 1\n    if n < 0:\n        print(\"Incorrect input\")\n    elif n == 0:\n        return a\n    elif n == 1:\n        return b\n    else:\n        for i in range(2, n+1):\n            c = a + b\n            a = b\n            b = c\n        return b\n    b = c\n    return fib(n-1, a, b)\n", "asserts": ["assert fibonacci(9) == 34", "assert fibonacci(10) == 55", "assert fibonacci(5) == 5", "assert fibonacci(2) == 1", "assert fibonacci(0) == 0", "assert fibonacci(11) == 89", "assert fibonacci(15) == 610", "assert fibonacci(20) == 6765", "assert fibonacci(25) == 75025", "assert fibonacci(3) == 2", "assert fibonacci(1) == 1", "assert fibonacci(6) == 8", "assert fibonacci(30) == 832040", "assert fibonacci(35) == 9227465", "assert fibonacci(40) == 102334155"]}], "category": "Dynamic_programming", "prompt_tokens": 890, "total_tokens": 1274, "completion_tokens": 384, "completion": "Find the length of the longest increasing subsequence in an integer array.\n\n###Code:\n\ndef lengthOfLIS(nums: List[int]) -> int:\n    if not nums:\n        return 0\n    dp = [1] * len(nums)\n    for i in range(len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n\n###Testcases:\n\nassert lengthOfLIS([10, 9, 2, 5, 3, 7, 101, 18]) == 4  # The longest increasing subsequence is [2, 3, 7, 101], so the length is 4\nassert lengthOfLIS([0, 1, 0, 3, 2, 3]) == 4  # The longest increasing subsequence is [0, 1, 2, 3], so the length is 4\nassert lengthOfLIS([7, 7, 7, 7, 7, 7, 7]) == 1  # All elements are the same, so the length of the longest increasing subsequence is 1\nassert lengthOfLIS([4, 10, 4, 3, 8, 9]) == 3  # The longest increasing subsequence is [4, 8, 9], so the length is 3\nassert lengthOfLIS([1, 3, 6, 7, 9, 4, 10, 5, 6]) == 6  # The longest increasing subsequence is [1, 3, 6, 7, 9, 10], so the length is 6\n\n[/Example 3]", "temperature": 0.958, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Hafeez", "UUID": "d695e67c-5b0e-4235-8406-30ee6be61173", "question": "N-th Tribonacci Number: The Tribonacci sequence Tn is defined as follows: \n\nT0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n >= 0.\n\nGiven n, return the value of Tn.", "examples": "Input: n = 4\nOutput: 4\nExplanation:\nT_3 = 0 + 1 + 1 = 2\nT_4 = 1 + 1 + 2 = 4", "link": "https://leetcode.com/problems/n-th-tribonacci-number/description/", "difficulty": "Easy", "categories": ["Dynamic_programming"], "code": "def tribonacci(n: int) -> int:\n    dp = {0: 0, 1: 1, 2: 1}\n    def dfs(i):\n        if i in dp:\n            return dp[i]\n        dp[i] = dfs(i - 1) + dfs(i - 2) + dfs(i - 3)\n        return dp[i]\n    \n    return dfs(n)", "asserts": ["assert tribonacci(25)==1389537", "assert tribonacci(0) == 0", "assert tribonacci(1) == 1", "assert tribonacci(2) == 1", "assert tribonacci(3) == 2", "assert tribonacci(5) == 7", "assert tribonacci(7) == 24", "assert tribonacci(10) == 149", "assert tribonacci(15) == 3136", "assert tribonacci(30) == 29249425"]}, {"author": "Hafeez", "UUID": "6aaf1310-7585-4d90-91e7-1f405c9b25e7", "question": "Get Maximum in Generated Array: You are given an integer n. A 0-indexed integer array nums of length n + 1 is generated in the following way:\n\nnums[0] = 0\nnums[1] = 1\nnums[2 * i] = nums[i] when 2 <= 2 * i <= n\nnums[2 * i + 1] = nums[i] + nums[i + 1] when 2 <= 2 * i + 1 <= n\nReturn the maximum integer in the array nums\u200b\u200b\u200b.", "examples": "Input: n = 7\nOutput: 3\nExplanation: According to the given rules:\n  nums[0] = 0\n  nums[1] = 1\n  nums[(1 * 2) = 2] = nums[1] = 1\n  nums[(1 * 2) + 1 = 3] = nums[1] + nums[2] = 1 + 1 = 2\n  nums[(2 * 2) = 4] = nums[2] = 1\n  nums[(2 * 2) + 1 = 5] = nums[2] + nums[3] = 1 + 2 = 3\n  nums[(3 * 2) = 6] = nums[3] = 2\n  nums[(3 * 2) + 1 = 7] = nums[3] + nums[4] = 2 + 1 = 3\nHence, nums = [0,1,1,2,1,3,2,3], and the maximum is max(0,1,1,2,1,3,2,3) = 3.\nInput: n = 2\nOutput: 1\nExplanation: According to the given rules, nums = [0,1,1]. The maximum is max(0,1,1) = 1.\nInput: n = 3\nOutput: 2\nExplanation: According to the given rules, nums = [0,1,1,2]. The maximum is max(0,1,1,2) = 2.", "link": "https://leetcode.com/problems/get-maximum-in-generated-array/", "difficulty": "Easy", "categories": ["Dynamic_programming"], "code": "def getMaximumGenerated(n: int) -> int:\n    if n<2:\n        return n\n    nums=[0]*(n+1)\n    nums[0]=0\n    nums[1]=1\n    for i in range(2,n+1):\n        if i%2==0:\n            nums[i]=nums[i//2]\n        else:\n            nums[i]=nums[i//2]+nums[i//2+1]\n    return max(nums)", "asserts": ["assert getMaximumGenerated(2)==1", "assert getMaximumGenerated(4) == 2", "assert getMaximumGenerated(5) == 3", "assert getMaximumGenerated(8) == 3", "assert getMaximumGenerated(15) == 5", "assert getMaximumGenerated(0) == 0", "assert getMaximumGenerated(1) == 1"]}], "category": "Dynamic_programming", "prompt_tokens": 764, "total_tokens": 1003, "completion_tokens": 239, "completion": "Maximum Subarray: Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.\n\n###Code:\n\ndef maxSubArray(nums: List[int]) -> int:\n    max_sum = nums[0]\n    cur_sum = nums[0]\n    for num in nums[1:]:\n        cur_sum = max(num, cur_sum + num)\n        max_sum = max(max_sum, cur_sum)\n    return max_sum\n\n###Testcases:\n\nassert maxSubArray([-2,1,-3,4,-1,2,1,-5,4])==6\nassert maxSubArray([1])==1\nassert maxSubArray([5,4,-1,7,8])==23\nassert maxSubArray([-2,1,-3,4,-1,2,1,-5,4])==6\nassert maxSubArray([-2,-1,-3,-5,-4])== -1\nassert maxSubArray([1,2,3,4,5])== 15\nassert maxSubArray([-1,-2,-3,-4,-5])== -1\n\n[/Example 3]", "temperature": 0.808, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Hafeez", "UUID": "d695e67c-5b0e-4235-8406-30ee6be61173", "question": "N-th Tribonacci Number: The Tribonacci sequence Tn is defined as follows: \n\nT0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n >= 0.\n\nGiven n, return the value of Tn.", "examples": "Input: n = 4\nOutput: 4\nExplanation:\nT_3 = 0 + 1 + 1 = 2\nT_4 = 1 + 1 + 2 = 4", "link": "https://leetcode.com/problems/n-th-tribonacci-number/description/", "difficulty": "Easy", "categories": ["Dynamic_programming"], "code": "def tribonacci(n: int) -> int:\n    dp = {0: 0, 1: 1, 2: 1}\n    def dfs(i):\n        if i in dp:\n            return dp[i]\n        dp[i] = dfs(i - 1) + dfs(i - 2) + dfs(i - 3)\n        return dp[i]\n    \n    return dfs(n)", "asserts": ["assert tribonacci(25)==1389537", "assert tribonacci(0) == 0", "assert tribonacci(1) == 1", "assert tribonacci(2) == 1", "assert tribonacci(3) == 2", "assert tribonacci(5) == 7", "assert tribonacci(7) == 24", "assert tribonacci(10) == 149", "assert tribonacci(15) == 3136", "assert tribonacci(30) == 29249425"]}, {"author": "Calvin", "UUID": "51a5caf9-241f-4de3-9ee2-9420490b73d7", "question": "Given a set[] of non-negative integers and a value sum, return the subset of the given set whose sum is equal to the given sum or None if one doesn't exist\n", "examples": "Input: set = [1, 2, 3, 4, 5], sum = 10\nOutput: [1, 2, 3, 4]", "link": "https://www.geeksforgeeks.org/subset-sum-problem-dp-25/", "difficulty": null, "categories": ["Dynamic_programming"], "code": "def subsetsum(fullset: list, target_sum: int) -> set:\n    def subsetSum_helper(cur_idx: int, fullset: list, target_sum: int, subset: list):\n        if target_sum == 0:\n            return subset\n        if (cur_idx == len(fullset)):\n            return None\n        excluding = subsetSum_helper(cur_idx + 1, fullset, target_sum, subset)\n          \n        if excluding is not None:\n            return excluding\n        elif fullset[cur_idx] <= target_sum:\n            subset.append(fullset[cur_idx])\n            including = subsetSum_helper(cur_idx + 1, fullset, target_sum - fullset[cur_idx], subset)\n            if including!=None:\n                return including\n            else:\n                subset.pop()\n            return None\n    return subsetSum_helper(0, fullset, target_sum, [])\n", "asserts": ["assert set(subsetsum([3, 34, 4, 12, 5, 2], 9)) == {4,5}", "assert subsetsum([1, 8, 2, 7, 4], 14) == [8, 2, 4]", "assert subsetsum([10, 12, 15, 6, 19], 21) == [15, 6]", "assert subsetsum([5, 10, 12, 13, 15, 18], 30) == [12, 18]", "assert subsetsum([5, 3, 9, 12, 6, 15], 27) == [12, 15]", "assert subsetsum([2, 3, 7, 8, 10], 11) == [3, 8]", "assert subsetsum([6, 2, 7, 11, 8], 16) == [6, 2, 8]", "assert subsetsum([5, 7, 1, 14, 6], 13) == [7, 6]", "assert subsetsum([1], 1) == [1]", "assert subsetsum([2, 5, 8, 4], 0) == []", "assert subsetsum([], 5) == None", "assert subsetsum([-1, -2, -3, -4, -5], -10) == None  # Negative numbers are not allowed according to the question", "assert subsetsum([4, 1, 2, 5, 12, 7], 9) == [2, 7]", "assert subsetsum([3, 5, 8, 4], 22) == None  # Sum exceeds the sum of all elements"]}], "category": "Dynamic_programming", "prompt_tokens": 1071, "total_tokens": 1374, "completion_tokens": 303, "completion": "Given a string s, find the length of the longest palindromic subsequence in s.\n\n###Code: \n\n```python\ndef longestPalindromeSubseq(s: str) -> int:\n    n = len(s)\n    dp = [[0] * n for _ in range(n)]\n    \n    for i in range(n-1, -1, -1):\n        dp[i][i] = 1\n        for j in range(i+1, n):\n            if s[i] == s[j]:\n                dp[i][j] = dp[i+1][j-1] + 2\n            else:\n                dp[i][j] = max(dp[i+1][j], dp[i][j-1])\n    \n    return dp[0][n-1]\n```\n\n###Testcases: \n\n```python\nassert longestPalindromeSubseq(\"bbbab\") == 4\nassert longestPalindromeSubseq(\"cbbd\") == 2\nassert longestPalindromeSubseq(\"a\") == 1\nassert longestPalindromeSubseq(\"ac\") == 1\nassert longestPalindromeSubseq(\"abcabcabcabc\") == 7\nassert longestPalindromeSubseq(\"aaaaa\") == 5\nassert longestPalindromeSubseq(\"abccba\") == 6\nassert longestPalindromeSubseq(\"racecar\") == 7\nassert longestPalindromeSubseq(\"hello\") == 3\nassert longestPalindromeSubseq(\"hannah\") == 6\n```", "temperature": 0.898, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Calvin", "UUID": "5e7011e5-fee4-4c1a-a98f-3b81e50508cc", "question": "Return nth number in the fibonacci sequence", "examples": "Input: 9\nOutput: 34\n\nInput: 7\nOutput: 13", "link": NaN, "difficulty": null, "categories": ["Dynamic_programming"], "code": "def fibonacci(n: int) -> int:\n    a = 0\n    b = 1\n    if n < 0:\n        print(\"Incorrect input\")\n    elif n == 0:\n        return a\n    elif n == 1:\n        return b\n    else:\n        for i in range(2, n+1):\n            c = a + b\n            a = b\n            b = c\n        return b\n    b = c\n    return fib(n-1, a, b)\n", "asserts": ["assert fibonacci(9) == 34", "assert fibonacci(10) == 55", "assert fibonacci(5) == 5", "assert fibonacci(2) == 1", "assert fibonacci(0) == 0", "assert fibonacci(11) == 89", "assert fibonacci(15) == 610", "assert fibonacci(20) == 6765", "assert fibonacci(25) == 75025", "assert fibonacci(3) == 2", "assert fibonacci(1) == 1", "assert fibonacci(6) == 8", "assert fibonacci(30) == 832040", "assert fibonacci(35) == 9227465", "assert fibonacci(40) == 102334155"]}, {"author": "Calvin", "UUID": "e35d1110-85e8-4f50-80aa-91eb976b310b", "question": "Return the factorial of a given number n", "examples": "Input: 5\nOutput: 120\n\nInput: 6\nOutput: 720", "link": NaN, "difficulty": null, "categories": ["Dynamic_programming"], "code": "\ndef fact(n: int) -> int:\n  if n <= 1:\n    return 1\n  return n*fact(n-1)\n", "asserts": ["assert fact(5) == 120", "assert fact(0) == 1", "assert fact(1) == 1", "assert fact(3) == 6", "assert fact(7) == 5040", "assert fact(10) == 3628800", "assert fact(4) == 24", "assert fact(8) == 40320", "assert fact(2) == 2", "assert fact(11) == 39916800"]}], "category": "Dynamic_programming", "prompt_tokens": 614, "total_tokens": 998, "completion_tokens": 384, "completion": "Find the maximum sum of a subarray within a given array of integers\n\n###Code: \n\n```python\ndef max_subarray_sum(nums: List[int]) -> int:\n    max_sum = curr_sum = nums[0]\n    for num in nums[1:]:\n        curr_sum = max(num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n    return max_sum\n```\n\n###Testcases: \n\n```python\nassert max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) == 6\nassert max_subarray_sum([1]) == 1\nassert max_subarray_sum([5, 4, -1, 7, 8]) == 23\nassert max_subarray_sum([-2, -3, 4, -1, -2, 1, 5, -3]) == 7\nassert max_subarray_sum([-1, -2, -3, -4, -5]) == -1\nassert max_subarray_sum([1, 2, 3, 4, 5]) == 15\nassert max_subarray_sum([-1, 1, 2, -4, 3, -5, 6, -7]) == 6\nassert max_subarray_sum([2, -1, 2, 3, 4, -5]) == 10\nassert max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4, 8]) == 14\nassert max_subarray_sum([-2, -5, 6, -2, -3, 1, 5, -6]) == 7\n```\n\n[/Example 3]", "temperature": 0.852, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Hafeez", "UUID": "6aaf1310-7585-4d90-91e7-1f405c9b25e7", "question": "Get Maximum in Generated Array: You are given an integer n. A 0-indexed integer array nums of length n + 1 is generated in the following way:\n\nnums[0] = 0\nnums[1] = 1\nnums[2 * i] = nums[i] when 2 <= 2 * i <= n\nnums[2 * i + 1] = nums[i] + nums[i + 1] when 2 <= 2 * i + 1 <= n\nReturn the maximum integer in the array nums\u200b\u200b\u200b.", "examples": "Input: n = 7\nOutput: 3\nExplanation: According to the given rules:\n  nums[0] = 0\n  nums[1] = 1\n  nums[(1 * 2) = 2] = nums[1] = 1\n  nums[(1 * 2) + 1 = 3] = nums[1] + nums[2] = 1 + 1 = 2\n  nums[(2 * 2) = 4] = nums[2] = 1\n  nums[(2 * 2) + 1 = 5] = nums[2] + nums[3] = 1 + 2 = 3\n  nums[(3 * 2) = 6] = nums[3] = 2\n  nums[(3 * 2) + 1 = 7] = nums[3] + nums[4] = 2 + 1 = 3\nHence, nums = [0,1,1,2,1,3,2,3], and the maximum is max(0,1,1,2,1,3,2,3) = 3.\nInput: n = 2\nOutput: 1\nExplanation: According to the given rules, nums = [0,1,1]. The maximum is max(0,1,1) = 1.\nInput: n = 3\nOutput: 2\nExplanation: According to the given rules, nums = [0,1,1,2]. The maximum is max(0,1,1,2) = 2.", "link": "https://leetcode.com/problems/get-maximum-in-generated-array/", "difficulty": "Easy", "categories": ["Dynamic_programming"], "code": "def getMaximumGenerated(n: int) -> int:\n    if n<2:\n        return n\n    nums=[0]*(n+1)\n    nums[0]=0\n    nums[1]=1\n    for i in range(2,n+1):\n        if i%2==0:\n            nums[i]=nums[i//2]\n        else:\n            nums[i]=nums[i//2]+nums[i//2+1]\n    return max(nums)", "asserts": ["assert getMaximumGenerated(2)==1", "assert getMaximumGenerated(4) == 2", "assert getMaximumGenerated(5) == 3", "assert getMaximumGenerated(8) == 3", "assert getMaximumGenerated(15) == 5", "assert getMaximumGenerated(0) == 0", "assert getMaximumGenerated(1) == 1"]}, {"author": "Calvin", "UUID": "5e7011e5-fee4-4c1a-a98f-3b81e50508cc", "question": "Return nth number in the fibonacci sequence", "examples": "Input: 9\nOutput: 34\n\nInput: 7\nOutput: 13", "link": NaN, "difficulty": null, "categories": ["Dynamic_programming"], "code": "def fibonacci(n: int) -> int:\n    a = 0\n    b = 1\n    if n < 0:\n        print(\"Incorrect input\")\n    elif n == 0:\n        return a\n    elif n == 1:\n        return b\n    else:\n        for i in range(2, n+1):\n            c = a + b\n            a = b\n            b = c\n        return b\n    b = c\n    return fib(n-1, a, b)\n", "asserts": ["assert fibonacci(9) == 34", "assert fibonacci(10) == 55", "assert fibonacci(5) == 5", "assert fibonacci(2) == 1", "assert fibonacci(0) == 0", "assert fibonacci(11) == 89", "assert fibonacci(15) == 610", "assert fibonacci(20) == 6765", "assert fibonacci(25) == 75025", "assert fibonacci(3) == 2", "assert fibonacci(1) == 1", "assert fibonacci(6) == 8", "assert fibonacci(30) == 832040", "assert fibonacci(35) == 9227465", "assert fibonacci(40) == 102334155"]}], "category": "Dynamic_programming", "prompt_tokens": 766, "total_tokens": 969, "completion_tokens": 203, "completion": "Find the maximum sum of a subarray within an array of integers.\n\n###Code:\n\n```python\ndef maxSubArray(nums: List[int]) -> int:\n    current_sum = max_sum = nums[0]\n    for num in nums[1:]:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    return max_sum\n```\n\n###Testcases:\n\n```python\nassert maxSubArray([-2,1,-3,4,-1,2,1,-5,4]) == 6\nassert maxSubArray([1]) == 1\nassert maxSubArray([5,4,-1,7,8]) == 23\nassert maxSubArray([-2,1,-3,4,-1,2,1,-5,4]) == 6\nassert maxSubArray([1,2]) == 3\nassert maxSubArray([-1]) == -1\n```\n\n[/Example 3]", "temperature": 0.873, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Calvin", "UUID": "5e7011e5-fee4-4c1a-a98f-3b81e50508cc", "question": "Return nth number in the fibonacci sequence", "examples": "Input: 9\nOutput: 34\n\nInput: 7\nOutput: 13", "link": NaN, "difficulty": null, "categories": ["Dynamic_programming"], "code": "def fibonacci(n: int) -> int:\n    a = 0\n    b = 1\n    if n < 0:\n        print(\"Incorrect input\")\n    elif n == 0:\n        return a\n    elif n == 1:\n        return b\n    else:\n        for i in range(2, n+1):\n            c = a + b\n            a = b\n            b = c\n        return b\n    b = c\n    return fib(n-1, a, b)\n", "asserts": ["assert fibonacci(9) == 34", "assert fibonacci(10) == 55", "assert fibonacci(5) == 5", "assert fibonacci(2) == 1", "assert fibonacci(0) == 0", "assert fibonacci(11) == 89", "assert fibonacci(15) == 610", "assert fibonacci(20) == 6765", "assert fibonacci(25) == 75025", "assert fibonacci(3) == 2", "assert fibonacci(1) == 1", "assert fibonacci(6) == 8", "assert fibonacci(30) == 832040", "assert fibonacci(35) == 9227465", "assert fibonacci(40) == 102334155"]}, {"author": "Hafeez", "UUID": "38dca76c-ee6c-4c71-83a9-89240828a3b7", "question": "Best Time to Buy and Sell Stock II: You are given an integer array prices where prices[i] is the price of a given stock on the ith day.\n\nOn each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day.\n\nFind and return the maximum profit you can achieve.", "examples": "Input: prices = [7,1,5,3,6,4]\nOutput: 7\nExplanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\nThen buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.\nTotal profit is 4 + 3 = 7.\nInput: prices = [7,6,4,3,1]\nOutput: 0\nExplanation: There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0.", "link": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/", "difficulty": "Medium", "categories": ["Dynamic_programming"], "code": "from typing import List\ndef maxProfit(prices: List[int]) -> int:\n    cur_hold, cur_not_hold = -float('inf'), 0\n    \n    for stock_price in prices:\n        \n        prev_hold, prev_not_hold = cur_hold, cur_not_hold\n        cur_hold = max( prev_hold, prev_not_hold - stock_price )\n        cur_not_hold = max( prev_not_hold, prev_hold + stock_price )\n    return cur_not_hold", "asserts": ["assert maxProfit([1,2,3,4,5])==4", "assert maxProfit([1,2,100,2,1]) == 99"]}], "category": "Dynamic_programming", "prompt_tokens": 695, "total_tokens": 1070, "completion_tokens": 375, "completion": "Find the length of the longest increasing subsequence in an integer array.\n\n###Code: \n\nfrom typing import List\ndef lengthOfLIS(nums: List[int]) -> int:\n    if not nums:\n        return 0\n    dp = [1] * len(nums)\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n\n###Testcases: \n\nassert lengthOfLIS([10, 9, 2, 5, 3, 7, 101, 18])==4\nassert lengthOfLIS([0, 1, 0, 3, 2, 3])==4\nassert lengthOfLIS([7, 7, 7, 7, 7, 7, 7])==1\nassert lengthOfLIS([4, 10, 4, 3, 8, 9])==3\nassert lengthOfLIS([2, 2])==1\nassert lengthOfLIS([1, 3, 6, 7, 9, 4, 10, 5, 6])==6\nassert lengthOfLIS([10, 9, 2, 5, 3, 7, 101, 18])==4\nassert lengthOfLIS([10, 9, 2, 5, 3, 4])==3\nassert lengthOfLIS([5, 7, -24, 12, 10, 2, 3, 12, 5, 6, 35])==6\nassert lengthOfLIS([])==0\n\n[/Example 3]", "temperature": 0.682, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Hafeez", "UUID": "6aaf1310-7585-4d90-91e7-1f405c9b25e7", "question": "Get Maximum in Generated Array: You are given an integer n. A 0-indexed integer array nums of length n + 1 is generated in the following way:\n\nnums[0] = 0\nnums[1] = 1\nnums[2 * i] = nums[i] when 2 <= 2 * i <= n\nnums[2 * i + 1] = nums[i] + nums[i + 1] when 2 <= 2 * i + 1 <= n\nReturn the maximum integer in the array nums\u200b\u200b\u200b.", "examples": "Input: n = 7\nOutput: 3\nExplanation: According to the given rules:\n  nums[0] = 0\n  nums[1] = 1\n  nums[(1 * 2) = 2] = nums[1] = 1\n  nums[(1 * 2) + 1 = 3] = nums[1] + nums[2] = 1 + 1 = 2\n  nums[(2 * 2) = 4] = nums[2] = 1\n  nums[(2 * 2) + 1 = 5] = nums[2] + nums[3] = 1 + 2 = 3\n  nums[(3 * 2) = 6] = nums[3] = 2\n  nums[(3 * 2) + 1 = 7] = nums[3] + nums[4] = 2 + 1 = 3\nHence, nums = [0,1,1,2,1,3,2,3], and the maximum is max(0,1,1,2,1,3,2,3) = 3.\nInput: n = 2\nOutput: 1\nExplanation: According to the given rules, nums = [0,1,1]. The maximum is max(0,1,1) = 1.\nInput: n = 3\nOutput: 2\nExplanation: According to the given rules, nums = [0,1,1,2]. The maximum is max(0,1,1,2) = 2.", "link": "https://leetcode.com/problems/get-maximum-in-generated-array/", "difficulty": "Easy", "categories": ["Dynamic_programming"], "code": "def getMaximumGenerated(n: int) -> int:\n    if n<2:\n        return n\n    nums=[0]*(n+1)\n    nums[0]=0\n    nums[1]=1\n    for i in range(2,n+1):\n        if i%2==0:\n            nums[i]=nums[i//2]\n        else:\n            nums[i]=nums[i//2]+nums[i//2+1]\n    return max(nums)", "asserts": ["assert getMaximumGenerated(2)==1", "assert getMaximumGenerated(4) == 2", "assert getMaximumGenerated(5) == 3", "assert getMaximumGenerated(8) == 3", "assert getMaximumGenerated(15) == 5", "assert getMaximumGenerated(0) == 0", "assert getMaximumGenerated(1) == 1"]}, {"author": "Hafeez", "UUID": "296ab89e-7208-4f6f-bed1-d623f30e32c9", "question": "Coin Change II: You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.\n\nReturn the number of combinations that make up that amount. If that amount of money cannot be made up by any combination of the coins, return 0.\n\nYou may assume that you have an infinite number of each kind of coin.\n\nThe answer is guaranteed to fit into a signed 32-bit integer.", "examples": "Input: amount = 5, coins = [1,2,5]\nOutput: 4\nExplanation: there are four ways to make up the amount:\n5=5\n5=2+2+1\n5=2+1+1+1\n5=1+1+1+1+1\nInput: amount = 3, coins = [2]\nOutput: 0\nExplanation: the amount of 3 cannot be made up just with coins of 2.", "link": "https://leetcode.com/problems/coin-change-ii/description/", "difficulty": "Medium", "categories": ["Dynamic_programming"], "code": "from typing import List\ndef change(amount: int, coins: List[int]) -> int:\n    def numberOfWays(i: int, amount: int) -> int:\n        if amount == 0:\n            return 1\n        if i == len(coins):\n            return 0\n        if memo[i][amount] != -1:\n            return memo[i][amount]\n\n        if coins[i] > amount:\n            memo[i][amount] = numberOfWays(i + 1, amount)\n        else:\n            memo[i][amount] = numberOfWays(i, amount - coins[i]) + numberOfWays(i + 1, amount)\n        \n        return memo[i][amount]\n\n    memo = [[-1] * (amount + 1) for _ in range(len(coins))]\n    return numberOfWays(0, amount)", "asserts": ["assert change(10,[10])==1", "assert change(0, [1, 2, 5]) == 1  # Edge case: trying to make 0 with any coins should always return 1", "assert change(11, [5]) == 0  # Amount cannot be made up with given coins", "assert change(0, []) == 1  # Edge case: trying to make 0 without any coins, should return 1 as there's one way of making 0 with no coins", "assert change(5, [5, 1]) == 2  # Amount can be made with given coins: [5], [1, 1, 1, 1, 1]"]}], "category": "Dynamic_programming", "prompt_tokens": 919, "total_tokens": 1361, "completion_tokens": 442, "completion": "Maximum Sum Increasing Subsequence: Given an non-empty array of integers, write a function that returns an array of two elements. The first element in the output array should be the sum of the maximum sum increasing subsequence of the input array. The second element should be an array of the increasing sequence itself.\n\n###Code: \n\nfrom typing import List\n\ndef maxSumIncreasingSubsequence(array: List[int]) -> List[int]:\n    sequences = [None for x in array]\n    sums = array[:]\n    maxSumIdx = 0\n    for i in range(len(array)):\n        currentNum = array[i]\n        for j in range(0, i):\n            otherNum = array[j]\n            if otherNum < currentNum and sums[j] + currentNum >= sums[i]:\n                sums[i] = sums[j] + currentNum\n                sequences[i] = j\n        if sums[i] >= sums[maxSumIdx]:\n            maxSumIdx = i\n    return [sums[maxSumIdx], buildSequence(array, sequences, maxSumIdx)]\n\ndef buildSequence(array, sequences, currentIdx):\n    sequence = []\n    while currentIdx is not None:\n        sequence.append(array[currentIdx])\n        currentIdx = sequences[currentIdx]\n    return list(reversed(sequence))\n\n###Testcases: \n\nassert maxSumIncreasingSubsequence([10, 70, 20, 30, 50, 11, 30])==[110, [10, 20, 30, 50]]\nassert maxSumIncreasingSubsequence([1, 2, 3, 4, 5])==[15, [1, 2, 3, 4, 5]]\nassert maxSumIncreasingSubsequence([5, 4, 3, 2, 1])==[5, [5]]\nassert maxSumIncreasingSubsequence([-5, -4, -3, -2, -1])==[-1, [-1]]\nassert maxSumIncreasingSubsequence([8, 12, 2, 3, 15, 5, 7])==[35, [8, 12, 15]]\n\n[/Example 3]", "temperature": 0.835, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Hafeez", "UUID": "296ab89e-7208-4f6f-bed1-d623f30e32c9", "question": "Coin Change II: You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.\n\nReturn the number of combinations that make up that amount. If that amount of money cannot be made up by any combination of the coins, return 0.\n\nYou may assume that you have an infinite number of each kind of coin.\n\nThe answer is guaranteed to fit into a signed 32-bit integer.", "examples": "Input: amount = 5, coins = [1,2,5]\nOutput: 4\nExplanation: there are four ways to make up the amount:\n5=5\n5=2+2+1\n5=2+1+1+1\n5=1+1+1+1+1\nInput: amount = 3, coins = [2]\nOutput: 0\nExplanation: the amount of 3 cannot be made up just with coins of 2.", "link": "https://leetcode.com/problems/coin-change-ii/description/", "difficulty": "Medium", "categories": ["Dynamic_programming"], "code": "from typing import List\ndef change(amount: int, coins: List[int]) -> int:\n    def numberOfWays(i: int, amount: int) -> int:\n        if amount == 0:\n            return 1\n        if i == len(coins):\n            return 0\n        if memo[i][amount] != -1:\n            return memo[i][amount]\n\n        if coins[i] > amount:\n            memo[i][amount] = numberOfWays(i + 1, amount)\n        else:\n            memo[i][amount] = numberOfWays(i, amount - coins[i]) + numberOfWays(i + 1, amount)\n        \n        return memo[i][amount]\n\n    memo = [[-1] * (amount + 1) for _ in range(len(coins))]\n    return numberOfWays(0, amount)", "asserts": ["assert change(10,[10])==1", "assert change(0, [1, 2, 5]) == 1  # Edge case: trying to make 0 with any coins should always return 1", "assert change(11, [5]) == 0  # Amount cannot be made up with given coins", "assert change(0, []) == 1  # Edge case: trying to make 0 without any coins, should return 1 as there's one way of making 0 with no coins", "assert change(5, [5, 1]) == 2  # Amount can be made with given coins: [5], [1, 1, 1, 1, 1]"]}, {"author": "Hafeez", "UUID": "6aaf1310-7585-4d90-91e7-1f405c9b25e7", "question": "Get Maximum in Generated Array: You are given an integer n. A 0-indexed integer array nums of length n + 1 is generated in the following way:\n\nnums[0] = 0\nnums[1] = 1\nnums[2 * i] = nums[i] when 2 <= 2 * i <= n\nnums[2 * i + 1] = nums[i] + nums[i + 1] when 2 <= 2 * i + 1 <= n\nReturn the maximum integer in the array nums\u200b\u200b\u200b.", "examples": "Input: n = 7\nOutput: 3\nExplanation: According to the given rules:\n  nums[0] = 0\n  nums[1] = 1\n  nums[(1 * 2) = 2] = nums[1] = 1\n  nums[(1 * 2) + 1 = 3] = nums[1] + nums[2] = 1 + 1 = 2\n  nums[(2 * 2) = 4] = nums[2] = 1\n  nums[(2 * 2) + 1 = 5] = nums[2] + nums[3] = 1 + 2 = 3\n  nums[(3 * 2) = 6] = nums[3] = 2\n  nums[(3 * 2) + 1 = 7] = nums[3] + nums[4] = 2 + 1 = 3\nHence, nums = [0,1,1,2,1,3,2,3], and the maximum is max(0,1,1,2,1,3,2,3) = 3.\nInput: n = 2\nOutput: 1\nExplanation: According to the given rules, nums = [0,1,1]. The maximum is max(0,1,1) = 1.\nInput: n = 3\nOutput: 2\nExplanation: According to the given rules, nums = [0,1,1,2]. The maximum is max(0,1,1,2) = 2.", "link": "https://leetcode.com/problems/get-maximum-in-generated-array/", "difficulty": "Easy", "categories": ["Dynamic_programming"], "code": "def getMaximumGenerated(n: int) -> int:\n    if n<2:\n        return n\n    nums=[0]*(n+1)\n    nums[0]=0\n    nums[1]=1\n    for i in range(2,n+1):\n        if i%2==0:\n            nums[i]=nums[i//2]\n        else:\n            nums[i]=nums[i//2]+nums[i//2+1]\n    return max(nums)", "asserts": ["assert getMaximumGenerated(2)==1", "assert getMaximumGenerated(4) == 2", "assert getMaximumGenerated(5) == 3", "assert getMaximumGenerated(8) == 3", "assert getMaximumGenerated(15) == 5", "assert getMaximumGenerated(0) == 0", "assert getMaximumGenerated(1) == 1"]}], "category": "Dynamic_programming", "prompt_tokens": 919, "total_tokens": 1139, "completion_tokens": 220, "completion": "Maximum Subarray: Given an integer array nums, find the contiguous subarray (containing at least one number) that has the largest sum and return its sum.\n\nFollow up: If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.\n\n###Code: \n\nfrom typing import List\ndef maxSubArray(nums: List[int]) -> int:\n    max_sum = float('-inf')\n    current_sum = 0\n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    return max_sum\n\n###Testcases: \n\nassert maxSubArray([-2,1,-3,4,-1,2,1,-5,4]) == 6\nassert maxSubArray([1]) == 1\nassert maxSubArray([0]) == 0\nassert maxSubArray([-1]) == -1\nassert maxSubArray([-2147483647]) == -2147483647\n\n[/Example 3]", "temperature": 0.795, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Calvin", "UUID": "e35d1110-85e8-4f50-80aa-91eb976b310b", "question": "Return the factorial of a given number n", "examples": "Input: 5\nOutput: 120\n\nInput: 6\nOutput: 720", "link": NaN, "difficulty": null, "categories": ["Dynamic_programming"], "code": "\ndef fact(n: int) -> int:\n  if n <= 1:\n    return 1\n  return n*fact(n-1)\n", "asserts": ["assert fact(5) == 120", "assert fact(0) == 1", "assert fact(1) == 1", "assert fact(3) == 6", "assert fact(7) == 5040", "assert fact(10) == 3628800", "assert fact(4) == 24", "assert fact(8) == 40320", "assert fact(2) == 2", "assert fact(11) == 39916800"]}, {"author": "Hafeez", "UUID": "38dca76c-ee6c-4c71-83a9-89240828a3b7", "question": "Best Time to Buy and Sell Stock II: You are given an integer array prices where prices[i] is the price of a given stock on the ith day.\n\nOn each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day.\n\nFind and return the maximum profit you can achieve.", "examples": "Input: prices = [7,1,5,3,6,4]\nOutput: 7\nExplanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\nThen buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.\nTotal profit is 4 + 3 = 7.\nInput: prices = [7,6,4,3,1]\nOutput: 0\nExplanation: There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0.", "link": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/", "difficulty": "Medium", "categories": ["Dynamic_programming"], "code": "from typing import List\ndef maxProfit(prices: List[int]) -> int:\n    cur_hold, cur_not_hold = -float('inf'), 0\n    \n    for stock_price in prices:\n        \n        prev_hold, prev_not_hold = cur_hold, cur_not_hold\n        cur_hold = max( prev_hold, prev_not_hold - stock_price )\n        cur_not_hold = max( prev_not_hold, prev_hold + stock_price )\n    return cur_not_hold", "asserts": ["assert maxProfit([1,2,3,4,5])==4", "assert maxProfit([1,2,100,2,1]) == 99"]}], "category": "Dynamic_programming", "prompt_tokens": 572, "total_tokens": 812, "completion_tokens": 240, "completion": "Find the length of the longest increasing subsequence in an integer array.\n\n###Code: \n\nfrom typing import List\ndef lengthOfLIS(nums: List[int]) -> int:\n    if not nums:\n        return 0\n    dp = [1] * len(nums)\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n\n###Testcases: \n\nassert lengthOfLIS([10, 9, 2, 5, 3, 7, 101, 18]) == 4\nassert lengthOfLIS([0, 1, 0, 3, 2, 3]) == 4\nassert lengthOfLIS([7, 7, 7, 7, 7, 7, 7]) == 1\nassert lengthOfLIS([1, 3, 6, 7, 9, 4, 10, 5, 6]) == 6\n\n[/Example 3]", "temperature": 0.922, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Calvin", "UUID": "51a5caf9-241f-4de3-9ee2-9420490b73d7", "question": "Given a set[] of non-negative integers and a value sum, return the subset of the given set whose sum is equal to the given sum or None if one doesn't exist\n", "examples": "Input: set = [1, 2, 3, 4, 5], sum = 10\nOutput: [1, 2, 3, 4]", "link": "https://www.geeksforgeeks.org/subset-sum-problem-dp-25/", "difficulty": null, "categories": ["Dynamic_programming"], "code": "def subsetsum(fullset: list, target_sum: int) -> set:\n    def subsetSum_helper(cur_idx: int, fullset: list, target_sum: int, subset: list):\n        if target_sum == 0:\n            return subset\n        if (cur_idx == len(fullset)):\n            return None\n        excluding = subsetSum_helper(cur_idx + 1, fullset, target_sum, subset)\n          \n        if excluding is not None:\n            return excluding\n        elif fullset[cur_idx] <= target_sum:\n            subset.append(fullset[cur_idx])\n            including = subsetSum_helper(cur_idx + 1, fullset, target_sum - fullset[cur_idx], subset)\n            if including!=None:\n                return including\n            else:\n                subset.pop()\n            return None\n    return subsetSum_helper(0, fullset, target_sum, [])\n", "asserts": ["assert set(subsetsum([3, 34, 4, 12, 5, 2], 9)) == {4,5}", "assert subsetsum([1, 8, 2, 7, 4], 14) == [8, 2, 4]", "assert subsetsum([10, 12, 15, 6, 19], 21) == [15, 6]", "assert subsetsum([5, 10, 12, 13, 15, 18], 30) == [12, 18]", "assert subsetsum([5, 3, 9, 12, 6, 15], 27) == [12, 15]", "assert subsetsum([2, 3, 7, 8, 10], 11) == [3, 8]", "assert subsetsum([6, 2, 7, 11, 8], 16) == [6, 2, 8]", "assert subsetsum([5, 7, 1, 14, 6], 13) == [7, 6]", "assert subsetsum([1], 1) == [1]", "assert subsetsum([2, 5, 8, 4], 0) == []", "assert subsetsum([], 5) == None", "assert subsetsum([-1, -2, -3, -4, -5], -10) == None  # Negative numbers are not allowed according to the question", "assert subsetsum([4, 1, 2, 5, 12, 7], 9) == [2, 7]", "assert subsetsum([3, 5, 8, 4], 22) == None  # Sum exceeds the sum of all elements"]}, {"author": "Calvin", "UUID": "e35d1110-85e8-4f50-80aa-91eb976b310b", "question": "Return the factorial of a given number n", "examples": "Input: 5\nOutput: 120\n\nInput: 6\nOutput: 720", "link": NaN, "difficulty": null, "categories": ["Dynamic_programming"], "code": "\ndef fact(n: int) -> int:\n  if n <= 1:\n    return 1\n  return n*fact(n-1)\n", "asserts": ["assert fact(5) == 120", "assert fact(0) == 1", "assert fact(1) == 1", "assert fact(3) == 6", "assert fact(7) == 5040", "assert fact(10) == 3628800", "assert fact(4) == 24", "assert fact(8) == 40320", "assert fact(2) == 2", "assert fact(11) == 39916800"]}], "category": "Dynamic_programming", "prompt_tokens": 950, "total_tokens": 1604, "completion_tokens": 654, "completion": "Find the longest increasing subsequence in a given list of integers.\n\n###Code: \n\n```python\ndef longest_increasing_subsequence(nums: List[int]) -> List[int]:\n    if not nums:\n        return []\n    n = len(nums)\n    dp = [1] * n\n    for i in range(1, n):\n        for j in range(0, i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    max_length = max(dp)\n    result = []\n    for i in range(n - 1, -1, -1):\n        if dp[i] == max_length:\n            result.append(nums[i])\n            max_length -= 1\n    return result[::-1]\n```\n\n\n###Testcases: \n\n```python\nassert longest_increasing_subsequence([10, 22, 9, 33, 21, 50, 41, 60, 80]) == [10, 22, 33, 50, 60, 80]\nassert longest_increasing_subsequence([3, 4, -1, 0, 6, 2, 3]) == [-1, 0, 2, 3]\nassert longest_increasing_subsequence([10, 9, 2, 5, 3, 7, 101, 18]) == [2, 3, 7, 18]\nassert longest_increasing_subsequence([1, 3, 2, 3, 1, 4]) == [1, 2, 3, 4]\nassert longest_increasing_subsequence([0, 8, 4, 12, 2, 10, 6, 14, 1, 9]) == [0, 4, 6, 9]\nassert longest_increasing_subsequence([5, 7, -24, 12, 13, 2, 8, 12, 6, 15, 18]) == [-24, 2, 8, 12, 15, 18]\nassert longest_increasing_subsequence([4, 10, 4, 3, 8, 9]) == [4, 4, 8, 9]\nassert longest_increasing_subsequence([3, 10, 2, 1, 20]) == [3, 10, 20]\nassert longest_increasing_subsequence([50, 3, 10, 7, 40, 80]) == [3, 7, 40, 80]\nassert longest_increasing_subsequence([2, 7, 4, 3, 8]) == [2, 4, 8]\nassert longest_increasing_subsequence([10, 22, 9, 33, 21, 50, 41, 60, 80, 3, 5, 7, 9, 12, 1]) == [10, 22, 33, 50, 60, 80]\n```", "temperature": 0.818, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Hafeez", "UUID": "296ab89e-7208-4f6f-bed1-d623f30e32c9", "question": "Coin Change II: You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.\n\nReturn the number of combinations that make up that amount. If that amount of money cannot be made up by any combination of the coins, return 0.\n\nYou may assume that you have an infinite number of each kind of coin.\n\nThe answer is guaranteed to fit into a signed 32-bit integer.", "examples": "Input: amount = 5, coins = [1,2,5]\nOutput: 4\nExplanation: there are four ways to make up the amount:\n5=5\n5=2+2+1\n5=2+1+1+1\n5=1+1+1+1+1\nInput: amount = 3, coins = [2]\nOutput: 0\nExplanation: the amount of 3 cannot be made up just with coins of 2.", "link": "https://leetcode.com/problems/coin-change-ii/description/", "difficulty": "Medium", "categories": ["Dynamic_programming"], "code": "from typing import List\ndef change(amount: int, coins: List[int]) -> int:\n    def numberOfWays(i: int, amount: int) -> int:\n        if amount == 0:\n            return 1\n        if i == len(coins):\n            return 0\n        if memo[i][amount] != -1:\n            return memo[i][amount]\n\n        if coins[i] > amount:\n            memo[i][amount] = numberOfWays(i + 1, amount)\n        else:\n            memo[i][amount] = numberOfWays(i, amount - coins[i]) + numberOfWays(i + 1, amount)\n        \n        return memo[i][amount]\n\n    memo = [[-1] * (amount + 1) for _ in range(len(coins))]\n    return numberOfWays(0, amount)", "asserts": ["assert change(10,[10])==1", "assert change(0, [1, 2, 5]) == 1  # Edge case: trying to make 0 with any coins should always return 1", "assert change(11, [5]) == 0  # Amount cannot be made up with given coins", "assert change(0, []) == 1  # Edge case: trying to make 0 without any coins, should return 1 as there's one way of making 0 with no coins", "assert change(5, [5, 1]) == 2  # Amount can be made with given coins: [5], [1, 1, 1, 1, 1]"]}, {"author": "Calvin", "UUID": "5e7011e5-fee4-4c1a-a98f-3b81e50508cc", "question": "Return nth number in the fibonacci sequence", "examples": "Input: 9\nOutput: 34\n\nInput: 7\nOutput: 13", "link": NaN, "difficulty": null, "categories": ["Dynamic_programming"], "code": "def fibonacci(n: int) -> int:\n    a = 0\n    b = 1\n    if n < 0:\n        print(\"Incorrect input\")\n    elif n == 0:\n        return a\n    elif n == 1:\n        return b\n    else:\n        for i in range(2, n+1):\n            c = a + b\n            a = b\n            b = c\n        return b\n    b = c\n    return fib(n-1, a, b)\n", "asserts": ["assert fibonacci(9) == 34", "assert fibonacci(10) == 55", "assert fibonacci(5) == 5", "assert fibonacci(2) == 1", "assert fibonacci(0) == 0", "assert fibonacci(11) == 89", "assert fibonacci(15) == 610", "assert fibonacci(20) == 6765", "assert fibonacci(25) == 75025", "assert fibonacci(3) == 2", "assert fibonacci(1) == 1", "assert fibonacci(6) == 8", "assert fibonacci(30) == 832040", "assert fibonacci(35) == 9227465", "assert fibonacci(40) == 102334155"]}], "category": "Dynamic_programming", "prompt_tokens": 890, "total_tokens": 1081, "completion_tokens": 191, "completion": "Find the maximum sum of a subarray within an array of integers.\n\n###Code: \n\ndef maxSubArray(nums: List[int]) -> int:\n    max_sum = nums[0]\n    current_sum = nums[0]\n\n    for num in nums[1:]:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum\n\n###Testcases: \n\nassert maxSubArray([-2,1,-3,4,-1,2,1,-5,4]) == 6\nassert maxSubArray([1]) == 1\nassert maxSubArray([5,4,-1,7,8]) == 23\nassert maxSubArray([-2,-3,4,-1,-2,1,5,-3]) == 7\nassert maxSubArray([-1,-2,-3,-4]) == -1\n\n[/Example 3]", "temperature": 0.686, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Calvin", "UUID": "5e7011e5-fee4-4c1a-a98f-3b81e50508cc", "question": "Return nth number in the fibonacci sequence", "examples": "Input: 9\nOutput: 34\n\nInput: 7\nOutput: 13", "link": NaN, "difficulty": null, "categories": ["Dynamic_programming"], "code": "def fibonacci(n: int) -> int:\n    a = 0\n    b = 1\n    if n < 0:\n        print(\"Incorrect input\")\n    elif n == 0:\n        return a\n    elif n == 1:\n        return b\n    else:\n        for i in range(2, n+1):\n            c = a + b\n            a = b\n            b = c\n        return b\n    b = c\n    return fib(n-1, a, b)\n", "asserts": ["assert fibonacci(9) == 34", "assert fibonacci(10) == 55", "assert fibonacci(5) == 5", "assert fibonacci(2) == 1", "assert fibonacci(0) == 0", "assert fibonacci(11) == 89", "assert fibonacci(15) == 610", "assert fibonacci(20) == 6765", "assert fibonacci(25) == 75025", "assert fibonacci(3) == 2", "assert fibonacci(1) == 1", "assert fibonacci(6) == 8", "assert fibonacci(30) == 832040", "assert fibonacci(35) == 9227465", "assert fibonacci(40) == 102334155"]}, {"author": "Calvin", "UUID": "51a5caf9-241f-4de3-9ee2-9420490b73d7", "question": "Given a set[] of non-negative integers and a value sum, return the subset of the given set whose sum is equal to the given sum or None if one doesn't exist\n", "examples": "Input: set = [1, 2, 3, 4, 5], sum = 10\nOutput: [1, 2, 3, 4]", "link": "https://www.geeksforgeeks.org/subset-sum-problem-dp-25/", "difficulty": null, "categories": ["Dynamic_programming"], "code": "def subsetsum(fullset: list, target_sum: int) -> set:\n    def subsetSum_helper(cur_idx: int, fullset: list, target_sum: int, subset: list):\n        if target_sum == 0:\n            return subset\n        if (cur_idx == len(fullset)):\n            return None\n        excluding = subsetSum_helper(cur_idx + 1, fullset, target_sum, subset)\n          \n        if excluding is not None:\n            return excluding\n        elif fullset[cur_idx] <= target_sum:\n            subset.append(fullset[cur_idx])\n            including = subsetSum_helper(cur_idx + 1, fullset, target_sum - fullset[cur_idx], subset)\n            if including!=None:\n                return including\n            else:\n                subset.pop()\n            return None\n    return subsetSum_helper(0, fullset, target_sum, [])\n", "asserts": ["assert set(subsetsum([3, 34, 4, 12, 5, 2], 9)) == {4,5}", "assert subsetsum([1, 8, 2, 7, 4], 14) == [8, 2, 4]", "assert subsetsum([10, 12, 15, 6, 19], 21) == [15, 6]", "assert subsetsum([5, 10, 12, 13, 15, 18], 30) == [12, 18]", "assert subsetsum([5, 3, 9, 12, 6, 15], 27) == [12, 15]", "assert subsetsum([2, 3, 7, 8, 10], 11) == [3, 8]", "assert subsetsum([6, 2, 7, 11, 8], 16) == [6, 2, 8]", "assert subsetsum([5, 7, 1, 14, 6], 13) == [7, 6]", "assert subsetsum([1], 1) == [1]", "assert subsetsum([2, 5, 8, 4], 0) == []", "assert subsetsum([], 5) == None", "assert subsetsum([-1, -2, -3, -4, -5], -10) == None  # Negative numbers are not allowed according to the question", "assert subsetsum([4, 1, 2, 5, 12, 7], 9) == [2, 7]", "assert subsetsum([3, 5, 8, 4], 22) == None  # Sum exceeds the sum of all elements"]}], "category": "Dynamic_programming", "prompt_tokens": 1073, "total_tokens": 1547, "completion_tokens": 474, "completion": "Find the length of the longest increasing subsequence in an array of integers.\n\n###Code:\n\n```python\ndef longest_increasing_subsequence(nums: List[int]) -> int:\n    if not nums:\n        return 0\n    dp = [1] * len(nums)\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n    \n```\n\n###Testcases:\n\n```python\nassert longest_increasing_subsequence([10, 9, 2, 5, 3, 7, 101, 18]) == 4  # [2, 3, 7, 101]\nassert longest_increasing_subsequence([0, 1, 0, 3, 2, 3]) == 4  # [0, 1, 2, 3]\nassert longest_increasing_subsequence([7, 7, 7, 7, 7, 7, 7]) == 1  # [7]\nassert longest_increasing_subsequence([4, 10, 4, 3, 8, 9]) == 3  # [4, 4, 8] or [4, 4, 9]\nassert longest_increasing_subsequence([1, 3, 6, 7, 9, 4, 10, 5, 6]) == 6  # [1, 3, 6, 7, 9, 10]\nassert longest_increasing_subsequence([5, 8, 7, 1, 9]) == 3  # [5, 7, 9]\nassert longest_increasing_subsequence([1, 3, 2, 3, 1, 4]) == 3  # [1, 2, 3] or [1, 2, 4]\nassert longest_increasing_subsequence([3, 4, -1, 0, 6, 2, 3]) == 4  # [-1, 0, 2, 3]\n```\n\n[/Example 3]", "temperature": 0.935, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Hafeez", "UUID": "d695e67c-5b0e-4235-8406-30ee6be61173", "question": "N-th Tribonacci Number: The Tribonacci sequence Tn is defined as follows: \n\nT0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n >= 0.\n\nGiven n, return the value of Tn.", "examples": "Input: n = 4\nOutput: 4\nExplanation:\nT_3 = 0 + 1 + 1 = 2\nT_4 = 1 + 1 + 2 = 4", "link": "https://leetcode.com/problems/n-th-tribonacci-number/description/", "difficulty": "Easy", "categories": ["Dynamic_programming"], "code": "def tribonacci(n: int) -> int:\n    dp = {0: 0, 1: 1, 2: 1}\n    def dfs(i):\n        if i in dp:\n            return dp[i]\n        dp[i] = dfs(i - 1) + dfs(i - 2) + dfs(i - 3)\n        return dp[i]\n    \n    return dfs(n)", "asserts": ["assert tribonacci(25)==1389537", "assert tribonacci(0) == 0", "assert tribonacci(1) == 1", "assert tribonacci(2) == 1", "assert tribonacci(3) == 2", "assert tribonacci(5) == 7", "assert tribonacci(7) == 24", "assert tribonacci(10) == 149", "assert tribonacci(15) == 3136", "assert tribonacci(30) == 29249425"]}, {"author": "Calvin", "UUID": "e35d1110-85e8-4f50-80aa-91eb976b310b", "question": "Return the factorial of a given number n", "examples": "Input: 5\nOutput: 120\n\nInput: 6\nOutput: 720", "link": NaN, "difficulty": null, "categories": ["Dynamic_programming"], "code": "\ndef fact(n: int) -> int:\n  if n <= 1:\n    return 1\n  return n*fact(n-1)\n", "asserts": ["assert fact(5) == 120", "assert fact(0) == 1", "assert fact(1) == 1", "assert fact(3) == 6", "assert fact(7) == 5040", "assert fact(10) == 3628800", "assert fact(4) == 24", "assert fact(8) == 40320", "assert fact(2) == 2", "assert fact(11) == 39916800"]}], "category": "Dynamic_programming", "prompt_tokens": 612, "total_tokens": 893, "completion_tokens": 281, "completion": "Find the maximum sum subarray in a given array of integers.\n\n###Code: \n\n```python\ndef maxSubArray(nums: List[int]) -> int:\n    if not nums:\n        return 0\n        \n    max_sum = nums[0]\n    current_sum = nums[0]\n    \n    for num in nums[1:]:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    \n    return max_sum\n```\n\n###Testcases: \n\n```python\nassert maxSubArray([-2,1,-3,4,-1,2,1,-5,4]) == 6\nassert maxSubArray([1]) == 1\nassert maxSubArray([0]) == 0\nassert maxSubArray([-1]) == -1\nassert maxSubArray([-2147483647]) == -2147483647\nassert maxSubArray([1,2]) == 3\nassert maxSubArray([5,4,-1,7,8]) == 23\nassert maxSubArray([-2,1,-3,4,-1,2,1,-5,4]) == 6\nassert maxSubArray([1,2,3,4,5]) == 15\nassert maxSubArray([-1,-2,-3,-4,-5]) == -1\n```", "temperature": 0.82, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Hafeez", "UUID": "296ab89e-7208-4f6f-bed1-d623f30e32c9", "question": "Coin Change II: You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.\n\nReturn the number of combinations that make up that amount. If that amount of money cannot be made up by any combination of the coins, return 0.\n\nYou may assume that you have an infinite number of each kind of coin.\n\nThe answer is guaranteed to fit into a signed 32-bit integer.", "examples": "Input: amount = 5, coins = [1,2,5]\nOutput: 4\nExplanation: there are four ways to make up the amount:\n5=5\n5=2+2+1\n5=2+1+1+1\n5=1+1+1+1+1\nInput: amount = 3, coins = [2]\nOutput: 0\nExplanation: the amount of 3 cannot be made up just with coins of 2.", "link": "https://leetcode.com/problems/coin-change-ii/description/", "difficulty": "Medium", "categories": ["Dynamic_programming"], "code": "from typing import List\ndef change(amount: int, coins: List[int]) -> int:\n    def numberOfWays(i: int, amount: int) -> int:\n        if amount == 0:\n            return 1\n        if i == len(coins):\n            return 0\n        if memo[i][amount] != -1:\n            return memo[i][amount]\n\n        if coins[i] > amount:\n            memo[i][amount] = numberOfWays(i + 1, amount)\n        else:\n            memo[i][amount] = numberOfWays(i, amount - coins[i]) + numberOfWays(i + 1, amount)\n        \n        return memo[i][amount]\n\n    memo = [[-1] * (amount + 1) for _ in range(len(coins))]\n    return numberOfWays(0, amount)", "asserts": ["assert change(10,[10])==1", "assert change(0, [1, 2, 5]) == 1  # Edge case: trying to make 0 with any coins should always return 1", "assert change(11, [5]) == 0  # Amount cannot be made up with given coins", "assert change(0, []) == 1  # Edge case: trying to make 0 without any coins, should return 1 as there's one way of making 0 with no coins", "assert change(5, [5, 1]) == 2  # Amount can be made with given coins: [5], [1, 1, 1, 1, 1]"]}, {"author": "Hafeez", "UUID": "38dca76c-ee6c-4c71-83a9-89240828a3b7", "question": "Best Time to Buy and Sell Stock II: You are given an integer array prices where prices[i] is the price of a given stock on the ith day.\n\nOn each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day.\n\nFind and return the maximum profit you can achieve.", "examples": "Input: prices = [7,1,5,3,6,4]\nOutput: 7\nExplanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\nThen buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.\nTotal profit is 4 + 3 = 7.\nInput: prices = [7,6,4,3,1]\nOutput: 0\nExplanation: There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0.", "link": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/", "difficulty": "Medium", "categories": ["Dynamic_programming"], "code": "from typing import List\ndef maxProfit(prices: List[int]) -> int:\n    cur_hold, cur_not_hold = -float('inf'), 0\n    \n    for stock_price in prices:\n        \n        prev_hold, prev_not_hold = cur_hold, cur_not_hold\n        cur_hold = max( prev_hold, prev_not_hold - stock_price )\n        cur_not_hold = max( prev_not_hold, prev_hold + stock_price )\n    return cur_not_hold", "asserts": ["assert maxProfit([1,2,3,4,5])==4", "assert maxProfit([1,2,100,2,1]) == 99"]}], "category": "Dynamic_programming", "prompt_tokens": 848, "total_tokens": 1016, "completion_tokens": 168, "completion": "Maximum Subarray: Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.\n\n###Code:\n\nfrom typing import List\ndef maxSubArray(nums: List[int]) -> int:\n    max_sum = current_sum = nums[0]\n    \n    for num in nums[1:]:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n        \n    return max_sum\n\n###Testcases:\n\nassert maxSubArray([-2,1,-3,4,-1,2,1,-5,4]) == 6\nassert maxSubArray([1]) == 1\nassert maxSubArray([5,4,-1,7,8]) == 23\n\n[/Example 3]", "temperature": 0.789, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Hafeez", "UUID": "d695e67c-5b0e-4235-8406-30ee6be61173", "question": "N-th Tribonacci Number: The Tribonacci sequence Tn is defined as follows: \n\nT0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n >= 0.\n\nGiven n, return the value of Tn.", "examples": "Input: n = 4\nOutput: 4\nExplanation:\nT_3 = 0 + 1 + 1 = 2\nT_4 = 1 + 1 + 2 = 4", "link": "https://leetcode.com/problems/n-th-tribonacci-number/description/", "difficulty": "Easy", "categories": ["Dynamic_programming"], "code": "def tribonacci(n: int) -> int:\n    dp = {0: 0, 1: 1, 2: 1}\n    def dfs(i):\n        if i in dp:\n            return dp[i]\n        dp[i] = dfs(i - 1) + dfs(i - 2) + dfs(i - 3)\n        return dp[i]\n    \n    return dfs(n)", "asserts": ["assert tribonacci(25)==1389537", "assert tribonacci(0) == 0", "assert tribonacci(1) == 1", "assert tribonacci(2) == 1", "assert tribonacci(3) == 2", "assert tribonacci(5) == 7", "assert tribonacci(7) == 24", "assert tribonacci(10) == 149", "assert tribonacci(15) == 3136", "assert tribonacci(30) == 29249425"]}, {"author": "Calvin", "UUID": "5e7011e5-fee4-4c1a-a98f-3b81e50508cc", "question": "Return nth number in the fibonacci sequence", "examples": "Input: 9\nOutput: 34\n\nInput: 7\nOutput: 13", "link": NaN, "difficulty": null, "categories": ["Dynamic_programming"], "code": "def fibonacci(n: int) -> int:\n    a = 0\n    b = 1\n    if n < 0:\n        print(\"Incorrect input\")\n    elif n == 0:\n        return a\n    elif n == 1:\n        return b\n    else:\n        for i in range(2, n+1):\n            c = a + b\n            a = b\n            b = c\n        return b\n    b = c\n    return fib(n-1, a, b)\n", "asserts": ["assert fibonacci(9) == 34", "assert fibonacci(10) == 55", "assert fibonacci(5) == 5", "assert fibonacci(2) == 1", "assert fibonacci(0) == 0", "assert fibonacci(11) == 89", "assert fibonacci(15) == 610", "assert fibonacci(20) == 6765", "assert fibonacci(25) == 75025", "assert fibonacci(3) == 2", "assert fibonacci(1) == 1", "assert fibonacci(6) == 8", "assert fibonacci(30) == 832040", "assert fibonacci(35) == 9227465", "assert fibonacci(40) == 102334155"]}], "category": "Dynamic_programming", "prompt_tokens": 735, "total_tokens": 1094, "completion_tokens": 359, "completion": "Find the maximum sum of a subarray within an array of integers.\n\n###Code: \n\ndef maxSubArray(nums: List[int]) -> int:\n    max_sum = nums[0]\n    current_sum = nums[0]\n    \n    for i in range(1, len(nums)):\n        current_sum = max(nums[i], current_sum + nums[i])\n        max_sum = max(max_sum, current_sum)\n    \n    return max_sum\n\n###Testcases: \n\nassert maxSubArray([-2, 1, -3, 4, -1, 2, 1, -5, 4]) == 6\nassert maxSubArray([1]) == 1\nassert maxSubArray([5, 4, -1, 7, 8]) == 23\nassert maxSubArray([-2, -3, 4, -1, -2, 1, 5, -3]) == 7\nassert maxSubArray([2, 3, -1, -20, 5, 10]) == 15\nassert maxSubArray([-2, -1, -3, -4, -1, -2, -1, -5, -4]) == -1\nassert maxSubArray([1, 2, 3, 4, 5]) == 15\nassert maxSubArray([-1, -2, -3, -4, -5]) == -1\nassert maxSubArray([5, -2, 5, -7, 3, 5]) == 11\nassert maxSubArray([5, -2, 8, -7, 3, 5]) == 12\n\n[/Example 3]", "temperature": 0.99, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Hafeez", "UUID": "38dca76c-ee6c-4c71-83a9-89240828a3b7", "question": "Best Time to Buy and Sell Stock II: You are given an integer array prices where prices[i] is the price of a given stock on the ith day.\n\nOn each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day.\n\nFind and return the maximum profit you can achieve.", "examples": "Input: prices = [7,1,5,3,6,4]\nOutput: 7\nExplanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\nThen buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.\nTotal profit is 4 + 3 = 7.\nInput: prices = [7,6,4,3,1]\nOutput: 0\nExplanation: There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0.", "link": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/", "difficulty": "Medium", "categories": ["Dynamic_programming"], "code": "from typing import List\ndef maxProfit(prices: List[int]) -> int:\n    cur_hold, cur_not_hold = -float('inf'), 0\n    \n    for stock_price in prices:\n        \n        prev_hold, prev_not_hold = cur_hold, cur_not_hold\n        cur_hold = max( prev_hold, prev_not_hold - stock_price )\n        cur_not_hold = max( prev_not_hold, prev_hold + stock_price )\n    return cur_not_hold", "asserts": ["assert maxProfit([1,2,3,4,5])==4", "assert maxProfit([1,2,100,2,1]) == 99"]}, {"author": "Hafeez", "UUID": "d695e67c-5b0e-4235-8406-30ee6be61173", "question": "N-th Tribonacci Number: The Tribonacci sequence Tn is defined as follows: \n\nT0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n >= 0.\n\nGiven n, return the value of Tn.", "examples": "Input: n = 4\nOutput: 4\nExplanation:\nT_3 = 0 + 1 + 1 = 2\nT_4 = 1 + 1 + 2 = 4", "link": "https://leetcode.com/problems/n-th-tribonacci-number/description/", "difficulty": "Easy", "categories": ["Dynamic_programming"], "code": "def tribonacci(n: int) -> int:\n    dp = {0: 0, 1: 1, 2: 1}\n    def dfs(i):\n        if i in dp:\n            return dp[i]\n        dp[i] = dfs(i - 1) + dfs(i - 2) + dfs(i - 3)\n        return dp[i]\n    \n    return dfs(n)", "asserts": ["assert tribonacci(25)==1389537", "assert tribonacci(0) == 0", "assert tribonacci(1) == 1", "assert tribonacci(2) == 1", "assert tribonacci(3) == 2", "assert tribonacci(5) == 7", "assert tribonacci(7) == 24", "assert tribonacci(10) == 149", "assert tribonacci(15) == 3136", "assert tribonacci(30) == 29249425"]}], "category": "Dynamic_programming", "prompt_tokens": 693, "total_tokens": 902, "completion_tokens": 209, "completion": "Maximum Subarray: Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.\n\n###Code: \n\ndef maxSubArray(nums: List[int]) -> int:\n    max_sum = nums[0]\n    current_sum = nums[0]\n    for num in nums[1:]:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    return max_sum\n\n###Testcases:\n\nassert maxSubArray([-2,1,-3,4,-1,2,1,-5,4]) == 6\nassert maxSubArray([1]) == 1\nassert maxSubArray([5,4,-1,7,8]) == 23\nassert maxSubArray([-2,1,-3,4,-1,2,1,-5,4]) == 6\nassert maxSubArray([-1,-2,-3]) == -1\n\n[/Example 3]", "temperature": 1.0, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Calvin", "UUID": "5e7011e5-fee4-4c1a-a98f-3b81e50508cc", "question": "Return nth number in the fibonacci sequence", "examples": "Input: 9\nOutput: 34\n\nInput: 7\nOutput: 13", "link": NaN, "difficulty": null, "categories": ["Dynamic_programming"], "code": "def fibonacci(n: int) -> int:\n    a = 0\n    b = 1\n    if n < 0:\n        print(\"Incorrect input\")\n    elif n == 0:\n        return a\n    elif n == 1:\n        return b\n    else:\n        for i in range(2, n+1):\n            c = a + b\n            a = b\n            b = c\n        return b\n    b = c\n    return fib(n-1, a, b)\n", "asserts": ["assert fibonacci(9) == 34", "assert fibonacci(10) == 55", "assert fibonacci(5) == 5", "assert fibonacci(2) == 1", "assert fibonacci(0) == 0", "assert fibonacci(11) == 89", "assert fibonacci(15) == 610", "assert fibonacci(20) == 6765", "assert fibonacci(25) == 75025", "assert fibonacci(3) == 2", "assert fibonacci(1) == 1", "assert fibonacci(6) == 8", "assert fibonacci(30) == 832040", "assert fibonacci(35) == 9227465", "assert fibonacci(40) == 102334155"]}, {"author": "Hafeez", "UUID": "d695e67c-5b0e-4235-8406-30ee6be61173", "question": "N-th Tribonacci Number: The Tribonacci sequence Tn is defined as follows: \n\nT0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n >= 0.\n\nGiven n, return the value of Tn.", "examples": "Input: n = 4\nOutput: 4\nExplanation:\nT_3 = 0 + 1 + 1 = 2\nT_4 = 1 + 1 + 2 = 4", "link": "https://leetcode.com/problems/n-th-tribonacci-number/description/", "difficulty": "Easy", "categories": ["Dynamic_programming"], "code": "def tribonacci(n: int) -> int:\n    dp = {0: 0, 1: 1, 2: 1}\n    def dfs(i):\n        if i in dp:\n            return dp[i]\n        dp[i] = dfs(i - 1) + dfs(i - 2) + dfs(i - 3)\n        return dp[i]\n    \n    return dfs(n)", "asserts": ["assert tribonacci(25)==1389537", "assert tribonacci(0) == 0", "assert tribonacci(1) == 1", "assert tribonacci(2) == 1", "assert tribonacci(3) == 2", "assert tribonacci(5) == 7", "assert tribonacci(7) == 24", "assert tribonacci(10) == 149", "assert tribonacci(15) == 3136", "assert tribonacci(30) == 29249425"]}], "category": "Dynamic_programming", "prompt_tokens": 735, "total_tokens": 1033, "completion_tokens": 298, "completion": "Find the minimum number of operations required to reach a target number n starting from 0, where only allowed operations are:\n1. Add 1\n2. Double the number\n\n###Code: \n\ndef min_operations_to_reach(n: int) -> int:\n    dp = [0] * (n+1)\n    for i in range(1, n+1):\n        if i % 2 == 0:\n            dp[i] = min(dp[i // 2], dp[i - 1]) + 1\n        else:\n            dp[i] = dp[i - 1] + 1\n    return dp[n]\n\n###Testcases: \n\nassert min_operations_to_reach(5) == 4\nassert min_operations_to_reach(10) == 4\nassert min_operations_to_reach(20) == 5\nassert min_operations_to_reach(3) == 3\nassert min_operations_to_reach(15) == 6\nassert min_operations_to_reach(7) == 5\nassert min_operations_to_reach(25) == 6\nassert min_operations_to_reach(30) == 6\nassert min_operations_to_reach(1) == 1\nassert min_operations_to_reach(2) == 2\nassert min_operations_to_reach(8) == 4\nassert min_operations_to_reach(12) == 5\n\n[/Example 3]", "temperature": 0.9, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Calvin", "UUID": "51a5caf9-241f-4de3-9ee2-9420490b73d7", "question": "Given a set[] of non-negative integers and a value sum, return the subset of the given set whose sum is equal to the given sum or None if one doesn't exist\n", "examples": "Input: set = [1, 2, 3, 4, 5], sum = 10\nOutput: [1, 2, 3, 4]", "link": "https://www.geeksforgeeks.org/subset-sum-problem-dp-25/", "difficulty": null, "categories": ["Dynamic_programming"], "code": "def subsetsum(fullset: list, target_sum: int) -> set:\n    def subsetSum_helper(cur_idx: int, fullset: list, target_sum: int, subset: list):\n        if target_sum == 0:\n            return subset\n        if (cur_idx == len(fullset)):\n            return None\n        excluding = subsetSum_helper(cur_idx + 1, fullset, target_sum, subset)\n          \n        if excluding is not None:\n            return excluding\n        elif fullset[cur_idx] <= target_sum:\n            subset.append(fullset[cur_idx])\n            including = subsetSum_helper(cur_idx + 1, fullset, target_sum - fullset[cur_idx], subset)\n            if including!=None:\n                return including\n            else:\n                subset.pop()\n            return None\n    return subsetSum_helper(0, fullset, target_sum, [])\n", "asserts": ["assert set(subsetsum([3, 34, 4, 12, 5, 2], 9)) == {4,5}", "assert subsetsum([1, 8, 2, 7, 4], 14) == [8, 2, 4]", "assert subsetsum([10, 12, 15, 6, 19], 21) == [15, 6]", "assert subsetsum([5, 10, 12, 13, 15, 18], 30) == [12, 18]", "assert subsetsum([5, 3, 9, 12, 6, 15], 27) == [12, 15]", "assert subsetsum([2, 3, 7, 8, 10], 11) == [3, 8]", "assert subsetsum([6, 2, 7, 11, 8], 16) == [6, 2, 8]", "assert subsetsum([5, 7, 1, 14, 6], 13) == [7, 6]", "assert subsetsum([1], 1) == [1]", "assert subsetsum([2, 5, 8, 4], 0) == []", "assert subsetsum([], 5) == None", "assert subsetsum([-1, -2, -3, -4, -5], -10) == None  # Negative numbers are not allowed according to the question", "assert subsetsum([4, 1, 2, 5, 12, 7], 9) == [2, 7]", "assert subsetsum([3, 5, 8, 4], 22) == None  # Sum exceeds the sum of all elements"]}, {"author": "Hafeez", "UUID": "296ab89e-7208-4f6f-bed1-d623f30e32c9", "question": "Coin Change II: You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.\n\nReturn the number of combinations that make up that amount. If that amount of money cannot be made up by any combination of the coins, return 0.\n\nYou may assume that you have an infinite number of each kind of coin.\n\nThe answer is guaranteed to fit into a signed 32-bit integer.", "examples": "Input: amount = 5, coins = [1,2,5]\nOutput: 4\nExplanation: there are four ways to make up the amount:\n5=5\n5=2+2+1\n5=2+1+1+1\n5=1+1+1+1+1\nInput: amount = 3, coins = [2]\nOutput: 0\nExplanation: the amount of 3 cannot be made up just with coins of 2.", "link": "https://leetcode.com/problems/coin-change-ii/description/", "difficulty": "Medium", "categories": ["Dynamic_programming"], "code": "from typing import List\ndef change(amount: int, coins: List[int]) -> int:\n    def numberOfWays(i: int, amount: int) -> int:\n        if amount == 0:\n            return 1\n        if i == len(coins):\n            return 0\n        if memo[i][amount] != -1:\n            return memo[i][amount]\n\n        if coins[i] > amount:\n            memo[i][amount] = numberOfWays(i + 1, amount)\n        else:\n            memo[i][amount] = numberOfWays(i, amount - coins[i]) + numberOfWays(i + 1, amount)\n        \n        return memo[i][amount]\n\n    memo = [[-1] * (amount + 1) for _ in range(len(coins))]\n    return numberOfWays(0, amount)", "asserts": ["assert change(10,[10])==1", "assert change(0, [1, 2, 5]) == 1  # Edge case: trying to make 0 with any coins should always return 1", "assert change(11, [5]) == 0  # Amount cannot be made up with given coins", "assert change(0, []) == 1  # Edge case: trying to make 0 without any coins, should return 1 as there's one way of making 0 with no coins", "assert change(5, [5, 1]) == 2  # Amount can be made with given coins: [5], [1, 1, 1, 1, 1]"]}], "category": "Dynamic_programming", "prompt_tokens": 1226, "total_tokens": 1584, "completion_tokens": 358, "completion": "Given two strings s1 and s2, find the length of the longest common subsequence (LCS).\n\nA subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements.\n\n###Code: \n\ndef longestCommonSubsequence(s1: str, s2: str) -> int:\n    m, n = len(s1), len(s2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    \n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if s1[i - 1] == s2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    \n    return dp[m][n]\n\n###Testcases: \n\nassert longestCommonSubsequence(\"abcde\", \"ace\") == 3  # LCS is \"ace\"\nassert longestCommonSubsequence(\"abc\", \"abc\") == 3  # LCS is \"abc\"\nassert longestCommonSubsequence(\"abc\", \"def\") == 0  # No common subsequence\nassert longestCommonSubsequence(\"AGGTAB\", \"GXTXAYB\") == 4  # LCS is \"GTAB\"\nassert longestCommonSubsequence(\"ABCDGH\", \"AEDFHR\") == 3  # LCS is \"ADH\"\nassert longestCommonSubsequence(\"aaaa\", \"aa\") == 2  # LCS is \"aa\"\n\n[/Example 3]", "temperature": 0.825, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Calvin", "UUID": "51a5caf9-241f-4de3-9ee2-9420490b73d7", "question": "Given a set[] of non-negative integers and a value sum, return the subset of the given set whose sum is equal to the given sum or None if one doesn't exist\n", "examples": "Input: set = [1, 2, 3, 4, 5], sum = 10\nOutput: [1, 2, 3, 4]", "link": "https://www.geeksforgeeks.org/subset-sum-problem-dp-25/", "difficulty": null, "categories": ["Dynamic_programming"], "code": "def subsetsum(fullset: list, target_sum: int) -> set:\n    def subsetSum_helper(cur_idx: int, fullset: list, target_sum: int, subset: list):\n        if target_sum == 0:\n            return subset\n        if (cur_idx == len(fullset)):\n            return None\n        excluding = subsetSum_helper(cur_idx + 1, fullset, target_sum, subset)\n          \n        if excluding is not None:\n            return excluding\n        elif fullset[cur_idx] <= target_sum:\n            subset.append(fullset[cur_idx])\n            including = subsetSum_helper(cur_idx + 1, fullset, target_sum - fullset[cur_idx], subset)\n            if including!=None:\n                return including\n            else:\n                subset.pop()\n            return None\n    return subsetSum_helper(0, fullset, target_sum, [])\n", "asserts": ["assert set(subsetsum([3, 34, 4, 12, 5, 2], 9)) == {4,5}", "assert subsetsum([1, 8, 2, 7, 4], 14) == [8, 2, 4]", "assert subsetsum([10, 12, 15, 6, 19], 21) == [15, 6]", "assert subsetsum([5, 10, 12, 13, 15, 18], 30) == [12, 18]", "assert subsetsum([5, 3, 9, 12, 6, 15], 27) == [12, 15]", "assert subsetsum([2, 3, 7, 8, 10], 11) == [3, 8]", "assert subsetsum([6, 2, 7, 11, 8], 16) == [6, 2, 8]", "assert subsetsum([5, 7, 1, 14, 6], 13) == [7, 6]", "assert subsetsum([1], 1) == [1]", "assert subsetsum([2, 5, 8, 4], 0) == []", "assert subsetsum([], 5) == None", "assert subsetsum([-1, -2, -3, -4, -5], -10) == None  # Negative numbers are not allowed according to the question", "assert subsetsum([4, 1, 2, 5, 12, 7], 9) == [2, 7]", "assert subsetsum([3, 5, 8, 4], 22) == None  # Sum exceeds the sum of all elements"]}, {"author": "Hafeez", "UUID": "38dca76c-ee6c-4c71-83a9-89240828a3b7", "question": "Best Time to Buy and Sell Stock II: You are given an integer array prices where prices[i] is the price of a given stock on the ith day.\n\nOn each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day.\n\nFind and return the maximum profit you can achieve.", "examples": "Input: prices = [7,1,5,3,6,4]\nOutput: 7\nExplanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\nThen buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.\nTotal profit is 4 + 3 = 7.\nInput: prices = [7,6,4,3,1]\nOutput: 0\nExplanation: There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0.", "link": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/", "difficulty": "Medium", "categories": ["Dynamic_programming"], "code": "from typing import List\ndef maxProfit(prices: List[int]) -> int:\n    cur_hold, cur_not_hold = -float('inf'), 0\n    \n    for stock_price in prices:\n        \n        prev_hold, prev_not_hold = cur_hold, cur_not_hold\n        cur_hold = max( prev_hold, prev_not_hold - stock_price )\n        cur_not_hold = max( prev_not_hold, prev_hold + stock_price )\n    return cur_not_hold", "asserts": ["assert maxProfit([1,2,3,4,5])==4", "assert maxProfit([1,2,100,2,1]) == 99"]}], "category": "Dynamic_programming", "prompt_tokens": 1031, "total_tokens": 1291, "completion_tokens": 260, "completion": "Given a string s, find the length of the longest substring without repeating characters.\n\n\n###Code: \n\ndef lengthOfLongestSubstring(s: str) -> int:\n    max_length = 0\n    start = 0\n    char_index_map = {}\n    \n    for end in range(len(s)):\n        if s[end] in char_index_map and char_index_map[s[end]] >= start:\n            start = char_index_map[s[end]] + 1\n        char_index_map[s[end]] = end\n        max_length = max(max_length, end - start + 1)\n    \n    return max_length\n\n###Testcases: \n\nassert lengthOfLongestSubstring(\"abcabcbb\") == 3\nassert lengthOfLongestSubstring(\"bbbbb\") == 1\nassert lengthOfLongestSubstring(\"pwwkew\") == 3\nassert lengthOfLongestSubstring(\"\") == 0\nassert lengthOfLongestSubstring(\" \") == 1\nassert lengthOfLongestSubstring(\"au\") == 2\nassert lengthOfLongestSubstring(\"dvdf\") == 3\nassert lengthOfLongestSubstring(\"tmmzuxt\") == 5\nassert lengthOfLongestSubstring(\"abcadef\") == 6\n\n[/Example 3]", "temperature": 0.715, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Hafeez", "UUID": "296ab89e-7208-4f6f-bed1-d623f30e32c9", "question": "Coin Change II: You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.\n\nReturn the number of combinations that make up that amount. If that amount of money cannot be made up by any combination of the coins, return 0.\n\nYou may assume that you have an infinite number of each kind of coin.\n\nThe answer is guaranteed to fit into a signed 32-bit integer.", "examples": "Input: amount = 5, coins = [1,2,5]\nOutput: 4\nExplanation: there are four ways to make up the amount:\n5=5\n5=2+2+1\n5=2+1+1+1\n5=1+1+1+1+1\nInput: amount = 3, coins = [2]\nOutput: 0\nExplanation: the amount of 3 cannot be made up just with coins of 2.", "link": "https://leetcode.com/problems/coin-change-ii/description/", "difficulty": "Medium", "categories": ["Dynamic_programming"], "code": "from typing import List\ndef change(amount: int, coins: List[int]) -> int:\n    def numberOfWays(i: int, amount: int) -> int:\n        if amount == 0:\n            return 1\n        if i == len(coins):\n            return 0\n        if memo[i][amount] != -1:\n            return memo[i][amount]\n\n        if coins[i] > amount:\n            memo[i][amount] = numberOfWays(i + 1, amount)\n        else:\n            memo[i][amount] = numberOfWays(i, amount - coins[i]) + numberOfWays(i + 1, amount)\n        \n        return memo[i][amount]\n\n    memo = [[-1] * (amount + 1) for _ in range(len(coins))]\n    return numberOfWays(0, amount)", "asserts": ["assert change(10,[10])==1", "assert change(0, [1, 2, 5]) == 1  # Edge case: trying to make 0 with any coins should always return 1", "assert change(11, [5]) == 0  # Amount cannot be made up with given coins", "assert change(0, []) == 1  # Edge case: trying to make 0 without any coins, should return 1 as there's one way of making 0 with no coins", "assert change(5, [5, 1]) == 2  # Amount can be made with given coins: [5], [1, 1, 1, 1, 1]"]}, {"author": "Calvin", "UUID": "51a5caf9-241f-4de3-9ee2-9420490b73d7", "question": "Given a set[] of non-negative integers and a value sum, return the subset of the given set whose sum is equal to the given sum or None if one doesn't exist\n", "examples": "Input: set = [1, 2, 3, 4, 5], sum = 10\nOutput: [1, 2, 3, 4]", "link": "https://www.geeksforgeeks.org/subset-sum-problem-dp-25/", "difficulty": null, "categories": ["Dynamic_programming"], "code": "def subsetsum(fullset: list, target_sum: int) -> set:\n    def subsetSum_helper(cur_idx: int, fullset: list, target_sum: int, subset: list):\n        if target_sum == 0:\n            return subset\n        if (cur_idx == len(fullset)):\n            return None\n        excluding = subsetSum_helper(cur_idx + 1, fullset, target_sum, subset)\n          \n        if excluding is not None:\n            return excluding\n        elif fullset[cur_idx] <= target_sum:\n            subset.append(fullset[cur_idx])\n            including = subsetSum_helper(cur_idx + 1, fullset, target_sum - fullset[cur_idx], subset)\n            if including!=None:\n                return including\n            else:\n                subset.pop()\n            return None\n    return subsetSum_helper(0, fullset, target_sum, [])\n", "asserts": ["assert set(subsetsum([3, 34, 4, 12, 5, 2], 9)) == {4,5}", "assert subsetsum([1, 8, 2, 7, 4], 14) == [8, 2, 4]", "assert subsetsum([10, 12, 15, 6, 19], 21) == [15, 6]", "assert subsetsum([5, 10, 12, 13, 15, 18], 30) == [12, 18]", "assert subsetsum([5, 3, 9, 12, 6, 15], 27) == [12, 15]", "assert subsetsum([2, 3, 7, 8, 10], 11) == [3, 8]", "assert subsetsum([6, 2, 7, 11, 8], 16) == [6, 2, 8]", "assert subsetsum([5, 7, 1, 14, 6], 13) == [7, 6]", "assert subsetsum([1], 1) == [1]", "assert subsetsum([2, 5, 8, 4], 0) == []", "assert subsetsum([], 5) == None", "assert subsetsum([-1, -2, -3, -4, -5], -10) == None  # Negative numbers are not allowed according to the question", "assert subsetsum([4, 1, 2, 5, 12, 7], 9) == [2, 7]", "assert subsetsum([3, 5, 8, 4], 22) == None  # Sum exceeds the sum of all elements"]}], "category": "Dynamic_programming", "prompt_tokens": 1226, "total_tokens": 1705, "completion_tokens": 479, "completion": "You are given an array of integers. Find the length of the longest increasing subsequence (LIS). A subsequence is a sequence that can be derived from an array by deleting some or no elements without changing the order of the remaining elements. \n\n###Code: \n\n```python\ndef lengthOfLIS(nums: List[int]) -> int:\n    if not nums:\n        return 0\n    dp = [1] * len(nums)\n    for i in range(len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n```\n\n###Testcases: \n\n```python\nassert lengthOfLIS([10, 9, 2, 5, 3, 7, 101, 18]) == 4  # The longest increasing subsequence is [2, 3, 7, 101]\nassert lengthOfLIS([0, 1, 0, 3, 2, 3]) == 4  # The longest increasing subsequence is [0, 1, 2, 3]\nassert lengthOfLIS([7, 7, 7, 7, 7, 7, 7]) == 1  # The longest increasing subsequence is [7]\nassert lengthOfLIS([4, 10, 4, 3, 8, 9]) == 3  # The longest increasing subsequence is [4, 8, 9]\nassert lengthOfLIS([1, 3, 6, 7, 9, 4, 10, 5, 6]) == 6  # The longest increasing subsequence is [1, 3, 6, 7, 9, 10]\nassert lengthOfLIS([5, 6, 7, 1, 2, 8]) == 4  # The longest increasing subsequence is [5, 6, 7, 8]\nassert lengthOfLIS([]) == 0  # Empty input should return 0\nassert lengthOfLIS([5]) == 1  # Single element should return 1\n```\n\n[/Example 3]", "temperature": 0.649, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Hafeez", "UUID": "d695e67c-5b0e-4235-8406-30ee6be61173", "question": "N-th Tribonacci Number: The Tribonacci sequence Tn is defined as follows: \n\nT0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n >= 0.\n\nGiven n, return the value of Tn.", "examples": "Input: n = 4\nOutput: 4\nExplanation:\nT_3 = 0 + 1 + 1 = 2\nT_4 = 1 + 1 + 2 = 4", "link": "https://leetcode.com/problems/n-th-tribonacci-number/description/", "difficulty": "Easy", "categories": ["Dynamic_programming"], "code": "def tribonacci(n: int) -> int:\n    dp = {0: 0, 1: 1, 2: 1}\n    def dfs(i):\n        if i in dp:\n            return dp[i]\n        dp[i] = dfs(i - 1) + dfs(i - 2) + dfs(i - 3)\n        return dp[i]\n    \n    return dfs(n)", "asserts": ["assert tribonacci(25)==1389537", "assert tribonacci(0) == 0", "assert tribonacci(1) == 1", "assert tribonacci(2) == 1", "assert tribonacci(3) == 2", "assert tribonacci(5) == 7", "assert tribonacci(7) == 24", "assert tribonacci(10) == 149", "assert tribonacci(15) == 3136", "assert tribonacci(30) == 29249425"]}, {"author": "Hafeez", "UUID": "6aaf1310-7585-4d90-91e7-1f405c9b25e7", "question": "Get Maximum in Generated Array: You are given an integer n. A 0-indexed integer array nums of length n + 1 is generated in the following way:\n\nnums[0] = 0\nnums[1] = 1\nnums[2 * i] = nums[i] when 2 <= 2 * i <= n\nnums[2 * i + 1] = nums[i] + nums[i + 1] when 2 <= 2 * i + 1 <= n\nReturn the maximum integer in the array nums\u200b\u200b\u200b.", "examples": "Input: n = 7\nOutput: 3\nExplanation: According to the given rules:\n  nums[0] = 0\n  nums[1] = 1\n  nums[(1 * 2) = 2] = nums[1] = 1\n  nums[(1 * 2) + 1 = 3] = nums[1] + nums[2] = 1 + 1 = 2\n  nums[(2 * 2) = 4] = nums[2] = 1\n  nums[(2 * 2) + 1 = 5] = nums[2] + nums[3] = 1 + 2 = 3\n  nums[(3 * 2) = 6] = nums[3] = 2\n  nums[(3 * 2) + 1 = 7] = nums[3] + nums[4] = 2 + 1 = 3\nHence, nums = [0,1,1,2,1,3,2,3], and the maximum is max(0,1,1,2,1,3,2,3) = 3.\nInput: n = 2\nOutput: 1\nExplanation: According to the given rules, nums = [0,1,1]. The maximum is max(0,1,1) = 1.\nInput: n = 3\nOutput: 2\nExplanation: According to the given rules, nums = [0,1,1,2]. The maximum is max(0,1,1,2) = 2.", "link": "https://leetcode.com/problems/get-maximum-in-generated-array/", "difficulty": "Easy", "categories": ["Dynamic_programming"], "code": "def getMaximumGenerated(n: int) -> int:\n    if n<2:\n        return n\n    nums=[0]*(n+1)\n    nums[0]=0\n    nums[1]=1\n    for i in range(2,n+1):\n        if i%2==0:\n            nums[i]=nums[i//2]\n        else:\n            nums[i]=nums[i//2]+nums[i//2+1]\n    return max(nums)", "asserts": ["assert getMaximumGenerated(2)==1", "assert getMaximumGenerated(4) == 2", "assert getMaximumGenerated(5) == 3", "assert getMaximumGenerated(8) == 3", "assert getMaximumGenerated(15) == 5", "assert getMaximumGenerated(0) == 0", "assert getMaximumGenerated(1) == 1"]}], "category": "Dynamic_programming", "prompt_tokens": 764, "total_tokens": 1045, "completion_tokens": 281, "completion": "Maximum Subarray: Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.\n\n###Code:\n\n```python\ndef maxSubArray(nums: List[int]) -> int:\n    max_sum = nums[0]\n    current_sum = nums[0]\n    for num in nums[1:]:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    return max_sum\n```\n\n###Testcases:\n\n```python\nassert maxSubArray([-2, 1, -3, 4, -1, 2, 1, -5, 4]) == 6\nassert maxSubArray([1]) == 1\nassert maxSubArray([5, 4, -1, 7, 8]) == 23\nassert maxSubArray([-2, -3, 4, -1, -2, 1, 5, -3]) == 7\nassert maxSubArray([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == 55\nassert maxSubArray([-1, -2, -3, -4, -5]) == -1\n```\n\n[/Example 3]", "temperature": 0.882, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Hafeez", "UUID": "38dca76c-ee6c-4c71-83a9-89240828a3b7", "question": "Best Time to Buy and Sell Stock II: You are given an integer array prices where prices[i] is the price of a given stock on the ith day.\n\nOn each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day.\n\nFind and return the maximum profit you can achieve.", "examples": "Input: prices = [7,1,5,3,6,4]\nOutput: 7\nExplanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\nThen buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.\nTotal profit is 4 + 3 = 7.\nInput: prices = [7,6,4,3,1]\nOutput: 0\nExplanation: There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0.", "link": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/", "difficulty": "Medium", "categories": ["Dynamic_programming"], "code": "from typing import List\ndef maxProfit(prices: List[int]) -> int:\n    cur_hold, cur_not_hold = -float('inf'), 0\n    \n    for stock_price in prices:\n        \n        prev_hold, prev_not_hold = cur_hold, cur_not_hold\n        cur_hold = max( prev_hold, prev_not_hold - stock_price )\n        cur_not_hold = max( prev_not_hold, prev_hold + stock_price )\n    return cur_not_hold", "asserts": ["assert maxProfit([1,2,3,4,5])==4", "assert maxProfit([1,2,100,2,1]) == 99"]}, {"author": "Calvin", "UUID": "5e7011e5-fee4-4c1a-a98f-3b81e50508cc", "question": "Return nth number in the fibonacci sequence", "examples": "Input: 9\nOutput: 34\n\nInput: 7\nOutput: 13", "link": NaN, "difficulty": null, "categories": ["Dynamic_programming"], "code": "def fibonacci(n: int) -> int:\n    a = 0\n    b = 1\n    if n < 0:\n        print(\"Incorrect input\")\n    elif n == 0:\n        return a\n    elif n == 1:\n        return b\n    else:\n        for i in range(2, n+1):\n            c = a + b\n            a = b\n            b = c\n        return b\n    b = c\n    return fib(n-1, a, b)\n", "asserts": ["assert fibonacci(9) == 34", "assert fibonacci(10) == 55", "assert fibonacci(5) == 5", "assert fibonacci(2) == 1", "assert fibonacci(0) == 0", "assert fibonacci(11) == 89", "assert fibonacci(15) == 610", "assert fibonacci(20) == 6765", "assert fibonacci(25) == 75025", "assert fibonacci(3) == 2", "assert fibonacci(1) == 1", "assert fibonacci(6) == 8", "assert fibonacci(30) == 832040", "assert fibonacci(35) == 9227465", "assert fibonacci(40) == 102334155"]}], "category": "Dynamic_programming", "prompt_tokens": 695, "total_tokens": 1050, "completion_tokens": 355, "completion": "Find the length of the longest increasing subsequence in an integer array.\n\n###Code: \n\nfrom typing import List\n\ndef lengthOfLIS(nums: List[int]) -> int:\n    if not nums:\n        return 0\n    dp = [1] * len(nums)\n    \n    for i in range(len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    \n    return max(dp)\n\n###Testcases: \n\nassert lengthOfLIS([10, 9, 2, 5, 3, 7, 101, 18]) == 4\nassert lengthOfLIS([0, 1, 0, 3, 2, 3]) == 4\nassert lengthOfLIS([7, 7, 7, 7, 7, 7, 7]) == 1\nassert lengthOfLIS([4, 10, 4, 3, 8, 9]) == 3\nassert lengthOfLIS([2, 2]) == 1\nassert lengthOfLIS([1, 3, 6, 7, 9, 4, 10, 5, 6]) == 6\nassert lengthOfLIS([3, 4, -1, 0, 6, 2, 3]) == 4\nassert lengthOfLIS([10, 9, 2, 5, 3, 7, 101, 18]) == 4\nassert lengthOfLIS([]) == 0\n\n[/Example 3]", "temperature": 0.866, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Calvin", "UUID": "e35d1110-85e8-4f50-80aa-91eb976b310b", "question": "Return the factorial of a given number n", "examples": "Input: 5\nOutput: 120\n\nInput: 6\nOutput: 720", "link": NaN, "difficulty": null, "categories": ["Dynamic_programming"], "code": "\ndef fact(n: int) -> int:\n  if n <= 1:\n    return 1\n  return n*fact(n-1)\n", "asserts": ["assert fact(5) == 120", "assert fact(0) == 1", "assert fact(1) == 1", "assert fact(3) == 6", "assert fact(7) == 5040", "assert fact(10) == 3628800", "assert fact(4) == 24", "assert fact(8) == 40320", "assert fact(2) == 2", "assert fact(11) == 39916800"]}, {"author": "Calvin", "UUID": "5e7011e5-fee4-4c1a-a98f-3b81e50508cc", "question": "Return nth number in the fibonacci sequence", "examples": "Input: 9\nOutput: 34\n\nInput: 7\nOutput: 13", "link": NaN, "difficulty": null, "categories": ["Dynamic_programming"], "code": "def fibonacci(n: int) -> int:\n    a = 0\n    b = 1\n    if n < 0:\n        print(\"Incorrect input\")\n    elif n == 0:\n        return a\n    elif n == 1:\n        return b\n    else:\n        for i in range(2, n+1):\n            c = a + b\n            a = b\n            b = c\n        return b\n    b = c\n    return fib(n-1, a, b)\n", "asserts": ["assert fibonacci(9) == 34", "assert fibonacci(10) == 55", "assert fibonacci(5) == 5", "assert fibonacci(2) == 1", "assert fibonacci(0) == 0", "assert fibonacci(11) == 89", "assert fibonacci(15) == 610", "assert fibonacci(20) == 6765", "assert fibonacci(25) == 75025", "assert fibonacci(3) == 2", "assert fibonacci(1) == 1", "assert fibonacci(6) == 8", "assert fibonacci(30) == 832040", "assert fibonacci(35) == 9227465", "assert fibonacci(40) == 102334155"]}], "category": "Dynamic_programming", "prompt_tokens": 614, "total_tokens": 1009, "completion_tokens": 395, "completion": "Find the maximum sum of a subarray within a given array of integers.\n\n###Code: \n\n```python\ndef max_subarray_sum(nums: List[int]) -> int:\n    max_sum = float('-inf')\n    current_sum = 0\n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    return max_sum\n```\n\n###Testcases: \n\n```python\nassert max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) == 6\nassert max_subarray_sum([1]) == 1\nassert max_subarray_sum([5, 4, -1, 7, 8]) == 23\nassert max_subarray_sum([-2, -3, 4, -1, -2, 1, 5, -3]) == 7\nassert max_subarray_sum([-1, -2, -3, -4]) == -1\nassert max_subarray_sum([2, 3, -1, -20, 5, 10]) == 15\nassert max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4, 8, -10, 5, 6]) == 16\nassert max_subarray_sum([2, -1, 2, 3, -1, 2]) == 7\nassert max_subarray_sum([-2, -1, -3, -4, -1, -2, -1, -5, -4]) == -1\nassert max_subarray_sum([1, -1, 1, -1, 1, -1, 1, -1, 1]) == 1\n```", "temperature": 0.832, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Calvin", "UUID": "5e7011e5-fee4-4c1a-a98f-3b81e50508cc", "question": "Return nth number in the fibonacci sequence", "examples": "Input: 9\nOutput: 34\n\nInput: 7\nOutput: 13", "link": NaN, "difficulty": null, "categories": ["Dynamic_programming"], "code": "def fibonacci(n: int) -> int:\n    a = 0\n    b = 1\n    if n < 0:\n        print(\"Incorrect input\")\n    elif n == 0:\n        return a\n    elif n == 1:\n        return b\n    else:\n        for i in range(2, n+1):\n            c = a + b\n            a = b\n            b = c\n        return b\n    b = c\n    return fib(n-1, a, b)\n", "asserts": ["assert fibonacci(9) == 34", "assert fibonacci(10) == 55", "assert fibonacci(5) == 5", "assert fibonacci(2) == 1", "assert fibonacci(0) == 0", "assert fibonacci(11) == 89", "assert fibonacci(15) == 610", "assert fibonacci(20) == 6765", "assert fibonacci(25) == 75025", "assert fibonacci(3) == 2", "assert fibonacci(1) == 1", "assert fibonacci(6) == 8", "assert fibonacci(30) == 832040", "assert fibonacci(35) == 9227465", "assert fibonacci(40) == 102334155"]}, {"author": "Hafeez", "UUID": "296ab89e-7208-4f6f-bed1-d623f30e32c9", "question": "Coin Change II: You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.\n\nReturn the number of combinations that make up that amount. If that amount of money cannot be made up by any combination of the coins, return 0.\n\nYou may assume that you have an infinite number of each kind of coin.\n\nThe answer is guaranteed to fit into a signed 32-bit integer.", "examples": "Input: amount = 5, coins = [1,2,5]\nOutput: 4\nExplanation: there are four ways to make up the amount:\n5=5\n5=2+2+1\n5=2+1+1+1\n5=1+1+1+1+1\nInput: amount = 3, coins = [2]\nOutput: 0\nExplanation: the amount of 3 cannot be made up just with coins of 2.", "link": "https://leetcode.com/problems/coin-change-ii/description/", "difficulty": "Medium", "categories": ["Dynamic_programming"], "code": "from typing import List\ndef change(amount: int, coins: List[int]) -> int:\n    def numberOfWays(i: int, amount: int) -> int:\n        if amount == 0:\n            return 1\n        if i == len(coins):\n            return 0\n        if memo[i][amount] != -1:\n            return memo[i][amount]\n\n        if coins[i] > amount:\n            memo[i][amount] = numberOfWays(i + 1, amount)\n        else:\n            memo[i][amount] = numberOfWays(i, amount - coins[i]) + numberOfWays(i + 1, amount)\n        \n        return memo[i][amount]\n\n    memo = [[-1] * (amount + 1) for _ in range(len(coins))]\n    return numberOfWays(0, amount)", "asserts": ["assert change(10,[10])==1", "assert change(0, [1, 2, 5]) == 1  # Edge case: trying to make 0 with any coins should always return 1", "assert change(11, [5]) == 0  # Amount cannot be made up with given coins", "assert change(0, []) == 1  # Edge case: trying to make 0 without any coins, should return 1 as there's one way of making 0 with no coins", "assert change(5, [5, 1]) == 2  # Amount can be made with given coins: [5], [1, 1, 1, 1, 1]"]}], "category": "Dynamic_programming", "prompt_tokens": 890, "total_tokens": 1158, "completion_tokens": 268, "completion": "Find the length of the longest increasing subsequence in an array.\n\n###Code:\n\ndef lengthOfLIS(nums: List[int]) -> int:\n    if not nums:\n        return 0\n    dp = [1] * len(nums)\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n\n###Testcases:\n\nassert lengthOfLIS([10, 9, 2, 5, 3, 7, 101, 18]) == 4  # The longest increasing subsequence is [2, 3, 7, 101], which has a length of 4\nassert lengthOfLIS([0, 1, 0, 3, 2, 3]) == 4  # The longest increasing subsequence is [0, 1, 2, 3], which has a length of 4\nassert lengthOfLIS([7, 7, 7, 7, 7, 7, 7]) == 1  # The longest increasing subsequence is [7], which has a length of 1\n\n[/Example 3]", "temperature": 0.941, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Calvin", "UUID": "e35d1110-85e8-4f50-80aa-91eb976b310b", "question": "Return the factorial of a given number n", "examples": "Input: 5\nOutput: 120\n\nInput: 6\nOutput: 720", "link": NaN, "difficulty": null, "categories": ["Dynamic_programming"], "code": "\ndef fact(n: int) -> int:\n  if n <= 1:\n    return 1\n  return n*fact(n-1)\n", "asserts": ["assert fact(5) == 120", "assert fact(0) == 1", "assert fact(1) == 1", "assert fact(3) == 6", "assert fact(7) == 5040", "assert fact(10) == 3628800", "assert fact(4) == 24", "assert fact(8) == 40320", "assert fact(2) == 2", "assert fact(11) == 39916800"]}, {"author": "Hafeez", "UUID": "296ab89e-7208-4f6f-bed1-d623f30e32c9", "question": "Coin Change II: You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.\n\nReturn the number of combinations that make up that amount. If that amount of money cannot be made up by any combination of the coins, return 0.\n\nYou may assume that you have an infinite number of each kind of coin.\n\nThe answer is guaranteed to fit into a signed 32-bit integer.", "examples": "Input: amount = 5, coins = [1,2,5]\nOutput: 4\nExplanation: there are four ways to make up the amount:\n5=5\n5=2+2+1\n5=2+1+1+1\n5=1+1+1+1+1\nInput: amount = 3, coins = [2]\nOutput: 0\nExplanation: the amount of 3 cannot be made up just with coins of 2.", "link": "https://leetcode.com/problems/coin-change-ii/description/", "difficulty": "Medium", "categories": ["Dynamic_programming"], "code": "from typing import List\ndef change(amount: int, coins: List[int]) -> int:\n    def numberOfWays(i: int, amount: int) -> int:\n        if amount == 0:\n            return 1\n        if i == len(coins):\n            return 0\n        if memo[i][amount] != -1:\n            return memo[i][amount]\n\n        if coins[i] > amount:\n            memo[i][amount] = numberOfWays(i + 1, amount)\n        else:\n            memo[i][amount] = numberOfWays(i, amount - coins[i]) + numberOfWays(i + 1, amount)\n        \n        return memo[i][amount]\n\n    memo = [[-1] * (amount + 1) for _ in range(len(coins))]\n    return numberOfWays(0, amount)", "asserts": ["assert change(10,[10])==1", "assert change(0, [1, 2, 5]) == 1  # Edge case: trying to make 0 with any coins should always return 1", "assert change(11, [5]) == 0  # Amount cannot be made up with given coins", "assert change(0, []) == 1  # Edge case: trying to make 0 without any coins, should return 1 as there's one way of making 0 with no coins", "assert change(5, [5, 1]) == 2  # Amount can be made with given coins: [5], [1, 1, 1, 1, 1]"]}], "category": "Dynamic_programming", "prompt_tokens": 767, "total_tokens": 1183, "completion_tokens": 416, "completion": "Find the length of the longest increasing subsequence in an integer array.\n\n###Code: \n\nfrom typing import List\n\ndef lengthOfLIS(nums: List[int]) -> int:\n    if not nums:\n        return 0\n    \n    dp = [1] * len(nums)\n    for i in range(len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    \n    return max(dp)\n\n###Testcases: \n\nassert lengthOfLIS([10, 9, 2, 5, 3, 7, 101, 18]) == 4  # The longest increasing subsequence is [2, 3, 7, 101], which has a length of 4\nassert lengthOfLIS([0, 1, 0, 3, 2, 3]) == 4  # The longest increasing subsequence is [0, 1, 2, 3], which has a length of 4\nassert lengthOfLIS([7, 7, 7, 7, 7, 7, 7]) == 1  # The longest increasing subsequence is [7], which has a length of 1\nassert lengthOfLIS([4, 10, 4, 3, 8, 9]) == 3  # The longest increasing subsequence is [4, 4, 8] or [4, 3, 8] or [4, 3, 9], all of which have a length of 3\nassert lengthOfLIS([1, 3, 6, 7, 9, 4, 10, 5, 6]) == 6  # The longest increasing subsequence is [1, 3, 6, 7, 9, 10], which has a length of 6\n\n[/Example 3]", "temperature": 0.68, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Calvin", "UUID": "5e7011e5-fee4-4c1a-a98f-3b81e50508cc", "question": "Return nth number in the fibonacci sequence", "examples": "Input: 9\nOutput: 34\n\nInput: 7\nOutput: 13", "link": NaN, "difficulty": null, "categories": ["Dynamic_programming"], "code": "def fibonacci(n: int) -> int:\n    a = 0\n    b = 1\n    if n < 0:\n        print(\"Incorrect input\")\n    elif n == 0:\n        return a\n    elif n == 1:\n        return b\n    else:\n        for i in range(2, n+1):\n            c = a + b\n            a = b\n            b = c\n        return b\n    b = c\n    return fib(n-1, a, b)\n", "asserts": ["assert fibonacci(9) == 34", "assert fibonacci(10) == 55", "assert fibonacci(5) == 5", "assert fibonacci(2) == 1", "assert fibonacci(0) == 0", "assert fibonacci(11) == 89", "assert fibonacci(15) == 610", "assert fibonacci(20) == 6765", "assert fibonacci(25) == 75025", "assert fibonacci(3) == 2", "assert fibonacci(1) == 1", "assert fibonacci(6) == 8", "assert fibonacci(30) == 832040", "assert fibonacci(35) == 9227465", "assert fibonacci(40) == 102334155"]}, {"author": "Hafeez", "UUID": "d695e67c-5b0e-4235-8406-30ee6be61173", "question": "N-th Tribonacci Number: The Tribonacci sequence Tn is defined as follows: \n\nT0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n >= 0.\n\nGiven n, return the value of Tn.", "examples": "Input: n = 4\nOutput: 4\nExplanation:\nT_3 = 0 + 1 + 1 = 2\nT_4 = 1 + 1 + 2 = 4", "link": "https://leetcode.com/problems/n-th-tribonacci-number/description/", "difficulty": "Easy", "categories": ["Dynamic_programming"], "code": "def tribonacci(n: int) -> int:\n    dp = {0: 0, 1: 1, 2: 1}\n    def dfs(i):\n        if i in dp:\n            return dp[i]\n        dp[i] = dfs(i - 1) + dfs(i - 2) + dfs(i - 3)\n        return dp[i]\n    \n    return dfs(n)", "asserts": ["assert tribonacci(25)==1389537", "assert tribonacci(0) == 0", "assert tribonacci(1) == 1", "assert tribonacci(2) == 1", "assert tribonacci(3) == 2", "assert tribonacci(5) == 7", "assert tribonacci(7) == 24", "assert tribonacci(10) == 149", "assert tribonacci(15) == 3136", "assert tribonacci(30) == 29249425"]}], "category": "Dynamic_programming", "prompt_tokens": 735, "total_tokens": 1034, "completion_tokens": 299, "completion": "Find the maximum sum subarray in a given array of integers.\n\n###Code: \n\ndef max_subarray_sum(arr: List[int]) -> int:\n    max_sum = arr[0]\n    current_sum = arr[0]\n\n    for num in arr[1:]:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum\n\n###Testcases: \n\nassert max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) == 6\nassert max_subarray_sum([1]) == 1\nassert max_subarray_sum([5, 4, -1, 7, 8]) == 23\nassert max_subarray_sum([-2, -3, 4, -1, -2, 1, 5, -3]) == 7\nassert max_subarray_sum([-1, -2, -3, -4]) == -1\nassert max_subarray_sum([1, 2, 3, 4, 5]) == 15\nassert max_subarray_sum([-5, -1, -8, -9]) == -1\nassert max_subarray_sum([1, -2, 3, 4, -10, 4, 6, -8, 1]) == 10\n\n[/Example 3]", "temperature": 0.819, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Hafeez", "UUID": "6aaf1310-7585-4d90-91e7-1f405c9b25e7", "question": "Get Maximum in Generated Array: You are given an integer n. A 0-indexed integer array nums of length n + 1 is generated in the following way:\n\nnums[0] = 0\nnums[1] = 1\nnums[2 * i] = nums[i] when 2 <= 2 * i <= n\nnums[2 * i + 1] = nums[i] + nums[i + 1] when 2 <= 2 * i + 1 <= n\nReturn the maximum integer in the array nums\u200b\u200b\u200b.", "examples": "Input: n = 7\nOutput: 3\nExplanation: According to the given rules:\n  nums[0] = 0\n  nums[1] = 1\n  nums[(1 * 2) = 2] = nums[1] = 1\n  nums[(1 * 2) + 1 = 3] = nums[1] + nums[2] = 1 + 1 = 2\n  nums[(2 * 2) = 4] = nums[2] = 1\n  nums[(2 * 2) + 1 = 5] = nums[2] + nums[3] = 1 + 2 = 3\n  nums[(3 * 2) = 6] = nums[3] = 2\n  nums[(3 * 2) + 1 = 7] = nums[3] + nums[4] = 2 + 1 = 3\nHence, nums = [0,1,1,2,1,3,2,3], and the maximum is max(0,1,1,2,1,3,2,3) = 3.\nInput: n = 2\nOutput: 1\nExplanation: According to the given rules, nums = [0,1,1]. The maximum is max(0,1,1) = 1.\nInput: n = 3\nOutput: 2\nExplanation: According to the given rules, nums = [0,1,1,2]. The maximum is max(0,1,1,2) = 2.", "link": "https://leetcode.com/problems/get-maximum-in-generated-array/", "difficulty": "Easy", "categories": ["Dynamic_programming"], "code": "def getMaximumGenerated(n: int) -> int:\n    if n<2:\n        return n\n    nums=[0]*(n+1)\n    nums[0]=0\n    nums[1]=1\n    for i in range(2,n+1):\n        if i%2==0:\n            nums[i]=nums[i//2]\n        else:\n            nums[i]=nums[i//2]+nums[i//2+1]\n    return max(nums)", "asserts": ["assert getMaximumGenerated(2)==1", "assert getMaximumGenerated(4) == 2", "assert getMaximumGenerated(5) == 3", "assert getMaximumGenerated(8) == 3", "assert getMaximumGenerated(15) == 5", "assert getMaximumGenerated(0) == 0", "assert getMaximumGenerated(1) == 1"]}, {"author": "Calvin", "UUID": "5e7011e5-fee4-4c1a-a98f-3b81e50508cc", "question": "Return nth number in the fibonacci sequence", "examples": "Input: 9\nOutput: 34\n\nInput: 7\nOutput: 13", "link": NaN, "difficulty": null, "categories": ["Dynamic_programming"], "code": "def fibonacci(n: int) -> int:\n    a = 0\n    b = 1\n    if n < 0:\n        print(\"Incorrect input\")\n    elif n == 0:\n        return a\n    elif n == 1:\n        return b\n    else:\n        for i in range(2, n+1):\n            c = a + b\n            a = b\n            b = c\n        return b\n    b = c\n    return fib(n-1, a, b)\n", "asserts": ["assert fibonacci(9) == 34", "assert fibonacci(10) == 55", "assert fibonacci(5) == 5", "assert fibonacci(2) == 1", "assert fibonacci(0) == 0", "assert fibonacci(11) == 89", "assert fibonacci(15) == 610", "assert fibonacci(20) == 6765", "assert fibonacci(25) == 75025", "assert fibonacci(3) == 2", "assert fibonacci(1) == 1", "assert fibonacci(6) == 8", "assert fibonacci(30) == 832040", "assert fibonacci(35) == 9227465", "assert fibonacci(40) == 102334155"]}], "category": "Dynamic_programming", "prompt_tokens": 766, "total_tokens": 1127, "completion_tokens": 361, "completion": "Find the minimum cost to reach the end of an array when you can move either one or two steps at a time. The cost of each step is given in an array.\n\n###Code:\n\n```python\ndef minCostClimbingStairs(cost: List[int]) -> int:\n    n = len(cost)\n    dp = [0] * (n + 1)\n    dp[0], dp[1] = cost[0], cost[1]\n    for i in range(2, n):\n        dp[i] = cost[i] + min(dp[i-1], dp[i-2])\n    return min(dp[-1], dp[-2])\n```\n\n###Testcases:\n\n```python\nassert minCostClimbingStairs([10, 15, 20]) == 15\nassert minCostClimbingStairs([1, 100, 1, 1, 1, 100, 1, 1, 100, 1]) == 6\nassert minCostClimbingStairs([1, 1, 1, 1, 1]) == 2\nassert minCostClimbingStairs([0, 0, 0, 1]) == 0\nassert minCostClimbingStairs([1, 0, 0, 0]) == 0\nassert minCostClimbingStairs([1, 1, 1, 1, 1, 1, 1, 5]) == 5\nassert minCostClimbingStairs([5, 1, 1, 1, 1, 1, 1, 1]) == 5\n```\n\n[/Example 3]", "temperature": 0.91, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Hafeez", "UUID": "d695e67c-5b0e-4235-8406-30ee6be61173", "question": "N-th Tribonacci Number: The Tribonacci sequence Tn is defined as follows: \n\nT0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n >= 0.\n\nGiven n, return the value of Tn.", "examples": "Input: n = 4\nOutput: 4\nExplanation:\nT_3 = 0 + 1 + 1 = 2\nT_4 = 1 + 1 + 2 = 4", "link": "https://leetcode.com/problems/n-th-tribonacci-number/description/", "difficulty": "Easy", "categories": ["Dynamic_programming"], "code": "def tribonacci(n: int) -> int:\n    dp = {0: 0, 1: 1, 2: 1}\n    def dfs(i):\n        if i in dp:\n            return dp[i]\n        dp[i] = dfs(i - 1) + dfs(i - 2) + dfs(i - 3)\n        return dp[i]\n    \n    return dfs(n)", "asserts": ["assert tribonacci(25)==1389537", "assert tribonacci(0) == 0", "assert tribonacci(1) == 1", "assert tribonacci(2) == 1", "assert tribonacci(3) == 2", "assert tribonacci(5) == 7", "assert tribonacci(7) == 24", "assert tribonacci(10) == 149", "assert tribonacci(15) == 3136", "assert tribonacci(30) == 29249425"]}, {"author": "Hafeez", "UUID": "38dca76c-ee6c-4c71-83a9-89240828a3b7", "question": "Best Time to Buy and Sell Stock II: You are given an integer array prices where prices[i] is the price of a given stock on the ith day.\n\nOn each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day.\n\nFind and return the maximum profit you can achieve.", "examples": "Input: prices = [7,1,5,3,6,4]\nOutput: 7\nExplanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\nThen buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.\nTotal profit is 4 + 3 = 7.\nInput: prices = [7,6,4,3,1]\nOutput: 0\nExplanation: There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0.", "link": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/", "difficulty": "Medium", "categories": ["Dynamic_programming"], "code": "from typing import List\ndef maxProfit(prices: List[int]) -> int:\n    cur_hold, cur_not_hold = -float('inf'), 0\n    \n    for stock_price in prices:\n        \n        prev_hold, prev_not_hold = cur_hold, cur_not_hold\n        cur_hold = max( prev_hold, prev_not_hold - stock_price )\n        cur_not_hold = max( prev_not_hold, prev_hold + stock_price )\n    return cur_not_hold", "asserts": ["assert maxProfit([1,2,3,4,5])==4", "assert maxProfit([1,2,100,2,1]) == 99"]}], "category": "Dynamic_programming", "prompt_tokens": 693, "total_tokens": 891, "completion_tokens": 198, "completion": "Maximum Subarray: Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.\n\n###Code: \n\nfrom typing import List\ndef maxSubArray(nums: List[int]) -> int:\n    max_sum = float('-inf')\n    current_sum = 0\n    \n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    \n    return max_sum\n\n###Testcases: \n\nassert maxSubArray([-2,1,-3,4,-1,2,1,-5,4]) == 6\nassert maxSubArray([1]) == 1\nassert maxSubArray([5,4,-1,7,8]) == 23\nassert maxSubArray([-2,-1,-3,-4,-1,-2,-1,-5,-4]) == -1\n\n[/Example 3]", "temperature": 0.664, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Hafeez", "UUID": "d695e67c-5b0e-4235-8406-30ee6be61173", "question": "N-th Tribonacci Number: The Tribonacci sequence Tn is defined as follows: \n\nT0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n >= 0.\n\nGiven n, return the value of Tn.", "examples": "Input: n = 4\nOutput: 4\nExplanation:\nT_3 = 0 + 1 + 1 = 2\nT_4 = 1 + 1 + 2 = 4", "link": "https://leetcode.com/problems/n-th-tribonacci-number/description/", "difficulty": "Easy", "categories": ["Dynamic_programming"], "code": "def tribonacci(n: int) -> int:\n    dp = {0: 0, 1: 1, 2: 1}\n    def dfs(i):\n        if i in dp:\n            return dp[i]\n        dp[i] = dfs(i - 1) + dfs(i - 2) + dfs(i - 3)\n        return dp[i]\n    \n    return dfs(n)", "asserts": ["assert tribonacci(25)==1389537", "assert tribonacci(0) == 0", "assert tribonacci(1) == 1", "assert tribonacci(2) == 1", "assert tribonacci(3) == 2", "assert tribonacci(5) == 7", "assert tribonacci(7) == 24", "assert tribonacci(10) == 149", "assert tribonacci(15) == 3136", "assert tribonacci(30) == 29249425"]}, {"author": "Hafeez", "UUID": "6aaf1310-7585-4d90-91e7-1f405c9b25e7", "question": "Get Maximum in Generated Array: You are given an integer n. A 0-indexed integer array nums of length n + 1 is generated in the following way:\n\nnums[0] = 0\nnums[1] = 1\nnums[2 * i] = nums[i] when 2 <= 2 * i <= n\nnums[2 * i + 1] = nums[i] + nums[i + 1] when 2 <= 2 * i + 1 <= n\nReturn the maximum integer in the array nums\u200b\u200b\u200b.", "examples": "Input: n = 7\nOutput: 3\nExplanation: According to the given rules:\n  nums[0] = 0\n  nums[1] = 1\n  nums[(1 * 2) = 2] = nums[1] = 1\n  nums[(1 * 2) + 1 = 3] = nums[1] + nums[2] = 1 + 1 = 2\n  nums[(2 * 2) = 4] = nums[2] = 1\n  nums[(2 * 2) + 1 = 5] = nums[2] + nums[3] = 1 + 2 = 3\n  nums[(3 * 2) = 6] = nums[3] = 2\n  nums[(3 * 2) + 1 = 7] = nums[3] + nums[4] = 2 + 1 = 3\nHence, nums = [0,1,1,2,1,3,2,3], and the maximum is max(0,1,1,2,1,3,2,3) = 3.\nInput: n = 2\nOutput: 1\nExplanation: According to the given rules, nums = [0,1,1]. The maximum is max(0,1,1) = 1.\nInput: n = 3\nOutput: 2\nExplanation: According to the given rules, nums = [0,1,1,2]. The maximum is max(0,1,1,2) = 2.", "link": "https://leetcode.com/problems/get-maximum-in-generated-array/", "difficulty": "Easy", "categories": ["Dynamic_programming"], "code": "def getMaximumGenerated(n: int) -> int:\n    if n<2:\n        return n\n    nums=[0]*(n+1)\n    nums[0]=0\n    nums[1]=1\n    for i in range(2,n+1):\n        if i%2==0:\n            nums[i]=nums[i//2]\n        else:\n            nums[i]=nums[i//2]+nums[i//2+1]\n    return max(nums)", "asserts": ["assert getMaximumGenerated(2)==1", "assert getMaximumGenerated(4) == 2", "assert getMaximumGenerated(5) == 3", "assert getMaximumGenerated(8) == 3", "assert getMaximumGenerated(15) == 5", "assert getMaximumGenerated(0) == 0", "assert getMaximumGenerated(1) == 1"]}], "category": "Dynamic_programming", "prompt_tokens": 764, "total_tokens": 1085, "completion_tokens": 321, "completion": "Maximum Subarray: Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.\n\n###Code: \n\ndef maxSubArray(nums: List[int]) -> int:\n    max_sum = nums[0]\n    current_sum = nums[0]\n    \n    for num in nums[1:]:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    \n    return max_sum\n\n###Testcases: \n\nassert maxSubArray([-2, 1, -3, 4, -1, 2, 1, -5, 4]) == 6\nassert maxSubArray([1]) == 1\nassert maxSubArray([5, 4, -1, 7, 8]) == 23\nassert maxSubArray([-2, -1, -3, -4, -1, -2, -1, -5, -4]) == -1\nassert maxSubArray([-8, -3, -6, -2, -5, -4]) == -2\nassert maxSubArray([1, 2, 3, 4, 5]) == 15\nassert maxSubArray([-1, -2, -3, -4, -5]) == -1\nassert maxSubArray([-2, -5, 6, -2, -3, 1, 5, -6]) == 7\n\n[/Example 3]", "temperature": 0.795, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Calvin", "UUID": "51a5caf9-241f-4de3-9ee2-9420490b73d7", "question": "Given a set[] of non-negative integers and a value sum, return the subset of the given set whose sum is equal to the given sum or None if one doesn't exist\n", "examples": "Input: set = [1, 2, 3, 4, 5], sum = 10\nOutput: [1, 2, 3, 4]", "link": "https://www.geeksforgeeks.org/subset-sum-problem-dp-25/", "difficulty": null, "categories": ["Dynamic_programming"], "code": "def subsetsum(fullset: list, target_sum: int) -> set:\n    def subsetSum_helper(cur_idx: int, fullset: list, target_sum: int, subset: list):\n        if target_sum == 0:\n            return subset\n        if (cur_idx == len(fullset)):\n            return None\n        excluding = subsetSum_helper(cur_idx + 1, fullset, target_sum, subset)\n          \n        if excluding is not None:\n            return excluding\n        elif fullset[cur_idx] <= target_sum:\n            subset.append(fullset[cur_idx])\n            including = subsetSum_helper(cur_idx + 1, fullset, target_sum - fullset[cur_idx], subset)\n            if including!=None:\n                return including\n            else:\n                subset.pop()\n            return None\n    return subsetSum_helper(0, fullset, target_sum, [])\n", "asserts": ["assert set(subsetsum([3, 34, 4, 12, 5, 2], 9)) == {4,5}", "assert subsetsum([1, 8, 2, 7, 4], 14) == [8, 2, 4]", "assert subsetsum([10, 12, 15, 6, 19], 21) == [15, 6]", "assert subsetsum([5, 10, 12, 13, 15, 18], 30) == [12, 18]", "assert subsetsum([5, 3, 9, 12, 6, 15], 27) == [12, 15]", "assert subsetsum([2, 3, 7, 8, 10], 11) == [3, 8]", "assert subsetsum([6, 2, 7, 11, 8], 16) == [6, 2, 8]", "assert subsetsum([5, 7, 1, 14, 6], 13) == [7, 6]", "assert subsetsum([1], 1) == [1]", "assert subsetsum([2, 5, 8, 4], 0) == []", "assert subsetsum([], 5) == None", "assert subsetsum([-1, -2, -3, -4, -5], -10) == None  # Negative numbers are not allowed according to the question", "assert subsetsum([4, 1, 2, 5, 12, 7], 9) == [2, 7]", "assert subsetsum([3, 5, 8, 4], 22) == None  # Sum exceeds the sum of all elements"]}, {"author": "Calvin", "UUID": "e35d1110-85e8-4f50-80aa-91eb976b310b", "question": "Return the factorial of a given number n", "examples": "Input: 5\nOutput: 120\n\nInput: 6\nOutput: 720", "link": NaN, "difficulty": null, "categories": ["Dynamic_programming"], "code": "\ndef fact(n: int) -> int:\n  if n <= 1:\n    return 1\n  return n*fact(n-1)\n", "asserts": ["assert fact(5) == 120", "assert fact(0) == 1", "assert fact(1) == 1", "assert fact(3) == 6", "assert fact(7) == 5040", "assert fact(10) == 3628800", "assert fact(4) == 24", "assert fact(8) == 40320", "assert fact(2) == 2", "assert fact(11) == 39916800"]}], "category": "Dynamic_programming", "prompt_tokens": 950, "total_tokens": 1412, "completion_tokens": 462, "completion": "Find the length of the longest increasing subsequence in a given list of integers.\n\n###Code:\n\n```python\ndef lengthOfLIS(nums: List[int]) -> int:\n    if not nums:\n        return 0\n    dp = [1] * len(nums)\n    for i in range(len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n```\n\n###Testcases:\n\n```python\nassert lengthOfLIS([10, 9, 2, 5, 3, 7, 101, 18]) == 4  # Longest increasing subsequence is [2, 3, 7, 101]\nassert lengthOfLIS([0, 1, 0, 3, 2, 3]) == 4  # Longest increasing subsequence is [0, 1, 2, 3]\nassert lengthOfLIS([7, 7, 7, 7, 7, 7, 7]) == 1  # Longest increasing subsequence is [7]\nassert lengthOfLIS([4, 10, 4, 3, 8, 9]) == 3  # Longest increasing subsequence is [4, 8, 9]\nassert lengthOfLIS([5, 6, 7, 8, 1, 2, 3]) == 4  # Longest increasing subsequence is [5, 6, 7, 8]\nassert lengthOfLIS([]) == 0  # Empty list\nassert lengthOfLIS([5]) == 1  # List with one element\nassert lengthOfLIS([3, 2, 1]) == 1  # Longest increasing subsequence is [3]\nassert lengthOfLIS([1, 3, 6, 7, 9, 4, 10, 5, 6]) == 6  # Longest increasing subsequence is [1, 3, 6, 7, 9, 10]\n```", "temperature": 0.907, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Hafeez", "UUID": "296ab89e-7208-4f6f-bed1-d623f30e32c9", "question": "Coin Change II: You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.\n\nReturn the number of combinations that make up that amount. If that amount of money cannot be made up by any combination of the coins, return 0.\n\nYou may assume that you have an infinite number of each kind of coin.\n\nThe answer is guaranteed to fit into a signed 32-bit integer.", "examples": "Input: amount = 5, coins = [1,2,5]\nOutput: 4\nExplanation: there are four ways to make up the amount:\n5=5\n5=2+2+1\n5=2+1+1+1\n5=1+1+1+1+1\nInput: amount = 3, coins = [2]\nOutput: 0\nExplanation: the amount of 3 cannot be made up just with coins of 2.", "link": "https://leetcode.com/problems/coin-change-ii/description/", "difficulty": "Medium", "categories": ["Dynamic_programming"], "code": "from typing import List\ndef change(amount: int, coins: List[int]) -> int:\n    def numberOfWays(i: int, amount: int) -> int:\n        if amount == 0:\n            return 1\n        if i == len(coins):\n            return 0\n        if memo[i][amount] != -1:\n            return memo[i][amount]\n\n        if coins[i] > amount:\n            memo[i][amount] = numberOfWays(i + 1, amount)\n        else:\n            memo[i][amount] = numberOfWays(i, amount - coins[i]) + numberOfWays(i + 1, amount)\n        \n        return memo[i][amount]\n\n    memo = [[-1] * (amount + 1) for _ in range(len(coins))]\n    return numberOfWays(0, amount)", "asserts": ["assert change(10,[10])==1", "assert change(0, [1, 2, 5]) == 1  # Edge case: trying to make 0 with any coins should always return 1", "assert change(11, [5]) == 0  # Amount cannot be made up with given coins", "assert change(0, []) == 1  # Edge case: trying to make 0 without any coins, should return 1 as there's one way of making 0 with no coins", "assert change(5, [5, 1]) == 2  # Amount can be made with given coins: [5], [1, 1, 1, 1, 1]"]}, {"author": "Hafeez", "UUID": "38dca76c-ee6c-4c71-83a9-89240828a3b7", "question": "Best Time to Buy and Sell Stock II: You are given an integer array prices where prices[i] is the price of a given stock on the ith day.\n\nOn each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day.\n\nFind and return the maximum profit you can achieve.", "examples": "Input: prices = [7,1,5,3,6,4]\nOutput: 7\nExplanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\nThen buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.\nTotal profit is 4 + 3 = 7.\nInput: prices = [7,6,4,3,1]\nOutput: 0\nExplanation: There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0.", "link": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/", "difficulty": "Medium", "categories": ["Dynamic_programming"], "code": "from typing import List\ndef maxProfit(prices: List[int]) -> int:\n    cur_hold, cur_not_hold = -float('inf'), 0\n    \n    for stock_price in prices:\n        \n        prev_hold, prev_not_hold = cur_hold, cur_not_hold\n        cur_hold = max( prev_hold, prev_not_hold - stock_price )\n        cur_not_hold = max( prev_not_hold, prev_hold + stock_price )\n    return cur_not_hold", "asserts": ["assert maxProfit([1,2,3,4,5])==4", "assert maxProfit([1,2,100,2,1]) == 99"]}], "category": "Dynamic_programming", "prompt_tokens": 848, "total_tokens": 1011, "completion_tokens": 163, "completion": "Maximum Subarray: Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.\n\n###Code: \n\ndef maxSubArray(nums: List[int]) -> int:\n    max_sum = current_sum = nums[0]\n    for num in nums[1:]:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    return max_sum\n\n###Testcases: \n\nassert maxSubArray([-2,1,-3,4,-1,2,1,-5,4]) == 6\nassert maxSubArray([1]) == 1\nassert maxSubArray([5,4,-1,7,8]) == 23\n\n[/Example 3]", "temperature": 0.696, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Calvin", "UUID": "e35d1110-85e8-4f50-80aa-91eb976b310b", "question": "Return the factorial of a given number n", "examples": "Input: 5\nOutput: 120\n\nInput: 6\nOutput: 720", "link": NaN, "difficulty": null, "categories": ["Dynamic_programming"], "code": "\ndef fact(n: int) -> int:\n  if n <= 1:\n    return 1\n  return n*fact(n-1)\n", "asserts": ["assert fact(5) == 120", "assert fact(0) == 1", "assert fact(1) == 1", "assert fact(3) == 6", "assert fact(7) == 5040", "assert fact(10) == 3628800", "assert fact(4) == 24", "assert fact(8) == 40320", "assert fact(2) == 2", "assert fact(11) == 39916800"]}, {"author": "Calvin", "UUID": "51a5caf9-241f-4de3-9ee2-9420490b73d7", "question": "Given a set[] of non-negative integers and a value sum, return the subset of the given set whose sum is equal to the given sum or None if one doesn't exist\n", "examples": "Input: set = [1, 2, 3, 4, 5], sum = 10\nOutput: [1, 2, 3, 4]", "link": "https://www.geeksforgeeks.org/subset-sum-problem-dp-25/", "difficulty": null, "categories": ["Dynamic_programming"], "code": "def subsetsum(fullset: list, target_sum: int) -> set:\n    def subsetSum_helper(cur_idx: int, fullset: list, target_sum: int, subset: list):\n        if target_sum == 0:\n            return subset\n        if (cur_idx == len(fullset)):\n            return None\n        excluding = subsetSum_helper(cur_idx + 1, fullset, target_sum, subset)\n          \n        if excluding is not None:\n            return excluding\n        elif fullset[cur_idx] <= target_sum:\n            subset.append(fullset[cur_idx])\n            including = subsetSum_helper(cur_idx + 1, fullset, target_sum - fullset[cur_idx], subset)\n            if including!=None:\n                return including\n            else:\n                subset.pop()\n            return None\n    return subsetSum_helper(0, fullset, target_sum, [])\n", "asserts": ["assert set(subsetsum([3, 34, 4, 12, 5, 2], 9)) == {4,5}", "assert subsetsum([1, 8, 2, 7, 4], 14) == [8, 2, 4]", "assert subsetsum([10, 12, 15, 6, 19], 21) == [15, 6]", "assert subsetsum([5, 10, 12, 13, 15, 18], 30) == [12, 18]", "assert subsetsum([5, 3, 9, 12, 6, 15], 27) == [12, 15]", "assert subsetsum([2, 3, 7, 8, 10], 11) == [3, 8]", "assert subsetsum([6, 2, 7, 11, 8], 16) == [6, 2, 8]", "assert subsetsum([5, 7, 1, 14, 6], 13) == [7, 6]", "assert subsetsum([1], 1) == [1]", "assert subsetsum([2, 5, 8, 4], 0) == []", "assert subsetsum([], 5) == None", "assert subsetsum([-1, -2, -3, -4, -5], -10) == None  # Negative numbers are not allowed according to the question", "assert subsetsum([4, 1, 2, 5, 12, 7], 9) == [2, 7]", "assert subsetsum([3, 5, 8, 4], 22) == None  # Sum exceeds the sum of all elements"]}], "category": "Dynamic_programming", "prompt_tokens": 950, "total_tokens": 1296, "completion_tokens": 346, "completion": "Find the length of the longest increasing subsequence in a given list of integers.\n\n###Code: \n\n```python\ndef longest_increasing_subsequence(nums: List[int]) -> int:\n    if not nums:\n        return 0\n    dp = [1] * len(nums)\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n```\n\n###Testcases: \n\n```python\nassert longest_increasing_subsequence([10, 9, 2, 5, 3, 7, 101, 18]) == 4\nassert longest_increasing_subsequence([0, 1, 0, 3, 2, 3]) == 4\nassert longest_increasing_subsequence([7, 7, 7, 7, 7, 7, 7]) == 1\nassert longest_increasing_subsequence([2, 2, 2, 2, 2]) == 1\nassert longest_increasing_subsequence([1, 3, 6, 7, 9, 4, 10, 5, 6]) == 6\nassert longest_increasing_subsequence([1, 2, 3, 4, 5]) == 5\nassert longest_increasing_subsequence([5, 4, 3, 2, 1]) == 1\nassert longest_increasing_subsequence([3, 4, 5, 1, 2]) == 3\n```", "temperature": 0.794, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Hafeez", "UUID": "d695e67c-5b0e-4235-8406-30ee6be61173", "question": "N-th Tribonacci Number: The Tribonacci sequence Tn is defined as follows: \n\nT0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n >= 0.\n\nGiven n, return the value of Tn.", "examples": "Input: n = 4\nOutput: 4\nExplanation:\nT_3 = 0 + 1 + 1 = 2\nT_4 = 1 + 1 + 2 = 4", "link": "https://leetcode.com/problems/n-th-tribonacci-number/description/", "difficulty": "Easy", "categories": ["Dynamic_programming"], "code": "def tribonacci(n: int) -> int:\n    dp = {0: 0, 1: 1, 2: 1}\n    def dfs(i):\n        if i in dp:\n            return dp[i]\n        dp[i] = dfs(i - 1) + dfs(i - 2) + dfs(i - 3)\n        return dp[i]\n    \n    return dfs(n)", "asserts": ["assert tribonacci(25)==1389537", "assert tribonacci(0) == 0", "assert tribonacci(1) == 1", "assert tribonacci(2) == 1", "assert tribonacci(3) == 2", "assert tribonacci(5) == 7", "assert tribonacci(7) == 24", "assert tribonacci(10) == 149", "assert tribonacci(15) == 3136", "assert tribonacci(30) == 29249425"]}, {"author": "Calvin", "UUID": "5e7011e5-fee4-4c1a-a98f-3b81e50508cc", "question": "Return nth number in the fibonacci sequence", "examples": "Input: 9\nOutput: 34\n\nInput: 7\nOutput: 13", "link": NaN, "difficulty": null, "categories": ["Dynamic_programming"], "code": "def fibonacci(n: int) -> int:\n    a = 0\n    b = 1\n    if n < 0:\n        print(\"Incorrect input\")\n    elif n == 0:\n        return a\n    elif n == 1:\n        return b\n    else:\n        for i in range(2, n+1):\n            c = a + b\n            a = b\n            b = c\n        return b\n    b = c\n    return fib(n-1, a, b)\n", "asserts": ["assert fibonacci(9) == 34", "assert fibonacci(10) == 55", "assert fibonacci(5) == 5", "assert fibonacci(2) == 1", "assert fibonacci(0) == 0", "assert fibonacci(11) == 89", "assert fibonacci(15) == 610", "assert fibonacci(20) == 6765", "assert fibonacci(25) == 75025", "assert fibonacci(3) == 2", "assert fibonacci(1) == 1", "assert fibonacci(6) == 8", "assert fibonacci(30) == 832040", "assert fibonacci(35) == 9227465", "assert fibonacci(40) == 102334155"]}], "category": "Dynamic_programming", "prompt_tokens": 735, "total_tokens": 1140, "completion_tokens": 405, "completion": "Find the maximum sum of a subarray within an array of integers.\n\n###Code: \n\ndef max_subarray_sum(nums: List[int]) -> int:\n    max_sum = float('-inf')\n    current_sum = 0\n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    return max_sum\n\n###Testcases: \n\nassert max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) == 6\nassert max_subarray_sum([1]) == 1\nassert max_subarray_sum([5, 4, -1, 7, 8]) == 23\nassert max_subarray_sum([-2, -3, 4, -1, -2, 1, 5, -3]) == 7\nassert max_subarray_sum([-1, -2, -3, -4, -5, -6, -7, -8]) == -1\nassert max_subarray_sum([1, 2, 3, 4, 5, 6, 7, 8]) == 36\nassert max_subarray_sum([-2, -5, 6, -2, -3, 1, 5, -6]) == 7\nassert max_subarray_sum([1, -5, 2, -1, 3, -2, 2, -5, 4]) == 6\nassert max_subarray_sum([-1, 1, 2, 3, -2, 5, 4, -2, 6]) == 16\nassert max_subarray_sum([5, -3, 5, -8, -1, 3, 2, 1, -5, 8]) == 10\n\n[/Example 3]", "temperature": 0.823, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Hafeez", "UUID": "d695e67c-5b0e-4235-8406-30ee6be61173", "question": "N-th Tribonacci Number: The Tribonacci sequence Tn is defined as follows: \n\nT0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n >= 0.\n\nGiven n, return the value of Tn.", "examples": "Input: n = 4\nOutput: 4\nExplanation:\nT_3 = 0 + 1 + 1 = 2\nT_4 = 1 + 1 + 2 = 4", "link": "https://leetcode.com/problems/n-th-tribonacci-number/description/", "difficulty": "Easy", "categories": ["Dynamic_programming"], "code": "def tribonacci(n: int) -> int:\n    dp = {0: 0, 1: 1, 2: 1}\n    def dfs(i):\n        if i in dp:\n            return dp[i]\n        dp[i] = dfs(i - 1) + dfs(i - 2) + dfs(i - 3)\n        return dp[i]\n    \n    return dfs(n)", "asserts": ["assert tribonacci(25)==1389537", "assert tribonacci(0) == 0", "assert tribonacci(1) == 1", "assert tribonacci(2) == 1", "assert tribonacci(3) == 2", "assert tribonacci(5) == 7", "assert tribonacci(7) == 24", "assert tribonacci(10) == 149", "assert tribonacci(15) == 3136", "assert tribonacci(30) == 29249425"]}, {"author": "Calvin", "UUID": "e35d1110-85e8-4f50-80aa-91eb976b310b", "question": "Return the factorial of a given number n", "examples": "Input: 5\nOutput: 120\n\nInput: 6\nOutput: 720", "link": NaN, "difficulty": null, "categories": ["Dynamic_programming"], "code": "\ndef fact(n: int) -> int:\n  if n <= 1:\n    return 1\n  return n*fact(n-1)\n", "asserts": ["assert fact(5) == 120", "assert fact(0) == 1", "assert fact(1) == 1", "assert fact(3) == 6", "assert fact(7) == 5040", "assert fact(10) == 3628800", "assert fact(4) == 24", "assert fact(8) == 40320", "assert fact(2) == 2", "assert fact(11) == 39916800"]}], "category": "Dynamic_programming", "prompt_tokens": 612, "total_tokens": 1023, "completion_tokens": 411, "completion": "Find the maximum subarray sum of a given array.\n\n###Code:\n\n```python\ndef maxSubArray(nums: List[int]) -> int:\n    max_sum = nums[0]\n    current_sum = nums[0]\n    for num in nums[1:]:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    return max_sum\n```\n\n###Testcases:\n\n```python\nassert maxSubArray([-2, 1, -3, 4, -1, 2, 1, -5, 4]) == 6\nassert maxSubArray([1]) == 1\nassert maxSubArray([5, 4, -1, 7, 8]) == 23\nassert maxSubArray([-2, -3, 4, -1, -2, 1, 5, -3]) == 7\nassert maxSubArray([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == 55\nassert maxSubArray([-10, -2, -3, -4, -5, -6, -7, -8, -9, -1]) == -1\nassert maxSubArray([-1, -2, -3, -4, -5, -6, -7, -8, -9, -10]) == -1\nassert maxSubArray([2, 3, -4, 5, -2, -3, 3, -7]) == 7\nassert maxSubArray([10, -1, -2, -3, -4, -5, -6, -7, -8, 20]) == 20\nassert maxSubArray([5, 4, -1, 7, 8, -20, 10]) == 19\n```\n\n[/Example 3]", "temperature": 0.876, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Calvin", "UUID": "e35d1110-85e8-4f50-80aa-91eb976b310b", "question": "Return the factorial of a given number n", "examples": "Input: 5\nOutput: 120\n\nInput: 6\nOutput: 720", "link": NaN, "difficulty": null, "categories": ["Dynamic_programming"], "code": "\ndef fact(n: int) -> int:\n  if n <= 1:\n    return 1\n  return n*fact(n-1)\n", "asserts": ["assert fact(5) == 120", "assert fact(0) == 1", "assert fact(1) == 1", "assert fact(3) == 6", "assert fact(7) == 5040", "assert fact(10) == 3628800", "assert fact(4) == 24", "assert fact(8) == 40320", "assert fact(2) == 2", "assert fact(11) == 39916800"]}, {"author": "Hafeez", "UUID": "6aaf1310-7585-4d90-91e7-1f405c9b25e7", "question": "Get Maximum in Generated Array: You are given an integer n. A 0-indexed integer array nums of length n + 1 is generated in the following way:\n\nnums[0] = 0\nnums[1] = 1\nnums[2 * i] = nums[i] when 2 <= 2 * i <= n\nnums[2 * i + 1] = nums[i] + nums[i + 1] when 2 <= 2 * i + 1 <= n\nReturn the maximum integer in the array nums\u200b\u200b\u200b.", "examples": "Input: n = 7\nOutput: 3\nExplanation: According to the given rules:\n  nums[0] = 0\n  nums[1] = 1\n  nums[(1 * 2) = 2] = nums[1] = 1\n  nums[(1 * 2) + 1 = 3] = nums[1] + nums[2] = 1 + 1 = 2\n  nums[(2 * 2) = 4] = nums[2] = 1\n  nums[(2 * 2) + 1 = 5] = nums[2] + nums[3] = 1 + 2 = 3\n  nums[(3 * 2) = 6] = nums[3] = 2\n  nums[(3 * 2) + 1 = 7] = nums[3] + nums[4] = 2 + 1 = 3\nHence, nums = [0,1,1,2,1,3,2,3], and the maximum is max(0,1,1,2,1,3,2,3) = 3.\nInput: n = 2\nOutput: 1\nExplanation: According to the given rules, nums = [0,1,1]. The maximum is max(0,1,1) = 1.\nInput: n = 3\nOutput: 2\nExplanation: According to the given rules, nums = [0,1,1,2]. The maximum is max(0,1,1,2) = 2.", "link": "https://leetcode.com/problems/get-maximum-in-generated-array/", "difficulty": "Easy", "categories": ["Dynamic_programming"], "code": "def getMaximumGenerated(n: int) -> int:\n    if n<2:\n        return n\n    nums=[0]*(n+1)\n    nums[0]=0\n    nums[1]=1\n    for i in range(2,n+1):\n        if i%2==0:\n            nums[i]=nums[i//2]\n        else:\n            nums[i]=nums[i//2]+nums[i//2+1]\n    return max(nums)", "asserts": ["assert getMaximumGenerated(2)==1", "assert getMaximumGenerated(4) == 2", "assert getMaximumGenerated(5) == 3", "assert getMaximumGenerated(8) == 3", "assert getMaximumGenerated(15) == 5", "assert getMaximumGenerated(0) == 0", "assert getMaximumGenerated(1) == 1"]}], "category": "Dynamic_programming", "prompt_tokens": 643, "total_tokens": 844, "completion_tokens": 201, "completion": "Return the minimum number of coins needed to make up the given amount. You have an infinite supply of each coin denomination.\n\n###Code: \n\n```python\nfrom typing import List\n\ndef minCoins(coins: List[int], amount: int) -> int:\n    dp = [float('inf')] * (amount + 1)\n    dp[0] = 0\n    for coin in coins:\n        for i in range(coin, amount + 1):\n            dp[i] = min(dp[i], dp[i - coin] + 1)\n    return dp[amount]\n```\n\n###Testcases: \n\n```python\nassert minCoins([1, 2, 5], 11) == 3\nassert minCoins([2], 3) == -1\nassert minCoins([1], 0) == 0\nassert minCoins([1], 1) == 1\nassert minCoins([1], 2) == 2\n```", "temperature": 0.658, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Hafeez", "UUID": "38dca76c-ee6c-4c71-83a9-89240828a3b7", "question": "Best Time to Buy and Sell Stock II: You are given an integer array prices where prices[i] is the price of a given stock on the ith day.\n\nOn each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day.\n\nFind and return the maximum profit you can achieve.", "examples": "Input: prices = [7,1,5,3,6,4]\nOutput: 7\nExplanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\nThen buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.\nTotal profit is 4 + 3 = 7.\nInput: prices = [7,6,4,3,1]\nOutput: 0\nExplanation: There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0.", "link": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/", "difficulty": "Medium", "categories": ["Dynamic_programming"], "code": "from typing import List\ndef maxProfit(prices: List[int]) -> int:\n    cur_hold, cur_not_hold = -float('inf'), 0\n    \n    for stock_price in prices:\n        \n        prev_hold, prev_not_hold = cur_hold, cur_not_hold\n        cur_hold = max( prev_hold, prev_not_hold - stock_price )\n        cur_not_hold = max( prev_not_hold, prev_hold + stock_price )\n    return cur_not_hold", "asserts": ["assert maxProfit([1,2,3,4,5])==4", "assert maxProfit([1,2,100,2,1]) == 99"]}, {"author": "Hafeez", "UUID": "6aaf1310-7585-4d90-91e7-1f405c9b25e7", "question": "Get Maximum in Generated Array: You are given an integer n. A 0-indexed integer array nums of length n + 1 is generated in the following way:\n\nnums[0] = 0\nnums[1] = 1\nnums[2 * i] = nums[i] when 2 <= 2 * i <= n\nnums[2 * i + 1] = nums[i] + nums[i + 1] when 2 <= 2 * i + 1 <= n\nReturn the maximum integer in the array nums\u200b\u200b\u200b.", "examples": "Input: n = 7\nOutput: 3\nExplanation: According to the given rules:\n  nums[0] = 0\n  nums[1] = 1\n  nums[(1 * 2) = 2] = nums[1] = 1\n  nums[(1 * 2) + 1 = 3] = nums[1] + nums[2] = 1 + 1 = 2\n  nums[(2 * 2) = 4] = nums[2] = 1\n  nums[(2 * 2) + 1 = 5] = nums[2] + nums[3] = 1 + 2 = 3\n  nums[(3 * 2) = 6] = nums[3] = 2\n  nums[(3 * 2) + 1 = 7] = nums[3] + nums[4] = 2 + 1 = 3\nHence, nums = [0,1,1,2,1,3,2,3], and the maximum is max(0,1,1,2,1,3,2,3) = 3.\nInput: n = 2\nOutput: 1\nExplanation: According to the given rules, nums = [0,1,1]. The maximum is max(0,1,1) = 1.\nInput: n = 3\nOutput: 2\nExplanation: According to the given rules, nums = [0,1,1,2]. The maximum is max(0,1,1,2) = 2.", "link": "https://leetcode.com/problems/get-maximum-in-generated-array/", "difficulty": "Easy", "categories": ["Dynamic_programming"], "code": "def getMaximumGenerated(n: int) -> int:\n    if n<2:\n        return n\n    nums=[0]*(n+1)\n    nums[0]=0\n    nums[1]=1\n    for i in range(2,n+1):\n        if i%2==0:\n            nums[i]=nums[i//2]\n        else:\n            nums[i]=nums[i//2]+nums[i//2+1]\n    return max(nums)", "asserts": ["assert getMaximumGenerated(2)==1", "assert getMaximumGenerated(4) == 2", "assert getMaximumGenerated(5) == 3", "assert getMaximumGenerated(8) == 3", "assert getMaximumGenerated(15) == 5", "assert getMaximumGenerated(0) == 0", "assert getMaximumGenerated(1) == 1"]}], "category": "Dynamic_programming", "prompt_tokens": 724, "total_tokens": 1014, "completion_tokens": 290, "completion": "Count Square Submatrices with All Ones: Given a m x n matrix of 0s and 1s, return the number of square submatrices with all ones.\n\n###Code: \n\nfrom typing import List\ndef countSquares(matrix: List[List[int]]) -> int:\n    m, n = len(matrix), len(matrix[0])\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    count = 0\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if matrix[i - 1][j - 1] == 1:\n                dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1\n                count += dp[i][j]\n    return count\n\n###Testcases: \n\nassert countSquares([[0,1,1,1],[1,1,1,1],[0,1,1,1]]) == 15\nassert countSquares([[1,0,1],[1,1,0],[1,1,0]]) == 7\nassert countSquares([[1,1,1],[1,1,1],[1,1,1]]) == 14\n\n[/Example 3]", "temperature": 0.776, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Hafeez", "UUID": "d695e67c-5b0e-4235-8406-30ee6be61173", "question": "N-th Tribonacci Number: The Tribonacci sequence Tn is defined as follows: \n\nT0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n >= 0.\n\nGiven n, return the value of Tn.", "examples": "Input: n = 4\nOutput: 4\nExplanation:\nT_3 = 0 + 1 + 1 = 2\nT_4 = 1 + 1 + 2 = 4", "link": "https://leetcode.com/problems/n-th-tribonacci-number/description/", "difficulty": "Easy", "categories": ["Dynamic_programming"], "code": "def tribonacci(n: int) -> int:\n    dp = {0: 0, 1: 1, 2: 1}\n    def dfs(i):\n        if i in dp:\n            return dp[i]\n        dp[i] = dfs(i - 1) + dfs(i - 2) + dfs(i - 3)\n        return dp[i]\n    \n    return dfs(n)", "asserts": ["assert tribonacci(25)==1389537", "assert tribonacci(0) == 0", "assert tribonacci(1) == 1", "assert tribonacci(2) == 1", "assert tribonacci(3) == 2", "assert tribonacci(5) == 7", "assert tribonacci(7) == 24", "assert tribonacci(10) == 149", "assert tribonacci(15) == 3136", "assert tribonacci(30) == 29249425"]}, {"author": "Calvin", "UUID": "5e7011e5-fee4-4c1a-a98f-3b81e50508cc", "question": "Return nth number in the fibonacci sequence", "examples": "Input: 9\nOutput: 34\n\nInput: 7\nOutput: 13", "link": NaN, "difficulty": null, "categories": ["Dynamic_programming"], "code": "def fibonacci(n: int) -> int:\n    a = 0\n    b = 1\n    if n < 0:\n        print(\"Incorrect input\")\n    elif n == 0:\n        return a\n    elif n == 1:\n        return b\n    else:\n        for i in range(2, n+1):\n            c = a + b\n            a = b\n            b = c\n        return b\n    b = c\n    return fib(n-1, a, b)\n", "asserts": ["assert fibonacci(9) == 34", "assert fibonacci(10) == 55", "assert fibonacci(5) == 5", "assert fibonacci(2) == 1", "assert fibonacci(0) == 0", "assert fibonacci(11) == 89", "assert fibonacci(15) == 610", "assert fibonacci(20) == 6765", "assert fibonacci(25) == 75025", "assert fibonacci(3) == 2", "assert fibonacci(1) == 1", "assert fibonacci(6) == 8", "assert fibonacci(30) == 832040", "assert fibonacci(35) == 9227465", "assert fibonacci(40) == 102334155"]}], "category": "Dynamic_programming", "prompt_tokens": 735, "total_tokens": 1113, "completion_tokens": 378, "completion": "Find the maximum sum of a subarray within an array of integers.\n\n###Code: \n\ndef max_subarray(nums: List[int]) -> int:\n    max_sum = nums[0]\n    current_sum = nums[0]\n    \n    for num in nums[1:]:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n        \n    return max_sum\n\n###Testcases: \n\nassert max_subarray([-2, 1, -3, 4, -1, 2, 1, -5, 4]) == 6\nassert max_subarray([1]) == 1\nassert max_subarray([5, 4, -1, 7, 8]) == 23\nassert max_subarray([-1, -2, -3, -4, -5, -6, -7]) == -1\nassert max_subarray([2, 3, -1, -20, 5, 10]) == 15\nassert max_subarray([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == 55\nassert max_subarray([-2, -5, 6, -2, -3, 1, 5, -6]) == 7\nassert max_subarray([-2, 1, -3, 4, -1, 2, 1, -5, 4]) == 6\nassert max_subarray([-2, -1, -3, -4, -1, -2, -1, -5, -4]) == -1\nassert max_subarray([8, -1, 3, 4]) == 14\n\n[/Example 3]", "temperature": 0.995, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Hafeez", "UUID": "296ab89e-7208-4f6f-bed1-d623f30e32c9", "question": "Coin Change II: You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.\n\nReturn the number of combinations that make up that amount. If that amount of money cannot be made up by any combination of the coins, return 0.\n\nYou may assume that you have an infinite number of each kind of coin.\n\nThe answer is guaranteed to fit into a signed 32-bit integer.", "examples": "Input: amount = 5, coins = [1,2,5]\nOutput: 4\nExplanation: there are four ways to make up the amount:\n5=5\n5=2+2+1\n5=2+1+1+1\n5=1+1+1+1+1\nInput: amount = 3, coins = [2]\nOutput: 0\nExplanation: the amount of 3 cannot be made up just with coins of 2.", "link": "https://leetcode.com/problems/coin-change-ii/description/", "difficulty": "Medium", "categories": ["Dynamic_programming"], "code": "from typing import List\ndef change(amount: int, coins: List[int]) -> int:\n    def numberOfWays(i: int, amount: int) -> int:\n        if amount == 0:\n            return 1\n        if i == len(coins):\n            return 0\n        if memo[i][amount] != -1:\n            return memo[i][amount]\n\n        if coins[i] > amount:\n            memo[i][amount] = numberOfWays(i + 1, amount)\n        else:\n            memo[i][amount] = numberOfWays(i, amount - coins[i]) + numberOfWays(i + 1, amount)\n        \n        return memo[i][amount]\n\n    memo = [[-1] * (amount + 1) for _ in range(len(coins))]\n    return numberOfWays(0, amount)", "asserts": ["assert change(10,[10])==1", "assert change(0, [1, 2, 5]) == 1  # Edge case: trying to make 0 with any coins should always return 1", "assert change(11, [5]) == 0  # Amount cannot be made up with given coins", "assert change(0, []) == 1  # Edge case: trying to make 0 without any coins, should return 1 as there's one way of making 0 with no coins", "assert change(5, [5, 1]) == 2  # Amount can be made with given coins: [5], [1, 1, 1, 1, 1]"]}, {"author": "Calvin", "UUID": "51a5caf9-241f-4de3-9ee2-9420490b73d7", "question": "Given a set[] of non-negative integers and a value sum, return the subset of the given set whose sum is equal to the given sum or None if one doesn't exist\n", "examples": "Input: set = [1, 2, 3, 4, 5], sum = 10\nOutput: [1, 2, 3, 4]", "link": "https://www.geeksforgeeks.org/subset-sum-problem-dp-25/", "difficulty": null, "categories": ["Dynamic_programming"], "code": "def subsetsum(fullset: list, target_sum: int) -> set:\n    def subsetSum_helper(cur_idx: int, fullset: list, target_sum: int, subset: list):\n        if target_sum == 0:\n            return subset\n        if (cur_idx == len(fullset)):\n            return None\n        excluding = subsetSum_helper(cur_idx + 1, fullset, target_sum, subset)\n          \n        if excluding is not None:\n            return excluding\n        elif fullset[cur_idx] <= target_sum:\n            subset.append(fullset[cur_idx])\n            including = subsetSum_helper(cur_idx + 1, fullset, target_sum - fullset[cur_idx], subset)\n            if including!=None:\n                return including\n            else:\n                subset.pop()\n            return None\n    return subsetSum_helper(0, fullset, target_sum, [])\n", "asserts": ["assert set(subsetsum([3, 34, 4, 12, 5, 2], 9)) == {4,5}", "assert subsetsum([1, 8, 2, 7, 4], 14) == [8, 2, 4]", "assert subsetsum([10, 12, 15, 6, 19], 21) == [15, 6]", "assert subsetsum([5, 10, 12, 13, 15, 18], 30) == [12, 18]", "assert subsetsum([5, 3, 9, 12, 6, 15], 27) == [12, 15]", "assert subsetsum([2, 3, 7, 8, 10], 11) == [3, 8]", "assert subsetsum([6, 2, 7, 11, 8], 16) == [6, 2, 8]", "assert subsetsum([5, 7, 1, 14, 6], 13) == [7, 6]", "assert subsetsum([1], 1) == [1]", "assert subsetsum([2, 5, 8, 4], 0) == []", "assert subsetsum([], 5) == None", "assert subsetsum([-1, -2, -3, -4, -5], -10) == None  # Negative numbers are not allowed according to the question", "assert subsetsum([4, 1, 2, 5, 12, 7], 9) == [2, 7]", "assert subsetsum([3, 5, 8, 4], 22) == None  # Sum exceeds the sum of all elements"]}], "category": "Dynamic_programming", "prompt_tokens": 1226, "total_tokens": 1622, "completion_tokens": 396, "completion": "Find the length of the longest increasing subsequence in an integer array.\n\n###Code:\n\n```python\ndef lengthOfLIS(nums: List[int]) -> int:\n    if len(nums) == 0:\n        return 0\n    dp = [1] * len(nums)\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n```\n\n###Testcases:\n\n```python\nassert lengthOfLIS([10, 9, 2, 5, 3, 7, 101, 18]) == 4  # The longest increasing subsequence is [2, 3, 7, 101]\nassert lengthOfLIS([0, 1, 0, 3, 2, 3]) == 4  # The longest increasing subsequence is [0, 1, 2, 3]\nassert lengthOfLIS([7, 7, 7, 7, 7, 7, 7]) == 1  # The longest increasing subsequence is [7]\nassert lengthOfLIS([4, 10, 4, 3, 8, 9]) == 3  # The longest increasing subsequence is [4, 8, 9]\nassert lengthOfLIS([1]) == 1  # The longest increasing subsequence is [1]\nassert lengthOfLIS([]) == 0  # Empty array has no increasing subsequence\nassert lengthOfLIS([5, 2, 8, 6, 3, 6, 9, 7]) == 4  # The longest increasing subsequence is [2, 3, 6, 9]\n```\n\n[/Example 3]", "temperature": 0.913, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Hafeez", "UUID": "38dca76c-ee6c-4c71-83a9-89240828a3b7", "question": "Best Time to Buy and Sell Stock II: You are given an integer array prices where prices[i] is the price of a given stock on the ith day.\n\nOn each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day.\n\nFind and return the maximum profit you can achieve.", "examples": "Input: prices = [7,1,5,3,6,4]\nOutput: 7\nExplanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\nThen buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.\nTotal profit is 4 + 3 = 7.\nInput: prices = [7,6,4,3,1]\nOutput: 0\nExplanation: There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0.", "link": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/", "difficulty": "Medium", "categories": ["Dynamic_programming"], "code": "from typing import List\ndef maxProfit(prices: List[int]) -> int:\n    cur_hold, cur_not_hold = -float('inf'), 0\n    \n    for stock_price in prices:\n        \n        prev_hold, prev_not_hold = cur_hold, cur_not_hold\n        cur_hold = max( prev_hold, prev_not_hold - stock_price )\n        cur_not_hold = max( prev_not_hold, prev_hold + stock_price )\n    return cur_not_hold", "asserts": ["assert maxProfit([1,2,3,4,5])==4", "assert maxProfit([1,2,100,2,1]) == 99"]}, {"author": "Calvin", "UUID": "51a5caf9-241f-4de3-9ee2-9420490b73d7", "question": "Given a set[] of non-negative integers and a value sum, return the subset of the given set whose sum is equal to the given sum or None if one doesn't exist\n", "examples": "Input: set = [1, 2, 3, 4, 5], sum = 10\nOutput: [1, 2, 3, 4]", "link": "https://www.geeksforgeeks.org/subset-sum-problem-dp-25/", "difficulty": null, "categories": ["Dynamic_programming"], "code": "def subsetsum(fullset: list, target_sum: int) -> set:\n    def subsetSum_helper(cur_idx: int, fullset: list, target_sum: int, subset: list):\n        if target_sum == 0:\n            return subset\n        if (cur_idx == len(fullset)):\n            return None\n        excluding = subsetSum_helper(cur_idx + 1, fullset, target_sum, subset)\n          \n        if excluding is not None:\n            return excluding\n        elif fullset[cur_idx] <= target_sum:\n            subset.append(fullset[cur_idx])\n            including = subsetSum_helper(cur_idx + 1, fullset, target_sum - fullset[cur_idx], subset)\n            if including!=None:\n                return including\n            else:\n                subset.pop()\n            return None\n    return subsetSum_helper(0, fullset, target_sum, [])\n", "asserts": ["assert set(subsetsum([3, 34, 4, 12, 5, 2], 9)) == {4,5}", "assert subsetsum([1, 8, 2, 7, 4], 14) == [8, 2, 4]", "assert subsetsum([10, 12, 15, 6, 19], 21) == [15, 6]", "assert subsetsum([5, 10, 12, 13, 15, 18], 30) == [12, 18]", "assert subsetsum([5, 3, 9, 12, 6, 15], 27) == [12, 15]", "assert subsetsum([2, 3, 7, 8, 10], 11) == [3, 8]", "assert subsetsum([6, 2, 7, 11, 8], 16) == [6, 2, 8]", "assert subsetsum([5, 7, 1, 14, 6], 13) == [7, 6]", "assert subsetsum([1], 1) == [1]", "assert subsetsum([2, 5, 8, 4], 0) == []", "assert subsetsum([], 5) == None", "assert subsetsum([-1, -2, -3, -4, -5], -10) == None  # Negative numbers are not allowed according to the question", "assert subsetsum([4, 1, 2, 5, 12, 7], 9) == [2, 7]", "assert subsetsum([3, 5, 8, 4], 22) == None  # Sum exceeds the sum of all elements"]}], "category": "Dynamic_programming", "prompt_tokens": 1031, "total_tokens": 1289, "completion_tokens": 258, "completion": "You are given an array of non-negative integers nums. You are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position. Determine if you are able to reach the last index.\n\nReturn true if you can reach the last index, otherwise return false.\n\n###Code: \n\ndef canJump(nums: List[int]) -> bool:\n    last_position = len(nums) - 1\n    for i in range(len(nums) - 1, -1, -1):\n        if i + nums[i] >= last_position:\n            last_position = i\n    return last_position == 0\n\n###Testcases: \n\nassert canJump([2,3,1,1,4]) == True\nassert canJump([3,2,1,0,4]) == False\nassert canJump([2,0,0]) == True\nassert canJump([0]) == True\nassert canJump([1,1,2,2,0,1,1]) == True\nassert canJump([5,4,3,2,1,0,0,0,0,1]) == False\nassert canJump([1,2,3]) == True\n\n[/Example 3]", "temperature": 0.722, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Calvin", "UUID": "e35d1110-85e8-4f50-80aa-91eb976b310b", "question": "Return the factorial of a given number n", "examples": "Input: 5\nOutput: 120\n\nInput: 6\nOutput: 720", "link": NaN, "difficulty": null, "categories": ["Dynamic_programming"], "code": "\ndef fact(n: int) -> int:\n  if n <= 1:\n    return 1\n  return n*fact(n-1)\n", "asserts": ["assert fact(5) == 120", "assert fact(0) == 1", "assert fact(1) == 1", "assert fact(3) == 6", "assert fact(7) == 5040", "assert fact(10) == 3628800", "assert fact(4) == 24", "assert fact(8) == 40320", "assert fact(2) == 2", "assert fact(11) == 39916800"]}, {"author": "Hafeez", "UUID": "296ab89e-7208-4f6f-bed1-d623f30e32c9", "question": "Coin Change II: You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.\n\nReturn the number of combinations that make up that amount. If that amount of money cannot be made up by any combination of the coins, return 0.\n\nYou may assume that you have an infinite number of each kind of coin.\n\nThe answer is guaranteed to fit into a signed 32-bit integer.", "examples": "Input: amount = 5, coins = [1,2,5]\nOutput: 4\nExplanation: there are four ways to make up the amount:\n5=5\n5=2+2+1\n5=2+1+1+1\n5=1+1+1+1+1\nInput: amount = 3, coins = [2]\nOutput: 0\nExplanation: the amount of 3 cannot be made up just with coins of 2.", "link": "https://leetcode.com/problems/coin-change-ii/description/", "difficulty": "Medium", "categories": ["Dynamic_programming"], "code": "from typing import List\ndef change(amount: int, coins: List[int]) -> int:\n    def numberOfWays(i: int, amount: int) -> int:\n        if amount == 0:\n            return 1\n        if i == len(coins):\n            return 0\n        if memo[i][amount] != -1:\n            return memo[i][amount]\n\n        if coins[i] > amount:\n            memo[i][amount] = numberOfWays(i + 1, amount)\n        else:\n            memo[i][amount] = numberOfWays(i, amount - coins[i]) + numberOfWays(i + 1, amount)\n        \n        return memo[i][amount]\n\n    memo = [[-1] * (amount + 1) for _ in range(len(coins))]\n    return numberOfWays(0, amount)", "asserts": ["assert change(10,[10])==1", "assert change(0, [1, 2, 5]) == 1  # Edge case: trying to make 0 with any coins should always return 1", "assert change(11, [5]) == 0  # Amount cannot be made up with given coins", "assert change(0, []) == 1  # Edge case: trying to make 0 without any coins, should return 1 as there's one way of making 0 with no coins", "assert change(5, [5, 1]) == 2  # Amount can be made with given coins: [5], [1, 1, 1, 1, 1]"]}], "category": "Dynamic_programming", "prompt_tokens": 767, "total_tokens": 980, "completion_tokens": 213, "completion": "Find the maximum sum of a subarray in an array of integers.\n\n###Code: \n\ndef max_subarray_sum(nums):\n    max_sum = float('-inf')\n    current_sum = 0\n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    return max_sum\n\n###Testcases: \n\nassert max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) == 6\nassert max_subarray_sum([1]) == 1\nassert max_subarray_sum([5, 4, -1, 7, 8]) == 23\nassert max_subarray_sum([-2, -3, 4, -1, -2, 1, 5, -3]) == 7\nassert max_subarray_sum([-1, -2, -3, -4, -5]) == -1\n\n[/Example 3]", "temperature": 0.796, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Hafeez", "UUID": "296ab89e-7208-4f6f-bed1-d623f30e32c9", "question": "Coin Change II: You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.\n\nReturn the number of combinations that make up that amount. If that amount of money cannot be made up by any combination of the coins, return 0.\n\nYou may assume that you have an infinite number of each kind of coin.\n\nThe answer is guaranteed to fit into a signed 32-bit integer.", "examples": "Input: amount = 5, coins = [1,2,5]\nOutput: 4\nExplanation: there are four ways to make up the amount:\n5=5\n5=2+2+1\n5=2+1+1+1\n5=1+1+1+1+1\nInput: amount = 3, coins = [2]\nOutput: 0\nExplanation: the amount of 3 cannot be made up just with coins of 2.", "link": "https://leetcode.com/problems/coin-change-ii/description/", "difficulty": "Medium", "categories": ["Dynamic_programming"], "code": "from typing import List\ndef change(amount: int, coins: List[int]) -> int:\n    def numberOfWays(i: int, amount: int) -> int:\n        if amount == 0:\n            return 1\n        if i == len(coins):\n            return 0\n        if memo[i][amount] != -1:\n            return memo[i][amount]\n\n        if coins[i] > amount:\n            memo[i][amount] = numberOfWays(i + 1, amount)\n        else:\n            memo[i][amount] = numberOfWays(i, amount - coins[i]) + numberOfWays(i + 1, amount)\n        \n        return memo[i][amount]\n\n    memo = [[-1] * (amount + 1) for _ in range(len(coins))]\n    return numberOfWays(0, amount)", "asserts": ["assert change(10,[10])==1", "assert change(0, [1, 2, 5]) == 1  # Edge case: trying to make 0 with any coins should always return 1", "assert change(11, [5]) == 0  # Amount cannot be made up with given coins", "assert change(0, []) == 1  # Edge case: trying to make 0 without any coins, should return 1 as there's one way of making 0 with no coins", "assert change(5, [5, 1]) == 2  # Amount can be made with given coins: [5], [1, 1, 1, 1, 1]"]}, {"author": "Calvin", "UUID": "51a5caf9-241f-4de3-9ee2-9420490b73d7", "question": "Given a set[] of non-negative integers and a value sum, return the subset of the given set whose sum is equal to the given sum or None if one doesn't exist\n", "examples": "Input: set = [1, 2, 3, 4, 5], sum = 10\nOutput: [1, 2, 3, 4]", "link": "https://www.geeksforgeeks.org/subset-sum-problem-dp-25/", "difficulty": null, "categories": ["Dynamic_programming"], "code": "def subsetsum(fullset: list, target_sum: int) -> set:\n    def subsetSum_helper(cur_idx: int, fullset: list, target_sum: int, subset: list):\n        if target_sum == 0:\n            return subset\n        if (cur_idx == len(fullset)):\n            return None\n        excluding = subsetSum_helper(cur_idx + 1, fullset, target_sum, subset)\n          \n        if excluding is not None:\n            return excluding\n        elif fullset[cur_idx] <= target_sum:\n            subset.append(fullset[cur_idx])\n            including = subsetSum_helper(cur_idx + 1, fullset, target_sum - fullset[cur_idx], subset)\n            if including!=None:\n                return including\n            else:\n                subset.pop()\n            return None\n    return subsetSum_helper(0, fullset, target_sum, [])\n", "asserts": ["assert set(subsetsum([3, 34, 4, 12, 5, 2], 9)) == {4,5}", "assert subsetsum([1, 8, 2, 7, 4], 14) == [8, 2, 4]", "assert subsetsum([10, 12, 15, 6, 19], 21) == [15, 6]", "assert subsetsum([5, 10, 12, 13, 15, 18], 30) == [12, 18]", "assert subsetsum([5, 3, 9, 12, 6, 15], 27) == [12, 15]", "assert subsetsum([2, 3, 7, 8, 10], 11) == [3, 8]", "assert subsetsum([6, 2, 7, 11, 8], 16) == [6, 2, 8]", "assert subsetsum([5, 7, 1, 14, 6], 13) == [7, 6]", "assert subsetsum([1], 1) == [1]", "assert subsetsum([2, 5, 8, 4], 0) == []", "assert subsetsum([], 5) == None", "assert subsetsum([-1, -2, -3, -4, -5], -10) == None  # Negative numbers are not allowed according to the question", "assert subsetsum([4, 1, 2, 5, 12, 7], 9) == [2, 7]", "assert subsetsum([3, 5, 8, 4], 22) == None  # Sum exceeds the sum of all elements"]}], "category": "Dynamic_programming", "prompt_tokens": 1226, "total_tokens": 1627, "completion_tokens": 401, "completion": "Find the length of the longest increasing subsequence in an integer array.\n\n###Code:\n\n```python\ndef lengthOfLIS(nums: List[int]) -> int:\n    if not nums:\n        return 0\n    \n    dp = [1] * len(nums)\n    \n    for i in range(len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    \n    return max(dp)\n```\n\n###Testcases:\n\n```python\nassert lengthOfLIS([10, 9, 2, 5, 3, 7, 101, 18]) == 4  # The longest increasing subsequence is [2, 3, 7, 101]\nassert lengthOfLIS([0, 1, 0, 3, 2, 3]) == 4  # The longest increasing subsequence is [0, 1, 2, 3]\nassert lengthOfLIS([7, 7, 7, 7, 7, 7, 7]) == 1  # The longest increasing subsequence is [7]\nassert lengthOfLIS([4, 10, 4, 3, 8, 9]) == 3  # The longest increasing subsequence is [4, 8, 9]\nassert lengthOfLIS([1, 3, 6, 7, 9, 4, 10, 5, 6]) == 6  # The longest increasing subsequence is [1, 3, 6, 7, 9, 10]\nassert lengthOfLIS([10, 9, 2, 5, 3, 4]) == 3  # The longest increasing subsequence is [2, 3, 4]\n```\n\n[/Example 3]", "temperature": 0.688, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Calvin", "UUID": "5e7011e5-fee4-4c1a-a98f-3b81e50508cc", "question": "Return nth number in the fibonacci sequence", "examples": "Input: 9\nOutput: 34\n\nInput: 7\nOutput: 13", "link": NaN, "difficulty": null, "categories": ["Dynamic_programming"], "code": "def fibonacci(n: int) -> int:\n    a = 0\n    b = 1\n    if n < 0:\n        print(\"Incorrect input\")\n    elif n == 0:\n        return a\n    elif n == 1:\n        return b\n    else:\n        for i in range(2, n+1):\n            c = a + b\n            a = b\n            b = c\n        return b\n    b = c\n    return fib(n-1, a, b)\n", "asserts": ["assert fibonacci(9) == 34", "assert fibonacci(10) == 55", "assert fibonacci(5) == 5", "assert fibonacci(2) == 1", "assert fibonacci(0) == 0", "assert fibonacci(11) == 89", "assert fibonacci(15) == 610", "assert fibonacci(20) == 6765", "assert fibonacci(25) == 75025", "assert fibonacci(3) == 2", "assert fibonacci(1) == 1", "assert fibonacci(6) == 8", "assert fibonacci(30) == 832040", "assert fibonacci(35) == 9227465", "assert fibonacci(40) == 102334155"]}, {"author": "Hafeez", "UUID": "d695e67c-5b0e-4235-8406-30ee6be61173", "question": "N-th Tribonacci Number: The Tribonacci sequence Tn is defined as follows: \n\nT0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n >= 0.\n\nGiven n, return the value of Tn.", "examples": "Input: n = 4\nOutput: 4\nExplanation:\nT_3 = 0 + 1 + 1 = 2\nT_4 = 1 + 1 + 2 = 4", "link": "https://leetcode.com/problems/n-th-tribonacci-number/description/", "difficulty": "Easy", "categories": ["Dynamic_programming"], "code": "def tribonacci(n: int) -> int:\n    dp = {0: 0, 1: 1, 2: 1}\n    def dfs(i):\n        if i in dp:\n            return dp[i]\n        dp[i] = dfs(i - 1) + dfs(i - 2) + dfs(i - 3)\n        return dp[i]\n    \n    return dfs(n)", "asserts": ["assert tribonacci(25)==1389537", "assert tribonacci(0) == 0", "assert tribonacci(1) == 1", "assert tribonacci(2) == 1", "assert tribonacci(3) == 2", "assert tribonacci(5) == 7", "assert tribonacci(7) == 24", "assert tribonacci(10) == 149", "assert tribonacci(15) == 3136", "assert tribonacci(30) == 29249425"]}], "category": "Dynamic_programming", "prompt_tokens": 735, "total_tokens": 1066, "completion_tokens": 331, "completion": "Find the minimum cost to reach the end of an array by jumping from one index to another. Each element in the array represents the cost to step on that index. You can jump to the next position or the position after that, with the cost of the current position.\n\n###Code: \n\n```python\ndef minCostClimbingStairs(cost) -> int:\n    n = len(cost)\n    dp = [0] * (n+1)\n    for i in range(2, n+1):\n        dp[i] = min(dp[i-1] + cost[i-1], dp[i-2] + cost[i-2])\n    return dp[n]\n```\n\n###Testcases: \n\n```python\nassert minCostClimbingStairs([10, 15, 20]) == 15\nassert minCostClimbingStairs([1, 100, 1, 1, 1, 100, 1, 1, 100, 1]) == 6\nassert minCostClimbingStairs([0, 0, 0, 1]) == 0\nassert minCostClimbingStairs([1, 0, 0, 0]) == 0\nassert minCostClimbingStairs([0, 0, 1, 1]) == 0\nassert minCostClimbingStairs([1, 1, 1, 0]) == 1\nassert minCostClimbingStairs([0, 0, 0, 0]) == 0\n```", "temperature": 0.855, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Calvin", "UUID": "51a5caf9-241f-4de3-9ee2-9420490b73d7", "question": "Given a set[] of non-negative integers and a value sum, return the subset of the given set whose sum is equal to the given sum or None if one doesn't exist\n", "examples": "Input: set = [1, 2, 3, 4, 5], sum = 10\nOutput: [1, 2, 3, 4]", "link": "https://www.geeksforgeeks.org/subset-sum-problem-dp-25/", "difficulty": null, "categories": ["Dynamic_programming"], "code": "def subsetsum(fullset: list, target_sum: int) -> set:\n    def subsetSum_helper(cur_idx: int, fullset: list, target_sum: int, subset: list):\n        if target_sum == 0:\n            return subset\n        if (cur_idx == len(fullset)):\n            return None\n        excluding = subsetSum_helper(cur_idx + 1, fullset, target_sum, subset)\n          \n        if excluding is not None:\n            return excluding\n        elif fullset[cur_idx] <= target_sum:\n            subset.append(fullset[cur_idx])\n            including = subsetSum_helper(cur_idx + 1, fullset, target_sum - fullset[cur_idx], subset)\n            if including!=None:\n                return including\n            else:\n                subset.pop()\n            return None\n    return subsetSum_helper(0, fullset, target_sum, [])\n", "asserts": ["assert set(subsetsum([3, 34, 4, 12, 5, 2], 9)) == {4,5}", "assert subsetsum([1, 8, 2, 7, 4], 14) == [8, 2, 4]", "assert subsetsum([10, 12, 15, 6, 19], 21) == [15, 6]", "assert subsetsum([5, 10, 12, 13, 15, 18], 30) == [12, 18]", "assert subsetsum([5, 3, 9, 12, 6, 15], 27) == [12, 15]", "assert subsetsum([2, 3, 7, 8, 10], 11) == [3, 8]", "assert subsetsum([6, 2, 7, 11, 8], 16) == [6, 2, 8]", "assert subsetsum([5, 7, 1, 14, 6], 13) == [7, 6]", "assert subsetsum([1], 1) == [1]", "assert subsetsum([2, 5, 8, 4], 0) == []", "assert subsetsum([], 5) == None", "assert subsetsum([-1, -2, -3, -4, -5], -10) == None  # Negative numbers are not allowed according to the question", "assert subsetsum([4, 1, 2, 5, 12, 7], 9) == [2, 7]", "assert subsetsum([3, 5, 8, 4], 22) == None  # Sum exceeds the sum of all elements"]}, {"author": "Hafeez", "UUID": "d695e67c-5b0e-4235-8406-30ee6be61173", "question": "N-th Tribonacci Number: The Tribonacci sequence Tn is defined as follows: \n\nT0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n >= 0.\n\nGiven n, return the value of Tn.", "examples": "Input: n = 4\nOutput: 4\nExplanation:\nT_3 = 0 + 1 + 1 = 2\nT_4 = 1 + 1 + 2 = 4", "link": "https://leetcode.com/problems/n-th-tribonacci-number/description/", "difficulty": "Easy", "categories": ["Dynamic_programming"], "code": "def tribonacci(n: int) -> int:\n    dp = {0: 0, 1: 1, 2: 1}\n    def dfs(i):\n        if i in dp:\n            return dp[i]\n        dp[i] = dfs(i - 1) + dfs(i - 2) + dfs(i - 3)\n        return dp[i]\n    \n    return dfs(n)", "asserts": ["assert tribonacci(25)==1389537", "assert tribonacci(0) == 0", "assert tribonacci(1) == 1", "assert tribonacci(2) == 1", "assert tribonacci(3) == 2", "assert tribonacci(5) == 7", "assert tribonacci(7) == 24", "assert tribonacci(10) == 149", "assert tribonacci(15) == 3136", "assert tribonacci(30) == 29249425"]}], "category": "Dynamic_programming", "prompt_tokens": 1071, "total_tokens": 1439, "completion_tokens": 368, "completion": "Find the minimum number of operations needed to transform string1 into string2. The allowed operations are insertion, deletion, or substitution of a single character.\n\n###Code: \n\ndef min_edit_distance(s1: str, s2: str) -> int:\n    m, n = len(s1), len(s2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    \n    for i in range(m + 1):\n        for j in range(n + 1):\n            if i == 0:\n                dp[i][j] = j\n            elif j == 0:\n                dp[i][j] = i\n            elif s1[i - 1] == s2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1]\n            else:\n                dp[i][j] = 1 + min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1])\n    \n    return dp[m][n]\n\n###Testcases: \n\nassert min_edit_distance(\"kitten\", \"sitting\") == 3\nassert min_edit_distance(\"intention\", \"execution\") == 5\nassert min_edit_distance(\"horse\", \"ros\") == 3\nassert min_edit_distance(\"abc\", \"abc\") == 0\nassert min_edit_distance(\"abc\", \"def\") == 3\nassert min_edit_distance(\"abc\", \"abcd\") == 1\nassert min_edit_distance(\"abc\", \"ab\") == 1\nassert min_edit_distance(\"\", \"abc\") == 3\nassert min_edit_distance(\"abc\", \"\") == 3\nassert min_edit_distance(\"\", \"\") == 0\n\n[/Example 3]", "temperature": 0.68, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Hafeez", "UUID": "38dca76c-ee6c-4c71-83a9-89240828a3b7", "question": "Best Time to Buy and Sell Stock II: You are given an integer array prices where prices[i] is the price of a given stock on the ith day.\n\nOn each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day.\n\nFind and return the maximum profit you can achieve.", "examples": "Input: prices = [7,1,5,3,6,4]\nOutput: 7\nExplanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\nThen buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.\nTotal profit is 4 + 3 = 7.\nInput: prices = [7,6,4,3,1]\nOutput: 0\nExplanation: There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0.", "link": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/", "difficulty": "Medium", "categories": ["Dynamic_programming"], "code": "from typing import List\ndef maxProfit(prices: List[int]) -> int:\n    cur_hold, cur_not_hold = -float('inf'), 0\n    \n    for stock_price in prices:\n        \n        prev_hold, prev_not_hold = cur_hold, cur_not_hold\n        cur_hold = max( prev_hold, prev_not_hold - stock_price )\n        cur_not_hold = max( prev_not_hold, prev_hold + stock_price )\n    return cur_not_hold", "asserts": ["assert maxProfit([1,2,3,4,5])==4", "assert maxProfit([1,2,100,2,1]) == 99"]}, {"author": "Hafeez", "UUID": "296ab89e-7208-4f6f-bed1-d623f30e32c9", "question": "Coin Change II: You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.\n\nReturn the number of combinations that make up that amount. If that amount of money cannot be made up by any combination of the coins, return 0.\n\nYou may assume that you have an infinite number of each kind of coin.\n\nThe answer is guaranteed to fit into a signed 32-bit integer.", "examples": "Input: amount = 5, coins = [1,2,5]\nOutput: 4\nExplanation: there are four ways to make up the amount:\n5=5\n5=2+2+1\n5=2+1+1+1\n5=1+1+1+1+1\nInput: amount = 3, coins = [2]\nOutput: 0\nExplanation: the amount of 3 cannot be made up just with coins of 2.", "link": "https://leetcode.com/problems/coin-change-ii/description/", "difficulty": "Medium", "categories": ["Dynamic_programming"], "code": "from typing import List\ndef change(amount: int, coins: List[int]) -> int:\n    def numberOfWays(i: int, amount: int) -> int:\n        if amount == 0:\n            return 1\n        if i == len(coins):\n            return 0\n        if memo[i][amount] != -1:\n            return memo[i][amount]\n\n        if coins[i] > amount:\n            memo[i][amount] = numberOfWays(i + 1, amount)\n        else:\n            memo[i][amount] = numberOfWays(i, amount - coins[i]) + numberOfWays(i + 1, amount)\n        \n        return memo[i][amount]\n\n    memo = [[-1] * (amount + 1) for _ in range(len(coins))]\n    return numberOfWays(0, amount)", "asserts": ["assert change(10,[10])==1", "assert change(0, [1, 2, 5]) == 1  # Edge case: trying to make 0 with any coins should always return 1", "assert change(11, [5]) == 0  # Amount cannot be made up with given coins", "assert change(0, []) == 1  # Edge case: trying to make 0 without any coins, should return 1 as there's one way of making 0 with no coins", "assert change(5, [5, 1]) == 2  # Amount can be made with given coins: [5], [1, 1, 1, 1, 1]"]}], "category": "Dynamic_programming", "prompt_tokens": 848, "total_tokens": 1018, "completion_tokens": 170, "completion": "Maximum Subarray: Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.\n\n###Code: \n\nfrom typing import List\ndef maxSubArray(nums: List[int]) -> int:\n    max_sum = float('-inf')\n    curr_sum = 0\n\n    for num in nums:\n        curr_sum = max(num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n\n    return max_sum\n\n###Testcases: \n\nassert maxSubArray([-2,1,-3,4,-1,2,1,-5,4]) == 6\nassert maxSubArray([1]) == 1\nassert maxSubArray([5,4,-1,7,8]) == 23\n\n[/Example 3]", "temperature": 0.669, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Calvin", "UUID": "51a5caf9-241f-4de3-9ee2-9420490b73d7", "question": "Given a set[] of non-negative integers and a value sum, return the subset of the given set whose sum is equal to the given sum or None if one doesn't exist\n", "examples": "Input: set = [1, 2, 3, 4, 5], sum = 10\nOutput: [1, 2, 3, 4]", "link": "https://www.geeksforgeeks.org/subset-sum-problem-dp-25/", "difficulty": null, "categories": ["Dynamic_programming"], "code": "def subsetsum(fullset: list, target_sum: int) -> set:\n    def subsetSum_helper(cur_idx: int, fullset: list, target_sum: int, subset: list):\n        if target_sum == 0:\n            return subset\n        if (cur_idx == len(fullset)):\n            return None\n        excluding = subsetSum_helper(cur_idx + 1, fullset, target_sum, subset)\n          \n        if excluding is not None:\n            return excluding\n        elif fullset[cur_idx] <= target_sum:\n            subset.append(fullset[cur_idx])\n            including = subsetSum_helper(cur_idx + 1, fullset, target_sum - fullset[cur_idx], subset)\n            if including!=None:\n                return including\n            else:\n                subset.pop()\n            return None\n    return subsetSum_helper(0, fullset, target_sum, [])\n", "asserts": ["assert set(subsetsum([3, 34, 4, 12, 5, 2], 9)) == {4,5}", "assert subsetsum([1, 8, 2, 7, 4], 14) == [8, 2, 4]", "assert subsetsum([10, 12, 15, 6, 19], 21) == [15, 6]", "assert subsetsum([5, 10, 12, 13, 15, 18], 30) == [12, 18]", "assert subsetsum([5, 3, 9, 12, 6, 15], 27) == [12, 15]", "assert subsetsum([2, 3, 7, 8, 10], 11) == [3, 8]", "assert subsetsum([6, 2, 7, 11, 8], 16) == [6, 2, 8]", "assert subsetsum([5, 7, 1, 14, 6], 13) == [7, 6]", "assert subsetsum([1], 1) == [1]", "assert subsetsum([2, 5, 8, 4], 0) == []", "assert subsetsum([], 5) == None", "assert subsetsum([-1, -2, -3, -4, -5], -10) == None  # Negative numbers are not allowed according to the question", "assert subsetsum([4, 1, 2, 5, 12, 7], 9) == [2, 7]", "assert subsetsum([3, 5, 8, 4], 22) == None  # Sum exceeds the sum of all elements"]}, {"author": "Hafeez", "UUID": "d695e67c-5b0e-4235-8406-30ee6be61173", "question": "N-th Tribonacci Number: The Tribonacci sequence Tn is defined as follows: \n\nT0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n >= 0.\n\nGiven n, return the value of Tn.", "examples": "Input: n = 4\nOutput: 4\nExplanation:\nT_3 = 0 + 1 + 1 = 2\nT_4 = 1 + 1 + 2 = 4", "link": "https://leetcode.com/problems/n-th-tribonacci-number/description/", "difficulty": "Easy", "categories": ["Dynamic_programming"], "code": "def tribonacci(n: int) -> int:\n    dp = {0: 0, 1: 1, 2: 1}\n    def dfs(i):\n        if i in dp:\n            return dp[i]\n        dp[i] = dfs(i - 1) + dfs(i - 2) + dfs(i - 3)\n        return dp[i]\n    \n    return dfs(n)", "asserts": ["assert tribonacci(25)==1389537", "assert tribonacci(0) == 0", "assert tribonacci(1) == 1", "assert tribonacci(2) == 1", "assert tribonacci(3) == 2", "assert tribonacci(5) == 7", "assert tribonacci(7) == 24", "assert tribonacci(10) == 149", "assert tribonacci(15) == 3136", "assert tribonacci(30) == 29249425"]}], "category": "Dynamic_programming", "prompt_tokens": 1071, "total_tokens": 1472, "completion_tokens": 401, "completion": "Find the length of the longest increasing subsequence in the given list of integers.\n\n###Code:\n\n```python\ndef lengthOfLIS(nums: List[int]) -> int:\n    if not nums:\n        return 0\n    dp = [1] * len(nums)\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n```\n\n###Testcases: \n\n```python\nassert lengthOfLIS([10, 9, 2, 5, 3, 7, 101, 18]) == 4\nassert lengthOfLIS([0, 1, 0, 3, 2, 3]) == 4\nassert lengthOfLIS([7, 7, 7, 7, 7, 7, 7]) == 1\nassert lengthOfLIS([4, 10, 4, 3, 8, 9]) == 3\nassert lengthOfLIS([1, 3, 6, 7, 9, 4, 10, 5, 6]) == 6\nassert lengthOfLIS([10, 22, 9, 33, 21, 50, 41, 60, 80]) == 6\nassert lengthOfLIS([3, 2, 6, 4, 5, 1]) == 3\nassert lengthOfLIS([1, 2, 3, 4, 5]) == 5\nassert lengthOfLIS([5, 4, 3, 2, 1]) == 1\nassert lengthOfLIS([5]) == 1\nassert lengthOfLIS([]) == 0\n```", "temperature": 0.917, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Calvin", "UUID": "5e7011e5-fee4-4c1a-a98f-3b81e50508cc", "question": "Return nth number in the fibonacci sequence", "examples": "Input: 9\nOutput: 34\n\nInput: 7\nOutput: 13", "link": NaN, "difficulty": null, "categories": ["Dynamic_programming"], "code": "def fibonacci(n: int) -> int:\n    a = 0\n    b = 1\n    if n < 0:\n        print(\"Incorrect input\")\n    elif n == 0:\n        return a\n    elif n == 1:\n        return b\n    else:\n        for i in range(2, n+1):\n            c = a + b\n            a = b\n            b = c\n        return b\n    b = c\n    return fib(n-1, a, b)\n", "asserts": ["assert fibonacci(9) == 34", "assert fibonacci(10) == 55", "assert fibonacci(5) == 5", "assert fibonacci(2) == 1", "assert fibonacci(0) == 0", "assert fibonacci(11) == 89", "assert fibonacci(15) == 610", "assert fibonacci(20) == 6765", "assert fibonacci(25) == 75025", "assert fibonacci(3) == 2", "assert fibonacci(1) == 1", "assert fibonacci(6) == 8", "assert fibonacci(30) == 832040", "assert fibonacci(35) == 9227465", "assert fibonacci(40) == 102334155"]}, {"author": "Calvin", "UUID": "e35d1110-85e8-4f50-80aa-91eb976b310b", "question": "Return the factorial of a given number n", "examples": "Input: 5\nOutput: 120\n\nInput: 6\nOutput: 720", "link": NaN, "difficulty": null, "categories": ["Dynamic_programming"], "code": "\ndef fact(n: int) -> int:\n  if n <= 1:\n    return 1\n  return n*fact(n-1)\n", "asserts": ["assert fact(5) == 120", "assert fact(0) == 1", "assert fact(1) == 1", "assert fact(3) == 6", "assert fact(7) == 5040", "assert fact(10) == 3628800", "assert fact(4) == 24", "assert fact(8) == 40320", "assert fact(2) == 2", "assert fact(11) == 39916800"]}], "category": "Dynamic_programming", "prompt_tokens": 614, "total_tokens": 1154, "completion_tokens": 540, "completion": "Return the maximum sum of a subarray from a given array of integers\n\n###Code: \n\n```python\ndef max_subarray_sum(arr: List[int]) -> int:\n    max_ending_here = max_so_far = arr[0]\n    for i in arr[1:]:\n        max_ending_here = max(i, max_ending_here + i)\n        max_so_far = max(max_so_far, max_ending_here)\n    return max_so_far\n```\n\n###Testcases: \n\n```python\nassert max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) == 6\nassert max_subarray_sum([1, 2, 3, -2, 5]) == 9\nassert max_subarray_sum([-1, -2, -3, -4]) == -1\nassert max_subarray_sum([5, -1, -5, 3, 1]) == 5\nassert max_subarray_sum([3, -2, 5, -1, 1]) == 6\nassert max_subarray_sum([2, -1, 2, 3, -2]) == 6\nassert max_subarray_sum([2, -3, 4, -1, -2, 1, 5, -3]) == 7\nassert max_subarray_sum([-2, -3, 4, -1, -2, 1, 5, -3]) == 7\nassert max_subarray_sum([1, -2, 3, 4, -1, 2, 1, -5, 4]) == 10\nassert max_subarray_sum([1, 2, 3, -2, 5, -3, 4, -1]) == 10\nassert max_subarray_sum([-2, -5, 6, -2, -3, 1, 5, -6]) == 7\nassert max_subarray_sum([8, -1, -2, 4, -5, 6, 7, -8]) == 19\nassert max_subarray_sum([3, 4, 5, -1, -2, 7]) == 16\nassert max_subarray_sum([1, 2, -5, -3, 2]) == 3\nassert max_subarray_sum([2, 3, -4, 5, -8]) == 6\n```\n\n[/Example 3]", "temperature": 0.775, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Hafeez", "UUID": "d695e67c-5b0e-4235-8406-30ee6be61173", "question": "N-th Tribonacci Number: The Tribonacci sequence Tn is defined as follows: \n\nT0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n >= 0.\n\nGiven n, return the value of Tn.", "examples": "Input: n = 4\nOutput: 4\nExplanation:\nT_3 = 0 + 1 + 1 = 2\nT_4 = 1 + 1 + 2 = 4", "link": "https://leetcode.com/problems/n-th-tribonacci-number/description/", "difficulty": "Easy", "categories": ["Dynamic_programming"], "code": "def tribonacci(n: int) -> int:\n    dp = {0: 0, 1: 1, 2: 1}\n    def dfs(i):\n        if i in dp:\n            return dp[i]\n        dp[i] = dfs(i - 1) + dfs(i - 2) + dfs(i - 3)\n        return dp[i]\n    \n    return dfs(n)", "asserts": ["assert tribonacci(25)==1389537", "assert tribonacci(0) == 0", "assert tribonacci(1) == 1", "assert tribonacci(2) == 1", "assert tribonacci(3) == 2", "assert tribonacci(5) == 7", "assert tribonacci(7) == 24", "assert tribonacci(10) == 149", "assert tribonacci(15) == 3136", "assert tribonacci(30) == 29249425"]}, {"author": "Calvin", "UUID": "e35d1110-85e8-4f50-80aa-91eb976b310b", "question": "Return the factorial of a given number n", "examples": "Input: 5\nOutput: 120\n\nInput: 6\nOutput: 720", "link": NaN, "difficulty": null, "categories": ["Dynamic_programming"], "code": "\ndef fact(n: int) -> int:\n  if n <= 1:\n    return 1\n  return n*fact(n-1)\n", "asserts": ["assert fact(5) == 120", "assert fact(0) == 1", "assert fact(1) == 1", "assert fact(3) == 6", "assert fact(7) == 5040", "assert fact(10) == 3628800", "assert fact(4) == 24", "assert fact(8) == 40320", "assert fact(2) == 2", "assert fact(11) == 39916800"]}], "category": "Dynamic_programming", "prompt_tokens": 612, "total_tokens": 1036, "completion_tokens": 424, "completion": "Find the maximum sum of a subarray within an array of integers.\n\n###Code: \n\n```python\ndef max_subarray_sum(nums: List[int]) -> int:\n    max_sum = nums[0]\n    current_sum = nums[0]\n    for num in nums[1:]:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    return max_sum\n```\n\n###Testcases: \n\n```python\nassert max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) == 6\nassert max_subarray_sum([1]) == 1\nassert max_subarray_sum([5, 4, -1, 7, 8]) == 23\nassert max_subarray_sum([-2, -3, 4, -1, -2, 1, 5, -3]) == 7\nassert max_subarray_sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == 55\nassert max_subarray_sum([-1, -2, -3, -4, -5, -6, -7, -8, -9, -10]) == -1\nassert max_subarray_sum([10, -7, 4, 6, -8, 10]) == 15\nassert max_subarray_sum([-1, -2, -3, 4, -5, -6, -7, -8, -9, -10]) == 4\nassert max_subarray_sum([1, -1, 1, -1, 1, -1, 1, -1, 1, -1]) == 1\nassert max_subarray_sum([-1, -2, -3, -4, -5, -6, 10, -8, -9, -10]) == 10\n```", "temperature": 0.732, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Calvin", "UUID": "51a5caf9-241f-4de3-9ee2-9420490b73d7", "question": "Given a set[] of non-negative integers and a value sum, return the subset of the given set whose sum is equal to the given sum or None if one doesn't exist\n", "examples": "Input: set = [1, 2, 3, 4, 5], sum = 10\nOutput: [1, 2, 3, 4]", "link": "https://www.geeksforgeeks.org/subset-sum-problem-dp-25/", "difficulty": null, "categories": ["Dynamic_programming"], "code": "def subsetsum(fullset: list, target_sum: int) -> set:\n    def subsetSum_helper(cur_idx: int, fullset: list, target_sum: int, subset: list):\n        if target_sum == 0:\n            return subset\n        if (cur_idx == len(fullset)):\n            return None\n        excluding = subsetSum_helper(cur_idx + 1, fullset, target_sum, subset)\n          \n        if excluding is not None:\n            return excluding\n        elif fullset[cur_idx] <= target_sum:\n            subset.append(fullset[cur_idx])\n            including = subsetSum_helper(cur_idx + 1, fullset, target_sum - fullset[cur_idx], subset)\n            if including!=None:\n                return including\n            else:\n                subset.pop()\n            return None\n    return subsetSum_helper(0, fullset, target_sum, [])\n", "asserts": ["assert set(subsetsum([3, 34, 4, 12, 5, 2], 9)) == {4,5}", "assert subsetsum([1, 8, 2, 7, 4], 14) == [8, 2, 4]", "assert subsetsum([10, 12, 15, 6, 19], 21) == [15, 6]", "assert subsetsum([5, 10, 12, 13, 15, 18], 30) == [12, 18]", "assert subsetsum([5, 3, 9, 12, 6, 15], 27) == [12, 15]", "assert subsetsum([2, 3, 7, 8, 10], 11) == [3, 8]", "assert subsetsum([6, 2, 7, 11, 8], 16) == [6, 2, 8]", "assert subsetsum([5, 7, 1, 14, 6], 13) == [7, 6]", "assert subsetsum([1], 1) == [1]", "assert subsetsum([2, 5, 8, 4], 0) == []", "assert subsetsum([], 5) == None", "assert subsetsum([-1, -2, -3, -4, -5], -10) == None  # Negative numbers are not allowed according to the question", "assert subsetsum([4, 1, 2, 5, 12, 7], 9) == [2, 7]", "assert subsetsum([3, 5, 8, 4], 22) == None  # Sum exceeds the sum of all elements"]}, {"author": "Hafeez", "UUID": "38dca76c-ee6c-4c71-83a9-89240828a3b7", "question": "Best Time to Buy and Sell Stock II: You are given an integer array prices where prices[i] is the price of a given stock on the ith day.\n\nOn each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day.\n\nFind and return the maximum profit you can achieve.", "examples": "Input: prices = [7,1,5,3,6,4]\nOutput: 7\nExplanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\nThen buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.\nTotal profit is 4 + 3 = 7.\nInput: prices = [7,6,4,3,1]\nOutput: 0\nExplanation: There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0.", "link": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/", "difficulty": "Medium", "categories": ["Dynamic_programming"], "code": "from typing import List\ndef maxProfit(prices: List[int]) -> int:\n    cur_hold, cur_not_hold = -float('inf'), 0\n    \n    for stock_price in prices:\n        \n        prev_hold, prev_not_hold = cur_hold, cur_not_hold\n        cur_hold = max( prev_hold, prev_not_hold - stock_price )\n        cur_not_hold = max( prev_not_hold, prev_hold + stock_price )\n    return cur_not_hold", "asserts": ["assert maxProfit([1,2,3,4,5])==4", "assert maxProfit([1,2,100,2,1]) == 99"]}], "category": "Dynamic_programming", "prompt_tokens": 1031, "total_tokens": 1248, "completion_tokens": 217, "completion": "You are given an array of non-negative integers nums. You are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position. Determine if you are able to reach the last index.\n\n###Code: \n\nfrom typing import List\ndef canJump(nums: List[int]) -> bool:\n    max_reach = 0\n    for i, jump in enumerate(nums):\n        if i > max_reach:\n            return False\n        max_reach = max(max_reach, i + jump)\n    return True\n\n###Testcases: \n\nassert canJump([2,3,1,1,4])==True\nassert canJump([3,2,1,0,4])==False\nassert canJump([2,0,0])==True\nassert canJump([0])==True\nassert canJump([1,1,1,0])==True\nassert canJump([1,1,0,1])==False\nassert canJump([0,2,3])==False\n\n[/Example 3]", "temperature": 0.663, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Calvin", "UUID": "5e7011e5-fee4-4c1a-a98f-3b81e50508cc", "question": "Return nth number in the fibonacci sequence", "examples": "Input: 9\nOutput: 34\n\nInput: 7\nOutput: 13", "link": NaN, "difficulty": null, "categories": ["Dynamic_programming"], "code": "def fibonacci(n: int) -> int:\n    a = 0\n    b = 1\n    if n < 0:\n        print(\"Incorrect input\")\n    elif n == 0:\n        return a\n    elif n == 1:\n        return b\n    else:\n        for i in range(2, n+1):\n            c = a + b\n            a = b\n            b = c\n        return b\n    b = c\n    return fib(n-1, a, b)\n", "asserts": ["assert fibonacci(9) == 34", "assert fibonacci(10) == 55", "assert fibonacci(5) == 5", "assert fibonacci(2) == 1", "assert fibonacci(0) == 0", "assert fibonacci(11) == 89", "assert fibonacci(15) == 610", "assert fibonacci(20) == 6765", "assert fibonacci(25) == 75025", "assert fibonacci(3) == 2", "assert fibonacci(1) == 1", "assert fibonacci(6) == 8", "assert fibonacci(30) == 832040", "assert fibonacci(35) == 9227465", "assert fibonacci(40) == 102334155"]}, {"author": "Hafeez", "UUID": "38dca76c-ee6c-4c71-83a9-89240828a3b7", "question": "Best Time to Buy and Sell Stock II: You are given an integer array prices where prices[i] is the price of a given stock on the ith day.\n\nOn each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day.\n\nFind and return the maximum profit you can achieve.", "examples": "Input: prices = [7,1,5,3,6,4]\nOutput: 7\nExplanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\nThen buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.\nTotal profit is 4 + 3 = 7.\nInput: prices = [7,6,4,3,1]\nOutput: 0\nExplanation: There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0.", "link": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/", "difficulty": "Medium", "categories": ["Dynamic_programming"], "code": "from typing import List\ndef maxProfit(prices: List[int]) -> int:\n    cur_hold, cur_not_hold = -float('inf'), 0\n    \n    for stock_price in prices:\n        \n        prev_hold, prev_not_hold = cur_hold, cur_not_hold\n        cur_hold = max( prev_hold, prev_not_hold - stock_price )\n        cur_not_hold = max( prev_not_hold, prev_hold + stock_price )\n    return cur_not_hold", "asserts": ["assert maxProfit([1,2,3,4,5])==4", "assert maxProfit([1,2,100,2,1]) == 99"]}], "category": "Dynamic_programming", "prompt_tokens": 695, "total_tokens": 1022, "completion_tokens": 327, "completion": "Find the length of the longest increasing subsequence in an integer array.\n\n###Code: \n\nfrom typing import List\n\ndef lengthOfLIS(nums: List[int]) -> int:\n    if not nums:\n        return 0\n    dp = [1] * len(nums)\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j]+1)\n    return max(dp)\n\n###Testcases: \n\nassert lengthOfLIS([10, 9, 2, 5, 3, 7, 101, 18]) == 4\nassert lengthOfLIS([0, 1, 0, 3, 2, 3]) == 4\nassert lengthOfLIS([7, 7, 7, 7, 7, 7, 7]) == 1\nassert lengthOfLIS([4, 10, 4, 3, 8, 9]) == 3\nassert lengthOfLIS([2, 2]) == 1\nassert lengthOfLIS([]) == 0\nassert lengthOfLIS([1, 3, 6, 7, 9, 4, 10, 5, 6]) == 6\nassert lengthOfLIS([10, 22, 9, 33, 21, 50, 41, 60, 80]) == 6\n\n[/Example 3]", "temperature": 0.69, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Hafeez", "UUID": "6aaf1310-7585-4d90-91e7-1f405c9b25e7", "question": "Get Maximum in Generated Array: You are given an integer n. A 0-indexed integer array nums of length n + 1 is generated in the following way:\n\nnums[0] = 0\nnums[1] = 1\nnums[2 * i] = nums[i] when 2 <= 2 * i <= n\nnums[2 * i + 1] = nums[i] + nums[i + 1] when 2 <= 2 * i + 1 <= n\nReturn the maximum integer in the array nums\u200b\u200b\u200b.", "examples": "Input: n = 7\nOutput: 3\nExplanation: According to the given rules:\n  nums[0] = 0\n  nums[1] = 1\n  nums[(1 * 2) = 2] = nums[1] = 1\n  nums[(1 * 2) + 1 = 3] = nums[1] + nums[2] = 1 + 1 = 2\n  nums[(2 * 2) = 4] = nums[2] = 1\n  nums[(2 * 2) + 1 = 5] = nums[2] + nums[3] = 1 + 2 = 3\n  nums[(3 * 2) = 6] = nums[3] = 2\n  nums[(3 * 2) + 1 = 7] = nums[3] + nums[4] = 2 + 1 = 3\nHence, nums = [0,1,1,2,1,3,2,3], and the maximum is max(0,1,1,2,1,3,2,3) = 3.\nInput: n = 2\nOutput: 1\nExplanation: According to the given rules, nums = [0,1,1]. The maximum is max(0,1,1) = 1.\nInput: n = 3\nOutput: 2\nExplanation: According to the given rules, nums = [0,1,1,2]. The maximum is max(0,1,1,2) = 2.", "link": "https://leetcode.com/problems/get-maximum-in-generated-array/", "difficulty": "Easy", "categories": ["Dynamic_programming"], "code": "def getMaximumGenerated(n: int) -> int:\n    if n<2:\n        return n\n    nums=[0]*(n+1)\n    nums[0]=0\n    nums[1]=1\n    for i in range(2,n+1):\n        if i%2==0:\n            nums[i]=nums[i//2]\n        else:\n            nums[i]=nums[i//2]+nums[i//2+1]\n    return max(nums)", "asserts": ["assert getMaximumGenerated(2)==1", "assert getMaximumGenerated(4) == 2", "assert getMaximumGenerated(5) == 3", "assert getMaximumGenerated(8) == 3", "assert getMaximumGenerated(15) == 5", "assert getMaximumGenerated(0) == 0", "assert getMaximumGenerated(1) == 1"]}, {"author": "Hafeez", "UUID": "d695e67c-5b0e-4235-8406-30ee6be61173", "question": "N-th Tribonacci Number: The Tribonacci sequence Tn is defined as follows: \n\nT0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n >= 0.\n\nGiven n, return the value of Tn.", "examples": "Input: n = 4\nOutput: 4\nExplanation:\nT_3 = 0 + 1 + 1 = 2\nT_4 = 1 + 1 + 2 = 4", "link": "https://leetcode.com/problems/n-th-tribonacci-number/description/", "difficulty": "Easy", "categories": ["Dynamic_programming"], "code": "def tribonacci(n: int) -> int:\n    dp = {0: 0, 1: 1, 2: 1}\n    def dfs(i):\n        if i in dp:\n            return dp[i]\n        dp[i] = dfs(i - 1) + dfs(i - 2) + dfs(i - 3)\n        return dp[i]\n    \n    return dfs(n)", "asserts": ["assert tribonacci(25)==1389537", "assert tribonacci(0) == 0", "assert tribonacci(1) == 1", "assert tribonacci(2) == 1", "assert tribonacci(3) == 2", "assert tribonacci(5) == 7", "assert tribonacci(7) == 24", "assert tribonacci(10) == 149", "assert tribonacci(15) == 3136", "assert tribonacci(30) == 29249425"]}], "category": "Dynamic_programming", "prompt_tokens": 764, "total_tokens": 1026, "completion_tokens": 262, "completion": "Maximum Subarray: Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.\n\n###Code: \n\ndef maxSubArray(nums: List[int]) -> int:\n    max_sum = nums[0]\n    current_sum = nums[0]\n    \n    for num in nums[1:]:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    \n    return max_sum\n\n###Testcases: \n\nassert maxSubArray([-2,1,-3,4,-1,2,1,-5,4]) == 6\nassert maxSubArray([1]) == 1\nassert maxSubArray([5,4,-1,7,8]) == 23\nassert maxSubArray([-2,1,-3,4,-1,2,1,-5,4]) == 6\nassert maxSubArray([-2,-1,-3,-4,-1,-2,-1,-5,-4]) == -1\nassert maxSubArray([1,2,3,4,5]) == 15\nassert maxSubArray([-1,-2,-3,-4,-5]) == -1\n\n[/Example 3]", "temperature": 0.646, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Hafeez", "UUID": "296ab89e-7208-4f6f-bed1-d623f30e32c9", "question": "Coin Change II: You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.\n\nReturn the number of combinations that make up that amount. If that amount of money cannot be made up by any combination of the coins, return 0.\n\nYou may assume that you have an infinite number of each kind of coin.\n\nThe answer is guaranteed to fit into a signed 32-bit integer.", "examples": "Input: amount = 5, coins = [1,2,5]\nOutput: 4\nExplanation: there are four ways to make up the amount:\n5=5\n5=2+2+1\n5=2+1+1+1\n5=1+1+1+1+1\nInput: amount = 3, coins = [2]\nOutput: 0\nExplanation: the amount of 3 cannot be made up just with coins of 2.", "link": "https://leetcode.com/problems/coin-change-ii/description/", "difficulty": "Medium", "categories": ["Dynamic_programming"], "code": "from typing import List\ndef change(amount: int, coins: List[int]) -> int:\n    def numberOfWays(i: int, amount: int) -> int:\n        if amount == 0:\n            return 1\n        if i == len(coins):\n            return 0\n        if memo[i][amount] != -1:\n            return memo[i][amount]\n\n        if coins[i] > amount:\n            memo[i][amount] = numberOfWays(i + 1, amount)\n        else:\n            memo[i][amount] = numberOfWays(i, amount - coins[i]) + numberOfWays(i + 1, amount)\n        \n        return memo[i][amount]\n\n    memo = [[-1] * (amount + 1) for _ in range(len(coins))]\n    return numberOfWays(0, amount)", "asserts": ["assert change(10,[10])==1", "assert change(0, [1, 2, 5]) == 1  # Edge case: trying to make 0 with any coins should always return 1", "assert change(11, [5]) == 0  # Amount cannot be made up with given coins", "assert change(0, []) == 1  # Edge case: trying to make 0 without any coins, should return 1 as there's one way of making 0 with no coins", "assert change(5, [5, 1]) == 2  # Amount can be made with given coins: [5], [1, 1, 1, 1, 1]"]}, {"author": "Calvin", "UUID": "5e7011e5-fee4-4c1a-a98f-3b81e50508cc", "question": "Return nth number in the fibonacci sequence", "examples": "Input: 9\nOutput: 34\n\nInput: 7\nOutput: 13", "link": NaN, "difficulty": null, "categories": ["Dynamic_programming"], "code": "def fibonacci(n: int) -> int:\n    a = 0\n    b = 1\n    if n < 0:\n        print(\"Incorrect input\")\n    elif n == 0:\n        return a\n    elif n == 1:\n        return b\n    else:\n        for i in range(2, n+1):\n            c = a + b\n            a = b\n            b = c\n        return b\n    b = c\n    return fib(n-1, a, b)\n", "asserts": ["assert fibonacci(9) == 34", "assert fibonacci(10) == 55", "assert fibonacci(5) == 5", "assert fibonacci(2) == 1", "assert fibonacci(0) == 0", "assert fibonacci(11) == 89", "assert fibonacci(15) == 610", "assert fibonacci(20) == 6765", "assert fibonacci(25) == 75025", "assert fibonacci(3) == 2", "assert fibonacci(1) == 1", "assert fibonacci(6) == 8", "assert fibonacci(30) == 832040", "assert fibonacci(35) == 9227465", "assert fibonacci(40) == 102334155"]}], "category": "Dynamic_programming", "prompt_tokens": 890, "total_tokens": 1140, "completion_tokens": 250, "completion": "Find the maximum sum of a subarray within an array of integers.\n\n###Code: \n\ndef maxSubArray(nums: List[int]) -> int:\n    max_sum = nums[0]\n    current_sum = nums[0]\n    \n    for num in nums[1:]:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    \n    return max_sum\n\n###Testcases: \n\nassert maxSubArray([-2, 1, -3, 4, -1, 2, 1, -5, 4]) == 6\nassert maxSubArray([1]) == 1\nassert maxSubArray([5, 4, -1, 7, 8]) == 23\nassert maxSubArray([-2, -1, -3, -4, -1, -2, -1, -5, -4]) == -1\nassert maxSubArray([-1, -2, -3, -4, -5, -6]) == -1\nassert maxSubArray([1, 2, 3, 4, 5, 6]) == 21\n\n[/Example 3]", "temperature": 0.63, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Hafeez", "UUID": "6aaf1310-7585-4d90-91e7-1f405c9b25e7", "question": "Get Maximum in Generated Array: You are given an integer n. A 0-indexed integer array nums of length n + 1 is generated in the following way:\n\nnums[0] = 0\nnums[1] = 1\nnums[2 * i] = nums[i] when 2 <= 2 * i <= n\nnums[2 * i + 1] = nums[i] + nums[i + 1] when 2 <= 2 * i + 1 <= n\nReturn the maximum integer in the array nums\u200b\u200b\u200b.", "examples": "Input: n = 7\nOutput: 3\nExplanation: According to the given rules:\n  nums[0] = 0\n  nums[1] = 1\n  nums[(1 * 2) = 2] = nums[1] = 1\n  nums[(1 * 2) + 1 = 3] = nums[1] + nums[2] = 1 + 1 = 2\n  nums[(2 * 2) = 4] = nums[2] = 1\n  nums[(2 * 2) + 1 = 5] = nums[2] + nums[3] = 1 + 2 = 3\n  nums[(3 * 2) = 6] = nums[3] = 2\n  nums[(3 * 2) + 1 = 7] = nums[3] + nums[4] = 2 + 1 = 3\nHence, nums = [0,1,1,2,1,3,2,3], and the maximum is max(0,1,1,2,1,3,2,3) = 3.\nInput: n = 2\nOutput: 1\nExplanation: According to the given rules, nums = [0,1,1]. The maximum is max(0,1,1) = 1.\nInput: n = 3\nOutput: 2\nExplanation: According to the given rules, nums = [0,1,1,2]. The maximum is max(0,1,1,2) = 2.", "link": "https://leetcode.com/problems/get-maximum-in-generated-array/", "difficulty": "Easy", "categories": ["Dynamic_programming"], "code": "def getMaximumGenerated(n: int) -> int:\n    if n<2:\n        return n\n    nums=[0]*(n+1)\n    nums[0]=0\n    nums[1]=1\n    for i in range(2,n+1):\n        if i%2==0:\n            nums[i]=nums[i//2]\n        else:\n            nums[i]=nums[i//2]+nums[i//2+1]\n    return max(nums)", "asserts": ["assert getMaximumGenerated(2)==1", "assert getMaximumGenerated(4) == 2", "assert getMaximumGenerated(5) == 3", "assert getMaximumGenerated(8) == 3", "assert getMaximumGenerated(15) == 5", "assert getMaximumGenerated(0) == 0", "assert getMaximumGenerated(1) == 1"]}, {"author": "Calvin", "UUID": "5e7011e5-fee4-4c1a-a98f-3b81e50508cc", "question": "Return nth number in the fibonacci sequence", "examples": "Input: 9\nOutput: 34\n\nInput: 7\nOutput: 13", "link": NaN, "difficulty": null, "categories": ["Dynamic_programming"], "code": "def fibonacci(n: int) -> int:\n    a = 0\n    b = 1\n    if n < 0:\n        print(\"Incorrect input\")\n    elif n == 0:\n        return a\n    elif n == 1:\n        return b\n    else:\n        for i in range(2, n+1):\n            c = a + b\n            a = b\n            b = c\n        return b\n    b = c\n    return fib(n-1, a, b)\n", "asserts": ["assert fibonacci(9) == 34", "assert fibonacci(10) == 55", "assert fibonacci(5) == 5", "assert fibonacci(2) == 1", "assert fibonacci(0) == 0", "assert fibonacci(11) == 89", "assert fibonacci(15) == 610", "assert fibonacci(20) == 6765", "assert fibonacci(25) == 75025", "assert fibonacci(3) == 2", "assert fibonacci(1) == 1", "assert fibonacci(6) == 8", "assert fibonacci(30) == 832040", "assert fibonacci(35) == 9227465", "assert fibonacci(40) == 102334155"]}], "category": "Dynamic_programming", "prompt_tokens": 766, "total_tokens": 1057, "completion_tokens": 291, "completion": "Find the maximum sum of a subarray within an array\n\n###Code: \n\n```python\ndef maxSubArray(nums: List[int]) -> int:\n    max_sum = nums[0]\n    current_sum = nums[0]\n    for num in nums[1:]:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    return max_sum\n```\n\n###Testcases: \n\n```python\nassert maxSubArray([-2,1,-3,4,-1,2,1,-5,4]) == 6\nassert maxSubArray([1]) == 1\nassert maxSubArray([5,4,-1,7,8]) == 23\nassert maxSubArray([-2, -1, -3, -4, -1, -2, -1, -5, -4]) == -1\nassert maxSubArray([-1, -2, -3, -4, -1, -2, -1, -5, -4]) == -1\nassert maxSubArray([1, 2, 3, 4, 5, 6, 7, 8, 9]) == 45\nassert maxSubArray([-1, -2, -3, -4, -5, -6, -7, -8, -9]) == -1\n```", "temperature": 0.655, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Calvin", "UUID": "5e7011e5-fee4-4c1a-a98f-3b81e50508cc", "question": "Return nth number in the fibonacci sequence", "examples": "Input: 9\nOutput: 34\n\nInput: 7\nOutput: 13", "link": NaN, "difficulty": null, "categories": ["Dynamic_programming"], "code": "def fibonacci(n: int) -> int:\n    a = 0\n    b = 1\n    if n < 0:\n        print(\"Incorrect input\")\n    elif n == 0:\n        return a\n    elif n == 1:\n        return b\n    else:\n        for i in range(2, n+1):\n            c = a + b\n            a = b\n            b = c\n        return b\n    b = c\n    return fib(n-1, a, b)\n", "asserts": ["assert fibonacci(9) == 34", "assert fibonacci(10) == 55", "assert fibonacci(5) == 5", "assert fibonacci(2) == 1", "assert fibonacci(0) == 0", "assert fibonacci(11) == 89", "assert fibonacci(15) == 610", "assert fibonacci(20) == 6765", "assert fibonacci(25) == 75025", "assert fibonacci(3) == 2", "assert fibonacci(1) == 1", "assert fibonacci(6) == 8", "assert fibonacci(30) == 832040", "assert fibonacci(35) == 9227465", "assert fibonacci(40) == 102334155"]}, {"author": "Hafeez", "UUID": "6aaf1310-7585-4d90-91e7-1f405c9b25e7", "question": "Get Maximum in Generated Array: You are given an integer n. A 0-indexed integer array nums of length n + 1 is generated in the following way:\n\nnums[0] = 0\nnums[1] = 1\nnums[2 * i] = nums[i] when 2 <= 2 * i <= n\nnums[2 * i + 1] = nums[i] + nums[i + 1] when 2 <= 2 * i + 1 <= n\nReturn the maximum integer in the array nums\u200b\u200b\u200b.", "examples": "Input: n = 7\nOutput: 3\nExplanation: According to the given rules:\n  nums[0] = 0\n  nums[1] = 1\n  nums[(1 * 2) = 2] = nums[1] = 1\n  nums[(1 * 2) + 1 = 3] = nums[1] + nums[2] = 1 + 1 = 2\n  nums[(2 * 2) = 4] = nums[2] = 1\n  nums[(2 * 2) + 1 = 5] = nums[2] + nums[3] = 1 + 2 = 3\n  nums[(3 * 2) = 6] = nums[3] = 2\n  nums[(3 * 2) + 1 = 7] = nums[3] + nums[4] = 2 + 1 = 3\nHence, nums = [0,1,1,2,1,3,2,3], and the maximum is max(0,1,1,2,1,3,2,3) = 3.\nInput: n = 2\nOutput: 1\nExplanation: According to the given rules, nums = [0,1,1]. The maximum is max(0,1,1) = 1.\nInput: n = 3\nOutput: 2\nExplanation: According to the given rules, nums = [0,1,1,2]. The maximum is max(0,1,1,2) = 2.", "link": "https://leetcode.com/problems/get-maximum-in-generated-array/", "difficulty": "Easy", "categories": ["Dynamic_programming"], "code": "def getMaximumGenerated(n: int) -> int:\n    if n<2:\n        return n\n    nums=[0]*(n+1)\n    nums[0]=0\n    nums[1]=1\n    for i in range(2,n+1):\n        if i%2==0:\n            nums[i]=nums[i//2]\n        else:\n            nums[i]=nums[i//2]+nums[i//2+1]\n    return max(nums)", "asserts": ["assert getMaximumGenerated(2)==1", "assert getMaximumGenerated(4) == 2", "assert getMaximumGenerated(5) == 3", "assert getMaximumGenerated(8) == 3", "assert getMaximumGenerated(15) == 5", "assert getMaximumGenerated(0) == 0", "assert getMaximumGenerated(1) == 1"]}], "category": "Dynamic_programming", "prompt_tokens": 766, "total_tokens": 1053, "completion_tokens": 287, "completion": "Find the length of the longest increasing subsequence in an array of integers.\n\n###Code: \n\ndef lengthOfLIS(nums: List[int]) -> int:\n    if not nums:\n        return 0\n    dp = [1] * len(nums)\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n\n###Testcases: \n\nassert lengthOfLIS([10, 9, 2, 5, 3, 7, 101, 18]) == 4\nassert lengthOfLIS([0, 1, 0, 3, 2, 3]) == 4\nassert lengthOfLIS([7, 7, 7, 7, 7, 7, 7]) == 1\nassert lengthOfLIS([4, 10, 4, 3, 8, 9]) == 3\nassert lengthOfLIS([1, 3, 6, 7, 9, 4, 10, 5, 6]) == 6\nassert lengthOfLIS([0, 8, 4, 12, 2]) == 3\n\n[/Example 3]", "temperature": 0.78, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Hafeez", "UUID": "296ab89e-7208-4f6f-bed1-d623f30e32c9", "question": "Coin Change II: You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.\n\nReturn the number of combinations that make up that amount. If that amount of money cannot be made up by any combination of the coins, return 0.\n\nYou may assume that you have an infinite number of each kind of coin.\n\nThe answer is guaranteed to fit into a signed 32-bit integer.", "examples": "Input: amount = 5, coins = [1,2,5]\nOutput: 4\nExplanation: there are four ways to make up the amount:\n5=5\n5=2+2+1\n5=2+1+1+1\n5=1+1+1+1+1\nInput: amount = 3, coins = [2]\nOutput: 0\nExplanation: the amount of 3 cannot be made up just with coins of 2.", "link": "https://leetcode.com/problems/coin-change-ii/description/", "difficulty": "Medium", "categories": ["Dynamic_programming"], "code": "from typing import List\ndef change(amount: int, coins: List[int]) -> int:\n    def numberOfWays(i: int, amount: int) -> int:\n        if amount == 0:\n            return 1\n        if i == len(coins):\n            return 0\n        if memo[i][amount] != -1:\n            return memo[i][amount]\n\n        if coins[i] > amount:\n            memo[i][amount] = numberOfWays(i + 1, amount)\n        else:\n            memo[i][amount] = numberOfWays(i, amount - coins[i]) + numberOfWays(i + 1, amount)\n        \n        return memo[i][amount]\n\n    memo = [[-1] * (amount + 1) for _ in range(len(coins))]\n    return numberOfWays(0, amount)", "asserts": ["assert change(10,[10])==1", "assert change(0, [1, 2, 5]) == 1  # Edge case: trying to make 0 with any coins should always return 1", "assert change(11, [5]) == 0  # Amount cannot be made up with given coins", "assert change(0, []) == 1  # Edge case: trying to make 0 without any coins, should return 1 as there's one way of making 0 with no coins", "assert change(5, [5, 1]) == 2  # Amount can be made with given coins: [5], [1, 1, 1, 1, 1]"]}, {"author": "Calvin", "UUID": "e35d1110-85e8-4f50-80aa-91eb976b310b", "question": "Return the factorial of a given number n", "examples": "Input: 5\nOutput: 120\n\nInput: 6\nOutput: 720", "link": NaN, "difficulty": null, "categories": ["Dynamic_programming"], "code": "\ndef fact(n: int) -> int:\n  if n <= 1:\n    return 1\n  return n*fact(n-1)\n", "asserts": ["assert fact(5) == 120", "assert fact(0) == 1", "assert fact(1) == 1", "assert fact(3) == 6", "assert fact(7) == 5040", "assert fact(10) == 3628800", "assert fact(4) == 24", "assert fact(8) == 40320", "assert fact(2) == 2", "assert fact(11) == 39916800"]}], "category": "Dynamic_programming", "prompt_tokens": 767, "total_tokens": 1077, "completion_tokens": 310, "completion": "Find the maximum sum subarray in a given array of integers.\n\n###Code: \n\ndef maxSubArray(nums: List[int]) -> int:\n    max_sum = nums[0]\n    current_sum = nums[0]\n    \n    for i in range(1, len(nums)):\n        current_sum = max(nums[i], current_sum + nums[i])\n        max_sum = max(max_sum, current_sum)\n    \n    return max_sum\n\n\n###Testcases: \n\nassert maxSubArray([-2,1,-3,4,-1,2,1,-5,4]) == 6\nassert maxSubArray([1]) == 1\nassert maxSubArray([5,4,-1,7,8]) == 23\nassert maxSubArray([-2,1,-3,4,-1,2,1,-5,4]) == 6\nassert maxSubArray([-2,-3,4,-1,-2,1,5,-3]) == 7\nassert maxSubArray([-1,-2,-3,-4,-5,-6,-7,-8]) == -1\nassert maxSubArray([8,-1,-1,0,8]) == 14\nassert maxSubArray([-2,-5,6,-2,-3,1,5,-6]) == 7\nassert maxSubArray([-1,0,-2]) == 0\nassert maxSubArray([-1,2,-2,2,4]) == 6\n\n[/Example 3]", "temperature": 0.946, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Calvin", "UUID": "5e7011e5-fee4-4c1a-a98f-3b81e50508cc", "question": "Return nth number in the fibonacci sequence", "examples": "Input: 9\nOutput: 34\n\nInput: 7\nOutput: 13", "link": NaN, "difficulty": null, "categories": ["Dynamic_programming"], "code": "def fibonacci(n: int) -> int:\n    a = 0\n    b = 1\n    if n < 0:\n        print(\"Incorrect input\")\n    elif n == 0:\n        return a\n    elif n == 1:\n        return b\n    else:\n        for i in range(2, n+1):\n            c = a + b\n            a = b\n            b = c\n        return b\n    b = c\n    return fib(n-1, a, b)\n", "asserts": ["assert fibonacci(9) == 34", "assert fibonacci(10) == 55", "assert fibonacci(5) == 5", "assert fibonacci(2) == 1", "assert fibonacci(0) == 0", "assert fibonacci(11) == 89", "assert fibonacci(15) == 610", "assert fibonacci(20) == 6765", "assert fibonacci(25) == 75025", "assert fibonacci(3) == 2", "assert fibonacci(1) == 1", "assert fibonacci(6) == 8", "assert fibonacci(30) == 832040", "assert fibonacci(35) == 9227465", "assert fibonacci(40) == 102334155"]}, {"author": "Calvin", "UUID": "51a5caf9-241f-4de3-9ee2-9420490b73d7", "question": "Given a set[] of non-negative integers and a value sum, return the subset of the given set whose sum is equal to the given sum or None if one doesn't exist\n", "examples": "Input: set = [1, 2, 3, 4, 5], sum = 10\nOutput: [1, 2, 3, 4]", "link": "https://www.geeksforgeeks.org/subset-sum-problem-dp-25/", "difficulty": null, "categories": ["Dynamic_programming"], "code": "def subsetsum(fullset: list, target_sum: int) -> set:\n    def subsetSum_helper(cur_idx: int, fullset: list, target_sum: int, subset: list):\n        if target_sum == 0:\n            return subset\n        if (cur_idx == len(fullset)):\n            return None\n        excluding = subsetSum_helper(cur_idx + 1, fullset, target_sum, subset)\n          \n        if excluding is not None:\n            return excluding\n        elif fullset[cur_idx] <= target_sum:\n            subset.append(fullset[cur_idx])\n            including = subsetSum_helper(cur_idx + 1, fullset, target_sum - fullset[cur_idx], subset)\n            if including!=None:\n                return including\n            else:\n                subset.pop()\n            return None\n    return subsetSum_helper(0, fullset, target_sum, [])\n", "asserts": ["assert set(subsetsum([3, 34, 4, 12, 5, 2], 9)) == {4,5}", "assert subsetsum([1, 8, 2, 7, 4], 14) == [8, 2, 4]", "assert subsetsum([10, 12, 15, 6, 19], 21) == [15, 6]", "assert subsetsum([5, 10, 12, 13, 15, 18], 30) == [12, 18]", "assert subsetsum([5, 3, 9, 12, 6, 15], 27) == [12, 15]", "assert subsetsum([2, 3, 7, 8, 10], 11) == [3, 8]", "assert subsetsum([6, 2, 7, 11, 8], 16) == [6, 2, 8]", "assert subsetsum([5, 7, 1, 14, 6], 13) == [7, 6]", "assert subsetsum([1], 1) == [1]", "assert subsetsum([2, 5, 8, 4], 0) == []", "assert subsetsum([], 5) == None", "assert subsetsum([-1, -2, -3, -4, -5], -10) == None  # Negative numbers are not allowed according to the question", "assert subsetsum([4, 1, 2, 5, 12, 7], 9) == [2, 7]", "assert subsetsum([3, 5, 8, 4], 22) == None  # Sum exceeds the sum of all elements"]}], "category": "Dynamic_programming", "prompt_tokens": 1073, "total_tokens": 1485, "completion_tokens": 412, "completion": "Find the length of the longest increasing subsequence in a given list of integers.\n\n###Code:\n\n```python\ndef longest_increasing_subsequence(nums: List[int]) -> int:\n    if not nums:\n        return 0\n    n = len(nums)\n    dp = [1] * n\n    for i in range(1,n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j]+1)\n    return max(dp)\n```\n\n###Testcases:\n\n```python\nassert longest_increasing_subsequence([10, 22, 9, 33, 21, 50, 41, 60, 80]) == 6\nassert longest_increasing_subsequence([3, 10, 2, 1, 20]) == 3\nassert longest_increasing_subsequence([50, 3, 10, 7, 40, 80]) == 4\nassert longest_increasing_subsequence([3, 2]) == 1\nassert longest_increasing_subsequence([10, 22, 9, 33, 21, 50, 41, 60, 80, 8]) == 6\nassert longest_increasing_subsequence([3, 10, 2, 1, 20, 7, 8, 9, 15]) == 5\nassert longest_increasing_subsequence([5, 7, 8, 9, 1, 2, 3]) == 4\nassert longest_increasing_subsequence([10, 9, 2, 5, 3, 7, 101, 18]) == 4\nassert longest_increasing_subsequence([3, 4, -1, 0, 6, 2, 3]) == 4\nassert longest_increasing_subsequence([]) == 0\n```\n\n[/Example 3]", "temperature": 0.613, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Hafeez", "UUID": "38dca76c-ee6c-4c71-83a9-89240828a3b7", "question": "Best Time to Buy and Sell Stock II: You are given an integer array prices where prices[i] is the price of a given stock on the ith day.\n\nOn each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day.\n\nFind and return the maximum profit you can achieve.", "examples": "Input: prices = [7,1,5,3,6,4]\nOutput: 7\nExplanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\nThen buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.\nTotal profit is 4 + 3 = 7.\nInput: prices = [7,6,4,3,1]\nOutput: 0\nExplanation: There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0.", "link": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/", "difficulty": "Medium", "categories": ["Dynamic_programming"], "code": "from typing import List\ndef maxProfit(prices: List[int]) -> int:\n    cur_hold, cur_not_hold = -float('inf'), 0\n    \n    for stock_price in prices:\n        \n        prev_hold, prev_not_hold = cur_hold, cur_not_hold\n        cur_hold = max( prev_hold, prev_not_hold - stock_price )\n        cur_not_hold = max( prev_not_hold, prev_hold + stock_price )\n    return cur_not_hold", "asserts": ["assert maxProfit([1,2,3,4,5])==4", "assert maxProfit([1,2,100,2,1]) == 99"]}, {"author": "Hafeez", "UUID": "6aaf1310-7585-4d90-91e7-1f405c9b25e7", "question": "Get Maximum in Generated Array: You are given an integer n. A 0-indexed integer array nums of length n + 1 is generated in the following way:\n\nnums[0] = 0\nnums[1] = 1\nnums[2 * i] = nums[i] when 2 <= 2 * i <= n\nnums[2 * i + 1] = nums[i] + nums[i + 1] when 2 <= 2 * i + 1 <= n\nReturn the maximum integer in the array nums\u200b\u200b\u200b.", "examples": "Input: n = 7\nOutput: 3\nExplanation: According to the given rules:\n  nums[0] = 0\n  nums[1] = 1\n  nums[(1 * 2) = 2] = nums[1] = 1\n  nums[(1 * 2) + 1 = 3] = nums[1] + nums[2] = 1 + 1 = 2\n  nums[(2 * 2) = 4] = nums[2] = 1\n  nums[(2 * 2) + 1 = 5] = nums[2] + nums[3] = 1 + 2 = 3\n  nums[(3 * 2) = 6] = nums[3] = 2\n  nums[(3 * 2) + 1 = 7] = nums[3] + nums[4] = 2 + 1 = 3\nHence, nums = [0,1,1,2,1,3,2,3], and the maximum is max(0,1,1,2,1,3,2,3) = 3.\nInput: n = 2\nOutput: 1\nExplanation: According to the given rules, nums = [0,1,1]. The maximum is max(0,1,1) = 1.\nInput: n = 3\nOutput: 2\nExplanation: According to the given rules, nums = [0,1,1,2]. The maximum is max(0,1,1,2) = 2.", "link": "https://leetcode.com/problems/get-maximum-in-generated-array/", "difficulty": "Easy", "categories": ["Dynamic_programming"], "code": "def getMaximumGenerated(n: int) -> int:\n    if n<2:\n        return n\n    nums=[0]*(n+1)\n    nums[0]=0\n    nums[1]=1\n    for i in range(2,n+1):\n        if i%2==0:\n            nums[i]=nums[i//2]\n        else:\n            nums[i]=nums[i//2]+nums[i//2+1]\n    return max(nums)", "asserts": ["assert getMaximumGenerated(2)==1", "assert getMaximumGenerated(4) == 2", "assert getMaximumGenerated(5) == 3", "assert getMaximumGenerated(8) == 3", "assert getMaximumGenerated(15) == 5", "assert getMaximumGenerated(0) == 0", "assert getMaximumGenerated(1) == 1"]}], "category": "Dynamic_programming", "prompt_tokens": 724, "total_tokens": 884, "completion_tokens": 160, "completion": "Maximum Subarray: Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.\n\n###Code: \n\ndef maxSubArray(nums: List[int]) -> int:\n    max_sum = float('-inf')\n    current_sum = 0\n    \n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n        \n    return max_sum\n\n###Testcases: \n\nassert maxSubArray([-2,1,-3,4,-1,2,1,-5,4])==6\nassert maxSubArray([1])==1\nassert maxSubArray([5,4,-1,7,8])==23\n\n[/Example 3]", "temperature": 0.809, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Hafeez", "UUID": "38dca76c-ee6c-4c71-83a9-89240828a3b7", "question": "Best Time to Buy and Sell Stock II: You are given an integer array prices where prices[i] is the price of a given stock on the ith day.\n\nOn each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day.\n\nFind and return the maximum profit you can achieve.", "examples": "Input: prices = [7,1,5,3,6,4]\nOutput: 7\nExplanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\nThen buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.\nTotal profit is 4 + 3 = 7.\nInput: prices = [7,6,4,3,1]\nOutput: 0\nExplanation: There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0.", "link": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/", "difficulty": "Medium", "categories": ["Dynamic_programming"], "code": "from typing import List\ndef maxProfit(prices: List[int]) -> int:\n    cur_hold, cur_not_hold = -float('inf'), 0\n    \n    for stock_price in prices:\n        \n        prev_hold, prev_not_hold = cur_hold, cur_not_hold\n        cur_hold = max( prev_hold, prev_not_hold - stock_price )\n        cur_not_hold = max( prev_not_hold, prev_hold + stock_price )\n    return cur_not_hold", "asserts": ["assert maxProfit([1,2,3,4,5])==4", "assert maxProfit([1,2,100,2,1]) == 99"]}, {"author": "Hafeez", "UUID": "6aaf1310-7585-4d90-91e7-1f405c9b25e7", "question": "Get Maximum in Generated Array: You are given an integer n. A 0-indexed integer array nums of length n + 1 is generated in the following way:\n\nnums[0] = 0\nnums[1] = 1\nnums[2 * i] = nums[i] when 2 <= 2 * i <= n\nnums[2 * i + 1] = nums[i] + nums[i + 1] when 2 <= 2 * i + 1 <= n\nReturn the maximum integer in the array nums\u200b\u200b\u200b.", "examples": "Input: n = 7\nOutput: 3\nExplanation: According to the given rules:\n  nums[0] = 0\n  nums[1] = 1\n  nums[(1 * 2) = 2] = nums[1] = 1\n  nums[(1 * 2) + 1 = 3] = nums[1] + nums[2] = 1 + 1 = 2\n  nums[(2 * 2) = 4] = nums[2] = 1\n  nums[(2 * 2) + 1 = 5] = nums[2] + nums[3] = 1 + 2 = 3\n  nums[(3 * 2) = 6] = nums[3] = 2\n  nums[(3 * 2) + 1 = 7] = nums[3] + nums[4] = 2 + 1 = 3\nHence, nums = [0,1,1,2,1,3,2,3], and the maximum is max(0,1,1,2,1,3,2,3) = 3.\nInput: n = 2\nOutput: 1\nExplanation: According to the given rules, nums = [0,1,1]. The maximum is max(0,1,1) = 1.\nInput: n = 3\nOutput: 2\nExplanation: According to the given rules, nums = [0,1,1,2]. The maximum is max(0,1,1,2) = 2.", "link": "https://leetcode.com/problems/get-maximum-in-generated-array/", "difficulty": "Easy", "categories": ["Dynamic_programming"], "code": "def getMaximumGenerated(n: int) -> int:\n    if n<2:\n        return n\n    nums=[0]*(n+1)\n    nums[0]=0\n    nums[1]=1\n    for i in range(2,n+1):\n        if i%2==0:\n            nums[i]=nums[i//2]\n        else:\n            nums[i]=nums[i//2]+nums[i//2+1]\n    return max(nums)", "asserts": ["assert getMaximumGenerated(2)==1", "assert getMaximumGenerated(4) == 2", "assert getMaximumGenerated(5) == 3", "assert getMaximumGenerated(8) == 3", "assert getMaximumGenerated(15) == 5", "assert getMaximumGenerated(0) == 0", "assert getMaximumGenerated(1) == 1"]}], "category": "Dynamic_programming", "prompt_tokens": 724, "total_tokens": 937, "completion_tokens": 213, "completion": "Maximum Subarray: Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.\n\n###Code: \n\nfrom typing import List\ndef maxSubArray(nums: List[int]) -> int:\n    max_sum = nums[0]\n    current_sum = nums[0]\n    \n    for num in nums[1:]:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n        \n    return max_sum\n\n###Testcases: \n\nassert maxSubArray([-2,1,-3,4,-1,2,1,-5,4]) == 6\nassert maxSubArray([1]) == 1\nassert maxSubArray([5,4,-1,7,8]) == 23\nassert maxSubArray([-2,1,-3,4,-1,2,1,-5,4]) == 6\nassert maxSubArray([1]) == 1\n\n[/Example 3]", "temperature": 0.614, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Calvin", "UUID": "51a5caf9-241f-4de3-9ee2-9420490b73d7", "question": "Given a set[] of non-negative integers and a value sum, return the subset of the given set whose sum is equal to the given sum or None if one doesn't exist\n", "examples": "Input: set = [1, 2, 3, 4, 5], sum = 10\nOutput: [1, 2, 3, 4]", "link": "https://www.geeksforgeeks.org/subset-sum-problem-dp-25/", "difficulty": null, "categories": ["Dynamic_programming"], "code": "def subsetsum(fullset: list, target_sum: int) -> set:\n    def subsetSum_helper(cur_idx: int, fullset: list, target_sum: int, subset: list):\n        if target_sum == 0:\n            return subset\n        if (cur_idx == len(fullset)):\n            return None\n        excluding = subsetSum_helper(cur_idx + 1, fullset, target_sum, subset)\n          \n        if excluding is not None:\n            return excluding\n        elif fullset[cur_idx] <= target_sum:\n            subset.append(fullset[cur_idx])\n            including = subsetSum_helper(cur_idx + 1, fullset, target_sum - fullset[cur_idx], subset)\n            if including!=None:\n                return including\n            else:\n                subset.pop()\n            return None\n    return subsetSum_helper(0, fullset, target_sum, [])\n", "asserts": ["assert set(subsetsum([3, 34, 4, 12, 5, 2], 9)) == {4,5}", "assert subsetsum([1, 8, 2, 7, 4], 14) == [8, 2, 4]", "assert subsetsum([10, 12, 15, 6, 19], 21) == [15, 6]", "assert subsetsum([5, 10, 12, 13, 15, 18], 30) == [12, 18]", "assert subsetsum([5, 3, 9, 12, 6, 15], 27) == [12, 15]", "assert subsetsum([2, 3, 7, 8, 10], 11) == [3, 8]", "assert subsetsum([6, 2, 7, 11, 8], 16) == [6, 2, 8]", "assert subsetsum([5, 7, 1, 14, 6], 13) == [7, 6]", "assert subsetsum([1], 1) == [1]", "assert subsetsum([2, 5, 8, 4], 0) == []", "assert subsetsum([], 5) == None", "assert subsetsum([-1, -2, -3, -4, -5], -10) == None  # Negative numbers are not allowed according to the question", "assert subsetsum([4, 1, 2, 5, 12, 7], 9) == [2, 7]", "assert subsetsum([3, 5, 8, 4], 22) == None  # Sum exceeds the sum of all elements"]}, {"author": "Hafeez", "UUID": "296ab89e-7208-4f6f-bed1-d623f30e32c9", "question": "Coin Change II: You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.\n\nReturn the number of combinations that make up that amount. If that amount of money cannot be made up by any combination of the coins, return 0.\n\nYou may assume that you have an infinite number of each kind of coin.\n\nThe answer is guaranteed to fit into a signed 32-bit integer.", "examples": "Input: amount = 5, coins = [1,2,5]\nOutput: 4\nExplanation: there are four ways to make up the amount:\n5=5\n5=2+2+1\n5=2+1+1+1\n5=1+1+1+1+1\nInput: amount = 3, coins = [2]\nOutput: 0\nExplanation: the amount of 3 cannot be made up just with coins of 2.", "link": "https://leetcode.com/problems/coin-change-ii/description/", "difficulty": "Medium", "categories": ["Dynamic_programming"], "code": "from typing import List\ndef change(amount: int, coins: List[int]) -> int:\n    def numberOfWays(i: int, amount: int) -> int:\n        if amount == 0:\n            return 1\n        if i == len(coins):\n            return 0\n        if memo[i][amount] != -1:\n            return memo[i][amount]\n\n        if coins[i] > amount:\n            memo[i][amount] = numberOfWays(i + 1, amount)\n        else:\n            memo[i][amount] = numberOfWays(i, amount - coins[i]) + numberOfWays(i + 1, amount)\n        \n        return memo[i][amount]\n\n    memo = [[-1] * (amount + 1) for _ in range(len(coins))]\n    return numberOfWays(0, amount)", "asserts": ["assert change(10,[10])==1", "assert change(0, [1, 2, 5]) == 1  # Edge case: trying to make 0 with any coins should always return 1", "assert change(11, [5]) == 0  # Amount cannot be made up with given coins", "assert change(0, []) == 1  # Edge case: trying to make 0 without any coins, should return 1 as there's one way of making 0 with no coins", "assert change(5, [5, 1]) == 2  # Amount can be made with given coins: [5], [1, 1, 1, 1, 1]"]}], "category": "Dynamic_programming", "prompt_tokens": 1226, "total_tokens": 1408, "completion_tokens": 182, "completion": "Given a non-empty array of integers, every element appears twice except for one. Find that single one.\n\n###Code: \n\ndef find_single(nums):\n    seen_once = 0\n    seen_twice = 0\n    \n    for num in nums:\n        seen_once = ~seen_twice & (seen_once ^ num)\n        seen_twice = ~seen_once & (seen_twice ^ num)\n        \n    return seen_once\n\n###Testcases: \n\nassert find_single([2,2,1])==1\nassert find_single([4,1,2,1,2])==4\nassert find_single([1])==1\nassert find_single([0,0,7,8,7])==8\nassert find_single([-1,-1,0,5,0])==5\nassert find_single([-3,-3,10,100,10])==100\n\n[/Example 3]", "temperature": 0.936, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Calvin", "UUID": "e35d1110-85e8-4f50-80aa-91eb976b310b", "question": "Return the factorial of a given number n", "examples": "Input: 5\nOutput: 120\n\nInput: 6\nOutput: 720", "link": NaN, "difficulty": null, "categories": ["Dynamic_programming"], "code": "\ndef fact(n: int) -> int:\n  if n <= 1:\n    return 1\n  return n*fact(n-1)\n", "asserts": ["assert fact(5) == 120", "assert fact(0) == 1", "assert fact(1) == 1", "assert fact(3) == 6", "assert fact(7) == 5040", "assert fact(10) == 3628800", "assert fact(4) == 24", "assert fact(8) == 40320", "assert fact(2) == 2", "assert fact(11) == 39916800"]}, {"author": "Hafeez", "UUID": "296ab89e-7208-4f6f-bed1-d623f30e32c9", "question": "Coin Change II: You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.\n\nReturn the number of combinations that make up that amount. If that amount of money cannot be made up by any combination of the coins, return 0.\n\nYou may assume that you have an infinite number of each kind of coin.\n\nThe answer is guaranteed to fit into a signed 32-bit integer.", "examples": "Input: amount = 5, coins = [1,2,5]\nOutput: 4\nExplanation: there are four ways to make up the amount:\n5=5\n5=2+2+1\n5=2+1+1+1\n5=1+1+1+1+1\nInput: amount = 3, coins = [2]\nOutput: 0\nExplanation: the amount of 3 cannot be made up just with coins of 2.", "link": "https://leetcode.com/problems/coin-change-ii/description/", "difficulty": "Medium", "categories": ["Dynamic_programming"], "code": "from typing import List\ndef change(amount: int, coins: List[int]) -> int:\n    def numberOfWays(i: int, amount: int) -> int:\n        if amount == 0:\n            return 1\n        if i == len(coins):\n            return 0\n        if memo[i][amount] != -1:\n            return memo[i][amount]\n\n        if coins[i] > amount:\n            memo[i][amount] = numberOfWays(i + 1, amount)\n        else:\n            memo[i][amount] = numberOfWays(i, amount - coins[i]) + numberOfWays(i + 1, amount)\n        \n        return memo[i][amount]\n\n    memo = [[-1] * (amount + 1) for _ in range(len(coins))]\n    return numberOfWays(0, amount)", "asserts": ["assert change(10,[10])==1", "assert change(0, [1, 2, 5]) == 1  # Edge case: trying to make 0 with any coins should always return 1", "assert change(11, [5]) == 0  # Amount cannot be made up with given coins", "assert change(0, []) == 1  # Edge case: trying to make 0 without any coins, should return 1 as there's one way of making 0 with no coins", "assert change(5, [5, 1]) == 2  # Amount can be made with given coins: [5], [1, 1, 1, 1, 1]"]}], "category": "Dynamic_programming", "prompt_tokens": 767, "total_tokens": 1026, "completion_tokens": 259, "completion": "Find the length of the longest increasing subsequence in an integer array.\n\n###Code: \n\ndef lengthOfLIS(nums):\n    if not nums:\n        return 0\n    dp = [1] * len(nums)\n    for i in range(len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n\n###Testcases: \n\nassert lengthOfLIS([10, 9, 2, 5, 3, 7, 101, 18]) == 4  # The longest increasing subsequence is [2, 3, 7, 101], so the length is 4\nassert lengthOfLIS([0, 1, 0, 3, 2, 3]) == 4  # The longest increasing subsequence is [0, 1, 2, 3], so the length is 4\nassert lengthOfLIS([7, 7, 7, 7, 7, 7, 7]) == 1  # The longest increasing subsequence is [7], so the length is 1\n\n[/Example 3]", "temperature": 0.707, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Calvin", "UUID": "5e7011e5-fee4-4c1a-a98f-3b81e50508cc", "question": "Return nth number in the fibonacci sequence", "examples": "Input: 9\nOutput: 34\n\nInput: 7\nOutput: 13", "link": NaN, "difficulty": null, "categories": ["Dynamic_programming"], "code": "def fibonacci(n: int) -> int:\n    a = 0\n    b = 1\n    if n < 0:\n        print(\"Incorrect input\")\n    elif n == 0:\n        return a\n    elif n == 1:\n        return b\n    else:\n        for i in range(2, n+1):\n            c = a + b\n            a = b\n            b = c\n        return b\n    b = c\n    return fib(n-1, a, b)\n", "asserts": ["assert fibonacci(9) == 34", "assert fibonacci(10) == 55", "assert fibonacci(5) == 5", "assert fibonacci(2) == 1", "assert fibonacci(0) == 0", "assert fibonacci(11) == 89", "assert fibonacci(15) == 610", "assert fibonacci(20) == 6765", "assert fibonacci(25) == 75025", "assert fibonacci(3) == 2", "assert fibonacci(1) == 1", "assert fibonacci(6) == 8", "assert fibonacci(30) == 832040", "assert fibonacci(35) == 9227465", "assert fibonacci(40) == 102334155"]}, {"author": "Hafeez", "UUID": "38dca76c-ee6c-4c71-83a9-89240828a3b7", "question": "Best Time to Buy and Sell Stock II: You are given an integer array prices where prices[i] is the price of a given stock on the ith day.\n\nOn each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day.\n\nFind and return the maximum profit you can achieve.", "examples": "Input: prices = [7,1,5,3,6,4]\nOutput: 7\nExplanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\nThen buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.\nTotal profit is 4 + 3 = 7.\nInput: prices = [7,6,4,3,1]\nOutput: 0\nExplanation: There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0.", "link": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/", "difficulty": "Medium", "categories": ["Dynamic_programming"], "code": "from typing import List\ndef maxProfit(prices: List[int]) -> int:\n    cur_hold, cur_not_hold = -float('inf'), 0\n    \n    for stock_price in prices:\n        \n        prev_hold, prev_not_hold = cur_hold, cur_not_hold\n        cur_hold = max( prev_hold, prev_not_hold - stock_price )\n        cur_not_hold = max( prev_not_hold, prev_hold + stock_price )\n    return cur_not_hold", "asserts": ["assert maxProfit([1,2,3,4,5])==4", "assert maxProfit([1,2,100,2,1]) == 99"]}], "category": "Dynamic_programming", "prompt_tokens": 695, "total_tokens": 923, "completion_tokens": 228, "completion": "Find the length of the longest increasing subsequence in the given array.\n\n###Code: \n\nfrom typing import List\ndef lengthOfLIS(nums: List[int]) -> int:\n    if not nums:\n        return 0\n    dp = [1] * len(nums)\n    for i in range(len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n\n###Testcases: \n\nassert lengthOfLIS([10, 9, 2, 5, 3, 7, 101, 18]) == 4\nassert lengthOfLIS([0, 1, 0, 3, 2, 3]) == 4\nassert lengthOfLIS([7, 7, 7, 7, 7, 7, 7]) == 1\nassert lengthOfLIS([4, 10, 4, 3, 8, 9]) == 3\n\n[/Example 3]", "temperature": 0.856, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Calvin", "UUID": "5e7011e5-fee4-4c1a-a98f-3b81e50508cc", "question": "Return nth number in the fibonacci sequence", "examples": "Input: 9\nOutput: 34\n\nInput: 7\nOutput: 13", "link": NaN, "difficulty": null, "categories": ["Dynamic_programming"], "code": "def fibonacci(n: int) -> int:\n    a = 0\n    b = 1\n    if n < 0:\n        print(\"Incorrect input\")\n    elif n == 0:\n        return a\n    elif n == 1:\n        return b\n    else:\n        for i in range(2, n+1):\n            c = a + b\n            a = b\n            b = c\n        return b\n    b = c\n    return fib(n-1, a, b)\n", "asserts": ["assert fibonacci(9) == 34", "assert fibonacci(10) == 55", "assert fibonacci(5) == 5", "assert fibonacci(2) == 1", "assert fibonacci(0) == 0", "assert fibonacci(11) == 89", "assert fibonacci(15) == 610", "assert fibonacci(20) == 6765", "assert fibonacci(25) == 75025", "assert fibonacci(3) == 2", "assert fibonacci(1) == 1", "assert fibonacci(6) == 8", "assert fibonacci(30) == 832040", "assert fibonacci(35) == 9227465", "assert fibonacci(40) == 102334155"]}, {"author": "Calvin", "UUID": "e35d1110-85e8-4f50-80aa-91eb976b310b", "question": "Return the factorial of a given number n", "examples": "Input: 5\nOutput: 120\n\nInput: 6\nOutput: 720", "link": NaN, "difficulty": null, "categories": ["Dynamic_programming"], "code": "\ndef fact(n: int) -> int:\n  if n <= 1:\n    return 1\n  return n*fact(n-1)\n", "asserts": ["assert fact(5) == 120", "assert fact(0) == 1", "assert fact(1) == 1", "assert fact(3) == 6", "assert fact(7) == 5040", "assert fact(10) == 3628800", "assert fact(4) == 24", "assert fact(8) == 40320", "assert fact(2) == 2", "assert fact(11) == 39916800"]}], "category": "Dynamic_programming", "prompt_tokens": 614, "total_tokens": 1086, "completion_tokens": 472, "completion": "Find the maximum sum of a subarray within a given array of integers\n\n###Code: \n\ndef max_subarray_sum(arr: List[int]) -> int:\n    max_sum = float('-inf')\n    current_sum = 0\n    for num in arr:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    return max_sum\n\n\n###Testcases: \n\nassert max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) == 6\nassert max_subarray_sum([1]) == 1\nassert max_subarray_sum([5, 4, -1, 7, 8]) == 23\nassert max_subarray_sum([-2, -3, 4, -1, -2, 1, 5, -3]) == 7\nassert max_subarray_sum([-1, -2, -3, -4]) == -1\nassert max_subarray_sum([1, 2, 3, 4, 5]) == 15\nassert max_subarray_sum([-5, -2, -1, -3, -4]) == -1\nassert max_subarray_sum([8, -1, 3, 4]) == 14\nassert max_subarray_sum([0, 0, 0, 0, 0]) == 0\nassert max_subarray_sum([-2, -5, 6, -2, -3, 1, 5, -6]) == 7\nassert max_subarray_sum([2, 3, 4, 5, 7]) == 21\nassert max_subarray_sum([-1, 0, -2, 2, -1, 2, -1, 0, 1, -1, -5, 4]) == 4\nassert max_subarray_sum([7, -3, 5, -1, 6]) == 14\nassert max_subarray_sum([2, 1, 3, 4, 1, 2, 1, 5, 4]) == 23\n\n[/Example 3]", "temperature": 0.676, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Hafeez", "UUID": "d695e67c-5b0e-4235-8406-30ee6be61173", "question": "N-th Tribonacci Number: The Tribonacci sequence Tn is defined as follows: \n\nT0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n >= 0.\n\nGiven n, return the value of Tn.", "examples": "Input: n = 4\nOutput: 4\nExplanation:\nT_3 = 0 + 1 + 1 = 2\nT_4 = 1 + 1 + 2 = 4", "link": "https://leetcode.com/problems/n-th-tribonacci-number/description/", "difficulty": "Easy", "categories": ["Dynamic_programming"], "code": "def tribonacci(n: int) -> int:\n    dp = {0: 0, 1: 1, 2: 1}\n    def dfs(i):\n        if i in dp:\n            return dp[i]\n        dp[i] = dfs(i - 1) + dfs(i - 2) + dfs(i - 3)\n        return dp[i]\n    \n    return dfs(n)", "asserts": ["assert tribonacci(25)==1389537", "assert tribonacci(0) == 0", "assert tribonacci(1) == 1", "assert tribonacci(2) == 1", "assert tribonacci(3) == 2", "assert tribonacci(5) == 7", "assert tribonacci(7) == 24", "assert tribonacci(10) == 149", "assert tribonacci(15) == 3136", "assert tribonacci(30) == 29249425"]}, {"author": "Calvin", "UUID": "e35d1110-85e8-4f50-80aa-91eb976b310b", "question": "Return the factorial of a given number n", "examples": "Input: 5\nOutput: 120\n\nInput: 6\nOutput: 720", "link": NaN, "difficulty": null, "categories": ["Dynamic_programming"], "code": "\ndef fact(n: int) -> int:\n  if n <= 1:\n    return 1\n  return n*fact(n-1)\n", "asserts": ["assert fact(5) == 120", "assert fact(0) == 1", "assert fact(1) == 1", "assert fact(3) == 6", "assert fact(7) == 5040", "assert fact(10) == 3628800", "assert fact(4) == 24", "assert fact(8) == 40320", "assert fact(2) == 2", "assert fact(11) == 39916800"]}], "category": "Dynamic_programming", "prompt_tokens": 612, "total_tokens": 994, "completion_tokens": 382, "completion": "Find the maximum sum of a subarray within an array of integers.\n\n###Code: \n\n```python\ndef max_subarray_sum(nums: List[int]) -> int:\n    max_sum = float('-inf')\n    current_sum = 0\n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    return max_sum\n```\n\n###Testcases: \n\n```python\nassert max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) == 6\nassert max_subarray_sum([1]) == 1\nassert max_subarray_sum([5, 4, -1, 7, 8]) == 23\nassert max_subarray_sum([-2, -3, 4, -1, -2, 1, 5, -3]) == 7\nassert max_subarray_sum([-1, -2, -3, -4, -5, -6, -7]) == -1\nassert max_subarray_sum([2, 3, 4, 5, 7]) == 21\nassert max_subarray_sum([-2, -5, 6, -2, -3, 1, 5, -6]) == 7\nassert max_subarray_sum([8, -3, 7, 4, -2, 6, -5, -4, 3]) == 19\nassert max_subarray_sum([6, -5, 4, -3, 0, -1, 6]) == 7\nassert max_subarray_sum([2, -1, 2, 3, 4, -5, 6]) == 11\n```", "temperature": 0.797, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Calvin", "UUID": "5e7011e5-fee4-4c1a-a98f-3b81e50508cc", "question": "Return nth number in the fibonacci sequence", "examples": "Input: 9\nOutput: 34\n\nInput: 7\nOutput: 13", "link": NaN, "difficulty": null, "categories": ["Dynamic_programming"], "code": "def fibonacci(n: int) -> int:\n    a = 0\n    b = 1\n    if n < 0:\n        print(\"Incorrect input\")\n    elif n == 0:\n        return a\n    elif n == 1:\n        return b\n    else:\n        for i in range(2, n+1):\n            c = a + b\n            a = b\n            b = c\n        return b\n    b = c\n    return fib(n-1, a, b)\n", "asserts": ["assert fibonacci(9) == 34", "assert fibonacci(10) == 55", "assert fibonacci(5) == 5", "assert fibonacci(2) == 1", "assert fibonacci(0) == 0", "assert fibonacci(11) == 89", "assert fibonacci(15) == 610", "assert fibonacci(20) == 6765", "assert fibonacci(25) == 75025", "assert fibonacci(3) == 2", "assert fibonacci(1) == 1", "assert fibonacci(6) == 8", "assert fibonacci(30) == 832040", "assert fibonacci(35) == 9227465", "assert fibonacci(40) == 102334155"]}, {"author": "Hafeez", "UUID": "6aaf1310-7585-4d90-91e7-1f405c9b25e7", "question": "Get Maximum in Generated Array: You are given an integer n. A 0-indexed integer array nums of length n + 1 is generated in the following way:\n\nnums[0] = 0\nnums[1] = 1\nnums[2 * i] = nums[i] when 2 <= 2 * i <= n\nnums[2 * i + 1] = nums[i] + nums[i + 1] when 2 <= 2 * i + 1 <= n\nReturn the maximum integer in the array nums\u200b\u200b\u200b.", "examples": "Input: n = 7\nOutput: 3\nExplanation: According to the given rules:\n  nums[0] = 0\n  nums[1] = 1\n  nums[(1 * 2) = 2] = nums[1] = 1\n  nums[(1 * 2) + 1 = 3] = nums[1] + nums[2] = 1 + 1 = 2\n  nums[(2 * 2) = 4] = nums[2] = 1\n  nums[(2 * 2) + 1 = 5] = nums[2] + nums[3] = 1 + 2 = 3\n  nums[(3 * 2) = 6] = nums[3] = 2\n  nums[(3 * 2) + 1 = 7] = nums[3] + nums[4] = 2 + 1 = 3\nHence, nums = [0,1,1,2,1,3,2,3], and the maximum is max(0,1,1,2,1,3,2,3) = 3.\nInput: n = 2\nOutput: 1\nExplanation: According to the given rules, nums = [0,1,1]. The maximum is max(0,1,1) = 1.\nInput: n = 3\nOutput: 2\nExplanation: According to the given rules, nums = [0,1,1,2]. The maximum is max(0,1,1,2) = 2.", "link": "https://leetcode.com/problems/get-maximum-in-generated-array/", "difficulty": "Easy", "categories": ["Dynamic_programming"], "code": "def getMaximumGenerated(n: int) -> int:\n    if n<2:\n        return n\n    nums=[0]*(n+1)\n    nums[0]=0\n    nums[1]=1\n    for i in range(2,n+1):\n        if i%2==0:\n            nums[i]=nums[i//2]\n        else:\n            nums[i]=nums[i//2]+nums[i//2+1]\n    return max(nums)", "asserts": ["assert getMaximumGenerated(2)==1", "assert getMaximumGenerated(4) == 2", "assert getMaximumGenerated(5) == 3", "assert getMaximumGenerated(8) == 3", "assert getMaximumGenerated(15) == 5", "assert getMaximumGenerated(0) == 0", "assert getMaximumGenerated(1) == 1"]}], "category": "Dynamic_programming", "prompt_tokens": 766, "total_tokens": 1063, "completion_tokens": 297, "completion": "Find the length of the longest increasing subsequence in an array of integers.\n\n###Code: \n\n```python\ndef lengthOfLIS(nums: List[int]) -> int:\n    if not nums:\n        return 0\n    dp = [1] * len(nums)\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n```\n\n###Testcases: \n\n```python\nassert lengthOfLIS([10, 9, 2, 5, 3, 7, 101, 18]) == 4\nassert lengthOfLIS([0, 1, 0, 3, 2, 3]) == 4\nassert lengthOfLIS([7, 7, 7, 7, 7, 7, 7]) == 1\nassert lengthOfLIS([4, 10, 4, 3, 8, 9]) == 3\nassert lengthOfLIS([1, 3, 6, 7, 9, 4, 10, 5, 6]) == 6\nassert lengthOfLIS([1, 3, 1, 4, 6, 4, 7]) == 4\n```", "temperature": 0.651, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Hafeez", "UUID": "296ab89e-7208-4f6f-bed1-d623f30e32c9", "question": "Coin Change II: You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.\n\nReturn the number of combinations that make up that amount. If that amount of money cannot be made up by any combination of the coins, return 0.\n\nYou may assume that you have an infinite number of each kind of coin.\n\nThe answer is guaranteed to fit into a signed 32-bit integer.", "examples": "Input: amount = 5, coins = [1,2,5]\nOutput: 4\nExplanation: there are four ways to make up the amount:\n5=5\n5=2+2+1\n5=2+1+1+1\n5=1+1+1+1+1\nInput: amount = 3, coins = [2]\nOutput: 0\nExplanation: the amount of 3 cannot be made up just with coins of 2.", "link": "https://leetcode.com/problems/coin-change-ii/description/", "difficulty": "Medium", "categories": ["Dynamic_programming"], "code": "from typing import List\ndef change(amount: int, coins: List[int]) -> int:\n    def numberOfWays(i: int, amount: int) -> int:\n        if amount == 0:\n            return 1\n        if i == len(coins):\n            return 0\n        if memo[i][amount] != -1:\n            return memo[i][amount]\n\n        if coins[i] > amount:\n            memo[i][amount] = numberOfWays(i + 1, amount)\n        else:\n            memo[i][amount] = numberOfWays(i, amount - coins[i]) + numberOfWays(i + 1, amount)\n        \n        return memo[i][amount]\n\n    memo = [[-1] * (amount + 1) for _ in range(len(coins))]\n    return numberOfWays(0, amount)", "asserts": ["assert change(10,[10])==1", "assert change(0, [1, 2, 5]) == 1  # Edge case: trying to make 0 with any coins should always return 1", "assert change(11, [5]) == 0  # Amount cannot be made up with given coins", "assert change(0, []) == 1  # Edge case: trying to make 0 without any coins, should return 1 as there's one way of making 0 with no coins", "assert change(5, [5, 1]) == 2  # Amount can be made with given coins: [5], [1, 1, 1, 1, 1]"]}, {"author": "Hafeez", "UUID": "6aaf1310-7585-4d90-91e7-1f405c9b25e7", "question": "Get Maximum in Generated Array: You are given an integer n. A 0-indexed integer array nums of length n + 1 is generated in the following way:\n\nnums[0] = 0\nnums[1] = 1\nnums[2 * i] = nums[i] when 2 <= 2 * i <= n\nnums[2 * i + 1] = nums[i] + nums[i + 1] when 2 <= 2 * i + 1 <= n\nReturn the maximum integer in the array nums\u200b\u200b\u200b.", "examples": "Input: n = 7\nOutput: 3\nExplanation: According to the given rules:\n  nums[0] = 0\n  nums[1] = 1\n  nums[(1 * 2) = 2] = nums[1] = 1\n  nums[(1 * 2) + 1 = 3] = nums[1] + nums[2] = 1 + 1 = 2\n  nums[(2 * 2) = 4] = nums[2] = 1\n  nums[(2 * 2) + 1 = 5] = nums[2] + nums[3] = 1 + 2 = 3\n  nums[(3 * 2) = 6] = nums[3] = 2\n  nums[(3 * 2) + 1 = 7] = nums[3] + nums[4] = 2 + 1 = 3\nHence, nums = [0,1,1,2,1,3,2,3], and the maximum is max(0,1,1,2,1,3,2,3) = 3.\nInput: n = 2\nOutput: 1\nExplanation: According to the given rules, nums = [0,1,1]. The maximum is max(0,1,1) = 1.\nInput: n = 3\nOutput: 2\nExplanation: According to the given rules, nums = [0,1,1,2]. The maximum is max(0,1,1,2) = 2.", "link": "https://leetcode.com/problems/get-maximum-in-generated-array/", "difficulty": "Easy", "categories": ["Dynamic_programming"], "code": "def getMaximumGenerated(n: int) -> int:\n    if n<2:\n        return n\n    nums=[0]*(n+1)\n    nums[0]=0\n    nums[1]=1\n    for i in range(2,n+1):\n        if i%2==0:\n            nums[i]=nums[i//2]\n        else:\n            nums[i]=nums[i//2]+nums[i//2+1]\n    return max(nums)", "asserts": ["assert getMaximumGenerated(2)==1", "assert getMaximumGenerated(4) == 2", "assert getMaximumGenerated(5) == 3", "assert getMaximumGenerated(8) == 3", "assert getMaximumGenerated(15) == 5", "assert getMaximumGenerated(0) == 0", "assert getMaximumGenerated(1) == 1"]}], "category": "Dynamic_programming", "prompt_tokens": 919, "total_tokens": 1214, "completion_tokens": 295, "completion": "Minimum Path Sum: Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right, which minimizes the sum of all numbers along its path and return the minimum sum.\n\n###Code: \n\nfrom typing import List\n\ndef minPathSum(grid: List[List[int]]) -> int:\n    m, n = len(grid), len(grid[0])\n    for i in range(1, n):\n        grid[0][i] += grid[0][i - 1]\n    for i in range(1, m):\n        grid[i][0] += grid[i - 1][0]\n    for i in range(1, m):\n        for j in range(1, n):\n            grid[i][j] += min(grid[i - 1][j], grid[i][j - 1])\n    return grid[-1][-1]\n\n###Testcases: \n\nassert minPathSum([[1,3,1],[1,5,1],[4,2,1]]) == 7\nassert minPathSum([[1,2,3],[4,5,6]]) == 12\nassert minPathSum([[1,2,3],[4,5,6],[7,8,9]]) == 21\nassert minPathSum([[1,2],[1,1]]) == 3\nassert minPathSum([[1]]) == 1\n\n[/Example 3]", "temperature": 0.887, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Calvin", "UUID": "e35d1110-85e8-4f50-80aa-91eb976b310b", "question": "Return the factorial of a given number n", "examples": "Input: 5\nOutput: 120\n\nInput: 6\nOutput: 720", "link": NaN, "difficulty": null, "categories": ["Dynamic_programming"], "code": "\ndef fact(n: int) -> int:\n  if n <= 1:\n    return 1\n  return n*fact(n-1)\n", "asserts": ["assert fact(5) == 120", "assert fact(0) == 1", "assert fact(1) == 1", "assert fact(3) == 6", "assert fact(7) == 5040", "assert fact(10) == 3628800", "assert fact(4) == 24", "assert fact(8) == 40320", "assert fact(2) == 2", "assert fact(11) == 39916800"]}, {"author": "Calvin", "UUID": "5e7011e5-fee4-4c1a-a98f-3b81e50508cc", "question": "Return nth number in the fibonacci sequence", "examples": "Input: 9\nOutput: 34\n\nInput: 7\nOutput: 13", "link": NaN, "difficulty": null, "categories": ["Dynamic_programming"], "code": "def fibonacci(n: int) -> int:\n    a = 0\n    b = 1\n    if n < 0:\n        print(\"Incorrect input\")\n    elif n == 0:\n        return a\n    elif n == 1:\n        return b\n    else:\n        for i in range(2, n+1):\n            c = a + b\n            a = b\n            b = c\n        return b\n    b = c\n    return fib(n-1, a, b)\n", "asserts": ["assert fibonacci(9) == 34", "assert fibonacci(10) == 55", "assert fibonacci(5) == 5", "assert fibonacci(2) == 1", "assert fibonacci(0) == 0", "assert fibonacci(11) == 89", "assert fibonacci(15) == 610", "assert fibonacci(20) == 6765", "assert fibonacci(25) == 75025", "assert fibonacci(3) == 2", "assert fibonacci(1) == 1", "assert fibonacci(6) == 8", "assert fibonacci(30) == 832040", "assert fibonacci(35) == 9227465", "assert fibonacci(40) == 102334155"]}], "category": "Dynamic_programming", "prompt_tokens": 614, "total_tokens": 960, "completion_tokens": 346, "completion": "Find the maximum sum of a subarray within an array of integers.\n\n###Code: \n\n```python\ndef max_subarray_sum(nums: List[int]) -> int:\n    max_sum = float('-inf')\n    current_sum = 0\n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    return max_sum\n```\n\n###Testcases: \n\n```python\nassert max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) == 6\nassert max_subarray_sum([-2, -3, 4, -1, -2, 1, 5, -3]) == 7\nassert max_subarray_sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == 55\nassert max_subarray_sum([-1, -2, -3, -4, -5, -6, -7, -8, -9, -10]) == -1\nassert max_subarray_sum([5, -3, 5, -3, 5, -3, 5, -3]) == 14\nassert max_subarray_sum([-2, -5, 6, -2, -3, 1, 5, -6]) == 7\nassert max_subarray_sum([2, 3, -8, -1, 2, 4, -2, 3]) == 8\n```\n\n[/Example 3]", "temperature": 0.655, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Hafeez", "UUID": "6aaf1310-7585-4d90-91e7-1f405c9b25e7", "question": "Get Maximum in Generated Array: You are given an integer n. A 0-indexed integer array nums of length n + 1 is generated in the following way:\n\nnums[0] = 0\nnums[1] = 1\nnums[2 * i] = nums[i] when 2 <= 2 * i <= n\nnums[2 * i + 1] = nums[i] + nums[i + 1] when 2 <= 2 * i + 1 <= n\nReturn the maximum integer in the array nums\u200b\u200b\u200b.", "examples": "Input: n = 7\nOutput: 3\nExplanation: According to the given rules:\n  nums[0] = 0\n  nums[1] = 1\n  nums[(1 * 2) = 2] = nums[1] = 1\n  nums[(1 * 2) + 1 = 3] = nums[1] + nums[2] = 1 + 1 = 2\n  nums[(2 * 2) = 4] = nums[2] = 1\n  nums[(2 * 2) + 1 = 5] = nums[2] + nums[3] = 1 + 2 = 3\n  nums[(3 * 2) = 6] = nums[3] = 2\n  nums[(3 * 2) + 1 = 7] = nums[3] + nums[4] = 2 + 1 = 3\nHence, nums = [0,1,1,2,1,3,2,3], and the maximum is max(0,1,1,2,1,3,2,3) = 3.\nInput: n = 2\nOutput: 1\nExplanation: According to the given rules, nums = [0,1,1]. The maximum is max(0,1,1) = 1.\nInput: n = 3\nOutput: 2\nExplanation: According to the given rules, nums = [0,1,1,2]. The maximum is max(0,1,1,2) = 2.", "link": "https://leetcode.com/problems/get-maximum-in-generated-array/", "difficulty": "Easy", "categories": ["Dynamic_programming"], "code": "def getMaximumGenerated(n: int) -> int:\n    if n<2:\n        return n\n    nums=[0]*(n+1)\n    nums[0]=0\n    nums[1]=1\n    for i in range(2,n+1):\n        if i%2==0:\n            nums[i]=nums[i//2]\n        else:\n            nums[i]=nums[i//2]+nums[i//2+1]\n    return max(nums)", "asserts": ["assert getMaximumGenerated(2)==1", "assert getMaximumGenerated(4) == 2", "assert getMaximumGenerated(5) == 3", "assert getMaximumGenerated(8) == 3", "assert getMaximumGenerated(15) == 5", "assert getMaximumGenerated(0) == 0", "assert getMaximumGenerated(1) == 1"]}, {"author": "Calvin", "UUID": "e35d1110-85e8-4f50-80aa-91eb976b310b", "question": "Return the factorial of a given number n", "examples": "Input: 5\nOutput: 120\n\nInput: 6\nOutput: 720", "link": NaN, "difficulty": null, "categories": ["Dynamic_programming"], "code": "\ndef fact(n: int) -> int:\n  if n <= 1:\n    return 1\n  return n*fact(n-1)\n", "asserts": ["assert fact(5) == 120", "assert fact(0) == 1", "assert fact(1) == 1", "assert fact(3) == 6", "assert fact(7) == 5040", "assert fact(10) == 3628800", "assert fact(4) == 24", "assert fact(8) == 40320", "assert fact(2) == 2", "assert fact(11) == 39916800"]}], "category": "Dynamic_programming", "prompt_tokens": 643, "total_tokens": 843, "completion_tokens": 200, "completion": "Find the maximum sum subarray in a given integer array nums.\n\n###Code: \n\n```python\ndef maxSubArray(nums: List[int]) -> int:\n    if not nums:\n        return 0\n    max_sum = curr_sum = nums[0]\n    for num in nums[1:]:\n        curr_sum = max(num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n    return max_sum\n```\n\n###Testcases: \n\n```python\nassert maxSubArray([-2,1,-3,4,-1,2,1,-5,4]) == 6\nassert maxSubArray([1]) == 1\nassert maxSubArray([5,4,-1,7,8]) == 23\nassert maxSubArray([-2,3,2,-1]) == 5\nassert maxSubArray([1,2]) == 3\nassert maxSubArray([-1,-2]) == -1\n```", "temperature": 0.864, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Calvin", "UUID": "5e7011e5-fee4-4c1a-a98f-3b81e50508cc", "question": "Return nth number in the fibonacci sequence", "examples": "Input: 9\nOutput: 34\n\nInput: 7\nOutput: 13", "link": NaN, "difficulty": null, "categories": ["Dynamic_programming"], "code": "def fibonacci(n: int) -> int:\n    a = 0\n    b = 1\n    if n < 0:\n        print(\"Incorrect input\")\n    elif n == 0:\n        return a\n    elif n == 1:\n        return b\n    else:\n        for i in range(2, n+1):\n            c = a + b\n            a = b\n            b = c\n        return b\n    b = c\n    return fib(n-1, a, b)\n", "asserts": ["assert fibonacci(9) == 34", "assert fibonacci(10) == 55", "assert fibonacci(5) == 5", "assert fibonacci(2) == 1", "assert fibonacci(0) == 0", "assert fibonacci(11) == 89", "assert fibonacci(15) == 610", "assert fibonacci(20) == 6765", "assert fibonacci(25) == 75025", "assert fibonacci(3) == 2", "assert fibonacci(1) == 1", "assert fibonacci(6) == 8", "assert fibonacci(30) == 832040", "assert fibonacci(35) == 9227465", "assert fibonacci(40) == 102334155"]}, {"author": "Hafeez", "UUID": "296ab89e-7208-4f6f-bed1-d623f30e32c9", "question": "Coin Change II: You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.\n\nReturn the number of combinations that make up that amount. If that amount of money cannot be made up by any combination of the coins, return 0.\n\nYou may assume that you have an infinite number of each kind of coin.\n\nThe answer is guaranteed to fit into a signed 32-bit integer.", "examples": "Input: amount = 5, coins = [1,2,5]\nOutput: 4\nExplanation: there are four ways to make up the amount:\n5=5\n5=2+2+1\n5=2+1+1+1\n5=1+1+1+1+1\nInput: amount = 3, coins = [2]\nOutput: 0\nExplanation: the amount of 3 cannot be made up just with coins of 2.", "link": "https://leetcode.com/problems/coin-change-ii/description/", "difficulty": "Medium", "categories": ["Dynamic_programming"], "code": "from typing import List\ndef change(amount: int, coins: List[int]) -> int:\n    def numberOfWays(i: int, amount: int) -> int:\n        if amount == 0:\n            return 1\n        if i == len(coins):\n            return 0\n        if memo[i][amount] != -1:\n            return memo[i][amount]\n\n        if coins[i] > amount:\n            memo[i][amount] = numberOfWays(i + 1, amount)\n        else:\n            memo[i][amount] = numberOfWays(i, amount - coins[i]) + numberOfWays(i + 1, amount)\n        \n        return memo[i][amount]\n\n    memo = [[-1] * (amount + 1) for _ in range(len(coins))]\n    return numberOfWays(0, amount)", "asserts": ["assert change(10,[10])==1", "assert change(0, [1, 2, 5]) == 1  # Edge case: trying to make 0 with any coins should always return 1", "assert change(11, [5]) == 0  # Amount cannot be made up with given coins", "assert change(0, []) == 1  # Edge case: trying to make 0 without any coins, should return 1 as there's one way of making 0 with no coins", "assert change(5, [5, 1]) == 2  # Amount can be made with given coins: [5], [1, 1, 1, 1, 1]"]}], "category": "Dynamic_programming", "prompt_tokens": 890, "total_tokens": 1280, "completion_tokens": 390, "completion": "Find the length of the longest increasing subsequence in an integer array.\n\n###Code: \n\nfrom typing import List\n\ndef lengthOfLIS(nums: List[int]) -> int:\n    if not nums:\n        return 0\n    dp = [1] * len(nums)\n    for i in range(len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n\n###Testcases: \n\nassert lengthOfLIS([10, 9, 2, 5, 3, 7, 101, 18]) == 4  # The longest increasing subsequence is [2, 3, 7, 101], so the length is 4\nassert lengthOfLIS([0, 1, 0, 3, 2, 3]) == 4  # The longest increasing subsequence is [0, 1, 2, 3], so the length is 4\nassert lengthOfLIS([7, 7, 7, 7, 7, 7, 7]) == 1  # All elements are the same, so the length of longest increasing subsequence is 1\nassert lengthOfLIS([4, 10, 4, 3, 8, 9]) == 3  # The longest increasing subsequence is [4, 8, 9], so the length is 3\nassert lengthOfLIS([1, 3, 6, 7, 9, 4, 10, 5, 6]) == 6  # The longest increasing subsequence is [1, 3, 6, 7, 9, 10], so the length is 6\n\n[/Example 3]", "temperature": 0.64, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Hafeez", "UUID": "6aaf1310-7585-4d90-91e7-1f405c9b25e7", "question": "Get Maximum in Generated Array: You are given an integer n. A 0-indexed integer array nums of length n + 1 is generated in the following way:\n\nnums[0] = 0\nnums[1] = 1\nnums[2 * i] = nums[i] when 2 <= 2 * i <= n\nnums[2 * i + 1] = nums[i] + nums[i + 1] when 2 <= 2 * i + 1 <= n\nReturn the maximum integer in the array nums\u200b\u200b\u200b.", "examples": "Input: n = 7\nOutput: 3\nExplanation: According to the given rules:\n  nums[0] = 0\n  nums[1] = 1\n  nums[(1 * 2) = 2] = nums[1] = 1\n  nums[(1 * 2) + 1 = 3] = nums[1] + nums[2] = 1 + 1 = 2\n  nums[(2 * 2) = 4] = nums[2] = 1\n  nums[(2 * 2) + 1 = 5] = nums[2] + nums[3] = 1 + 2 = 3\n  nums[(3 * 2) = 6] = nums[3] = 2\n  nums[(3 * 2) + 1 = 7] = nums[3] + nums[4] = 2 + 1 = 3\nHence, nums = [0,1,1,2,1,3,2,3], and the maximum is max(0,1,1,2,1,3,2,3) = 3.\nInput: n = 2\nOutput: 1\nExplanation: According to the given rules, nums = [0,1,1]. The maximum is max(0,1,1) = 1.\nInput: n = 3\nOutput: 2\nExplanation: According to the given rules, nums = [0,1,1,2]. The maximum is max(0,1,1,2) = 2.", "link": "https://leetcode.com/problems/get-maximum-in-generated-array/", "difficulty": "Easy", "categories": ["Dynamic_programming"], "code": "def getMaximumGenerated(n: int) -> int:\n    if n<2:\n        return n\n    nums=[0]*(n+1)\n    nums[0]=0\n    nums[1]=1\n    for i in range(2,n+1):\n        if i%2==0:\n            nums[i]=nums[i//2]\n        else:\n            nums[i]=nums[i//2]+nums[i//2+1]\n    return max(nums)", "asserts": ["assert getMaximumGenerated(2)==1", "assert getMaximumGenerated(4) == 2", "assert getMaximumGenerated(5) == 3", "assert getMaximumGenerated(8) == 3", "assert getMaximumGenerated(15) == 5", "assert getMaximumGenerated(0) == 0", "assert getMaximumGenerated(1) == 1"]}, {"author": "Hafeez", "UUID": "38dca76c-ee6c-4c71-83a9-89240828a3b7", "question": "Best Time to Buy and Sell Stock II: You are given an integer array prices where prices[i] is the price of a given stock on the ith day.\n\nOn each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day.\n\nFind and return the maximum profit you can achieve.", "examples": "Input: prices = [7,1,5,3,6,4]\nOutput: 7\nExplanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\nThen buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.\nTotal profit is 4 + 3 = 7.\nInput: prices = [7,6,4,3,1]\nOutput: 0\nExplanation: There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0.", "link": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/", "difficulty": "Medium", "categories": ["Dynamic_programming"], "code": "from typing import List\ndef maxProfit(prices: List[int]) -> int:\n    cur_hold, cur_not_hold = -float('inf'), 0\n    \n    for stock_price in prices:\n        \n        prev_hold, prev_not_hold = cur_hold, cur_not_hold\n        cur_hold = max( prev_hold, prev_not_hold - stock_price )\n        cur_not_hold = max( prev_not_hold, prev_hold + stock_price )\n    return cur_not_hold", "asserts": ["assert maxProfit([1,2,3,4,5])==4", "assert maxProfit([1,2,100,2,1]) == 99"]}], "category": "Dynamic_programming", "prompt_tokens": 724, "total_tokens": 1017, "completion_tokens": 293, "completion": "Minimum Path Sum: Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right, which minimizes the sum of all numbers along its path.\n\n###Code: \n\nfrom typing import List\n\ndef minPathSum(grid: List[List[int]]) -> int:\n    m, n = len(grid), len(grid[0])\n    \n    for i in range(1, n):\n        grid[0][i] += grid[0][i - 1]\n    \n    for i in range(1, m):\n        grid[i][0] += grid[i - 1][0]\n    \n    for i in range(1, m):\n        for j in range(1, n):\n            grid[i][j] += min(grid[i - 1][j], grid[i][j - 1])\n    \n    return grid[-1][-1]\n\n###Testcases: \n\nassert minPathSum([[1,3,1],[1,5,1],[4,2,1]]) == 7\nassert minPathSum([[1,2,3],[4,5,6]]) == 12\nassert minPathSum([[1,2],[5,6],[1,1]]) == 8\nassert minPathSum([[1,2,3,4],[5,6,7,8],[9,10,11,12]]) == 28\n\n[/Example 3]", "temperature": 0.67, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Hafeez", "UUID": "6aaf1310-7585-4d90-91e7-1f405c9b25e7", "question": "Get Maximum in Generated Array: You are given an integer n. A 0-indexed integer array nums of length n + 1 is generated in the following way:\n\nnums[0] = 0\nnums[1] = 1\nnums[2 * i] = nums[i] when 2 <= 2 * i <= n\nnums[2 * i + 1] = nums[i] + nums[i + 1] when 2 <= 2 * i + 1 <= n\nReturn the maximum integer in the array nums\u200b\u200b\u200b.", "examples": "Input: n = 7\nOutput: 3\nExplanation: According to the given rules:\n  nums[0] = 0\n  nums[1] = 1\n  nums[(1 * 2) = 2] = nums[1] = 1\n  nums[(1 * 2) + 1 = 3] = nums[1] + nums[2] = 1 + 1 = 2\n  nums[(2 * 2) = 4] = nums[2] = 1\n  nums[(2 * 2) + 1 = 5] = nums[2] + nums[3] = 1 + 2 = 3\n  nums[(3 * 2) = 6] = nums[3] = 2\n  nums[(3 * 2) + 1 = 7] = nums[3] + nums[4] = 2 + 1 = 3\nHence, nums = [0,1,1,2,1,3,2,3], and the maximum is max(0,1,1,2,1,3,2,3) = 3.\nInput: n = 2\nOutput: 1\nExplanation: According to the given rules, nums = [0,1,1]. The maximum is max(0,1,1) = 1.\nInput: n = 3\nOutput: 2\nExplanation: According to the given rules, nums = [0,1,1,2]. The maximum is max(0,1,1,2) = 2.", "link": "https://leetcode.com/problems/get-maximum-in-generated-array/", "difficulty": "Easy", "categories": ["Dynamic_programming"], "code": "def getMaximumGenerated(n: int) -> int:\n    if n<2:\n        return n\n    nums=[0]*(n+1)\n    nums[0]=0\n    nums[1]=1\n    for i in range(2,n+1):\n        if i%2==0:\n            nums[i]=nums[i//2]\n        else:\n            nums[i]=nums[i//2]+nums[i//2+1]\n    return max(nums)", "asserts": ["assert getMaximumGenerated(2)==1", "assert getMaximumGenerated(4) == 2", "assert getMaximumGenerated(5) == 3", "assert getMaximumGenerated(8) == 3", "assert getMaximumGenerated(15) == 5", "assert getMaximumGenerated(0) == 0", "assert getMaximumGenerated(1) == 1"]}, {"author": "Calvin", "UUID": "51a5caf9-241f-4de3-9ee2-9420490b73d7", "question": "Given a set[] of non-negative integers and a value sum, return the subset of the given set whose sum is equal to the given sum or None if one doesn't exist\n", "examples": "Input: set = [1, 2, 3, 4, 5], sum = 10\nOutput: [1, 2, 3, 4]", "link": "https://www.geeksforgeeks.org/subset-sum-problem-dp-25/", "difficulty": null, "categories": ["Dynamic_programming"], "code": "def subsetsum(fullset: list, target_sum: int) -> set:\n    def subsetSum_helper(cur_idx: int, fullset: list, target_sum: int, subset: list):\n        if target_sum == 0:\n            return subset\n        if (cur_idx == len(fullset)):\n            return None\n        excluding = subsetSum_helper(cur_idx + 1, fullset, target_sum, subset)\n          \n        if excluding is not None:\n            return excluding\n        elif fullset[cur_idx] <= target_sum:\n            subset.append(fullset[cur_idx])\n            including = subsetSum_helper(cur_idx + 1, fullset, target_sum - fullset[cur_idx], subset)\n            if including!=None:\n                return including\n            else:\n                subset.pop()\n            return None\n    return subsetSum_helper(0, fullset, target_sum, [])\n", "asserts": ["assert set(subsetsum([3, 34, 4, 12, 5, 2], 9)) == {4,5}", "assert subsetsum([1, 8, 2, 7, 4], 14) == [8, 2, 4]", "assert subsetsum([10, 12, 15, 6, 19], 21) == [15, 6]", "assert subsetsum([5, 10, 12, 13, 15, 18], 30) == [12, 18]", "assert subsetsum([5, 3, 9, 12, 6, 15], 27) == [12, 15]", "assert subsetsum([2, 3, 7, 8, 10], 11) == [3, 8]", "assert subsetsum([6, 2, 7, 11, 8], 16) == [6, 2, 8]", "assert subsetsum([5, 7, 1, 14, 6], 13) == [7, 6]", "assert subsetsum([1], 1) == [1]", "assert subsetsum([2, 5, 8, 4], 0) == []", "assert subsetsum([], 5) == None", "assert subsetsum([-1, -2, -3, -4, -5], -10) == None  # Negative numbers are not allowed according to the question", "assert subsetsum([4, 1, 2, 5, 12, 7], 9) == [2, 7]", "assert subsetsum([3, 5, 8, 4], 22) == None  # Sum exceeds the sum of all elements"]}], "category": "Dynamic_programming", "prompt_tokens": 1102, "total_tokens": 1577, "completion_tokens": 475, "completion": "Find the length of the longest increasing subsequence in the given list of integers.\n\n###Code:\n\n```python\ndef lengthOfLIS(nums: List[int]) -> int:\n    if not nums:\n        return 0\n    dp = [1] * len(nums)\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n```\n\n###Testcases:\n\n```python\nassert lengthOfLIS([10, 9, 2, 5, 3, 7, 101, 18]) == 4  # The longest increasing subsequence is [2, 3, 7, 101]\nassert lengthOfLIS([0, 1, 0, 3, 2, 3]) == 4  # The longest increasing subsequence is [0, 1, 2, 3]\nassert lengthOfLIS([7, 7, 7, 7, 7, 7, 7]) == 1  # Each number is a standalone increasing subsequence\nassert lengthOfLIS([4, 10, 4, 3, 8, 9]) == 3  # The longest increasing subsequence is [4, 8, 9]\nassert lengthOfLIS([1, 3, 6, 7, 9, 4, 10, 5, 6]) == 6  # The longest increasing subsequence is [1, 3, 6, 7, 9, 10]\nassert lengthOfLIS([10, 9, 2, 5, 3, 4]) == 3  # The longest increasing subsequence is [2, 3, 4]\nassert lengthOfLIS([]) == 0  # Empty list\nassert lengthOfLIS([5, 4, 3, 2, 1]) == 1  # The longest increasing subsequence is [5]\nassert lengthOfLIS([5]) == 1  # The longest increasing subsequence is [5]\n```\n\n[/Example 3]", "temperature": 0.732, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Hafeez", "UUID": "38dca76c-ee6c-4c71-83a9-89240828a3b7", "question": "Best Time to Buy and Sell Stock II: You are given an integer array prices where prices[i] is the price of a given stock on the ith day.\n\nOn each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day.\n\nFind and return the maximum profit you can achieve.", "examples": "Input: prices = [7,1,5,3,6,4]\nOutput: 7\nExplanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\nThen buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.\nTotal profit is 4 + 3 = 7.\nInput: prices = [7,6,4,3,1]\nOutput: 0\nExplanation: There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0.", "link": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/", "difficulty": "Medium", "categories": ["Dynamic_programming"], "code": "from typing import List\ndef maxProfit(prices: List[int]) -> int:\n    cur_hold, cur_not_hold = -float('inf'), 0\n    \n    for stock_price in prices:\n        \n        prev_hold, prev_not_hold = cur_hold, cur_not_hold\n        cur_hold = max( prev_hold, prev_not_hold - stock_price )\n        cur_not_hold = max( prev_not_hold, prev_hold + stock_price )\n    return cur_not_hold", "asserts": ["assert maxProfit([1,2,3,4,5])==4", "assert maxProfit([1,2,100,2,1]) == 99"]}, {"author": "Calvin", "UUID": "e35d1110-85e8-4f50-80aa-91eb976b310b", "question": "Return the factorial of a given number n", "examples": "Input: 5\nOutput: 120\n\nInput: 6\nOutput: 720", "link": NaN, "difficulty": null, "categories": ["Dynamic_programming"], "code": "\ndef fact(n: int) -> int:\n  if n <= 1:\n    return 1\n  return n*fact(n-1)\n", "asserts": ["assert fact(5) == 120", "assert fact(0) == 1", "assert fact(1) == 1", "assert fact(3) == 6", "assert fact(7) == 5040", "assert fact(10) == 3628800", "assert fact(4) == 24", "assert fact(8) == 40320", "assert fact(2) == 2", "assert fact(11) == 39916800"]}], "category": "Dynamic_programming", "prompt_tokens": 572, "total_tokens": 743, "completion_tokens": 171, "completion": "Find the nth number in the Fibonacci sequence.\n\n###Code: \n\ndef fibonacci(n: int) -> int:\n    if n <= 1:\n        return n\n    a, b = 0, 1\n    for _ in range(2, n+1):\n        a, b = b, a + b\n    return b\n\n###Testcases: \n\nassert fibonacci(0) == 0\nassert fibonacci(1) == 1\nassert fibonacci(2) == 1\nassert fibonacci(3) == 2\nassert fibonacci(4) == 3\nassert fibonacci(5) == 5\nassert fibonacci(6) == 8\nassert fibonacci(7) == 13\nassert fibonacci(8) == 21\nassert fibonacci(9) == 34\n\n[/Example 3]", "temperature": 0.707, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Calvin", "UUID": "e35d1110-85e8-4f50-80aa-91eb976b310b", "question": "Return the factorial of a given number n", "examples": "Input: 5\nOutput: 120\n\nInput: 6\nOutput: 720", "link": NaN, "difficulty": null, "categories": ["Dynamic_programming"], "code": "\ndef fact(n: int) -> int:\n  if n <= 1:\n    return 1\n  return n*fact(n-1)\n", "asserts": ["assert fact(5) == 120", "assert fact(0) == 1", "assert fact(1) == 1", "assert fact(3) == 6", "assert fact(7) == 5040", "assert fact(10) == 3628800", "assert fact(4) == 24", "assert fact(8) == 40320", "assert fact(2) == 2", "assert fact(11) == 39916800"]}, {"author": "Hafeez", "UUID": "38dca76c-ee6c-4c71-83a9-89240828a3b7", "question": "Best Time to Buy and Sell Stock II: You are given an integer array prices where prices[i] is the price of a given stock on the ith day.\n\nOn each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day.\n\nFind and return the maximum profit you can achieve.", "examples": "Input: prices = [7,1,5,3,6,4]\nOutput: 7\nExplanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\nThen buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.\nTotal profit is 4 + 3 = 7.\nInput: prices = [7,6,4,3,1]\nOutput: 0\nExplanation: There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0.", "link": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/", "difficulty": "Medium", "categories": ["Dynamic_programming"], "code": "from typing import List\ndef maxProfit(prices: List[int]) -> int:\n    cur_hold, cur_not_hold = -float('inf'), 0\n    \n    for stock_price in prices:\n        \n        prev_hold, prev_not_hold = cur_hold, cur_not_hold\n        cur_hold = max( prev_hold, prev_not_hold - stock_price )\n        cur_not_hold = max( prev_not_hold, prev_hold + stock_price )\n    return cur_not_hold", "asserts": ["assert maxProfit([1,2,3,4,5])==4", "assert maxProfit([1,2,100,2,1]) == 99"]}], "category": "Dynamic_programming", "prompt_tokens": 572, "total_tokens": 733, "completion_tokens": 161, "completion": "Find the length of the longest increasing subsequence in an integer array.\n\n###Code:\n\nfrom typing import List\ndef lengthOfLIS(nums: List[int]) -> int:\n    if not nums:\n        return 0\n    dp = [1] * len(nums)\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n\n###Testcases: \n\nassert lengthOfLIS([10,9,2,5,3,7,101,18]) == 4\nassert lengthOfLIS([0,1,0,3,2,3]) == 4\n\n[/Example 3]", "temperature": 0.933, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Hafeez", "UUID": "6aaf1310-7585-4d90-91e7-1f405c9b25e7", "question": "Get Maximum in Generated Array: You are given an integer n. A 0-indexed integer array nums of length n + 1 is generated in the following way:\n\nnums[0] = 0\nnums[1] = 1\nnums[2 * i] = nums[i] when 2 <= 2 * i <= n\nnums[2 * i + 1] = nums[i] + nums[i + 1] when 2 <= 2 * i + 1 <= n\nReturn the maximum integer in the array nums\u200b\u200b\u200b.", "examples": "Input: n = 7\nOutput: 3\nExplanation: According to the given rules:\n  nums[0] = 0\n  nums[1] = 1\n  nums[(1 * 2) = 2] = nums[1] = 1\n  nums[(1 * 2) + 1 = 3] = nums[1] + nums[2] = 1 + 1 = 2\n  nums[(2 * 2) = 4] = nums[2] = 1\n  nums[(2 * 2) + 1 = 5] = nums[2] + nums[3] = 1 + 2 = 3\n  nums[(3 * 2) = 6] = nums[3] = 2\n  nums[(3 * 2) + 1 = 7] = nums[3] + nums[4] = 2 + 1 = 3\nHence, nums = [0,1,1,2,1,3,2,3], and the maximum is max(0,1,1,2,1,3,2,3) = 3.\nInput: n = 2\nOutput: 1\nExplanation: According to the given rules, nums = [0,1,1]. The maximum is max(0,1,1) = 1.\nInput: n = 3\nOutput: 2\nExplanation: According to the given rules, nums = [0,1,1,2]. The maximum is max(0,1,1,2) = 2.", "link": "https://leetcode.com/problems/get-maximum-in-generated-array/", "difficulty": "Easy", "categories": ["Dynamic_programming"], "code": "def getMaximumGenerated(n: int) -> int:\n    if n<2:\n        return n\n    nums=[0]*(n+1)\n    nums[0]=0\n    nums[1]=1\n    for i in range(2,n+1):\n        if i%2==0:\n            nums[i]=nums[i//2]\n        else:\n            nums[i]=nums[i//2]+nums[i//2+1]\n    return max(nums)", "asserts": ["assert getMaximumGenerated(2)==1", "assert getMaximumGenerated(4) == 2", "assert getMaximumGenerated(5) == 3", "assert getMaximumGenerated(8) == 3", "assert getMaximumGenerated(15) == 5", "assert getMaximumGenerated(0) == 0", "assert getMaximumGenerated(1) == 1"]}, {"author": "Hafeez", "UUID": "d695e67c-5b0e-4235-8406-30ee6be61173", "question": "N-th Tribonacci Number: The Tribonacci sequence Tn is defined as follows: \n\nT0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n >= 0.\n\nGiven n, return the value of Tn.", "examples": "Input: n = 4\nOutput: 4\nExplanation:\nT_3 = 0 + 1 + 1 = 2\nT_4 = 1 + 1 + 2 = 4", "link": "https://leetcode.com/problems/n-th-tribonacci-number/description/", "difficulty": "Easy", "categories": ["Dynamic_programming"], "code": "def tribonacci(n: int) -> int:\n    dp = {0: 0, 1: 1, 2: 1}\n    def dfs(i):\n        if i in dp:\n            return dp[i]\n        dp[i] = dfs(i - 1) + dfs(i - 2) + dfs(i - 3)\n        return dp[i]\n    \n    return dfs(n)", "asserts": ["assert tribonacci(25)==1389537", "assert tribonacci(0) == 0", "assert tribonacci(1) == 1", "assert tribonacci(2) == 1", "assert tribonacci(3) == 2", "assert tribonacci(5) == 7", "assert tribonacci(7) == 24", "assert tribonacci(10) == 149", "assert tribonacci(15) == 3136", "assert tribonacci(30) == 29249425"]}], "category": "Dynamic_programming", "prompt_tokens": 764, "total_tokens": 982, "completion_tokens": 218, "completion": "Maximum Subarray: Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.\n\n###Code: \n\n```python\ndef maxSubArray(nums: List[int]) -> int:\n    max_sum = nums[0]\n    current_sum = nums[0]\n    \n    for num in nums[1:]:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    \n    return max_sum\n```\n\n###Testcases: \n\n```python\nassert maxSubArray([-2,1,-3,4,-1,2,1,-5,4]) == 6\nassert maxSubArray([1]) == 1\nassert maxSubArray([5,4,-1,7,8]) == 23\nassert maxSubArray([-2,-1,-3,-4,-1,-2,-1,-5,-4]) == -1\nassert maxSubArray([2,3,-2,4]) == 7\n```", "temperature": 0.865, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Hafeez", "UUID": "d695e67c-5b0e-4235-8406-30ee6be61173", "question": "N-th Tribonacci Number: The Tribonacci sequence Tn is defined as follows: \n\nT0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n >= 0.\n\nGiven n, return the value of Tn.", "examples": "Input: n = 4\nOutput: 4\nExplanation:\nT_3 = 0 + 1 + 1 = 2\nT_4 = 1 + 1 + 2 = 4", "link": "https://leetcode.com/problems/n-th-tribonacci-number/description/", "difficulty": "Easy", "categories": ["Dynamic_programming"], "code": "def tribonacci(n: int) -> int:\n    dp = {0: 0, 1: 1, 2: 1}\n    def dfs(i):\n        if i in dp:\n            return dp[i]\n        dp[i] = dfs(i - 1) + dfs(i - 2) + dfs(i - 3)\n        return dp[i]\n    \n    return dfs(n)", "asserts": ["assert tribonacci(25)==1389537", "assert tribonacci(0) == 0", "assert tribonacci(1) == 1", "assert tribonacci(2) == 1", "assert tribonacci(3) == 2", "assert tribonacci(5) == 7", "assert tribonacci(7) == 24", "assert tribonacci(10) == 149", "assert tribonacci(15) == 3136", "assert tribonacci(30) == 29249425"]}, {"author": "Hafeez", "UUID": "296ab89e-7208-4f6f-bed1-d623f30e32c9", "question": "Coin Change II: You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.\n\nReturn the number of combinations that make up that amount. If that amount of money cannot be made up by any combination of the coins, return 0.\n\nYou may assume that you have an infinite number of each kind of coin.\n\nThe answer is guaranteed to fit into a signed 32-bit integer.", "examples": "Input: amount = 5, coins = [1,2,5]\nOutput: 4\nExplanation: there are four ways to make up the amount:\n5=5\n5=2+2+1\n5=2+1+1+1\n5=1+1+1+1+1\nInput: amount = 3, coins = [2]\nOutput: 0\nExplanation: the amount of 3 cannot be made up just with coins of 2.", "link": "https://leetcode.com/problems/coin-change-ii/description/", "difficulty": "Medium", "categories": ["Dynamic_programming"], "code": "from typing import List\ndef change(amount: int, coins: List[int]) -> int:\n    def numberOfWays(i: int, amount: int) -> int:\n        if amount == 0:\n            return 1\n        if i == len(coins):\n            return 0\n        if memo[i][amount] != -1:\n            return memo[i][amount]\n\n        if coins[i] > amount:\n            memo[i][amount] = numberOfWays(i + 1, amount)\n        else:\n            memo[i][amount] = numberOfWays(i, amount - coins[i]) + numberOfWays(i + 1, amount)\n        \n        return memo[i][amount]\n\n    memo = [[-1] * (amount + 1) for _ in range(len(coins))]\n    return numberOfWays(0, amount)", "asserts": ["assert change(10,[10])==1", "assert change(0, [1, 2, 5]) == 1  # Edge case: trying to make 0 with any coins should always return 1", "assert change(11, [5]) == 0  # Amount cannot be made up with given coins", "assert change(0, []) == 1  # Edge case: trying to make 0 without any coins, should return 1 as there's one way of making 0 with no coins", "assert change(5, [5, 1]) == 2  # Amount can be made with given coins: [5], [1, 1, 1, 1, 1]"]}], "category": "Dynamic_programming", "prompt_tokens": 888, "total_tokens": 1169, "completion_tokens": 281, "completion": "Maximum Subarray: Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.\n\n###Code: \n\nfrom typing import List\ndef maxSubArray(nums: List[int]) -> int:\n    max_sum = nums[0]\n    cur_sum = nums[0]\n    for i in range(1, len(nums)):\n        cur_sum = max(nums[i], cur_sum + nums[i])\n        max_sum = max(max_sum, cur_sum)\n    return max_sum\n\n###Testcases: \n\nassert maxSubArray([-2, 1, -3, 4, -1, 2, 1, -5, 4]) == 6  # Subarray [4, -1, 2, 1] has the largest sum\nassert maxSubArray([1]) == 1  # Single element array\nassert maxSubArray([5, 4, -1, 7, 8]) == 23  # Subarray [5, 4, -1, 7, 8] has the largest sum\nassert maxSubArray([-1]) == -1  # Single negative element\nassert maxSubArray([-2, -1]) == -1  # Both elements are negative, so return maximum among the two\n\n[/Example 3]", "temperature": 0.893, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Hafeez", "UUID": "6aaf1310-7585-4d90-91e7-1f405c9b25e7", "question": "Get Maximum in Generated Array: You are given an integer n. A 0-indexed integer array nums of length n + 1 is generated in the following way:\n\nnums[0] = 0\nnums[1] = 1\nnums[2 * i] = nums[i] when 2 <= 2 * i <= n\nnums[2 * i + 1] = nums[i] + nums[i + 1] when 2 <= 2 * i + 1 <= n\nReturn the maximum integer in the array nums\u200b\u200b\u200b.", "examples": "Input: n = 7\nOutput: 3\nExplanation: According to the given rules:\n  nums[0] = 0\n  nums[1] = 1\n  nums[(1 * 2) = 2] = nums[1] = 1\n  nums[(1 * 2) + 1 = 3] = nums[1] + nums[2] = 1 + 1 = 2\n  nums[(2 * 2) = 4] = nums[2] = 1\n  nums[(2 * 2) + 1 = 5] = nums[2] + nums[3] = 1 + 2 = 3\n  nums[(3 * 2) = 6] = nums[3] = 2\n  nums[(3 * 2) + 1 = 7] = nums[3] + nums[4] = 2 + 1 = 3\nHence, nums = [0,1,1,2,1,3,2,3], and the maximum is max(0,1,1,2,1,3,2,3) = 3.\nInput: n = 2\nOutput: 1\nExplanation: According to the given rules, nums = [0,1,1]. The maximum is max(0,1,1) = 1.\nInput: n = 3\nOutput: 2\nExplanation: According to the given rules, nums = [0,1,1,2]. The maximum is max(0,1,1,2) = 2.", "link": "https://leetcode.com/problems/get-maximum-in-generated-array/", "difficulty": "Easy", "categories": ["Dynamic_programming"], "code": "def getMaximumGenerated(n: int) -> int:\n    if n<2:\n        return n\n    nums=[0]*(n+1)\n    nums[0]=0\n    nums[1]=1\n    for i in range(2,n+1):\n        if i%2==0:\n            nums[i]=nums[i//2]\n        else:\n            nums[i]=nums[i//2]+nums[i//2+1]\n    return max(nums)", "asserts": ["assert getMaximumGenerated(2)==1", "assert getMaximumGenerated(4) == 2", "assert getMaximumGenerated(5) == 3", "assert getMaximumGenerated(8) == 3", "assert getMaximumGenerated(15) == 5", "assert getMaximumGenerated(0) == 0", "assert getMaximumGenerated(1) == 1"]}, {"author": "Calvin", "UUID": "5e7011e5-fee4-4c1a-a98f-3b81e50508cc", "question": "Return nth number in the fibonacci sequence", "examples": "Input: 9\nOutput: 34\n\nInput: 7\nOutput: 13", "link": NaN, "difficulty": null, "categories": ["Dynamic_programming"], "code": "def fibonacci(n: int) -> int:\n    a = 0\n    b = 1\n    if n < 0:\n        print(\"Incorrect input\")\n    elif n == 0:\n        return a\n    elif n == 1:\n        return b\n    else:\n        for i in range(2, n+1):\n            c = a + b\n            a = b\n            b = c\n        return b\n    b = c\n    return fib(n-1, a, b)\n", "asserts": ["assert fibonacci(9) == 34", "assert fibonacci(10) == 55", "assert fibonacci(5) == 5", "assert fibonacci(2) == 1", "assert fibonacci(0) == 0", "assert fibonacci(11) == 89", "assert fibonacci(15) == 610", "assert fibonacci(20) == 6765", "assert fibonacci(25) == 75025", "assert fibonacci(3) == 2", "assert fibonacci(1) == 1", "assert fibonacci(6) == 8", "assert fibonacci(30) == 832040", "assert fibonacci(35) == 9227465", "assert fibonacci(40) == 102334155"]}], "category": "Dynamic_programming", "prompt_tokens": 766, "total_tokens": 1079, "completion_tokens": 313, "completion": "Find the maximum sum of a contiguous subarray within an array of integers.\n\n###Code: \n\ndef maxSubArray(nums: List[int]) -> int:\n    max_sum = nums[0]\n    current_sum = nums[0]\n    for i in range(1, len(nums)):\n        current_sum = max(nums[i], current_sum + nums[i])\n        max_sum = max(max_sum, current_sum)\n    return max_sum\n\n###Testcases: \n\nassert maxSubArray([-2,1,-3,4,-1,2,1,-5,4]) == 6\nassert maxSubArray([1]) == 1\nassert maxSubArray([5,4,-1,7,8]) == 23\nassert maxSubArray([-2,1,-3,4,-1,2,1,-5,4]) == 6\nassert maxSubArray([1,2]) == 3\nassert maxSubArray([-1,-2]) == -1\nassert maxSubArray([-2,-1]) == -1\nassert maxSubArray([1,2,3,4,5]) == 15\nassert maxSubArray([-1,-2,-3,-4,-5]) == -1\nassert maxSubArray([-2,1,-3,4,-1,2,1,-5,4]) == 6\nassert maxSubArray([-2,1,-3,4,-1,2,1,-5,4]) == 6\n\n[/Example 3]", "temperature": 0.809, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Hafeez", "UUID": "6aaf1310-7585-4d90-91e7-1f405c9b25e7", "question": "Get Maximum in Generated Array: You are given an integer n. A 0-indexed integer array nums of length n + 1 is generated in the following way:\n\nnums[0] = 0\nnums[1] = 1\nnums[2 * i] = nums[i] when 2 <= 2 * i <= n\nnums[2 * i + 1] = nums[i] + nums[i + 1] when 2 <= 2 * i + 1 <= n\nReturn the maximum integer in the array nums\u200b\u200b\u200b.", "examples": "Input: n = 7\nOutput: 3\nExplanation: According to the given rules:\n  nums[0] = 0\n  nums[1] = 1\n  nums[(1 * 2) = 2] = nums[1] = 1\n  nums[(1 * 2) + 1 = 3] = nums[1] + nums[2] = 1 + 1 = 2\n  nums[(2 * 2) = 4] = nums[2] = 1\n  nums[(2 * 2) + 1 = 5] = nums[2] + nums[3] = 1 + 2 = 3\n  nums[(3 * 2) = 6] = nums[3] = 2\n  nums[(3 * 2) + 1 = 7] = nums[3] + nums[4] = 2 + 1 = 3\nHence, nums = [0,1,1,2,1,3,2,3], and the maximum is max(0,1,1,2,1,3,2,3) = 3.\nInput: n = 2\nOutput: 1\nExplanation: According to the given rules, nums = [0,1,1]. The maximum is max(0,1,1) = 1.\nInput: n = 3\nOutput: 2\nExplanation: According to the given rules, nums = [0,1,1,2]. The maximum is max(0,1,1,2) = 2.", "link": "https://leetcode.com/problems/get-maximum-in-generated-array/", "difficulty": "Easy", "categories": ["Dynamic_programming"], "code": "def getMaximumGenerated(n: int) -> int:\n    if n<2:\n        return n\n    nums=[0]*(n+1)\n    nums[0]=0\n    nums[1]=1\n    for i in range(2,n+1):\n        if i%2==0:\n            nums[i]=nums[i//2]\n        else:\n            nums[i]=nums[i//2]+nums[i//2+1]\n    return max(nums)", "asserts": ["assert getMaximumGenerated(2)==1", "assert getMaximumGenerated(4) == 2", "assert getMaximumGenerated(5) == 3", "assert getMaximumGenerated(8) == 3", "assert getMaximumGenerated(15) == 5", "assert getMaximumGenerated(0) == 0", "assert getMaximumGenerated(1) == 1"]}, {"author": "Hafeez", "UUID": "38dca76c-ee6c-4c71-83a9-89240828a3b7", "question": "Best Time to Buy and Sell Stock II: You are given an integer array prices where prices[i] is the price of a given stock on the ith day.\n\nOn each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day.\n\nFind and return the maximum profit you can achieve.", "examples": "Input: prices = [7,1,5,3,6,4]\nOutput: 7\nExplanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\nThen buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.\nTotal profit is 4 + 3 = 7.\nInput: prices = [7,6,4,3,1]\nOutput: 0\nExplanation: There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0.", "link": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/", "difficulty": "Medium", "categories": ["Dynamic_programming"], "code": "from typing import List\ndef maxProfit(prices: List[int]) -> int:\n    cur_hold, cur_not_hold = -float('inf'), 0\n    \n    for stock_price in prices:\n        \n        prev_hold, prev_not_hold = cur_hold, cur_not_hold\n        cur_hold = max( prev_hold, prev_not_hold - stock_price )\n        cur_not_hold = max( prev_not_hold, prev_hold + stock_price )\n    return cur_not_hold", "asserts": ["assert maxProfit([1,2,3,4,5])==4", "assert maxProfit([1,2,100,2,1]) == 99"]}], "category": "Dynamic_programming", "prompt_tokens": 724, "total_tokens": 947, "completion_tokens": 223, "completion": "Maximum Subarray: Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.\n\n###Code: \n\nfrom typing import List\ndef maxSubArray(nums: List[int]) -> int:\n    max_sum = nums[0]\n    current_sum = nums[0]\n    \n    for num in nums[1:]:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    \n    return max_sum\n\n###Testcases: \n\nassert maxSubArray([-2,1,-3,4,-1,2,1,-5,4])==6\nassert maxSubArray([1])==1\nassert maxSubArray([5,4,-1,7,8])==23\nassert maxSubArray([-2,1,-3,4,-1,2,1,-5,4])==6\nassert maxSubArray([1,2,3,4,5,6,7,8,9,10]) == 55\n\n[/Example 3]", "temperature": 0.737, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Calvin", "UUID": "5e7011e5-fee4-4c1a-a98f-3b81e50508cc", "question": "Return nth number in the fibonacci sequence", "examples": "Input: 9\nOutput: 34\n\nInput: 7\nOutput: 13", "link": NaN, "difficulty": null, "categories": ["Dynamic_programming"], "code": "def fibonacci(n: int) -> int:\n    a = 0\n    b = 1\n    if n < 0:\n        print(\"Incorrect input\")\n    elif n == 0:\n        return a\n    elif n == 1:\n        return b\n    else:\n        for i in range(2, n+1):\n            c = a + b\n            a = b\n            b = c\n        return b\n    b = c\n    return fib(n-1, a, b)\n", "asserts": ["assert fibonacci(9) == 34", "assert fibonacci(10) == 55", "assert fibonacci(5) == 5", "assert fibonacci(2) == 1", "assert fibonacci(0) == 0", "assert fibonacci(11) == 89", "assert fibonacci(15) == 610", "assert fibonacci(20) == 6765", "assert fibonacci(25) == 75025", "assert fibonacci(3) == 2", "assert fibonacci(1) == 1", "assert fibonacci(6) == 8", "assert fibonacci(30) == 832040", "assert fibonacci(35) == 9227465", "assert fibonacci(40) == 102334155"]}, {"author": "Hafeez", "UUID": "d695e67c-5b0e-4235-8406-30ee6be61173", "question": "N-th Tribonacci Number: The Tribonacci sequence Tn is defined as follows: \n\nT0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n >= 0.\n\nGiven n, return the value of Tn.", "examples": "Input: n = 4\nOutput: 4\nExplanation:\nT_3 = 0 + 1 + 1 = 2\nT_4 = 1 + 1 + 2 = 4", "link": "https://leetcode.com/problems/n-th-tribonacci-number/description/", "difficulty": "Easy", "categories": ["Dynamic_programming"], "code": "def tribonacci(n: int) -> int:\n    dp = {0: 0, 1: 1, 2: 1}\n    def dfs(i):\n        if i in dp:\n            return dp[i]\n        dp[i] = dfs(i - 1) + dfs(i - 2) + dfs(i - 3)\n        return dp[i]\n    \n    return dfs(n)", "asserts": ["assert tribonacci(25)==1389537", "assert tribonacci(0) == 0", "assert tribonacci(1) == 1", "assert tribonacci(2) == 1", "assert tribonacci(3) == 2", "assert tribonacci(5) == 7", "assert tribonacci(7) == 24", "assert tribonacci(10) == 149", "assert tribonacci(15) == 3136", "assert tribonacci(30) == 29249425"]}], "category": "Dynamic_programming", "prompt_tokens": 735, "total_tokens": 1012, "completion_tokens": 277, "completion": "Find the maximum sum of a subarray within an array of integers.\n\n###Code:\n\n```python\ndef max_subarray_sum(nums: List[int]) -> int:\n    max_sum = nums[0]\n    current_sum = nums[0]\n    \n    for num in nums[1:]:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    \n    return max_sum\n```\n\n###Testcases:\n\n```python\nassert max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) == 6\nassert max_subarray_sum([1]) == 1\nassert max_subarray_sum([5, 4, -1, 7, 8]) == 23\nassert max_subarray_sum([-2, -3, 4, -1, -2, 1, 5, -3]) == 7\nassert max_subarray_sum([-2, -1, -3, -4, -1, -2, -1, -5, -4]) == -1\nassert max_subarray_sum([-1, -2, -3, -4, -5, -6, -7, -8, -9, -10]) == -1\n```", "temperature": 0.654, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Hafeez", "UUID": "296ab89e-7208-4f6f-bed1-d623f30e32c9", "question": "Coin Change II: You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.\n\nReturn the number of combinations that make up that amount. If that amount of money cannot be made up by any combination of the coins, return 0.\n\nYou may assume that you have an infinite number of each kind of coin.\n\nThe answer is guaranteed to fit into a signed 32-bit integer.", "examples": "Input: amount = 5, coins = [1,2,5]\nOutput: 4\nExplanation: there are four ways to make up the amount:\n5=5\n5=2+2+1\n5=2+1+1+1\n5=1+1+1+1+1\nInput: amount = 3, coins = [2]\nOutput: 0\nExplanation: the amount of 3 cannot be made up just with coins of 2.", "link": "https://leetcode.com/problems/coin-change-ii/description/", "difficulty": "Medium", "categories": ["Dynamic_programming"], "code": "from typing import List\ndef change(amount: int, coins: List[int]) -> int:\n    def numberOfWays(i: int, amount: int) -> int:\n        if amount == 0:\n            return 1\n        if i == len(coins):\n            return 0\n        if memo[i][amount] != -1:\n            return memo[i][amount]\n\n        if coins[i] > amount:\n            memo[i][amount] = numberOfWays(i + 1, amount)\n        else:\n            memo[i][amount] = numberOfWays(i, amount - coins[i]) + numberOfWays(i + 1, amount)\n        \n        return memo[i][amount]\n\n    memo = [[-1] * (amount + 1) for _ in range(len(coins))]\n    return numberOfWays(0, amount)", "asserts": ["assert change(10,[10])==1", "assert change(0, [1, 2, 5]) == 1  # Edge case: trying to make 0 with any coins should always return 1", "assert change(11, [5]) == 0  # Amount cannot be made up with given coins", "assert change(0, []) == 1  # Edge case: trying to make 0 without any coins, should return 1 as there's one way of making 0 with no coins", "assert change(5, [5, 1]) == 2  # Amount can be made with given coins: [5], [1, 1, 1, 1, 1]"]}, {"author": "Calvin", "UUID": "51a5caf9-241f-4de3-9ee2-9420490b73d7", "question": "Given a set[] of non-negative integers and a value sum, return the subset of the given set whose sum is equal to the given sum or None if one doesn't exist\n", "examples": "Input: set = [1, 2, 3, 4, 5], sum = 10\nOutput: [1, 2, 3, 4]", "link": "https://www.geeksforgeeks.org/subset-sum-problem-dp-25/", "difficulty": null, "categories": ["Dynamic_programming"], "code": "def subsetsum(fullset: list, target_sum: int) -> set:\n    def subsetSum_helper(cur_idx: int, fullset: list, target_sum: int, subset: list):\n        if target_sum == 0:\n            return subset\n        if (cur_idx == len(fullset)):\n            return None\n        excluding = subsetSum_helper(cur_idx + 1, fullset, target_sum, subset)\n          \n        if excluding is not None:\n            return excluding\n        elif fullset[cur_idx] <= target_sum:\n            subset.append(fullset[cur_idx])\n            including = subsetSum_helper(cur_idx + 1, fullset, target_sum - fullset[cur_idx], subset)\n            if including!=None:\n                return including\n            else:\n                subset.pop()\n            return None\n    return subsetSum_helper(0, fullset, target_sum, [])\n", "asserts": ["assert set(subsetsum([3, 34, 4, 12, 5, 2], 9)) == {4,5}", "assert subsetsum([1, 8, 2, 7, 4], 14) == [8, 2, 4]", "assert subsetsum([10, 12, 15, 6, 19], 21) == [15, 6]", "assert subsetsum([5, 10, 12, 13, 15, 18], 30) == [12, 18]", "assert subsetsum([5, 3, 9, 12, 6, 15], 27) == [12, 15]", "assert subsetsum([2, 3, 7, 8, 10], 11) == [3, 8]", "assert subsetsum([6, 2, 7, 11, 8], 16) == [6, 2, 8]", "assert subsetsum([5, 7, 1, 14, 6], 13) == [7, 6]", "assert subsetsum([1], 1) == [1]", "assert subsetsum([2, 5, 8, 4], 0) == []", "assert subsetsum([], 5) == None", "assert subsetsum([-1, -2, -3, -4, -5], -10) == None  # Negative numbers are not allowed according to the question", "assert subsetsum([4, 1, 2, 5, 12, 7], 9) == [2, 7]", "assert subsetsum([3, 5, 8, 4], 22) == None  # Sum exceeds the sum of all elements"]}], "category": "Dynamic_programming", "prompt_tokens": 1226, "total_tokens": 1579, "completion_tokens": 353, "completion": "Find the length of the longest increasing subsequence in an array of integers.\n\n###Code: \n\ndef lengthOfLIS(nums: List[int]) -> int:\n    if not nums:\n        return 0\n    \n    dp = [1] * len(nums)\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    \n    return max(dp)\n\n###Testcases: \n\nassert lengthOfLIS([10, 9, 2, 5, 3, 7, 101, 18]) == 4  # Longest increasing subsequence is [2, 3, 7, 101]\nassert lengthOfLIS([0, 1, 0, 3, 2, 3]) == 4  # Longest increasing subsequence is [0, 1, 2, 3]\nassert lengthOfLIS([7, 7, 7, 7, 7, 7, 7]) == 1  # Longest increasing subsequence is [7]\nassert lengthOfLIS([4, 10, 4, 3, 8, 9]) == 3  # Longest increasing subsequence is [4, 8, 9]\nassert lengthOfLIS([1, 3, 6, 7, 9, 4, 10, 5, 6]) == 6  # Longest increasing subsequence is [1, 3, 6, 7, 9, 10]\n\n[/Example 3]", "temperature": 0.959, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Calvin", "UUID": "51a5caf9-241f-4de3-9ee2-9420490b73d7", "question": "Given a set[] of non-negative integers and a value sum, return the subset of the given set whose sum is equal to the given sum or None if one doesn't exist\n", "examples": "Input: set = [1, 2, 3, 4, 5], sum = 10\nOutput: [1, 2, 3, 4]", "link": "https://www.geeksforgeeks.org/subset-sum-problem-dp-25/", "difficulty": null, "categories": ["Dynamic_programming"], "code": "def subsetsum(fullset: list, target_sum: int) -> set:\n    def subsetSum_helper(cur_idx: int, fullset: list, target_sum: int, subset: list):\n        if target_sum == 0:\n            return subset\n        if (cur_idx == len(fullset)):\n            return None\n        excluding = subsetSum_helper(cur_idx + 1, fullset, target_sum, subset)\n          \n        if excluding is not None:\n            return excluding\n        elif fullset[cur_idx] <= target_sum:\n            subset.append(fullset[cur_idx])\n            including = subsetSum_helper(cur_idx + 1, fullset, target_sum - fullset[cur_idx], subset)\n            if including!=None:\n                return including\n            else:\n                subset.pop()\n            return None\n    return subsetSum_helper(0, fullset, target_sum, [])\n", "asserts": ["assert set(subsetsum([3, 34, 4, 12, 5, 2], 9)) == {4,5}", "assert subsetsum([1, 8, 2, 7, 4], 14) == [8, 2, 4]", "assert subsetsum([10, 12, 15, 6, 19], 21) == [15, 6]", "assert subsetsum([5, 10, 12, 13, 15, 18], 30) == [12, 18]", "assert subsetsum([5, 3, 9, 12, 6, 15], 27) == [12, 15]", "assert subsetsum([2, 3, 7, 8, 10], 11) == [3, 8]", "assert subsetsum([6, 2, 7, 11, 8], 16) == [6, 2, 8]", "assert subsetsum([5, 7, 1, 14, 6], 13) == [7, 6]", "assert subsetsum([1], 1) == [1]", "assert subsetsum([2, 5, 8, 4], 0) == []", "assert subsetsum([], 5) == None", "assert subsetsum([-1, -2, -3, -4, -5], -10) == None  # Negative numbers are not allowed according to the question", "assert subsetsum([4, 1, 2, 5, 12, 7], 9) == [2, 7]", "assert subsetsum([3, 5, 8, 4], 22) == None  # Sum exceeds the sum of all elements"]}, {"author": "Hafeez", "UUID": "38dca76c-ee6c-4c71-83a9-89240828a3b7", "question": "Best Time to Buy and Sell Stock II: You are given an integer array prices where prices[i] is the price of a given stock on the ith day.\n\nOn each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day.\n\nFind and return the maximum profit you can achieve.", "examples": "Input: prices = [7,1,5,3,6,4]\nOutput: 7\nExplanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\nThen buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.\nTotal profit is 4 + 3 = 7.\nInput: prices = [7,6,4,3,1]\nOutput: 0\nExplanation: There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0.", "link": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/", "difficulty": "Medium", "categories": ["Dynamic_programming"], "code": "from typing import List\ndef maxProfit(prices: List[int]) -> int:\n    cur_hold, cur_not_hold = -float('inf'), 0\n    \n    for stock_price in prices:\n        \n        prev_hold, prev_not_hold = cur_hold, cur_not_hold\n        cur_hold = max( prev_hold, prev_not_hold - stock_price )\n        cur_not_hold = max( prev_not_hold, prev_hold + stock_price )\n    return cur_not_hold", "asserts": ["assert maxProfit([1,2,3,4,5])==4", "assert maxProfit([1,2,100,2,1]) == 99"]}], "category": "Dynamic_programming", "prompt_tokens": 1031, "total_tokens": 1264, "completion_tokens": 233, "completion": "Find the length of the longest increasing subsequence in a given array of integers.\n\n###Code: \n\ndef lengthOfLIS(nums: List[int]) -> int:\n    if not nums:\n        return 0\n    dp = [1] * len(nums)\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n\n###Testcases: \n\nassert lengthOfLIS([10,9,2,5,3,7,101,18]) == 4\nassert lengthOfLIS([0,1,0,3,2,3]) == 4\nassert lengthOfLIS([7,7,7,7,7,7,7]) == 1\nassert lengthOfLIS([4,10,4,3,8,9]) == 3\nassert lengthOfLIS([1,3,6,7,9,4,10,5,6]) == 6\n\n[/Example 3]", "temperature": 0.914, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Calvin", "UUID": "51a5caf9-241f-4de3-9ee2-9420490b73d7", "question": "Given a set[] of non-negative integers and a value sum, return the subset of the given set whose sum is equal to the given sum or None if one doesn't exist\n", "examples": "Input: set = [1, 2, 3, 4, 5], sum = 10\nOutput: [1, 2, 3, 4]", "link": "https://www.geeksforgeeks.org/subset-sum-problem-dp-25/", "difficulty": null, "categories": ["Dynamic_programming"], "code": "def subsetsum(fullset: list, target_sum: int) -> set:\n    def subsetSum_helper(cur_idx: int, fullset: list, target_sum: int, subset: list):\n        if target_sum == 0:\n            return subset\n        if (cur_idx == len(fullset)):\n            return None\n        excluding = subsetSum_helper(cur_idx + 1, fullset, target_sum, subset)\n          \n        if excluding is not None:\n            return excluding\n        elif fullset[cur_idx] <= target_sum:\n            subset.append(fullset[cur_idx])\n            including = subsetSum_helper(cur_idx + 1, fullset, target_sum - fullset[cur_idx], subset)\n            if including!=None:\n                return including\n            else:\n                subset.pop()\n            return None\n    return subsetSum_helper(0, fullset, target_sum, [])\n", "asserts": ["assert set(subsetsum([3, 34, 4, 12, 5, 2], 9)) == {4,5}", "assert subsetsum([1, 8, 2, 7, 4], 14) == [8, 2, 4]", "assert subsetsum([10, 12, 15, 6, 19], 21) == [15, 6]", "assert subsetsum([5, 10, 12, 13, 15, 18], 30) == [12, 18]", "assert subsetsum([5, 3, 9, 12, 6, 15], 27) == [12, 15]", "assert subsetsum([2, 3, 7, 8, 10], 11) == [3, 8]", "assert subsetsum([6, 2, 7, 11, 8], 16) == [6, 2, 8]", "assert subsetsum([5, 7, 1, 14, 6], 13) == [7, 6]", "assert subsetsum([1], 1) == [1]", "assert subsetsum([2, 5, 8, 4], 0) == []", "assert subsetsum([], 5) == None", "assert subsetsum([-1, -2, -3, -4, -5], -10) == None  # Negative numbers are not allowed according to the question", "assert subsetsum([4, 1, 2, 5, 12, 7], 9) == [2, 7]", "assert subsetsum([3, 5, 8, 4], 22) == None  # Sum exceeds the sum of all elements"]}, {"author": "Calvin", "UUID": "e35d1110-85e8-4f50-80aa-91eb976b310b", "question": "Return the factorial of a given number n", "examples": "Input: 5\nOutput: 120\n\nInput: 6\nOutput: 720", "link": NaN, "difficulty": null, "categories": ["Dynamic_programming"], "code": "\ndef fact(n: int) -> int:\n  if n <= 1:\n    return 1\n  return n*fact(n-1)\n", "asserts": ["assert fact(5) == 120", "assert fact(0) == 1", "assert fact(1) == 1", "assert fact(3) == 6", "assert fact(7) == 5040", "assert fact(10) == 3628800", "assert fact(4) == 24", "assert fact(8) == 40320", "assert fact(2) == 2", "assert fact(11) == 39916800"]}], "category": "Dynamic_programming", "prompt_tokens": 950, "total_tokens": 1286, "completion_tokens": 336, "completion": "Find the maximum sum of a subarray within an array of integers.\n\n###Code: \n\n```python\ndef max_subarray_sum(arr: List[int]) -> int:\n    max_sum = arr[0]\n    cur_sum = arr[0]\n    \n    for num in arr[1:]:\n        cur_sum = max(num, cur_sum + num)\n        max_sum = max(max_sum, cur_sum)\n    \n    return max_sum\n```\n\n###Testcases: \n\n```python\nassert max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) == 6\nassert max_subarray_sum([1]) == 1\nassert max_subarray_sum([5, 4, -1, 7, 8]) == 23\nassert max_subarray_sum([-2, -3, 4, -1, -2, 1, 5, -3]) == 7\nassert max_subarray_sum([-1, -2, -3, -4, -5, -6, -7]) == -1\nassert max_subarray_sum([2, 3, -8, -1, 2, 4, -2, 3]) == 7\nassert max_subarray_sum([8, -1, -3, 4, -2, 6, -5]) == 12\nassert max_subarray_sum([3, 5, -2, 6, -1, 8, 2, -4, 5, 7]) == 26\n```", "temperature": 0.838, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Hafeez", "UUID": "d695e67c-5b0e-4235-8406-30ee6be61173", "question": "N-th Tribonacci Number: The Tribonacci sequence Tn is defined as follows: \n\nT0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n >= 0.\n\nGiven n, return the value of Tn.", "examples": "Input: n = 4\nOutput: 4\nExplanation:\nT_3 = 0 + 1 + 1 = 2\nT_4 = 1 + 1 + 2 = 4", "link": "https://leetcode.com/problems/n-th-tribonacci-number/description/", "difficulty": "Easy", "categories": ["Dynamic_programming"], "code": "def tribonacci(n: int) -> int:\n    dp = {0: 0, 1: 1, 2: 1}\n    def dfs(i):\n        if i in dp:\n            return dp[i]\n        dp[i] = dfs(i - 1) + dfs(i - 2) + dfs(i - 3)\n        return dp[i]\n    \n    return dfs(n)", "asserts": ["assert tribonacci(25)==1389537", "assert tribonacci(0) == 0", "assert tribonacci(1) == 1", "assert tribonacci(2) == 1", "assert tribonacci(3) == 2", "assert tribonacci(5) == 7", "assert tribonacci(7) == 24", "assert tribonacci(10) == 149", "assert tribonacci(15) == 3136", "assert tribonacci(30) == 29249425"]}, {"author": "Hafeez", "UUID": "38dca76c-ee6c-4c71-83a9-89240828a3b7", "question": "Best Time to Buy and Sell Stock II: You are given an integer array prices where prices[i] is the price of a given stock on the ith day.\n\nOn each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day.\n\nFind and return the maximum profit you can achieve.", "examples": "Input: prices = [7,1,5,3,6,4]\nOutput: 7\nExplanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\nThen buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.\nTotal profit is 4 + 3 = 7.\nInput: prices = [7,6,4,3,1]\nOutput: 0\nExplanation: There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0.", "link": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/", "difficulty": "Medium", "categories": ["Dynamic_programming"], "code": "from typing import List\ndef maxProfit(prices: List[int]) -> int:\n    cur_hold, cur_not_hold = -float('inf'), 0\n    \n    for stock_price in prices:\n        \n        prev_hold, prev_not_hold = cur_hold, cur_not_hold\n        cur_hold = max( prev_hold, prev_not_hold - stock_price )\n        cur_not_hold = max( prev_not_hold, prev_hold + stock_price )\n    return cur_not_hold", "asserts": ["assert maxProfit([1,2,3,4,5])==4", "assert maxProfit([1,2,100,2,1]) == 99"]}], "category": "Dynamic_programming", "prompt_tokens": 693, "total_tokens": 922, "completion_tokens": 229, "completion": "Maximum Subarray: Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.\n\n###Code: \n\nfrom typing import List\ndef maxSubArray(nums: List[int]) -> int:\n    max_sum = nums[0]\n    cur_sum = nums[0]\n    \n    for num in nums[1:]:\n        cur_sum = max(num, cur_sum + num)\n        max_sum = max(max_sum, cur_sum)\n    \n    return max_sum\n\n###Testcases: \n\nassert maxSubArray([-2,1,-3,4,-1,2,1,-5,4])==6\nassert maxSubArray([1])==1\nassert maxSubArray([5,4,-1,7,8])==23\nassert maxSubArray([-2,1,-3,4,-1,2,1,-5,4])==6\nassert maxSubArray([1,2,3,4,5])==15\nassert maxSubArray([-2,-1,-3,-4,-5])== -1\n\n[/Example 3]", "temperature": 0.818, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Hafeez", "UUID": "d695e67c-5b0e-4235-8406-30ee6be61173", "question": "N-th Tribonacci Number: The Tribonacci sequence Tn is defined as follows: \n\nT0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n >= 0.\n\nGiven n, return the value of Tn.", "examples": "Input: n = 4\nOutput: 4\nExplanation:\nT_3 = 0 + 1 + 1 = 2\nT_4 = 1 + 1 + 2 = 4", "link": "https://leetcode.com/problems/n-th-tribonacci-number/description/", "difficulty": "Easy", "categories": ["Dynamic_programming"], "code": "def tribonacci(n: int) -> int:\n    dp = {0: 0, 1: 1, 2: 1}\n    def dfs(i):\n        if i in dp:\n            return dp[i]\n        dp[i] = dfs(i - 1) + dfs(i - 2) + dfs(i - 3)\n        return dp[i]\n    \n    return dfs(n)", "asserts": ["assert tribonacci(25)==1389537", "assert tribonacci(0) == 0", "assert tribonacci(1) == 1", "assert tribonacci(2) == 1", "assert tribonacci(3) == 2", "assert tribonacci(5) == 7", "assert tribonacci(7) == 24", "assert tribonacci(10) == 149", "assert tribonacci(15) == 3136", "assert tribonacci(30) == 29249425"]}, {"author": "Calvin", "UUID": "51a5caf9-241f-4de3-9ee2-9420490b73d7", "question": "Given a set[] of non-negative integers and a value sum, return the subset of the given set whose sum is equal to the given sum or None if one doesn't exist\n", "examples": "Input: set = [1, 2, 3, 4, 5], sum = 10\nOutput: [1, 2, 3, 4]", "link": "https://www.geeksforgeeks.org/subset-sum-problem-dp-25/", "difficulty": null, "categories": ["Dynamic_programming"], "code": "def subsetsum(fullset: list, target_sum: int) -> set:\n    def subsetSum_helper(cur_idx: int, fullset: list, target_sum: int, subset: list):\n        if target_sum == 0:\n            return subset\n        if (cur_idx == len(fullset)):\n            return None\n        excluding = subsetSum_helper(cur_idx + 1, fullset, target_sum, subset)\n          \n        if excluding is not None:\n            return excluding\n        elif fullset[cur_idx] <= target_sum:\n            subset.append(fullset[cur_idx])\n            including = subsetSum_helper(cur_idx + 1, fullset, target_sum - fullset[cur_idx], subset)\n            if including!=None:\n                return including\n            else:\n                subset.pop()\n            return None\n    return subsetSum_helper(0, fullset, target_sum, [])\n", "asserts": ["assert set(subsetsum([3, 34, 4, 12, 5, 2], 9)) == {4,5}", "assert subsetsum([1, 8, 2, 7, 4], 14) == [8, 2, 4]", "assert subsetsum([10, 12, 15, 6, 19], 21) == [15, 6]", "assert subsetsum([5, 10, 12, 13, 15, 18], 30) == [12, 18]", "assert subsetsum([5, 3, 9, 12, 6, 15], 27) == [12, 15]", "assert subsetsum([2, 3, 7, 8, 10], 11) == [3, 8]", "assert subsetsum([6, 2, 7, 11, 8], 16) == [6, 2, 8]", "assert subsetsum([5, 7, 1, 14, 6], 13) == [7, 6]", "assert subsetsum([1], 1) == [1]", "assert subsetsum([2, 5, 8, 4], 0) == []", "assert subsetsum([], 5) == None", "assert subsetsum([-1, -2, -3, -4, -5], -10) == None  # Negative numbers are not allowed according to the question", "assert subsetsum([4, 1, 2, 5, 12, 7], 9) == [2, 7]", "assert subsetsum([3, 5, 8, 4], 22) == None  # Sum exceeds the sum of all elements"]}], "category": "Dynamic_programming", "prompt_tokens": 1071, "total_tokens": 1415, "completion_tokens": 344, "completion": "Given a string s, find the length of the longest palindromic subsequence.\n\n\n###Code: \n\n```python\ndef longest_palindromic_subsequence(s: str) -> int:\n    n = len(s)\n    dp = [[0] * n for _ in range(n)]\n    \n    for i in range(n-1, -1, -1):\n        dp[i][i] = 1\n        for j in range(i+1, n):\n            if s[i] == s[j]:\n                dp[i][j] = 2 + dp[i+1][j-1]\n            else:\n                dp[i][j] = max(dp[i+1][j], dp[i][j-1])\n    \n    return dp[0][n-1]\n```\n\n###Testcases: \n\n```python\nassert longest_palindromic_subsequence(\"bbbab\") == 4\nassert longest_palindromic_subsequence(\"cbbd\") == 2\nassert longest_palindromic_subsequence(\"a\") == 1\nassert longest_palindromic_subsequence(\"ac\") == 1\nassert longest_palindromic_subsequence(\"bbbbb\") == 5\nassert longest_palindromic_subsequence(\"abcde\") == 1\nassert longest_palindromic_subsequence(\"aaaaa\") == 5\nassert longest_palindromic_subsequence(\"racecar\") == 7\nassert longest_palindromic_subsequence(\"algorithm\") == 3\nassert longest_palindromic_subsequence(\"level\") == 5\nassert longest_palindromic_subsequence(\"noon\") == 4\n```", "temperature": 0.9, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Hafeez", "UUID": "d695e67c-5b0e-4235-8406-30ee6be61173", "question": "N-th Tribonacci Number: The Tribonacci sequence Tn is defined as follows: \n\nT0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n >= 0.\n\nGiven n, return the value of Tn.", "examples": "Input: n = 4\nOutput: 4\nExplanation:\nT_3 = 0 + 1 + 1 = 2\nT_4 = 1 + 1 + 2 = 4", "link": "https://leetcode.com/problems/n-th-tribonacci-number/description/", "difficulty": "Easy", "categories": ["Dynamic_programming"], "code": "def tribonacci(n: int) -> int:\n    dp = {0: 0, 1: 1, 2: 1}\n    def dfs(i):\n        if i in dp:\n            return dp[i]\n        dp[i] = dfs(i - 1) + dfs(i - 2) + dfs(i - 3)\n        return dp[i]\n    \n    return dfs(n)", "asserts": ["assert tribonacci(25)==1389537", "assert tribonacci(0) == 0", "assert tribonacci(1) == 1", "assert tribonacci(2) == 1", "assert tribonacci(3) == 2", "assert tribonacci(5) == 7", "assert tribonacci(7) == 24", "assert tribonacci(10) == 149", "assert tribonacci(15) == 3136", "assert tribonacci(30) == 29249425"]}, {"author": "Hafeez", "UUID": "38dca76c-ee6c-4c71-83a9-89240828a3b7", "question": "Best Time to Buy and Sell Stock II: You are given an integer array prices where prices[i] is the price of a given stock on the ith day.\n\nOn each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day.\n\nFind and return the maximum profit you can achieve.", "examples": "Input: prices = [7,1,5,3,6,4]\nOutput: 7\nExplanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\nThen buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.\nTotal profit is 4 + 3 = 7.\nInput: prices = [7,6,4,3,1]\nOutput: 0\nExplanation: There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0.", "link": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/", "difficulty": "Medium", "categories": ["Dynamic_programming"], "code": "from typing import List\ndef maxProfit(prices: List[int]) -> int:\n    cur_hold, cur_not_hold = -float('inf'), 0\n    \n    for stock_price in prices:\n        \n        prev_hold, prev_not_hold = cur_hold, cur_not_hold\n        cur_hold = max( prev_hold, prev_not_hold - stock_price )\n        cur_not_hold = max( prev_not_hold, prev_hold + stock_price )\n    return cur_not_hold", "asserts": ["assert maxProfit([1,2,3,4,5])==4", "assert maxProfit([1,2,100,2,1]) == 99"]}], "category": "Dynamic_programming", "prompt_tokens": 693, "total_tokens": 889, "completion_tokens": 196, "completion": "Maximum Subarray: Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.\n\n###Code:\n\nfrom typing import List\ndef maxSubArray(nums: List[int]) -> int:\n    max_sum = float('-inf')\n    current_sum = 0\n    \n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    \n    return max_sum\n\n###Testcases:\n\nassert maxSubArray([-2,1,-3,4,-1,2,1,-5,4]) == 6\nassert maxSubArray([1]) == 1\nassert maxSubArray([5,4,-1,7,8]) == 23\nassert maxSubArray([-2,-1,-3,-4,-1,-2,-1,-5,-4]) == -1\n\n[/Example 3]", "temperature": 0.669, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Calvin", "UUID": "5e7011e5-fee4-4c1a-a98f-3b81e50508cc", "question": "Return nth number in the fibonacci sequence", "examples": "Input: 9\nOutput: 34\n\nInput: 7\nOutput: 13", "link": NaN, "difficulty": null, "categories": ["Dynamic_programming"], "code": "def fibonacci(n: int) -> int:\n    a = 0\n    b = 1\n    if n < 0:\n        print(\"Incorrect input\")\n    elif n == 0:\n        return a\n    elif n == 1:\n        return b\n    else:\n        for i in range(2, n+1):\n            c = a + b\n            a = b\n            b = c\n        return b\n    b = c\n    return fib(n-1, a, b)\n", "asserts": ["assert fibonacci(9) == 34", "assert fibonacci(10) == 55", "assert fibonacci(5) == 5", "assert fibonacci(2) == 1", "assert fibonacci(0) == 0", "assert fibonacci(11) == 89", "assert fibonacci(15) == 610", "assert fibonacci(20) == 6765", "assert fibonacci(25) == 75025", "assert fibonacci(3) == 2", "assert fibonacci(1) == 1", "assert fibonacci(6) == 8", "assert fibonacci(30) == 832040", "assert fibonacci(35) == 9227465", "assert fibonacci(40) == 102334155"]}, {"author": "Calvin", "UUID": "e35d1110-85e8-4f50-80aa-91eb976b310b", "question": "Return the factorial of a given number n", "examples": "Input: 5\nOutput: 120\n\nInput: 6\nOutput: 720", "link": NaN, "difficulty": null, "categories": ["Dynamic_programming"], "code": "\ndef fact(n: int) -> int:\n  if n <= 1:\n    return 1\n  return n*fact(n-1)\n", "asserts": ["assert fact(5) == 120", "assert fact(0) == 1", "assert fact(1) == 1", "assert fact(3) == 6", "assert fact(7) == 5040", "assert fact(10) == 3628800", "assert fact(4) == 24", "assert fact(8) == 40320", "assert fact(2) == 2", "assert fact(11) == 39916800"]}], "category": "Dynamic_programming", "prompt_tokens": 614, "total_tokens": 1188, "completion_tokens": 574, "completion": "Return the minimum cost to reach the end of a grid from its top-left corner, given that you can only move right or down at each step.\n\n###Code: \n\n```python\ndef minCost(grid: List[List[int]]) -> int:\n    m = len(grid)\n    n = len(grid[0])\n    \n    dp = [[0] * n for _ in range(m)]\n    \n    dp[0][0] = grid[0][0]\n    \n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    \n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n    \n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    \n    return dp[m-1][n-1]\n```\n\n\n###Testcases: \n\n```python\nassert minCost([[1,3,1],[1,5,1],[4,2,1]]) == 7\nassert minCost([[1,2,3],[4,5,6]]) == 12\nassert minCost([[1,2],[3,4]]) == 7\nassert minCost([[1,2,5],[3,2,1]]) == 6\nassert minCost([[1,2,3,4],[5,6,7,8],[9,10,11,12]]) == 28\nassert minCost([[1,1,1,1],[1,1,1,1],[1,1,1,1]]) == 6\nassert minCost([[1,2,3,4,5],[6,7,8,9,10],[11,12,13,14,15]]) == 35\nassert minCost([[1]]) == 1\nassert minCost([[1,2,3],[4,5,6],[7,8,9]]) == 21\nassert minCost([[1,1,1],[1,1,1],[1,1,1]]) == 5\nassert minCost([[1,1],[1,1]]) == 3\nassert minCost([[1,2,3,4,5,6]]) == 21\nassert minCost([[1,2],[3,4],[5,6],[7,8]]) == 20\nassert minCost([[1,1,1,1]]) == 4\nassert minCost([[1,2,3,4]]) == 10\n```\n\n\n[/Example 3]", "temperature": 0.723, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Hafeez", "UUID": "296ab89e-7208-4f6f-bed1-d623f30e32c9", "question": "Coin Change II: You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.\n\nReturn the number of combinations that make up that amount. If that amount of money cannot be made up by any combination of the coins, return 0.\n\nYou may assume that you have an infinite number of each kind of coin.\n\nThe answer is guaranteed to fit into a signed 32-bit integer.", "examples": "Input: amount = 5, coins = [1,2,5]\nOutput: 4\nExplanation: there are four ways to make up the amount:\n5=5\n5=2+2+1\n5=2+1+1+1\n5=1+1+1+1+1\nInput: amount = 3, coins = [2]\nOutput: 0\nExplanation: the amount of 3 cannot be made up just with coins of 2.", "link": "https://leetcode.com/problems/coin-change-ii/description/", "difficulty": "Medium", "categories": ["Dynamic_programming"], "code": "from typing import List\ndef change(amount: int, coins: List[int]) -> int:\n    def numberOfWays(i: int, amount: int) -> int:\n        if amount == 0:\n            return 1\n        if i == len(coins):\n            return 0\n        if memo[i][amount] != -1:\n            return memo[i][amount]\n\n        if coins[i] > amount:\n            memo[i][amount] = numberOfWays(i + 1, amount)\n        else:\n            memo[i][amount] = numberOfWays(i, amount - coins[i]) + numberOfWays(i + 1, amount)\n        \n        return memo[i][amount]\n\n    memo = [[-1] * (amount + 1) for _ in range(len(coins))]\n    return numberOfWays(0, amount)", "asserts": ["assert change(10,[10])==1", "assert change(0, [1, 2, 5]) == 1  # Edge case: trying to make 0 with any coins should always return 1", "assert change(11, [5]) == 0  # Amount cannot be made up with given coins", "assert change(0, []) == 1  # Edge case: trying to make 0 without any coins, should return 1 as there's one way of making 0 with no coins", "assert change(5, [5, 1]) == 2  # Amount can be made with given coins: [5], [1, 1, 1, 1, 1]"]}, {"author": "Calvin", "UUID": "5e7011e5-fee4-4c1a-a98f-3b81e50508cc", "question": "Return nth number in the fibonacci sequence", "examples": "Input: 9\nOutput: 34\n\nInput: 7\nOutput: 13", "link": NaN, "difficulty": null, "categories": ["Dynamic_programming"], "code": "def fibonacci(n: int) -> int:\n    a = 0\n    b = 1\n    if n < 0:\n        print(\"Incorrect input\")\n    elif n == 0:\n        return a\n    elif n == 1:\n        return b\n    else:\n        for i in range(2, n+1):\n            c = a + b\n            a = b\n            b = c\n        return b\n    b = c\n    return fib(n-1, a, b)\n", "asserts": ["assert fibonacci(9) == 34", "assert fibonacci(10) == 55", "assert fibonacci(5) == 5", "assert fibonacci(2) == 1", "assert fibonacci(0) == 0", "assert fibonacci(11) == 89", "assert fibonacci(15) == 610", "assert fibonacci(20) == 6765", "assert fibonacci(25) == 75025", "assert fibonacci(3) == 2", "assert fibonacci(1) == 1", "assert fibonacci(6) == 8", "assert fibonacci(30) == 832040", "assert fibonacci(35) == 9227465", "assert fibonacci(40) == 102334155"]}], "category": "Dynamic_programming", "prompt_tokens": 890, "total_tokens": 1237, "completion_tokens": 347, "completion": "Find the maximum sum of a subarray within an array.\n\n###Code:\n\nfrom typing import List\n\ndef maxSubArray(nums: List[int]) -> int:\n    max_sum = nums[0]\n    current_sum = nums[0]\n    \n    for num in nums[1:]:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    \n    return max_sum\n\n###Testcases:\n\nassert maxSubArray([-2,1,-3,4,-1,2,1,-5,4]) == 6\nassert maxSubArray([1]) == 1\nassert maxSubArray([5,4,-1,7,8]) == 23\nassert maxSubArray([-2,-1,-3,-4,-1,-2,-1,-5,-4]) == -1\nassert maxSubArray([-1,-2,-3,-4,-5,-6,-7,-8,-9]) == -1\nassert maxSubArray([1,2,3,4,5,6,7,8,9]) == 45\nassert maxSubArray([-1,0,-2,0,-3,0,-4,0,-5,0]) == 0\nassert maxSubArray([-1,0,-2,0,-3,0,-4,0,-5,1]) == 1\nassert maxSubArray([10,-1,-2,-3,-4,-5,-6,7,8,-9]) == 17\nassert maxSubArray([1,2,-5,4,3,-6,7,8,-9]) == 15\n\n[/Example 3]", "temperature": 0.824, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Calvin", "UUID": "e35d1110-85e8-4f50-80aa-91eb976b310b", "question": "Return the factorial of a given number n", "examples": "Input: 5\nOutput: 120\n\nInput: 6\nOutput: 720", "link": NaN, "difficulty": null, "categories": ["Dynamic_programming"], "code": "\ndef fact(n: int) -> int:\n  if n <= 1:\n    return 1\n  return n*fact(n-1)\n", "asserts": ["assert fact(5) == 120", "assert fact(0) == 1", "assert fact(1) == 1", "assert fact(3) == 6", "assert fact(7) == 5040", "assert fact(10) == 3628800", "assert fact(4) == 24", "assert fact(8) == 40320", "assert fact(2) == 2", "assert fact(11) == 39916800"]}, {"author": "Calvin", "UUID": "51a5caf9-241f-4de3-9ee2-9420490b73d7", "question": "Given a set[] of non-negative integers and a value sum, return the subset of the given set whose sum is equal to the given sum or None if one doesn't exist\n", "examples": "Input: set = [1, 2, 3, 4, 5], sum = 10\nOutput: [1, 2, 3, 4]", "link": "https://www.geeksforgeeks.org/subset-sum-problem-dp-25/", "difficulty": null, "categories": ["Dynamic_programming"], "code": "def subsetsum(fullset: list, target_sum: int) -> set:\n    def subsetSum_helper(cur_idx: int, fullset: list, target_sum: int, subset: list):\n        if target_sum == 0:\n            return subset\n        if (cur_idx == len(fullset)):\n            return None\n        excluding = subsetSum_helper(cur_idx + 1, fullset, target_sum, subset)\n          \n        if excluding is not None:\n            return excluding\n        elif fullset[cur_idx] <= target_sum:\n            subset.append(fullset[cur_idx])\n            including = subsetSum_helper(cur_idx + 1, fullset, target_sum - fullset[cur_idx], subset)\n            if including!=None:\n                return including\n            else:\n                subset.pop()\n            return None\n    return subsetSum_helper(0, fullset, target_sum, [])\n", "asserts": ["assert set(subsetsum([3, 34, 4, 12, 5, 2], 9)) == {4,5}", "assert subsetsum([1, 8, 2, 7, 4], 14) == [8, 2, 4]", "assert subsetsum([10, 12, 15, 6, 19], 21) == [15, 6]", "assert subsetsum([5, 10, 12, 13, 15, 18], 30) == [12, 18]", "assert subsetsum([5, 3, 9, 12, 6, 15], 27) == [12, 15]", "assert subsetsum([2, 3, 7, 8, 10], 11) == [3, 8]", "assert subsetsum([6, 2, 7, 11, 8], 16) == [6, 2, 8]", "assert subsetsum([5, 7, 1, 14, 6], 13) == [7, 6]", "assert subsetsum([1], 1) == [1]", "assert subsetsum([2, 5, 8, 4], 0) == []", "assert subsetsum([], 5) == None", "assert subsetsum([-1, -2, -3, -4, -5], -10) == None  # Negative numbers are not allowed according to the question", "assert subsetsum([4, 1, 2, 5, 12, 7], 9) == [2, 7]", "assert subsetsum([3, 5, 8, 4], 22) == None  # Sum exceeds the sum of all elements"]}], "category": "Dynamic_programming", "prompt_tokens": 950, "total_tokens": 1251, "completion_tokens": 301, "completion": "Find the length of the longest increasing subsequence in a given list of integers.\n\n###Code:\n\n```python\ndef longest_increasing_subsequence(nums: List[int]) -> int:\n    if not nums:\n        return 0\n    \n    dp = [1] * len(nums)\n    for i in range(len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    \n    return max(dp)\n```\n\n###Testcases:\n\n```python\nassert longest_increasing_subsequence([10, 9, 2, 5, 3, 7, 101, 18]) == 4\nassert longest_increasing_subsequence([0, 1, 0, 3, 2, 3]) == 4\nassert longest_increasing_subsequence([7, 7, 7, 7, 7, 7, 7]) == 1\nassert longest_increasing_subsequence([4, 10, 4, 3, 8, 9]) == 3\nassert longest_increasing_subsequence([1, 3, 6, 7, 9, 4, 10, 5, 6]) == 6\nassert longest_increasing_subsequence([1]) == 1\nassert longest_increasing_subsequence([]) == 0\n```\n\n[/Example 3]", "temperature": 0.654, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Calvin", "UUID": "51a5caf9-241f-4de3-9ee2-9420490b73d7", "question": "Given a set[] of non-negative integers and a value sum, return the subset of the given set whose sum is equal to the given sum or None if one doesn't exist\n", "examples": "Input: set = [1, 2, 3, 4, 5], sum = 10\nOutput: [1, 2, 3, 4]", "link": "https://www.geeksforgeeks.org/subset-sum-problem-dp-25/", "difficulty": null, "categories": ["Dynamic_programming"], "code": "def subsetsum(fullset: list, target_sum: int) -> set:\n    def subsetSum_helper(cur_idx: int, fullset: list, target_sum: int, subset: list):\n        if target_sum == 0:\n            return subset\n        if (cur_idx == len(fullset)):\n            return None\n        excluding = subsetSum_helper(cur_idx + 1, fullset, target_sum, subset)\n          \n        if excluding is not None:\n            return excluding\n        elif fullset[cur_idx] <= target_sum:\n            subset.append(fullset[cur_idx])\n            including = subsetSum_helper(cur_idx + 1, fullset, target_sum - fullset[cur_idx], subset)\n            if including!=None:\n                return including\n            else:\n                subset.pop()\n            return None\n    return subsetSum_helper(0, fullset, target_sum, [])\n", "asserts": ["assert set(subsetsum([3, 34, 4, 12, 5, 2], 9)) == {4,5}", "assert subsetsum([1, 8, 2, 7, 4], 14) == [8, 2, 4]", "assert subsetsum([10, 12, 15, 6, 19], 21) == [15, 6]", "assert subsetsum([5, 10, 12, 13, 15, 18], 30) == [12, 18]", "assert subsetsum([5, 3, 9, 12, 6, 15], 27) == [12, 15]", "assert subsetsum([2, 3, 7, 8, 10], 11) == [3, 8]", "assert subsetsum([6, 2, 7, 11, 8], 16) == [6, 2, 8]", "assert subsetsum([5, 7, 1, 14, 6], 13) == [7, 6]", "assert subsetsum([1], 1) == [1]", "assert subsetsum([2, 5, 8, 4], 0) == []", "assert subsetsum([], 5) == None", "assert subsetsum([-1, -2, -3, -4, -5], -10) == None  # Negative numbers are not allowed according to the question", "assert subsetsum([4, 1, 2, 5, 12, 7], 9) == [2, 7]", "assert subsetsum([3, 5, 8, 4], 22) == None  # Sum exceeds the sum of all elements"]}, {"author": "Hafeez", "UUID": "d695e67c-5b0e-4235-8406-30ee6be61173", "question": "N-th Tribonacci Number: The Tribonacci sequence Tn is defined as follows: \n\nT0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n >= 0.\n\nGiven n, return the value of Tn.", "examples": "Input: n = 4\nOutput: 4\nExplanation:\nT_3 = 0 + 1 + 1 = 2\nT_4 = 1 + 1 + 2 = 4", "link": "https://leetcode.com/problems/n-th-tribonacci-number/description/", "difficulty": "Easy", "categories": ["Dynamic_programming"], "code": "def tribonacci(n: int) -> int:\n    dp = {0: 0, 1: 1, 2: 1}\n    def dfs(i):\n        if i in dp:\n            return dp[i]\n        dp[i] = dfs(i - 1) + dfs(i - 2) + dfs(i - 3)\n        return dp[i]\n    \n    return dfs(n)", "asserts": ["assert tribonacci(25)==1389537", "assert tribonacci(0) == 0", "assert tribonacci(1) == 1", "assert tribonacci(2) == 1", "assert tribonacci(3) == 2", "assert tribonacci(5) == 7", "assert tribonacci(7) == 24", "assert tribonacci(10) == 149", "assert tribonacci(15) == 3136", "assert tribonacci(30) == 29249425"]}], "category": "Dynamic_programming", "prompt_tokens": 1071, "total_tokens": 1425, "completion_tokens": 354, "completion": "Given a non-empty array of integers, find the length of the longest increasing subsequence.\n\n###Code: \n\n```python\ndef length_of_LIS(nums: List[int]) -> int:\n    if not nums:\n        return 0\n    dp = [1] * len(nums)\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n```\n\n###Testcases: \n\n```python\nassert length_of_LIS([10, 9, 2, 5, 3, 7, 101, 18]) == 4\nassert length_of_LIS([0, 1, 0, 3, 2, 3]) == 4\nassert length_of_LIS([7, 7, 7, 7, 7, 7, 7]) == 1\nassert length_of_LIS([4, 10, 4, 3, 8, 9]) == 3\nassert length_of_LIS([1, 3, 6, 7, 9, 4, 10, 5, 6]) == 6\nassert length_of_LIS([5, 3, 4, 8, 6, 7]) == 4\nassert length_of_LIS([0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15]) == 6\n```", "temperature": 0.894, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Hafeez", "UUID": "6aaf1310-7585-4d90-91e7-1f405c9b25e7", "question": "Get Maximum in Generated Array: You are given an integer n. A 0-indexed integer array nums of length n + 1 is generated in the following way:\n\nnums[0] = 0\nnums[1] = 1\nnums[2 * i] = nums[i] when 2 <= 2 * i <= n\nnums[2 * i + 1] = nums[i] + nums[i + 1] when 2 <= 2 * i + 1 <= n\nReturn the maximum integer in the array nums\u200b\u200b\u200b.", "examples": "Input: n = 7\nOutput: 3\nExplanation: According to the given rules:\n  nums[0] = 0\n  nums[1] = 1\n  nums[(1 * 2) = 2] = nums[1] = 1\n  nums[(1 * 2) + 1 = 3] = nums[1] + nums[2] = 1 + 1 = 2\n  nums[(2 * 2) = 4] = nums[2] = 1\n  nums[(2 * 2) + 1 = 5] = nums[2] + nums[3] = 1 + 2 = 3\n  nums[(3 * 2) = 6] = nums[3] = 2\n  nums[(3 * 2) + 1 = 7] = nums[3] + nums[4] = 2 + 1 = 3\nHence, nums = [0,1,1,2,1,3,2,3], and the maximum is max(0,1,1,2,1,3,2,3) = 3.\nInput: n = 2\nOutput: 1\nExplanation: According to the given rules, nums = [0,1,1]. The maximum is max(0,1,1) = 1.\nInput: n = 3\nOutput: 2\nExplanation: According to the given rules, nums = [0,1,1,2]. The maximum is max(0,1,1,2) = 2.", "link": "https://leetcode.com/problems/get-maximum-in-generated-array/", "difficulty": "Easy", "categories": ["Dynamic_programming"], "code": "def getMaximumGenerated(n: int) -> int:\n    if n<2:\n        return n\n    nums=[0]*(n+1)\n    nums[0]=0\n    nums[1]=1\n    for i in range(2,n+1):\n        if i%2==0:\n            nums[i]=nums[i//2]\n        else:\n            nums[i]=nums[i//2]+nums[i//2+1]\n    return max(nums)", "asserts": ["assert getMaximumGenerated(2)==1", "assert getMaximumGenerated(4) == 2", "assert getMaximumGenerated(5) == 3", "assert getMaximumGenerated(8) == 3", "assert getMaximumGenerated(15) == 5", "assert getMaximumGenerated(0) == 0", "assert getMaximumGenerated(1) == 1"]}, {"author": "Hafeez", "UUID": "d695e67c-5b0e-4235-8406-30ee6be61173", "question": "N-th Tribonacci Number: The Tribonacci sequence Tn is defined as follows: \n\nT0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n >= 0.\n\nGiven n, return the value of Tn.", "examples": "Input: n = 4\nOutput: 4\nExplanation:\nT_3 = 0 + 1 + 1 = 2\nT_4 = 1 + 1 + 2 = 4", "link": "https://leetcode.com/problems/n-th-tribonacci-number/description/", "difficulty": "Easy", "categories": ["Dynamic_programming"], "code": "def tribonacci(n: int) -> int:\n    dp = {0: 0, 1: 1, 2: 1}\n    def dfs(i):\n        if i in dp:\n            return dp[i]\n        dp[i] = dfs(i - 1) + dfs(i - 2) + dfs(i - 3)\n        return dp[i]\n    \n    return dfs(n)", "asserts": ["assert tribonacci(25)==1389537", "assert tribonacci(0) == 0", "assert tribonacci(1) == 1", "assert tribonacci(2) == 1", "assert tribonacci(3) == 2", "assert tribonacci(5) == 7", "assert tribonacci(7) == 24", "assert tribonacci(10) == 149", "assert tribonacci(15) == 3136", "assert tribonacci(30) == 29249425"]}], "category": "Dynamic_programming", "prompt_tokens": 764, "total_tokens": 1021, "completion_tokens": 257, "completion": "Maximum Product Subarray: Given an integer array nums, find a contiguous non-empty subarray within the array that has the largest product, and return the product.\n\n###Code: \n\n```python\ndef maxProduct(nums) -> int:\n    if not nums:\n        return 0\n    max_prod = nums[0]\n    min_prod = nums[0]\n    result = max_prod\n    for num in nums[1:]:\n        if num < 0:\n            max_prod, min_prod = min_prod, max_prod\n        max_prod = max(num, max_prod * num)\n        min_prod = min(num, min_prod * num)\n        result = max(result, max_prod)\n    return result\n```\n\n###Testcases: \n\n```python\nassert maxProduct([2,3,-2,4]) == 6\nassert maxProduct([-2,0,-1]) == 0\nassert maxProduct([0,2]) == 2\nassert maxProduct([2,-5,-2,-4,3]) == 24\nassert maxProduct([2,-5,0,-2,4,-3]) == 8\nassert maxProduct([0,0,0,0]) == 0\n```\n\n[/Example 3]", "temperature": 0.932, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Calvin", "UUID": "e35d1110-85e8-4f50-80aa-91eb976b310b", "question": "Return the factorial of a given number n", "examples": "Input: 5\nOutput: 120\n\nInput: 6\nOutput: 720", "link": NaN, "difficulty": null, "categories": ["Dynamic_programming"], "code": "\ndef fact(n: int) -> int:\n  if n <= 1:\n    return 1\n  return n*fact(n-1)\n", "asserts": ["assert fact(5) == 120", "assert fact(0) == 1", "assert fact(1) == 1", "assert fact(3) == 6", "assert fact(7) == 5040", "assert fact(10) == 3628800", "assert fact(4) == 24", "assert fact(8) == 40320", "assert fact(2) == 2", "assert fact(11) == 39916800"]}, {"author": "Hafeez", "UUID": "296ab89e-7208-4f6f-bed1-d623f30e32c9", "question": "Coin Change II: You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.\n\nReturn the number of combinations that make up that amount. If that amount of money cannot be made up by any combination of the coins, return 0.\n\nYou may assume that you have an infinite number of each kind of coin.\n\nThe answer is guaranteed to fit into a signed 32-bit integer.", "examples": "Input: amount = 5, coins = [1,2,5]\nOutput: 4\nExplanation: there are four ways to make up the amount:\n5=5\n5=2+2+1\n5=2+1+1+1\n5=1+1+1+1+1\nInput: amount = 3, coins = [2]\nOutput: 0\nExplanation: the amount of 3 cannot be made up just with coins of 2.", "link": "https://leetcode.com/problems/coin-change-ii/description/", "difficulty": "Medium", "categories": ["Dynamic_programming"], "code": "from typing import List\ndef change(amount: int, coins: List[int]) -> int:\n    def numberOfWays(i: int, amount: int) -> int:\n        if amount == 0:\n            return 1\n        if i == len(coins):\n            return 0\n        if memo[i][amount] != -1:\n            return memo[i][amount]\n\n        if coins[i] > amount:\n            memo[i][amount] = numberOfWays(i + 1, amount)\n        else:\n            memo[i][amount] = numberOfWays(i, amount - coins[i]) + numberOfWays(i + 1, amount)\n        \n        return memo[i][amount]\n\n    memo = [[-1] * (amount + 1) for _ in range(len(coins))]\n    return numberOfWays(0, amount)", "asserts": ["assert change(10,[10])==1", "assert change(0, [1, 2, 5]) == 1  # Edge case: trying to make 0 with any coins should always return 1", "assert change(11, [5]) == 0  # Amount cannot be made up with given coins", "assert change(0, []) == 1  # Edge case: trying to make 0 without any coins, should return 1 as there's one way of making 0 with no coins", "assert change(5, [5, 1]) == 2  # Amount can be made with given coins: [5], [1, 1, 1, 1, 1]"]}], "category": "Dynamic_programming", "prompt_tokens": 767, "total_tokens": 1120, "completion_tokens": 353, "completion": "Find the length of the longest increasing subsequence in an integer array.\n\n###Code: \n\nfrom typing import List\n\ndef lengthOfLIS(nums: List[int]) -> int:\n    if not nums:\n        return 0\n\n    dp = [1] * len(nums)\n\n    for i in range(len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)\n\n###Testcases: \n\nassert lengthOfLIS([10, 9, 2, 5, 3, 7, 101, 18]) == 4  # The longest increasing subsequence is [2, 3, 7, 101]\nassert lengthOfLIS([0, 1, 0, 3, 2, 3]) == 4  # The longest increasing subsequence is [0, 1, 2, 3]\nassert lengthOfLIS([7, 7, 7, 7, 7, 7, 7]) == 1  # The longest increasing subsequence is [7]\nassert lengthOfLIS([4, 10, 4, 3, 8, 9]) == 3  # The longest increasing subsequence is [4, 8, 9]\nassert lengthOfLIS([1, 3, 6, 7, 9, 4, 10, 5, 6]) == 6  # The longest increasing subsequence is [1, 3, 6, 7, 9, 10]\n\n[/Example 3]", "temperature": 0.894, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Hafeez", "UUID": "d695e67c-5b0e-4235-8406-30ee6be61173", "question": "N-th Tribonacci Number: The Tribonacci sequence Tn is defined as follows: \n\nT0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n >= 0.\n\nGiven n, return the value of Tn.", "examples": "Input: n = 4\nOutput: 4\nExplanation:\nT_3 = 0 + 1 + 1 = 2\nT_4 = 1 + 1 + 2 = 4", "link": "https://leetcode.com/problems/n-th-tribonacci-number/description/", "difficulty": "Easy", "categories": ["Dynamic_programming"], "code": "def tribonacci(n: int) -> int:\n    dp = {0: 0, 1: 1, 2: 1}\n    def dfs(i):\n        if i in dp:\n            return dp[i]\n        dp[i] = dfs(i - 1) + dfs(i - 2) + dfs(i - 3)\n        return dp[i]\n    \n    return dfs(n)", "asserts": ["assert tribonacci(25)==1389537", "assert tribonacci(0) == 0", "assert tribonacci(1) == 1", "assert tribonacci(2) == 1", "assert tribonacci(3) == 2", "assert tribonacci(5) == 7", "assert tribonacci(7) == 24", "assert tribonacci(10) == 149", "assert tribonacci(15) == 3136", "assert tribonacci(30) == 29249425"]}, {"author": "Calvin", "UUID": "5e7011e5-fee4-4c1a-a98f-3b81e50508cc", "question": "Return nth number in the fibonacci sequence", "examples": "Input: 9\nOutput: 34\n\nInput: 7\nOutput: 13", "link": NaN, "difficulty": null, "categories": ["Dynamic_programming"], "code": "def fibonacci(n: int) -> int:\n    a = 0\n    b = 1\n    if n < 0:\n        print(\"Incorrect input\")\n    elif n == 0:\n        return a\n    elif n == 1:\n        return b\n    else:\n        for i in range(2, n+1):\n            c = a + b\n            a = b\n            b = c\n        return b\n    b = c\n    return fib(n-1, a, b)\n", "asserts": ["assert fibonacci(9) == 34", "assert fibonacci(10) == 55", "assert fibonacci(5) == 5", "assert fibonacci(2) == 1", "assert fibonacci(0) == 0", "assert fibonacci(11) == 89", "assert fibonacci(15) == 610", "assert fibonacci(20) == 6765", "assert fibonacci(25) == 75025", "assert fibonacci(3) == 2", "assert fibonacci(1) == 1", "assert fibonacci(6) == 8", "assert fibonacci(30) == 832040", "assert fibonacci(35) == 9227465", "assert fibonacci(40) == 102334155"]}], "category": "Dynamic_programming", "prompt_tokens": 735, "total_tokens": 1084, "completion_tokens": 349, "completion": "Find the minimum number of jumps required to reach the end of an array.\n\n###Code: \n\ndef min_jumps(nums):\n    n = len(nums)\n    dp = [float('inf')] * n\n    dp[0] = 0\n    for i in range(1, n):\n        for j in range(i):\n            if j + nums[j] >= i:\n                dp[i] = min(dp[i], dp[j] + 1)\n    return dp[n-1]\n\n###Testcases: \n\nassert min_jumps([2,3,1,1,4]) == 2\nassert min_jumps([2,3,0,1,4]) == 2\nassert min_jumps([2,1,3,1,1,4]) == 3\nassert min_jumps([1,1,1,1,1]) == 4\nassert min_jumps([5,4,3,2,1,1,0,0]) == 2\nassert min_jumps([1,2,3]) == 2\nassert min_jumps([3,2,1]) == 1\nassert min_jumps([1,1,1,1,1]) == 4\nassert min_jumps([3,4,3,2,5,4,3]) == 2\nassert min_jumps([1,1,1,1,1,1]) == 5\nassert min_jumps([2,2,2,2,2,2,2]) == 3\nassert min_jumps([1,2,1,1,1]) == 3\n\n[/Example 3]", "temperature": 0.911, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Calvin", "UUID": "5e7011e5-fee4-4c1a-a98f-3b81e50508cc", "question": "Return nth number in the fibonacci sequence", "examples": "Input: 9\nOutput: 34\n\nInput: 7\nOutput: 13", "link": NaN, "difficulty": null, "categories": ["Dynamic_programming"], "code": "def fibonacci(n: int) -> int:\n    a = 0\n    b = 1\n    if n < 0:\n        print(\"Incorrect input\")\n    elif n == 0:\n        return a\n    elif n == 1:\n        return b\n    else:\n        for i in range(2, n+1):\n            c = a + b\n            a = b\n            b = c\n        return b\n    b = c\n    return fib(n-1, a, b)\n", "asserts": ["assert fibonacci(9) == 34", "assert fibonacci(10) == 55", "assert fibonacci(5) == 5", "assert fibonacci(2) == 1", "assert fibonacci(0) == 0", "assert fibonacci(11) == 89", "assert fibonacci(15) == 610", "assert fibonacci(20) == 6765", "assert fibonacci(25) == 75025", "assert fibonacci(3) == 2", "assert fibonacci(1) == 1", "assert fibonacci(6) == 8", "assert fibonacci(30) == 832040", "assert fibonacci(35) == 9227465", "assert fibonacci(40) == 102334155"]}, {"author": "Hafeez", "UUID": "38dca76c-ee6c-4c71-83a9-89240828a3b7", "question": "Best Time to Buy and Sell Stock II: You are given an integer array prices where prices[i] is the price of a given stock on the ith day.\n\nOn each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day.\n\nFind and return the maximum profit you can achieve.", "examples": "Input: prices = [7,1,5,3,6,4]\nOutput: 7\nExplanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\nThen buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.\nTotal profit is 4 + 3 = 7.\nInput: prices = [7,6,4,3,1]\nOutput: 0\nExplanation: There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0.", "link": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/", "difficulty": "Medium", "categories": ["Dynamic_programming"], "code": "from typing import List\ndef maxProfit(prices: List[int]) -> int:\n    cur_hold, cur_not_hold = -float('inf'), 0\n    \n    for stock_price in prices:\n        \n        prev_hold, prev_not_hold = cur_hold, cur_not_hold\n        cur_hold = max( prev_hold, prev_not_hold - stock_price )\n        cur_not_hold = max( prev_not_hold, prev_hold + stock_price )\n    return cur_not_hold", "asserts": ["assert maxProfit([1,2,3,4,5])==4", "assert maxProfit([1,2,100,2,1]) == 99"]}], "category": "Dynamic_programming", "prompt_tokens": 695, "total_tokens": 923, "completion_tokens": 228, "completion": "Find the length of the longest increasing subsequence in the given array.\n\n###Code: \n\nfrom typing import List\n\ndef lengthOfLIS(nums: List[int]) -> int:\n    if not nums:\n        return 0\n    dp = [1] * len(nums)\n    for i in range(len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n\n###Testcases: \n\nassert lengthOfLIS([10, 9, 2, 5, 3, 7, 101, 18]) == 4\nassert lengthOfLIS([0, 1, 0, 3, 2, 3]) == 4\nassert lengthOfLIS([7, 7, 7, 7, 7, 7, 7]) == 1\nassert lengthOfLIS([4, 10, 4, 3, 8, 9]) == 3\n\n[/Example 3]", "temperature": 0.736, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Calvin", "UUID": "e35d1110-85e8-4f50-80aa-91eb976b310b", "question": "Return the factorial of a given number n", "examples": "Input: 5\nOutput: 120\n\nInput: 6\nOutput: 720", "link": NaN, "difficulty": null, "categories": ["Dynamic_programming"], "code": "\ndef fact(n: int) -> int:\n  if n <= 1:\n    return 1\n  return n*fact(n-1)\n", "asserts": ["assert fact(5) == 120", "assert fact(0) == 1", "assert fact(1) == 1", "assert fact(3) == 6", "assert fact(7) == 5040", "assert fact(10) == 3628800", "assert fact(4) == 24", "assert fact(8) == 40320", "assert fact(2) == 2", "assert fact(11) == 39916800"]}, {"author": "Hafeez", "UUID": "d695e67c-5b0e-4235-8406-30ee6be61173", "question": "N-th Tribonacci Number: The Tribonacci sequence Tn is defined as follows: \n\nT0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n >= 0.\n\nGiven n, return the value of Tn.", "examples": "Input: n = 4\nOutput: 4\nExplanation:\nT_3 = 0 + 1 + 1 = 2\nT_4 = 1 + 1 + 2 = 4", "link": "https://leetcode.com/problems/n-th-tribonacci-number/description/", "difficulty": "Easy", "categories": ["Dynamic_programming"], "code": "def tribonacci(n: int) -> int:\n    dp = {0: 0, 1: 1, 2: 1}\n    def dfs(i):\n        if i in dp:\n            return dp[i]\n        dp[i] = dfs(i - 1) + dfs(i - 2) + dfs(i - 3)\n        return dp[i]\n    \n    return dfs(n)", "asserts": ["assert tribonacci(25)==1389537", "assert tribonacci(0) == 0", "assert tribonacci(1) == 1", "assert tribonacci(2) == 1", "assert tribonacci(3) == 2", "assert tribonacci(5) == 7", "assert tribonacci(7) == 24", "assert tribonacci(10) == 149", "assert tribonacci(15) == 3136", "assert tribonacci(30) == 29249425"]}], "category": "Dynamic_programming", "prompt_tokens": 612, "total_tokens": 892, "completion_tokens": 280, "completion": "Return the minimum number of operations needed to go from 0 to n. \n\nYou can perform the following operations:\n1. Increment x by 1\n2. Decrement x by 1\n3. Double the value of x\n\n###Code: \n\n```python\ndef min_operations_to_n(n: int) -> int:\n    dp = [0] * (n+1)\n    for i in range(1, n+1):\n        if i % 2 == 0:\n            dp[i] = min(dp[i-1]+1, dp[i//2]+1)\n        else:\n            dp[i] = dp[i-1]+1\n    return dp[n]\n```\n\n###Testcases: \n\n```python\nassert min_operations_to_n(5) == 4\nassert min_operations_to_n(10) == 5\nassert min_operations_to_n(15) == 5\nassert min_operations_to_n(20) == 6\nassert min_operations_to_n(25) == 6\nassert min_operations_to_n(30) == 7\nassert min_operations_to_n(100) == 9\nassert min_operations_to_n(500) == 14\nassert min_operations_to_n(1000) == 15\nassert min_operations_to_n(10000) == 17\n```\n\n[/Example 3]", "temperature": 0.869, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Hafeez", "UUID": "6aaf1310-7585-4d90-91e7-1f405c9b25e7", "question": "Get Maximum in Generated Array: You are given an integer n. A 0-indexed integer array nums of length n + 1 is generated in the following way:\n\nnums[0] = 0\nnums[1] = 1\nnums[2 * i] = nums[i] when 2 <= 2 * i <= n\nnums[2 * i + 1] = nums[i] + nums[i + 1] when 2 <= 2 * i + 1 <= n\nReturn the maximum integer in the array nums\u200b\u200b\u200b.", "examples": "Input: n = 7\nOutput: 3\nExplanation: According to the given rules:\n  nums[0] = 0\n  nums[1] = 1\n  nums[(1 * 2) = 2] = nums[1] = 1\n  nums[(1 * 2) + 1 = 3] = nums[1] + nums[2] = 1 + 1 = 2\n  nums[(2 * 2) = 4] = nums[2] = 1\n  nums[(2 * 2) + 1 = 5] = nums[2] + nums[3] = 1 + 2 = 3\n  nums[(3 * 2) = 6] = nums[3] = 2\n  nums[(3 * 2) + 1 = 7] = nums[3] + nums[4] = 2 + 1 = 3\nHence, nums = [0,1,1,2,1,3,2,3], and the maximum is max(0,1,1,2,1,3,2,3) = 3.\nInput: n = 2\nOutput: 1\nExplanation: According to the given rules, nums = [0,1,1]. The maximum is max(0,1,1) = 1.\nInput: n = 3\nOutput: 2\nExplanation: According to the given rules, nums = [0,1,1,2]. The maximum is max(0,1,1,2) = 2.", "link": "https://leetcode.com/problems/get-maximum-in-generated-array/", "difficulty": "Easy", "categories": ["Dynamic_programming"], "code": "def getMaximumGenerated(n: int) -> int:\n    if n<2:\n        return n\n    nums=[0]*(n+1)\n    nums[0]=0\n    nums[1]=1\n    for i in range(2,n+1):\n        if i%2==0:\n            nums[i]=nums[i//2]\n        else:\n            nums[i]=nums[i//2]+nums[i//2+1]\n    return max(nums)", "asserts": ["assert getMaximumGenerated(2)==1", "assert getMaximumGenerated(4) == 2", "assert getMaximumGenerated(5) == 3", "assert getMaximumGenerated(8) == 3", "assert getMaximumGenerated(15) == 5", "assert getMaximumGenerated(0) == 0", "assert getMaximumGenerated(1) == 1"]}, {"author": "Hafeez", "UUID": "38dca76c-ee6c-4c71-83a9-89240828a3b7", "question": "Best Time to Buy and Sell Stock II: You are given an integer array prices where prices[i] is the price of a given stock on the ith day.\n\nOn each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day.\n\nFind and return the maximum profit you can achieve.", "examples": "Input: prices = [7,1,5,3,6,4]\nOutput: 7\nExplanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\nThen buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.\nTotal profit is 4 + 3 = 7.\nInput: prices = [7,6,4,3,1]\nOutput: 0\nExplanation: There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0.", "link": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/", "difficulty": "Medium", "categories": ["Dynamic_programming"], "code": "from typing import List\ndef maxProfit(prices: List[int]) -> int:\n    cur_hold, cur_not_hold = -float('inf'), 0\n    \n    for stock_price in prices:\n        \n        prev_hold, prev_not_hold = cur_hold, cur_not_hold\n        cur_hold = max( prev_hold, prev_not_hold - stock_price )\n        cur_not_hold = max( prev_not_hold, prev_hold + stock_price )\n    return cur_not_hold", "asserts": ["assert maxProfit([1,2,3,4,5])==4", "assert maxProfit([1,2,100,2,1]) == 99"]}], "category": "Dynamic_programming", "prompt_tokens": 724, "total_tokens": 920, "completion_tokens": 196, "completion": "Maximum Subarray: Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.\n\n###Code: \n\nfrom typing import List\ndef maxSubArray(nums: List[int]) -> int:\n    max_sum = nums[0]\n    curr_sum = nums[0]\n    \n    for num in nums[1:]:\n        curr_sum = max(num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n        \n    return max_sum\n\n###Testcases: \n\nassert maxSubArray([-2,1,-3,4,-1,2,1,-5,4])==6\nassert maxSubArray([1])==1\nassert maxSubArray([5,4,-1,7,8])==23\nassert maxSubArray([-2,1,-3,4,-1,2,1,-5,4,7])==11\n\n[/Example 3]", "temperature": 0.608, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Hafeez", "UUID": "296ab89e-7208-4f6f-bed1-d623f30e32c9", "question": "Coin Change II: You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.\n\nReturn the number of combinations that make up that amount. If that amount of money cannot be made up by any combination of the coins, return 0.\n\nYou may assume that you have an infinite number of each kind of coin.\n\nThe answer is guaranteed to fit into a signed 32-bit integer.", "examples": "Input: amount = 5, coins = [1,2,5]\nOutput: 4\nExplanation: there are four ways to make up the amount:\n5=5\n5=2+2+1\n5=2+1+1+1\n5=1+1+1+1+1\nInput: amount = 3, coins = [2]\nOutput: 0\nExplanation: the amount of 3 cannot be made up just with coins of 2.", "link": "https://leetcode.com/problems/coin-change-ii/description/", "difficulty": "Medium", "categories": ["Dynamic_programming"], "code": "from typing import List\ndef change(amount: int, coins: List[int]) -> int:\n    def numberOfWays(i: int, amount: int) -> int:\n        if amount == 0:\n            return 1\n        if i == len(coins):\n            return 0\n        if memo[i][amount] != -1:\n            return memo[i][amount]\n\n        if coins[i] > amount:\n            memo[i][amount] = numberOfWays(i + 1, amount)\n        else:\n            memo[i][amount] = numberOfWays(i, amount - coins[i]) + numberOfWays(i + 1, amount)\n        \n        return memo[i][amount]\n\n    memo = [[-1] * (amount + 1) for _ in range(len(coins))]\n    return numberOfWays(0, amount)", "asserts": ["assert change(10,[10])==1", "assert change(0, [1, 2, 5]) == 1  # Edge case: trying to make 0 with any coins should always return 1", "assert change(11, [5]) == 0  # Amount cannot be made up with given coins", "assert change(0, []) == 1  # Edge case: trying to make 0 without any coins, should return 1 as there's one way of making 0 with no coins", "assert change(5, [5, 1]) == 2  # Amount can be made with given coins: [5], [1, 1, 1, 1, 1]"]}, {"author": "Hafeez", "UUID": "d695e67c-5b0e-4235-8406-30ee6be61173", "question": "N-th Tribonacci Number: The Tribonacci sequence Tn is defined as follows: \n\nT0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n >= 0.\n\nGiven n, return the value of Tn.", "examples": "Input: n = 4\nOutput: 4\nExplanation:\nT_3 = 0 + 1 + 1 = 2\nT_4 = 1 + 1 + 2 = 4", "link": "https://leetcode.com/problems/n-th-tribonacci-number/description/", "difficulty": "Easy", "categories": ["Dynamic_programming"], "code": "def tribonacci(n: int) -> int:\n    dp = {0: 0, 1: 1, 2: 1}\n    def dfs(i):\n        if i in dp:\n            return dp[i]\n        dp[i] = dfs(i - 1) + dfs(i - 2) + dfs(i - 3)\n        return dp[i]\n    \n    return dfs(n)", "asserts": ["assert tribonacci(25)==1389537", "assert tribonacci(0) == 0", "assert tribonacci(1) == 1", "assert tribonacci(2) == 1", "assert tribonacci(3) == 2", "assert tribonacci(5) == 7", "assert tribonacci(7) == 24", "assert tribonacci(10) == 149", "assert tribonacci(15) == 3136", "assert tribonacci(30) == 29249425"]}], "category": "Dynamic_programming", "prompt_tokens": 888, "total_tokens": 1118, "completion_tokens": 230, "completion": "Longest Increasing Subsequence: Given an unsorted array of integers, find the length of longest increasing subsequence.\n\n###Code: \n\nfrom typing import List\n\ndef lengthOfLIS(nums: List[int]) -> int:\n    if not nums:\n        return 0\n        \n    dp = [1] * len(nums)\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n                    \n    return max(dp)\n\n###Testcases: \n\nassert lengthOfLIS([10,9,2,5,3,4])==3\nassert lengthOfLIS([10,9,2,5,3,7,101,18])==4\nassert lengthOfLIS([0,1,0,3,2,3])==4\nassert lengthOfLIS([7,7,7,7,7,7,7])==1\nassert lengthOfLIS([4,10,4,3,8,9])==3\n\n[/Example 3]", "temperature": 0.951, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Calvin", "UUID": "e35d1110-85e8-4f50-80aa-91eb976b310b", "question": "Return the factorial of a given number n", "examples": "Input: 5\nOutput: 120\n\nInput: 6\nOutput: 720", "link": NaN, "difficulty": null, "categories": ["Dynamic_programming"], "code": "\ndef fact(n: int) -> int:\n  if n <= 1:\n    return 1\n  return n*fact(n-1)\n", "asserts": ["assert fact(5) == 120", "assert fact(0) == 1", "assert fact(1) == 1", "assert fact(3) == 6", "assert fact(7) == 5040", "assert fact(10) == 3628800", "assert fact(4) == 24", "assert fact(8) == 40320", "assert fact(2) == 2", "assert fact(11) == 39916800"]}, {"author": "Hafeez", "UUID": "d695e67c-5b0e-4235-8406-30ee6be61173", "question": "N-th Tribonacci Number: The Tribonacci sequence Tn is defined as follows: \n\nT0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n >= 0.\n\nGiven n, return the value of Tn.", "examples": "Input: n = 4\nOutput: 4\nExplanation:\nT_3 = 0 + 1 + 1 = 2\nT_4 = 1 + 1 + 2 = 4", "link": "https://leetcode.com/problems/n-th-tribonacci-number/description/", "difficulty": "Easy", "categories": ["Dynamic_programming"], "code": "def tribonacci(n: int) -> int:\n    dp = {0: 0, 1: 1, 2: 1}\n    def dfs(i):\n        if i in dp:\n            return dp[i]\n        dp[i] = dfs(i - 1) + dfs(i - 2) + dfs(i - 3)\n        return dp[i]\n    \n    return dfs(n)", "asserts": ["assert tribonacci(25)==1389537", "assert tribonacci(0) == 0", "assert tribonacci(1) == 1", "assert tribonacci(2) == 1", "assert tribonacci(3) == 2", "assert tribonacci(5) == 7", "assert tribonacci(7) == 24", "assert tribonacci(10) == 149", "assert tribonacci(15) == 3136", "assert tribonacci(30) == 29249425"]}], "category": "Dynamic_programming", "prompt_tokens": 612, "total_tokens": 800, "completion_tokens": 188, "completion": "Return the nth Fibonacci number.\n\n###Code: \n\n```python\ndef fibonacci(n: int) -> int:\n    if n <= 1:\n        return n\n    dp = [0] * (n+1)\n    dp[1] = 1\n    for i in range(2, n+1):\n        dp[i] = dp[i-1] + dp[i-2]\n    return dp[n]\n```\n\n###Testcases: \n\n```python\nassert fibonacci(0) == 0\nassert fibonacci(1) == 1\nassert fibonacci(2) == 1\nassert fibonacci(3) == 2\nassert fibonacci(4) == 3\nassert fibonacci(5) == 5\nassert fibonacci(6) == 8\nassert fibonacci(7) == 13\nassert fibonacci(8) == 21\nassert fibonacci(9) == 34\n```", "temperature": 0.796, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Calvin", "UUID": "51a5caf9-241f-4de3-9ee2-9420490b73d7", "question": "Given a set[] of non-negative integers and a value sum, return the subset of the given set whose sum is equal to the given sum or None if one doesn't exist\n", "examples": "Input: set = [1, 2, 3, 4, 5], sum = 10\nOutput: [1, 2, 3, 4]", "link": "https://www.geeksforgeeks.org/subset-sum-problem-dp-25/", "difficulty": null, "categories": ["Dynamic_programming"], "code": "def subsetsum(fullset: list, target_sum: int) -> set:\n    def subsetSum_helper(cur_idx: int, fullset: list, target_sum: int, subset: list):\n        if target_sum == 0:\n            return subset\n        if (cur_idx == len(fullset)):\n            return None\n        excluding = subsetSum_helper(cur_idx + 1, fullset, target_sum, subset)\n          \n        if excluding is not None:\n            return excluding\n        elif fullset[cur_idx] <= target_sum:\n            subset.append(fullset[cur_idx])\n            including = subsetSum_helper(cur_idx + 1, fullset, target_sum - fullset[cur_idx], subset)\n            if including!=None:\n                return including\n            else:\n                subset.pop()\n            return None\n    return subsetSum_helper(0, fullset, target_sum, [])\n", "asserts": ["assert set(subsetsum([3, 34, 4, 12, 5, 2], 9)) == {4,5}", "assert subsetsum([1, 8, 2, 7, 4], 14) == [8, 2, 4]", "assert subsetsum([10, 12, 15, 6, 19], 21) == [15, 6]", "assert subsetsum([5, 10, 12, 13, 15, 18], 30) == [12, 18]", "assert subsetsum([5, 3, 9, 12, 6, 15], 27) == [12, 15]", "assert subsetsum([2, 3, 7, 8, 10], 11) == [3, 8]", "assert subsetsum([6, 2, 7, 11, 8], 16) == [6, 2, 8]", "assert subsetsum([5, 7, 1, 14, 6], 13) == [7, 6]", "assert subsetsum([1], 1) == [1]", "assert subsetsum([2, 5, 8, 4], 0) == []", "assert subsetsum([], 5) == None", "assert subsetsum([-1, -2, -3, -4, -5], -10) == None  # Negative numbers are not allowed according to the question", "assert subsetsum([4, 1, 2, 5, 12, 7], 9) == [2, 7]", "assert subsetsum([3, 5, 8, 4], 22) == None  # Sum exceeds the sum of all elements"]}, {"author": "Hafeez", "UUID": "6aaf1310-7585-4d90-91e7-1f405c9b25e7", "question": "Get Maximum in Generated Array: You are given an integer n. A 0-indexed integer array nums of length n + 1 is generated in the following way:\n\nnums[0] = 0\nnums[1] = 1\nnums[2 * i] = nums[i] when 2 <= 2 * i <= n\nnums[2 * i + 1] = nums[i] + nums[i + 1] when 2 <= 2 * i + 1 <= n\nReturn the maximum integer in the array nums\u200b\u200b\u200b.", "examples": "Input: n = 7\nOutput: 3\nExplanation: According to the given rules:\n  nums[0] = 0\n  nums[1] = 1\n  nums[(1 * 2) = 2] = nums[1] = 1\n  nums[(1 * 2) + 1 = 3] = nums[1] + nums[2] = 1 + 1 = 2\n  nums[(2 * 2) = 4] = nums[2] = 1\n  nums[(2 * 2) + 1 = 5] = nums[2] + nums[3] = 1 + 2 = 3\n  nums[(3 * 2) = 6] = nums[3] = 2\n  nums[(3 * 2) + 1 = 7] = nums[3] + nums[4] = 2 + 1 = 3\nHence, nums = [0,1,1,2,1,3,2,3], and the maximum is max(0,1,1,2,1,3,2,3) = 3.\nInput: n = 2\nOutput: 1\nExplanation: According to the given rules, nums = [0,1,1]. The maximum is max(0,1,1) = 1.\nInput: n = 3\nOutput: 2\nExplanation: According to the given rules, nums = [0,1,1,2]. The maximum is max(0,1,1,2) = 2.", "link": "https://leetcode.com/problems/get-maximum-in-generated-array/", "difficulty": "Easy", "categories": ["Dynamic_programming"], "code": "def getMaximumGenerated(n: int) -> int:\n    if n<2:\n        return n\n    nums=[0]*(n+1)\n    nums[0]=0\n    nums[1]=1\n    for i in range(2,n+1):\n        if i%2==0:\n            nums[i]=nums[i//2]\n        else:\n            nums[i]=nums[i//2]+nums[i//2+1]\n    return max(nums)", "asserts": ["assert getMaximumGenerated(2)==1", "assert getMaximumGenerated(4) == 2", "assert getMaximumGenerated(5) == 3", "assert getMaximumGenerated(8) == 3", "assert getMaximumGenerated(15) == 5", "assert getMaximumGenerated(0) == 0", "assert getMaximumGenerated(1) == 1"]}], "category": "Dynamic_programming", "prompt_tokens": 1102, "total_tokens": 1554, "completion_tokens": 452, "completion": "Given a list of positive integers, find the length of the longest increasing subsequence (LIS).\n\nA subsequence is a sequence that can be derived from an array by deleting some or no elements without changing the order of the remaining elements. For example, [3,6,2,7] is a subsequence of the array [0,3,1,6,2,2,7].\n\n###Code: \n\n```python\ndef lengthOfLIS(nums: list) -> int:\n    n = len(nums)\n    if n <= 1:\n        return n\n    dp = [1] * n\n    for i in range(1, n):\n        for j in range(0, i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n```\n\n###Testcases: \n\n```python\nassert lengthOfLIS([10, 9, 2, 5, 3, 7, 101, 18]) == 4\nassert lengthOfLIS([0, 1, 0, 3, 2, 3]) == 4\nassert lengthOfLIS([7, 7, 7, 7, 7, 7, 7]) == 1\nassert lengthOfLIS([4, 10, 4, 3, 8, 9]) == 3\nassert lengthOfLIS([1, 3, 6, 7, 9, 4, 10, 5, 6]) == 6\nassert lengthOfLIS([10, 9, 2, 5, 3, 7, 101, 18, 20]) == 5\nassert lengthOfLIS([2, 5, 7, 3, 4, 8, 12, 1]) == 5\nassert lengthOfLIS([9, 8, 7, 6, 5, 4, 3, 2, 1]) == 1\n```\n\n[/Example 3]", "temperature": 0.977, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Hafeez", "UUID": "6aaf1310-7585-4d90-91e7-1f405c9b25e7", "question": "Get Maximum in Generated Array: You are given an integer n. A 0-indexed integer array nums of length n + 1 is generated in the following way:\n\nnums[0] = 0\nnums[1] = 1\nnums[2 * i] = nums[i] when 2 <= 2 * i <= n\nnums[2 * i + 1] = nums[i] + nums[i + 1] when 2 <= 2 * i + 1 <= n\nReturn the maximum integer in the array nums\u200b\u200b\u200b.", "examples": "Input: n = 7\nOutput: 3\nExplanation: According to the given rules:\n  nums[0] = 0\n  nums[1] = 1\n  nums[(1 * 2) = 2] = nums[1] = 1\n  nums[(1 * 2) + 1 = 3] = nums[1] + nums[2] = 1 + 1 = 2\n  nums[(2 * 2) = 4] = nums[2] = 1\n  nums[(2 * 2) + 1 = 5] = nums[2] + nums[3] = 1 + 2 = 3\n  nums[(3 * 2) = 6] = nums[3] = 2\n  nums[(3 * 2) + 1 = 7] = nums[3] + nums[4] = 2 + 1 = 3\nHence, nums = [0,1,1,2,1,3,2,3], and the maximum is max(0,1,1,2,1,3,2,3) = 3.\nInput: n = 2\nOutput: 1\nExplanation: According to the given rules, nums = [0,1,1]. The maximum is max(0,1,1) = 1.\nInput: n = 3\nOutput: 2\nExplanation: According to the given rules, nums = [0,1,1,2]. The maximum is max(0,1,1,2) = 2.", "link": "https://leetcode.com/problems/get-maximum-in-generated-array/", "difficulty": "Easy", "categories": ["Dynamic_programming"], "code": "def getMaximumGenerated(n: int) -> int:\n    if n<2:\n        return n\n    nums=[0]*(n+1)\n    nums[0]=0\n    nums[1]=1\n    for i in range(2,n+1):\n        if i%2==0:\n            nums[i]=nums[i//2]\n        else:\n            nums[i]=nums[i//2]+nums[i//2+1]\n    return max(nums)", "asserts": ["assert getMaximumGenerated(2)==1", "assert getMaximumGenerated(4) == 2", "assert getMaximumGenerated(5) == 3", "assert getMaximumGenerated(8) == 3", "assert getMaximumGenerated(15) == 5", "assert getMaximumGenerated(0) == 0", "assert getMaximumGenerated(1) == 1"]}, {"author": "Hafeez", "UUID": "296ab89e-7208-4f6f-bed1-d623f30e32c9", "question": "Coin Change II: You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.\n\nReturn the number of combinations that make up that amount. If that amount of money cannot be made up by any combination of the coins, return 0.\n\nYou may assume that you have an infinite number of each kind of coin.\n\nThe answer is guaranteed to fit into a signed 32-bit integer.", "examples": "Input: amount = 5, coins = [1,2,5]\nOutput: 4\nExplanation: there are four ways to make up the amount:\n5=5\n5=2+2+1\n5=2+1+1+1\n5=1+1+1+1+1\nInput: amount = 3, coins = [2]\nOutput: 0\nExplanation: the amount of 3 cannot be made up just with coins of 2.", "link": "https://leetcode.com/problems/coin-change-ii/description/", "difficulty": "Medium", "categories": ["Dynamic_programming"], "code": "from typing import List\ndef change(amount: int, coins: List[int]) -> int:\n    def numberOfWays(i: int, amount: int) -> int:\n        if amount == 0:\n            return 1\n        if i == len(coins):\n            return 0\n        if memo[i][amount] != -1:\n            return memo[i][amount]\n\n        if coins[i] > amount:\n            memo[i][amount] = numberOfWays(i + 1, amount)\n        else:\n            memo[i][amount] = numberOfWays(i, amount - coins[i]) + numberOfWays(i + 1, amount)\n        \n        return memo[i][amount]\n\n    memo = [[-1] * (amount + 1) for _ in range(len(coins))]\n    return numberOfWays(0, amount)", "asserts": ["assert change(10,[10])==1", "assert change(0, [1, 2, 5]) == 1  # Edge case: trying to make 0 with any coins should always return 1", "assert change(11, [5]) == 0  # Amount cannot be made up with given coins", "assert change(0, []) == 1  # Edge case: trying to make 0 without any coins, should return 1 as there's one way of making 0 with no coins", "assert change(5, [5, 1]) == 2  # Amount can be made with given coins: [5], [1, 1, 1, 1, 1]"]}], "category": "Dynamic_programming", "prompt_tokens": 919, "total_tokens": 1187, "completion_tokens": 268, "completion": "Maximum Subarray: Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.\n\n###Code: \n\nfrom typing import List\ndef maxSubArray(nums: List[int]) -> int:\n    max_sum = nums[0]\n    current_sum = nums[0]\n    \n    for num in nums[1:]:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    \n    return max_sum\n\n###Testcases: \n\nassert maxSubArray([-2,1,-3,4,-1,2,1,-5,4]) == 6  # Subarray [4,-1,2,1] has the largest sum = 6\nassert maxSubArray([1]) == 1  # Subarray [1] itself is the maximum subarray\nassert maxSubArray([5,4,-1,7,8]) == 23  # The entire array is the maximum subarray with sum = 23\nassert maxSubArray([-2,-1,-3,-4,-1,-2,-1,-5,-4]) == -1  # Subarray [-1] itself is the maximum subarray with sum = -1\n\n[/Example 3]", "temperature": 0.691, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Calvin", "UUID": "51a5caf9-241f-4de3-9ee2-9420490b73d7", "question": "Given a set[] of non-negative integers and a value sum, return the subset of the given set whose sum is equal to the given sum or None if one doesn't exist\n", "examples": "Input: set = [1, 2, 3, 4, 5], sum = 10\nOutput: [1, 2, 3, 4]", "link": "https://www.geeksforgeeks.org/subset-sum-problem-dp-25/", "difficulty": null, "categories": ["Dynamic_programming"], "code": "def subsetsum(fullset: list, target_sum: int) -> set:\n    def subsetSum_helper(cur_idx: int, fullset: list, target_sum: int, subset: list):\n        if target_sum == 0:\n            return subset\n        if (cur_idx == len(fullset)):\n            return None\n        excluding = subsetSum_helper(cur_idx + 1, fullset, target_sum, subset)\n          \n        if excluding is not None:\n            return excluding\n        elif fullset[cur_idx] <= target_sum:\n            subset.append(fullset[cur_idx])\n            including = subsetSum_helper(cur_idx + 1, fullset, target_sum - fullset[cur_idx], subset)\n            if including!=None:\n                return including\n            else:\n                subset.pop()\n            return None\n    return subsetSum_helper(0, fullset, target_sum, [])\n", "asserts": ["assert set(subsetsum([3, 34, 4, 12, 5, 2], 9)) == {4,5}", "assert subsetsum([1, 8, 2, 7, 4], 14) == [8, 2, 4]", "assert subsetsum([10, 12, 15, 6, 19], 21) == [15, 6]", "assert subsetsum([5, 10, 12, 13, 15, 18], 30) == [12, 18]", "assert subsetsum([5, 3, 9, 12, 6, 15], 27) == [12, 15]", "assert subsetsum([2, 3, 7, 8, 10], 11) == [3, 8]", "assert subsetsum([6, 2, 7, 11, 8], 16) == [6, 2, 8]", "assert subsetsum([5, 7, 1, 14, 6], 13) == [7, 6]", "assert subsetsum([1], 1) == [1]", "assert subsetsum([2, 5, 8, 4], 0) == []", "assert subsetsum([], 5) == None", "assert subsetsum([-1, -2, -3, -4, -5], -10) == None  # Negative numbers are not allowed according to the question", "assert subsetsum([4, 1, 2, 5, 12, 7], 9) == [2, 7]", "assert subsetsum([3, 5, 8, 4], 22) == None  # Sum exceeds the sum of all elements"]}, {"author": "Hafeez", "UUID": "296ab89e-7208-4f6f-bed1-d623f30e32c9", "question": "Coin Change II: You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.\n\nReturn the number of combinations that make up that amount. If that amount of money cannot be made up by any combination of the coins, return 0.\n\nYou may assume that you have an infinite number of each kind of coin.\n\nThe answer is guaranteed to fit into a signed 32-bit integer.", "examples": "Input: amount = 5, coins = [1,2,5]\nOutput: 4\nExplanation: there are four ways to make up the amount:\n5=5\n5=2+2+1\n5=2+1+1+1\n5=1+1+1+1+1\nInput: amount = 3, coins = [2]\nOutput: 0\nExplanation: the amount of 3 cannot be made up just with coins of 2.", "link": "https://leetcode.com/problems/coin-change-ii/description/", "difficulty": "Medium", "categories": ["Dynamic_programming"], "code": "from typing import List\ndef change(amount: int, coins: List[int]) -> int:\n    def numberOfWays(i: int, amount: int) -> int:\n        if amount == 0:\n            return 1\n        if i == len(coins):\n            return 0\n        if memo[i][amount] != -1:\n            return memo[i][amount]\n\n        if coins[i] > amount:\n            memo[i][amount] = numberOfWays(i + 1, amount)\n        else:\n            memo[i][amount] = numberOfWays(i, amount - coins[i]) + numberOfWays(i + 1, amount)\n        \n        return memo[i][amount]\n\n    memo = [[-1] * (amount + 1) for _ in range(len(coins))]\n    return numberOfWays(0, amount)", "asserts": ["assert change(10,[10])==1", "assert change(0, [1, 2, 5]) == 1  # Edge case: trying to make 0 with any coins should always return 1", "assert change(11, [5]) == 0  # Amount cannot be made up with given coins", "assert change(0, []) == 1  # Edge case: trying to make 0 without any coins, should return 1 as there's one way of making 0 with no coins", "assert change(5, [5, 1]) == 2  # Amount can be made with given coins: [5], [1, 1, 1, 1, 1]"]}], "category": "Dynamic_programming", "prompt_tokens": 1226, "total_tokens": 1614, "completion_tokens": 388, "completion": "Given a sequence of non-negative integers, find the subsequence with the maximum sum and return the sum.\n\n###Code: \n\ndef max_subsequence_sum(nums: list) -> int:\n    if len(nums) == 0:\n        return 0\n    max_sum = current_sum = nums[0]\n    for num in nums[1:]:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    return max_sum\n\n###Testcases: \n\nassert max_subsequence_sum([1, 2, 3, 4, 5]) == 15  # Maximum sum subsequence is the entire sequence\nassert max_subsequence_sum([5, 4, -1, 7, 8]) == 23  # Maximum sum subsequence is [5, 4, -1, 7, 8]\nassert max_subsequence_sum([-2, -3, 4, -1, -2, 1, 5, -3]) == 7  # Maximum sum subsequence is [4, -1, -2, 1, 5]\nassert max_subsequence_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) == 6  # Maximum sum subsequence is [4, -1, 2, 1]\nassert max_subsequence_sum([8, -1, 3, 4]) == 14  # Maximum sum subsequence is [8, -1, 3, 4]\nassert max_subsequence_sum([-2, -5, 6, -2, -3, 1, 5, -6]) == 7  # Maximum sum subsequence is [6, -2, -3, 1, 5]\n\n[/Example 3]", "temperature": 0.608, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Hafeez", "UUID": "38dca76c-ee6c-4c71-83a9-89240828a3b7", "question": "Best Time to Buy and Sell Stock II: You are given an integer array prices where prices[i] is the price of a given stock on the ith day.\n\nOn each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day.\n\nFind and return the maximum profit you can achieve.", "examples": "Input: prices = [7,1,5,3,6,4]\nOutput: 7\nExplanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\nThen buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.\nTotal profit is 4 + 3 = 7.\nInput: prices = [7,6,4,3,1]\nOutput: 0\nExplanation: There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0.", "link": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/", "difficulty": "Medium", "categories": ["Dynamic_programming"], "code": "from typing import List\ndef maxProfit(prices: List[int]) -> int:\n    cur_hold, cur_not_hold = -float('inf'), 0\n    \n    for stock_price in prices:\n        \n        prev_hold, prev_not_hold = cur_hold, cur_not_hold\n        cur_hold = max( prev_hold, prev_not_hold - stock_price )\n        cur_not_hold = max( prev_not_hold, prev_hold + stock_price )\n    return cur_not_hold", "asserts": ["assert maxProfit([1,2,3,4,5])==4", "assert maxProfit([1,2,100,2,1]) == 99"]}, {"author": "Calvin", "UUID": "e35d1110-85e8-4f50-80aa-91eb976b310b", "question": "Return the factorial of a given number n", "examples": "Input: 5\nOutput: 120\n\nInput: 6\nOutput: 720", "link": NaN, "difficulty": null, "categories": ["Dynamic_programming"], "code": "\ndef fact(n: int) -> int:\n  if n <= 1:\n    return 1\n  return n*fact(n-1)\n", "asserts": ["assert fact(5) == 120", "assert fact(0) == 1", "assert fact(1) == 1", "assert fact(3) == 6", "assert fact(7) == 5040", "assert fact(10) == 3628800", "assert fact(4) == 24", "assert fact(8) == 40320", "assert fact(2) == 2", "assert fact(11) == 39916800"]}], "category": "Dynamic_programming", "prompt_tokens": 572, "total_tokens": 833, "completion_tokens": 261, "completion": "Find the maximum subarray sum for a given array of integers.\n\n###Code: \n\ndef maxSubArray(nums: List[int]) -> int:\n    max_sum = float('-inf')\n    current_sum = 0\n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    return max_sum\n\n\n###Testcases: \n\nassert maxSubArray([-2,1,-3,4,-1,2,1,-5,4]) == 6\nassert maxSubArray([1]) == 1\nassert maxSubArray([5,4,-1,7,8]) == 23\nassert maxSubArray([-2, -3, 4, -1, -2, 1, 5, -3]) == 7\nassert maxSubArray([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == 55\nassert maxSubArray([-10, -5, -3, -2, -1]) == -1\nassert maxSubArray([-10, -5, -3, 2, -1]) == 2\n\n[/Example 3]", "temperature": 0.985, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Hafeez", "UUID": "38dca76c-ee6c-4c71-83a9-89240828a3b7", "question": "Best Time to Buy and Sell Stock II: You are given an integer array prices where prices[i] is the price of a given stock on the ith day.\n\nOn each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day.\n\nFind and return the maximum profit you can achieve.", "examples": "Input: prices = [7,1,5,3,6,4]\nOutput: 7\nExplanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\nThen buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.\nTotal profit is 4 + 3 = 7.\nInput: prices = [7,6,4,3,1]\nOutput: 0\nExplanation: There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0.", "link": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/", "difficulty": "Medium", "categories": ["Dynamic_programming"], "code": "from typing import List\ndef maxProfit(prices: List[int]) -> int:\n    cur_hold, cur_not_hold = -float('inf'), 0\n    \n    for stock_price in prices:\n        \n        prev_hold, prev_not_hold = cur_hold, cur_not_hold\n        cur_hold = max( prev_hold, prev_not_hold - stock_price )\n        cur_not_hold = max( prev_not_hold, prev_hold + stock_price )\n    return cur_not_hold", "asserts": ["assert maxProfit([1,2,3,4,5])==4", "assert maxProfit([1,2,100,2,1]) == 99"]}, {"author": "Hafeez", "UUID": "d695e67c-5b0e-4235-8406-30ee6be61173", "question": "N-th Tribonacci Number: The Tribonacci sequence Tn is defined as follows: \n\nT0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n >= 0.\n\nGiven n, return the value of Tn.", "examples": "Input: n = 4\nOutput: 4\nExplanation:\nT_3 = 0 + 1 + 1 = 2\nT_4 = 1 + 1 + 2 = 4", "link": "https://leetcode.com/problems/n-th-tribonacci-number/description/", "difficulty": "Easy", "categories": ["Dynamic_programming"], "code": "def tribonacci(n: int) -> int:\n    dp = {0: 0, 1: 1, 2: 1}\n    def dfs(i):\n        if i in dp:\n            return dp[i]\n        dp[i] = dfs(i - 1) + dfs(i - 2) + dfs(i - 3)\n        return dp[i]\n    \n    return dfs(n)", "asserts": ["assert tribonacci(25)==1389537", "assert tribonacci(0) == 0", "assert tribonacci(1) == 1", "assert tribonacci(2) == 1", "assert tribonacci(3) == 2", "assert tribonacci(5) == 7", "assert tribonacci(7) == 24", "assert tribonacci(10) == 149", "assert tribonacci(15) == 3136", "assert tribonacci(30) == 29249425"]}], "category": "Dynamic_programming", "prompt_tokens": 693, "total_tokens": 1049, "completion_tokens": 356, "completion": "Count Square Submatrices with All Ones: Given a m x n matrix of 0s and 1s, return the number of square submatrices with all ones.\n\n###Code: \n\nfrom typing import List\ndef countSquares(matrix: List[List[int]]) -> int:\n    m, n = len(matrix), len(matrix[0])\n    dp = [[0] * n for _ in range(m)]\n    count = 0\n    \n    for i in range(m):\n        for j in range(n):\n            if matrix[i][j] == 1:\n                dp[i][j] = 1\n                if i > 0 and j > 0:\n                    dp[i][j] += min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])\n                count += dp[i][j]\n    \n    return count\n\n###Testcases: \n\nassert countSquares([[0,1,1,1],[1,1,1,1],[0,1,1,1]]) == 15\nassert countSquares([[1,0,1],[1,1,0],[1,1,0]]) == 7\nassert countSquares([[0,1,1,1],[1,1,1,1],[0,1,1,1],[1,0,0,1]]) == 20\nassert countSquares([[1,1,1,1],[1,1,1,1],[1,1,1,1],[1,1,1,1]]) == 20\nassert countSquares([[1]]) == 1\nassert countSquares([[0]]) == 0\n\n[/Example 3]", "temperature": 0.729, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Calvin", "UUID": "e35d1110-85e8-4f50-80aa-91eb976b310b", "question": "Return the factorial of a given number n", "examples": "Input: 5\nOutput: 120\n\nInput: 6\nOutput: 720", "link": NaN, "difficulty": null, "categories": ["Dynamic_programming"], "code": "\ndef fact(n: int) -> int:\n  if n <= 1:\n    return 1\n  return n*fact(n-1)\n", "asserts": ["assert fact(5) == 120", "assert fact(0) == 1", "assert fact(1) == 1", "assert fact(3) == 6", "assert fact(7) == 5040", "assert fact(10) == 3628800", "assert fact(4) == 24", "assert fact(8) == 40320", "assert fact(2) == 2", "assert fact(11) == 39916800"]}, {"author": "Hafeez", "UUID": "d695e67c-5b0e-4235-8406-30ee6be61173", "question": "N-th Tribonacci Number: The Tribonacci sequence Tn is defined as follows: \n\nT0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n >= 0.\n\nGiven n, return the value of Tn.", "examples": "Input: n = 4\nOutput: 4\nExplanation:\nT_3 = 0 + 1 + 1 = 2\nT_4 = 1 + 1 + 2 = 4", "link": "https://leetcode.com/problems/n-th-tribonacci-number/description/", "difficulty": "Easy", "categories": ["Dynamic_programming"], "code": "def tribonacci(n: int) -> int:\n    dp = {0: 0, 1: 1, 2: 1}\n    def dfs(i):\n        if i in dp:\n            return dp[i]\n        dp[i] = dfs(i - 1) + dfs(i - 2) + dfs(i - 3)\n        return dp[i]\n    \n    return dfs(n)", "asserts": ["assert tribonacci(25)==1389537", "assert tribonacci(0) == 0", "assert tribonacci(1) == 1", "assert tribonacci(2) == 1", "assert tribonacci(3) == 2", "assert tribonacci(5) == 7", "assert tribonacci(7) == 24", "assert tribonacci(10) == 149", "assert tribonacci(15) == 3136", "assert tribonacci(30) == 29249425"]}], "category": "Dynamic_programming", "prompt_tokens": 612, "total_tokens": 900, "completion_tokens": 288, "completion": "Find the minimum cost to reach the end of the array by jumping from one element to another. You can jump at most k steps ahead.\n\n###Code: \n\n```python\ndef minCostJump(nums, k):\n    n = len(nums)\n    dp = [0] + [float('inf')] * (n-1)\n    for i in range(1, n):\n        for j in range(max(0, i-k), i):\n            dp[i] = min(dp[i], dp[j] + nums[i])\n    return dp[-1]\n```\n\n###Testcases: \n\n```python\nassert minCostJump([1,2,4,-1,2], 2) == 5\nassert minCostJump([1,2,4,-1,2], 1) == 3\nassert minCostJump([1,2,4,-1,2], 3) == 3\nassert minCostJump([1,2,4,-1,2,1], 2) == 4\nassert minCostJump([1,2,4,-1,2,1], 3) == 3\nassert minCostJump([2,3,1,1,4], 2) == 2\nassert minCostJump([2,3,1,1,4], 1) == 4\n```\n\n[/Example 3]", "temperature": 0.603, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Hafeez", "UUID": "38dca76c-ee6c-4c71-83a9-89240828a3b7", "question": "Best Time to Buy and Sell Stock II: You are given an integer array prices where prices[i] is the price of a given stock on the ith day.\n\nOn each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day.\n\nFind and return the maximum profit you can achieve.", "examples": "Input: prices = [7,1,5,3,6,4]\nOutput: 7\nExplanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\nThen buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.\nTotal profit is 4 + 3 = 7.\nInput: prices = [7,6,4,3,1]\nOutput: 0\nExplanation: There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0.", "link": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/", "difficulty": "Medium", "categories": ["Dynamic_programming"], "code": "from typing import List\ndef maxProfit(prices: List[int]) -> int:\n    cur_hold, cur_not_hold = -float('inf'), 0\n    \n    for stock_price in prices:\n        \n        prev_hold, prev_not_hold = cur_hold, cur_not_hold\n        cur_hold = max( prev_hold, prev_not_hold - stock_price )\n        cur_not_hold = max( prev_not_hold, prev_hold + stock_price )\n    return cur_not_hold", "asserts": ["assert maxProfit([1,2,3,4,5])==4", "assert maxProfit([1,2,100,2,1]) == 99"]}, {"author": "Hafeez", "UUID": "296ab89e-7208-4f6f-bed1-d623f30e32c9", "question": "Coin Change II: You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.\n\nReturn the number of combinations that make up that amount. If that amount of money cannot be made up by any combination of the coins, return 0.\n\nYou may assume that you have an infinite number of each kind of coin.\n\nThe answer is guaranteed to fit into a signed 32-bit integer.", "examples": "Input: amount = 5, coins = [1,2,5]\nOutput: 4\nExplanation: there are four ways to make up the amount:\n5=5\n5=2+2+1\n5=2+1+1+1\n5=1+1+1+1+1\nInput: amount = 3, coins = [2]\nOutput: 0\nExplanation: the amount of 3 cannot be made up just with coins of 2.", "link": "https://leetcode.com/problems/coin-change-ii/description/", "difficulty": "Medium", "categories": ["Dynamic_programming"], "code": "from typing import List\ndef change(amount: int, coins: List[int]) -> int:\n    def numberOfWays(i: int, amount: int) -> int:\n        if amount == 0:\n            return 1\n        if i == len(coins):\n            return 0\n        if memo[i][amount] != -1:\n            return memo[i][amount]\n\n        if coins[i] > amount:\n            memo[i][amount] = numberOfWays(i + 1, amount)\n        else:\n            memo[i][amount] = numberOfWays(i, amount - coins[i]) + numberOfWays(i + 1, amount)\n        \n        return memo[i][amount]\n\n    memo = [[-1] * (amount + 1) for _ in range(len(coins))]\n    return numberOfWays(0, amount)", "asserts": ["assert change(10,[10])==1", "assert change(0, [1, 2, 5]) == 1  # Edge case: trying to make 0 with any coins should always return 1", "assert change(11, [5]) == 0  # Amount cannot be made up with given coins", "assert change(0, []) == 1  # Edge case: trying to make 0 without any coins, should return 1 as there's one way of making 0 with no coins", "assert change(5, [5, 1]) == 2  # Amount can be made with given coins: [5], [1, 1, 1, 1, 1]"]}], "category": "Dynamic_programming", "prompt_tokens": 848, "total_tokens": 1134, "completion_tokens": 286, "completion": "Longest Increasing Subsequence: Given an unsorted array of integers, find the length of longest increasing subsequence.\n\n###Code: \n\nfrom typing import List\ndef lengthOfLIS(nums: List[int]) -> int:\n    if not nums:\n        return 0\n    \n    dp = [1] * len(nums)\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    \n    return max(dp)\n\n###Testcases: \n\nassert lengthOfLIS([10, 9, 2, 5, 3, 7, 101, 18]) == 4  # The longest increasing subsequence is [2, 3, 7, 101], so the expected output is 4\nassert lengthOfLIS([0, 1, 0, 3, 2, 3]) == 4  # The longest increasing subsequence is [0, 1, 2, 3], so the expected output is 4\nassert lengthOfLIS([7, 7, 7, 7, 7, 7, 7]) == 1  # The longest increasing subsequence is [7], so the expected output is 1\n\n[/Example 3]", "temperature": 0.713, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Calvin", "UUID": "e35d1110-85e8-4f50-80aa-91eb976b310b", "question": "Return the factorial of a given number n", "examples": "Input: 5\nOutput: 120\n\nInput: 6\nOutput: 720", "link": NaN, "difficulty": null, "categories": ["Dynamic_programming"], "code": "\ndef fact(n: int) -> int:\n  if n <= 1:\n    return 1\n  return n*fact(n-1)\n", "asserts": ["assert fact(5) == 120", "assert fact(0) == 1", "assert fact(1) == 1", "assert fact(3) == 6", "assert fact(7) == 5040", "assert fact(10) == 3628800", "assert fact(4) == 24", "assert fact(8) == 40320", "assert fact(2) == 2", "assert fact(11) == 39916800"]}, {"author": "Hafeez", "UUID": "6aaf1310-7585-4d90-91e7-1f405c9b25e7", "question": "Get Maximum in Generated Array: You are given an integer n. A 0-indexed integer array nums of length n + 1 is generated in the following way:\n\nnums[0] = 0\nnums[1] = 1\nnums[2 * i] = nums[i] when 2 <= 2 * i <= n\nnums[2 * i + 1] = nums[i] + nums[i + 1] when 2 <= 2 * i + 1 <= n\nReturn the maximum integer in the array nums\u200b\u200b\u200b.", "examples": "Input: n = 7\nOutput: 3\nExplanation: According to the given rules:\n  nums[0] = 0\n  nums[1] = 1\n  nums[(1 * 2) = 2] = nums[1] = 1\n  nums[(1 * 2) + 1 = 3] = nums[1] + nums[2] = 1 + 1 = 2\n  nums[(2 * 2) = 4] = nums[2] = 1\n  nums[(2 * 2) + 1 = 5] = nums[2] + nums[3] = 1 + 2 = 3\n  nums[(3 * 2) = 6] = nums[3] = 2\n  nums[(3 * 2) + 1 = 7] = nums[3] + nums[4] = 2 + 1 = 3\nHence, nums = [0,1,1,2,1,3,2,3], and the maximum is max(0,1,1,2,1,3,2,3) = 3.\nInput: n = 2\nOutput: 1\nExplanation: According to the given rules, nums = [0,1,1]. The maximum is max(0,1,1) = 1.\nInput: n = 3\nOutput: 2\nExplanation: According to the given rules, nums = [0,1,1,2]. The maximum is max(0,1,1,2) = 2.", "link": "https://leetcode.com/problems/get-maximum-in-generated-array/", "difficulty": "Easy", "categories": ["Dynamic_programming"], "code": "def getMaximumGenerated(n: int) -> int:\n    if n<2:\n        return n\n    nums=[0]*(n+1)\n    nums[0]=0\n    nums[1]=1\n    for i in range(2,n+1):\n        if i%2==0:\n            nums[i]=nums[i//2]\n        else:\n            nums[i]=nums[i//2]+nums[i//2+1]\n    return max(nums)", "asserts": ["assert getMaximumGenerated(2)==1", "assert getMaximumGenerated(4) == 2", "assert getMaximumGenerated(5) == 3", "assert getMaximumGenerated(8) == 3", "assert getMaximumGenerated(15) == 5", "assert getMaximumGenerated(0) == 0", "assert getMaximumGenerated(1) == 1"]}], "category": "Dynamic_programming", "prompt_tokens": 643, "total_tokens": 997, "completion_tokens": 354, "completion": "Calculate the minimum number of operations to transform string s1 into string s2. You can perform three types of operations: \n- Insert a character\n- Delete a character\n- Replace a character\n\n###Code: \n\ndef minDistance(s1: str, s2: str) -> int:\n    m, n = len(s1), len(s2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(m + 1):\n        dp[i][0] = i\n    for j in range(n + 1):\n        dp[0][j] = j\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if s1[i - 1] == s2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1]\n            else:\n                dp[i][j] = 1 + min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1])\n\n    return dp[m][n]\n\n###Testcases: \n\nassert minDistance(\"horse\", \"ros\") == 3\nassert minDistance(\"intention\", \"execution\") == 5\nassert minDistance(\"kitten\", \"sitting\") == 3\nassert minDistance(\"\", \"abc\") == 3\nassert minDistance(\"abc\", \"\") == 3\nassert minDistance(\"\", \"\") == 0\nassert minDistance(\"hello\", \"hello\") == 0\nassert minDistance(\"abcde\", \"vwxyz\") == 5\n\n[/Example 3]", "temperature": 0.917, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Hafeez", "UUID": "38dca76c-ee6c-4c71-83a9-89240828a3b7", "question": "Best Time to Buy and Sell Stock II: You are given an integer array prices where prices[i] is the price of a given stock on the ith day.\n\nOn each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day.\n\nFind and return the maximum profit you can achieve.", "examples": "Input: prices = [7,1,5,3,6,4]\nOutput: 7\nExplanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\nThen buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.\nTotal profit is 4 + 3 = 7.\nInput: prices = [7,6,4,3,1]\nOutput: 0\nExplanation: There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0.", "link": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/", "difficulty": "Medium", "categories": ["Dynamic_programming"], "code": "from typing import List\ndef maxProfit(prices: List[int]) -> int:\n    cur_hold, cur_not_hold = -float('inf'), 0\n    \n    for stock_price in prices:\n        \n        prev_hold, prev_not_hold = cur_hold, cur_not_hold\n        cur_hold = max( prev_hold, prev_not_hold - stock_price )\n        cur_not_hold = max( prev_not_hold, prev_hold + stock_price )\n    return cur_not_hold", "asserts": ["assert maxProfit([1,2,3,4,5])==4", "assert maxProfit([1,2,100,2,1]) == 99"]}, {"author": "Hafeez", "UUID": "6aaf1310-7585-4d90-91e7-1f405c9b25e7", "question": "Get Maximum in Generated Array: You are given an integer n. A 0-indexed integer array nums of length n + 1 is generated in the following way:\n\nnums[0] = 0\nnums[1] = 1\nnums[2 * i] = nums[i] when 2 <= 2 * i <= n\nnums[2 * i + 1] = nums[i] + nums[i + 1] when 2 <= 2 * i + 1 <= n\nReturn the maximum integer in the array nums\u200b\u200b\u200b.", "examples": "Input: n = 7\nOutput: 3\nExplanation: According to the given rules:\n  nums[0] = 0\n  nums[1] = 1\n  nums[(1 * 2) = 2] = nums[1] = 1\n  nums[(1 * 2) + 1 = 3] = nums[1] + nums[2] = 1 + 1 = 2\n  nums[(2 * 2) = 4] = nums[2] = 1\n  nums[(2 * 2) + 1 = 5] = nums[2] + nums[3] = 1 + 2 = 3\n  nums[(3 * 2) = 6] = nums[3] = 2\n  nums[(3 * 2) + 1 = 7] = nums[3] + nums[4] = 2 + 1 = 3\nHence, nums = [0,1,1,2,1,3,2,3], and the maximum is max(0,1,1,2,1,3,2,3) = 3.\nInput: n = 2\nOutput: 1\nExplanation: According to the given rules, nums = [0,1,1]. The maximum is max(0,1,1) = 1.\nInput: n = 3\nOutput: 2\nExplanation: According to the given rules, nums = [0,1,1,2]. The maximum is max(0,1,1,2) = 2.", "link": "https://leetcode.com/problems/get-maximum-in-generated-array/", "difficulty": "Easy", "categories": ["Dynamic_programming"], "code": "def getMaximumGenerated(n: int) -> int:\n    if n<2:\n        return n\n    nums=[0]*(n+1)\n    nums[0]=0\n    nums[1]=1\n    for i in range(2,n+1):\n        if i%2==0:\n            nums[i]=nums[i//2]\n        else:\n            nums[i]=nums[i//2]+nums[i//2+1]\n    return max(nums)", "asserts": ["assert getMaximumGenerated(2)==1", "assert getMaximumGenerated(4) == 2", "assert getMaximumGenerated(5) == 3", "assert getMaximumGenerated(8) == 3", "assert getMaximumGenerated(15) == 5", "assert getMaximumGenerated(0) == 0", "assert getMaximumGenerated(1) == 1"]}], "category": "Dynamic_programming", "prompt_tokens": 724, "total_tokens": 1038, "completion_tokens": 314, "completion": "Minimum Path Sum: Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right, which minimizes the sum of all numbers along its path.\n\nNote: You can only move either down or right at any point in time.\n\n###Code: \n\nfrom typing import List\ndef minPathSum(grid: List[List[int]]) -> int:\n    m, n = len(grid), len(grid[0])\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n    \n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n    \n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    \n    return dp[-1][-1]\n\n###Testcases: \n\nassert minPathSum([[1,3,1],[1,5,1],[4,2,1]]) == 7\nassert minPathSum([[1,2,3],[4,5,6]]) == 12\nassert minPathSum([[1,2],[1,1]]) == 3\n\n[/Example 3]", "temperature": 0.653, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Calvin", "UUID": "5e7011e5-fee4-4c1a-a98f-3b81e50508cc", "question": "Return nth number in the fibonacci sequence", "examples": "Input: 9\nOutput: 34\n\nInput: 7\nOutput: 13", "link": NaN, "difficulty": null, "categories": ["Dynamic_programming"], "code": "def fibonacci(n: int) -> int:\n    a = 0\n    b = 1\n    if n < 0:\n        print(\"Incorrect input\")\n    elif n == 0:\n        return a\n    elif n == 1:\n        return b\n    else:\n        for i in range(2, n+1):\n            c = a + b\n            a = b\n            b = c\n        return b\n    b = c\n    return fib(n-1, a, b)\n", "asserts": ["assert fibonacci(9) == 34", "assert fibonacci(10) == 55", "assert fibonacci(5) == 5", "assert fibonacci(2) == 1", "assert fibonacci(0) == 0", "assert fibonacci(11) == 89", "assert fibonacci(15) == 610", "assert fibonacci(20) == 6765", "assert fibonacci(25) == 75025", "assert fibonacci(3) == 2", "assert fibonacci(1) == 1", "assert fibonacci(6) == 8", "assert fibonacci(30) == 832040", "assert fibonacci(35) == 9227465", "assert fibonacci(40) == 102334155"]}, {"author": "Hafeez", "UUID": "d695e67c-5b0e-4235-8406-30ee6be61173", "question": "N-th Tribonacci Number: The Tribonacci sequence Tn is defined as follows: \n\nT0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n >= 0.\n\nGiven n, return the value of Tn.", "examples": "Input: n = 4\nOutput: 4\nExplanation:\nT_3 = 0 + 1 + 1 = 2\nT_4 = 1 + 1 + 2 = 4", "link": "https://leetcode.com/problems/n-th-tribonacci-number/description/", "difficulty": "Easy", "categories": ["Dynamic_programming"], "code": "def tribonacci(n: int) -> int:\n    dp = {0: 0, 1: 1, 2: 1}\n    def dfs(i):\n        if i in dp:\n            return dp[i]\n        dp[i] = dfs(i - 1) + dfs(i - 2) + dfs(i - 3)\n        return dp[i]\n    \n    return dfs(n)", "asserts": ["assert tribonacci(25)==1389537", "assert tribonacci(0) == 0", "assert tribonacci(1) == 1", "assert tribonacci(2) == 1", "assert tribonacci(3) == 2", "assert tribonacci(5) == 7", "assert tribonacci(7) == 24", "assert tribonacci(10) == 149", "assert tribonacci(15) == 3136", "assert tribonacci(30) == 29249425"]}], "category": "Dynamic_programming", "prompt_tokens": 735, "total_tokens": 1132, "completion_tokens": 397, "completion": "Find the minimum number of operations needed to transform string1 into string2. There are 3 operations allowed:\n1. Insert a character\n2. Delete a character\n3. Replace a character\n\n###Code: \n\ndef min_edit_distance(word1: str, word2: str) -> int:\n    len1 = len(word1)\n    len2 = len(word2)\n    dp = [[0] * (len2 + 1) for _ in range(len1 + 1)]\n    \n    for i in range(len1 + 1):\n        dp[i][0] = i\n    \n    for j in range(len2 + 1):\n        dp[0][j] = j\n    \n    for i in range(1, len1 + 1):\n        for j in range(1, len2 + 1):\n            if word1[i-1] == word2[j-1]:\n                dp[i][j] = dp[i-1][j-1]\n            else:\n                dp[i][j] = 1 + min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1])\n    \n    return dp[len1][len2]\n\n###Testcases: \n\nassert min_edit_distance(\"kitten\", \"sitting\") == 3\nassert min_edit_distance(\"intention\", \"execution\") == 5\nassert min_edit_distance(\"horse\", \"ros\") == 3\nassert min_edit_distance(\"hello\", \"helo\") == 1\nassert min_edit_distance(\"abc\", \"abc\") == 0\nassert min_edit_distance(\"abc\", \"def\") == 3\nassert min_edit_distance(\"abc\", \"abcd\") == 1\nassert min_edit_distance(\"abc\", \"ab\") == 1\nassert min_edit_distance(\"\", \"abc\") == 3\nassert min_edit_distance(\"\", \"\") == 0\n\n[/Example 3]", "temperature": 0.903, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Hafeez", "UUID": "296ab89e-7208-4f6f-bed1-d623f30e32c9", "question": "Coin Change II: You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.\n\nReturn the number of combinations that make up that amount. If that amount of money cannot be made up by any combination of the coins, return 0.\n\nYou may assume that you have an infinite number of each kind of coin.\n\nThe answer is guaranteed to fit into a signed 32-bit integer.", "examples": "Input: amount = 5, coins = [1,2,5]\nOutput: 4\nExplanation: there are four ways to make up the amount:\n5=5\n5=2+2+1\n5=2+1+1+1\n5=1+1+1+1+1\nInput: amount = 3, coins = [2]\nOutput: 0\nExplanation: the amount of 3 cannot be made up just with coins of 2.", "link": "https://leetcode.com/problems/coin-change-ii/description/", "difficulty": "Medium", "categories": ["Dynamic_programming"], "code": "from typing import List\ndef change(amount: int, coins: List[int]) -> int:\n    def numberOfWays(i: int, amount: int) -> int:\n        if amount == 0:\n            return 1\n        if i == len(coins):\n            return 0\n        if memo[i][amount] != -1:\n            return memo[i][amount]\n\n        if coins[i] > amount:\n            memo[i][amount] = numberOfWays(i + 1, amount)\n        else:\n            memo[i][amount] = numberOfWays(i, amount - coins[i]) + numberOfWays(i + 1, amount)\n        \n        return memo[i][amount]\n\n    memo = [[-1] * (amount + 1) for _ in range(len(coins))]\n    return numberOfWays(0, amount)", "asserts": ["assert change(10,[10])==1", "assert change(0, [1, 2, 5]) == 1  # Edge case: trying to make 0 with any coins should always return 1", "assert change(11, [5]) == 0  # Amount cannot be made up with given coins", "assert change(0, []) == 1  # Edge case: trying to make 0 without any coins, should return 1 as there's one way of making 0 with no coins", "assert change(5, [5, 1]) == 2  # Amount can be made with given coins: [5], [1, 1, 1, 1, 1]"]}, {"author": "Calvin", "UUID": "51a5caf9-241f-4de3-9ee2-9420490b73d7", "question": "Given a set[] of non-negative integers and a value sum, return the subset of the given set whose sum is equal to the given sum or None if one doesn't exist\n", "examples": "Input: set = [1, 2, 3, 4, 5], sum = 10\nOutput: [1, 2, 3, 4]", "link": "https://www.geeksforgeeks.org/subset-sum-problem-dp-25/", "difficulty": null, "categories": ["Dynamic_programming"], "code": "def subsetsum(fullset: list, target_sum: int) -> set:\n    def subsetSum_helper(cur_idx: int, fullset: list, target_sum: int, subset: list):\n        if target_sum == 0:\n            return subset\n        if (cur_idx == len(fullset)):\n            return None\n        excluding = subsetSum_helper(cur_idx + 1, fullset, target_sum, subset)\n          \n        if excluding is not None:\n            return excluding\n        elif fullset[cur_idx] <= target_sum:\n            subset.append(fullset[cur_idx])\n            including = subsetSum_helper(cur_idx + 1, fullset, target_sum - fullset[cur_idx], subset)\n            if including!=None:\n                return including\n            else:\n                subset.pop()\n            return None\n    return subsetSum_helper(0, fullset, target_sum, [])\n", "asserts": ["assert set(subsetsum([3, 34, 4, 12, 5, 2], 9)) == {4,5}", "assert subsetsum([1, 8, 2, 7, 4], 14) == [8, 2, 4]", "assert subsetsum([10, 12, 15, 6, 19], 21) == [15, 6]", "assert subsetsum([5, 10, 12, 13, 15, 18], 30) == [12, 18]", "assert subsetsum([5, 3, 9, 12, 6, 15], 27) == [12, 15]", "assert subsetsum([2, 3, 7, 8, 10], 11) == [3, 8]", "assert subsetsum([6, 2, 7, 11, 8], 16) == [6, 2, 8]", "assert subsetsum([5, 7, 1, 14, 6], 13) == [7, 6]", "assert subsetsum([1], 1) == [1]", "assert subsetsum([2, 5, 8, 4], 0) == []", "assert subsetsum([], 5) == None", "assert subsetsum([-1, -2, -3, -4, -5], -10) == None  # Negative numbers are not allowed according to the question", "assert subsetsum([4, 1, 2, 5, 12, 7], 9) == [2, 7]", "assert subsetsum([3, 5, 8, 4], 22) == None  # Sum exceeds the sum of all elements"]}], "category": "Dynamic_programming", "prompt_tokens": 1226, "total_tokens": 1691, "completion_tokens": 465, "completion": "You are given an array of integers, find the length of the longest increasing subsequence.\n\nA subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements.\n\nFor example:\n```\nInput: [10, 9, 2, 5, 3, 7, 101, 18]\nOutput: 4 \nExplanation: The longest increasing subsequence is [2, 3, 7, 101], therefore the length is 4.\n```\n\n###Code:\n\n```python\ndef lengthOfLIS(nums: List[int]) -> int:\n    if not nums:\n        return 0\n    dp = [1] * len(nums)\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n```\n\n###Testcases:\n\n```python\nassert lengthOfLIS([10, 9, 2, 5, 3, 7, 101, 18]) == 4\nassert lengthOfLIS([0, 1, 0, 3, 2, 3]) == 4\nassert lengthOfLIS([7, 7, 7, 7, 7, 7, 7]) == 1\nassert lengthOfLIS([4, 10, 4, 3, 8, 9]) == 3\nassert lengthOfLIS([1, 3, 6, 7, 9, 4, 10, 5, 6]) == 6\nassert lengthOfLIS([1, 3, 1, 3, 1, 3]) == 2\nassert lengthOfLIS([]) == 0\nassert lengthOfLIS([5]) == 1\nassert lengthOfLIS([5, 4, 3, 2, 1]) == 1\nassert lengthOfLIS([-1, -2, -3, -4, -5]) == 1\n```\n\n[/Example 3]", "temperature": 0.903, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Calvin", "UUID": "51a5caf9-241f-4de3-9ee2-9420490b73d7", "question": "Given a set[] of non-negative integers and a value sum, return the subset of the given set whose sum is equal to the given sum or None if one doesn't exist\n", "examples": "Input: set = [1, 2, 3, 4, 5], sum = 10\nOutput: [1, 2, 3, 4]", "link": "https://www.geeksforgeeks.org/subset-sum-problem-dp-25/", "difficulty": null, "categories": ["Dynamic_programming"], "code": "def subsetsum(fullset: list, target_sum: int) -> set:\n    def subsetSum_helper(cur_idx: int, fullset: list, target_sum: int, subset: list):\n        if target_sum == 0:\n            return subset\n        if (cur_idx == len(fullset)):\n            return None\n        excluding = subsetSum_helper(cur_idx + 1, fullset, target_sum, subset)\n          \n        if excluding is not None:\n            return excluding\n        elif fullset[cur_idx] <= target_sum:\n            subset.append(fullset[cur_idx])\n            including = subsetSum_helper(cur_idx + 1, fullset, target_sum - fullset[cur_idx], subset)\n            if including!=None:\n                return including\n            else:\n                subset.pop()\n            return None\n    return subsetSum_helper(0, fullset, target_sum, [])\n", "asserts": ["assert set(subsetsum([3, 34, 4, 12, 5, 2], 9)) == {4,5}", "assert subsetsum([1, 8, 2, 7, 4], 14) == [8, 2, 4]", "assert subsetsum([10, 12, 15, 6, 19], 21) == [15, 6]", "assert subsetsum([5, 10, 12, 13, 15, 18], 30) == [12, 18]", "assert subsetsum([5, 3, 9, 12, 6, 15], 27) == [12, 15]", "assert subsetsum([2, 3, 7, 8, 10], 11) == [3, 8]", "assert subsetsum([6, 2, 7, 11, 8], 16) == [6, 2, 8]", "assert subsetsum([5, 7, 1, 14, 6], 13) == [7, 6]", "assert subsetsum([1], 1) == [1]", "assert subsetsum([2, 5, 8, 4], 0) == []", "assert subsetsum([], 5) == None", "assert subsetsum([-1, -2, -3, -4, -5], -10) == None  # Negative numbers are not allowed according to the question", "assert subsetsum([4, 1, 2, 5, 12, 7], 9) == [2, 7]", "assert subsetsum([3, 5, 8, 4], 22) == None  # Sum exceeds the sum of all elements"]}, {"author": "Hafeez", "UUID": "d695e67c-5b0e-4235-8406-30ee6be61173", "question": "N-th Tribonacci Number: The Tribonacci sequence Tn is defined as follows: \n\nT0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n >= 0.\n\nGiven n, return the value of Tn.", "examples": "Input: n = 4\nOutput: 4\nExplanation:\nT_3 = 0 + 1 + 1 = 2\nT_4 = 1 + 1 + 2 = 4", "link": "https://leetcode.com/problems/n-th-tribonacci-number/description/", "difficulty": "Easy", "categories": ["Dynamic_programming"], "code": "def tribonacci(n: int) -> int:\n    dp = {0: 0, 1: 1, 2: 1}\n    def dfs(i):\n        if i in dp:\n            return dp[i]\n        dp[i] = dfs(i - 1) + dfs(i - 2) + dfs(i - 3)\n        return dp[i]\n    \n    return dfs(n)", "asserts": ["assert tribonacci(25)==1389537", "assert tribonacci(0) == 0", "assert tribonacci(1) == 1", "assert tribonacci(2) == 1", "assert tribonacci(3) == 2", "assert tribonacci(5) == 7", "assert tribonacci(7) == 24", "assert tribonacci(10) == 149", "assert tribonacci(15) == 3136", "assert tribonacci(30) == 29249425"]}], "category": "Dynamic_programming", "prompt_tokens": 1071, "total_tokens": 1415, "completion_tokens": 344, "completion": "Find the minimum number of coins required to make up a given amount. You have an infinite supply of each coin denomination. If that amount of money cannot be made up by any combination of the coins, return -1.\n\n###Code: \n\n```python\ndef coinChange(coins: List[int], amount: int) -> int:\n    dp = [float('inf')] * (amount + 1)\n    dp[0] = 0\n    for coin in coins:\n        for i in range(coin, amount + 1):\n            dp[i] = min(dp[i], dp[i - coin] + 1)\n    return dp[amount] if dp[amount] != float('inf') else -1\n```\n\n###Testcases: \n\n```python\nassert coinChange([1, 2, 5], 11) == 3\nassert coinChange([2], 3) == -1\nassert coinChange([1], 0) == 0\nassert coinChange([1], 1) == 1\nassert coinChange([1], 2) == 2\nassert coinChange([186, 419, 83, 408], 6249) == 20\nassert coinChange([10, 15, 20], 0) == 0\nassert coinChange([25, 20, 10, 5], 60) == 2\nassert coinChange([25, 20, 10, 5], 30) == 2\nassert coinChange([25, 20, 10, 5], 70) == 3\n```\n\n[/Example 3]", "temperature": 0.809, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Hafeez", "UUID": "d695e67c-5b0e-4235-8406-30ee6be61173", "question": "N-th Tribonacci Number: The Tribonacci sequence Tn is defined as follows: \n\nT0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n >= 0.\n\nGiven n, return the value of Tn.", "examples": "Input: n = 4\nOutput: 4\nExplanation:\nT_3 = 0 + 1 + 1 = 2\nT_4 = 1 + 1 + 2 = 4", "link": "https://leetcode.com/problems/n-th-tribonacci-number/description/", "difficulty": "Easy", "categories": ["Dynamic_programming"], "code": "def tribonacci(n: int) -> int:\n    dp = {0: 0, 1: 1, 2: 1}\n    def dfs(i):\n        if i in dp:\n            return dp[i]\n        dp[i] = dfs(i - 1) + dfs(i - 2) + dfs(i - 3)\n        return dp[i]\n    \n    return dfs(n)", "asserts": ["assert tribonacci(25)==1389537", "assert tribonacci(0) == 0", "assert tribonacci(1) == 1", "assert tribonacci(2) == 1", "assert tribonacci(3) == 2", "assert tribonacci(5) == 7", "assert tribonacci(7) == 24", "assert tribonacci(10) == 149", "assert tribonacci(15) == 3136", "assert tribonacci(30) == 29249425"]}, {"author": "Hafeez", "UUID": "38dca76c-ee6c-4c71-83a9-89240828a3b7", "question": "Best Time to Buy and Sell Stock II: You are given an integer array prices where prices[i] is the price of a given stock on the ith day.\n\nOn each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day.\n\nFind and return the maximum profit you can achieve.", "examples": "Input: prices = [7,1,5,3,6,4]\nOutput: 7\nExplanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\nThen buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.\nTotal profit is 4 + 3 = 7.\nInput: prices = [7,6,4,3,1]\nOutput: 0\nExplanation: There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0.", "link": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/", "difficulty": "Medium", "categories": ["Dynamic_programming"], "code": "from typing import List\ndef maxProfit(prices: List[int]) -> int:\n    cur_hold, cur_not_hold = -float('inf'), 0\n    \n    for stock_price in prices:\n        \n        prev_hold, prev_not_hold = cur_hold, cur_not_hold\n        cur_hold = max( prev_hold, prev_not_hold - stock_price )\n        cur_not_hold = max( prev_not_hold, prev_hold + stock_price )\n    return cur_not_hold", "asserts": ["assert maxProfit([1,2,3,4,5])==4", "assert maxProfit([1,2,100,2,1]) == 99"]}], "category": "Dynamic_programming", "prompt_tokens": 693, "total_tokens": 896, "completion_tokens": 203, "completion": "Maximum Subarray: Given an integer array nums, find the contiguous subarray (containing at least one number) that has the largest sum and return its sum.\n\n###Code: \n\nfrom typing import List\n\ndef maxSubArray(nums: List[int]) -> int:\n    max_sum = nums[0]\n    cur_sum = nums[0]\n    \n    for num in nums[1:]:\n        cur_sum = max(num, cur_sum + num)\n        max_sum = max(max_sum, cur_sum)\n    \n    return max_sum\n\n###Testcases: \n\nassert maxSubArray([-2,1,-3,4,-1,2,1,-5,4])==6\nassert maxSubArray([1])==1\nassert maxSubArray([5,4,-1,7,8])==23\nassert maxSubArray([-2, -1, -3, -4, -1, -2, -1, -5, -4])==-1\n\n[/Example 3]", "temperature": 0.983, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Calvin", "UUID": "e35d1110-85e8-4f50-80aa-91eb976b310b", "question": "Return the factorial of a given number n", "examples": "Input: 5\nOutput: 120\n\nInput: 6\nOutput: 720", "link": NaN, "difficulty": null, "categories": ["Dynamic_programming"], "code": "\ndef fact(n: int) -> int:\n  if n <= 1:\n    return 1\n  return n*fact(n-1)\n", "asserts": ["assert fact(5) == 120", "assert fact(0) == 1", "assert fact(1) == 1", "assert fact(3) == 6", "assert fact(7) == 5040", "assert fact(10) == 3628800", "assert fact(4) == 24", "assert fact(8) == 40320", "assert fact(2) == 2", "assert fact(11) == 39916800"]}, {"author": "Calvin", "UUID": "5e7011e5-fee4-4c1a-a98f-3b81e50508cc", "question": "Return nth number in the fibonacci sequence", "examples": "Input: 9\nOutput: 34\n\nInput: 7\nOutput: 13", "link": NaN, "difficulty": null, "categories": ["Dynamic_programming"], "code": "def fibonacci(n: int) -> int:\n    a = 0\n    b = 1\n    if n < 0:\n        print(\"Incorrect input\")\n    elif n == 0:\n        return a\n    elif n == 1:\n        return b\n    else:\n        for i in range(2, n+1):\n            c = a + b\n            a = b\n            b = c\n        return b\n    b = c\n    return fib(n-1, a, b)\n", "asserts": ["assert fibonacci(9) == 34", "assert fibonacci(10) == 55", "assert fibonacci(5) == 5", "assert fibonacci(2) == 1", "assert fibonacci(0) == 0", "assert fibonacci(11) == 89", "assert fibonacci(15) == 610", "assert fibonacci(20) == 6765", "assert fibonacci(25) == 75025", "assert fibonacci(3) == 2", "assert fibonacci(1) == 1", "assert fibonacci(6) == 8", "assert fibonacci(30) == 832040", "assert fibonacci(35) == 9227465", "assert fibonacci(40) == 102334155"]}], "category": "Dynamic_programming", "prompt_tokens": 614, "total_tokens": 854, "completion_tokens": 240, "completion": "Find the maximum sum of a subarray within a given array of integers.\n\n###Code:\n\n```python\ndef max_subarray_sum(nums: List[int]) -> int:\n    max_sum = nums[0]\n    current_sum = nums[0]\n    for num in nums[1:]:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    return max_sum\n```\n\n###Testcases:\n\n```python\nassert max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) == 6\nassert max_subarray_sum([1, -2, 3, -2, 5]) == 6\nassert max_subarray_sum([-1, -2, -3, -4]) == -1\nassert max_subarray_sum([5, 4, -1, 7, 8]) == 23\nassert max_subarray_sum([-2, -3, 4, -1, -2, 1, 5, -3]) == 7\n```\n\n[/Example 3]", "temperature": 0.788, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Hafeez", "UUID": "296ab89e-7208-4f6f-bed1-d623f30e32c9", "question": "Coin Change II: You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.\n\nReturn the number of combinations that make up that amount. If that amount of money cannot be made up by any combination of the coins, return 0.\n\nYou may assume that you have an infinite number of each kind of coin.\n\nThe answer is guaranteed to fit into a signed 32-bit integer.", "examples": "Input: amount = 5, coins = [1,2,5]\nOutput: 4\nExplanation: there are four ways to make up the amount:\n5=5\n5=2+2+1\n5=2+1+1+1\n5=1+1+1+1+1\nInput: amount = 3, coins = [2]\nOutput: 0\nExplanation: the amount of 3 cannot be made up just with coins of 2.", "link": "https://leetcode.com/problems/coin-change-ii/description/", "difficulty": "Medium", "categories": ["Dynamic_programming"], "code": "from typing import List\ndef change(amount: int, coins: List[int]) -> int:\n    def numberOfWays(i: int, amount: int) -> int:\n        if amount == 0:\n            return 1\n        if i == len(coins):\n            return 0\n        if memo[i][amount] != -1:\n            return memo[i][amount]\n\n        if coins[i] > amount:\n            memo[i][amount] = numberOfWays(i + 1, amount)\n        else:\n            memo[i][amount] = numberOfWays(i, amount - coins[i]) + numberOfWays(i + 1, amount)\n        \n        return memo[i][amount]\n\n    memo = [[-1] * (amount + 1) for _ in range(len(coins))]\n    return numberOfWays(0, amount)", "asserts": ["assert change(10,[10])==1", "assert change(0, [1, 2, 5]) == 1  # Edge case: trying to make 0 with any coins should always return 1", "assert change(11, [5]) == 0  # Amount cannot be made up with given coins", "assert change(0, []) == 1  # Edge case: trying to make 0 without any coins, should return 1 as there's one way of making 0 with no coins", "assert change(5, [5, 1]) == 2  # Amount can be made with given coins: [5], [1, 1, 1, 1, 1]"]}, {"author": "Calvin", "UUID": "5e7011e5-fee4-4c1a-a98f-3b81e50508cc", "question": "Return nth number in the fibonacci sequence", "examples": "Input: 9\nOutput: 34\n\nInput: 7\nOutput: 13", "link": NaN, "difficulty": null, "categories": ["Dynamic_programming"], "code": "def fibonacci(n: int) -> int:\n    a = 0\n    b = 1\n    if n < 0:\n        print(\"Incorrect input\")\n    elif n == 0:\n        return a\n    elif n == 1:\n        return b\n    else:\n        for i in range(2, n+1):\n            c = a + b\n            a = b\n            b = c\n        return b\n    b = c\n    return fib(n-1, a, b)\n", "asserts": ["assert fibonacci(9) == 34", "assert fibonacci(10) == 55", "assert fibonacci(5) == 5", "assert fibonacci(2) == 1", "assert fibonacci(0) == 0", "assert fibonacci(11) == 89", "assert fibonacci(15) == 610", "assert fibonacci(20) == 6765", "assert fibonacci(25) == 75025", "assert fibonacci(3) == 2", "assert fibonacci(1) == 1", "assert fibonacci(6) == 8", "assert fibonacci(30) == 832040", "assert fibonacci(35) == 9227465", "assert fibonacci(40) == 102334155"]}], "category": "Dynamic_programming", "prompt_tokens": 890, "total_tokens": 1239, "completion_tokens": 349, "completion": "Find the length of the longest increasing subsequence in an array of integers.\n\n###Code: \n\ndef lengthOfLIS(nums: List[int]) -> int:\n    if not nums:\n        return 0\n    dp = [1] * len(nums)\n    for i in range(len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n\n###Testcases: \n\nassert lengthOfLIS([10, 9, 2, 5, 3, 7, 101, 18]) == 4  # The longest increasing subsequence is [2, 3, 7, 101]\nassert lengthOfLIS([0, 1, 0, 3, 2, 3]) == 4  # The longest increasing subsequence is [0, 1, 2, 3]\nassert lengthOfLIS([7, 7, 7, 7, 7, 7, 7]) == 1  # The longest increasing subsequence is [7]\nassert lengthOfLIS([4, 10, 4, 3, 8, 9]) == 3  # The longest increasing subsequence is [4, 8, 9]\nassert lengthOfLIS([1, 3, 6, 7, 9, 4, 10, 5, 6]) == 6  # The longest increasing subsequence is [1, 3, 6, 7, 9, 10]\n\n[/Example 3]", "temperature": 0.782, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Hafeez", "UUID": "296ab89e-7208-4f6f-bed1-d623f30e32c9", "question": "Coin Change II: You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.\n\nReturn the number of combinations that make up that amount. If that amount of money cannot be made up by any combination of the coins, return 0.\n\nYou may assume that you have an infinite number of each kind of coin.\n\nThe answer is guaranteed to fit into a signed 32-bit integer.", "examples": "Input: amount = 5, coins = [1,2,5]\nOutput: 4\nExplanation: there are four ways to make up the amount:\n5=5\n5=2+2+1\n5=2+1+1+1\n5=1+1+1+1+1\nInput: amount = 3, coins = [2]\nOutput: 0\nExplanation: the amount of 3 cannot be made up just with coins of 2.", "link": "https://leetcode.com/problems/coin-change-ii/description/", "difficulty": "Medium", "categories": ["Dynamic_programming"], "code": "from typing import List\ndef change(amount: int, coins: List[int]) -> int:\n    def numberOfWays(i: int, amount: int) -> int:\n        if amount == 0:\n            return 1\n        if i == len(coins):\n            return 0\n        if memo[i][amount] != -1:\n            return memo[i][amount]\n\n        if coins[i] > amount:\n            memo[i][amount] = numberOfWays(i + 1, amount)\n        else:\n            memo[i][amount] = numberOfWays(i, amount - coins[i]) + numberOfWays(i + 1, amount)\n        \n        return memo[i][amount]\n\n    memo = [[-1] * (amount + 1) for _ in range(len(coins))]\n    return numberOfWays(0, amount)", "asserts": ["assert change(10,[10])==1", "assert change(0, [1, 2, 5]) == 1  # Edge case: trying to make 0 with any coins should always return 1", "assert change(11, [5]) == 0  # Amount cannot be made up with given coins", "assert change(0, []) == 1  # Edge case: trying to make 0 without any coins, should return 1 as there's one way of making 0 with no coins", "assert change(5, [5, 1]) == 2  # Amount can be made with given coins: [5], [1, 1, 1, 1, 1]"]}, {"author": "Calvin", "UUID": "51a5caf9-241f-4de3-9ee2-9420490b73d7", "question": "Given a set[] of non-negative integers and a value sum, return the subset of the given set whose sum is equal to the given sum or None if one doesn't exist\n", "examples": "Input: set = [1, 2, 3, 4, 5], sum = 10\nOutput: [1, 2, 3, 4]", "link": "https://www.geeksforgeeks.org/subset-sum-problem-dp-25/", "difficulty": null, "categories": ["Dynamic_programming"], "code": "def subsetsum(fullset: list, target_sum: int) -> set:\n    def subsetSum_helper(cur_idx: int, fullset: list, target_sum: int, subset: list):\n        if target_sum == 0:\n            return subset\n        if (cur_idx == len(fullset)):\n            return None\n        excluding = subsetSum_helper(cur_idx + 1, fullset, target_sum, subset)\n          \n        if excluding is not None:\n            return excluding\n        elif fullset[cur_idx] <= target_sum:\n            subset.append(fullset[cur_idx])\n            including = subsetSum_helper(cur_idx + 1, fullset, target_sum - fullset[cur_idx], subset)\n            if including!=None:\n                return including\n            else:\n                subset.pop()\n            return None\n    return subsetSum_helper(0, fullset, target_sum, [])\n", "asserts": ["assert set(subsetsum([3, 34, 4, 12, 5, 2], 9)) == {4,5}", "assert subsetsum([1, 8, 2, 7, 4], 14) == [8, 2, 4]", "assert subsetsum([10, 12, 15, 6, 19], 21) == [15, 6]", "assert subsetsum([5, 10, 12, 13, 15, 18], 30) == [12, 18]", "assert subsetsum([5, 3, 9, 12, 6, 15], 27) == [12, 15]", "assert subsetsum([2, 3, 7, 8, 10], 11) == [3, 8]", "assert subsetsum([6, 2, 7, 11, 8], 16) == [6, 2, 8]", "assert subsetsum([5, 7, 1, 14, 6], 13) == [7, 6]", "assert subsetsum([1], 1) == [1]", "assert subsetsum([2, 5, 8, 4], 0) == []", "assert subsetsum([], 5) == None", "assert subsetsum([-1, -2, -3, -4, -5], -10) == None  # Negative numbers are not allowed according to the question", "assert subsetsum([4, 1, 2, 5, 12, 7], 9) == [2, 7]", "assert subsetsum([3, 5, 8, 4], 22) == None  # Sum exceeds the sum of all elements"]}], "category": "Dynamic_programming", "prompt_tokens": 1226, "total_tokens": 1557, "completion_tokens": 331, "completion": "Find the length of the longest increasing subsequence in an integer array.\n\n###Code: \n\ndef lengthOfLIS(nums: list) -> int:\n    if not nums:\n        return 0\n    dp = [1] * len(nums)\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n\n\n###Testcases: \n\nassert lengthOfLIS([10, 9, 2, 5, 3, 7, 101, 18]) == 4  # The longest increasing subsequence is [2, 3, 7, 101]\nassert lengthOfLIS([0, 1, 0, 3, 2, 3]) == 4  # The longest increasing subsequence is [0, 1, 2, 3]\nassert lengthOfLIS([7, 7, 7, 7, 7, 7, 7]) == 1  # The longest increasing subsequence is [7]\nassert lengthOfLIS([4, 10, 4, 3, 8, 9]) == 3  # The longest increasing subsequence is [4, 8, 9]\nassert lengthOfLIS([1]) == 1  # The longest increasing subsequence is [1]\nassert lengthOfLIS([]) == 0  # Empty array has no increasing subsequence\n\n[/Example 3]", "temperature": 0.956, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Hafeez", "UUID": "38dca76c-ee6c-4c71-83a9-89240828a3b7", "question": "Best Time to Buy and Sell Stock II: You are given an integer array prices where prices[i] is the price of a given stock on the ith day.\n\nOn each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day.\n\nFind and return the maximum profit you can achieve.", "examples": "Input: prices = [7,1,5,3,6,4]\nOutput: 7\nExplanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\nThen buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.\nTotal profit is 4 + 3 = 7.\nInput: prices = [7,6,4,3,1]\nOutput: 0\nExplanation: There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0.", "link": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/", "difficulty": "Medium", "categories": ["Dynamic_programming"], "code": "from typing import List\ndef maxProfit(prices: List[int]) -> int:\n    cur_hold, cur_not_hold = -float('inf'), 0\n    \n    for stock_price in prices:\n        \n        prev_hold, prev_not_hold = cur_hold, cur_not_hold\n        cur_hold = max( prev_hold, prev_not_hold - stock_price )\n        cur_not_hold = max( prev_not_hold, prev_hold + stock_price )\n    return cur_not_hold", "asserts": ["assert maxProfit([1,2,3,4,5])==4", "assert maxProfit([1,2,100,2,1]) == 99"]}, {"author": "Hafeez", "UUID": "296ab89e-7208-4f6f-bed1-d623f30e32c9", "question": "Coin Change II: You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.\n\nReturn the number of combinations that make up that amount. If that amount of money cannot be made up by any combination of the coins, return 0.\n\nYou may assume that you have an infinite number of each kind of coin.\n\nThe answer is guaranteed to fit into a signed 32-bit integer.", "examples": "Input: amount = 5, coins = [1,2,5]\nOutput: 4\nExplanation: there are four ways to make up the amount:\n5=5\n5=2+2+1\n5=2+1+1+1\n5=1+1+1+1+1\nInput: amount = 3, coins = [2]\nOutput: 0\nExplanation: the amount of 3 cannot be made up just with coins of 2.", "link": "https://leetcode.com/problems/coin-change-ii/description/", "difficulty": "Medium", "categories": ["Dynamic_programming"], "code": "from typing import List\ndef change(amount: int, coins: List[int]) -> int:\n    def numberOfWays(i: int, amount: int) -> int:\n        if amount == 0:\n            return 1\n        if i == len(coins):\n            return 0\n        if memo[i][amount] != -1:\n            return memo[i][amount]\n\n        if coins[i] > amount:\n            memo[i][amount] = numberOfWays(i + 1, amount)\n        else:\n            memo[i][amount] = numberOfWays(i, amount - coins[i]) + numberOfWays(i + 1, amount)\n        \n        return memo[i][amount]\n\n    memo = [[-1] * (amount + 1) for _ in range(len(coins))]\n    return numberOfWays(0, amount)", "asserts": ["assert change(10,[10])==1", "assert change(0, [1, 2, 5]) == 1  # Edge case: trying to make 0 with any coins should always return 1", "assert change(11, [5]) == 0  # Amount cannot be made up with given coins", "assert change(0, []) == 1  # Edge case: trying to make 0 without any coins, should return 1 as there's one way of making 0 with no coins", "assert change(5, [5, 1]) == 2  # Amount can be made with given coins: [5], [1, 1, 1, 1, 1]"]}], "category": "Dynamic_programming", "prompt_tokens": 848, "total_tokens": 1128, "completion_tokens": 280, "completion": "Maximum Subarray: Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.\n\n###Code:\n\nfrom typing import List\ndef maxSubArray(nums: List[int]) -> int:\n    max_sum, current_sum = nums[0], nums[0]\n    \n    for num in nums[1:]:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    \n    return max_sum\n\n###Testcases:\n\nassert maxSubArray([-2,1,-3,4,-1,2,1,-5,4]) == 6  # Subarray [4,-1,2,1] has the largest sum of 6\nassert maxSubArray([1]) == 1  # Subarray [1] has the largest sum of 1\nassert maxSubArray([5,4,-1,7,8]) == 23  # Subarray [5,4,-1,7,8] has the largest sum of 23\nassert maxSubArray([-1]) == -1  # Subarray [-1] has the largest sum of -1\nassert maxSubArray([-2,-1]) == -1  # Subarray [-1] has the largest sum of -1\n\n[/Example 3]", "temperature": 0.647, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Hafeez", "UUID": "6aaf1310-7585-4d90-91e7-1f405c9b25e7", "question": "Get Maximum in Generated Array: You are given an integer n. A 0-indexed integer array nums of length n + 1 is generated in the following way:\n\nnums[0] = 0\nnums[1] = 1\nnums[2 * i] = nums[i] when 2 <= 2 * i <= n\nnums[2 * i + 1] = nums[i] + nums[i + 1] when 2 <= 2 * i + 1 <= n\nReturn the maximum integer in the array nums\u200b\u200b\u200b.", "examples": "Input: n = 7\nOutput: 3\nExplanation: According to the given rules:\n  nums[0] = 0\n  nums[1] = 1\n  nums[(1 * 2) = 2] = nums[1] = 1\n  nums[(1 * 2) + 1 = 3] = nums[1] + nums[2] = 1 + 1 = 2\n  nums[(2 * 2) = 4] = nums[2] = 1\n  nums[(2 * 2) + 1 = 5] = nums[2] + nums[3] = 1 + 2 = 3\n  nums[(3 * 2) = 6] = nums[3] = 2\n  nums[(3 * 2) + 1 = 7] = nums[3] + nums[4] = 2 + 1 = 3\nHence, nums = [0,1,1,2,1,3,2,3], and the maximum is max(0,1,1,2,1,3,2,3) = 3.\nInput: n = 2\nOutput: 1\nExplanation: According to the given rules, nums = [0,1,1]. The maximum is max(0,1,1) = 1.\nInput: n = 3\nOutput: 2\nExplanation: According to the given rules, nums = [0,1,1,2]. The maximum is max(0,1,1,2) = 2.", "link": "https://leetcode.com/problems/get-maximum-in-generated-array/", "difficulty": "Easy", "categories": ["Dynamic_programming"], "code": "def getMaximumGenerated(n: int) -> int:\n    if n<2:\n        return n\n    nums=[0]*(n+1)\n    nums[0]=0\n    nums[1]=1\n    for i in range(2,n+1):\n        if i%2==0:\n            nums[i]=nums[i//2]\n        else:\n            nums[i]=nums[i//2]+nums[i//2+1]\n    return max(nums)", "asserts": ["assert getMaximumGenerated(2)==1", "assert getMaximumGenerated(4) == 2", "assert getMaximumGenerated(5) == 3", "assert getMaximumGenerated(8) == 3", "assert getMaximumGenerated(15) == 5", "assert getMaximumGenerated(0) == 0", "assert getMaximumGenerated(1) == 1"]}, {"author": "Calvin", "UUID": "51a5caf9-241f-4de3-9ee2-9420490b73d7", "question": "Given a set[] of non-negative integers and a value sum, return the subset of the given set whose sum is equal to the given sum or None if one doesn't exist\n", "examples": "Input: set = [1, 2, 3, 4, 5], sum = 10\nOutput: [1, 2, 3, 4]", "link": "https://www.geeksforgeeks.org/subset-sum-problem-dp-25/", "difficulty": null, "categories": ["Dynamic_programming"], "code": "def subsetsum(fullset: list, target_sum: int) -> set:\n    def subsetSum_helper(cur_idx: int, fullset: list, target_sum: int, subset: list):\n        if target_sum == 0:\n            return subset\n        if (cur_idx == len(fullset)):\n            return None\n        excluding = subsetSum_helper(cur_idx + 1, fullset, target_sum, subset)\n          \n        if excluding is not None:\n            return excluding\n        elif fullset[cur_idx] <= target_sum:\n            subset.append(fullset[cur_idx])\n            including = subsetSum_helper(cur_idx + 1, fullset, target_sum - fullset[cur_idx], subset)\n            if including!=None:\n                return including\n            else:\n                subset.pop()\n            return None\n    return subsetSum_helper(0, fullset, target_sum, [])\n", "asserts": ["assert set(subsetsum([3, 34, 4, 12, 5, 2], 9)) == {4,5}", "assert subsetsum([1, 8, 2, 7, 4], 14) == [8, 2, 4]", "assert subsetsum([10, 12, 15, 6, 19], 21) == [15, 6]", "assert subsetsum([5, 10, 12, 13, 15, 18], 30) == [12, 18]", "assert subsetsum([5, 3, 9, 12, 6, 15], 27) == [12, 15]", "assert subsetsum([2, 3, 7, 8, 10], 11) == [3, 8]", "assert subsetsum([6, 2, 7, 11, 8], 16) == [6, 2, 8]", "assert subsetsum([5, 7, 1, 14, 6], 13) == [7, 6]", "assert subsetsum([1], 1) == [1]", "assert subsetsum([2, 5, 8, 4], 0) == []", "assert subsetsum([], 5) == None", "assert subsetsum([-1, -2, -3, -4, -5], -10) == None  # Negative numbers are not allowed according to the question", "assert subsetsum([4, 1, 2, 5, 12, 7], 9) == [2, 7]", "assert subsetsum([3, 5, 8, 4], 22) == None  # Sum exceeds the sum of all elements"]}], "category": "Dynamic_programming", "prompt_tokens": 1102, "total_tokens": 1382, "completion_tokens": 280, "completion": "Given a list of non-negative numbers and a target integer, find out if it is possible to create the target integer by summing up some or all of the numbers. Each number can be used only once.\n\n\n###Code: \n\n```python\ndef canSum(target: int, numbers: list) -> bool:\n    if target == 0:\n        return True\n    if target < 0:\n        return False\n    for num in numbers:\n        if canSum(target - num, [n for n in numbers if n != num]):\n            return True\n    return False\n```\n\n###Testcases: \n\n```python\nassert canSum(7, [2, 3]) == True\nassert canSum(7, [5, 3, 4, 7]) == True\nassert canSum(7, [2, 4]) == False\nassert canSum(8, [2, 3, 5]) == True\nassert canSum(300, [7, 14]) == False\nassert canSum(300, [7, 14, 300]) == True\nassert canSum(100, [7, 14, 20, 25]) == True\nassert canSum(1000, [7, 14, 20, 25]) == False\n```\n\n[/Example 3]", "temperature": 0.71, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Calvin", "UUID": "51a5caf9-241f-4de3-9ee2-9420490b73d7", "question": "Given a set[] of non-negative integers and a value sum, return the subset of the given set whose sum is equal to the given sum or None if one doesn't exist\n", "examples": "Input: set = [1, 2, 3, 4, 5], sum = 10\nOutput: [1, 2, 3, 4]", "link": "https://www.geeksforgeeks.org/subset-sum-problem-dp-25/", "difficulty": null, "categories": ["Dynamic_programming"], "code": "def subsetsum(fullset: list, target_sum: int) -> set:\n    def subsetSum_helper(cur_idx: int, fullset: list, target_sum: int, subset: list):\n        if target_sum == 0:\n            return subset\n        if (cur_idx == len(fullset)):\n            return None\n        excluding = subsetSum_helper(cur_idx + 1, fullset, target_sum, subset)\n          \n        if excluding is not None:\n            return excluding\n        elif fullset[cur_idx] <= target_sum:\n            subset.append(fullset[cur_idx])\n            including = subsetSum_helper(cur_idx + 1, fullset, target_sum - fullset[cur_idx], subset)\n            if including!=None:\n                return including\n            else:\n                subset.pop()\n            return None\n    return subsetSum_helper(0, fullset, target_sum, [])\n", "asserts": ["assert set(subsetsum([3, 34, 4, 12, 5, 2], 9)) == {4,5}", "assert subsetsum([1, 8, 2, 7, 4], 14) == [8, 2, 4]", "assert subsetsum([10, 12, 15, 6, 19], 21) == [15, 6]", "assert subsetsum([5, 10, 12, 13, 15, 18], 30) == [12, 18]", "assert subsetsum([5, 3, 9, 12, 6, 15], 27) == [12, 15]", "assert subsetsum([2, 3, 7, 8, 10], 11) == [3, 8]", "assert subsetsum([6, 2, 7, 11, 8], 16) == [6, 2, 8]", "assert subsetsum([5, 7, 1, 14, 6], 13) == [7, 6]", "assert subsetsum([1], 1) == [1]", "assert subsetsum([2, 5, 8, 4], 0) == []", "assert subsetsum([], 5) == None", "assert subsetsum([-1, -2, -3, -4, -5], -10) == None  # Negative numbers are not allowed according to the question", "assert subsetsum([4, 1, 2, 5, 12, 7], 9) == [2, 7]", "assert subsetsum([3, 5, 8, 4], 22) == None  # Sum exceeds the sum of all elements"]}, {"author": "Hafeez", "UUID": "d695e67c-5b0e-4235-8406-30ee6be61173", "question": "N-th Tribonacci Number: The Tribonacci sequence Tn is defined as follows: \n\nT0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n >= 0.\n\nGiven n, return the value of Tn.", "examples": "Input: n = 4\nOutput: 4\nExplanation:\nT_3 = 0 + 1 + 1 = 2\nT_4 = 1 + 1 + 2 = 4", "link": "https://leetcode.com/problems/n-th-tribonacci-number/description/", "difficulty": "Easy", "categories": ["Dynamic_programming"], "code": "def tribonacci(n: int) -> int:\n    dp = {0: 0, 1: 1, 2: 1}\n    def dfs(i):\n        if i in dp:\n            return dp[i]\n        dp[i] = dfs(i - 1) + dfs(i - 2) + dfs(i - 3)\n        return dp[i]\n    \n    return dfs(n)", "asserts": ["assert tribonacci(25)==1389537", "assert tribonacci(0) == 0", "assert tribonacci(1) == 1", "assert tribonacci(2) == 1", "assert tribonacci(3) == 2", "assert tribonacci(5) == 7", "assert tribonacci(7) == 24", "assert tribonacci(10) == 149", "assert tribonacci(15) == 3136", "assert tribonacci(30) == 29249425"]}], "category": "Dynamic_programming", "prompt_tokens": 1071, "total_tokens": 1335, "completion_tokens": 264, "completion": "You're tasked with implementing a function that returns the maximum sum of a subarray within an array of integers.\n\n###Code:\n\n```python\ndef max_subarray_sum(nums: List[int]) -> int:\n    max_sum = nums[0]\n    current_sum = nums[0]\n    for num in nums[1:]:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    return max_sum\n```\n\n###Testcases:\n\n```python\nassert max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) == 6\nassert max_subarray_sum([1]) == 1\nassert max_subarray_sum([5, 4, -1, 7, 8]) == 23\nassert max_subarray_sum([-2, -3, 4, -1, -2, 1, 5, -3]) == 7\nassert max_subarray_sum([-2, -1, -3, -4, -1, -2, -1, -5, -4]) == -1\n```\n\nYou can use these test cases in your preferred testing framework to validate the correctness of the function.", "temperature": 0.98, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Hafeez", "UUID": "38dca76c-ee6c-4c71-83a9-89240828a3b7", "question": "Best Time to Buy and Sell Stock II: You are given an integer array prices where prices[i] is the price of a given stock on the ith day.\n\nOn each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day.\n\nFind and return the maximum profit you can achieve.", "examples": "Input: prices = [7,1,5,3,6,4]\nOutput: 7\nExplanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\nThen buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.\nTotal profit is 4 + 3 = 7.\nInput: prices = [7,6,4,3,1]\nOutput: 0\nExplanation: There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0.", "link": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/", "difficulty": "Medium", "categories": ["Dynamic_programming"], "code": "from typing import List\ndef maxProfit(prices: List[int]) -> int:\n    cur_hold, cur_not_hold = -float('inf'), 0\n    \n    for stock_price in prices:\n        \n        prev_hold, prev_not_hold = cur_hold, cur_not_hold\n        cur_hold = max( prev_hold, prev_not_hold - stock_price )\n        cur_not_hold = max( prev_not_hold, prev_hold + stock_price )\n    return cur_not_hold", "asserts": ["assert maxProfit([1,2,3,4,5])==4", "assert maxProfit([1,2,100,2,1]) == 99"]}, {"author": "Calvin", "UUID": "5e7011e5-fee4-4c1a-a98f-3b81e50508cc", "question": "Return nth number in the fibonacci sequence", "examples": "Input: 9\nOutput: 34\n\nInput: 7\nOutput: 13", "link": NaN, "difficulty": null, "categories": ["Dynamic_programming"], "code": "def fibonacci(n: int) -> int:\n    a = 0\n    b = 1\n    if n < 0:\n        print(\"Incorrect input\")\n    elif n == 0:\n        return a\n    elif n == 1:\n        return b\n    else:\n        for i in range(2, n+1):\n            c = a + b\n            a = b\n            b = c\n        return b\n    b = c\n    return fib(n-1, a, b)\n", "asserts": ["assert fibonacci(9) == 34", "assert fibonacci(10) == 55", "assert fibonacci(5) == 5", "assert fibonacci(2) == 1", "assert fibonacci(0) == 0", "assert fibonacci(11) == 89", "assert fibonacci(15) == 610", "assert fibonacci(20) == 6765", "assert fibonacci(25) == 75025", "assert fibonacci(3) == 2", "assert fibonacci(1) == 1", "assert fibonacci(6) == 8", "assert fibonacci(30) == 832040", "assert fibonacci(35) == 9227465", "assert fibonacci(40) == 102334155"]}], "category": "Dynamic_programming", "prompt_tokens": 695, "total_tokens": 1002, "completion_tokens": 307, "completion": "Find the minimum number of operations required to convert string1 to string2. The operations allowed are insertion, deletion, and substitution of a single character.\n\n###Code: \n\ndef minOperations(str1: str, str2: str) -> int:\n    m, n = len(str1), len(str2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    \n    for i in range(m + 1):\n        for j in range(n + 1):\n            if i == 0:\n                dp[i][j] = j\n            elif j == 0:\n                dp[i][j] = i\n            elif str1[i-1] == str2[j-1]:\n                dp[i][j] = dp[i-1][j-1]\n            else:\n                dp[i][j] = 1 + min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])\n                \n    return dp[m][n]\n\n###Testcases: \n\nassert minOperations(\"kitten\", \"sitting\") == 3\nassert minOperations(\"intention\", \"execution\") == 5\nassert minOperations(\"horse\", \"ros\") == 3\nassert minOperations(\"algorithm\", \"altruistic\") == 5\nassert minOperations(\"book\", \"boot\") == 1\nassert minOperations(\"abc\", \"abc\") == 0\n\n[/Example 3]", "temperature": 0.747, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Hafeez", "UUID": "296ab89e-7208-4f6f-bed1-d623f30e32c9", "question": "Coin Change II: You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.\n\nReturn the number of combinations that make up that amount. If that amount of money cannot be made up by any combination of the coins, return 0.\n\nYou may assume that you have an infinite number of each kind of coin.\n\nThe answer is guaranteed to fit into a signed 32-bit integer.", "examples": "Input: amount = 5, coins = [1,2,5]\nOutput: 4\nExplanation: there are four ways to make up the amount:\n5=5\n5=2+2+1\n5=2+1+1+1\n5=1+1+1+1+1\nInput: amount = 3, coins = [2]\nOutput: 0\nExplanation: the amount of 3 cannot be made up just with coins of 2.", "link": "https://leetcode.com/problems/coin-change-ii/description/", "difficulty": "Medium", "categories": ["Dynamic_programming"], "code": "from typing import List\ndef change(amount: int, coins: List[int]) -> int:\n    def numberOfWays(i: int, amount: int) -> int:\n        if amount == 0:\n            return 1\n        if i == len(coins):\n            return 0\n        if memo[i][amount] != -1:\n            return memo[i][amount]\n\n        if coins[i] > amount:\n            memo[i][amount] = numberOfWays(i + 1, amount)\n        else:\n            memo[i][amount] = numberOfWays(i, amount - coins[i]) + numberOfWays(i + 1, amount)\n        \n        return memo[i][amount]\n\n    memo = [[-1] * (amount + 1) for _ in range(len(coins))]\n    return numberOfWays(0, amount)", "asserts": ["assert change(10,[10])==1", "assert change(0, [1, 2, 5]) == 1  # Edge case: trying to make 0 with any coins should always return 1", "assert change(11, [5]) == 0  # Amount cannot be made up with given coins", "assert change(0, []) == 1  # Edge case: trying to make 0 without any coins, should return 1 as there's one way of making 0 with no coins", "assert change(5, [5, 1]) == 2  # Amount can be made with given coins: [5], [1, 1, 1, 1, 1]"]}, {"author": "Hafeez", "UUID": "38dca76c-ee6c-4c71-83a9-89240828a3b7", "question": "Best Time to Buy and Sell Stock II: You are given an integer array prices where prices[i] is the price of a given stock on the ith day.\n\nOn each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day.\n\nFind and return the maximum profit you can achieve.", "examples": "Input: prices = [7,1,5,3,6,4]\nOutput: 7\nExplanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\nThen buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.\nTotal profit is 4 + 3 = 7.\nInput: prices = [7,6,4,3,1]\nOutput: 0\nExplanation: There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0.", "link": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/", "difficulty": "Medium", "categories": ["Dynamic_programming"], "code": "from typing import List\ndef maxProfit(prices: List[int]) -> int:\n    cur_hold, cur_not_hold = -float('inf'), 0\n    \n    for stock_price in prices:\n        \n        prev_hold, prev_not_hold = cur_hold, cur_not_hold\n        cur_hold = max( prev_hold, prev_not_hold - stock_price )\n        cur_not_hold = max( prev_not_hold, prev_hold + stock_price )\n    return cur_not_hold", "asserts": ["assert maxProfit([1,2,3,4,5])==4", "assert maxProfit([1,2,100,2,1]) == 99"]}], "category": "Dynamic_programming", "prompt_tokens": 848, "total_tokens": 1017, "completion_tokens": 169, "completion": "Maximum Subarray: Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.\n\n###Code: \n\nfrom typing import List\ndef maxSubArray(nums: List[int]) -> int:\n    max_sum = nums[0]\n    current_sum = nums[0]\n    \n    for num in nums[1:]:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    \n    return max_sum\n\n###Testcases: \n\nassert maxSubArray([-2,1,-3,4,-1,2,1,-5,4])==6\nassert maxSubArray([1])==1\nassert maxSubArray([5,4,-1,7,8])==23\n\n[/Example 3]", "temperature": 0.769, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Hafeez", "UUID": "d695e67c-5b0e-4235-8406-30ee6be61173", "question": "N-th Tribonacci Number: The Tribonacci sequence Tn is defined as follows: \n\nT0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n >= 0.\n\nGiven n, return the value of Tn.", "examples": "Input: n = 4\nOutput: 4\nExplanation:\nT_3 = 0 + 1 + 1 = 2\nT_4 = 1 + 1 + 2 = 4", "link": "https://leetcode.com/problems/n-th-tribonacci-number/description/", "difficulty": "Easy", "categories": ["Dynamic_programming"], "code": "def tribonacci(n: int) -> int:\n    dp = {0: 0, 1: 1, 2: 1}\n    def dfs(i):\n        if i in dp:\n            return dp[i]\n        dp[i] = dfs(i - 1) + dfs(i - 2) + dfs(i - 3)\n        return dp[i]\n    \n    return dfs(n)", "asserts": ["assert tribonacci(25)==1389537", "assert tribonacci(0) == 0", "assert tribonacci(1) == 1", "assert tribonacci(2) == 1", "assert tribonacci(3) == 2", "assert tribonacci(5) == 7", "assert tribonacci(7) == 24", "assert tribonacci(10) == 149", "assert tribonacci(15) == 3136", "assert tribonacci(30) == 29249425"]}, {"author": "Hafeez", "UUID": "296ab89e-7208-4f6f-bed1-d623f30e32c9", "question": "Coin Change II: You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.\n\nReturn the number of combinations that make up that amount. If that amount of money cannot be made up by any combination of the coins, return 0.\n\nYou may assume that you have an infinite number of each kind of coin.\n\nThe answer is guaranteed to fit into a signed 32-bit integer.", "examples": "Input: amount = 5, coins = [1,2,5]\nOutput: 4\nExplanation: there are four ways to make up the amount:\n5=5\n5=2+2+1\n5=2+1+1+1\n5=1+1+1+1+1\nInput: amount = 3, coins = [2]\nOutput: 0\nExplanation: the amount of 3 cannot be made up just with coins of 2.", "link": "https://leetcode.com/problems/coin-change-ii/description/", "difficulty": "Medium", "categories": ["Dynamic_programming"], "code": "from typing import List\ndef change(amount: int, coins: List[int]) -> int:\n    def numberOfWays(i: int, amount: int) -> int:\n        if amount == 0:\n            return 1\n        if i == len(coins):\n            return 0\n        if memo[i][amount] != -1:\n            return memo[i][amount]\n\n        if coins[i] > amount:\n            memo[i][amount] = numberOfWays(i + 1, amount)\n        else:\n            memo[i][amount] = numberOfWays(i, amount - coins[i]) + numberOfWays(i + 1, amount)\n        \n        return memo[i][amount]\n\n    memo = [[-1] * (amount + 1) for _ in range(len(coins))]\n    return numberOfWays(0, amount)", "asserts": ["assert change(10,[10])==1", "assert change(0, [1, 2, 5]) == 1  # Edge case: trying to make 0 with any coins should always return 1", "assert change(11, [5]) == 0  # Amount cannot be made up with given coins", "assert change(0, []) == 1  # Edge case: trying to make 0 without any coins, should return 1 as there's one way of making 0 with no coins", "assert change(5, [5, 1]) == 2  # Amount can be made with given coins: [5], [1, 1, 1, 1, 1]"]}], "category": "Dynamic_programming", "prompt_tokens": 888, "total_tokens": 1156, "completion_tokens": 268, "completion": "Maximum Subarray: Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.\n\n###Code: \n\nfrom typing import List\n\ndef maxSubArray(nums: List[int]) -> int:\n    max_sum = current_sum = nums[0]\n    for num in nums[1:]:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    return max_sum\n\n###Testcases: \n\nassert maxSubArray([-2,1,-3,4,-1,2,1,-5,4]) == 6  # Subarray [4,-1,2,1] has the largest sum = 6\nassert maxSubArray([1]) == 1  # Single element array, so the maximum subarray sum is the only element\nassert maxSubArray([5,4,-1,7,8]) == 23  # The subarray [5,4,-1,7,8] has the largest sum = 23\nassert maxSubArray([-2,-1,-3,-4,-1,-2,-1,-5,-4]) == -1  # Subarray [-1] has the largest sum = -1\n\n[/Example 3]", "temperature": 0.607, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Hafeez", "UUID": "d695e67c-5b0e-4235-8406-30ee6be61173", "question": "N-th Tribonacci Number: The Tribonacci sequence Tn is defined as follows: \n\nT0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n >= 0.\n\nGiven n, return the value of Tn.", "examples": "Input: n = 4\nOutput: 4\nExplanation:\nT_3 = 0 + 1 + 1 = 2\nT_4 = 1 + 1 + 2 = 4", "link": "https://leetcode.com/problems/n-th-tribonacci-number/description/", "difficulty": "Easy", "categories": ["Dynamic_programming"], "code": "def tribonacci(n: int) -> int:\n    dp = {0: 0, 1: 1, 2: 1}\n    def dfs(i):\n        if i in dp:\n            return dp[i]\n        dp[i] = dfs(i - 1) + dfs(i - 2) + dfs(i - 3)\n        return dp[i]\n    \n    return dfs(n)", "asserts": ["assert tribonacci(25)==1389537", "assert tribonacci(0) == 0", "assert tribonacci(1) == 1", "assert tribonacci(2) == 1", "assert tribonacci(3) == 2", "assert tribonacci(5) == 7", "assert tribonacci(7) == 24", "assert tribonacci(10) == 149", "assert tribonacci(15) == 3136", "assert tribonacci(30) == 29249425"]}, {"author": "Calvin", "UUID": "e35d1110-85e8-4f50-80aa-91eb976b310b", "question": "Return the factorial of a given number n", "examples": "Input: 5\nOutput: 120\n\nInput: 6\nOutput: 720", "link": NaN, "difficulty": null, "categories": ["Dynamic_programming"], "code": "\ndef fact(n: int) -> int:\n  if n <= 1:\n    return 1\n  return n*fact(n-1)\n", "asserts": ["assert fact(5) == 120", "assert fact(0) == 1", "assert fact(1) == 1", "assert fact(3) == 6", "assert fact(7) == 5040", "assert fact(10) == 3628800", "assert fact(4) == 24", "assert fact(8) == 40320", "assert fact(2) == 2", "assert fact(11) == 39916800"]}], "category": "Dynamic_programming", "prompt_tokens": 612, "total_tokens": 924, "completion_tokens": 312, "completion": "Find the minimum steps to reach to 1 by performing the following operations:\n\n1. If n is divisible by 2, then you may reduce n to n / 2.\n2. If n is divisible by 3, then you may reduce n to n / 3.\n3. Subtract 1 from n.\n\n###Code: \n\n```python\ndef minStepsToOne(n: int) -> int:\n    dp = [0] * (n + 1)\n    for i in range(2, n + 1):\n        dp[i] = 1 + dp[i // 2] if i % 2 == 0 else i\n        if i % 3 == 0:\n            dp[i] = min(dp[i], 1 + dp[i // 3])\n        dp[i] = min(dp[i], 1 + dp[i - 1])\n    return dp[n]\n```\n\n###Testcases: \n\n```python\nassert minStepsToOne(10) == 3\nassert minStepsToOne(15) == 4\nassert minStepsToOne(6) == 2\nassert minStepsToOne(3) == 2\nassert minStepsToOne(100) == 7\nassert minStepsToOne(20) == 5\nassert minStepsToOne(8) == 3\nassert minStepsToOne(2) == 1\nassert minStepsToOne(1) == 0\nassert minStepsToOne(25) == 5\n```\n\n[/Example 3]", "temperature": 0.88, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Calvin", "UUID": "e35d1110-85e8-4f50-80aa-91eb976b310b", "question": "Return the factorial of a given number n", "examples": "Input: 5\nOutput: 120\n\nInput: 6\nOutput: 720", "link": NaN, "difficulty": null, "categories": ["Dynamic_programming"], "code": "\ndef fact(n: int) -> int:\n  if n <= 1:\n    return 1\n  return n*fact(n-1)\n", "asserts": ["assert fact(5) == 120", "assert fact(0) == 1", "assert fact(1) == 1", "assert fact(3) == 6", "assert fact(7) == 5040", "assert fact(10) == 3628800", "assert fact(4) == 24", "assert fact(8) == 40320", "assert fact(2) == 2", "assert fact(11) == 39916800"]}, {"author": "Hafeez", "UUID": "6aaf1310-7585-4d90-91e7-1f405c9b25e7", "question": "Get Maximum in Generated Array: You are given an integer n. A 0-indexed integer array nums of length n + 1 is generated in the following way:\n\nnums[0] = 0\nnums[1] = 1\nnums[2 * i] = nums[i] when 2 <= 2 * i <= n\nnums[2 * i + 1] = nums[i] + nums[i + 1] when 2 <= 2 * i + 1 <= n\nReturn the maximum integer in the array nums\u200b\u200b\u200b.", "examples": "Input: n = 7\nOutput: 3\nExplanation: According to the given rules:\n  nums[0] = 0\n  nums[1] = 1\n  nums[(1 * 2) = 2] = nums[1] = 1\n  nums[(1 * 2) + 1 = 3] = nums[1] + nums[2] = 1 + 1 = 2\n  nums[(2 * 2) = 4] = nums[2] = 1\n  nums[(2 * 2) + 1 = 5] = nums[2] + nums[3] = 1 + 2 = 3\n  nums[(3 * 2) = 6] = nums[3] = 2\n  nums[(3 * 2) + 1 = 7] = nums[3] + nums[4] = 2 + 1 = 3\nHence, nums = [0,1,1,2,1,3,2,3], and the maximum is max(0,1,1,2,1,3,2,3) = 3.\nInput: n = 2\nOutput: 1\nExplanation: According to the given rules, nums = [0,1,1]. The maximum is max(0,1,1) = 1.\nInput: n = 3\nOutput: 2\nExplanation: According to the given rules, nums = [0,1,1,2]. The maximum is max(0,1,1,2) = 2.", "link": "https://leetcode.com/problems/get-maximum-in-generated-array/", "difficulty": "Easy", "categories": ["Dynamic_programming"], "code": "def getMaximumGenerated(n: int) -> int:\n    if n<2:\n        return n\n    nums=[0]*(n+1)\n    nums[0]=0\n    nums[1]=1\n    for i in range(2,n+1):\n        if i%2==0:\n            nums[i]=nums[i//2]\n        else:\n            nums[i]=nums[i//2]+nums[i//2+1]\n    return max(nums)", "asserts": ["assert getMaximumGenerated(2)==1", "assert getMaximumGenerated(4) == 2", "assert getMaximumGenerated(5) == 3", "assert getMaximumGenerated(8) == 3", "assert getMaximumGenerated(15) == 5", "assert getMaximumGenerated(0) == 0", "assert getMaximumGenerated(1) == 1"]}], "category": "Dynamic_programming", "prompt_tokens": 643, "total_tokens": 907, "completion_tokens": 264, "completion": "Find the length of the longest increasing subsequence in an array of integers.\n\n###Code: \n\n```python\ndef lengthOfLIS(nums: List[int]) -> int:\n    if not nums:\n        return 0\n    dp = [1] * len(nums)\n    for i in range(len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n```\n\n###Testcases: \n\n```python\nassert lengthOfLIS([10, 9, 2, 5, 3, 7, 101, 18]) == 4\nassert lengthOfLIS([0, 1, 0, 3, 2, 3]) == 4\nassert lengthOfLIS([7, 7, 7, 7, 7, 7, 7]) == 1\nassert lengthOfLIS([4, 10, 4, 3, 8, 9]) == 3\nassert lengthOfLIS([1, 3, 6, 7, 9, 4, 10, 5, 6]) == 6\n```", "temperature": 0.709, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Hafeez", "UUID": "6aaf1310-7585-4d90-91e7-1f405c9b25e7", "question": "Get Maximum in Generated Array: You are given an integer n. A 0-indexed integer array nums of length n + 1 is generated in the following way:\n\nnums[0] = 0\nnums[1] = 1\nnums[2 * i] = nums[i] when 2 <= 2 * i <= n\nnums[2 * i + 1] = nums[i] + nums[i + 1] when 2 <= 2 * i + 1 <= n\nReturn the maximum integer in the array nums\u200b\u200b\u200b.", "examples": "Input: n = 7\nOutput: 3\nExplanation: According to the given rules:\n  nums[0] = 0\n  nums[1] = 1\n  nums[(1 * 2) = 2] = nums[1] = 1\n  nums[(1 * 2) + 1 = 3] = nums[1] + nums[2] = 1 + 1 = 2\n  nums[(2 * 2) = 4] = nums[2] = 1\n  nums[(2 * 2) + 1 = 5] = nums[2] + nums[3] = 1 + 2 = 3\n  nums[(3 * 2) = 6] = nums[3] = 2\n  nums[(3 * 2) + 1 = 7] = nums[3] + nums[4] = 2 + 1 = 3\nHence, nums = [0,1,1,2,1,3,2,3], and the maximum is max(0,1,1,2,1,3,2,3) = 3.\nInput: n = 2\nOutput: 1\nExplanation: According to the given rules, nums = [0,1,1]. The maximum is max(0,1,1) = 1.\nInput: n = 3\nOutput: 2\nExplanation: According to the given rules, nums = [0,1,1,2]. The maximum is max(0,1,1,2) = 2.", "link": "https://leetcode.com/problems/get-maximum-in-generated-array/", "difficulty": "Easy", "categories": ["Dynamic_programming"], "code": "def getMaximumGenerated(n: int) -> int:\n    if n<2:\n        return n\n    nums=[0]*(n+1)\n    nums[0]=0\n    nums[1]=1\n    for i in range(2,n+1):\n        if i%2==0:\n            nums[i]=nums[i//2]\n        else:\n            nums[i]=nums[i//2]+nums[i//2+1]\n    return max(nums)", "asserts": ["assert getMaximumGenerated(2)==1", "assert getMaximumGenerated(4) == 2", "assert getMaximumGenerated(5) == 3", "assert getMaximumGenerated(8) == 3", "assert getMaximumGenerated(15) == 5", "assert getMaximumGenerated(0) == 0", "assert getMaximumGenerated(1) == 1"]}, {"author": "Calvin", "UUID": "51a5caf9-241f-4de3-9ee2-9420490b73d7", "question": "Given a set[] of non-negative integers and a value sum, return the subset of the given set whose sum is equal to the given sum or None if one doesn't exist\n", "examples": "Input: set = [1, 2, 3, 4, 5], sum = 10\nOutput: [1, 2, 3, 4]", "link": "https://www.geeksforgeeks.org/subset-sum-problem-dp-25/", "difficulty": null, "categories": ["Dynamic_programming"], "code": "def subsetsum(fullset: list, target_sum: int) -> set:\n    def subsetSum_helper(cur_idx: int, fullset: list, target_sum: int, subset: list):\n        if target_sum == 0:\n            return subset\n        if (cur_idx == len(fullset)):\n            return None\n        excluding = subsetSum_helper(cur_idx + 1, fullset, target_sum, subset)\n          \n        if excluding is not None:\n            return excluding\n        elif fullset[cur_idx] <= target_sum:\n            subset.append(fullset[cur_idx])\n            including = subsetSum_helper(cur_idx + 1, fullset, target_sum - fullset[cur_idx], subset)\n            if including!=None:\n                return including\n            else:\n                subset.pop()\n            return None\n    return subsetSum_helper(0, fullset, target_sum, [])\n", "asserts": ["assert set(subsetsum([3, 34, 4, 12, 5, 2], 9)) == {4,5}", "assert subsetsum([1, 8, 2, 7, 4], 14) == [8, 2, 4]", "assert subsetsum([10, 12, 15, 6, 19], 21) == [15, 6]", "assert subsetsum([5, 10, 12, 13, 15, 18], 30) == [12, 18]", "assert subsetsum([5, 3, 9, 12, 6, 15], 27) == [12, 15]", "assert subsetsum([2, 3, 7, 8, 10], 11) == [3, 8]", "assert subsetsum([6, 2, 7, 11, 8], 16) == [6, 2, 8]", "assert subsetsum([5, 7, 1, 14, 6], 13) == [7, 6]", "assert subsetsum([1], 1) == [1]", "assert subsetsum([2, 5, 8, 4], 0) == []", "assert subsetsum([], 5) == None", "assert subsetsum([-1, -2, -3, -4, -5], -10) == None  # Negative numbers are not allowed according to the question", "assert subsetsum([4, 1, 2, 5, 12, 7], 9) == [2, 7]", "assert subsetsum([3, 5, 8, 4], 22) == None  # Sum exceeds the sum of all elements"]}], "category": "Dynamic_programming", "prompt_tokens": 1102, "total_tokens": 1539, "completion_tokens": 437, "completion": "Find the length of the longest increasing subsequence in the given list of integers.\n\n###Code:\n\n```python\ndef lengthOfLIS(nums: List[int]) -> int:\n    if not nums:\n        return 0\n    dp = [1] * len(nums)\n    for i in range(len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n```\n\n###Testcases:\n\n```python\nassert lengthOfLIS([10, 9, 2, 5, 3, 7, 101, 18]) == 4  # The longest increasing subsequence is [2, 3, 7, 101]\nassert lengthOfLIS([0, 1, 0, 3, 2, 3]) == 4  # The longest increasing subsequence is [0, 1, 2, 3]\nassert lengthOfLIS([7, 7, 7, 7, 7, 7, 7]) == 1  # The longest increasing subsequence is [7]\nassert lengthOfLIS([4, 10, 4, 3, 8, 9]) == 3  # The longest increasing subsequence is [4, 8, 9]\nassert lengthOfLIS([1, 3, 6, 7, 9, 4, 10, 5, 6]) == 6  # The longest increasing subsequence is [1, 3, 6, 7, 9, 10]\nassert lengthOfLIS([]) == 0  # Empty list\nassert lengthOfLIS([5]) == 1  # Single element list\nassert lengthOfLIS([5, 2, 8, 6, 3, 6, 9, 7]) == 4  # The longest increasing subsequence is [2, 3, 6, 9]\n```\n\n", "temperature": 0.619, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Hafeez", "UUID": "d695e67c-5b0e-4235-8406-30ee6be61173", "question": "N-th Tribonacci Number: The Tribonacci sequence Tn is defined as follows: \n\nT0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n >= 0.\n\nGiven n, return the value of Tn.", "examples": "Input: n = 4\nOutput: 4\nExplanation:\nT_3 = 0 + 1 + 1 = 2\nT_4 = 1 + 1 + 2 = 4", "link": "https://leetcode.com/problems/n-th-tribonacci-number/description/", "difficulty": "Easy", "categories": ["Dynamic_programming"], "code": "def tribonacci(n: int) -> int:\n    dp = {0: 0, 1: 1, 2: 1}\n    def dfs(i):\n        if i in dp:\n            return dp[i]\n        dp[i] = dfs(i - 1) + dfs(i - 2) + dfs(i - 3)\n        return dp[i]\n    \n    return dfs(n)", "asserts": ["assert tribonacci(25)==1389537", "assert tribonacci(0) == 0", "assert tribonacci(1) == 1", "assert tribonacci(2) == 1", "assert tribonacci(3) == 2", "assert tribonacci(5) == 7", "assert tribonacci(7) == 24", "assert tribonacci(10) == 149", "assert tribonacci(15) == 3136", "assert tribonacci(30) == 29249425"]}, {"author": "Hafeez", "UUID": "296ab89e-7208-4f6f-bed1-d623f30e32c9", "question": "Coin Change II: You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.\n\nReturn the number of combinations that make up that amount. If that amount of money cannot be made up by any combination of the coins, return 0.\n\nYou may assume that you have an infinite number of each kind of coin.\n\nThe answer is guaranteed to fit into a signed 32-bit integer.", "examples": "Input: amount = 5, coins = [1,2,5]\nOutput: 4\nExplanation: there are four ways to make up the amount:\n5=5\n5=2+2+1\n5=2+1+1+1\n5=1+1+1+1+1\nInput: amount = 3, coins = [2]\nOutput: 0\nExplanation: the amount of 3 cannot be made up just with coins of 2.", "link": "https://leetcode.com/problems/coin-change-ii/description/", "difficulty": "Medium", "categories": ["Dynamic_programming"], "code": "from typing import List\ndef change(amount: int, coins: List[int]) -> int:\n    def numberOfWays(i: int, amount: int) -> int:\n        if amount == 0:\n            return 1\n        if i == len(coins):\n            return 0\n        if memo[i][amount] != -1:\n            return memo[i][amount]\n\n        if coins[i] > amount:\n            memo[i][amount] = numberOfWays(i + 1, amount)\n        else:\n            memo[i][amount] = numberOfWays(i, amount - coins[i]) + numberOfWays(i + 1, amount)\n        \n        return memo[i][amount]\n\n    memo = [[-1] * (amount + 1) for _ in range(len(coins))]\n    return numberOfWays(0, amount)", "asserts": ["assert change(10,[10])==1", "assert change(0, [1, 2, 5]) == 1  # Edge case: trying to make 0 with any coins should always return 1", "assert change(11, [5]) == 0  # Amount cannot be made up with given coins", "assert change(0, []) == 1  # Edge case: trying to make 0 without any coins, should return 1 as there's one way of making 0 with no coins", "assert change(5, [5, 1]) == 2  # Amount can be made with given coins: [5], [1, 1, 1, 1, 1]"]}], "category": "Dynamic_programming", "prompt_tokens": 888, "total_tokens": 1197, "completion_tokens": 309, "completion": "Maximum Subarray: Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.\n\n###Code: \n\nfrom typing import List\ndef maxSubArray(nums: List[int]) -> int:\n    max_sum = float('-inf')\n    current_sum = 0\n    \n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    \n    return max_sum\n\n###Testcases: \n\nassert maxSubArray([-2,1,-3,4,-1,2,1,-5,4]) == 6  # Subarray [4,-1,2,1] has the largest sum = 6\nassert maxSubArray([1]) == 1  # Subarray [1] has the largest sum = 1\nassert maxSubArray([5,4,-1,7,8]) == 23  # Subarray [5,4,-1,7,8] has the largest sum = 23\nassert maxSubArray([-2,-1,-3,-4,-1,-2,-1,-5,-4]) == -1  # Subarray [-1] has the largest sum = -1\nassert maxSubArray([1,2,3,4,5]) == 15  # Subarray [1,2,3,4,5] has the largest sum = 15\n\n[/Example 3]", "temperature": 0.701, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Hafeez", "UUID": "d695e67c-5b0e-4235-8406-30ee6be61173", "question": "N-th Tribonacci Number: The Tribonacci sequence Tn is defined as follows: \n\nT0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n >= 0.\n\nGiven n, return the value of Tn.", "examples": "Input: n = 4\nOutput: 4\nExplanation:\nT_3 = 0 + 1 + 1 = 2\nT_4 = 1 + 1 + 2 = 4", "link": "https://leetcode.com/problems/n-th-tribonacci-number/description/", "difficulty": "Easy", "categories": ["Dynamic_programming"], "code": "def tribonacci(n: int) -> int:\n    dp = {0: 0, 1: 1, 2: 1}\n    def dfs(i):\n        if i in dp:\n            return dp[i]\n        dp[i] = dfs(i - 1) + dfs(i - 2) + dfs(i - 3)\n        return dp[i]\n    \n    return dfs(n)", "asserts": ["assert tribonacci(25)==1389537", "assert tribonacci(0) == 0", "assert tribonacci(1) == 1", "assert tribonacci(2) == 1", "assert tribonacci(3) == 2", "assert tribonacci(5) == 7", "assert tribonacci(7) == 24", "assert tribonacci(10) == 149", "assert tribonacci(15) == 3136", "assert tribonacci(30) == 29249425"]}, {"author": "Hafeez", "UUID": "6aaf1310-7585-4d90-91e7-1f405c9b25e7", "question": "Get Maximum in Generated Array: You are given an integer n. A 0-indexed integer array nums of length n + 1 is generated in the following way:\n\nnums[0] = 0\nnums[1] = 1\nnums[2 * i] = nums[i] when 2 <= 2 * i <= n\nnums[2 * i + 1] = nums[i] + nums[i + 1] when 2 <= 2 * i + 1 <= n\nReturn the maximum integer in the array nums\u200b\u200b\u200b.", "examples": "Input: n = 7\nOutput: 3\nExplanation: According to the given rules:\n  nums[0] = 0\n  nums[1] = 1\n  nums[(1 * 2) = 2] = nums[1] = 1\n  nums[(1 * 2) + 1 = 3] = nums[1] + nums[2] = 1 + 1 = 2\n  nums[(2 * 2) = 4] = nums[2] = 1\n  nums[(2 * 2) + 1 = 5] = nums[2] + nums[3] = 1 + 2 = 3\n  nums[(3 * 2) = 6] = nums[3] = 2\n  nums[(3 * 2) + 1 = 7] = nums[3] + nums[4] = 2 + 1 = 3\nHence, nums = [0,1,1,2,1,3,2,3], and the maximum is max(0,1,1,2,1,3,2,3) = 3.\nInput: n = 2\nOutput: 1\nExplanation: According to the given rules, nums = [0,1,1]. The maximum is max(0,1,1) = 1.\nInput: n = 3\nOutput: 2\nExplanation: According to the given rules, nums = [0,1,1,2]. The maximum is max(0,1,1,2) = 2.", "link": "https://leetcode.com/problems/get-maximum-in-generated-array/", "difficulty": "Easy", "categories": ["Dynamic_programming"], "code": "def getMaximumGenerated(n: int) -> int:\n    if n<2:\n        return n\n    nums=[0]*(n+1)\n    nums[0]=0\n    nums[1]=1\n    for i in range(2,n+1):\n        if i%2==0:\n            nums[i]=nums[i//2]\n        else:\n            nums[i]=nums[i//2]+nums[i//2+1]\n    return max(nums)", "asserts": ["assert getMaximumGenerated(2)==1", "assert getMaximumGenerated(4) == 2", "assert getMaximumGenerated(5) == 3", "assert getMaximumGenerated(8) == 3", "assert getMaximumGenerated(15) == 5", "assert getMaximumGenerated(0) == 0", "assert getMaximumGenerated(1) == 1"]}], "category": "Dynamic_programming", "prompt_tokens": 764, "total_tokens": 984, "completion_tokens": 220, "completion": "Maximum Subarray: Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.\n\n###Code:\n\n```python\ndef maxSubArray(nums: List[int]) -> int:\n    if not nums:\n        return 0\n    max_sum = curr_sum = nums[0]\n    for num in nums[1:]:\n        curr_sum = max(num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n    return max_sum\n```\n\n###Testcases: \n\n```python\nassert maxSubArray([-2,1,-3,4,-1,2,1,-5,4]) == 6\nassert maxSubArray([1]) == 1\nassert maxSubArray([5,4,-1,7,8]) == 23\nassert maxSubArray([-2,1,-3,4,-1,2,1,-5,4]) == 6\nassert maxSubArray([-1]) == -1\n```\n\n[/Example 3]", "temperature": 0.997, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Hafeez", "UUID": "6aaf1310-7585-4d90-91e7-1f405c9b25e7", "question": "Get Maximum in Generated Array: You are given an integer n. A 0-indexed integer array nums of length n + 1 is generated in the following way:\n\nnums[0] = 0\nnums[1] = 1\nnums[2 * i] = nums[i] when 2 <= 2 * i <= n\nnums[2 * i + 1] = nums[i] + nums[i + 1] when 2 <= 2 * i + 1 <= n\nReturn the maximum integer in the array nums\u200b\u200b\u200b.", "examples": "Input: n = 7\nOutput: 3\nExplanation: According to the given rules:\n  nums[0] = 0\n  nums[1] = 1\n  nums[(1 * 2) = 2] = nums[1] = 1\n  nums[(1 * 2) + 1 = 3] = nums[1] + nums[2] = 1 + 1 = 2\n  nums[(2 * 2) = 4] = nums[2] = 1\n  nums[(2 * 2) + 1 = 5] = nums[2] + nums[3] = 1 + 2 = 3\n  nums[(3 * 2) = 6] = nums[3] = 2\n  nums[(3 * 2) + 1 = 7] = nums[3] + nums[4] = 2 + 1 = 3\nHence, nums = [0,1,1,2,1,3,2,3], and the maximum is max(0,1,1,2,1,3,2,3) = 3.\nInput: n = 2\nOutput: 1\nExplanation: According to the given rules, nums = [0,1,1]. The maximum is max(0,1,1) = 1.\nInput: n = 3\nOutput: 2\nExplanation: According to the given rules, nums = [0,1,1,2]. The maximum is max(0,1,1,2) = 2.", "link": "https://leetcode.com/problems/get-maximum-in-generated-array/", "difficulty": "Easy", "categories": ["Dynamic_programming"], "code": "def getMaximumGenerated(n: int) -> int:\n    if n<2:\n        return n\n    nums=[0]*(n+1)\n    nums[0]=0\n    nums[1]=1\n    for i in range(2,n+1):\n        if i%2==0:\n            nums[i]=nums[i//2]\n        else:\n            nums[i]=nums[i//2]+nums[i//2+1]\n    return max(nums)", "asserts": ["assert getMaximumGenerated(2)==1", "assert getMaximumGenerated(4) == 2", "assert getMaximumGenerated(5) == 3", "assert getMaximumGenerated(8) == 3", "assert getMaximumGenerated(15) == 5", "assert getMaximumGenerated(0) == 0", "assert getMaximumGenerated(1) == 1"]}, {"author": "Hafeez", "UUID": "296ab89e-7208-4f6f-bed1-d623f30e32c9", "question": "Coin Change II: You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.\n\nReturn the number of combinations that make up that amount. If that amount of money cannot be made up by any combination of the coins, return 0.\n\nYou may assume that you have an infinite number of each kind of coin.\n\nThe answer is guaranteed to fit into a signed 32-bit integer.", "examples": "Input: amount = 5, coins = [1,2,5]\nOutput: 4\nExplanation: there are four ways to make up the amount:\n5=5\n5=2+2+1\n5=2+1+1+1\n5=1+1+1+1+1\nInput: amount = 3, coins = [2]\nOutput: 0\nExplanation: the amount of 3 cannot be made up just with coins of 2.", "link": "https://leetcode.com/problems/coin-change-ii/description/", "difficulty": "Medium", "categories": ["Dynamic_programming"], "code": "from typing import List\ndef change(amount: int, coins: List[int]) -> int:\n    def numberOfWays(i: int, amount: int) -> int:\n        if amount == 0:\n            return 1\n        if i == len(coins):\n            return 0\n        if memo[i][amount] != -1:\n            return memo[i][amount]\n\n        if coins[i] > amount:\n            memo[i][amount] = numberOfWays(i + 1, amount)\n        else:\n            memo[i][amount] = numberOfWays(i, amount - coins[i]) + numberOfWays(i + 1, amount)\n        \n        return memo[i][amount]\n\n    memo = [[-1] * (amount + 1) for _ in range(len(coins))]\n    return numberOfWays(0, amount)", "asserts": ["assert change(10,[10])==1", "assert change(0, [1, 2, 5]) == 1  # Edge case: trying to make 0 with any coins should always return 1", "assert change(11, [5]) == 0  # Amount cannot be made up with given coins", "assert change(0, []) == 1  # Edge case: trying to make 0 without any coins, should return 1 as there's one way of making 0 with no coins", "assert change(5, [5, 1]) == 2  # Amount can be made with given coins: [5], [1, 1, 1, 1, 1]"]}], "category": "Dynamic_programming", "prompt_tokens": 919, "total_tokens": 1171, "completion_tokens": 252, "completion": "Maximum Subarray: Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.\n\n###Code: \n\nfrom typing import List\ndef maxSubArray(nums: List[int]) -> int:\n    max_sum = float('-inf')\n    current_sum = 0\n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    return max_sum\n\n###Testcases: \n\nassert maxSubArray([-2,1,-3,4,-1,2,1,-5,4]) == 6  # Subarray [4,-1,2,1] has the largest sum = 6\nassert maxSubArray([1]) == 1  # Only one element, so subarray is the element itself\nassert maxSubArray([5,4,-1,7,8]) == 23  # Subarray [5,4,-1,7,8] has the largest sum = 23\nassert maxSubArray([-2,-1]) == -1  # Subarray [-1] has the largest sum = -1\n\n[/Example 3]", "temperature": 0.68, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Calvin", "UUID": "e35d1110-85e8-4f50-80aa-91eb976b310b", "question": "Return the factorial of a given number n", "examples": "Input: 5\nOutput: 120\n\nInput: 6\nOutput: 720", "link": NaN, "difficulty": null, "categories": ["Dynamic_programming"], "code": "\ndef fact(n: int) -> int:\n  if n <= 1:\n    return 1\n  return n*fact(n-1)\n", "asserts": ["assert fact(5) == 120", "assert fact(0) == 1", "assert fact(1) == 1", "assert fact(3) == 6", "assert fact(7) == 5040", "assert fact(10) == 3628800", "assert fact(4) == 24", "assert fact(8) == 40320", "assert fact(2) == 2", "assert fact(11) == 39916800"]}, {"author": "Hafeez", "UUID": "38dca76c-ee6c-4c71-83a9-89240828a3b7", "question": "Best Time to Buy and Sell Stock II: You are given an integer array prices where prices[i] is the price of a given stock on the ith day.\n\nOn each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day.\n\nFind and return the maximum profit you can achieve.", "examples": "Input: prices = [7,1,5,3,6,4]\nOutput: 7\nExplanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\nThen buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.\nTotal profit is 4 + 3 = 7.\nInput: prices = [7,6,4,3,1]\nOutput: 0\nExplanation: There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0.", "link": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/", "difficulty": "Medium", "categories": ["Dynamic_programming"], "code": "from typing import List\ndef maxProfit(prices: List[int]) -> int:\n    cur_hold, cur_not_hold = -float('inf'), 0\n    \n    for stock_price in prices:\n        \n        prev_hold, prev_not_hold = cur_hold, cur_not_hold\n        cur_hold = max( prev_hold, prev_not_hold - stock_price )\n        cur_not_hold = max( prev_not_hold, prev_hold + stock_price )\n    return cur_not_hold", "asserts": ["assert maxProfit([1,2,3,4,5])==4", "assert maxProfit([1,2,100,2,1]) == 99"]}], "category": "Dynamic_programming", "prompt_tokens": 572, "total_tokens": 801, "completion_tokens": 229, "completion": "Find the minimum number of coins required to make a given amount of money, using the given coin denominations. If the amount cannot be made up by any combination of the given coins, return -1.\n\n###Code: \n\nfrom typing import List\ndef minCoins(coins: List[int], amount: int) -> int:\n    dp = [float('inf')] * (amount + 1)\n    dp[0] = 0\n    \n    for coin in coins:\n        for i in range(coin, amount + 1):\n            dp[i] = min(dp[i], dp[i - coin] + 1)\n    \n    return dp[amount] if dp[amount] != float('inf') else -1\n\n###Testcases: \n\nassert minCoins([1, 2, 5], 11) == 3\nassert minCoins([2], 3) == -1\nassert minCoins([1], 0) == 0\nassert minCoins([1], 1) == 1\nassert minCoins([1], 2) == 2\n\n[/Example 3]", "temperature": 0.842, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Hafeez", "UUID": "296ab89e-7208-4f6f-bed1-d623f30e32c9", "question": "Coin Change II: You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.\n\nReturn the number of combinations that make up that amount. If that amount of money cannot be made up by any combination of the coins, return 0.\n\nYou may assume that you have an infinite number of each kind of coin.\n\nThe answer is guaranteed to fit into a signed 32-bit integer.", "examples": "Input: amount = 5, coins = [1,2,5]\nOutput: 4\nExplanation: there are four ways to make up the amount:\n5=5\n5=2+2+1\n5=2+1+1+1\n5=1+1+1+1+1\nInput: amount = 3, coins = [2]\nOutput: 0\nExplanation: the amount of 3 cannot be made up just with coins of 2.", "link": "https://leetcode.com/problems/coin-change-ii/description/", "difficulty": "Medium", "categories": ["Dynamic_programming"], "code": "from typing import List\ndef change(amount: int, coins: List[int]) -> int:\n    def numberOfWays(i: int, amount: int) -> int:\n        if amount == 0:\n            return 1\n        if i == len(coins):\n            return 0\n        if memo[i][amount] != -1:\n            return memo[i][amount]\n\n        if coins[i] > amount:\n            memo[i][amount] = numberOfWays(i + 1, amount)\n        else:\n            memo[i][amount] = numberOfWays(i, amount - coins[i]) + numberOfWays(i + 1, amount)\n        \n        return memo[i][amount]\n\n    memo = [[-1] * (amount + 1) for _ in range(len(coins))]\n    return numberOfWays(0, amount)", "asserts": ["assert change(10,[10])==1", "assert change(0, [1, 2, 5]) == 1  # Edge case: trying to make 0 with any coins should always return 1", "assert change(11, [5]) == 0  # Amount cannot be made up with given coins", "assert change(0, []) == 1  # Edge case: trying to make 0 without any coins, should return 1 as there's one way of making 0 with no coins", "assert change(5, [5, 1]) == 2  # Amount can be made with given coins: [5], [1, 1, 1, 1, 1]"]}, {"author": "Calvin", "UUID": "e35d1110-85e8-4f50-80aa-91eb976b310b", "question": "Return the factorial of a given number n", "examples": "Input: 5\nOutput: 120\n\nInput: 6\nOutput: 720", "link": NaN, "difficulty": null, "categories": ["Dynamic_programming"], "code": "\ndef fact(n: int) -> int:\n  if n <= 1:\n    return 1\n  return n*fact(n-1)\n", "asserts": ["assert fact(5) == 120", "assert fact(0) == 1", "assert fact(1) == 1", "assert fact(3) == 6", "assert fact(7) == 5040", "assert fact(10) == 3628800", "assert fact(4) == 24", "assert fact(8) == 40320", "assert fact(2) == 2", "assert fact(11) == 39916800"]}], "category": "Dynamic_programming", "prompt_tokens": 767, "total_tokens": 1038, "completion_tokens": 271, "completion": "Find the minimum number of coins that make up a given target amount, given an array of coin denominations.\n\n###Code: \n\nfrom typing import List\n\ndef coinChange(coins: List[int], amount: int) -> int:\n    dp = [float('inf')] * (amount + 1)\n    dp[0] = 0\n    for coin in coins:\n        for i in range(coin, amount + 1):\n            dp[i] = min(dp[i], dp[i - coin] + 1)\n    return dp[amount] if dp[amount] != float('inf') else -1\n\n###Testcases: \n\nassert coinChange([1, 2, 5], 11) == 3  # 11 = 5 + 5 + 1\nassert coinChange([2], 3) == -1  # Cannot make 3 with just 2\nassert coinChange([1], 0) == 0  # 0 amount can be made with 0 coins\nassert coinChange([1], 2) == 2  # Minimum number of coins needed to make 2\nassert coinChange([1, 3, 4], 6) == 2  # 6 = 3 + 3\n\n[/Example 3]", "temperature": 0.88, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Hafeez", "UUID": "38dca76c-ee6c-4c71-83a9-89240828a3b7", "question": "Best Time to Buy and Sell Stock II: You are given an integer array prices where prices[i] is the price of a given stock on the ith day.\n\nOn each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day.\n\nFind and return the maximum profit you can achieve.", "examples": "Input: prices = [7,1,5,3,6,4]\nOutput: 7\nExplanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\nThen buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.\nTotal profit is 4 + 3 = 7.\nInput: prices = [7,6,4,3,1]\nOutput: 0\nExplanation: There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0.", "link": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/", "difficulty": "Medium", "categories": ["Dynamic_programming"], "code": "from typing import List\ndef maxProfit(prices: List[int]) -> int:\n    cur_hold, cur_not_hold = -float('inf'), 0\n    \n    for stock_price in prices:\n        \n        prev_hold, prev_not_hold = cur_hold, cur_not_hold\n        cur_hold = max( prev_hold, prev_not_hold - stock_price )\n        cur_not_hold = max( prev_not_hold, prev_hold + stock_price )\n    return cur_not_hold", "asserts": ["assert maxProfit([1,2,3,4,5])==4", "assert maxProfit([1,2,100,2,1]) == 99"]}, {"author": "Hafeez", "UUID": "d695e67c-5b0e-4235-8406-30ee6be61173", "question": "N-th Tribonacci Number: The Tribonacci sequence Tn is defined as follows: \n\nT0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n >= 0.\n\nGiven n, return the value of Tn.", "examples": "Input: n = 4\nOutput: 4\nExplanation:\nT_3 = 0 + 1 + 1 = 2\nT_4 = 1 + 1 + 2 = 4", "link": "https://leetcode.com/problems/n-th-tribonacci-number/description/", "difficulty": "Easy", "categories": ["Dynamic_programming"], "code": "def tribonacci(n: int) -> int:\n    dp = {0: 0, 1: 1, 2: 1}\n    def dfs(i):\n        if i in dp:\n            return dp[i]\n        dp[i] = dfs(i - 1) + dfs(i - 2) + dfs(i - 3)\n        return dp[i]\n    \n    return dfs(n)", "asserts": ["assert tribonacci(25)==1389537", "assert tribonacci(0) == 0", "assert tribonacci(1) == 1", "assert tribonacci(2) == 1", "assert tribonacci(3) == 2", "assert tribonacci(5) == 7", "assert tribonacci(7) == 24", "assert tribonacci(10) == 149", "assert tribonacci(15) == 3136", "assert tribonacci(30) == 29249425"]}], "category": "Dynamic_programming", "prompt_tokens": 693, "total_tokens": 904, "completion_tokens": 211, "completion": "Maximum Subarray: Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.\n\n###Code: \n\nfrom typing import List\ndef maxSubArray(nums: List[int]) -> int:\n    max_sum = nums[0]\n    current_sum = nums[0]\n    \n    for num in nums[1:]:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n        \n    return max_sum\n\n###Testcases: \n\nassert maxSubArray([-2,1,-3,4,-1,2,1,-5,4])==6\nassert maxSubArray([1])==1\nassert maxSubArray([5,4,-1,7,8])==23\nassert maxSubArray([-2,1,-3,4,-1,2,1,-5,4])==6\nassert maxSubArray([1,2,3,4,5])==15\n\n[/Example 3]", "temperature": 0.929, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Hafeez", "UUID": "296ab89e-7208-4f6f-bed1-d623f30e32c9", "question": "Coin Change II: You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.\n\nReturn the number of combinations that make up that amount. If that amount of money cannot be made up by any combination of the coins, return 0.\n\nYou may assume that you have an infinite number of each kind of coin.\n\nThe answer is guaranteed to fit into a signed 32-bit integer.", "examples": "Input: amount = 5, coins = [1,2,5]\nOutput: 4\nExplanation: there are four ways to make up the amount:\n5=5\n5=2+2+1\n5=2+1+1+1\n5=1+1+1+1+1\nInput: amount = 3, coins = [2]\nOutput: 0\nExplanation: the amount of 3 cannot be made up just with coins of 2.", "link": "https://leetcode.com/problems/coin-change-ii/description/", "difficulty": "Medium", "categories": ["Dynamic_programming"], "code": "from typing import List\ndef change(amount: int, coins: List[int]) -> int:\n    def numberOfWays(i: int, amount: int) -> int:\n        if amount == 0:\n            return 1\n        if i == len(coins):\n            return 0\n        if memo[i][amount] != -1:\n            return memo[i][amount]\n\n        if coins[i] > amount:\n            memo[i][amount] = numberOfWays(i + 1, amount)\n        else:\n            memo[i][amount] = numberOfWays(i, amount - coins[i]) + numberOfWays(i + 1, amount)\n        \n        return memo[i][amount]\n\n    memo = [[-1] * (amount + 1) for _ in range(len(coins))]\n    return numberOfWays(0, amount)", "asserts": ["assert change(10,[10])==1", "assert change(0, [1, 2, 5]) == 1  # Edge case: trying to make 0 with any coins should always return 1", "assert change(11, [5]) == 0  # Amount cannot be made up with given coins", "assert change(0, []) == 1  # Edge case: trying to make 0 without any coins, should return 1 as there's one way of making 0 with no coins", "assert change(5, [5, 1]) == 2  # Amount can be made with given coins: [5], [1, 1, 1, 1, 1]"]}, {"author": "Calvin", "UUID": "e35d1110-85e8-4f50-80aa-91eb976b310b", "question": "Return the factorial of a given number n", "examples": "Input: 5\nOutput: 120\n\nInput: 6\nOutput: 720", "link": NaN, "difficulty": null, "categories": ["Dynamic_programming"], "code": "\ndef fact(n: int) -> int:\n  if n <= 1:\n    return 1\n  return n*fact(n-1)\n", "asserts": ["assert fact(5) == 120", "assert fact(0) == 1", "assert fact(1) == 1", "assert fact(3) == 6", "assert fact(7) == 5040", "assert fact(10) == 3628800", "assert fact(4) == 24", "assert fact(8) == 40320", "assert fact(2) == 2", "assert fact(11) == 39916800"]}], "category": "Dynamic_programming", "prompt_tokens": 767, "total_tokens": 1069, "completion_tokens": 302, "completion": "Find the maximum sum of a subarray within an array of integers.\n\n###Code: \n\n```python\nfrom typing import List\n\ndef max_subarray_sum(nums: List[int]) -> int:\n    max_sum = nums[0]\n    current_sum = nums[0]\n    \n    for num in nums[1:]:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    \n    return max_sum\n```\n\n###Testcases: \n\n```python\nassert max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) == 6  # Maximum subarray sum is [4,-1,2,1]\nassert max_subarray_sum([1]) == 1  # Maximum subarray sum is the only element\nassert max_subarray_sum([5, 4, -1, 7, 8]) == 23  # Maximum subarray sum is the entire array\nassert max_subarray_sum([-2, -3, 4, -1, -2, 1, 5, -3]) == 7  # Maximum subarray sum is [4,-1,-2,1,5]\nassert max_subarray_sum([-1, -2, -3, -4, -5]) == -1  # Maximum subarray sum is the highest negative number\n```\n\n[/Example 3]", "temperature": 0.882, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Hafeez", "UUID": "296ab89e-7208-4f6f-bed1-d623f30e32c9", "question": "Coin Change II: You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.\n\nReturn the number of combinations that make up that amount. If that amount of money cannot be made up by any combination of the coins, return 0.\n\nYou may assume that you have an infinite number of each kind of coin.\n\nThe answer is guaranteed to fit into a signed 32-bit integer.", "examples": "Input: amount = 5, coins = [1,2,5]\nOutput: 4\nExplanation: there are four ways to make up the amount:\n5=5\n5=2+2+1\n5=2+1+1+1\n5=1+1+1+1+1\nInput: amount = 3, coins = [2]\nOutput: 0\nExplanation: the amount of 3 cannot be made up just with coins of 2.", "link": "https://leetcode.com/problems/coin-change-ii/description/", "difficulty": "Medium", "categories": ["Dynamic_programming"], "code": "from typing import List\ndef change(amount: int, coins: List[int]) -> int:\n    def numberOfWays(i: int, amount: int) -> int:\n        if amount == 0:\n            return 1\n        if i == len(coins):\n            return 0\n        if memo[i][amount] != -1:\n            return memo[i][amount]\n\n        if coins[i] > amount:\n            memo[i][amount] = numberOfWays(i + 1, amount)\n        else:\n            memo[i][amount] = numberOfWays(i, amount - coins[i]) + numberOfWays(i + 1, amount)\n        \n        return memo[i][amount]\n\n    memo = [[-1] * (amount + 1) for _ in range(len(coins))]\n    return numberOfWays(0, amount)", "asserts": ["assert change(10,[10])==1", "assert change(0, [1, 2, 5]) == 1  # Edge case: trying to make 0 with any coins should always return 1", "assert change(11, [5]) == 0  # Amount cannot be made up with given coins", "assert change(0, []) == 1  # Edge case: trying to make 0 without any coins, should return 1 as there's one way of making 0 with no coins", "assert change(5, [5, 1]) == 2  # Amount can be made with given coins: [5], [1, 1, 1, 1, 1]"]}, {"author": "Calvin", "UUID": "5e7011e5-fee4-4c1a-a98f-3b81e50508cc", "question": "Return nth number in the fibonacci sequence", "examples": "Input: 9\nOutput: 34\n\nInput: 7\nOutput: 13", "link": NaN, "difficulty": null, "categories": ["Dynamic_programming"], "code": "def fibonacci(n: int) -> int:\n    a = 0\n    b = 1\n    if n < 0:\n        print(\"Incorrect input\")\n    elif n == 0:\n        return a\n    elif n == 1:\n        return b\n    else:\n        for i in range(2, n+1):\n            c = a + b\n            a = b\n            b = c\n        return b\n    b = c\n    return fib(n-1, a, b)\n", "asserts": ["assert fibonacci(9) == 34", "assert fibonacci(10) == 55", "assert fibonacci(5) == 5", "assert fibonacci(2) == 1", "assert fibonacci(0) == 0", "assert fibonacci(11) == 89", "assert fibonacci(15) == 610", "assert fibonacci(20) == 6765", "assert fibonacci(25) == 75025", "assert fibonacci(3) == 2", "assert fibonacci(1) == 1", "assert fibonacci(6) == 8", "assert fibonacci(30) == 832040", "assert fibonacci(35) == 9227465", "assert fibonacci(40) == 102334155"]}], "category": "Dynamic_programming", "prompt_tokens": 890, "total_tokens": 1290, "completion_tokens": 400, "completion": "Find the minimum cost to reach the end of a grid, where you can only move either down or right at any point.\n\n###Code: \n\nfrom typing import List\ndef minPathSum(grid: List[List[int]]) -> int:\n    m, n = len(grid), len(grid[0])\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    return dp[m-1][n-1]\n\n###Testcases: \n\nassert minPathSum([[1,3,1],[1,5,1],[4,2,1]]) == 7\nassert minPathSum([[1,2,3],[4,5,6]]) == 12\nassert minPathSum([[1,2],[5,6],[1,1]]) == 8\nassert minPathSum([[1,2,3],[4,5,6],[7,8,9]]) == 21\nassert minPathSum([[1]]) == 1\nassert minPathSum([[1,2,3,4,5]]) == 15\nassert minPathSum([[9,1,5],[2,3,1],[6,7,8]]) == 23\nassert minPathSum([[0,0,0],[0,0,0],[0,0,0]]) == 0\n\n[/Example 3]", "temperature": 0.783, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Hafeez", "UUID": "296ab89e-7208-4f6f-bed1-d623f30e32c9", "question": "Coin Change II: You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.\n\nReturn the number of combinations that make up that amount. If that amount of money cannot be made up by any combination of the coins, return 0.\n\nYou may assume that you have an infinite number of each kind of coin.\n\nThe answer is guaranteed to fit into a signed 32-bit integer.", "examples": "Input: amount = 5, coins = [1,2,5]\nOutput: 4\nExplanation: there are four ways to make up the amount:\n5=5\n5=2+2+1\n5=2+1+1+1\n5=1+1+1+1+1\nInput: amount = 3, coins = [2]\nOutput: 0\nExplanation: the amount of 3 cannot be made up just with coins of 2.", "link": "https://leetcode.com/problems/coin-change-ii/description/", "difficulty": "Medium", "categories": ["Dynamic_programming"], "code": "from typing import List\ndef change(amount: int, coins: List[int]) -> int:\n    def numberOfWays(i: int, amount: int) -> int:\n        if amount == 0:\n            return 1\n        if i == len(coins):\n            return 0\n        if memo[i][amount] != -1:\n            return memo[i][amount]\n\n        if coins[i] > amount:\n            memo[i][amount] = numberOfWays(i + 1, amount)\n        else:\n            memo[i][amount] = numberOfWays(i, amount - coins[i]) + numberOfWays(i + 1, amount)\n        \n        return memo[i][amount]\n\n    memo = [[-1] * (amount + 1) for _ in range(len(coins))]\n    return numberOfWays(0, amount)", "asserts": ["assert change(10,[10])==1", "assert change(0, [1, 2, 5]) == 1  # Edge case: trying to make 0 with any coins should always return 1", "assert change(11, [5]) == 0  # Amount cannot be made up with given coins", "assert change(0, []) == 1  # Edge case: trying to make 0 without any coins, should return 1 as there's one way of making 0 with no coins", "assert change(5, [5, 1]) == 2  # Amount can be made with given coins: [5], [1, 1, 1, 1, 1]"]}, {"author": "Calvin", "UUID": "e35d1110-85e8-4f50-80aa-91eb976b310b", "question": "Return the factorial of a given number n", "examples": "Input: 5\nOutput: 120\n\nInput: 6\nOutput: 720", "link": NaN, "difficulty": null, "categories": ["Dynamic_programming"], "code": "\ndef fact(n: int) -> int:\n  if n <= 1:\n    return 1\n  return n*fact(n-1)\n", "asserts": ["assert fact(5) == 120", "assert fact(0) == 1", "assert fact(1) == 1", "assert fact(3) == 6", "assert fact(7) == 5040", "assert fact(10) == 3628800", "assert fact(4) == 24", "assert fact(8) == 40320", "assert fact(2) == 2", "assert fact(11) == 39916800"]}], "category": "Dynamic_programming", "prompt_tokens": 767, "total_tokens": 1081, "completion_tokens": 314, "completion": "Find the maximum sum subarray in a given array of integers.\n\n###Code: \n\nfrom typing import List\n\ndef maxSubArray(nums: List[int]) -> int:\n    max_sum = nums[0]\n    current_sum = nums[0]\n    \n    for num in nums[1:]:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    \n    return max_sum\n\n###Testcases: \n\nassert maxSubArray([-2,1,-3,4,-1,2,1,-5,4]) == 6  # Subarray [4,-1,2,1] has the largest sum = 6\nassert maxSubArray([1]) == 1  # Subarray [1] has the largest sum = 1\nassert maxSubArray([5,4,-1,7,8]) == 23  # Subarray [5,4,-1,7,8] has the largest sum = 23\nassert maxSubArray([-2, -3, 4, -1, -2, 1, 5, -3]) == 7  # Subarray [4,-1,-2,1,5] has the largest sum = 7\nassert maxSubArray([-2, -1, -3, -4, -1, -2, -1, -5, -4]) == -1  # Subarray [-1] has the largest sum = -1\n\n[/Example 3]", "temperature": 0.609, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Hafeez", "UUID": "d695e67c-5b0e-4235-8406-30ee6be61173", "question": "N-th Tribonacci Number: The Tribonacci sequence Tn is defined as follows: \n\nT0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n >= 0.\n\nGiven n, return the value of Tn.", "examples": "Input: n = 4\nOutput: 4\nExplanation:\nT_3 = 0 + 1 + 1 = 2\nT_4 = 1 + 1 + 2 = 4", "link": "https://leetcode.com/problems/n-th-tribonacci-number/description/", "difficulty": "Easy", "categories": ["Dynamic_programming"], "code": "def tribonacci(n: int) -> int:\n    dp = {0: 0, 1: 1, 2: 1}\n    def dfs(i):\n        if i in dp:\n            return dp[i]\n        dp[i] = dfs(i - 1) + dfs(i - 2) + dfs(i - 3)\n        return dp[i]\n    \n    return dfs(n)", "asserts": ["assert tribonacci(25)==1389537", "assert tribonacci(0) == 0", "assert tribonacci(1) == 1", "assert tribonacci(2) == 1", "assert tribonacci(3) == 2", "assert tribonacci(5) == 7", "assert tribonacci(7) == 24", "assert tribonacci(10) == 149", "assert tribonacci(15) == 3136", "assert tribonacci(30) == 29249425"]}, {"author": "Hafeez", "UUID": "6aaf1310-7585-4d90-91e7-1f405c9b25e7", "question": "Get Maximum in Generated Array: You are given an integer n. A 0-indexed integer array nums of length n + 1 is generated in the following way:\n\nnums[0] = 0\nnums[1] = 1\nnums[2 * i] = nums[i] when 2 <= 2 * i <= n\nnums[2 * i + 1] = nums[i] + nums[i + 1] when 2 <= 2 * i + 1 <= n\nReturn the maximum integer in the array nums\u200b\u200b\u200b.", "examples": "Input: n = 7\nOutput: 3\nExplanation: According to the given rules:\n  nums[0] = 0\n  nums[1] = 1\n  nums[(1 * 2) = 2] = nums[1] = 1\n  nums[(1 * 2) + 1 = 3] = nums[1] + nums[2] = 1 + 1 = 2\n  nums[(2 * 2) = 4] = nums[2] = 1\n  nums[(2 * 2) + 1 = 5] = nums[2] + nums[3] = 1 + 2 = 3\n  nums[(3 * 2) = 6] = nums[3] = 2\n  nums[(3 * 2) + 1 = 7] = nums[3] + nums[4] = 2 + 1 = 3\nHence, nums = [0,1,1,2,1,3,2,3], and the maximum is max(0,1,1,2,1,3,2,3) = 3.\nInput: n = 2\nOutput: 1\nExplanation: According to the given rules, nums = [0,1,1]. The maximum is max(0,1,1) = 1.\nInput: n = 3\nOutput: 2\nExplanation: According to the given rules, nums = [0,1,1,2]. The maximum is max(0,1,1,2) = 2.", "link": "https://leetcode.com/problems/get-maximum-in-generated-array/", "difficulty": "Easy", "categories": ["Dynamic_programming"], "code": "def getMaximumGenerated(n: int) -> int:\n    if n<2:\n        return n\n    nums=[0]*(n+1)\n    nums[0]=0\n    nums[1]=1\n    for i in range(2,n+1):\n        if i%2==0:\n            nums[i]=nums[i//2]\n        else:\n            nums[i]=nums[i//2]+nums[i//2+1]\n    return max(nums)", "asserts": ["assert getMaximumGenerated(2)==1", "assert getMaximumGenerated(4) == 2", "assert getMaximumGenerated(5) == 3", "assert getMaximumGenerated(8) == 3", "assert getMaximumGenerated(15) == 5", "assert getMaximumGenerated(0) == 0", "assert getMaximumGenerated(1) == 1"]}], "category": "Dynamic_programming", "prompt_tokens": 764, "total_tokens": 1009, "completion_tokens": 245, "completion": "Maximum Subarray: Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.\n\n###Code: \n\ndef maxSubArray(nums: List[int]) -> int:\n    max_sum = float('-inf')\n    current_sum = 0\n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    return max_sum\n\n###Testcases: \n\nassert maxSubArray([-2,1,-3,4,-1,2,1,-5,4])==6\nassert maxSubArray([1])==1\nassert maxSubArray([5,4,-1,7,8])==23\nassert maxSubArray([-2,1,-3,4,-1,2,1,-5,4])==6\nassert maxSubArray([-2,-1,-3,-4,-1,-2,-1,-5,-4])==-1\nassert maxSubArray([1,2,3,4,5])==15\nassert maxSubArray([-1,-2,-3,-4,-5])==-1\n\n[/Example 3]", "temperature": 0.638, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Hafeez", "UUID": "d695e67c-5b0e-4235-8406-30ee6be61173", "question": "N-th Tribonacci Number: The Tribonacci sequence Tn is defined as follows: \n\nT0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n >= 0.\n\nGiven n, return the value of Tn.", "examples": "Input: n = 4\nOutput: 4\nExplanation:\nT_3 = 0 + 1 + 1 = 2\nT_4 = 1 + 1 + 2 = 4", "link": "https://leetcode.com/problems/n-th-tribonacci-number/description/", "difficulty": "Easy", "categories": ["Dynamic_programming"], "code": "def tribonacci(n: int) -> int:\n    dp = {0: 0, 1: 1, 2: 1}\n    def dfs(i):\n        if i in dp:\n            return dp[i]\n        dp[i] = dfs(i - 1) + dfs(i - 2) + dfs(i - 3)\n        return dp[i]\n    \n    return dfs(n)", "asserts": ["assert tribonacci(25)==1389537", "assert tribonacci(0) == 0", "assert tribonacci(1) == 1", "assert tribonacci(2) == 1", "assert tribonacci(3) == 2", "assert tribonacci(5) == 7", "assert tribonacci(7) == 24", "assert tribonacci(10) == 149", "assert tribonacci(15) == 3136", "assert tribonacci(30) == 29249425"]}, {"author": "Hafeez", "UUID": "296ab89e-7208-4f6f-bed1-d623f30e32c9", "question": "Coin Change II: You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.\n\nReturn the number of combinations that make up that amount. If that amount of money cannot be made up by any combination of the coins, return 0.\n\nYou may assume that you have an infinite number of each kind of coin.\n\nThe answer is guaranteed to fit into a signed 32-bit integer.", "examples": "Input: amount = 5, coins = [1,2,5]\nOutput: 4\nExplanation: there are four ways to make up the amount:\n5=5\n5=2+2+1\n5=2+1+1+1\n5=1+1+1+1+1\nInput: amount = 3, coins = [2]\nOutput: 0\nExplanation: the amount of 3 cannot be made up just with coins of 2.", "link": "https://leetcode.com/problems/coin-change-ii/description/", "difficulty": "Medium", "categories": ["Dynamic_programming"], "code": "from typing import List\ndef change(amount: int, coins: List[int]) -> int:\n    def numberOfWays(i: int, amount: int) -> int:\n        if amount == 0:\n            return 1\n        if i == len(coins):\n            return 0\n        if memo[i][amount] != -1:\n            return memo[i][amount]\n\n        if coins[i] > amount:\n            memo[i][amount] = numberOfWays(i + 1, amount)\n        else:\n            memo[i][amount] = numberOfWays(i, amount - coins[i]) + numberOfWays(i + 1, amount)\n        \n        return memo[i][amount]\n\n    memo = [[-1] * (amount + 1) for _ in range(len(coins))]\n    return numberOfWays(0, amount)", "asserts": ["assert change(10,[10])==1", "assert change(0, [1, 2, 5]) == 1  # Edge case: trying to make 0 with any coins should always return 1", "assert change(11, [5]) == 0  # Amount cannot be made up with given coins", "assert change(0, []) == 1  # Edge case: trying to make 0 without any coins, should return 1 as there's one way of making 0 with no coins", "assert change(5, [5, 1]) == 2  # Amount can be made with given coins: [5], [1, 1, 1, 1, 1]"]}], "category": "Dynamic_programming", "prompt_tokens": 888, "total_tokens": 1175, "completion_tokens": 287, "completion": "Maximum Subarray Sum: Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.\n\n###Code:\n\nfrom typing import List\ndef maxSubArray(nums: List[int]) -> int:\n    max_sum = current_sum = nums[0]\n    for num in nums[1:]:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    return max_sum\n\n###Testcases:\n\nassert maxSubArray([-2,1,-3,4,-1,2,1,-5,4]) == 6  # Subarray [4,-1,2,1] has the largest sum = 6\nassert maxSubArray([1]) == 1  # Subarray [1] has the largest sum = 1\nassert maxSubArray([5,4,-1,7,8]) == 23  # Subarray [5,4,-1,7,8] has the largest sum = 23\nassert maxSubArray([-2,-3,-1,-5]) == -1  # Subarray [-1] has the largest sum = -1\nassert maxSubArray([-1,-2,-3,-4,-5]) == -1  # Subarray [-1] has the largest sum = -1\n\n[/Example 3]", "temperature": 0.759, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Calvin", "UUID": "e35d1110-85e8-4f50-80aa-91eb976b310b", "question": "Return the factorial of a given number n", "examples": "Input: 5\nOutput: 120\n\nInput: 6\nOutput: 720", "link": NaN, "difficulty": null, "categories": ["Dynamic_programming"], "code": "\ndef fact(n: int) -> int:\n  if n <= 1:\n    return 1\n  return n*fact(n-1)\n", "asserts": ["assert fact(5) == 120", "assert fact(0) == 1", "assert fact(1) == 1", "assert fact(3) == 6", "assert fact(7) == 5040", "assert fact(10) == 3628800", "assert fact(4) == 24", "assert fact(8) == 40320", "assert fact(2) == 2", "assert fact(11) == 39916800"]}, {"author": "Hafeez", "UUID": "38dca76c-ee6c-4c71-83a9-89240828a3b7", "question": "Best Time to Buy and Sell Stock II: You are given an integer array prices where prices[i] is the price of a given stock on the ith day.\n\nOn each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day.\n\nFind and return the maximum profit you can achieve.", "examples": "Input: prices = [7,1,5,3,6,4]\nOutput: 7\nExplanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\nThen buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.\nTotal profit is 4 + 3 = 7.\nInput: prices = [7,6,4,3,1]\nOutput: 0\nExplanation: There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0.", "link": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/", "difficulty": "Medium", "categories": ["Dynamic_programming"], "code": "from typing import List\ndef maxProfit(prices: List[int]) -> int:\n    cur_hold, cur_not_hold = -float('inf'), 0\n    \n    for stock_price in prices:\n        \n        prev_hold, prev_not_hold = cur_hold, cur_not_hold\n        cur_hold = max( prev_hold, prev_not_hold - stock_price )\n        cur_not_hold = max( prev_not_hold, prev_hold + stock_price )\n    return cur_not_hold", "asserts": ["assert maxProfit([1,2,3,4,5])==4", "assert maxProfit([1,2,100,2,1]) == 99"]}], "category": "Dynamic_programming", "prompt_tokens": 572, "total_tokens": 793, "completion_tokens": 221, "completion": "Find the length of the longest increasing subsequence in an integer array.\n\n###Code: \n\nfrom typing import List\n\ndef lengthOfLIS(nums: List[int]) -> int:\n    dp = [1] * len(nums)\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n\n###Testcases: \n\nassert lengthOfLIS([10, 9, 2, 5, 3, 7, 101, 18]) == 4\nassert lengthOfLIS([0, 1, 0, 3, 2, 3]) == 4\nassert lengthOfLIS([7, 7, 7, 7, 7, 7, 7]) == 1\nassert lengthOfLIS([4, 10, 4, 3, 8, 9]) == 3\n\n[/Example 3]", "temperature": 0.932, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Hafeez", "UUID": "38dca76c-ee6c-4c71-83a9-89240828a3b7", "question": "Best Time to Buy and Sell Stock II: You are given an integer array prices where prices[i] is the price of a given stock on the ith day.\n\nOn each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day.\n\nFind and return the maximum profit you can achieve.", "examples": "Input: prices = [7,1,5,3,6,4]\nOutput: 7\nExplanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\nThen buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.\nTotal profit is 4 + 3 = 7.\nInput: prices = [7,6,4,3,1]\nOutput: 0\nExplanation: There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0.", "link": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/", "difficulty": "Medium", "categories": ["Dynamic_programming"], "code": "from typing import List\ndef maxProfit(prices: List[int]) -> int:\n    cur_hold, cur_not_hold = -float('inf'), 0\n    \n    for stock_price in prices:\n        \n        prev_hold, prev_not_hold = cur_hold, cur_not_hold\n        cur_hold = max( prev_hold, prev_not_hold - stock_price )\n        cur_not_hold = max( prev_not_hold, prev_hold + stock_price )\n    return cur_not_hold", "asserts": ["assert maxProfit([1,2,3,4,5])==4", "assert maxProfit([1,2,100,2,1]) == 99"]}, {"author": "Hafeez", "UUID": "d695e67c-5b0e-4235-8406-30ee6be61173", "question": "N-th Tribonacci Number: The Tribonacci sequence Tn is defined as follows: \n\nT0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n >= 0.\n\nGiven n, return the value of Tn.", "examples": "Input: n = 4\nOutput: 4\nExplanation:\nT_3 = 0 + 1 + 1 = 2\nT_4 = 1 + 1 + 2 = 4", "link": "https://leetcode.com/problems/n-th-tribonacci-number/description/", "difficulty": "Easy", "categories": ["Dynamic_programming"], "code": "def tribonacci(n: int) -> int:\n    dp = {0: 0, 1: 1, 2: 1}\n    def dfs(i):\n        if i in dp:\n            return dp[i]\n        dp[i] = dfs(i - 1) + dfs(i - 2) + dfs(i - 3)\n        return dp[i]\n    \n    return dfs(n)", "asserts": ["assert tribonacci(25)==1389537", "assert tribonacci(0) == 0", "assert tribonacci(1) == 1", "assert tribonacci(2) == 1", "assert tribonacci(3) == 2", "assert tribonacci(5) == 7", "assert tribonacci(7) == 24", "assert tribonacci(10) == 149", "assert tribonacci(15) == 3136", "assert tribonacci(30) == 29249425"]}], "category": "Dynamic_programming", "prompt_tokens": 693, "total_tokens": 882, "completion_tokens": 189, "completion": "Maximum Subarray: Given an integer array nums, find the contiguous subarray (containing at least one number) with the largest sum and return its sum.\n\n###Code: \n\ndef maxSubArray(nums: List[int]) -> int:\n    max_sum = nums[0]\n    current_sum = nums[0]\n    \n    for num in nums[1:]:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    \n    return max_sum\n\n###Testcases: \n\nassert maxSubArray([-2,1,-3,4,-1,2,1,-5,4])==6\nassert maxSubArray([1])==1\nassert maxSubArray([5,4,-1,7,8])==23\nassert maxSubArray([-2,-1,-3,-4,-1,-2,-1,-5,-4])==-1\n\n[/Example 3]", "temperature": 0.856, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Calvin", "UUID": "51a5caf9-241f-4de3-9ee2-9420490b73d7", "question": "Given a set[] of non-negative integers and a value sum, return the subset of the given set whose sum is equal to the given sum or None if one doesn't exist\n", "examples": "Input: set = [1, 2, 3, 4, 5], sum = 10\nOutput: [1, 2, 3, 4]", "link": "https://www.geeksforgeeks.org/subset-sum-problem-dp-25/", "difficulty": null, "categories": ["Dynamic_programming"], "code": "def subsetsum(fullset: list, target_sum: int) -> set:\n    def subsetSum_helper(cur_idx: int, fullset: list, target_sum: int, subset: list):\n        if target_sum == 0:\n            return subset\n        if (cur_idx == len(fullset)):\n            return None\n        excluding = subsetSum_helper(cur_idx + 1, fullset, target_sum, subset)\n          \n        if excluding is not None:\n            return excluding\n        elif fullset[cur_idx] <= target_sum:\n            subset.append(fullset[cur_idx])\n            including = subsetSum_helper(cur_idx + 1, fullset, target_sum - fullset[cur_idx], subset)\n            if including!=None:\n                return including\n            else:\n                subset.pop()\n            return None\n    return subsetSum_helper(0, fullset, target_sum, [])\n", "asserts": ["assert set(subsetsum([3, 34, 4, 12, 5, 2], 9)) == {4,5}", "assert subsetsum([1, 8, 2, 7, 4], 14) == [8, 2, 4]", "assert subsetsum([10, 12, 15, 6, 19], 21) == [15, 6]", "assert subsetsum([5, 10, 12, 13, 15, 18], 30) == [12, 18]", "assert subsetsum([5, 3, 9, 12, 6, 15], 27) == [12, 15]", "assert subsetsum([2, 3, 7, 8, 10], 11) == [3, 8]", "assert subsetsum([6, 2, 7, 11, 8], 16) == [6, 2, 8]", "assert subsetsum([5, 7, 1, 14, 6], 13) == [7, 6]", "assert subsetsum([1], 1) == [1]", "assert subsetsum([2, 5, 8, 4], 0) == []", "assert subsetsum([], 5) == None", "assert subsetsum([-1, -2, -3, -4, -5], -10) == None  # Negative numbers are not allowed according to the question", "assert subsetsum([4, 1, 2, 5, 12, 7], 9) == [2, 7]", "assert subsetsum([3, 5, 8, 4], 22) == None  # Sum exceeds the sum of all elements"]}, {"author": "Calvin", "UUID": "5e7011e5-fee4-4c1a-a98f-3b81e50508cc", "question": "Return nth number in the fibonacci sequence", "examples": "Input: 9\nOutput: 34\n\nInput: 7\nOutput: 13", "link": NaN, "difficulty": null, "categories": ["Dynamic_programming"], "code": "def fibonacci(n: int) -> int:\n    a = 0\n    b = 1\n    if n < 0:\n        print(\"Incorrect input\")\n    elif n == 0:\n        return a\n    elif n == 1:\n        return b\n    else:\n        for i in range(2, n+1):\n            c = a + b\n            a = b\n            b = c\n        return b\n    b = c\n    return fib(n-1, a, b)\n", "asserts": ["assert fibonacci(9) == 34", "assert fibonacci(10) == 55", "assert fibonacci(5) == 5", "assert fibonacci(2) == 1", "assert fibonacci(0) == 0", "assert fibonacci(11) == 89", "assert fibonacci(15) == 610", "assert fibonacci(20) == 6765", "assert fibonacci(25) == 75025", "assert fibonacci(3) == 2", "assert fibonacci(1) == 1", "assert fibonacci(6) == 8", "assert fibonacci(30) == 832040", "assert fibonacci(35) == 9227465", "assert fibonacci(40) == 102334155"]}], "category": "Dynamic_programming", "prompt_tokens": 1073, "total_tokens": 1513, "completion_tokens": 440, "completion": "Find the length of the longest increasing subsequence in an array of integers.\n\n###Code: \n\n```python\ndef length_of_lis(nums: List[int]) -> int:\n    if not nums:\n        return 0\n    dp = [1] * len(nums)\n    for i in range(len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n```\n\n###Testcases: \n\n```python\nassert length_of_lis([10, 9, 2, 5, 3, 7, 101, 18]) == 4  # Longest increasing subsequence is [2, 3, 7, 101]\nassert length_of_lis([0, 1, 0, 3, 2, 3]) == 4  # Longest increasing subsequence is [0, 1, 2, 3]\nassert length_of_lis([7, 7, 7, 7, 7, 7, 7]) == 1  # Longest increasing subsequence is [7]\nassert length_of_lis([4, 10, 4, 3, 8, 9]) == 3  # Longest increasing subsequence is [4, 8, 9]\nassert length_of_lis([1, 3, 6, 7, 9, 4, 10, 5, 6]) == 6  # Longest increasing subsequence is [1, 3, 4, 5, 6, 7]\nassert length_of_lis([3, 4, -1, 0, 6, 2, 3]) == 4  # Longest increasing subsequence is [-1, 0, 2, 3]\nassert length_of_lis([]) == 0  # Empty input\nassert length_of_lis([5]) == 1  # Single element input\n```\n\n[/Example 3]", "temperature": 0.871, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Calvin", "UUID": "e35d1110-85e8-4f50-80aa-91eb976b310b", "question": "Return the factorial of a given number n", "examples": "Input: 5\nOutput: 120\n\nInput: 6\nOutput: 720", "link": NaN, "difficulty": null, "categories": ["Dynamic_programming"], "code": "\ndef fact(n: int) -> int:\n  if n <= 1:\n    return 1\n  return n*fact(n-1)\n", "asserts": ["assert fact(5) == 120", "assert fact(0) == 1", "assert fact(1) == 1", "assert fact(3) == 6", "assert fact(7) == 5040", "assert fact(10) == 3628800", "assert fact(4) == 24", "assert fact(8) == 40320", "assert fact(2) == 2", "assert fact(11) == 39916800"]}, {"author": "Calvin", "UUID": "5e7011e5-fee4-4c1a-a98f-3b81e50508cc", "question": "Return nth number in the fibonacci sequence", "examples": "Input: 9\nOutput: 34\n\nInput: 7\nOutput: 13", "link": NaN, "difficulty": null, "categories": ["Dynamic_programming"], "code": "def fibonacci(n: int) -> int:\n    a = 0\n    b = 1\n    if n < 0:\n        print(\"Incorrect input\")\n    elif n == 0:\n        return a\n    elif n == 1:\n        return b\n    else:\n        for i in range(2, n+1):\n            c = a + b\n            a = b\n            b = c\n        return b\n    b = c\n    return fib(n-1, a, b)\n", "asserts": ["assert fibonacci(9) == 34", "assert fibonacci(10) == 55", "assert fibonacci(5) == 5", "assert fibonacci(2) == 1", "assert fibonacci(0) == 0", "assert fibonacci(11) == 89", "assert fibonacci(15) == 610", "assert fibonacci(20) == 6765", "assert fibonacci(25) == 75025", "assert fibonacci(3) == 2", "assert fibonacci(1) == 1", "assert fibonacci(6) == 8", "assert fibonacci(30) == 832040", "assert fibonacci(35) == 9227465", "assert fibonacci(40) == 102334155"]}], "category": "Dynamic_programming", "prompt_tokens": 614, "total_tokens": 909, "completion_tokens": 295, "completion": "Find the length of the longest increasing subsequence in a given list of integers.\n\n###Code: \n\n```python\ndef lengthOfLIS(nums: List[int]) -> int:\n    if not nums:\n        return 0\n    dp = [1] * len(nums)\n    for i in range(len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n```\n\n###Testcases: \n\n```python\nassert lengthOfLIS([10, 9, 2, 5, 3, 7, 101, 18]) == 4\nassert lengthOfLIS([10, 22, 9, 33, 21, 50, 41, 60, 80]) == 6\nassert lengthOfLIS([3, 4, -1, 0, 6, 2, 3]) == 4\nassert lengthOfLIS([1, 3, 6, 7, 9, 4, 10, 5, 6]) == 6\nassert lengthOfLIS([5, 7, -24, 12, 10, 2, 3, 12, 5, 6, 35]) == 5\n```\n\n[/Example 3]", "temperature": 0.69, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Hafeez", "UUID": "38dca76c-ee6c-4c71-83a9-89240828a3b7", "question": "Best Time to Buy and Sell Stock II: You are given an integer array prices where prices[i] is the price of a given stock on the ith day.\n\nOn each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day.\n\nFind and return the maximum profit you can achieve.", "examples": "Input: prices = [7,1,5,3,6,4]\nOutput: 7\nExplanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\nThen buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.\nTotal profit is 4 + 3 = 7.\nInput: prices = [7,6,4,3,1]\nOutput: 0\nExplanation: There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0.", "link": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/", "difficulty": "Medium", "categories": ["Dynamic_programming"], "code": "from typing import List\ndef maxProfit(prices: List[int]) -> int:\n    cur_hold, cur_not_hold = -float('inf'), 0\n    \n    for stock_price in prices:\n        \n        prev_hold, prev_not_hold = cur_hold, cur_not_hold\n        cur_hold = max( prev_hold, prev_not_hold - stock_price )\n        cur_not_hold = max( prev_not_hold, prev_hold + stock_price )\n    return cur_not_hold", "asserts": ["assert maxProfit([1,2,3,4,5])==4", "assert maxProfit([1,2,100,2,1]) == 99"]}, {"author": "Hafeez", "UUID": "d695e67c-5b0e-4235-8406-30ee6be61173", "question": "N-th Tribonacci Number: The Tribonacci sequence Tn is defined as follows: \n\nT0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n >= 0.\n\nGiven n, return the value of Tn.", "examples": "Input: n = 4\nOutput: 4\nExplanation:\nT_3 = 0 + 1 + 1 = 2\nT_4 = 1 + 1 + 2 = 4", "link": "https://leetcode.com/problems/n-th-tribonacci-number/description/", "difficulty": "Easy", "categories": ["Dynamic_programming"], "code": "def tribonacci(n: int) -> int:\n    dp = {0: 0, 1: 1, 2: 1}\n    def dfs(i):\n        if i in dp:\n            return dp[i]\n        dp[i] = dfs(i - 1) + dfs(i - 2) + dfs(i - 3)\n        return dp[i]\n    \n    return dfs(n)", "asserts": ["assert tribonacci(25)==1389537", "assert tribonacci(0) == 0", "assert tribonacci(1) == 1", "assert tribonacci(2) == 1", "assert tribonacci(3) == 2", "assert tribonacci(5) == 7", "assert tribonacci(7) == 24", "assert tribonacci(10) == 149", "assert tribonacci(15) == 3136", "assert tribonacci(30) == 29249425"]}], "category": "Dynamic_programming", "prompt_tokens": 693, "total_tokens": 939, "completion_tokens": 246, "completion": "Maximum Subarray: Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.\n\n###Code:\n\nfrom typing import List\n\ndef maxSubArray(nums: List[int]) -> int:\n    max_sum = nums[0]\n    curr_sum = nums[0]\n    \n    for num in nums[1:]:\n        curr_sum = max(num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n    \n    return max_sum\n\n###Testcases: \n\nassert maxSubArray([-2,1,-3,4,-1,2,1,-5,4])==6\nassert maxSubArray([1])==1\nassert maxSubArray([5,4,-1,7,8])==23\nassert maxSubArray([-2,1,-3,4,-1,2,1,-5,4])==6\nassert maxSubArray([1,2,3,4,5])==15\nassert maxSubArray([-1,-2,-3,-4,-5])== -1\nassert maxSubArray([-5,-4,-3,-2,-1])== -1\n\n[/Example 3]", "temperature": 0.841, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Hafeez", "UUID": "6aaf1310-7585-4d90-91e7-1f405c9b25e7", "question": "Get Maximum in Generated Array: You are given an integer n. A 0-indexed integer array nums of length n + 1 is generated in the following way:\n\nnums[0] = 0\nnums[1] = 1\nnums[2 * i] = nums[i] when 2 <= 2 * i <= n\nnums[2 * i + 1] = nums[i] + nums[i + 1] when 2 <= 2 * i + 1 <= n\nReturn the maximum integer in the array nums\u200b\u200b\u200b.", "examples": "Input: n = 7\nOutput: 3\nExplanation: According to the given rules:\n  nums[0] = 0\n  nums[1] = 1\n  nums[(1 * 2) = 2] = nums[1] = 1\n  nums[(1 * 2) + 1 = 3] = nums[1] + nums[2] = 1 + 1 = 2\n  nums[(2 * 2) = 4] = nums[2] = 1\n  nums[(2 * 2) + 1 = 5] = nums[2] + nums[3] = 1 + 2 = 3\n  nums[(3 * 2) = 6] = nums[3] = 2\n  nums[(3 * 2) + 1 = 7] = nums[3] + nums[4] = 2 + 1 = 3\nHence, nums = [0,1,1,2,1,3,2,3], and the maximum is max(0,1,1,2,1,3,2,3) = 3.\nInput: n = 2\nOutput: 1\nExplanation: According to the given rules, nums = [0,1,1]. The maximum is max(0,1,1) = 1.\nInput: n = 3\nOutput: 2\nExplanation: According to the given rules, nums = [0,1,1,2]. The maximum is max(0,1,1,2) = 2.", "link": "https://leetcode.com/problems/get-maximum-in-generated-array/", "difficulty": "Easy", "categories": ["Dynamic_programming"], "code": "def getMaximumGenerated(n: int) -> int:\n    if n<2:\n        return n\n    nums=[0]*(n+1)\n    nums[0]=0\n    nums[1]=1\n    for i in range(2,n+1):\n        if i%2==0:\n            nums[i]=nums[i//2]\n        else:\n            nums[i]=nums[i//2]+nums[i//2+1]\n    return max(nums)", "asserts": ["assert getMaximumGenerated(2)==1", "assert getMaximumGenerated(4) == 2", "assert getMaximumGenerated(5) == 3", "assert getMaximumGenerated(8) == 3", "assert getMaximumGenerated(15) == 5", "assert getMaximumGenerated(0) == 0", "assert getMaximumGenerated(1) == 1"]}, {"author": "Hafeez", "UUID": "38dca76c-ee6c-4c71-83a9-89240828a3b7", "question": "Best Time to Buy and Sell Stock II: You are given an integer array prices where prices[i] is the price of a given stock on the ith day.\n\nOn each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day.\n\nFind and return the maximum profit you can achieve.", "examples": "Input: prices = [7,1,5,3,6,4]\nOutput: 7\nExplanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\nThen buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.\nTotal profit is 4 + 3 = 7.\nInput: prices = [7,6,4,3,1]\nOutput: 0\nExplanation: There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0.", "link": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/", "difficulty": "Medium", "categories": ["Dynamic_programming"], "code": "from typing import List\ndef maxProfit(prices: List[int]) -> int:\n    cur_hold, cur_not_hold = -float('inf'), 0\n    \n    for stock_price in prices:\n        \n        prev_hold, prev_not_hold = cur_hold, cur_not_hold\n        cur_hold = max( prev_hold, prev_not_hold - stock_price )\n        cur_not_hold = max( prev_not_hold, prev_hold + stock_price )\n    return cur_not_hold", "asserts": ["assert maxProfit([1,2,3,4,5])==4", "assert maxProfit([1,2,100,2,1]) == 99"]}], "category": "Dynamic_programming", "prompt_tokens": 724, "total_tokens": 997, "completion_tokens": 273, "completion": "Find the Minimum Path Sum: Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right, which minimizes the sum of all numbers along its path.\n\nNote: You can only move either down or right at any point in time.\n\n###Code: \n\nfrom typing import List\n\ndef minPathSum(grid: List[List[int]]) -> int:\n    m, n = len(grid), len(grid[0])\n        \n    for i in range(1, n):\n        grid[0][i] += grid[0][i - 1]\n\n    for i in range(1, m):\n        grid[i][0] += grid[i - 1][0]\n    \n    for i in range(1, m):\n        for j in range(1, n):\n            grid[i][j] += min(grid[i - 1][j], grid[i][j - 1])\n    \n    return grid[-1][-1]\n\n###Testcases: \n\nassert minPathSum([[1,3,1],[1,5,1],[4,2,1]]) == 7\nassert minPathSum([[1,2,3],[4,5,6]]) == 12\nassert minPathSum([[1,2],[1,1]]) == 3\n\n[/Example 3]", "temperature": 0.942, "model_name": "gpt-3.5-turbo-1106"}, {"few_shots": [{"author": "Hafeez", "UUID": "38dca76c-ee6c-4c71-83a9-89240828a3b7", "question": "Best Time to Buy and Sell Stock II: You are given an integer array prices where prices[i] is the price of a given stock on the ith day.\n\nOn each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day.\n\nFind and return the maximum profit you can achieve.", "examples": "Input: prices = [7,1,5,3,6,4]\nOutput: 7\nExplanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\nThen buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.\nTotal profit is 4 + 3 = 7.\nInput: prices = [7,6,4,3,1]\nOutput: 0\nExplanation: There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0.", "link": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/", "difficulty": "Medium", "categories": ["Dynamic_programming"], "code": "from typing import List\ndef maxProfit(prices: List[int]) -> int:\n    cur_hold, cur_not_hold = -float('inf'), 0\n    \n    for stock_price in prices:\n        \n        prev_hold, prev_not_hold = cur_hold, cur_not_hold\n        cur_hold = max( prev_hold, prev_not_hold - stock_price )\n        cur_not_hold = max( prev_not_hold, prev_hold + stock_price )\n    return cur_not_hold", "asserts": ["assert maxProfit([1,2,3,4,5])==4", "assert maxProfit([1,2,100,2,1]) == 99"]}, {"author": "Calvin", "UUID": "e35d1110-85e8-4f50-80aa-91eb976b310b", "question": "Return the factorial of a given number n", "examples": "Input: 5\nOutput: 120\n\nInput: 6\nOutput: 720", "link": NaN, "difficulty": null, "categories": ["Dynamic_programming"], "code": "\ndef fact(n: int) -> int:\n  if n <= 1:\n    return 1\n  return n*fact(n-1)\n", "asserts": ["assert fact(5) == 120", "assert fact(0) == 1", "assert fact(1) == 1", "assert fact(3) == 6", "assert fact(7) == 5040", "assert fact(10) == 3628800", "assert fact(4) == 24", "assert fact(8) == 40320", "assert fact(2) == 2", "assert fact(11) == 39916800"]}], "category": "Dynamic_programming", "prompt_tokens": 572, "total_tokens": 791, "completion_tokens": 219, "completion": "Find the maximum subarray sum in a given array of integers.\n\n###Code: \n\nfrom typing import List\n\ndef maxSubArray(nums: List[int]) -> int:\n    max_sum = nums[0]\n    cur_sum = nums[0]\n    \n    for num in nums[1:]:\n        cur_sum = max(num, cur_sum + num)\n        max_sum = max(max_sum, cur_sum)\n        \n    return max_sum\n\n###Testcases: \n\nassert maxSubArray([-2, 1, -3, 4, -1, 2, 1, -5, 4]) == 6\nassert maxSubArray([1]) == 1\nassert maxSubArray([5, 4, -1, 7, 8]) == 23\nassert maxSubArray([-2, -3, 4, -1, -2, 1, 5, -3]) == 7\nassert maxSubArray([-1, -2, -3, -4]) == -1\n\n[/Example 3]", "temperature": 0.665, "model_name": "gpt-3.5-turbo-1106"}]