[{"few_shots": [{"author": "Hafeez", "UUID": "effcb732-1f0d-4caa-8d9f-be914708d4ae", "question": "Repeated Substring Pattern: Given a string s, check if it can be constructed by taking a substring of it and appending multiple copies of the substring together.", "examples": "Input: s = \"aba\"\nOutput: false\nExplanation: It is the substring \"ab\" twice.\nInput: s = \"abcabcabcabc\"\nOutput: true\nExplanation: It is the substring \"abc\" four times or the substring \"abcabc\" twice.", "link": "https://leetcode.com/problems/repeated-substring-pattern/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def repeatedSubstringPattern(s: str) -> bool:\n    n = len(s)\n    for i in range(1, n // 2 + 1):\n        if n % i == 0:\n            pattern = s[:i] * (n // i)\n            if s == pattern:\n                return True\n    return False", "asserts": ["assert repeatedSubstringPattern(\"abab\")==True", "assert repeatedSubstringPattern(\"aaaa\") == True", "assert repeatedSubstringPattern(\"abac\") == False", "assert repeatedSubstringPattern(\"ababab\") == True", "assert repeatedSubstringPattern(\"xyzxyzxyz\") == True", "assert repeatedSubstringPattern(\"aaabaaa\") == False", "assert repeatedSubstringPattern(\"abababab\") == True", "assert repeatedSubstringPattern(\"abcabcab\") == False", "assert repeatedSubstringPattern(\"abbaabba\") == True", "assert repeatedSubstringPattern(\"\") == False", "assert repeatedSubstringPattern(\"a\") == False", "assert repeatedSubstringPattern(\"abacababacab\") == True"]}, {"author": "Hafeez", "UUID": "e811f9cc-fa5e-4ea0-8adb-8cf3ab7c72db", "question": "Detect Pattern of Length M Repeated K or More Times: Given an array of positive integers arr, find a pattern of length m that is repeated k or more times.\n\nA pattern is a subarray (consecutive sub-sequence) that consists of one or more values, repeated multiple times consecutively without overlapping. A pattern is defined by its length and the number of repetitions.\n\nReturn true if there exists a pattern of length m that is repeated k or more times, otherwise return false.", "examples": "Input: arr = [1,2,1,2,1,1,1,3], m = 2, k = 2\nOutput: true\nExplanation: The pattern (1,2) of length 2 is repeated 2 consecutive times. Another valid pattern (2,1) is also repeated 2 times.\nInput: arr = [1,2,1,2,1,3], m = 2, k = 3\nOutput: false\nExplanation: The pattern (1,2) is of length 2 but is repeated only 2 times. There is no pattern of length 2 that is repeated 3 or more times.\n", "link": "https://leetcode.com/problems/detect-pattern-of-length-m-repeated-k-or-more-times/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "from typing import List\ndef containsPattern(arr: List[int], m: int, k: int) -> bool:\n    i = 0\n    while i <= len(arr)-1:\n            p = arr[i:i+m]\n            if p * k == arr[i:i+m*k]:\n                    return True\n            i += 1\n    return False", "asserts": ["assert containsPattern([1,2,4,4,4,4],1,3)==True", "assert containsPattern([1,2,3,1,2,3,1,2,3], 3, 3) == True", "assert containsPattern([1,1,1,2,2,2,3,3], 2, 2) == False", "assert containsPattern([5,5,5,5,5,5,5], 1, 6) == True", "assert containsPattern([1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2], 2, 5) == True", "assert containsPattern([10,100,10,100,10,100,10,10,10,100], 2, 4) == False", "assert containsPattern([3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3], 4, 3) == True"]}], "category": "Pattern", "prompt_tokens": 855, "total_tokens": 940, "completion_tokens": 85, "completion": "Create Patterns without Using Loops: Given an integer n, generate a pattern of numbers from 1 to n without using any loops.\n\n###Code: \n\ndef generatePattern(n: int) -> None:\n    if n <= 0:\n        return\n    generatePattern(n-1)\n    print(n)\n    generatePattern(n-1)\n\n###Testcases: \n\nassert generatePattern(5)\n\n[/Example 3]", "temperature": 0.917}, {"few_shots": [{"author": "Hafeez", "UUID": "effcb732-1f0d-4caa-8d9f-be914708d4ae", "question": "Repeated Substring Pattern: Given a string s, check if it can be constructed by taking a substring of it and appending multiple copies of the substring together.", "examples": "Input: s = \"aba\"\nOutput: false\nExplanation: It is the substring \"ab\" twice.\nInput: s = \"abcabcabcabc\"\nOutput: true\nExplanation: It is the substring \"abc\" four times or the substring \"abcabc\" twice.", "link": "https://leetcode.com/problems/repeated-substring-pattern/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def repeatedSubstringPattern(s: str) -> bool:\n    n = len(s)\n    for i in range(1, n // 2 + 1):\n        if n % i == 0:\n            pattern = s[:i] * (n // i)\n            if s == pattern:\n                return True\n    return False", "asserts": ["assert repeatedSubstringPattern(\"abab\")==True", "assert repeatedSubstringPattern(\"aaaa\") == True", "assert repeatedSubstringPattern(\"abac\") == False", "assert repeatedSubstringPattern(\"ababab\") == True", "assert repeatedSubstringPattern(\"xyzxyzxyz\") == True", "assert repeatedSubstringPattern(\"aaabaaa\") == False", "assert repeatedSubstringPattern(\"abababab\") == True", "assert repeatedSubstringPattern(\"abcabcab\") == False", "assert repeatedSubstringPattern(\"abbaabba\") == True", "assert repeatedSubstringPattern(\"\") == False", "assert repeatedSubstringPattern(\"a\") == False", "assert repeatedSubstringPattern(\"abacababacab\") == True"]}, {"author": "Hafeez", "UUID": "e811f9cc-fa5e-4ea0-8adb-8cf3ab7c72db", "question": "Detect Pattern of Length M Repeated K or More Times: Given an array of positive integers arr, find a pattern of length m that is repeated k or more times.\n\nA pattern is a subarray (consecutive sub-sequence) that consists of one or more values, repeated multiple times consecutively without overlapping. A pattern is defined by its length and the number of repetitions.\n\nReturn true if there exists a pattern of length m that is repeated k or more times, otherwise return false.", "examples": "Input: arr = [1,2,1,2,1,1,1,3], m = 2, k = 2\nOutput: true\nExplanation: The pattern (1,2) of length 2 is repeated 2 consecutive times. Another valid pattern (2,1) is also repeated 2 times.\nInput: arr = [1,2,1,2,1,3], m = 2, k = 3\nOutput: false\nExplanation: The pattern (1,2) is of length 2 but is repeated only 2 times. There is no pattern of length 2 that is repeated 3 or more times.\n", "link": "https://leetcode.com/problems/detect-pattern-of-length-m-repeated-k-or-more-times/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "from typing import List\ndef containsPattern(arr: List[int], m: int, k: int) -> bool:\n    i = 0\n    while i <= len(arr)-1:\n            p = arr[i:i+m]\n            if p * k == arr[i:i+m*k]:\n                    return True\n            i += 1\n    return False", "asserts": ["assert containsPattern([1,2,4,4,4,4],1,3)==True", "assert containsPattern([1,2,3,1,2,3,1,2,3], 3, 3) == True", "assert containsPattern([1,1,1,2,2,2,3,3], 2, 2) == False", "assert containsPattern([5,5,5,5,5,5,5], 1, 6) == True", "assert containsPattern([1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2], 2, 5) == True", "assert containsPattern([10,100,10,100,10,100,10,10,10,100], 2, 4) == False", "assert containsPattern([3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3], 4, 3) == True"]}], "category": "Pattern", "prompt_tokens": 855, "total_tokens": 1153, "completion_tokens": 298, "completion": "Find All Anagrams in a String: Given a string s and a non-empty string p, find all the start indices of p's anagrams in s.\n\nStrings consists of lowercase English letters only.\n\n###Code: \n\nfrom typing import List\ndef findAnagrams(s: str, p: str) -> List[int]:\n    res = []\n    p_count = [0] * 26\n    s_count = [0] * 26\n    for char in p:\n        p_count[ord(char) - ord('a')] += 1\n    for i in range(len(s)):\n        s_count[ord(s[i]) - ord('a')] += 1\n        if i >= len(p):\n            s_count[ord(s[i - len(p)]) - ord('a')] -= 1\n        if s_count == p_count:\n            res.append(i - len(p) + 1)\n    return res\n\n###Testcases: \n\nassert findAnagrams(\"cbaebabacd\", \"abc\")==[0, 6]\nassert findAnagrams(\"abab\", \"ab\")==[0, 1, 2]\nassert findAnagrams(\"baa\", \"aa\")==[1]\nassert findAnagrams(\"acdcaeccde\", \"c\")==[3, 7, 8]\nassert findAnagrams(\"abacbabc\", \"abc\")==[1, 2, 3, 5]\n\n[/Example 3]", "temperature": 0.701}, {"few_shots": [{"author": "Hafeez", "UUID": "effcb732-1f0d-4caa-8d9f-be914708d4ae", "question": "Repeated Substring Pattern: Given a string s, check if it can be constructed by taking a substring of it and appending multiple copies of the substring together.", "examples": "Input: s = \"aba\"\nOutput: false\nExplanation: It is the substring \"ab\" twice.\nInput: s = \"abcabcabcabc\"\nOutput: true\nExplanation: It is the substring \"abc\" four times or the substring \"abcabc\" twice.", "link": "https://leetcode.com/problems/repeated-substring-pattern/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def repeatedSubstringPattern(s: str) -> bool:\n    n = len(s)\n    for i in range(1, n // 2 + 1):\n        if n % i == 0:\n            pattern = s[:i] * (n // i)\n            if s == pattern:\n                return True\n    return False", "asserts": ["assert repeatedSubstringPattern(\"abab\")==True", "assert repeatedSubstringPattern(\"aaaa\") == True", "assert repeatedSubstringPattern(\"abac\") == False", "assert repeatedSubstringPattern(\"ababab\") == True", "assert repeatedSubstringPattern(\"xyzxyzxyz\") == True", "assert repeatedSubstringPattern(\"aaabaaa\") == False", "assert repeatedSubstringPattern(\"abababab\") == True", "assert repeatedSubstringPattern(\"abcabcab\") == False", "assert repeatedSubstringPattern(\"abbaabba\") == True", "assert repeatedSubstringPattern(\"\") == False", "assert repeatedSubstringPattern(\"a\") == False", "assert repeatedSubstringPattern(\"abacababacab\") == True"]}, {"author": "Hafeez", "UUID": "e811f9cc-fa5e-4ea0-8adb-8cf3ab7c72db", "question": "Detect Pattern of Length M Repeated K or More Times: Given an array of positive integers arr, find a pattern of length m that is repeated k or more times.\n\nA pattern is a subarray (consecutive sub-sequence) that consists of one or more values, repeated multiple times consecutively without overlapping. A pattern is defined by its length and the number of repetitions.\n\nReturn true if there exists a pattern of length m that is repeated k or more times, otherwise return false.", "examples": "Input: arr = [1,2,1,2,1,1,1,3], m = 2, k = 2\nOutput: true\nExplanation: The pattern (1,2) of length 2 is repeated 2 consecutive times. Another valid pattern (2,1) is also repeated 2 times.\nInput: arr = [1,2,1,2,1,3], m = 2, k = 3\nOutput: false\nExplanation: The pattern (1,2) is of length 2 but is repeated only 2 times. There is no pattern of length 2 that is repeated 3 or more times.\n", "link": "https://leetcode.com/problems/detect-pattern-of-length-m-repeated-k-or-more-times/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "from typing import List\ndef containsPattern(arr: List[int], m: int, k: int) -> bool:\n    i = 0\n    while i <= len(arr)-1:\n            p = arr[i:i+m]\n            if p * k == arr[i:i+m*k]:\n                    return True\n            i += 1\n    return False", "asserts": ["assert containsPattern([1,2,4,4,4,4],1,3)==True", "assert containsPattern([1,2,3,1,2,3,1,2,3], 3, 3) == True", "assert containsPattern([1,1,1,2,2,2,3,3], 2, 2) == False", "assert containsPattern([5,5,5,5,5,5,5], 1, 6) == True", "assert containsPattern([1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2], 2, 5) == True", "assert containsPattern([10,100,10,100,10,100,10,10,10,100], 2, 4) == False", "assert containsPattern([3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3], 4, 3) == True"]}], "category": "Pattern", "prompt_tokens": 855, "total_tokens": 1162, "completion_tokens": 307, "completion": "Find All Anagrams in a String: Given a string s and a non-empty string p, find all the start indices of p's anagrams in s.\n\nStrings consists of lowercase English letters only.\n\n###Code: \n\nfrom typing import List\ndef findAnagrams(s: str, p: str) -> List[int]:\n    result = []\n    p_count = [0] * 26\n    s_count = [0] * 26\n    for char in p:\n        p_count[ord(char) - ord('a')] += 1\n    for i in range(len(s)):\n        s_count[ord(s[i]) - ord('a')] += 1\n        if i >= len(p):\n            s_count[ord(s[i - len(p)]) - ord('a')] -= 1\n        if s_count == p_count:\n            result.append(i - len(p) + 1)\n    return result\n\n###Testcases: \n\nassert findAnagrams(\"cbaebabacd\", \"abc\") == [0, 6]\nassert findAnagrams(\"abab\", \"ab\") == [0, 1, 2]\nassert findAnagrams(\"baa\", \"aa\") == [1]\nassert findAnagrams(\"aaaaa\", \"a\") == [0, 1, 2, 3, 4]\nassert findAnagrams(\"abacbabc\", \"abc\") == [1, 2, 3, 5]\n\n[/Example 3]", "temperature": 0.642}, {"few_shots": [{"author": "Hafeez", "UUID": "effcb732-1f0d-4caa-8d9f-be914708d4ae", "question": "Repeated Substring Pattern: Given a string s, check if it can be constructed by taking a substring of it and appending multiple copies of the substring together.", "examples": "Input: s = \"aba\"\nOutput: false\nExplanation: It is the substring \"ab\" twice.\nInput: s = \"abcabcabcabc\"\nOutput: true\nExplanation: It is the substring \"abc\" four times or the substring \"abcabc\" twice.", "link": "https://leetcode.com/problems/repeated-substring-pattern/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def repeatedSubstringPattern(s: str) -> bool:\n    n = len(s)\n    for i in range(1, n // 2 + 1):\n        if n % i == 0:\n            pattern = s[:i] * (n // i)\n            if s == pattern:\n                return True\n    return False", "asserts": ["assert repeatedSubstringPattern(\"abab\")==True", "assert repeatedSubstringPattern(\"aaaa\") == True", "assert repeatedSubstringPattern(\"abac\") == False", "assert repeatedSubstringPattern(\"ababab\") == True", "assert repeatedSubstringPattern(\"xyzxyzxyz\") == True", "assert repeatedSubstringPattern(\"aaabaaa\") == False", "assert repeatedSubstringPattern(\"abababab\") == True", "assert repeatedSubstringPattern(\"abcabcab\") == False", "assert repeatedSubstringPattern(\"abbaabba\") == True", "assert repeatedSubstringPattern(\"\") == False", "assert repeatedSubstringPattern(\"a\") == False", "assert repeatedSubstringPattern(\"abacababacab\") == True"]}, {"author": "Hafeez", "UUID": "e811f9cc-fa5e-4ea0-8adb-8cf3ab7c72db", "question": "Detect Pattern of Length M Repeated K or More Times: Given an array of positive integers arr, find a pattern of length m that is repeated k or more times.\n\nA pattern is a subarray (consecutive sub-sequence) that consists of one or more values, repeated multiple times consecutively without overlapping. A pattern is defined by its length and the number of repetitions.\n\nReturn true if there exists a pattern of length m that is repeated k or more times, otherwise return false.", "examples": "Input: arr = [1,2,1,2,1,1,1,3], m = 2, k = 2\nOutput: true\nExplanation: The pattern (1,2) of length 2 is repeated 2 consecutive times. Another valid pattern (2,1) is also repeated 2 times.\nInput: arr = [1,2,1,2,1,3], m = 2, k = 3\nOutput: false\nExplanation: The pattern (1,2) is of length 2 but is repeated only 2 times. There is no pattern of length 2 that is repeated 3 or more times.\n", "link": "https://leetcode.com/problems/detect-pattern-of-length-m-repeated-k-or-more-times/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "from typing import List\ndef containsPattern(arr: List[int], m: int, k: int) -> bool:\n    i = 0\n    while i <= len(arr)-1:\n            p = arr[i:i+m]\n            if p * k == arr[i:i+m*k]:\n                    return True\n            i += 1\n    return False", "asserts": ["assert containsPattern([1,2,4,4,4,4],1,3)==True", "assert containsPattern([1,2,3,1,2,3,1,2,3], 3, 3) == True", "assert containsPattern([1,1,1,2,2,2,3,3], 2, 2) == False", "assert containsPattern([5,5,5,5,5,5,5], 1, 6) == True", "assert containsPattern([1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2], 2, 5) == True", "assert containsPattern([10,100,10,100,10,100,10,10,10,100], 2, 4) == False", "assert containsPattern([3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3], 4, 3) == True"]}], "category": "Pattern", "prompt_tokens": 855, "total_tokens": 1166, "completion_tokens": 311, "completion": "Find All Anagrams in a String: Given a string s and a non-empty string p, find all the start indices of p's anagrams in s.\n\nStrings consists of lowercase English letters only.\n\n###Code: \n\nfrom typing import List\ndef findAnagrams(s: str, p: str) -> List[int]:\n    p_count = [0] * 26\n    for char in p:\n        p_count[ord(char) - ord('a')] += 1\n    \n    s_count = [0] * 26\n    result = []\n    for i in range(len(s)):\n        s_count[ord(s[i]) - ord('a')] += 1\n        if i >= len(p):\n            s_count[ord(s[i - len(p)]) - ord('a')] -= 1\n        if s_count == p_count:\n            result.append(i - len(p) + 1)\n    return result\n\n###Testcases: \n\nassert findAnagrams(\"cbaebabacd\", \"abc\")==[0, 6]\nassert findAnagrams(\"abab\", \"ab\")==[0, 1, 2]\nassert findAnagrams(\"baa\", \"aa\")==[1]\nassert findAnagrams(\"aabaabaa\", \"aaba\")==[0, 1, 4, 5]\nassert findAnagrams(\"abacd\", \"abc\")==[0]\nassert findAnagrams(\"aaa\", \"a\")==[0, 1, 2]\n\n[/Example 3]", "temperature": 0.772}, {"few_shots": [{"author": "Hafeez", "UUID": "effcb732-1f0d-4caa-8d9f-be914708d4ae", "question": "Repeated Substring Pattern: Given a string s, check if it can be constructed by taking a substring of it and appending multiple copies of the substring together.", "examples": "Input: s = \"aba\"\nOutput: false\nExplanation: It is the substring \"ab\" twice.\nInput: s = \"abcabcabcabc\"\nOutput: true\nExplanation: It is the substring \"abc\" four times or the substring \"abcabc\" twice.", "link": "https://leetcode.com/problems/repeated-substring-pattern/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def repeatedSubstringPattern(s: str) -> bool:\n    n = len(s)\n    for i in range(1, n // 2 + 1):\n        if n % i == 0:\n            pattern = s[:i] * (n // i)\n            if s == pattern:\n                return True\n    return False", "asserts": ["assert repeatedSubstringPattern(\"abab\")==True", "assert repeatedSubstringPattern(\"aaaa\") == True", "assert repeatedSubstringPattern(\"abac\") == False", "assert repeatedSubstringPattern(\"ababab\") == True", "assert repeatedSubstringPattern(\"xyzxyzxyz\") == True", "assert repeatedSubstringPattern(\"aaabaaa\") == False", "assert repeatedSubstringPattern(\"abababab\") == True", "assert repeatedSubstringPattern(\"abcabcab\") == False", "assert repeatedSubstringPattern(\"abbaabba\") == True", "assert repeatedSubstringPattern(\"\") == False", "assert repeatedSubstringPattern(\"a\") == False", "assert repeatedSubstringPattern(\"abacababacab\") == True"]}, {"author": "Hafeez", "UUID": "e811f9cc-fa5e-4ea0-8adb-8cf3ab7c72db", "question": "Detect Pattern of Length M Repeated K or More Times: Given an array of positive integers arr, find a pattern of length m that is repeated k or more times.\n\nA pattern is a subarray (consecutive sub-sequence) that consists of one or more values, repeated multiple times consecutively without overlapping. A pattern is defined by its length and the number of repetitions.\n\nReturn true if there exists a pattern of length m that is repeated k or more times, otherwise return false.", "examples": "Input: arr = [1,2,1,2,1,1,1,3], m = 2, k = 2\nOutput: true\nExplanation: The pattern (1,2) of length 2 is repeated 2 consecutive times. Another valid pattern (2,1) is also repeated 2 times.\nInput: arr = [1,2,1,2,1,3], m = 2, k = 3\nOutput: false\nExplanation: The pattern (1,2) is of length 2 but is repeated only 2 times. There is no pattern of length 2 that is repeated 3 or more times.\n", "link": "https://leetcode.com/problems/detect-pattern-of-length-m-repeated-k-or-more-times/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "from typing import List\ndef containsPattern(arr: List[int], m: int, k: int) -> bool:\n    i = 0\n    while i <= len(arr)-1:\n            p = arr[i:i+m]\n            if p * k == arr[i:i+m*k]:\n                    return True\n            i += 1\n    return False", "asserts": ["assert containsPattern([1,2,4,4,4,4],1,3)==True", "assert containsPattern([1,2,3,1,2,3,1,2,3], 3, 3) == True", "assert containsPattern([1,1,1,2,2,2,3,3], 2, 2) == False", "assert containsPattern([5,5,5,5,5,5,5], 1, 6) == True", "assert containsPattern([1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2], 2, 5) == True", "assert containsPattern([10,100,10,100,10,100,10,10,10,100], 2, 4) == False", "assert containsPattern([3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3], 4, 3) == True"]}], "category": "Pattern", "prompt_tokens": 855, "total_tokens": 1201, "completion_tokens": 346, "completion": "Find All Anagrams in a String: Given a string s and a non-empty string p, find all the start indices of p's anagrams in s.\n\nStrings consists of lowercase English letters only.\n\n###Code: \n\nfrom typing import List\ndef findAnagrams(s: str, p: str) -> List[int]:\n    res = []\n    p_hash = {}\n    for char in p:\n        if char in p_hash:\n            p_hash[char] += 1\n        else:\n            p_hash[char] = 1\n    \n    s_hash = {}\n    for i in range(len(s)):\n        if s[i] in s_hash:\n            s_hash[s[i]] += 1\n        else:\n            s_hash[s[i]] = 1\n        \n        if i >= len(p):\n            if s_hash[s[i - len(p)]] == 1:\n                del s_hash[s[i - len(p)]]\n            else:\n                s_hash[s[i - len(p)]] -= 1\n            \n        if s_hash == p_hash:\n            res.append(i - len(p) + 1)\n    \n    return res\n\n###Testcases: \n\nassert findAnagrams(\"cbaebabacd\", \"abc\") == [0, 6]\nassert findAnagrams(\"abab\", \"ab\") == [0, 1, 2]\nassert findAnagrams(\"aaaaaaaaaa\", \"a\") == [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nassert findAnagrams(\"abacbabc\", \"abc\") == [1, 2, 3, 5]\n\n[/Example 3]", "temperature": 0.987}, {"few_shots": [{"author": "Hafeez", "UUID": "effcb732-1f0d-4caa-8d9f-be914708d4ae", "question": "Repeated Substring Pattern: Given a string s, check if it can be constructed by taking a substring of it and appending multiple copies of the substring together.", "examples": "Input: s = \"aba\"\nOutput: false\nExplanation: It is the substring \"ab\" twice.\nInput: s = \"abcabcabcabc\"\nOutput: true\nExplanation: It is the substring \"abc\" four times or the substring \"abcabc\" twice.", "link": "https://leetcode.com/problems/repeated-substring-pattern/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def repeatedSubstringPattern(s: str) -> bool:\n    n = len(s)\n    for i in range(1, n // 2 + 1):\n        if n % i == 0:\n            pattern = s[:i] * (n // i)\n            if s == pattern:\n                return True\n    return False", "asserts": ["assert repeatedSubstringPattern(\"abab\")==True", "assert repeatedSubstringPattern(\"aaaa\") == True", "assert repeatedSubstringPattern(\"abac\") == False", "assert repeatedSubstringPattern(\"ababab\") == True", "assert repeatedSubstringPattern(\"xyzxyzxyz\") == True", "assert repeatedSubstringPattern(\"aaabaaa\") == False", "assert repeatedSubstringPattern(\"abababab\") == True", "assert repeatedSubstringPattern(\"abcabcab\") == False", "assert repeatedSubstringPattern(\"abbaabba\") == True", "assert repeatedSubstringPattern(\"\") == False", "assert repeatedSubstringPattern(\"a\") == False", "assert repeatedSubstringPattern(\"abacababacab\") == True"]}, {"author": "Hafeez", "UUID": "e811f9cc-fa5e-4ea0-8adb-8cf3ab7c72db", "question": "Detect Pattern of Length M Repeated K or More Times: Given an array of positive integers arr, find a pattern of length m that is repeated k or more times.\n\nA pattern is a subarray (consecutive sub-sequence) that consists of one or more values, repeated multiple times consecutively without overlapping. A pattern is defined by its length and the number of repetitions.\n\nReturn true if there exists a pattern of length m that is repeated k or more times, otherwise return false.", "examples": "Input: arr = [1,2,1,2,1,1,1,3], m = 2, k = 2\nOutput: true\nExplanation: The pattern (1,2) of length 2 is repeated 2 consecutive times. Another valid pattern (2,1) is also repeated 2 times.\nInput: arr = [1,2,1,2,1,3], m = 2, k = 3\nOutput: false\nExplanation: The pattern (1,2) is of length 2 but is repeated only 2 times. There is no pattern of length 2 that is repeated 3 or more times.\n", "link": "https://leetcode.com/problems/detect-pattern-of-length-m-repeated-k-or-more-times/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "from typing import List\ndef containsPattern(arr: List[int], m: int, k: int) -> bool:\n    i = 0\n    while i <= len(arr)-1:\n            p = arr[i:i+m]\n            if p * k == arr[i:i+m*k]:\n                    return True\n            i += 1\n    return False", "asserts": ["assert containsPattern([1,2,4,4,4,4],1,3)==True", "assert containsPattern([1,2,3,1,2,3,1,2,3], 3, 3) == True", "assert containsPattern([1,1,1,2,2,2,3,3], 2, 2) == False", "assert containsPattern([5,5,5,5,5,5,5], 1, 6) == True", "assert containsPattern([1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2], 2, 5) == True", "assert containsPattern([10,100,10,100,10,100,10,10,10,100], 2, 4) == False", "assert containsPattern([3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3], 4, 3) == True"]}], "category": "Pattern", "prompt_tokens": 855, "total_tokens": 1156, "completion_tokens": 301, "completion": "Find All Anagrams in a String: Given a string s and a non-empty string p, find all the start indices of p's anagrams in s.\n\n###Code: \n\nfrom typing import List\ndef findAnagrams(s: str, p: str) -> List[int]:\n    result = []\n    p_count = [0] * 26\n    s_count = [0] * 26\n    for char in p:\n        p_count[ord(char) - ord('a')] += 1\n    for i in range(len(s)):\n        s_count[ord(s[i]) - ord('a')] += 1\n        if i >= len(p):\n            s_count[ord(s[i - len(p)]) - ord('a')] -= 1\n        if s_count == p_count:\n            result.append(i - len(p) + 1)\n    return result\n\n###Testcases: \n\nassert findAnagrams(\"cbaebabacd\", \"abc\") == [0, 6]\nassert findAnagrams(\"abab\", \"ab\") == [0, 1, 2]\nassert findAnagrams(\"af\", \"be\") == []\nassert findAnagrams(\"afbe\", \"be\") == [1]\nassert findAnagrams(\"aabbccdd\", \"abcd\") == [0, 1, 2, 3, 4]\nassert findAnagrams(\"abcdefg\", \"xyz\") == []\n\n[/Example 3]", "temperature": 0.796}, {"few_shots": [{"author": "Hafeez", "UUID": "effcb732-1f0d-4caa-8d9f-be914708d4ae", "question": "Repeated Substring Pattern: Given a string s, check if it can be constructed by taking a substring of it and appending multiple copies of the substring together.", "examples": "Input: s = \"aba\"\nOutput: false\nExplanation: It is the substring \"ab\" twice.\nInput: s = \"abcabcabcabc\"\nOutput: true\nExplanation: It is the substring \"abc\" four times or the substring \"abcabc\" twice.", "link": "https://leetcode.com/problems/repeated-substring-pattern/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def repeatedSubstringPattern(s: str) -> bool:\n    n = len(s)\n    for i in range(1, n // 2 + 1):\n        if n % i == 0:\n            pattern = s[:i] * (n // i)\n            if s == pattern:\n                return True\n    return False", "asserts": ["assert repeatedSubstringPattern(\"abab\")==True", "assert repeatedSubstringPattern(\"aaaa\") == True", "assert repeatedSubstringPattern(\"abac\") == False", "assert repeatedSubstringPattern(\"ababab\") == True", "assert repeatedSubstringPattern(\"xyzxyzxyz\") == True", "assert repeatedSubstringPattern(\"aaabaaa\") == False", "assert repeatedSubstringPattern(\"abababab\") == True", "assert repeatedSubstringPattern(\"abcabcab\") == False", "assert repeatedSubstringPattern(\"abbaabba\") == True", "assert repeatedSubstringPattern(\"\") == False", "assert repeatedSubstringPattern(\"a\") == False", "assert repeatedSubstringPattern(\"abacababacab\") == True"]}, {"author": "Hafeez", "UUID": "e811f9cc-fa5e-4ea0-8adb-8cf3ab7c72db", "question": "Detect Pattern of Length M Repeated K or More Times: Given an array of positive integers arr, find a pattern of length m that is repeated k or more times.\n\nA pattern is a subarray (consecutive sub-sequence) that consists of one or more values, repeated multiple times consecutively without overlapping. A pattern is defined by its length and the number of repetitions.\n\nReturn true if there exists a pattern of length m that is repeated k or more times, otherwise return false.", "examples": "Input: arr = [1,2,1,2,1,1,1,3], m = 2, k = 2\nOutput: true\nExplanation: The pattern (1,2) of length 2 is repeated 2 consecutive times. Another valid pattern (2,1) is also repeated 2 times.\nInput: arr = [1,2,1,2,1,3], m = 2, k = 3\nOutput: false\nExplanation: The pattern (1,2) is of length 2 but is repeated only 2 times. There is no pattern of length 2 that is repeated 3 or more times.\n", "link": "https://leetcode.com/problems/detect-pattern-of-length-m-repeated-k-or-more-times/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "from typing import List\ndef containsPattern(arr: List[int], m: int, k: int) -> bool:\n    i = 0\n    while i <= len(arr)-1:\n            p = arr[i:i+m]\n            if p * k == arr[i:i+m*k]:\n                    return True\n            i += 1\n    return False", "asserts": ["assert containsPattern([1,2,4,4,4,4],1,3)==True", "assert containsPattern([1,2,3,1,2,3,1,2,3], 3, 3) == True", "assert containsPattern([1,1,1,2,2,2,3,3], 2, 2) == False", "assert containsPattern([5,5,5,5,5,5,5], 1, 6) == True", "assert containsPattern([1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2], 2, 5) == True", "assert containsPattern([10,100,10,100,10,100,10,10,10,100], 2, 4) == False", "assert containsPattern([3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3], 4, 3) == True"]}], "category": "Pattern", "prompt_tokens": 855, "total_tokens": 1163, "completion_tokens": 308, "completion": "Find All Anagrams in a String: Given a string s and a non-empty string p, find all the start indices of p's anagrams in s.\n\nStrings consists of lowercase English letters only.\n\n###Code: \n\nfrom typing import List\ndef findAnagrams(s: str, p: str) -> List[int]:\n        res = []\n        p_count = [0] * 26\n        s_count = [0] * 26\n        for ch in p:\n            p_count[ord(ch) - ord('a')] += 1\n        for i in range(len(s)):\n            s_count[ord(s[i]) - ord('a')] += 1\n            if i >= len(p):\n                s_count[ord(s[i - len(p)]) - ord('a')] -= 1\n            if p_count == s_count:\n                res.append(i - len(p) + 1)\n        return res\n\n###Testcases: \n\nassert findAnagrams(\"cbaebabacd\", \"abc\")==[0, 6]\nassert findAnagrams(\"abab\", \"ab\")==[0, 1, 2]\nassert findAnagrams(\"af\", \"be\")==[]\nassert findAnagrams(\"aaaaaaaaaa\", \"aa\")==[0, 1, 2, 3, 4, 5, 6, 7]\nassert findAnagrams(\"abacbabc\", \"abc\")==[1, 2, 3, 5]\n\n[/Example 3]", "temperature": 0.853}, {"few_shots": [{"author": "Hafeez", "UUID": "effcb732-1f0d-4caa-8d9f-be914708d4ae", "question": "Repeated Substring Pattern: Given a string s, check if it can be constructed by taking a substring of it and appending multiple copies of the substring together.", "examples": "Input: s = \"aba\"\nOutput: false\nExplanation: It is the substring \"ab\" twice.\nInput: s = \"abcabcabcabc\"\nOutput: true\nExplanation: It is the substring \"abc\" four times or the substring \"abcabc\" twice.", "link": "https://leetcode.com/problems/repeated-substring-pattern/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def repeatedSubstringPattern(s: str) -> bool:\n    n = len(s)\n    for i in range(1, n // 2 + 1):\n        if n % i == 0:\n            pattern = s[:i] * (n // i)\n            if s == pattern:\n                return True\n    return False", "asserts": ["assert repeatedSubstringPattern(\"abab\")==True", "assert repeatedSubstringPattern(\"aaaa\") == True", "assert repeatedSubstringPattern(\"abac\") == False", "assert repeatedSubstringPattern(\"ababab\") == True", "assert repeatedSubstringPattern(\"xyzxyzxyz\") == True", "assert repeatedSubstringPattern(\"aaabaaa\") == False", "assert repeatedSubstringPattern(\"abababab\") == True", "assert repeatedSubstringPattern(\"abcabcab\") == False", "assert repeatedSubstringPattern(\"abbaabba\") == True", "assert repeatedSubstringPattern(\"\") == False", "assert repeatedSubstringPattern(\"a\") == False", "assert repeatedSubstringPattern(\"abacababacab\") == True"]}, {"author": "Hafeez", "UUID": "e811f9cc-fa5e-4ea0-8adb-8cf3ab7c72db", "question": "Detect Pattern of Length M Repeated K or More Times: Given an array of positive integers arr, find a pattern of length m that is repeated k or more times.\n\nA pattern is a subarray (consecutive sub-sequence) that consists of one or more values, repeated multiple times consecutively without overlapping. A pattern is defined by its length and the number of repetitions.\n\nReturn true if there exists a pattern of length m that is repeated k or more times, otherwise return false.", "examples": "Input: arr = [1,2,1,2,1,1,1,3], m = 2, k = 2\nOutput: true\nExplanation: The pattern (1,2) of length 2 is repeated 2 consecutive times. Another valid pattern (2,1) is also repeated 2 times.\nInput: arr = [1,2,1,2,1,3], m = 2, k = 3\nOutput: false\nExplanation: The pattern (1,2) is of length 2 but is repeated only 2 times. There is no pattern of length 2 that is repeated 3 or more times.\n", "link": "https://leetcode.com/problems/detect-pattern-of-length-m-repeated-k-or-more-times/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "from typing import List\ndef containsPattern(arr: List[int], m: int, k: int) -> bool:\n    i = 0\n    while i <= len(arr)-1:\n            p = arr[i:i+m]\n            if p * k == arr[i:i+m*k]:\n                    return True\n            i += 1\n    return False", "asserts": ["assert containsPattern([1,2,4,4,4,4],1,3)==True", "assert containsPattern([1,2,3,1,2,3,1,2,3], 3, 3) == True", "assert containsPattern([1,1,1,2,2,2,3,3], 2, 2) == False", "assert containsPattern([5,5,5,5,5,5,5], 1, 6) == True", "assert containsPattern([1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2], 2, 5) == True", "assert containsPattern([10,100,10,100,10,100,10,10,10,100], 2, 4) == False", "assert containsPattern([3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3], 4, 3) == True"]}], "category": "Pattern", "prompt_tokens": 855, "total_tokens": 1215, "completion_tokens": 360, "completion": "Find All Anagrams in a String: Given a string s and a non-empty string p, find all the start indices of p's anagrams in s.\n\nStrings consists of lowercase English letters only.\n\n###Code: \n\nfrom typing import List\ndef findAnagrams(s: str, p: str) -> List[int]:\n    result = []\n    p_count = [0] * 26\n    for char in p:\n        p_count[ord(char) - ord('a')] += 1\n    s_count = [0] * 26\n    for i in range(len(s)):\n        s_count[ord(s[i]) - ord('a')] += 1\n        if i >= len(p):\n            s_count[ord(s[i - len(p)]) - ord('a')] -= 1\n        if s_count == p_count:\n            result.append(i - len(p) + 1)\n    return result\n\n###Testcases: \n\nassert findAnagrams(\"cbaebabacd\", \"abc\") == [0, 6]\nassert findAnagrams(\"abab\", \"ab\") == [0, 1, 2]\nassert findAnagrams(\"acdabca\", \"a\") == [0, 3, 4, 5]\nassert findAnagrams(\"ababababab\", \"a\") == [0, 2, 4, 6, 8]\nassert findAnagrams(\"aaaaa\", \"a\") == [0, 1, 2, 3, 4]\nassert findAnagrams(\"abcdefghijklmnopqrstuvwxyz\", \"zyxwvutsrqponmlkjihgfedcba\") == [0]\nassert findAnagrams(\"dictionary\", \"counter\") == []\n\n[/Example 3]", "temperature": 0.875}, {"few_shots": [{"author": "Hafeez", "UUID": "effcb732-1f0d-4caa-8d9f-be914708d4ae", "question": "Repeated Substring Pattern: Given a string s, check if it can be constructed by taking a substring of it and appending multiple copies of the substring together.", "examples": "Input: s = \"aba\"\nOutput: false\nExplanation: It is the substring \"ab\" twice.\nInput: s = \"abcabcabcabc\"\nOutput: true\nExplanation: It is the substring \"abc\" four times or the substring \"abcabc\" twice.", "link": "https://leetcode.com/problems/repeated-substring-pattern/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def repeatedSubstringPattern(s: str) -> bool:\n    n = len(s)\n    for i in range(1, n // 2 + 1):\n        if n % i == 0:\n            pattern = s[:i] * (n // i)\n            if s == pattern:\n                return True\n    return False", "asserts": ["assert repeatedSubstringPattern(\"abab\")==True", "assert repeatedSubstringPattern(\"aaaa\") == True", "assert repeatedSubstringPattern(\"abac\") == False", "assert repeatedSubstringPattern(\"ababab\") == True", "assert repeatedSubstringPattern(\"xyzxyzxyz\") == True", "assert repeatedSubstringPattern(\"aaabaaa\") == False", "assert repeatedSubstringPattern(\"abababab\") == True", "assert repeatedSubstringPattern(\"abcabcab\") == False", "assert repeatedSubstringPattern(\"abbaabba\") == True", "assert repeatedSubstringPattern(\"\") == False", "assert repeatedSubstringPattern(\"a\") == False", "assert repeatedSubstringPattern(\"abacababacab\") == True"]}, {"author": "Hafeez", "UUID": "e811f9cc-fa5e-4ea0-8adb-8cf3ab7c72db", "question": "Detect Pattern of Length M Repeated K or More Times: Given an array of positive integers arr, find a pattern of length m that is repeated k or more times.\n\nA pattern is a subarray (consecutive sub-sequence) that consists of one or more values, repeated multiple times consecutively without overlapping. A pattern is defined by its length and the number of repetitions.\n\nReturn true if there exists a pattern of length m that is repeated k or more times, otherwise return false.", "examples": "Input: arr = [1,2,1,2,1,1,1,3], m = 2, k = 2\nOutput: true\nExplanation: The pattern (1,2) of length 2 is repeated 2 consecutive times. Another valid pattern (2,1) is also repeated 2 times.\nInput: arr = [1,2,1,2,1,3], m = 2, k = 3\nOutput: false\nExplanation: The pattern (1,2) is of length 2 but is repeated only 2 times. There is no pattern of length 2 that is repeated 3 or more times.\n", "link": "https://leetcode.com/problems/detect-pattern-of-length-m-repeated-k-or-more-times/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "from typing import List\ndef containsPattern(arr: List[int], m: int, k: int) -> bool:\n    i = 0\n    while i <= len(arr)-1:\n            p = arr[i:i+m]\n            if p * k == arr[i:i+m*k]:\n                    return True\n            i += 1\n    return False", "asserts": ["assert containsPattern([1,2,4,4,4,4],1,3)==True", "assert containsPattern([1,2,3,1,2,3,1,2,3], 3, 3) == True", "assert containsPattern([1,1,1,2,2,2,3,3], 2, 2) == False", "assert containsPattern([5,5,5,5,5,5,5], 1, 6) == True", "assert containsPattern([1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2], 2, 5) == True", "assert containsPattern([10,100,10,100,10,100,10,10,10,100], 2, 4) == False", "assert containsPattern([3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3], 4, 3) == True"]}], "category": "Pattern", "prompt_tokens": 855, "total_tokens": 1137, "completion_tokens": 282, "completion": "Find All Anagrams in a String: Given a string s and a non-empty string p, find all the start indices of p's anagrams in s.\n\nStrings consists of lowercase English letters only.\n\n###Code: \n\nfrom typing import List\nfrom collections import Counter\n\ndef findAnagrams(s: str, p: str) -> List[int]:\n    result = []\n    p_count = Counter(p)\n    s_count = Counter(s[:len(p)-1])\n    for i in range(len(p)-1, len(s)):\n        s_count[s[i]] += 1\n        if s_count == p_count:\n            result.append(i-len(p)+1)\n        s_count[s[i-len(p)+1]] -= 1\n        if s_count[s[i-len(p)+1]] == 0:\n            del s_count[s[i-len(p)+1]]\n    return result\n\n###Testcases: \n\nassert findAnagrams(\"cbaebabacd\", \"abc\") == [0, 6]\nassert findAnagrams(\"abab\", \"ab\") == [0, 1, 2]\nassert findAnagrams(\"aaaaaa\", \"a\") == [0, 1, 2, 3, 4, 5]\nassert findAnagrams(\"xxyyzzyx\", \"xyz\") == [0, 1, 5]\n\n[/Example 3]", "temperature": 0.886}, {"few_shots": [{"author": "Hafeez", "UUID": "effcb732-1f0d-4caa-8d9f-be914708d4ae", "question": "Repeated Substring Pattern: Given a string s, check if it can be constructed by taking a substring of it and appending multiple copies of the substring together.", "examples": "Input: s = \"aba\"\nOutput: false\nExplanation: It is the substring \"ab\" twice.\nInput: s = \"abcabcabcabc\"\nOutput: true\nExplanation: It is the substring \"abc\" four times or the substring \"abcabc\" twice.", "link": "https://leetcode.com/problems/repeated-substring-pattern/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def repeatedSubstringPattern(s: str) -> bool:\n    n = len(s)\n    for i in range(1, n // 2 + 1):\n        if n % i == 0:\n            pattern = s[:i] * (n // i)\n            if s == pattern:\n                return True\n    return False", "asserts": ["assert repeatedSubstringPattern(\"abab\")==True", "assert repeatedSubstringPattern(\"aaaa\") == True", "assert repeatedSubstringPattern(\"abac\") == False", "assert repeatedSubstringPattern(\"ababab\") == True", "assert repeatedSubstringPattern(\"xyzxyzxyz\") == True", "assert repeatedSubstringPattern(\"aaabaaa\") == False", "assert repeatedSubstringPattern(\"abababab\") == True", "assert repeatedSubstringPattern(\"abcabcab\") == False", "assert repeatedSubstringPattern(\"abbaabba\") == True", "assert repeatedSubstringPattern(\"\") == False", "assert repeatedSubstringPattern(\"a\") == False", "assert repeatedSubstringPattern(\"abacababacab\") == True"]}, {"author": "Hafeez", "UUID": "df98fd29-db88-4de7-a00a-0a3bd5ba1539", "question": "Word Pattern: Given a pattern and a string s, find if s follows the same pattern.\n\nHere follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in s.", "examples": "Input: pattern = \"abba\", s = \"dog cat cat fish\"\nOutput: false\nInput: pattern = \"aaaa\", s = \"dog cat cat dog\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def wordPattern(pattern: str, s: str) -> bool:\n    map_char = {}\n    map_word = {}\n    \n    words = s.split(' ')\n    if len(words) != len(pattern):\n        return False\n    \n    for c, w in zip(pattern, words):\n        if c not in map_char:\n            if w in map_word:\n                return False\n            else:\n                map_char[c] = w\n                map_word[w] = c\n        else:\n            if map_char[c] != w:\n                return False\n    return True", "asserts": ["assert wordPattern(\"abba\", \"dog cat cat dog\")==True", "assert wordPattern(\"aaaa\", \"dog dog dog dog\") == True", "assert wordPattern(\"xyz\", \"apple banana apple\") == False", "assert wordPattern(\"xyx\", \"apple banana apple\") == True", "assert wordPattern(\"abab\", \"dog cat dog cat\") == True", "assert wordPattern(\"aaaa\", \"dog dog dog cat\") == False", "assert wordPattern(\"aabb\", \"dog dog cat cat\") == True", "assert wordPattern(\"abc\", \"dog\") == False  # Not enough words", "assert wordPattern(\"\", \"dog cat\") == False  # Empty pattern", "assert wordPattern(\"a\", \"dog cat dog cat\") == False  # Not enough pattern characters", "assert wordPattern(\"ab\", \"\") == False  # Empty string", "assert wordPattern(\"abb\", \"dog dog dog\") == False  # Same word for different pattern characters", "assert wordPattern(\"abba\", \"dog cat cat\") == False  # Not enough words for the pattern", "assert wordPattern(\"abba\", \"dog cat cat dog fish\") == False  # Extra words beyond the pattern length"]}], "category": "Pattern", "prompt_tokens": 854, "total_tokens": 1197, "completion_tokens": 343, "completion": "Maximum Consecutive Ones: Given a binary array, find the maximum number of consecutive 1s in this array.\n\n###Code:\n\n```python\ndef findMaxConsecutiveOnes(nums: List[int]) -> int:\n    max_ones = 0\n    current_ones = 0\n    for num in nums:\n        if num == 1:\n            current_ones += 1\n            max_ones = max(max_ones, current_ones)\n        else:\n            current_ones = 0\n    return max_ones\n```\n\n###Testcases:\n\n```python\nassert findMaxConsecutiveOnes([1, 1, 0, 1, 1, 1])==3\nassert findMaxConsecutiveOnes([1, 1, 1, 0, 0, 1, 1, 1, 1, 1])==5\nassert findMaxConsecutiveOnes([1, 0, 1, 1, 0, 1])==2\nassert findMaxConsecutiveOnes([0, 0, 0, 0, 0])==0\nassert findMaxConsecutiveOnes([1, 1, 1, 1, 1])==5\nassert findMaxConsecutiveOnes([0, 1, 0, 1, 1, 0, 1, 1, 1, 1])==4\nassert findMaxConsecutiveOnes([1])==1\nassert findMaxConsecutiveOnes([0])==0\nassert findMaxConsecutiveOnes([])==0\n```\n\n[/Example 3]", "temperature": 0.939}, {"few_shots": [{"author": "Hafeez", "UUID": "effcb732-1f0d-4caa-8d9f-be914708d4ae", "question": "Repeated Substring Pattern: Given a string s, check if it can be constructed by taking a substring of it and appending multiple copies of the substring together.", "examples": "Input: s = \"aba\"\nOutput: false\nExplanation: It is the substring \"ab\" twice.\nInput: s = \"abcabcabcabc\"\nOutput: true\nExplanation: It is the substring \"abc\" four times or the substring \"abcabc\" twice.", "link": "https://leetcode.com/problems/repeated-substring-pattern/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def repeatedSubstringPattern(s: str) -> bool:\n    n = len(s)\n    for i in range(1, n // 2 + 1):\n        if n % i == 0:\n            pattern = s[:i] * (n // i)\n            if s == pattern:\n                return True\n    return False", "asserts": ["assert repeatedSubstringPattern(\"abab\")==True", "assert repeatedSubstringPattern(\"aaaa\") == True", "assert repeatedSubstringPattern(\"abac\") == False", "assert repeatedSubstringPattern(\"ababab\") == True", "assert repeatedSubstringPattern(\"xyzxyzxyz\") == True", "assert repeatedSubstringPattern(\"aaabaaa\") == False", "assert repeatedSubstringPattern(\"abababab\") == True", "assert repeatedSubstringPattern(\"abcabcab\") == False", "assert repeatedSubstringPattern(\"abbaabba\") == True", "assert repeatedSubstringPattern(\"\") == False", "assert repeatedSubstringPattern(\"a\") == False", "assert repeatedSubstringPattern(\"abacababacab\") == True"]}, {"author": "Hafeez", "UUID": "df98fd29-db88-4de7-a00a-0a3bd5ba1539", "question": "Word Pattern: Given a pattern and a string s, find if s follows the same pattern.\n\nHere follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in s.", "examples": "Input: pattern = \"abba\", s = \"dog cat cat fish\"\nOutput: false\nInput: pattern = \"aaaa\", s = \"dog cat cat dog\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def wordPattern(pattern: str, s: str) -> bool:\n    map_char = {}\n    map_word = {}\n    \n    words = s.split(' ')\n    if len(words) != len(pattern):\n        return False\n    \n    for c, w in zip(pattern, words):\n        if c not in map_char:\n            if w in map_word:\n                return False\n            else:\n                map_char[c] = w\n                map_word[w] = c\n        else:\n            if map_char[c] != w:\n                return False\n    return True", "asserts": ["assert wordPattern(\"abba\", \"dog cat cat dog\")==True", "assert wordPattern(\"aaaa\", \"dog dog dog dog\") == True", "assert wordPattern(\"xyz\", \"apple banana apple\") == False", "assert wordPattern(\"xyx\", \"apple banana apple\") == True", "assert wordPattern(\"abab\", \"dog cat dog cat\") == True", "assert wordPattern(\"aaaa\", \"dog dog dog cat\") == False", "assert wordPattern(\"aabb\", \"dog dog cat cat\") == True", "assert wordPattern(\"abc\", \"dog\") == False  # Not enough words", "assert wordPattern(\"\", \"dog cat\") == False  # Empty pattern", "assert wordPattern(\"a\", \"dog cat dog cat\") == False  # Not enough pattern characters", "assert wordPattern(\"ab\", \"\") == False  # Empty string", "assert wordPattern(\"abb\", \"dog dog dog\") == False  # Same word for different pattern characters", "assert wordPattern(\"abba\", \"dog cat cat\") == False  # Not enough words for the pattern", "assert wordPattern(\"abba\", \"dog cat cat dog fish\") == False  # Extra words beyond the pattern length"]}], "category": "Pattern", "prompt_tokens": 854, "total_tokens": 1300, "completion_tokens": 446, "completion": "Missing Number in Arithmetic Progression: You are given an array that represents an arithmetic progression of integers. One integer is missing from the progression. Write a function to find and return the missing number. \n\n###Code: \n\n```python\ndef missingNumber(arr):\n    n = len(arr)\n    diff = (arr[-1] - arr[0]) // n\n    left, right = 0, n - 1\n    \n    while left < right:\n        mid = left + (right - left) // 2\n        if arr[mid] != arr[0] + mid * diff:\n            right = mid\n        else:\n            left = mid + 1\n    \n    return arr[0] + left * diff\n```\n\n###Testcases: \n\n```python\nassert missingNumber([1, 3, 5, 7, 9, 11, 13]) == 15\nassert missingNumber([2, 4, 8, 10, 12, 14, 16]) == 6\nassert missingNumber([1, 4, 7, 10, 13, 16, 22]) == 19\nassert missingNumber([2, 7, 12, 17, 27, 32, 37]) == 22\nassert missingNumber([10, 20, 30, 40, 60, 70, 80]) == 50\nassert missingNumber([5, 15, 25, 35, 45, 55, 65]) == 10\nassert missingNumber([100, 200, 300, 400, 600, 700, 800]) == 500\nassert missingNumber([3, 6, 9, 12, 18, 21, 24]) == 15\nassert missingNumber([11, 22, 33, 44, 66, 77, 88]) == 55\nassert missingNumber([4, 10, 16, 22, 34, 40, 46]) == 28\n```\n\n[/Example 3]", "temperature": 0.859}, {"few_shots": [{"author": "Hafeez", "UUID": "effcb732-1f0d-4caa-8d9f-be914708d4ae", "question": "Repeated Substring Pattern: Given a string s, check if it can be constructed by taking a substring of it and appending multiple copies of the substring together.", "examples": "Input: s = \"aba\"\nOutput: false\nExplanation: It is the substring \"ab\" twice.\nInput: s = \"abcabcabcabc\"\nOutput: true\nExplanation: It is the substring \"abc\" four times or the substring \"abcabc\" twice.", "link": "https://leetcode.com/problems/repeated-substring-pattern/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def repeatedSubstringPattern(s: str) -> bool:\n    n = len(s)\n    for i in range(1, n // 2 + 1):\n        if n % i == 0:\n            pattern = s[:i] * (n // i)\n            if s == pattern:\n                return True\n    return False", "asserts": ["assert repeatedSubstringPattern(\"abab\")==True", "assert repeatedSubstringPattern(\"aaaa\") == True", "assert repeatedSubstringPattern(\"abac\") == False", "assert repeatedSubstringPattern(\"ababab\") == True", "assert repeatedSubstringPattern(\"xyzxyzxyz\") == True", "assert repeatedSubstringPattern(\"aaabaaa\") == False", "assert repeatedSubstringPattern(\"abababab\") == True", "assert repeatedSubstringPattern(\"abcabcab\") == False", "assert repeatedSubstringPattern(\"abbaabba\") == True", "assert repeatedSubstringPattern(\"\") == False", "assert repeatedSubstringPattern(\"a\") == False", "assert repeatedSubstringPattern(\"abacababacab\") == True"]}, {"author": "Hafeez", "UUID": "df98fd29-db88-4de7-a00a-0a3bd5ba1539", "question": "Word Pattern: Given a pattern and a string s, find if s follows the same pattern.\n\nHere follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in s.", "examples": "Input: pattern = \"abba\", s = \"dog cat cat fish\"\nOutput: false\nInput: pattern = \"aaaa\", s = \"dog cat cat dog\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def wordPattern(pattern: str, s: str) -> bool:\n    map_char = {}\n    map_word = {}\n    \n    words = s.split(' ')\n    if len(words) != len(pattern):\n        return False\n    \n    for c, w in zip(pattern, words):\n        if c not in map_char:\n            if w in map_word:\n                return False\n            else:\n                map_char[c] = w\n                map_word[w] = c\n        else:\n            if map_char[c] != w:\n                return False\n    return True", "asserts": ["assert wordPattern(\"abba\", \"dog cat cat dog\")==True", "assert wordPattern(\"aaaa\", \"dog dog dog dog\") == True", "assert wordPattern(\"xyz\", \"apple banana apple\") == False", "assert wordPattern(\"xyx\", \"apple banana apple\") == True", "assert wordPattern(\"abab\", \"dog cat dog cat\") == True", "assert wordPattern(\"aaaa\", \"dog dog dog cat\") == False", "assert wordPattern(\"aabb\", \"dog dog cat cat\") == True", "assert wordPattern(\"abc\", \"dog\") == False  # Not enough words", "assert wordPattern(\"\", \"dog cat\") == False  # Empty pattern", "assert wordPattern(\"a\", \"dog cat dog cat\") == False  # Not enough pattern characters", "assert wordPattern(\"ab\", \"\") == False  # Empty string", "assert wordPattern(\"abb\", \"dog dog dog\") == False  # Same word for different pattern characters", "assert wordPattern(\"abba\", \"dog cat cat\") == False  # Not enough words for the pattern", "assert wordPattern(\"abba\", \"dog cat cat dog fish\") == False  # Extra words beyond the pattern length"]}], "category": "Pattern", "prompt_tokens": 854, "total_tokens": 1246, "completion_tokens": 392, "completion": "Check if a string follows a given pattern. \n\n###Code: \n\n```python\ndef isPatternFollowed(pattern: str, s: str) -> bool:\n    pattern_map = {}\n    words = s.split()\n\n    if len(pattern) != len(words):\n        return False\n\n    for char, word in zip(pattern, words):\n        if char not in pattern_map:\n            if word in pattern_map.values():\n                return False\n            else:\n                pattern_map[char] = word\n        else:\n            if pattern_map[char] != word:\n                return False\n\n    return True\n```\n\n###Testcases: \n\n```python\nassert isPatternFollowed(\"abba\", \"red blue blue red\")==True\nassert isPatternFollowed(\"aaaa\", \"red red red red\") == True\nassert isPatternFollowed(\"abba\", \"red blue blue green\") == False\nassert isPatternFollowed(\"abcd\", \"dog cat cat dog\") == True\nassert isPatternFollowed(\"aabb\", \"cat cat dog dog\") == True\nassert isPatternFollowed(\"abab\", \"red blue red blue\") == True\nassert isPatternFollowed(\"abc\", \"dog\") == False  # Not enough words\nassert isPatternFollowed(\"\", \"dog cat\") == False  # Empty pattern\nassert isPatternFollowed(\"a\", \"dog cat dog cat\") == False  # Not enough pattern characters\nassert isPatternFollowed(\"ab\", \"\") == False  # Empty string\nassert isPatternFollowed(\"abb\", \"dog dog dog\") == False  # Same word for different pattern characters\nassert isPatternFollowed(\"abba\", \"red red red\") == False  # Not enough words for the pattern\nassert isPatternFollowed(\"abba\", \"red red red red blue\") == False  # Extra words beyond the pattern length\n```\n\n[/Example 3]", "temperature": 0.877}, {"few_shots": [{"author": "Hafeez", "UUID": "effcb732-1f0d-4caa-8d9f-be914708d4ae", "question": "Repeated Substring Pattern: Given a string s, check if it can be constructed by taking a substring of it and appending multiple copies of the substring together.", "examples": "Input: s = \"aba\"\nOutput: false\nExplanation: It is the substring \"ab\" twice.\nInput: s = \"abcabcabcabc\"\nOutput: true\nExplanation: It is the substring \"abc\" four times or the substring \"abcabc\" twice.", "link": "https://leetcode.com/problems/repeated-substring-pattern/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def repeatedSubstringPattern(s: str) -> bool:\n    n = len(s)\n    for i in range(1, n // 2 + 1):\n        if n % i == 0:\n            pattern = s[:i] * (n // i)\n            if s == pattern:\n                return True\n    return False", "asserts": ["assert repeatedSubstringPattern(\"abab\")==True", "assert repeatedSubstringPattern(\"aaaa\") == True", "assert repeatedSubstringPattern(\"abac\") == False", "assert repeatedSubstringPattern(\"ababab\") == True", "assert repeatedSubstringPattern(\"xyzxyzxyz\") == True", "assert repeatedSubstringPattern(\"aaabaaa\") == False", "assert repeatedSubstringPattern(\"abababab\") == True", "assert repeatedSubstringPattern(\"abcabcab\") == False", "assert repeatedSubstringPattern(\"abbaabba\") == True", "assert repeatedSubstringPattern(\"\") == False", "assert repeatedSubstringPattern(\"a\") == False", "assert repeatedSubstringPattern(\"abacababacab\") == True"]}, {"author": "Hafeez", "UUID": "df98fd29-db88-4de7-a00a-0a3bd5ba1539", "question": "Word Pattern: Given a pattern and a string s, find if s follows the same pattern.\n\nHere follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in s.", "examples": "Input: pattern = \"abba\", s = \"dog cat cat fish\"\nOutput: false\nInput: pattern = \"aaaa\", s = \"dog cat cat dog\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def wordPattern(pattern: str, s: str) -> bool:\n    map_char = {}\n    map_word = {}\n    \n    words = s.split(' ')\n    if len(words) != len(pattern):\n        return False\n    \n    for c, w in zip(pattern, words):\n        if c not in map_char:\n            if w in map_word:\n                return False\n            else:\n                map_char[c] = w\n                map_word[w] = c\n        else:\n            if map_char[c] != w:\n                return False\n    return True", "asserts": ["assert wordPattern(\"abba\", \"dog cat cat dog\")==True", "assert wordPattern(\"aaaa\", \"dog dog dog dog\") == True", "assert wordPattern(\"xyz\", \"apple banana apple\") == False", "assert wordPattern(\"xyx\", \"apple banana apple\") == True", "assert wordPattern(\"abab\", \"dog cat dog cat\") == True", "assert wordPattern(\"aaaa\", \"dog dog dog cat\") == False", "assert wordPattern(\"aabb\", \"dog dog cat cat\") == True", "assert wordPattern(\"abc\", \"dog\") == False  # Not enough words", "assert wordPattern(\"\", \"dog cat\") == False  # Empty pattern", "assert wordPattern(\"a\", \"dog cat dog cat\") == False  # Not enough pattern characters", "assert wordPattern(\"ab\", \"\") == False  # Empty string", "assert wordPattern(\"abb\", \"dog dog dog\") == False  # Same word for different pattern characters", "assert wordPattern(\"abba\", \"dog cat cat\") == False  # Not enough words for the pattern", "assert wordPattern(\"abba\", \"dog cat cat dog fish\") == False  # Extra words beyond the pattern length"]}], "category": "Pattern", "prompt_tokens": 854, "total_tokens": 1020, "completion_tokens": 166, "completion": "\nFibonacci Pattern: Given a number n, print the first n numbers of the Fibonacci sequence in the form of a pattern.\n\n###Code: \n\ndef fibonacciPattern(n: int) -> None:\n    a, b = 0, 1\n    for _ in range(n):\n        print(a, end=\" \")\n        a, b = b, a + b\n\n###Testcases: \n\nassert fibonacciPattern(5)  # Output: 0 1 1 2 3 \nassert fibonacciPattern(8)  # Output: 0 1 1 2 3 5 8 13 \nassert fibonacciPattern(10)  # Output: 0 1 1 2 3 5 8 13 21 34 \n\n[/Example 3]", "temperature": 0.929}, {"few_shots": [{"author": "Hafeez", "UUID": "effcb732-1f0d-4caa-8d9f-be914708d4ae", "question": "Repeated Substring Pattern: Given a string s, check if it can be constructed by taking a substring of it and appending multiple copies of the substring together.", "examples": "Input: s = \"aba\"\nOutput: false\nExplanation: It is the substring \"ab\" twice.\nInput: s = \"abcabcabcabc\"\nOutput: true\nExplanation: It is the substring \"abc\" four times or the substring \"abcabc\" twice.", "link": "https://leetcode.com/problems/repeated-substring-pattern/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def repeatedSubstringPattern(s: str) -> bool:\n    n = len(s)\n    for i in range(1, n // 2 + 1):\n        if n % i == 0:\n            pattern = s[:i] * (n // i)\n            if s == pattern:\n                return True\n    return False", "asserts": ["assert repeatedSubstringPattern(\"abab\")==True", "assert repeatedSubstringPattern(\"aaaa\") == True", "assert repeatedSubstringPattern(\"abac\") == False", "assert repeatedSubstringPattern(\"ababab\") == True", "assert repeatedSubstringPattern(\"xyzxyzxyz\") == True", "assert repeatedSubstringPattern(\"aaabaaa\") == False", "assert repeatedSubstringPattern(\"abababab\") == True", "assert repeatedSubstringPattern(\"abcabcab\") == False", "assert repeatedSubstringPattern(\"abbaabba\") == True", "assert repeatedSubstringPattern(\"\") == False", "assert repeatedSubstringPattern(\"a\") == False", "assert repeatedSubstringPattern(\"abacababacab\") == True"]}, {"author": "Hafeez", "UUID": "df98fd29-db88-4de7-a00a-0a3bd5ba1539", "question": "Word Pattern: Given a pattern and a string s, find if s follows the same pattern.\n\nHere follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in s.", "examples": "Input: pattern = \"abba\", s = \"dog cat cat fish\"\nOutput: false\nInput: pattern = \"aaaa\", s = \"dog cat cat dog\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def wordPattern(pattern: str, s: str) -> bool:\n    map_char = {}\n    map_word = {}\n    \n    words = s.split(' ')\n    if len(words) != len(pattern):\n        return False\n    \n    for c, w in zip(pattern, words):\n        if c not in map_char:\n            if w in map_word:\n                return False\n            else:\n                map_char[c] = w\n                map_word[w] = c\n        else:\n            if map_char[c] != w:\n                return False\n    return True", "asserts": ["assert wordPattern(\"abba\", \"dog cat cat dog\")==True", "assert wordPattern(\"aaaa\", \"dog dog dog dog\") == True", "assert wordPattern(\"xyz\", \"apple banana apple\") == False", "assert wordPattern(\"xyx\", \"apple banana apple\") == True", "assert wordPattern(\"abab\", \"dog cat dog cat\") == True", "assert wordPattern(\"aaaa\", \"dog dog dog cat\") == False", "assert wordPattern(\"aabb\", \"dog dog cat cat\") == True", "assert wordPattern(\"abc\", \"dog\") == False  # Not enough words", "assert wordPattern(\"\", \"dog cat\") == False  # Empty pattern", "assert wordPattern(\"a\", \"dog cat dog cat\") == False  # Not enough pattern characters", "assert wordPattern(\"ab\", \"\") == False  # Empty string", "assert wordPattern(\"abb\", \"dog dog dog\") == False  # Same word for different pattern characters", "assert wordPattern(\"abba\", \"dog cat cat\") == False  # Not enough words for the pattern", "assert wordPattern(\"abba\", \"dog cat cat dog fish\") == False  # Extra words beyond the pattern length"]}], "category": "Pattern", "prompt_tokens": 854, "total_tokens": 1169, "completion_tokens": 315, "completion": "ZigZag Conversion: The string \"PAYPALISHIRING\" is written in a zigzag pattern on a given number of rows, as follows:\n\nP   A   H   N\nA P L S I I G\nY   I   R\n\nAnd then read line by line: \"PAHNAPLSIIGYIR\"\n\nWrite the code to convert the given string to zigzag pattern based on the given number of rows.\n\n###Code: \n\n```python\ndef convert(s: str, numRows: int) -> str:\n    if numRows == 1 or numRows >= len(s):\n        return s\n\n    result = ['' for _ in range(numRows)]\n    index, step = 0, 1\n\n    for char in s:\n        result[index] += char\n        if index == 0:\n            step = 1\n        elif index == numRows - 1:\n            step = -1\n        index += step\n\n    return ''.join(result)\n```\n\n###Testcases: \n\n```python\nassert convert(\"PAYPALISHIRING\", 3) == \"PAHNAPLSIIGYIR\"\nassert convert(\"PAYPALISHIRING\", 4) == \"PINALSIGYAHRPI\"\nassert convert(\"AB\", 1) == \"AB\"\nassert convert(\"ABCD\", 2) == \"ACBD\"\nassert convert(\"ABCDE\", 4) == \"ABECD\"\nassert convert(\"A\", 1) == \"A\"\n```\n\n[/Example 3]", "temperature": 0.725}, {"few_shots": [{"author": "Hafeez", "UUID": "effcb732-1f0d-4caa-8d9f-be914708d4ae", "question": "Repeated Substring Pattern: Given a string s, check if it can be constructed by taking a substring of it and appending multiple copies of the substring together.", "examples": "Input: s = \"aba\"\nOutput: false\nExplanation: It is the substring \"ab\" twice.\nInput: s = \"abcabcabcabc\"\nOutput: true\nExplanation: It is the substring \"abc\" four times or the substring \"abcabc\" twice.", "link": "https://leetcode.com/problems/repeated-substring-pattern/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def repeatedSubstringPattern(s: str) -> bool:\n    n = len(s)\n    for i in range(1, n // 2 + 1):\n        if n % i == 0:\n            pattern = s[:i] * (n // i)\n            if s == pattern:\n                return True\n    return False", "asserts": ["assert repeatedSubstringPattern(\"abab\")==True", "assert repeatedSubstringPattern(\"aaaa\") == True", "assert repeatedSubstringPattern(\"abac\") == False", "assert repeatedSubstringPattern(\"ababab\") == True", "assert repeatedSubstringPattern(\"xyzxyzxyz\") == True", "assert repeatedSubstringPattern(\"aaabaaa\") == False", "assert repeatedSubstringPattern(\"abababab\") == True", "assert repeatedSubstringPattern(\"abcabcab\") == False", "assert repeatedSubstringPattern(\"abbaabba\") == True", "assert repeatedSubstringPattern(\"\") == False", "assert repeatedSubstringPattern(\"a\") == False", "assert repeatedSubstringPattern(\"abacababacab\") == True"]}, {"author": "Hafeez", "UUID": "df98fd29-db88-4de7-a00a-0a3bd5ba1539", "question": "Word Pattern: Given a pattern and a string s, find if s follows the same pattern.\n\nHere follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in s.", "examples": "Input: pattern = \"abba\", s = \"dog cat cat fish\"\nOutput: false\nInput: pattern = \"aaaa\", s = \"dog cat cat dog\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def wordPattern(pattern: str, s: str) -> bool:\n    map_char = {}\n    map_word = {}\n    \n    words = s.split(' ')\n    if len(words) != len(pattern):\n        return False\n    \n    for c, w in zip(pattern, words):\n        if c not in map_char:\n            if w in map_word:\n                return False\n            else:\n                map_char[c] = w\n                map_word[w] = c\n        else:\n            if map_char[c] != w:\n                return False\n    return True", "asserts": ["assert wordPattern(\"abba\", \"dog cat cat dog\")==True", "assert wordPattern(\"aaaa\", \"dog dog dog dog\") == True", "assert wordPattern(\"xyz\", \"apple banana apple\") == False", "assert wordPattern(\"xyx\", \"apple banana apple\") == True", "assert wordPattern(\"abab\", \"dog cat dog cat\") == True", "assert wordPattern(\"aaaa\", \"dog dog dog cat\") == False", "assert wordPattern(\"aabb\", \"dog dog cat cat\") == True", "assert wordPattern(\"abc\", \"dog\") == False  # Not enough words", "assert wordPattern(\"\", \"dog cat\") == False  # Empty pattern", "assert wordPattern(\"a\", \"dog cat dog cat\") == False  # Not enough pattern characters", "assert wordPattern(\"ab\", \"\") == False  # Empty string", "assert wordPattern(\"abb\", \"dog dog dog\") == False  # Same word for different pattern characters", "assert wordPattern(\"abba\", \"dog cat cat\") == False  # Not enough words for the pattern", "assert wordPattern(\"abba\", \"dog cat cat dog fish\") == False  # Extra words beyond the pattern length"]}], "category": "Pattern", "prompt_tokens": 854, "total_tokens": 1166, "completion_tokens": 312, "completion": "Zigzag Conversion: The string \"PAYPALISHIRING\" is written in a zigzag pattern on a given number of rows like this:\n\nP   A   H   N\nA P L S I I G\nY   I   R\n\nAnd then read line by line: \"PAHNAPLSIIGYIR\"\n\nWrite a function to convert the string s into ZigZag pattern with a given number of rows.\n\n###Code: \n\n```python\ndef convert(s: str, numRows: int) -> str:\n    if numRows == 1 or numRows >= len(s):\n        return s\n\n    result = ['' for _ in range(numRows)]\n    index, step = 0, 1\n\n    for char in s:\n        result[index] += char\n        if index == 0:\n            step = 1\n        elif index == numRows - 1:\n            step = -1\n        index += step\n\n    return ''.join(result)\n```\n\n###Testcases: \n\n```python\nassert convert(\"PAYPALISHIRING\", 3) == \"PAHNAPLSIIGYIR\"\nassert convert(\"PAYPALISHIRING\", 4) == \"PINALSIGYAHRPI\"\nassert convert(\"ABCDE\", 4) == \"ABCED\"\nassert convert(\"AB\", 1) == \"AB\"\nassert convert(\"A\", 1) == \"A\"\nassert convert(\"ABCD\", 2) == \"ACBD\"\n```\n\n[/Example 3]", "temperature": 0.818}, {"few_shots": [{"author": "Hafeez", "UUID": "effcb732-1f0d-4caa-8d9f-be914708d4ae", "question": "Repeated Substring Pattern: Given a string s, check if it can be constructed by taking a substring of it and appending multiple copies of the substring together.", "examples": "Input: s = \"aba\"\nOutput: false\nExplanation: It is the substring \"ab\" twice.\nInput: s = \"abcabcabcabc\"\nOutput: true\nExplanation: It is the substring \"abc\" four times or the substring \"abcabc\" twice.", "link": "https://leetcode.com/problems/repeated-substring-pattern/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def repeatedSubstringPattern(s: str) -> bool:\n    n = len(s)\n    for i in range(1, n // 2 + 1):\n        if n % i == 0:\n            pattern = s[:i] * (n // i)\n            if s == pattern:\n                return True\n    return False", "asserts": ["assert repeatedSubstringPattern(\"abab\")==True", "assert repeatedSubstringPattern(\"aaaa\") == True", "assert repeatedSubstringPattern(\"abac\") == False", "assert repeatedSubstringPattern(\"ababab\") == True", "assert repeatedSubstringPattern(\"xyzxyzxyz\") == True", "assert repeatedSubstringPattern(\"aaabaaa\") == False", "assert repeatedSubstringPattern(\"abababab\") == True", "assert repeatedSubstringPattern(\"abcabcab\") == False", "assert repeatedSubstringPattern(\"abbaabba\") == True", "assert repeatedSubstringPattern(\"\") == False", "assert repeatedSubstringPattern(\"a\") == False", "assert repeatedSubstringPattern(\"abacababacab\") == True"]}, {"author": "Hafeez", "UUID": "df98fd29-db88-4de7-a00a-0a3bd5ba1539", "question": "Word Pattern: Given a pattern and a string s, find if s follows the same pattern.\n\nHere follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in s.", "examples": "Input: pattern = \"abba\", s = \"dog cat cat fish\"\nOutput: false\nInput: pattern = \"aaaa\", s = \"dog cat cat dog\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def wordPattern(pattern: str, s: str) -> bool:\n    map_char = {}\n    map_word = {}\n    \n    words = s.split(' ')\n    if len(words) != len(pattern):\n        return False\n    \n    for c, w in zip(pattern, words):\n        if c not in map_char:\n            if w in map_word:\n                return False\n            else:\n                map_char[c] = w\n                map_word[w] = c\n        else:\n            if map_char[c] != w:\n                return False\n    return True", "asserts": ["assert wordPattern(\"abba\", \"dog cat cat dog\")==True", "assert wordPattern(\"aaaa\", \"dog dog dog dog\") == True", "assert wordPattern(\"xyz\", \"apple banana apple\") == False", "assert wordPattern(\"xyx\", \"apple banana apple\") == True", "assert wordPattern(\"abab\", \"dog cat dog cat\") == True", "assert wordPattern(\"aaaa\", \"dog dog dog cat\") == False", "assert wordPattern(\"aabb\", \"dog dog cat cat\") == True", "assert wordPattern(\"abc\", \"dog\") == False  # Not enough words", "assert wordPattern(\"\", \"dog cat\") == False  # Empty pattern", "assert wordPattern(\"a\", \"dog cat dog cat\") == False  # Not enough pattern characters", "assert wordPattern(\"ab\", \"\") == False  # Empty string", "assert wordPattern(\"abb\", \"dog dog dog\") == False  # Same word for different pattern characters", "assert wordPattern(\"abba\", \"dog cat cat\") == False  # Not enough words for the pattern", "assert wordPattern(\"abba\", \"dog cat cat dog fish\") == False  # Extra words beyond the pattern length"]}], "category": "Pattern", "prompt_tokens": 854, "total_tokens": 1163, "completion_tokens": 309, "completion": "Find All Anagrams in a String: Given a string s and a non-empty string p, find all the start indices of p's anagrams in s.\n\nStrings consists of lowercase English letters only.\n\n###Code: \n\n```python\nfrom collections import Counter\n\ndef findAnagrams(s: str, p: str) -> List[int]:\n    result = []\n    p_count = Counter(p)\n    s_count = Counter(s[:len(p)-1])\n    for i in range(len(p)-1, len(s)):\n        s_count[s[i]] += 1\n        if s_count == p_count:\n            result.append(i-len(p)+1)\n        s_count[s[i-len(p)+1]] -= 1\n        if s_count[s[i-len(p)+1]] == 0:\n            del s_count[s[i-len(p)+1]]\n    return result\n```\n\n###Testcases: \n\n```python\nassert findAnagrams(\"cbaebabacd\", \"abc\") == [0, 6]\nassert findAnagrams(\"abab\", \"ab\") == [0, 1, 2]\nassert findAnagrams(\"acdcaeccde\", \"c\") == [2, 3, 7]\nassert findAnagrams(\"aaaaa\", \"a\") == [0, 1, 2, 3, 4]\nassert findAnagrams(\"a\", \"ab\") == []\nassert findAnagrams(\"\", \"a\") == []\nassert findAnagrams(\"abc\", \"\") == []\n```", "temperature": 0.793}, {"few_shots": [{"author": "Hafeez", "UUID": "effcb732-1f0d-4caa-8d9f-be914708d4ae", "question": "Repeated Substring Pattern: Given a string s, check if it can be constructed by taking a substring of it and appending multiple copies of the substring together.", "examples": "Input: s = \"aba\"\nOutput: false\nExplanation: It is the substring \"ab\" twice.\nInput: s = \"abcabcabcabc\"\nOutput: true\nExplanation: It is the substring \"abc\" four times or the substring \"abcabc\" twice.", "link": "https://leetcode.com/problems/repeated-substring-pattern/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def repeatedSubstringPattern(s: str) -> bool:\n    n = len(s)\n    for i in range(1, n // 2 + 1):\n        if n % i == 0:\n            pattern = s[:i] * (n // i)\n            if s == pattern:\n                return True\n    return False", "asserts": ["assert repeatedSubstringPattern(\"abab\")==True", "assert repeatedSubstringPattern(\"aaaa\") == True", "assert repeatedSubstringPattern(\"abac\") == False", "assert repeatedSubstringPattern(\"ababab\") == True", "assert repeatedSubstringPattern(\"xyzxyzxyz\") == True", "assert repeatedSubstringPattern(\"aaabaaa\") == False", "assert repeatedSubstringPattern(\"abababab\") == True", "assert repeatedSubstringPattern(\"abcabcab\") == False", "assert repeatedSubstringPattern(\"abbaabba\") == True", "assert repeatedSubstringPattern(\"\") == False", "assert repeatedSubstringPattern(\"a\") == False", "assert repeatedSubstringPattern(\"abacababacab\") == True"]}, {"author": "Hafeez", "UUID": "df98fd29-db88-4de7-a00a-0a3bd5ba1539", "question": "Word Pattern: Given a pattern and a string s, find if s follows the same pattern.\n\nHere follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in s.", "examples": "Input: pattern = \"abba\", s = \"dog cat cat fish\"\nOutput: false\nInput: pattern = \"aaaa\", s = \"dog cat cat dog\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def wordPattern(pattern: str, s: str) -> bool:\n    map_char = {}\n    map_word = {}\n    \n    words = s.split(' ')\n    if len(words) != len(pattern):\n        return False\n    \n    for c, w in zip(pattern, words):\n        if c not in map_char:\n            if w in map_word:\n                return False\n            else:\n                map_char[c] = w\n                map_word[w] = c\n        else:\n            if map_char[c] != w:\n                return False\n    return True", "asserts": ["assert wordPattern(\"abba\", \"dog cat cat dog\")==True", "assert wordPattern(\"aaaa\", \"dog dog dog dog\") == True", "assert wordPattern(\"xyz\", \"apple banana apple\") == False", "assert wordPattern(\"xyx\", \"apple banana apple\") == True", "assert wordPattern(\"abab\", \"dog cat dog cat\") == True", "assert wordPattern(\"aaaa\", \"dog dog dog cat\") == False", "assert wordPattern(\"aabb\", \"dog dog cat cat\") == True", "assert wordPattern(\"abc\", \"dog\") == False  # Not enough words", "assert wordPattern(\"\", \"dog cat\") == False  # Empty pattern", "assert wordPattern(\"a\", \"dog cat dog cat\") == False  # Not enough pattern characters", "assert wordPattern(\"ab\", \"\") == False  # Empty string", "assert wordPattern(\"abb\", \"dog dog dog\") == False  # Same word for different pattern characters", "assert wordPattern(\"abba\", \"dog cat cat\") == False  # Not enough words for the pattern", "assert wordPattern(\"abba\", \"dog cat cat dog fish\") == False  # Extra words beyond the pattern length"]}], "category": "Pattern", "prompt_tokens": 854, "total_tokens": 1177, "completion_tokens": 323, "completion": "Zigzag Conversion: The string \"PAYPALISHIRING\" is written in a zigzag pattern on a given number of rows like this:\n\nP   A   H   N\nA P L S I I G\nY   I   R\n\nAnd then read line by line: \"PAHNAPLSIIGYIR\"\n\nWrite the code to convert the string s into a zigzag pattern and then return the read line by line.\n\n###Code: \n\ndef convert(s: str, numRows: int) -> str:\n    if numRows == 1:\n        return s\n    \n    result = ['' for _ in range(numRows)]\n    index, step = 0, 1\n    \n    for char in s:\n        result[index] += char\n        if index == 0:\n            step = 1\n        elif index == numRows - 1:\n            step = -1\n        index += step\n    \n    return ''.join(result)\n\n###Testcases: \n\nassert convert(\"PAYPALISHIRING\", 3)==\"PAHNAPLSIIGYIR\"\nassert convert(\"PAYPALISHIRING\", 4)==\"PINALSIGYAHRPI\"\nassert convert(\"ABCDE\", 2)==\"ACEBD\"\nassert convert(\"AB\", 1)==\"AB\"\nassert convert(\"A\", 1)==\"A\"\nassert convert(\"ABCD\", 3)==\"ABDC\"\nassert convert(\"AB\", 3)==\"AB\"\nassert convert(\"PAYPALISHIRING\", 1)==\"PAYPALISHIRING\"\n\n[/Example 3]", "temperature": 0.734}, {"few_shots": [{"author": "Hafeez", "UUID": "effcb732-1f0d-4caa-8d9f-be914708d4ae", "question": "Repeated Substring Pattern: Given a string s, check if it can be constructed by taking a substring of it and appending multiple copies of the substring together.", "examples": "Input: s = \"aba\"\nOutput: false\nExplanation: It is the substring \"ab\" twice.\nInput: s = \"abcabcabcabc\"\nOutput: true\nExplanation: It is the substring \"abc\" four times or the substring \"abcabc\" twice.", "link": "https://leetcode.com/problems/repeated-substring-pattern/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def repeatedSubstringPattern(s: str) -> bool:\n    n = len(s)\n    for i in range(1, n // 2 + 1):\n        if n % i == 0:\n            pattern = s[:i] * (n // i)\n            if s == pattern:\n                return True\n    return False", "asserts": ["assert repeatedSubstringPattern(\"abab\")==True", "assert repeatedSubstringPattern(\"aaaa\") == True", "assert repeatedSubstringPattern(\"abac\") == False", "assert repeatedSubstringPattern(\"ababab\") == True", "assert repeatedSubstringPattern(\"xyzxyzxyz\") == True", "assert repeatedSubstringPattern(\"aaabaaa\") == False", "assert repeatedSubstringPattern(\"abababab\") == True", "assert repeatedSubstringPattern(\"abcabcab\") == False", "assert repeatedSubstringPattern(\"abbaabba\") == True", "assert repeatedSubstringPattern(\"\") == False", "assert repeatedSubstringPattern(\"a\") == False", "assert repeatedSubstringPattern(\"abacababacab\") == True"]}, {"author": "Hafeez", "UUID": "df98fd29-db88-4de7-a00a-0a3bd5ba1539", "question": "Word Pattern: Given a pattern and a string s, find if s follows the same pattern.\n\nHere follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in s.", "examples": "Input: pattern = \"abba\", s = \"dog cat cat fish\"\nOutput: false\nInput: pattern = \"aaaa\", s = \"dog cat cat dog\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def wordPattern(pattern: str, s: str) -> bool:\n    map_char = {}\n    map_word = {}\n    \n    words = s.split(' ')\n    if len(words) != len(pattern):\n        return False\n    \n    for c, w in zip(pattern, words):\n        if c not in map_char:\n            if w in map_word:\n                return False\n            else:\n                map_char[c] = w\n                map_word[w] = c\n        else:\n            if map_char[c] != w:\n                return False\n    return True", "asserts": ["assert wordPattern(\"abba\", \"dog cat cat dog\")==True", "assert wordPattern(\"aaaa\", \"dog dog dog dog\") == True", "assert wordPattern(\"xyz\", \"apple banana apple\") == False", "assert wordPattern(\"xyx\", \"apple banana apple\") == True", "assert wordPattern(\"abab\", \"dog cat dog cat\") == True", "assert wordPattern(\"aaaa\", \"dog dog dog cat\") == False", "assert wordPattern(\"aabb\", \"dog dog cat cat\") == True", "assert wordPattern(\"abc\", \"dog\") == False  # Not enough words", "assert wordPattern(\"\", \"dog cat\") == False  # Empty pattern", "assert wordPattern(\"a\", \"dog cat dog cat\") == False  # Not enough pattern characters", "assert wordPattern(\"ab\", \"\") == False  # Empty string", "assert wordPattern(\"abb\", \"dog dog dog\") == False  # Same word for different pattern characters", "assert wordPattern(\"abba\", \"dog cat cat\") == False  # Not enough words for the pattern", "assert wordPattern(\"abba\", \"dog cat cat dog fish\") == False  # Extra words beyond the pattern length"]}], "category": "Pattern", "prompt_tokens": 854, "total_tokens": 1114, "completion_tokens": 260, "completion": "Repeated DNA Sequences: Given a string s that represents a DNA sequence, find all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule.\n\n###Code: \n\ndef findRepeatedDnaSequences(s: str) -> List[str]:\n    sequences = {}\n    result = []\n    \n    for i in range(len(s) - 9):\n        sequence = s[i:i+10]\n        sequences[sequence] = sequences.get(sequence, 0) + 1\n    \n    for sequence, count in sequences.items():\n        if count > 1:\n            result.append(sequence)\n    \n    return result\n\n###Testcases: \n\nassert findRepeatedDnaSequences(\"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\")==[\"AAAAACCCCC\", \"CCCCCAAAAA\"]\nassert findRepeatedDnaSequences(\"AAAAAAAAAAA\")==[\"AAAAAAAAAA\"]\nassert findRepeatedDnaSequences(\"ACGTACGTACGTACGT\")==[]\nassert findRepeatedDnaSequences(\"AGCTAGCTAGCTAGCTAGCTAGCTAGCT\")==[\"AGCTAGCTAGC\"]\nassert findRepeatedDnaSequences(\"ATATATATATATATATATAT\")==[\"ATATATATAT\"]\n\n[/Example 3]", "temperature": 0.625}, {"few_shots": [{"author": "Hafeez", "UUID": "effcb732-1f0d-4caa-8d9f-be914708d4ae", "question": "Repeated Substring Pattern: Given a string s, check if it can be constructed by taking a substring of it and appending multiple copies of the substring together.", "examples": "Input: s = \"aba\"\nOutput: false\nExplanation: It is the substring \"ab\" twice.\nInput: s = \"abcabcabcabc\"\nOutput: true\nExplanation: It is the substring \"abc\" four times or the substring \"abcabc\" twice.", "link": "https://leetcode.com/problems/repeated-substring-pattern/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def repeatedSubstringPattern(s: str) -> bool:\n    n = len(s)\n    for i in range(1, n // 2 + 1):\n        if n % i == 0:\n            pattern = s[:i] * (n // i)\n            if s == pattern:\n                return True\n    return False", "asserts": ["assert repeatedSubstringPattern(\"abab\")==True", "assert repeatedSubstringPattern(\"aaaa\") == True", "assert repeatedSubstringPattern(\"abac\") == False", "assert repeatedSubstringPattern(\"ababab\") == True", "assert repeatedSubstringPattern(\"xyzxyzxyz\") == True", "assert repeatedSubstringPattern(\"aaabaaa\") == False", "assert repeatedSubstringPattern(\"abababab\") == True", "assert repeatedSubstringPattern(\"abcabcab\") == False", "assert repeatedSubstringPattern(\"abbaabba\") == True", "assert repeatedSubstringPattern(\"\") == False", "assert repeatedSubstringPattern(\"a\") == False", "assert repeatedSubstringPattern(\"abacababacab\") == True"]}, {"author": "Hafeez", "UUID": "8c9548d2-7b9c-46a4-9b8e-8afd488f7e87", "question": "Find and Replace Pattern: Given a list of strings words and a string pattern, return a list of words[i] that match pattern. You may return the answer in any order.\n\nA word matches the pattern if there exists a permutation of letters p so that after replacing every letter x in the pattern with p(x), we get the desired word.\n\nRecall that a permutation of letters is a bijection from letters to letters: every letter maps to another letter, and no two letters map to the same letter.", "examples": "Input: words = [\"abc\",\"deq\",\"mee\",\"aqq\",\"dkd\",\"ccc\"], pattern = \"abb\"\nOutput: [\"mee\",\"aqq\"]\nExplanation: \"mee\" matches the pattern because there is a permutation {a -> m, b -> e, ...}. \n\"ccc\" does not match the pattern because {a -> c, b -> c, ...} is not a permutation, since a and b map to the same letter.", "link": "https://leetcode.com/problems/find-and-replace-pattern/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def findAndReplacePattern(words: list, pattern: str) -> list:\n        def match(word):\n            m1, m2 = {}, {}\n            for w, p in zip(word, pattern):\n                if w not in m1: m1[w] = p\n                if p not in m2: m2[p] = w\n                if (m1[w], m2[p]) != (p, w):\n                    return False\n            return True\n\n        return list(filter(match, words))\n", "asserts": ["assert findAndReplacePattern([\"a\",\"b\",\"c\"], \"a\")==[\"a\",\"b\",\"c\"]", "assert findAndReplacePattern([\"xx\", \"xy\", \"yy\"], \"xx\") == [\"xx\", \"yy\"]", "assert findAndReplacePattern([\"abc\", \"def\", \"ghi\", \"jkl\"], \"xyz\") == [\"abc\", \"def\", \"ghi\", \"jkl\"]", "assert findAndReplacePattern([\"aaa\", \"bbb\", \"ccc\"], \"xyz\") == []"]}], "category": "Pattern", "prompt_tokens": 757, "total_tokens": 995, "completion_tokens": 238, "completion": "Given a string s, return the first non-repeating character in it and return its index. If it does not exist, return -1.\n\n###Code: \n\n```python\ndef firstUniqChar(s: str) -> int:\n    char_count = {}\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    for i in range(len(s)):\n        if char_count[s[i]] == 1:\n            return i\n    return -1\n```\n\n###Testcases: \n\n```python\nassert firstUniqChar(\"leetcode\") == 0\nassert firstUniqChar(\"loveleetcode\") == 2\nassert firstUniqChar(\"aabbcc\") == -1\nassert firstUniqChar(\"abcabc\") == -1\nassert firstUniqChar(\"abcdabcd\") == -1\nassert firstUniqChar(\"abcd\") == 0\nassert firstUniqChar(\"abcda\") == 1\nassert firstUniqChar(\"\") == -1\nassert firstUniqChar(\"a\") == 0\n```", "temperature": 0.709}, {"few_shots": [{"author": "Hafeez", "UUID": "effcb732-1f0d-4caa-8d9f-be914708d4ae", "question": "Repeated Substring Pattern: Given a string s, check if it can be constructed by taking a substring of it and appending multiple copies of the substring together.", "examples": "Input: s = \"aba\"\nOutput: false\nExplanation: It is the substring \"ab\" twice.\nInput: s = \"abcabcabcabc\"\nOutput: true\nExplanation: It is the substring \"abc\" four times or the substring \"abcabc\" twice.", "link": "https://leetcode.com/problems/repeated-substring-pattern/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def repeatedSubstringPattern(s: str) -> bool:\n    n = len(s)\n    for i in range(1, n // 2 + 1):\n        if n % i == 0:\n            pattern = s[:i] * (n // i)\n            if s == pattern:\n                return True\n    return False", "asserts": ["assert repeatedSubstringPattern(\"abab\")==True", "assert repeatedSubstringPattern(\"aaaa\") == True", "assert repeatedSubstringPattern(\"abac\") == False", "assert repeatedSubstringPattern(\"ababab\") == True", "assert repeatedSubstringPattern(\"xyzxyzxyz\") == True", "assert repeatedSubstringPattern(\"aaabaaa\") == False", "assert repeatedSubstringPattern(\"abababab\") == True", "assert repeatedSubstringPattern(\"abcabcab\") == False", "assert repeatedSubstringPattern(\"abbaabba\") == True", "assert repeatedSubstringPattern(\"\") == False", "assert repeatedSubstringPattern(\"a\") == False", "assert repeatedSubstringPattern(\"abacababacab\") == True"]}, {"author": "Hafeez", "UUID": "8c9548d2-7b9c-46a4-9b8e-8afd488f7e87", "question": "Find and Replace Pattern: Given a list of strings words and a string pattern, return a list of words[i] that match pattern. You may return the answer in any order.\n\nA word matches the pattern if there exists a permutation of letters p so that after replacing every letter x in the pattern with p(x), we get the desired word.\n\nRecall that a permutation of letters is a bijection from letters to letters: every letter maps to another letter, and no two letters map to the same letter.", "examples": "Input: words = [\"abc\",\"deq\",\"mee\",\"aqq\",\"dkd\",\"ccc\"], pattern = \"abb\"\nOutput: [\"mee\",\"aqq\"]\nExplanation: \"mee\" matches the pattern because there is a permutation {a -> m, b -> e, ...}. \n\"ccc\" does not match the pattern because {a -> c, b -> c, ...} is not a permutation, since a and b map to the same letter.", "link": "https://leetcode.com/problems/find-and-replace-pattern/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def findAndReplacePattern(words: list, pattern: str) -> list:\n        def match(word):\n            m1, m2 = {}, {}\n            for w, p in zip(word, pattern):\n                if w not in m1: m1[w] = p\n                if p not in m2: m2[p] = w\n                if (m1[w], m2[p]) != (p, w):\n                    return False\n            return True\n\n        return list(filter(match, words))\n", "asserts": ["assert findAndReplacePattern([\"a\",\"b\",\"c\"], \"a\")==[\"a\",\"b\",\"c\"]", "assert findAndReplacePattern([\"xx\", \"xy\", \"yy\"], \"xx\") == [\"xx\", \"yy\"]", "assert findAndReplacePattern([\"abc\", \"def\", \"ghi\", \"jkl\"], \"xyz\") == [\"abc\", \"def\", \"ghi\", \"jkl\"]", "assert findAndReplacePattern([\"aaa\", \"bbb\", \"ccc\"], \"xyz\") == []"]}], "category": "Pattern", "prompt_tokens": 757, "total_tokens": 1060, "completion_tokens": 303, "completion": "ZigZag Conversion: The string \"PAYPALISHIRING\" is written in a zigzag pattern on a given number of rows like this:\n\nP   A   H   N\nA P L S I I G\nY   I   R\n\nAnd then read line by line: \"PAHNAPLSIIGYIR\"\n\nWrite the code that will take a string and convert it to a zigzag pattern given a number of rows.\n\n###Code: \n\ndef convert(s: str, numRows: int) -> str:\n        if numRows == 1:\n            return s\n        rows = [''] * min(numRows, len(s))\n        direction = -1\n        row = 0\n        for char in s:\n            rows[row] += char\n            if row == 0 or row == numRows - 1:\n                direction *= -1\n            row += direction\n        return ''.join(rows)\n\n###Testcases: \n\nassert convert(\"PAYPALISHIRING\", 3) == \"PAHNAPLSIIGYIR\"\nassert convert(\"PAYPALISHIRING\", 4) == \"PINALSIGYAHRPI\"\nassert convert(\"AB\", 1) == \"AB\"\nassert convert(\"A\", 1) == \"A\"\nassert convert(\"ABCDEFGHIJKL\", 2) == \"ACEGIKBDHJFL\"\nassert convert(\"HELLO\", 2) == \"HLOLEL\"\n\n[/Example 3]", "temperature": 0.719}, {"few_shots": [{"author": "Hafeez", "UUID": "effcb732-1f0d-4caa-8d9f-be914708d4ae", "question": "Repeated Substring Pattern: Given a string s, check if it can be constructed by taking a substring of it and appending multiple copies of the substring together.", "examples": "Input: s = \"aba\"\nOutput: false\nExplanation: It is the substring \"ab\" twice.\nInput: s = \"abcabcabcabc\"\nOutput: true\nExplanation: It is the substring \"abc\" four times or the substring \"abcabc\" twice.", "link": "https://leetcode.com/problems/repeated-substring-pattern/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def repeatedSubstringPattern(s: str) -> bool:\n    n = len(s)\n    for i in range(1, n // 2 + 1):\n        if n % i == 0:\n            pattern = s[:i] * (n // i)\n            if s == pattern:\n                return True\n    return False", "asserts": ["assert repeatedSubstringPattern(\"abab\")==True", "assert repeatedSubstringPattern(\"aaaa\") == True", "assert repeatedSubstringPattern(\"abac\") == False", "assert repeatedSubstringPattern(\"ababab\") == True", "assert repeatedSubstringPattern(\"xyzxyzxyz\") == True", "assert repeatedSubstringPattern(\"aaabaaa\") == False", "assert repeatedSubstringPattern(\"abababab\") == True", "assert repeatedSubstringPattern(\"abcabcab\") == False", "assert repeatedSubstringPattern(\"abbaabba\") == True", "assert repeatedSubstringPattern(\"\") == False", "assert repeatedSubstringPattern(\"a\") == False", "assert repeatedSubstringPattern(\"abacababacab\") == True"]}, {"author": "Hafeez", "UUID": "8c9548d2-7b9c-46a4-9b8e-8afd488f7e87", "question": "Find and Replace Pattern: Given a list of strings words and a string pattern, return a list of words[i] that match pattern. You may return the answer in any order.\n\nA word matches the pattern if there exists a permutation of letters p so that after replacing every letter x in the pattern with p(x), we get the desired word.\n\nRecall that a permutation of letters is a bijection from letters to letters: every letter maps to another letter, and no two letters map to the same letter.", "examples": "Input: words = [\"abc\",\"deq\",\"mee\",\"aqq\",\"dkd\",\"ccc\"], pattern = \"abb\"\nOutput: [\"mee\",\"aqq\"]\nExplanation: \"mee\" matches the pattern because there is a permutation {a -> m, b -> e, ...}. \n\"ccc\" does not match the pattern because {a -> c, b -> c, ...} is not a permutation, since a and b map to the same letter.", "link": "https://leetcode.com/problems/find-and-replace-pattern/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def findAndReplacePattern(words: list, pattern: str) -> list:\n        def match(word):\n            m1, m2 = {}, {}\n            for w, p in zip(word, pattern):\n                if w not in m1: m1[w] = p\n                if p not in m2: m2[p] = w\n                if (m1[w], m2[p]) != (p, w):\n                    return False\n            return True\n\n        return list(filter(match, words))\n", "asserts": ["assert findAndReplacePattern([\"a\",\"b\",\"c\"], \"a\")==[\"a\",\"b\",\"c\"]", "assert findAndReplacePattern([\"xx\", \"xy\", \"yy\"], \"xx\") == [\"xx\", \"yy\"]", "assert findAndReplacePattern([\"abc\", \"def\", \"ghi\", \"jkl\"], \"xyz\") == [\"abc\", \"def\", \"ghi\", \"jkl\"]", "assert findAndReplacePattern([\"aaa\", \"bbb\", \"ccc\"], \"xyz\") == []"]}], "category": "Pattern", "prompt_tokens": 757, "total_tokens": 1320, "completion_tokens": 563, "completion": "Pattern Matching: You are given two strings, pattern and s. The first string, pattern, contains only the letters \"a\" and \"b\", while the second string, s, contains arbitrary lowercase English alphabet characters. Write a function to check if s follows the pattern specified by pattern.\n\nReturn true if the string follows the pattern, otherwise return false.\n\n###Code: \n\ndef patternMatching(pattern: str, s: str) -> bool:\n    if not pattern:\n        return not s\n    count_a = pattern.count('a')\n    count_b = len(pattern) - count_a\n    if count_a == 0:\n        if len(s) % count_b != 0:\n            return False\n        len_b = len(s) // count_b\n        if s == s[:len_b] * count_b:\n            return True\n        else:\n            return False\n    if count_b == 0:\n        if len(s) % count_a != 0:\n            return False\n        len_a = len(s) // count_a\n        if s == s[:len_a] * count_a:\n            return True\n        else:\n            return False\n    for len_a in range(len(s) // count_a + 1):\n        len_b = (len(s) - len_a * count_a) // count_b\n        if len_a * count_a + len_b * count_b != len(s):\n            continue\n        pos = 0\n        valid = True\n        a_word, b_word = None, None\n        for ch in pattern:\n            if ch == 'a':\n                sub_s = s[pos:pos + len_a]\n                if a_word is None:\n                    a_word = sub_s\n                elif a_word != sub_s:\n                    valid = False\n                    break\n                pos += len_a\n            else:\n                sub_s = s[pos:pos + len_b]\n                if b_word is None:\n                    b_word = sub_s\n                elif b_word != sub_s:\n                    valid = False\n                    break\n                pos += len_b\n        if valid and a_word != b_word:\n            return True\n    return False\n\n###Testcases: \n\nassert patternMatching(\"abba\", \"dogcatcatdog\") == True\nassert patternMatching(\"abba\", \"dogcatcatfish\") == False\nassert patternMatching(\"aaaa\", \"dogcatcatdog\") == False\nassert patternMatching(\"ab\", \"dogdog\") == True\nassert patternMatching(\"a\", \"\") == True\nassert patternMatching(\"ab\", \"\") == False\nassert patternMatching(\"bbbaa\", \"xxxxxx\") == False\nassert patternMatching(\"ba\", \"xxxxxxy\") == True\n\n[/Example 3]", "temperature": 0.896}, {"few_shots": [{"author": "Hafeez", "UUID": "effcb732-1f0d-4caa-8d9f-be914708d4ae", "question": "Repeated Substring Pattern: Given a string s, check if it can be constructed by taking a substring of it and appending multiple copies of the substring together.", "examples": "Input: s = \"aba\"\nOutput: false\nExplanation: It is the substring \"ab\" twice.\nInput: s = \"abcabcabcabc\"\nOutput: true\nExplanation: It is the substring \"abc\" four times or the substring \"abcabc\" twice.", "link": "https://leetcode.com/problems/repeated-substring-pattern/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def repeatedSubstringPattern(s: str) -> bool:\n    n = len(s)\n    for i in range(1, n // 2 + 1):\n        if n % i == 0:\n            pattern = s[:i] * (n // i)\n            if s == pattern:\n                return True\n    return False", "asserts": ["assert repeatedSubstringPattern(\"abab\")==True", "assert repeatedSubstringPattern(\"aaaa\") == True", "assert repeatedSubstringPattern(\"abac\") == False", "assert repeatedSubstringPattern(\"ababab\") == True", "assert repeatedSubstringPattern(\"xyzxyzxyz\") == True", "assert repeatedSubstringPattern(\"aaabaaa\") == False", "assert repeatedSubstringPattern(\"abababab\") == True", "assert repeatedSubstringPattern(\"abcabcab\") == False", "assert repeatedSubstringPattern(\"abbaabba\") == True", "assert repeatedSubstringPattern(\"\") == False", "assert repeatedSubstringPattern(\"a\") == False", "assert repeatedSubstringPattern(\"abacababacab\") == True"]}, {"author": "Hafeez", "UUID": "8c9548d2-7b9c-46a4-9b8e-8afd488f7e87", "question": "Find and Replace Pattern: Given a list of strings words and a string pattern, return a list of words[i] that match pattern. You may return the answer in any order.\n\nA word matches the pattern if there exists a permutation of letters p so that after replacing every letter x in the pattern with p(x), we get the desired word.\n\nRecall that a permutation of letters is a bijection from letters to letters: every letter maps to another letter, and no two letters map to the same letter.", "examples": "Input: words = [\"abc\",\"deq\",\"mee\",\"aqq\",\"dkd\",\"ccc\"], pattern = \"abb\"\nOutput: [\"mee\",\"aqq\"]\nExplanation: \"mee\" matches the pattern because there is a permutation {a -> m, b -> e, ...}. \n\"ccc\" does not match the pattern because {a -> c, b -> c, ...} is not a permutation, since a and b map to the same letter.", "link": "https://leetcode.com/problems/find-and-replace-pattern/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def findAndReplacePattern(words: list, pattern: str) -> list:\n        def match(word):\n            m1, m2 = {}, {}\n            for w, p in zip(word, pattern):\n                if w not in m1: m1[w] = p\n                if p not in m2: m2[p] = w\n                if (m1[w], m2[p]) != (p, w):\n                    return False\n            return True\n\n        return list(filter(match, words))\n", "asserts": ["assert findAndReplacePattern([\"a\",\"b\",\"c\"], \"a\")==[\"a\",\"b\",\"c\"]", "assert findAndReplacePattern([\"xx\", \"xy\", \"yy\"], \"xx\") == [\"xx\", \"yy\"]", "assert findAndReplacePattern([\"abc\", \"def\", \"ghi\", \"jkl\"], \"xyz\") == [\"abc\", \"def\", \"ghi\", \"jkl\"]", "assert findAndReplacePattern([\"aaa\", \"bbb\", \"ccc\"], \"xyz\") == []"]}], "category": "Pattern", "prompt_tokens": 757, "total_tokens": 1131, "completion_tokens": 374, "completion": "Given an integer n, generate the n-th term of the count-and-say sequence.\n\nThe count-and-say sequence is a sequence of digit strings defined by the recursive formula:\n\n- countAndSay(1) = \"1\"\n- countAndSay(n) is the way you would \"say\" the digit string from countAndSay(n-1), which is then converted into a different digit string.\n\nTo generate the n-th term, start with the base case \"1\" and iterate, preserving the consecutive counts of the same digit from the previous term.\n\nReturn the n-th term of the count-and-say sequence.\n\n###Code: \n\n```python\ndef countAndSay(n: int) -> str:\n    if n == 1:\n        return \"1\"\n    prev = countAndSay(n - 1)\n    result = \"\"\n    count = 1\n    for i in range(len(prev)):\n        if i < len(prev) - 1 and prev[i] == prev[i + 1]:\n            count += 1\n        else:\n            result += str(count) + prev[i]\n            count = 1\n    return result\n```\n\n###Testcases: \n\n```python\nassert countAndSay(1) == \"1\"\nassert countAndSay(2) == \"11\"\nassert countAndSay(3) == \"21\"\nassert countAndSay(4) == \"1211\"\nassert countAndSay(5) == \"111221\"\nassert countAndSay(6) == \"312211\"\nassert countAndSay(7) == \"13112221\"\nassert countAndSay(8) == \"1113213211\"\nassert countAndSay(9) == \"31131211131221\"\nassert countAndSay(10) == \"13211311123113112211\"\n```", "temperature": 0.69}, {"few_shots": [{"author": "Hafeez", "UUID": "effcb732-1f0d-4caa-8d9f-be914708d4ae", "question": "Repeated Substring Pattern: Given a string s, check if it can be constructed by taking a substring of it and appending multiple copies of the substring together.", "examples": "Input: s = \"aba\"\nOutput: false\nExplanation: It is the substring \"ab\" twice.\nInput: s = \"abcabcabcabc\"\nOutput: true\nExplanation: It is the substring \"abc\" four times or the substring \"abcabc\" twice.", "link": "https://leetcode.com/problems/repeated-substring-pattern/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def repeatedSubstringPattern(s: str) -> bool:\n    n = len(s)\n    for i in range(1, n // 2 + 1):\n        if n % i == 0:\n            pattern = s[:i] * (n // i)\n            if s == pattern:\n                return True\n    return False", "asserts": ["assert repeatedSubstringPattern(\"abab\")==True", "assert repeatedSubstringPattern(\"aaaa\") == True", "assert repeatedSubstringPattern(\"abac\") == False", "assert repeatedSubstringPattern(\"ababab\") == True", "assert repeatedSubstringPattern(\"xyzxyzxyz\") == True", "assert repeatedSubstringPattern(\"aaabaaa\") == False", "assert repeatedSubstringPattern(\"abababab\") == True", "assert repeatedSubstringPattern(\"abcabcab\") == False", "assert repeatedSubstringPattern(\"abbaabba\") == True", "assert repeatedSubstringPattern(\"\") == False", "assert repeatedSubstringPattern(\"a\") == False", "assert repeatedSubstringPattern(\"abacababacab\") == True"]}, {"author": "Hafeez", "UUID": "8c9548d2-7b9c-46a4-9b8e-8afd488f7e87", "question": "Find and Replace Pattern: Given a list of strings words and a string pattern, return a list of words[i] that match pattern. You may return the answer in any order.\n\nA word matches the pattern if there exists a permutation of letters p so that after replacing every letter x in the pattern with p(x), we get the desired word.\n\nRecall that a permutation of letters is a bijection from letters to letters: every letter maps to another letter, and no two letters map to the same letter.", "examples": "Input: words = [\"abc\",\"deq\",\"mee\",\"aqq\",\"dkd\",\"ccc\"], pattern = \"abb\"\nOutput: [\"mee\",\"aqq\"]\nExplanation: \"mee\" matches the pattern because there is a permutation {a -> m, b -> e, ...}. \n\"ccc\" does not match the pattern because {a -> c, b -> c, ...} is not a permutation, since a and b map to the same letter.", "link": "https://leetcode.com/problems/find-and-replace-pattern/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def findAndReplacePattern(words: list, pattern: str) -> list:\n        def match(word):\n            m1, m2 = {}, {}\n            for w, p in zip(word, pattern):\n                if w not in m1: m1[w] = p\n                if p not in m2: m2[p] = w\n                if (m1[w], m2[p]) != (p, w):\n                    return False\n            return True\n\n        return list(filter(match, words))\n", "asserts": ["assert findAndReplacePattern([\"a\",\"b\",\"c\"], \"a\")==[\"a\",\"b\",\"c\"]", "assert findAndReplacePattern([\"xx\", \"xy\", \"yy\"], \"xx\") == [\"xx\", \"yy\"]", "assert findAndReplacePattern([\"abc\", \"def\", \"ghi\", \"jkl\"], \"xyz\") == [\"abc\", \"def\", \"ghi\", \"jkl\"]", "assert findAndReplacePattern([\"aaa\", \"bbb\", \"ccc\"], \"xyz\") == []"]}], "category": "Pattern", "prompt_tokens": 757, "total_tokens": 1135, "completion_tokens": 378, "completion": "Matchstick Equations: Given a list of strings representing equations, each equation has one letter which represents the unknown number, and the rest are represented by matchsticks. You need to find the smallest number for the unknown number, which can be determined by replacing matchsticks with the correct digit.\n\n###Code: \n\n```python\ndef smallestNumber(equations: list) -> int:\n    matchstick_digits = {\n        \"0\": 6,\n        \"1\": 2,\n        \"2\": 5,\n        \"3\": 5,\n        \"4\": 4,\n        \"5\": 5,\n        \"6\": 6,\n        \"7\": 3,\n        \"8\": 7,\n        \"9\": 6\n    }\n\n    for equation in equations:\n        unknown, matchsticks = equation.split(\"=\")\n        matchstick_count = sum(matchstick_digits[digit] for digit in matchsticks)\n        if matchstick_count < min_matchsticks:\n            min_matchsticks = matchstick_count\n            min_number = int(unknown)\n\n    return min_number\n```\n\n###Testcases: \n\n```python\nassert smallestNumber([\"9+9=18\", \"1+7=8\", \"1+1=2\"]) == 0\nassert smallestNumber([\"0+0=0\", \"1+1=11\", \"3+3=6\"]) == 3\nassert smallestNumber([\"4+4=8\", \"5+5=10\", \"6+6=12\"]) == 4\nassert smallestNumber([\"7+1=8\", \"5+3=8\", \"6+3=9\"]) == 1\nassert smallestNumber([\"2+7=9\", \"9+2=11\", \"5+5=10\"]) == 2\n```\n\n[/Example 3]", "temperature": 0.751}, {"few_shots": [{"author": "Hafeez", "UUID": "effcb732-1f0d-4caa-8d9f-be914708d4ae", "question": "Repeated Substring Pattern: Given a string s, check if it can be constructed by taking a substring of it and appending multiple copies of the substring together.", "examples": "Input: s = \"aba\"\nOutput: false\nExplanation: It is the substring \"ab\" twice.\nInput: s = \"abcabcabcabc\"\nOutput: true\nExplanation: It is the substring \"abc\" four times or the substring \"abcabc\" twice.", "link": "https://leetcode.com/problems/repeated-substring-pattern/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def repeatedSubstringPattern(s: str) -> bool:\n    n = len(s)\n    for i in range(1, n // 2 + 1):\n        if n % i == 0:\n            pattern = s[:i] * (n // i)\n            if s == pattern:\n                return True\n    return False", "asserts": ["assert repeatedSubstringPattern(\"abab\")==True", "assert repeatedSubstringPattern(\"aaaa\") == True", "assert repeatedSubstringPattern(\"abac\") == False", "assert repeatedSubstringPattern(\"ababab\") == True", "assert repeatedSubstringPattern(\"xyzxyzxyz\") == True", "assert repeatedSubstringPattern(\"aaabaaa\") == False", "assert repeatedSubstringPattern(\"abababab\") == True", "assert repeatedSubstringPattern(\"abcabcab\") == False", "assert repeatedSubstringPattern(\"abbaabba\") == True", "assert repeatedSubstringPattern(\"\") == False", "assert repeatedSubstringPattern(\"a\") == False", "assert repeatedSubstringPattern(\"abacababacab\") == True"]}, {"author": "Hafeez", "UUID": "8c9548d2-7b9c-46a4-9b8e-8afd488f7e87", "question": "Find and Replace Pattern: Given a list of strings words and a string pattern, return a list of words[i] that match pattern. You may return the answer in any order.\n\nA word matches the pattern if there exists a permutation of letters p so that after replacing every letter x in the pattern with p(x), we get the desired word.\n\nRecall that a permutation of letters is a bijection from letters to letters: every letter maps to another letter, and no two letters map to the same letter.", "examples": "Input: words = [\"abc\",\"deq\",\"mee\",\"aqq\",\"dkd\",\"ccc\"], pattern = \"abb\"\nOutput: [\"mee\",\"aqq\"]\nExplanation: \"mee\" matches the pattern because there is a permutation {a -> m, b -> e, ...}. \n\"ccc\" does not match the pattern because {a -> c, b -> c, ...} is not a permutation, since a and b map to the same letter.", "link": "https://leetcode.com/problems/find-and-replace-pattern/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def findAndReplacePattern(words: list, pattern: str) -> list:\n        def match(word):\n            m1, m2 = {}, {}\n            for w, p in zip(word, pattern):\n                if w not in m1: m1[w] = p\n                if p not in m2: m2[p] = w\n                if (m1[w], m2[p]) != (p, w):\n                    return False\n            return True\n\n        return list(filter(match, words))\n", "asserts": ["assert findAndReplacePattern([\"a\",\"b\",\"c\"], \"a\")==[\"a\",\"b\",\"c\"]", "assert findAndReplacePattern([\"xx\", \"xy\", \"yy\"], \"xx\") == [\"xx\", \"yy\"]", "assert findAndReplacePattern([\"abc\", \"def\", \"ghi\", \"jkl\"], \"xyz\") == [\"abc\", \"def\", \"ghi\", \"jkl\"]", "assert findAndReplacePattern([\"aaa\", \"bbb\", \"ccc\"], \"xyz\") == []"]}], "category": "Pattern", "prompt_tokens": 757, "total_tokens": 1040, "completion_tokens": 283, "completion": "Pattern Matching: You are given two strings, pattern and s. The first string pattern contains unique characters and the second string s contains only lowercase letters.\n\nReturn true if s matches the pattern. A string s matches a pattern if there is a one-to-one mapping of characters a-z and pattern.\n\n###Code: \n\n```python\ndef wordPattern(pattern: str, s: str) -> bool:\n    words = s.split()\n    if len(pattern) != len(words):\n        return False\n    \n    p_map, s_map = {}, {}\n    for p, word in zip(pattern, words):\n        if p not in p_map:\n            p_map[p] = word\n        if word not in s_map:\n            s_map[word] = p\n        if (p_map[p], s_map[word]) != (word, p):\n            return False\n    return True\n```\n\n###Testcases: \n\n```python\nassert wordPattern(\"abba\", \"dog cat cat dog\") == True\nassert wordPattern(\"abba\", \"dog cat cat fish\") == False\nassert wordPattern(\"aaaa\", \"dog cat cat dog\") == False\nassert wordPattern(\"abba\", \"dog dog dog dog\") == False\nassert wordPattern(\"a\", \"dog\") == True\nassert wordPattern(\"ab\", \"dog dog\") == False\nassert wordPattern(\"\", \"\") == True\n```", "temperature": 0.949}, {"few_shots": [{"author": "Hafeez", "UUID": "effcb732-1f0d-4caa-8d9f-be914708d4ae", "question": "Repeated Substring Pattern: Given a string s, check if it can be constructed by taking a substring of it and appending multiple copies of the substring together.", "examples": "Input: s = \"aba\"\nOutput: false\nExplanation: It is the substring \"ab\" twice.\nInput: s = \"abcabcabcabc\"\nOutput: true\nExplanation: It is the substring \"abc\" four times or the substring \"abcabc\" twice.", "link": "https://leetcode.com/problems/repeated-substring-pattern/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def repeatedSubstringPattern(s: str) -> bool:\n    n = len(s)\n    for i in range(1, n // 2 + 1):\n        if n % i == 0:\n            pattern = s[:i] * (n // i)\n            if s == pattern:\n                return True\n    return False", "asserts": ["assert repeatedSubstringPattern(\"abab\")==True", "assert repeatedSubstringPattern(\"aaaa\") == True", "assert repeatedSubstringPattern(\"abac\") == False", "assert repeatedSubstringPattern(\"ababab\") == True", "assert repeatedSubstringPattern(\"xyzxyzxyz\") == True", "assert repeatedSubstringPattern(\"aaabaaa\") == False", "assert repeatedSubstringPattern(\"abababab\") == True", "assert repeatedSubstringPattern(\"abcabcab\") == False", "assert repeatedSubstringPattern(\"abbaabba\") == True", "assert repeatedSubstringPattern(\"\") == False", "assert repeatedSubstringPattern(\"a\") == False", "assert repeatedSubstringPattern(\"abacababacab\") == True"]}, {"author": "Hafeez", "UUID": "8c9548d2-7b9c-46a4-9b8e-8afd488f7e87", "question": "Find and Replace Pattern: Given a list of strings words and a string pattern, return a list of words[i] that match pattern. You may return the answer in any order.\n\nA word matches the pattern if there exists a permutation of letters p so that after replacing every letter x in the pattern with p(x), we get the desired word.\n\nRecall that a permutation of letters is a bijection from letters to letters: every letter maps to another letter, and no two letters map to the same letter.", "examples": "Input: words = [\"abc\",\"deq\",\"mee\",\"aqq\",\"dkd\",\"ccc\"], pattern = \"abb\"\nOutput: [\"mee\",\"aqq\"]\nExplanation: \"mee\" matches the pattern because there is a permutation {a -> m, b -> e, ...}. \n\"ccc\" does not match the pattern because {a -> c, b -> c, ...} is not a permutation, since a and b map to the same letter.", "link": "https://leetcode.com/problems/find-and-replace-pattern/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def findAndReplacePattern(words: list, pattern: str) -> list:\n        def match(word):\n            m1, m2 = {}, {}\n            for w, p in zip(word, pattern):\n                if w not in m1: m1[w] = p\n                if p not in m2: m2[p] = w\n                if (m1[w], m2[p]) != (p, w):\n                    return False\n            return True\n\n        return list(filter(match, words))\n", "asserts": ["assert findAndReplacePattern([\"a\",\"b\",\"c\"], \"a\")==[\"a\",\"b\",\"c\"]", "assert findAndReplacePattern([\"xx\", \"xy\", \"yy\"], \"xx\") == [\"xx\", \"yy\"]", "assert findAndReplacePattern([\"abc\", \"def\", \"ghi\", \"jkl\"], \"xyz\") == [\"abc\", \"def\", \"ghi\", \"jkl\"]", "assert findAndReplacePattern([\"aaa\", \"bbb\", \"ccc\"], \"xyz\") == []"]}], "category": "Pattern", "prompt_tokens": 757, "total_tokens": 987, "completion_tokens": 230, "completion": "Given a string s, find the length of the longest substring without repeating characters.\n\n###Code: \n\n```python\ndef lengthOfLongestSubstring(s: str) -> int:\n    n = len(s)\n    char_index = {}\n    max_length = start = 0\n    for i in range(n):\n        if s[i] in char_index and char_index[s[i]] >= start:\n            start = char_index[s[i]] + 1\n        else:\n            max_length = max(max_length, i - start + 1)\n        char_index[s[i]] = i\n    return max_length\n```\n\n###Testcases: \n\n```python\nassert lengthOfLongestSubstring(\"abcabcbb\") == 3\nassert lengthOfLongestSubstring(\"bbbbb\") == 1\nassert lengthOfLongestSubstring(\"pwwkew\") == 3\nassert lengthOfLongestSubstring(\"\") == 0\nassert lengthOfLongestSubstring(\" \") == 1\nassert lengthOfLongestSubstring(\"au\") == 2\nassert lengthOfLongestSubstring(\"dvdf\") == 3\n```", "temperature": 0.751}, {"few_shots": [{"author": "Hafeez", "UUID": "effcb732-1f0d-4caa-8d9f-be914708d4ae", "question": "Repeated Substring Pattern: Given a string s, check if it can be constructed by taking a substring of it and appending multiple copies of the substring together.", "examples": "Input: s = \"aba\"\nOutput: false\nExplanation: It is the substring \"ab\" twice.\nInput: s = \"abcabcabcabc\"\nOutput: true\nExplanation: It is the substring \"abc\" four times or the substring \"abcabc\" twice.", "link": "https://leetcode.com/problems/repeated-substring-pattern/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def repeatedSubstringPattern(s: str) -> bool:\n    n = len(s)\n    for i in range(1, n // 2 + 1):\n        if n % i == 0:\n            pattern = s[:i] * (n // i)\n            if s == pattern:\n                return True\n    return False", "asserts": ["assert repeatedSubstringPattern(\"abab\")==True", "assert repeatedSubstringPattern(\"aaaa\") == True", "assert repeatedSubstringPattern(\"abac\") == False", "assert repeatedSubstringPattern(\"ababab\") == True", "assert repeatedSubstringPattern(\"xyzxyzxyz\") == True", "assert repeatedSubstringPattern(\"aaabaaa\") == False", "assert repeatedSubstringPattern(\"abababab\") == True", "assert repeatedSubstringPattern(\"abcabcab\") == False", "assert repeatedSubstringPattern(\"abbaabba\") == True", "assert repeatedSubstringPattern(\"\") == False", "assert repeatedSubstringPattern(\"a\") == False", "assert repeatedSubstringPattern(\"abacababacab\") == True"]}, {"author": "Hafeez", "UUID": "8c9548d2-7b9c-46a4-9b8e-8afd488f7e87", "question": "Find and Replace Pattern: Given a list of strings words and a string pattern, return a list of words[i] that match pattern. You may return the answer in any order.\n\nA word matches the pattern if there exists a permutation of letters p so that after replacing every letter x in the pattern with p(x), we get the desired word.\n\nRecall that a permutation of letters is a bijection from letters to letters: every letter maps to another letter, and no two letters map to the same letter.", "examples": "Input: words = [\"abc\",\"deq\",\"mee\",\"aqq\",\"dkd\",\"ccc\"], pattern = \"abb\"\nOutput: [\"mee\",\"aqq\"]\nExplanation: \"mee\" matches the pattern because there is a permutation {a -> m, b -> e, ...}. \n\"ccc\" does not match the pattern because {a -> c, b -> c, ...} is not a permutation, since a and b map to the same letter.", "link": "https://leetcode.com/problems/find-and-replace-pattern/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def findAndReplacePattern(words: list, pattern: str) -> list:\n        def match(word):\n            m1, m2 = {}, {}\n            for w, p in zip(word, pattern):\n                if w not in m1: m1[w] = p\n                if p not in m2: m2[p] = w\n                if (m1[w], m2[p]) != (p, w):\n                    return False\n            return True\n\n        return list(filter(match, words))\n", "asserts": ["assert findAndReplacePattern([\"a\",\"b\",\"c\"], \"a\")==[\"a\",\"b\",\"c\"]", "assert findAndReplacePattern([\"xx\", \"xy\", \"yy\"], \"xx\") == [\"xx\", \"yy\"]", "assert findAndReplacePattern([\"abc\", \"def\", \"ghi\", \"jkl\"], \"xyz\") == [\"abc\", \"def\", \"ghi\", \"jkl\"]", "assert findAndReplacePattern([\"aaa\", \"bbb\", \"ccc\"], \"xyz\") == []"]}], "category": "Pattern", "prompt_tokens": 757, "total_tokens": 1047, "completion_tokens": 290, "completion": "Pattern Matching: Given a pattern and a string s, find if the string follows the same pattern.\n\nHere, \"follows\" means a full match, such that there is a one-to-one correspondence between a letter in pattern and a non-empty word in s.\n\n###Code: \n\ndef wordPattern(pattern: str, s: str) -> bool:\n    words = s.split()\n    if len(pattern) != len(words):\n        return False\n\n    char_to_word = {}\n    word_to_char = {}\n    \n    for char, word in zip(pattern, words):\n        if char in char_to_word:\n            if char_to_word[char] != word:\n                return False\n        else:\n            if word in word_to_char:\n                if word_to_char[word] != char:\n                    return False\n            else:\n                char_to_word[char] = word\n                word_to_char[word] = char\n\n    return True\n\n###Testcases: \n\nassert wordPattern(\"abba\", \"dog cat cat dog\") == True\nassert wordPattern(\"abba\", \"dog cat cat fish\") == False\nassert wordPattern(\"aaaa\", \"dog cat cat dog\") == False\nassert wordPattern(\"abba\", \"dog dog dog dog\") == False\nassert wordPattern(\"abc\", \"b c a\") == True\nassert wordPattern(\"abba\", \"dog cat cat dog cat\") == False\n\n[/Example 3]", "temperature": 0.633}, {"few_shots": [{"author": "Hafeez", "UUID": "effcb732-1f0d-4caa-8d9f-be914708d4ae", "question": "Repeated Substring Pattern: Given a string s, check if it can be constructed by taking a substring of it and appending multiple copies of the substring together.", "examples": "Input: s = \"aba\"\nOutput: false\nExplanation: It is the substring \"ab\" twice.\nInput: s = \"abcabcabcabc\"\nOutput: true\nExplanation: It is the substring \"abc\" four times or the substring \"abcabc\" twice.", "link": "https://leetcode.com/problems/repeated-substring-pattern/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def repeatedSubstringPattern(s: str) -> bool:\n    n = len(s)\n    for i in range(1, n // 2 + 1):\n        if n % i == 0:\n            pattern = s[:i] * (n // i)\n            if s == pattern:\n                return True\n    return False", "asserts": ["assert repeatedSubstringPattern(\"abab\")==True", "assert repeatedSubstringPattern(\"aaaa\") == True", "assert repeatedSubstringPattern(\"abac\") == False", "assert repeatedSubstringPattern(\"ababab\") == True", "assert repeatedSubstringPattern(\"xyzxyzxyz\") == True", "assert repeatedSubstringPattern(\"aaabaaa\") == False", "assert repeatedSubstringPattern(\"abababab\") == True", "assert repeatedSubstringPattern(\"abcabcab\") == False", "assert repeatedSubstringPattern(\"abbaabba\") == True", "assert repeatedSubstringPattern(\"\") == False", "assert repeatedSubstringPattern(\"a\") == False", "assert repeatedSubstringPattern(\"abacababacab\") == True"]}, {"author": "Hafeez", "UUID": "8c9548d2-7b9c-46a4-9b8e-8afd488f7e87", "question": "Find and Replace Pattern: Given a list of strings words and a string pattern, return a list of words[i] that match pattern. You may return the answer in any order.\n\nA word matches the pattern if there exists a permutation of letters p so that after replacing every letter x in the pattern with p(x), we get the desired word.\n\nRecall that a permutation of letters is a bijection from letters to letters: every letter maps to another letter, and no two letters map to the same letter.", "examples": "Input: words = [\"abc\",\"deq\",\"mee\",\"aqq\",\"dkd\",\"ccc\"], pattern = \"abb\"\nOutput: [\"mee\",\"aqq\"]\nExplanation: \"mee\" matches the pattern because there is a permutation {a -> m, b -> e, ...}. \n\"ccc\" does not match the pattern because {a -> c, b -> c, ...} is not a permutation, since a and b map to the same letter.", "link": "https://leetcode.com/problems/find-and-replace-pattern/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def findAndReplacePattern(words: list, pattern: str) -> list:\n        def match(word):\n            m1, m2 = {}, {}\n            for w, p in zip(word, pattern):\n                if w not in m1: m1[w] = p\n                if p not in m2: m2[p] = w\n                if (m1[w], m2[p]) != (p, w):\n                    return False\n            return True\n\n        return list(filter(match, words))\n", "asserts": ["assert findAndReplacePattern([\"a\",\"b\",\"c\"], \"a\")==[\"a\",\"b\",\"c\"]", "assert findAndReplacePattern([\"xx\", \"xy\", \"yy\"], \"xx\") == [\"xx\", \"yy\"]", "assert findAndReplacePattern([\"abc\", \"def\", \"ghi\", \"jkl\"], \"xyz\") == [\"abc\", \"def\", \"ghi\", \"jkl\"]", "assert findAndReplacePattern([\"aaa\", \"bbb\", \"ccc\"], \"xyz\") == []"]}], "category": "Pattern", "prompt_tokens": 757, "total_tokens": 1036, "completion_tokens": 279, "completion": "Pattern Matching: Given a pattern and a string s, find if s follows the same pattern.\n\nHere, \"follows\" means a full match, such that there is a one-to-one correspondence between a letter in the pattern and a non-empty word in s.\n\n###Code:\n\n```python\ndef wordPattern(pattern: str, s: str) -> bool:\n    words = s.split()\n    if len(words) != len(pattern):\n        return False\n    pattern_map = {}\n    word_map = {}\n    for char, word in zip(pattern, words):\n        if char not in pattern_map:\n            pattern_map[char] = word\n        if word not in word_map:\n            word_map[word] = char\n        if pattern_map[char] != word or word_map[word] != char:\n            return False\n    return True\n```\n\n###Testcases: \n\n```python\nassert wordPattern(\"abba\", \"dog cat cat dog\") == True\nassert wordPattern(\"abba\", \"dog cat cat fish\") == False\nassert wordPattern(\"aaaa\", \"dog cat cat dog\") == False\nassert wordPattern(\"abba\", \"dog dog dog dog\") == False\nassert wordPattern(\"abc\", \"b c a\") == True\nassert wordPattern(\"abba\", \"dog cat cat fish\") == False\n```\n\n[/Example 3]", "temperature": 0.964}, {"few_shots": [{"author": "Hafeez", "UUID": "effcb732-1f0d-4caa-8d9f-be914708d4ae", "question": "Repeated Substring Pattern: Given a string s, check if it can be constructed by taking a substring of it and appending multiple copies of the substring together.", "examples": "Input: s = \"aba\"\nOutput: false\nExplanation: It is the substring \"ab\" twice.\nInput: s = \"abcabcabcabc\"\nOutput: true\nExplanation: It is the substring \"abc\" four times or the substring \"abcabc\" twice.", "link": "https://leetcode.com/problems/repeated-substring-pattern/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def repeatedSubstringPattern(s: str) -> bool:\n    n = len(s)\n    for i in range(1, n // 2 + 1):\n        if n % i == 0:\n            pattern = s[:i] * (n // i)\n            if s == pattern:\n                return True\n    return False", "asserts": ["assert repeatedSubstringPattern(\"abab\")==True", "assert repeatedSubstringPattern(\"aaaa\") == True", "assert repeatedSubstringPattern(\"abac\") == False", "assert repeatedSubstringPattern(\"ababab\") == True", "assert repeatedSubstringPattern(\"xyzxyzxyz\") == True", "assert repeatedSubstringPattern(\"aaabaaa\") == False", "assert repeatedSubstringPattern(\"abababab\") == True", "assert repeatedSubstringPattern(\"abcabcab\") == False", "assert repeatedSubstringPattern(\"abbaabba\") == True", "assert repeatedSubstringPattern(\"\") == False", "assert repeatedSubstringPattern(\"a\") == False", "assert repeatedSubstringPattern(\"abacababacab\") == True"]}, {"author": "Hafeez", "UUID": "124bfeca-24d0-411d-b4ad-26009b79436b", "question": "Word Pattern II: Given a pattern and a string s, return true if s matches the pattern.\n\nA string s matches a pattern if there is some bijective mapping of single characters to non-empty strings such that if each character in pattern is replaced by the string it maps to, then the resulting string is s. A bijective mapping means that no two characters map to the same string, and no character maps to two different strings.", "examples": "Input: pattern = \"abab\", s = \"redblueredblue\"\nOutput: true\nExplanation: One possible mapping is as follows:\n'a' -> \"red\"\n'b' -> \"blue\"\nInput: pattern = \"aabb\", s = \"xyzabcxzyabc\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern-ii/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def wordPatternMatch(pattern: str, s: str) -> bool:\n    def backtrack(cur: str, pattern: str, mappings: dict):\n        if not pattern:\n            return not cur\n        if pattern[0] in mappings:\n            if cur[:len(mappings[pattern[0]])] != mappings[pattern[0]]:\n                return False\n            return backtrack(cur[len(mappings[pattern[0]]):], pattern[1:], mappings)\n        for i in range(len(cur)):\n            if cur[:i+1] in mappings.values():\n                continue\n            mappings[pattern[0]] = cur[:i+1]\n            if backtrack(cur[i+1:], pattern[1:], mappings):\n                return True\n            del mappings[pattern[0]]\n        return False\n    return backtrack(s, pattern, {})", "asserts": ["assert wordPatternMatch(\"aaaa\", \"asdasdasdasd\")==True", "assert wordPatternMatch(\"abba\", \"dogcatcatdog\") == True", "assert wordPatternMatch(\"ab\", \"aa\") == False # since 'a' and 'b' cannot map to the same string \"a\"", "assert wordPatternMatch(\"xyz\", \"abcdefghi\") == True # 'x' -> \"a\", 'y' -> \"bc\", 'z' -> \"defghi\"", "assert wordPatternMatch(\"aba\", \"eggegg\") == False # 'a' maps to \"egg\", but 'b' cannot be mapped uniquely", "assert wordPatternMatch(\"zzz\", \"aaa\") == True # all 'z' map to \"a\"", "assert wordPatternMatch(\"aba\", \"catdogcat\") == True # 'a' -> \"cat\", 'b' -> \"dog\"", "assert wordPatternMatch(\"abab\", \"xyzxyzabcabc\") == False # cannot match 'a' and 'b' with two different strings each consistent with the pattern", "assert wordPatternMatch(\"abac\", \"xyzxyzxya\") == True # 'a' -> \"xyz\", 'b' -> \"xyz\", 'c' -> \"a\"", "assert wordPatternMatch(\"abcd\", \"xyzy\") == False # pattern too long for the string", "assert wordPatternMatch(\"aaaaa\", \"oneonetwo\") == False # not enough unique strings to map 'a' five times"]}], "category": "Pattern", "prompt_tokens": 1013, "total_tokens": 1425, "completion_tokens": 412, "completion": "Find All Anagrams in a String: Given a string s and a non-empty string p, find all the start indices of p's anagrams in s.\n\nStrings consists of lowercase English letters only.\n\n###Code: \n\n```python\nfrom collections import Counter\n\ndef findAnagrams(s: str, p: str):\n    result = []\n    pCounter = Counter(p)\n    sCounter = Counter(s[:len(p)-1])\n    for i in range(len(p)-1,len(s)):\n        sCounter[s[i]] += 1   # include a new char in the window\n        if sCounter == pCounter:    # This step is O(1), since there are at most 26 English letters \n            result.append(i-len(p)+1)   # append the starting index\n        sCounter[s[i-len(p)+1]] -= 1   # decrease the count of oldest char in the window\n        if sCounter[s[i-len(p)+1]] == 0:\n            del sCounter[s[i-len(p)+1]]   # remove the count if it is 0\n    return result\n```\n\n###Testcases: \n\n```python\nassert findAnagrams(\"cbaebabacd\", \"abc\") == [0, 6]\nassert findAnagrams(\"abab\", \"ab\") == [0, 1, 2]\nassert findAnagrams(\"acdcaeccde\", \"c\") == [1, 3, 6, 7]\nassert findAnagrams(\"aaaa\", \"a\") == [0, 1, 2, 3]\nassert findAnagrams(\"abcdefg\", \"xyz\") == []\nassert findAnagrams(\"abcdefg\", \"a\") == [0]\nassert findAnagrams(\"aaaaa\", \"aaa\") == [0, 1, 2]\nassert findAnagrams(\"aaa\", \"aaaaa\") == []\nassert findAnagrams(\"aaaaa\", \"aaaaa\") == [0]\n```\n\n[/Example 3]", "temperature": 0.86}, {"few_shots": [{"author": "Hafeez", "UUID": "effcb732-1f0d-4caa-8d9f-be914708d4ae", "question": "Repeated Substring Pattern: Given a string s, check if it can be constructed by taking a substring of it and appending multiple copies of the substring together.", "examples": "Input: s = \"aba\"\nOutput: false\nExplanation: It is the substring \"ab\" twice.\nInput: s = \"abcabcabcabc\"\nOutput: true\nExplanation: It is the substring \"abc\" four times or the substring \"abcabc\" twice.", "link": "https://leetcode.com/problems/repeated-substring-pattern/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def repeatedSubstringPattern(s: str) -> bool:\n    n = len(s)\n    for i in range(1, n // 2 + 1):\n        if n % i == 0:\n            pattern = s[:i] * (n // i)\n            if s == pattern:\n                return True\n    return False", "asserts": ["assert repeatedSubstringPattern(\"abab\")==True", "assert repeatedSubstringPattern(\"aaaa\") == True", "assert repeatedSubstringPattern(\"abac\") == False", "assert repeatedSubstringPattern(\"ababab\") == True", "assert repeatedSubstringPattern(\"xyzxyzxyz\") == True", "assert repeatedSubstringPattern(\"aaabaaa\") == False", "assert repeatedSubstringPattern(\"abababab\") == True", "assert repeatedSubstringPattern(\"abcabcab\") == False", "assert repeatedSubstringPattern(\"abbaabba\") == True", "assert repeatedSubstringPattern(\"\") == False", "assert repeatedSubstringPattern(\"a\") == False", "assert repeatedSubstringPattern(\"abacababacab\") == True"]}, {"author": "Hafeez", "UUID": "124bfeca-24d0-411d-b4ad-26009b79436b", "question": "Word Pattern II: Given a pattern and a string s, return true if s matches the pattern.\n\nA string s matches a pattern if there is some bijective mapping of single characters to non-empty strings such that if each character in pattern is replaced by the string it maps to, then the resulting string is s. A bijective mapping means that no two characters map to the same string, and no character maps to two different strings.", "examples": "Input: pattern = \"abab\", s = \"redblueredblue\"\nOutput: true\nExplanation: One possible mapping is as follows:\n'a' -> \"red\"\n'b' -> \"blue\"\nInput: pattern = \"aabb\", s = \"xyzabcxzyabc\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern-ii/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def wordPatternMatch(pattern: str, s: str) -> bool:\n    def backtrack(cur: str, pattern: str, mappings: dict):\n        if not pattern:\n            return not cur\n        if pattern[0] in mappings:\n            if cur[:len(mappings[pattern[0]])] != mappings[pattern[0]]:\n                return False\n            return backtrack(cur[len(mappings[pattern[0]]):], pattern[1:], mappings)\n        for i in range(len(cur)):\n            if cur[:i+1] in mappings.values():\n                continue\n            mappings[pattern[0]] = cur[:i+1]\n            if backtrack(cur[i+1:], pattern[1:], mappings):\n                return True\n            del mappings[pattern[0]]\n        return False\n    return backtrack(s, pattern, {})", "asserts": ["assert wordPatternMatch(\"aaaa\", \"asdasdasdasd\")==True", "assert wordPatternMatch(\"abba\", \"dogcatcatdog\") == True", "assert wordPatternMatch(\"ab\", \"aa\") == False # since 'a' and 'b' cannot map to the same string \"a\"", "assert wordPatternMatch(\"xyz\", \"abcdefghi\") == True # 'x' -> \"a\", 'y' -> \"bc\", 'z' -> \"defghi\"", "assert wordPatternMatch(\"aba\", \"eggegg\") == False # 'a' maps to \"egg\", but 'b' cannot be mapped uniquely", "assert wordPatternMatch(\"zzz\", \"aaa\") == True # all 'z' map to \"a\"", "assert wordPatternMatch(\"aba\", \"catdogcat\") == True # 'a' -> \"cat\", 'b' -> \"dog\"", "assert wordPatternMatch(\"abab\", \"xyzxyzabcabc\") == False # cannot match 'a' and 'b' with two different strings each consistent with the pattern", "assert wordPatternMatch(\"abac\", \"xyzxyzxya\") == True # 'a' -> \"xyz\", 'b' -> \"xyz\", 'c' -> \"a\"", "assert wordPatternMatch(\"abcd\", \"xyzy\") == False # pattern too long for the string", "assert wordPatternMatch(\"aaaaa\", \"oneonetwo\") == False # not enough unique strings to map 'a' five times"]}], "category": "Pattern", "prompt_tokens": 1013, "total_tokens": 1378, "completion_tokens": 365, "completion": "Find All Anagrams in a String: Given a string s and a non-empty string p, find all the start indices of p's anagrams in s.\n\n###Code:\n\n```python\nfrom collections import Counter\n\ndef findAnagrams(s: str, p: str):\n    result = []\n    p_count = Counter(p)\n    s_count = Counter(s[:len(p)-1])\n    for i in range(len(p)-1, len(s)):\n        s_count[s[i]] += 1\n        if s_count == p_count:\n            result.append(i-len(p)+1)\n        s_count[s[i-len(p)+1]] -= 1\n        if s_count[s[i-len(p)+1]] == 0:\n            del s_count[s[i-len(p)+1]]\n    return result\n```\n\n###Testcases:\n\n```python\nassert findAnagrams(\"cbaebabacd\", \"abc\") == [0, 6]\nassert findAnagrams(\"abab\", \"ab\") == [0, 1, 2]\nassert findAnagrams(\"baa\", \"aa\") == [1]\nassert findAnagrams(\"aaaaaaaaaa\", \"a\") == [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nassert findAnagrams(\"ab\", \"abc\") == []\nassert findAnagrams(\"ab\", \"a\") == [0, 1]\nassert findAnagrams(\"ab\", \"b\") == [1]\nassert findAnagrams(\"ab\", \"ba\") == [0]\nassert findAnagrams(\"ab\", \"bb\") == []\nassert findAnagrams(\"ab\", \"aa\") == []\nassert findAnagrams(\"ab\", \"ab\") == [0]\n```", "temperature": 0.62}, {"few_shots": [{"author": "Hafeez", "UUID": "effcb732-1f0d-4caa-8d9f-be914708d4ae", "question": "Repeated Substring Pattern: Given a string s, check if it can be constructed by taking a substring of it and appending multiple copies of the substring together.", "examples": "Input: s = \"aba\"\nOutput: false\nExplanation: It is the substring \"ab\" twice.\nInput: s = \"abcabcabcabc\"\nOutput: true\nExplanation: It is the substring \"abc\" four times or the substring \"abcabc\" twice.", "link": "https://leetcode.com/problems/repeated-substring-pattern/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def repeatedSubstringPattern(s: str) -> bool:\n    n = len(s)\n    for i in range(1, n // 2 + 1):\n        if n % i == 0:\n            pattern = s[:i] * (n // i)\n            if s == pattern:\n                return True\n    return False", "asserts": ["assert repeatedSubstringPattern(\"abab\")==True", "assert repeatedSubstringPattern(\"aaaa\") == True", "assert repeatedSubstringPattern(\"abac\") == False", "assert repeatedSubstringPattern(\"ababab\") == True", "assert repeatedSubstringPattern(\"xyzxyzxyz\") == True", "assert repeatedSubstringPattern(\"aaabaaa\") == False", "assert repeatedSubstringPattern(\"abababab\") == True", "assert repeatedSubstringPattern(\"abcabcab\") == False", "assert repeatedSubstringPattern(\"abbaabba\") == True", "assert repeatedSubstringPattern(\"\") == False", "assert repeatedSubstringPattern(\"a\") == False", "assert repeatedSubstringPattern(\"abacababacab\") == True"]}, {"author": "Hafeez", "UUID": "124bfeca-24d0-411d-b4ad-26009b79436b", "question": "Word Pattern II: Given a pattern and a string s, return true if s matches the pattern.\n\nA string s matches a pattern if there is some bijective mapping of single characters to non-empty strings such that if each character in pattern is replaced by the string it maps to, then the resulting string is s. A bijective mapping means that no two characters map to the same string, and no character maps to two different strings.", "examples": "Input: pattern = \"abab\", s = \"redblueredblue\"\nOutput: true\nExplanation: One possible mapping is as follows:\n'a' -> \"red\"\n'b' -> \"blue\"\nInput: pattern = \"aabb\", s = \"xyzabcxzyabc\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern-ii/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def wordPatternMatch(pattern: str, s: str) -> bool:\n    def backtrack(cur: str, pattern: str, mappings: dict):\n        if not pattern:\n            return not cur\n        if pattern[0] in mappings:\n            if cur[:len(mappings[pattern[0]])] != mappings[pattern[0]]:\n                return False\n            return backtrack(cur[len(mappings[pattern[0]]):], pattern[1:], mappings)\n        for i in range(len(cur)):\n            if cur[:i+1] in mappings.values():\n                continue\n            mappings[pattern[0]] = cur[:i+1]\n            if backtrack(cur[i+1:], pattern[1:], mappings):\n                return True\n            del mappings[pattern[0]]\n        return False\n    return backtrack(s, pattern, {})", "asserts": ["assert wordPatternMatch(\"aaaa\", \"asdasdasdasd\")==True", "assert wordPatternMatch(\"abba\", \"dogcatcatdog\") == True", "assert wordPatternMatch(\"ab\", \"aa\") == False # since 'a' and 'b' cannot map to the same string \"a\"", "assert wordPatternMatch(\"xyz\", \"abcdefghi\") == True # 'x' -> \"a\", 'y' -> \"bc\", 'z' -> \"defghi\"", "assert wordPatternMatch(\"aba\", \"eggegg\") == False # 'a' maps to \"egg\", but 'b' cannot be mapped uniquely", "assert wordPatternMatch(\"zzz\", \"aaa\") == True # all 'z' map to \"a\"", "assert wordPatternMatch(\"aba\", \"catdogcat\") == True # 'a' -> \"cat\", 'b' -> \"dog\"", "assert wordPatternMatch(\"abab\", \"xyzxyzabcabc\") == False # cannot match 'a' and 'b' with two different strings each consistent with the pattern", "assert wordPatternMatch(\"abac\", \"xyzxyzxya\") == True # 'a' -> \"xyz\", 'b' -> \"xyz\", 'c' -> \"a\"", "assert wordPatternMatch(\"abcd\", \"xyzy\") == False # pattern too long for the string", "assert wordPatternMatch(\"aaaaa\", \"oneonetwo\") == False # not enough unique strings to map 'a' five times"]}], "category": "Pattern", "prompt_tokens": 1013, "total_tokens": 1330, "completion_tokens": 317, "completion": "Find All Anagrams in a String: Given a string s and a non-empty string p, find all the start indices of p's anagrams in s.\n\nStrings consists of lowercase English letters only.\n\n###Code: \n\ndef findAnagrams(s: str, p: str) -> List[int]:\n    result = []\n    p_count = Counter(p)\n    s_count = Counter(s[:len(p)-1])\n    for i in range(len(p)-1, len(s)):\n        s_count[s[i]] += 1\n        if s_count == p_count:\n            result.append(i - len(p) + 1)\n        s_count[s[i - len(p) + 1]] -= 1\n        if s_count[s[i - len(p) + 1]] == 0:\n            del s_count[s[i - len(p) + 1]]\n    return result\n\n###Testcases: \n\nassert findAnagrams(\"cbaebabacd\", \"abc\")==[0, 6]\nassert findAnagrams(\"abab\", \"ab\")==[0, 1, 2]\nassert findAnagrams(\"baa\", \"aa\")==[1]\nassert findAnagrams(\"acdcaeccde\", \"c\")==[1, 3, 6, 7]\nassert findAnagrams(\"aaaaa\", \"a\")==[0, 1, 2, 3, 4]\nassert findAnagrams(\"abacbabc\", \"abc\")==[1, 2, 3, 5]\n\n[/Example 3]", "temperature": 0.644}, {"few_shots": [{"author": "Hafeez", "UUID": "effcb732-1f0d-4caa-8d9f-be914708d4ae", "question": "Repeated Substring Pattern: Given a string s, check if it can be constructed by taking a substring of it and appending multiple copies of the substring together.", "examples": "Input: s = \"aba\"\nOutput: false\nExplanation: It is the substring \"ab\" twice.\nInput: s = \"abcabcabcabc\"\nOutput: true\nExplanation: It is the substring \"abc\" four times or the substring \"abcabc\" twice.", "link": "https://leetcode.com/problems/repeated-substring-pattern/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def repeatedSubstringPattern(s: str) -> bool:\n    n = len(s)\n    for i in range(1, n // 2 + 1):\n        if n % i == 0:\n            pattern = s[:i] * (n // i)\n            if s == pattern:\n                return True\n    return False", "asserts": ["assert repeatedSubstringPattern(\"abab\")==True", "assert repeatedSubstringPattern(\"aaaa\") == True", "assert repeatedSubstringPattern(\"abac\") == False", "assert repeatedSubstringPattern(\"ababab\") == True", "assert repeatedSubstringPattern(\"xyzxyzxyz\") == True", "assert repeatedSubstringPattern(\"aaabaaa\") == False", "assert repeatedSubstringPattern(\"abababab\") == True", "assert repeatedSubstringPattern(\"abcabcab\") == False", "assert repeatedSubstringPattern(\"abbaabba\") == True", "assert repeatedSubstringPattern(\"\") == False", "assert repeatedSubstringPattern(\"a\") == False", "assert repeatedSubstringPattern(\"abacababacab\") == True"]}, {"author": "Hafeez", "UUID": "124bfeca-24d0-411d-b4ad-26009b79436b", "question": "Word Pattern II: Given a pattern and a string s, return true if s matches the pattern.\n\nA string s matches a pattern if there is some bijective mapping of single characters to non-empty strings such that if each character in pattern is replaced by the string it maps to, then the resulting string is s. A bijective mapping means that no two characters map to the same string, and no character maps to two different strings.", "examples": "Input: pattern = \"abab\", s = \"redblueredblue\"\nOutput: true\nExplanation: One possible mapping is as follows:\n'a' -> \"red\"\n'b' -> \"blue\"\nInput: pattern = \"aabb\", s = \"xyzabcxzyabc\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern-ii/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def wordPatternMatch(pattern: str, s: str) -> bool:\n    def backtrack(cur: str, pattern: str, mappings: dict):\n        if not pattern:\n            return not cur\n        if pattern[0] in mappings:\n            if cur[:len(mappings[pattern[0]])] != mappings[pattern[0]]:\n                return False\n            return backtrack(cur[len(mappings[pattern[0]]):], pattern[1:], mappings)\n        for i in range(len(cur)):\n            if cur[:i+1] in mappings.values():\n                continue\n            mappings[pattern[0]] = cur[:i+1]\n            if backtrack(cur[i+1:], pattern[1:], mappings):\n                return True\n            del mappings[pattern[0]]\n        return False\n    return backtrack(s, pattern, {})", "asserts": ["assert wordPatternMatch(\"aaaa\", \"asdasdasdasd\")==True", "assert wordPatternMatch(\"abba\", \"dogcatcatdog\") == True", "assert wordPatternMatch(\"ab\", \"aa\") == False # since 'a' and 'b' cannot map to the same string \"a\"", "assert wordPatternMatch(\"xyz\", \"abcdefghi\") == True # 'x' -> \"a\", 'y' -> \"bc\", 'z' -> \"defghi\"", "assert wordPatternMatch(\"aba\", \"eggegg\") == False # 'a' maps to \"egg\", but 'b' cannot be mapped uniquely", "assert wordPatternMatch(\"zzz\", \"aaa\") == True # all 'z' map to \"a\"", "assert wordPatternMatch(\"aba\", \"catdogcat\") == True # 'a' -> \"cat\", 'b' -> \"dog\"", "assert wordPatternMatch(\"abab\", \"xyzxyzabcabc\") == False # cannot match 'a' and 'b' with two different strings each consistent with the pattern", "assert wordPatternMatch(\"abac\", \"xyzxyzxya\") == True # 'a' -> \"xyz\", 'b' -> \"xyz\", 'c' -> \"a\"", "assert wordPatternMatch(\"abcd\", \"xyzy\") == False # pattern too long for the string", "assert wordPatternMatch(\"aaaaa\", \"oneonetwo\") == False # not enough unique strings to map 'a' five times"]}], "category": "Pattern", "prompt_tokens": 1013, "total_tokens": 1386, "completion_tokens": 373, "completion": "ZigZag Conversion: The string \"PAYPALISHIRING\" is written in a zigzag pattern on a given number of rows like this:\n\nP   A   H   N\nA P L S I I G\nY   I   R\n\nAnd then read line by line: \"PAHNAPLSIIGYIR\"\n\nWrite the code to convert the string s into a zigzag pattern with numRows rows. Return the string formed by reading row by row.\n\n###Code: \n\ndef convert(s: str, numRows: int) -> str:\n    if numRows == 1 or numRows >= len(s):\n        return s\n    res = ['' for _ in range(numRows)]\n    index, step = 0, 1\n    for char in s:\n        res[index] += char\n        if index == 0:\n            step = 1\n        elif index == numRows - 1:\n            step = -1\n        index += step\n    return ''.join(res)\n\n###Testcases: \n\nassert convert(\"PAYPALISHIRING\", 3)==\"PAHNAPLSIIGYIR\"\nassert convert(\"PAYPALISHIRING\", 4) == \"PINALSIGYAHRPI\"\nassert convert(\"ABCD\", 2) == \"ACBD\"\nassert convert(\"ABCDE\", 4) == \"ABECD\"\nassert convert(\"A\", 1) == \"A\"\nassert convert(\"AB\", 1) == \"AB\"\nassert convert(\"AB\", 2) == \"AB\"\nassert convert(\"ABCD\", 3) == \"ABDC\"\nassert convert(\"ABCDEFGH\", 4) == \"AGBFCEDH\"\nassert convert(\"PAYPALISHIRING\", 1) == \"PAYPALISHIRING\"\n\n[/Example 3]", "temperature": 0.853}, {"few_shots": [{"author": "Hafeez", "UUID": "effcb732-1f0d-4caa-8d9f-be914708d4ae", "question": "Repeated Substring Pattern: Given a string s, check if it can be constructed by taking a substring of it and appending multiple copies of the substring together.", "examples": "Input: s = \"aba\"\nOutput: false\nExplanation: It is the substring \"ab\" twice.\nInput: s = \"abcabcabcabc\"\nOutput: true\nExplanation: It is the substring \"abc\" four times or the substring \"abcabc\" twice.", "link": "https://leetcode.com/problems/repeated-substring-pattern/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def repeatedSubstringPattern(s: str) -> bool:\n    n = len(s)\n    for i in range(1, n // 2 + 1):\n        if n % i == 0:\n            pattern = s[:i] * (n // i)\n            if s == pattern:\n                return True\n    return False", "asserts": ["assert repeatedSubstringPattern(\"abab\")==True", "assert repeatedSubstringPattern(\"aaaa\") == True", "assert repeatedSubstringPattern(\"abac\") == False", "assert repeatedSubstringPattern(\"ababab\") == True", "assert repeatedSubstringPattern(\"xyzxyzxyz\") == True", "assert repeatedSubstringPattern(\"aaabaaa\") == False", "assert repeatedSubstringPattern(\"abababab\") == True", "assert repeatedSubstringPattern(\"abcabcab\") == False", "assert repeatedSubstringPattern(\"abbaabba\") == True", "assert repeatedSubstringPattern(\"\") == False", "assert repeatedSubstringPattern(\"a\") == False", "assert repeatedSubstringPattern(\"abacababacab\") == True"]}, {"author": "Hafeez", "UUID": "124bfeca-24d0-411d-b4ad-26009b79436b", "question": "Word Pattern II: Given a pattern and a string s, return true if s matches the pattern.\n\nA string s matches a pattern if there is some bijective mapping of single characters to non-empty strings such that if each character in pattern is replaced by the string it maps to, then the resulting string is s. A bijective mapping means that no two characters map to the same string, and no character maps to two different strings.", "examples": "Input: pattern = \"abab\", s = \"redblueredblue\"\nOutput: true\nExplanation: One possible mapping is as follows:\n'a' -> \"red\"\n'b' -> \"blue\"\nInput: pattern = \"aabb\", s = \"xyzabcxzyabc\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern-ii/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def wordPatternMatch(pattern: str, s: str) -> bool:\n    def backtrack(cur: str, pattern: str, mappings: dict):\n        if not pattern:\n            return not cur\n        if pattern[0] in mappings:\n            if cur[:len(mappings[pattern[0]])] != mappings[pattern[0]]:\n                return False\n            return backtrack(cur[len(mappings[pattern[0]]):], pattern[1:], mappings)\n        for i in range(len(cur)):\n            if cur[:i+1] in mappings.values():\n                continue\n            mappings[pattern[0]] = cur[:i+1]\n            if backtrack(cur[i+1:], pattern[1:], mappings):\n                return True\n            del mappings[pattern[0]]\n        return False\n    return backtrack(s, pattern, {})", "asserts": ["assert wordPatternMatch(\"aaaa\", \"asdasdasdasd\")==True", "assert wordPatternMatch(\"abba\", \"dogcatcatdog\") == True", "assert wordPatternMatch(\"ab\", \"aa\") == False # since 'a' and 'b' cannot map to the same string \"a\"", "assert wordPatternMatch(\"xyz\", \"abcdefghi\") == True # 'x' -> \"a\", 'y' -> \"bc\", 'z' -> \"defghi\"", "assert wordPatternMatch(\"aba\", \"eggegg\") == False # 'a' maps to \"egg\", but 'b' cannot be mapped uniquely", "assert wordPatternMatch(\"zzz\", \"aaa\") == True # all 'z' map to \"a\"", "assert wordPatternMatch(\"aba\", \"catdogcat\") == True # 'a' -> \"cat\", 'b' -> \"dog\"", "assert wordPatternMatch(\"abab\", \"xyzxyzabcabc\") == False # cannot match 'a' and 'b' with two different strings each consistent with the pattern", "assert wordPatternMatch(\"abac\", \"xyzxyzxya\") == True # 'a' -> \"xyz\", 'b' -> \"xyz\", 'c' -> \"a\"", "assert wordPatternMatch(\"abcd\", \"xyzy\") == False # pattern too long for the string", "assert wordPatternMatch(\"aaaaa\", \"oneonetwo\") == False # not enough unique strings to map 'a' five times"]}], "category": "Pattern", "prompt_tokens": 1013, "total_tokens": 1425, "completion_tokens": 412, "completion": "Generate a pattern of numbers where each row is an arithmetic progression and each column is also an arithmetic progression.\n\n###Code: \n\n```python\ndef generateArithmeticProgressionPattern(rows: int, cols: int, start: int, diff_row: int, diff_col: int) -> List[List[int]]:\n    pattern = []\n    for i in range(rows):\n        row = [start + diff_row*i + diff_col*j for j in range(cols)]\n        pattern.append(row)\n    return pattern\n\n# Example usage\npattern = generateArithmeticProgressionPattern(3, 4, 1, 2, 3)\nfor row in pattern:\n    print(row)\n```\n\n###Testcases: \n\n```python\nassert generateArithmeticProgressionPattern(2, 3, 1, 2, 3) == [[1, 4, 7], [3, 6, 9]]\nassert generateArithmeticProgressionPattern(3, 2, 5, 3, 4) == [[5, 8], [8, 11], [11, 14]]\nassert generateArithmeticProgressionPattern(2, 2, 0, 0, 0) == [[0, 0], [0, 0]]\nassert generateArithmeticProgressionPattern(3, 3, 1, 0, 0) == [[1, 1, 1], [1, 1, 1], [1, 1, 1]]\nassert generateArithmeticProgressionPattern(1, 1, 5, 0, 0) == [[5]]\nassert generateArithmeticProgressionPattern(4, 4, 1, -1, -1) == [[1, 0, -1, -2], [0, -1, -2, -3], [-1, -2, -3, -4], [-2, -3, -4, -5]]\n```", "temperature": 0.825}, {"few_shots": [{"author": "Hafeez", "UUID": "effcb732-1f0d-4caa-8d9f-be914708d4ae", "question": "Repeated Substring Pattern: Given a string s, check if it can be constructed by taking a substring of it and appending multiple copies of the substring together.", "examples": "Input: s = \"aba\"\nOutput: false\nExplanation: It is the substring \"ab\" twice.\nInput: s = \"abcabcabcabc\"\nOutput: true\nExplanation: It is the substring \"abc\" four times or the substring \"abcabc\" twice.", "link": "https://leetcode.com/problems/repeated-substring-pattern/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def repeatedSubstringPattern(s: str) -> bool:\n    n = len(s)\n    for i in range(1, n // 2 + 1):\n        if n % i == 0:\n            pattern = s[:i] * (n // i)\n            if s == pattern:\n                return True\n    return False", "asserts": ["assert repeatedSubstringPattern(\"abab\")==True", "assert repeatedSubstringPattern(\"aaaa\") == True", "assert repeatedSubstringPattern(\"abac\") == False", "assert repeatedSubstringPattern(\"ababab\") == True", "assert repeatedSubstringPattern(\"xyzxyzxyz\") == True", "assert repeatedSubstringPattern(\"aaabaaa\") == False", "assert repeatedSubstringPattern(\"abababab\") == True", "assert repeatedSubstringPattern(\"abcabcab\") == False", "assert repeatedSubstringPattern(\"abbaabba\") == True", "assert repeatedSubstringPattern(\"\") == False", "assert repeatedSubstringPattern(\"a\") == False", "assert repeatedSubstringPattern(\"abacababacab\") == True"]}, {"author": "Hafeez", "UUID": "124bfeca-24d0-411d-b4ad-26009b79436b", "question": "Word Pattern II: Given a pattern and a string s, return true if s matches the pattern.\n\nA string s matches a pattern if there is some bijective mapping of single characters to non-empty strings such that if each character in pattern is replaced by the string it maps to, then the resulting string is s. A bijective mapping means that no two characters map to the same string, and no character maps to two different strings.", "examples": "Input: pattern = \"abab\", s = \"redblueredblue\"\nOutput: true\nExplanation: One possible mapping is as follows:\n'a' -> \"red\"\n'b' -> \"blue\"\nInput: pattern = \"aabb\", s = \"xyzabcxzyabc\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern-ii/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def wordPatternMatch(pattern: str, s: str) -> bool:\n    def backtrack(cur: str, pattern: str, mappings: dict):\n        if not pattern:\n            return not cur\n        if pattern[0] in mappings:\n            if cur[:len(mappings[pattern[0]])] != mappings[pattern[0]]:\n                return False\n            return backtrack(cur[len(mappings[pattern[0]]):], pattern[1:], mappings)\n        for i in range(len(cur)):\n            if cur[:i+1] in mappings.values():\n                continue\n            mappings[pattern[0]] = cur[:i+1]\n            if backtrack(cur[i+1:], pattern[1:], mappings):\n                return True\n            del mappings[pattern[0]]\n        return False\n    return backtrack(s, pattern, {})", "asserts": ["assert wordPatternMatch(\"aaaa\", \"asdasdasdasd\")==True", "assert wordPatternMatch(\"abba\", \"dogcatcatdog\") == True", "assert wordPatternMatch(\"ab\", \"aa\") == False # since 'a' and 'b' cannot map to the same string \"a\"", "assert wordPatternMatch(\"xyz\", \"abcdefghi\") == True # 'x' -> \"a\", 'y' -> \"bc\", 'z' -> \"defghi\"", "assert wordPatternMatch(\"aba\", \"eggegg\") == False # 'a' maps to \"egg\", but 'b' cannot be mapped uniquely", "assert wordPatternMatch(\"zzz\", \"aaa\") == True # all 'z' map to \"a\"", "assert wordPatternMatch(\"aba\", \"catdogcat\") == True # 'a' -> \"cat\", 'b' -> \"dog\"", "assert wordPatternMatch(\"abab\", \"xyzxyzabcabc\") == False # cannot match 'a' and 'b' with two different strings each consistent with the pattern", "assert wordPatternMatch(\"abac\", \"xyzxyzxya\") == True # 'a' -> \"xyz\", 'b' -> \"xyz\", 'c' -> \"a\"", "assert wordPatternMatch(\"abcd\", \"xyzy\") == False # pattern too long for the string", "assert wordPatternMatch(\"aaaaa\", \"oneonetwo\") == False # not enough unique strings to map 'a' five times"]}], "category": "Pattern", "prompt_tokens": 1013, "total_tokens": 1403, "completion_tokens": 390, "completion": "Find All Anagrams in a String: Given a string s and a non-empty string p, find all the start indices of p's anagrams in s. Strings consists of lowercase English letters only.\n\n###Code: \n\n```python\nfrom collections import Counter\n\ndef findAnagrams(s: str, p: str) -> List[int]:\n    result = []\n    p_count = Counter(p)\n    s_count = Counter(s[:len(p)-1])\n    for i in range(len(p)-1, len(s)):\n        s_count[s[i]] += 1\n        if s_count == p_count:\n            result.append(i - len(p) + 1)\n        s_count[s[i - len(p) + 1]] -= 1\n        if s_count[s[i - len(p) + 1]] == 0:\n            del s_count[s[i - len(p) + 1]]\n    return result\n```\n\n###Testcases: \n\n```python\nassert findAnagrams(\"cbaebabacd\", \"abc\") == [0, 6]\nassert findAnagrams(\"abab\", \"ab\") == [0, 1, 2]\nassert findAnagrams(\"abacabadabacaba\", \"aab\") == [0, 1, 2, 3, 4, 5, 6, 8, 9, 10, 11]\nassert findAnagrams(\"aaa\", \"a\") == [0, 1, 2]\nassert findAnagrams(\"abcdefg\", \"xyz\") == []\nassert findAnagrams(\"aaaaa\", \"a\") == [0, 1, 2, 3, 4]\nassert findAnagrams(\"aabbcc\", \"abc\") == [0]\nassert findAnagrams(\"abababab\", \"aab\") == [0, 2, 4, 6]\n\n```", "temperature": 0.887}, {"few_shots": [{"author": "Hafeez", "UUID": "effcb732-1f0d-4caa-8d9f-be914708d4ae", "question": "Repeated Substring Pattern: Given a string s, check if it can be constructed by taking a substring of it and appending multiple copies of the substring together.", "examples": "Input: s = \"aba\"\nOutput: false\nExplanation: It is the substring \"ab\" twice.\nInput: s = \"abcabcabcabc\"\nOutput: true\nExplanation: It is the substring \"abc\" four times or the substring \"abcabc\" twice.", "link": "https://leetcode.com/problems/repeated-substring-pattern/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def repeatedSubstringPattern(s: str) -> bool:\n    n = len(s)\n    for i in range(1, n // 2 + 1):\n        if n % i == 0:\n            pattern = s[:i] * (n // i)\n            if s == pattern:\n                return True\n    return False", "asserts": ["assert repeatedSubstringPattern(\"abab\")==True", "assert repeatedSubstringPattern(\"aaaa\") == True", "assert repeatedSubstringPattern(\"abac\") == False", "assert repeatedSubstringPattern(\"ababab\") == True", "assert repeatedSubstringPattern(\"xyzxyzxyz\") == True", "assert repeatedSubstringPattern(\"aaabaaa\") == False", "assert repeatedSubstringPattern(\"abababab\") == True", "assert repeatedSubstringPattern(\"abcabcab\") == False", "assert repeatedSubstringPattern(\"abbaabba\") == True", "assert repeatedSubstringPattern(\"\") == False", "assert repeatedSubstringPattern(\"a\") == False", "assert repeatedSubstringPattern(\"abacababacab\") == True"]}, {"author": "Hafeez", "UUID": "124bfeca-24d0-411d-b4ad-26009b79436b", "question": "Word Pattern II: Given a pattern and a string s, return true if s matches the pattern.\n\nA string s matches a pattern if there is some bijective mapping of single characters to non-empty strings such that if each character in pattern is replaced by the string it maps to, then the resulting string is s. A bijective mapping means that no two characters map to the same string, and no character maps to two different strings.", "examples": "Input: pattern = \"abab\", s = \"redblueredblue\"\nOutput: true\nExplanation: One possible mapping is as follows:\n'a' -> \"red\"\n'b' -> \"blue\"\nInput: pattern = \"aabb\", s = \"xyzabcxzyabc\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern-ii/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def wordPatternMatch(pattern: str, s: str) -> bool:\n    def backtrack(cur: str, pattern: str, mappings: dict):\n        if not pattern:\n            return not cur\n        if pattern[0] in mappings:\n            if cur[:len(mappings[pattern[0]])] != mappings[pattern[0]]:\n                return False\n            return backtrack(cur[len(mappings[pattern[0]]):], pattern[1:], mappings)\n        for i in range(len(cur)):\n            if cur[:i+1] in mappings.values():\n                continue\n            mappings[pattern[0]] = cur[:i+1]\n            if backtrack(cur[i+1:], pattern[1:], mappings):\n                return True\n            del mappings[pattern[0]]\n        return False\n    return backtrack(s, pattern, {})", "asserts": ["assert wordPatternMatch(\"aaaa\", \"asdasdasdasd\")==True", "assert wordPatternMatch(\"abba\", \"dogcatcatdog\") == True", "assert wordPatternMatch(\"ab\", \"aa\") == False # since 'a' and 'b' cannot map to the same string \"a\"", "assert wordPatternMatch(\"xyz\", \"abcdefghi\") == True # 'x' -> \"a\", 'y' -> \"bc\", 'z' -> \"defghi\"", "assert wordPatternMatch(\"aba\", \"eggegg\") == False # 'a' maps to \"egg\", but 'b' cannot be mapped uniquely", "assert wordPatternMatch(\"zzz\", \"aaa\") == True # all 'z' map to \"a\"", "assert wordPatternMatch(\"aba\", \"catdogcat\") == True # 'a' -> \"cat\", 'b' -> \"dog\"", "assert wordPatternMatch(\"abab\", \"xyzxyzabcabc\") == False # cannot match 'a' and 'b' with two different strings each consistent with the pattern", "assert wordPatternMatch(\"abac\", \"xyzxyzxya\") == True # 'a' -> \"xyz\", 'b' -> \"xyz\", 'c' -> \"a\"", "assert wordPatternMatch(\"abcd\", \"xyzy\") == False # pattern too long for the string", "assert wordPatternMatch(\"aaaaa\", \"oneonetwo\") == False # not enough unique strings to map 'a' five times"]}], "category": "Pattern", "prompt_tokens": 1013, "total_tokens": 1339, "completion_tokens": 326, "completion": "Repeat and Missing Number: You are given a list of n-1 integers and these integers are in the range of 1 to n. There are no duplicates in the list. One of the integers is missing and one of the integers is repeated. Find the missing and the repeated number.\n\n###Code: \n\ndef findRepeatAndMissing(nums):\n    n = len(nums)\n    expected_sum = n * (n + 1) // 2\n    actual_sum = sum(nums)\n    expected_square_sum = sum(x ** 2 for x in range(1, n + 1))\n    actual_square_sum = sum(x ** 2 for x in nums)\n    \n    diff = actual_sum - expected_sum\n    diff_square = actual_square_sum - expected_square_sum\n    \n    repeat = (diff + diff_square // diff) // 2\n    missing = (diff_square // diff - diff) // 2\n    \n    return repeat, missing\n\n###Testcases: \n\nassert findRepeatAndMissing([3, 1, 2, 5, 3]) == (3, 4)\nassert findRepeatAndMissing([1, 2, 3, 4, 5, 6, 8, 8]) == (8, 7)\nassert findRepeatAndMissing([1, 2, 2, 4, 5, 6]) == (2, 3)\nassert findRepeatAndMissing([3, 2, 3, 4, 6, 5]) == (3, 1)\n\n[/Example 3]", "temperature": 0.768}, {"few_shots": [{"author": "Hafeez", "UUID": "effcb732-1f0d-4caa-8d9f-be914708d4ae", "question": "Repeated Substring Pattern: Given a string s, check if it can be constructed by taking a substring of it and appending multiple copies of the substring together.", "examples": "Input: s = \"aba\"\nOutput: false\nExplanation: It is the substring \"ab\" twice.\nInput: s = \"abcabcabcabc\"\nOutput: true\nExplanation: It is the substring \"abc\" four times or the substring \"abcabc\" twice.", "link": "https://leetcode.com/problems/repeated-substring-pattern/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def repeatedSubstringPattern(s: str) -> bool:\n    n = len(s)\n    for i in range(1, n // 2 + 1):\n        if n % i == 0:\n            pattern = s[:i] * (n // i)\n            if s == pattern:\n                return True\n    return False", "asserts": ["assert repeatedSubstringPattern(\"abab\")==True", "assert repeatedSubstringPattern(\"aaaa\") == True", "assert repeatedSubstringPattern(\"abac\") == False", "assert repeatedSubstringPattern(\"ababab\") == True", "assert repeatedSubstringPattern(\"xyzxyzxyz\") == True", "assert repeatedSubstringPattern(\"aaabaaa\") == False", "assert repeatedSubstringPattern(\"abababab\") == True", "assert repeatedSubstringPattern(\"abcabcab\") == False", "assert repeatedSubstringPattern(\"abbaabba\") == True", "assert repeatedSubstringPattern(\"\") == False", "assert repeatedSubstringPattern(\"a\") == False", "assert repeatedSubstringPattern(\"abacababacab\") == True"]}, {"author": "Hafeez", "UUID": "124bfeca-24d0-411d-b4ad-26009b79436b", "question": "Word Pattern II: Given a pattern and a string s, return true if s matches the pattern.\n\nA string s matches a pattern if there is some bijective mapping of single characters to non-empty strings such that if each character in pattern is replaced by the string it maps to, then the resulting string is s. A bijective mapping means that no two characters map to the same string, and no character maps to two different strings.", "examples": "Input: pattern = \"abab\", s = \"redblueredblue\"\nOutput: true\nExplanation: One possible mapping is as follows:\n'a' -> \"red\"\n'b' -> \"blue\"\nInput: pattern = \"aabb\", s = \"xyzabcxzyabc\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern-ii/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def wordPatternMatch(pattern: str, s: str) -> bool:\n    def backtrack(cur: str, pattern: str, mappings: dict):\n        if not pattern:\n            return not cur\n        if pattern[0] in mappings:\n            if cur[:len(mappings[pattern[0]])] != mappings[pattern[0]]:\n                return False\n            return backtrack(cur[len(mappings[pattern[0]]):], pattern[1:], mappings)\n        for i in range(len(cur)):\n            if cur[:i+1] in mappings.values():\n                continue\n            mappings[pattern[0]] = cur[:i+1]\n            if backtrack(cur[i+1:], pattern[1:], mappings):\n                return True\n            del mappings[pattern[0]]\n        return False\n    return backtrack(s, pattern, {})", "asserts": ["assert wordPatternMatch(\"aaaa\", \"asdasdasdasd\")==True", "assert wordPatternMatch(\"abba\", \"dogcatcatdog\") == True", "assert wordPatternMatch(\"ab\", \"aa\") == False # since 'a' and 'b' cannot map to the same string \"a\"", "assert wordPatternMatch(\"xyz\", \"abcdefghi\") == True # 'x' -> \"a\", 'y' -> \"bc\", 'z' -> \"defghi\"", "assert wordPatternMatch(\"aba\", \"eggegg\") == False # 'a' maps to \"egg\", but 'b' cannot be mapped uniquely", "assert wordPatternMatch(\"zzz\", \"aaa\") == True # all 'z' map to \"a\"", "assert wordPatternMatch(\"aba\", \"catdogcat\") == True # 'a' -> \"cat\", 'b' -> \"dog\"", "assert wordPatternMatch(\"abab\", \"xyzxyzabcabc\") == False # cannot match 'a' and 'b' with two different strings each consistent with the pattern", "assert wordPatternMatch(\"abac\", \"xyzxyzxya\") == True # 'a' -> \"xyz\", 'b' -> \"xyz\", 'c' -> \"a\"", "assert wordPatternMatch(\"abcd\", \"xyzy\") == False # pattern too long for the string", "assert wordPatternMatch(\"aaaaa\", \"oneonetwo\") == False # not enough unique strings to map 'a' five times"]}], "category": "Pattern", "prompt_tokens": 1013, "total_tokens": 1297, "completion_tokens": 284, "completion": "ZigZag Conversion: The string \"PAYPALISHIRING\" is written in a zigzag pattern on a given number of rows like this:\n\nP   A   H   N\nA P L S I I G\nY   I   R\nAnd then read line by line: \"PAHNAPLSIIGYIR\"\n\nWrite the code to convert the string s into a zigzag pattern given the number of rows.\n\n###Code: \n\ndef convert(s: str, numRows: int) -> str:\n    if numRows == 1 or numRows >= len(s):\n        return s\n    result = ['' for _ in range(numRows)]\n    index, step = 0, 1\n    for char in s:\n        result[index] += char\n        if index == 0:\n            step = 1\n        elif index == numRows - 1:\n            step = -1\n        index += step\n    return ''.join(result)\n\n###Testcases: \n\nassert convert(\"PAYPALISHIRING\", 3)==\"PAHNAPLSIIGYIR\"\nassert convert(\"PAYPALISHIRING\", 4)==\"PINALSIGYAHRPI\"\nassert convert(\"AB\", 1)==\"AB\"\nassert convert(\"A\", 1)==\"A\"\nassert convert(\"ABCD\", 2)==\"ACBD\"\n\n[/Example 3]", "temperature": 0.605}, {"few_shots": [{"author": "Hafeez", "UUID": "effcb732-1f0d-4caa-8d9f-be914708d4ae", "question": "Repeated Substring Pattern: Given a string s, check if it can be constructed by taking a substring of it and appending multiple copies of the substring together.", "examples": "Input: s = \"aba\"\nOutput: false\nExplanation: It is the substring \"ab\" twice.\nInput: s = \"abcabcabcabc\"\nOutput: true\nExplanation: It is the substring \"abc\" four times or the substring \"abcabc\" twice.", "link": "https://leetcode.com/problems/repeated-substring-pattern/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def repeatedSubstringPattern(s: str) -> bool:\n    n = len(s)\n    for i in range(1, n // 2 + 1):\n        if n % i == 0:\n            pattern = s[:i] * (n // i)\n            if s == pattern:\n                return True\n    return False", "asserts": ["assert repeatedSubstringPattern(\"abab\")==True", "assert repeatedSubstringPattern(\"aaaa\") == True", "assert repeatedSubstringPattern(\"abac\") == False", "assert repeatedSubstringPattern(\"ababab\") == True", "assert repeatedSubstringPattern(\"xyzxyzxyz\") == True", "assert repeatedSubstringPattern(\"aaabaaa\") == False", "assert repeatedSubstringPattern(\"abababab\") == True", "assert repeatedSubstringPattern(\"abcabcab\") == False", "assert repeatedSubstringPattern(\"abbaabba\") == True", "assert repeatedSubstringPattern(\"\") == False", "assert repeatedSubstringPattern(\"a\") == False", "assert repeatedSubstringPattern(\"abacababacab\") == True"]}, {"author": "Hafeez", "UUID": "124bfeca-24d0-411d-b4ad-26009b79436b", "question": "Word Pattern II: Given a pattern and a string s, return true if s matches the pattern.\n\nA string s matches a pattern if there is some bijective mapping of single characters to non-empty strings such that if each character in pattern is replaced by the string it maps to, then the resulting string is s. A bijective mapping means that no two characters map to the same string, and no character maps to two different strings.", "examples": "Input: pattern = \"abab\", s = \"redblueredblue\"\nOutput: true\nExplanation: One possible mapping is as follows:\n'a' -> \"red\"\n'b' -> \"blue\"\nInput: pattern = \"aabb\", s = \"xyzabcxzyabc\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern-ii/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def wordPatternMatch(pattern: str, s: str) -> bool:\n    def backtrack(cur: str, pattern: str, mappings: dict):\n        if not pattern:\n            return not cur\n        if pattern[0] in mappings:\n            if cur[:len(mappings[pattern[0]])] != mappings[pattern[0]]:\n                return False\n            return backtrack(cur[len(mappings[pattern[0]]):], pattern[1:], mappings)\n        for i in range(len(cur)):\n            if cur[:i+1] in mappings.values():\n                continue\n            mappings[pattern[0]] = cur[:i+1]\n            if backtrack(cur[i+1:], pattern[1:], mappings):\n                return True\n            del mappings[pattern[0]]\n        return False\n    return backtrack(s, pattern, {})", "asserts": ["assert wordPatternMatch(\"aaaa\", \"asdasdasdasd\")==True", "assert wordPatternMatch(\"abba\", \"dogcatcatdog\") == True", "assert wordPatternMatch(\"ab\", \"aa\") == False # since 'a' and 'b' cannot map to the same string \"a\"", "assert wordPatternMatch(\"xyz\", \"abcdefghi\") == True # 'x' -> \"a\", 'y' -> \"bc\", 'z' -> \"defghi\"", "assert wordPatternMatch(\"aba\", \"eggegg\") == False # 'a' maps to \"egg\", but 'b' cannot be mapped uniquely", "assert wordPatternMatch(\"zzz\", \"aaa\") == True # all 'z' map to \"a\"", "assert wordPatternMatch(\"aba\", \"catdogcat\") == True # 'a' -> \"cat\", 'b' -> \"dog\"", "assert wordPatternMatch(\"abab\", \"xyzxyzabcabc\") == False # cannot match 'a' and 'b' with two different strings each consistent with the pattern", "assert wordPatternMatch(\"abac\", \"xyzxyzxya\") == True # 'a' -> \"xyz\", 'b' -> \"xyz\", 'c' -> \"a\"", "assert wordPatternMatch(\"abcd\", \"xyzy\") == False # pattern too long for the string", "assert wordPatternMatch(\"aaaaa\", \"oneonetwo\") == False # not enough unique strings to map 'a' five times"]}], "category": "Pattern", "prompt_tokens": 1013, "total_tokens": 1455, "completion_tokens": 442, "completion": "Find All Anagrams in a String: Given a string s and a non-empty string p, find all the start indices of p's anagrams in s.\n\nStrings consists of lowercase English letters only.\n\n###Code: \n\n```python\nfrom collections import Counter\n\ndef findAnagrams(s: str, p: str) -> List[int]:\n    p_count = Counter(p)\n    s_count = Counter(s[:len(p)-1])\n    res = []\n    for i in range(len(p)-1, len(s)):\n        s_count[s[i]] += 1\n        if s_count == p_count:\n            res.append(i-len(p)+1)\n        s_count[s[i-len(p)+1]] -= 1\n        if s_count[s[i-len(p)+1]] == 0:\n            del s_count[s[i-len(p)+1]]\n    return res\n```\n\n###Testcases: \n\n```python\nassert findAnagrams(\"cbaebabacd\", \"abc\") == [0, 6]\nassert findAnagrams(\"abab\", \"ab\") == [0, 1, 2]\nassert findAnagrams(\"acdbacdacb\", \"abc\") == [3, 7]\nassert findAnagrams(\"aaaaaaaaaa\", \"a\") == [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nassert findAnagrams(\"xyzxyzxyz\", \"xyz\") == [0, 3, 6]\nassert findAnagrams(\"ababababab\", \"ab\") == [0, 1, 2, 3, 4, 5, 6, 7, 8]\nassert findAnagrams(\"abcabcab\", \"abc\") == [0, 3]\nassert findAnagrams(\"abbaabba\", \"ab\") == [0, 4]\nassert findAnagrams(\"\", \"a\") == []\nassert findAnagrams(\"a\", \"a\") == [0]\nassert findAnagrams(\"abacababacab\", \"ab\") == [0, 4, 8]\n```", "temperature": 0.695}, {"few_shots": [{"author": "Hafeez", "UUID": "e811f9cc-fa5e-4ea0-8adb-8cf3ab7c72db", "question": "Detect Pattern of Length M Repeated K or More Times: Given an array of positive integers arr, find a pattern of length m that is repeated k or more times.\n\nA pattern is a subarray (consecutive sub-sequence) that consists of one or more values, repeated multiple times consecutively without overlapping. A pattern is defined by its length and the number of repetitions.\n\nReturn true if there exists a pattern of length m that is repeated k or more times, otherwise return false.", "examples": "Input: arr = [1,2,1,2,1,1,1,3], m = 2, k = 2\nOutput: true\nExplanation: The pattern (1,2) of length 2 is repeated 2 consecutive times. Another valid pattern (2,1) is also repeated 2 times.\nInput: arr = [1,2,1,2,1,3], m = 2, k = 3\nOutput: false\nExplanation: The pattern (1,2) is of length 2 but is repeated only 2 times. There is no pattern of length 2 that is repeated 3 or more times.\n", "link": "https://leetcode.com/problems/detect-pattern-of-length-m-repeated-k-or-more-times/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "from typing import List\ndef containsPattern(arr: List[int], m: int, k: int) -> bool:\n    i = 0\n    while i <= len(arr)-1:\n            p = arr[i:i+m]\n            if p * k == arr[i:i+m*k]:\n                    return True\n            i += 1\n    return False", "asserts": ["assert containsPattern([1,2,4,4,4,4],1,3)==True", "assert containsPattern([1,2,3,1,2,3,1,2,3], 3, 3) == True", "assert containsPattern([1,1,1,2,2,2,3,3], 2, 2) == False", "assert containsPattern([5,5,5,5,5,5,5], 1, 6) == True", "assert containsPattern([1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2], 2, 5) == True", "assert containsPattern([10,100,10,100,10,100,10,10,10,100], 2, 4) == False", "assert containsPattern([3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3], 4, 3) == True"]}, {"author": "Hafeez", "UUID": "effcb732-1f0d-4caa-8d9f-be914708d4ae", "question": "Repeated Substring Pattern: Given a string s, check if it can be constructed by taking a substring of it and appending multiple copies of the substring together.", "examples": "Input: s = \"aba\"\nOutput: false\nExplanation: It is the substring \"ab\" twice.\nInput: s = \"abcabcabcabc\"\nOutput: true\nExplanation: It is the substring \"abc\" four times or the substring \"abcabc\" twice.", "link": "https://leetcode.com/problems/repeated-substring-pattern/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def repeatedSubstringPattern(s: str) -> bool:\n    n = len(s)\n    for i in range(1, n // 2 + 1):\n        if n % i == 0:\n            pattern = s[:i] * (n // i)\n            if s == pattern:\n                return True\n    return False", "asserts": ["assert repeatedSubstringPattern(\"abab\")==True", "assert repeatedSubstringPattern(\"aaaa\") == True", "assert repeatedSubstringPattern(\"abac\") == False", "assert repeatedSubstringPattern(\"ababab\") == True", "assert repeatedSubstringPattern(\"xyzxyzxyz\") == True", "assert repeatedSubstringPattern(\"aaabaaa\") == False", "assert repeatedSubstringPattern(\"abababab\") == True", "assert repeatedSubstringPattern(\"abcabcab\") == False", "assert repeatedSubstringPattern(\"abbaabba\") == True", "assert repeatedSubstringPattern(\"\") == False", "assert repeatedSubstringPattern(\"a\") == False", "assert repeatedSubstringPattern(\"abacababacab\") == True"]}], "category": "Pattern", "prompt_tokens": 855, "total_tokens": 1215, "completion_tokens": 360, "completion": "Find All Anagrams in a String: Given a string s and a non-empty string p, find all the start indices of p's anagrams in s.\n\nStrings consists of lowercase English letters only.\n\n###Code: \n\nfrom typing import List\nfrom collections import Counter\n\ndef findAnagrams(s: str, p: str) -> List[int]:\n    res = []\n    pCounter = Counter(p)\n    sCounter = Counter(s[:len(p)-1])\n    for i in range(len(p)-1,len(s)):\n        sCounter[s[i]] += 1   # include a new char in the window\n        if sCounter == pCounter:    # This step is O(1), since there are at most 26 English letters \n            res.append(i-len(p)+1)   # append the starting index\n        sCounter[s[i-len(p)+1]] -= 1   # decrease the count of oldest char in the window\n        if sCounter[s[i-len(p)+1]] == 0:\n            del sCounter[s[i-len(p)+1]]   # remove the count if it is 0\n    return res\n\n###Testcases: \n\nassert findAnagrams(\"cbaebabacd\", \"abc\") == [0, 6]\nassert findAnagrams(\"abab\", \"ab\") == [0, 1, 2]\nassert findAnagrams(\"acdcaeccde\", \"c\") == [0, 3, 7]\nassert findAnagrams(\"aaaaa\", \"a\") == [0, 1, 2, 3, 4]\nassert findAnagrams(\"abababab\", \"ab\") == [0, 2, 4, 6]\n\n[/Example 3]", "temperature": 0.788}, {"few_shots": [{"author": "Hafeez", "UUID": "e811f9cc-fa5e-4ea0-8adb-8cf3ab7c72db", "question": "Detect Pattern of Length M Repeated K or More Times: Given an array of positive integers arr, find a pattern of length m that is repeated k or more times.\n\nA pattern is a subarray (consecutive sub-sequence) that consists of one or more values, repeated multiple times consecutively without overlapping. A pattern is defined by its length and the number of repetitions.\n\nReturn true if there exists a pattern of length m that is repeated k or more times, otherwise return false.", "examples": "Input: arr = [1,2,1,2,1,1,1,3], m = 2, k = 2\nOutput: true\nExplanation: The pattern (1,2) of length 2 is repeated 2 consecutive times. Another valid pattern (2,1) is also repeated 2 times.\nInput: arr = [1,2,1,2,1,3], m = 2, k = 3\nOutput: false\nExplanation: The pattern (1,2) is of length 2 but is repeated only 2 times. There is no pattern of length 2 that is repeated 3 or more times.\n", "link": "https://leetcode.com/problems/detect-pattern-of-length-m-repeated-k-or-more-times/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "from typing import List\ndef containsPattern(arr: List[int], m: int, k: int) -> bool:\n    i = 0\n    while i <= len(arr)-1:\n            p = arr[i:i+m]\n            if p * k == arr[i:i+m*k]:\n                    return True\n            i += 1\n    return False", "asserts": ["assert containsPattern([1,2,4,4,4,4],1,3)==True", "assert containsPattern([1,2,3,1,2,3,1,2,3], 3, 3) == True", "assert containsPattern([1,1,1,2,2,2,3,3], 2, 2) == False", "assert containsPattern([5,5,5,5,5,5,5], 1, 6) == True", "assert containsPattern([1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2], 2, 5) == True", "assert containsPattern([10,100,10,100,10,100,10,10,10,100], 2, 4) == False", "assert containsPattern([3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3], 4, 3) == True"]}, {"author": "Hafeez", "UUID": "effcb732-1f0d-4caa-8d9f-be914708d4ae", "question": "Repeated Substring Pattern: Given a string s, check if it can be constructed by taking a substring of it and appending multiple copies of the substring together.", "examples": "Input: s = \"aba\"\nOutput: false\nExplanation: It is the substring \"ab\" twice.\nInput: s = \"abcabcabcabc\"\nOutput: true\nExplanation: It is the substring \"abc\" four times or the substring \"abcabc\" twice.", "link": "https://leetcode.com/problems/repeated-substring-pattern/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def repeatedSubstringPattern(s: str) -> bool:\n    n = len(s)\n    for i in range(1, n // 2 + 1):\n        if n % i == 0:\n            pattern = s[:i] * (n // i)\n            if s == pattern:\n                return True\n    return False", "asserts": ["assert repeatedSubstringPattern(\"abab\")==True", "assert repeatedSubstringPattern(\"aaaa\") == True", "assert repeatedSubstringPattern(\"abac\") == False", "assert repeatedSubstringPattern(\"ababab\") == True", "assert repeatedSubstringPattern(\"xyzxyzxyz\") == True", "assert repeatedSubstringPattern(\"aaabaaa\") == False", "assert repeatedSubstringPattern(\"abababab\") == True", "assert repeatedSubstringPattern(\"abcabcab\") == False", "assert repeatedSubstringPattern(\"abbaabba\") == True", "assert repeatedSubstringPattern(\"\") == False", "assert repeatedSubstringPattern(\"a\") == False", "assert repeatedSubstringPattern(\"abacababacab\") == True"]}], "category": "Pattern", "prompt_tokens": 855, "total_tokens": 1112, "completion_tokens": 257, "completion": "Detect Capital Use: Given a word, you need to judge whether the usage of capitals in it is right or not.\n\nWe define the usage of capitals in a word to be right when one of the following cases holds:\n- All letters in this word are capitals, like \"USA\".\n- All letters in this word are not capitals, like \"leetcode\".\n- Only the first letter in this word is capital, like \"Google\".\n\nReturn true if the usage of capitals in the word is right, otherwise return false.\n\n###Code: \n\ndef detectCapitalUse(word: str) -> bool:\n    return word.isupper() or word.islower() or word.istitle()\n\n###Testcases: \n\nassert detectCapitalUse(\"USA\")==True\nassert detectCapitalUse(\"leetcode\") == True\nassert detectCapitalUse(\"Google\") == True\nassert detectCapitalUse(\"FlaG\") == False\nassert detectCapitalUse(\"APPLY\") == True\nassert detectCapitalUse(\"apPLY\") == False\nassert detectCapitalUse(\"\") == False\nassert detectCapitalUse(\"a\") == True\nassert detectCapitalUse(\"AB\") == True\nassert detectCapitalUse(\"Ab\") == True\nassert detectCapitalUse(\"aB\") == False\n\n[/Example 3]", "temperature": 0.927}, {"few_shots": [{"author": "Hafeez", "UUID": "e811f9cc-fa5e-4ea0-8adb-8cf3ab7c72db", "question": "Detect Pattern of Length M Repeated K or More Times: Given an array of positive integers arr, find a pattern of length m that is repeated k or more times.\n\nA pattern is a subarray (consecutive sub-sequence) that consists of one or more values, repeated multiple times consecutively without overlapping. A pattern is defined by its length and the number of repetitions.\n\nReturn true if there exists a pattern of length m that is repeated k or more times, otherwise return false.", "examples": "Input: arr = [1,2,1,2,1,1,1,3], m = 2, k = 2\nOutput: true\nExplanation: The pattern (1,2) of length 2 is repeated 2 consecutive times. Another valid pattern (2,1) is also repeated 2 times.\nInput: arr = [1,2,1,2,1,3], m = 2, k = 3\nOutput: false\nExplanation: The pattern (1,2) is of length 2 but is repeated only 2 times. There is no pattern of length 2 that is repeated 3 or more times.\n", "link": "https://leetcode.com/problems/detect-pattern-of-length-m-repeated-k-or-more-times/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "from typing import List\ndef containsPattern(arr: List[int], m: int, k: int) -> bool:\n    i = 0\n    while i <= len(arr)-1:\n            p = arr[i:i+m]\n            if p * k == arr[i:i+m*k]:\n                    return True\n            i += 1\n    return False", "asserts": ["assert containsPattern([1,2,4,4,4,4],1,3)==True", "assert containsPattern([1,2,3,1,2,3,1,2,3], 3, 3) == True", "assert containsPattern([1,1,1,2,2,2,3,3], 2, 2) == False", "assert containsPattern([5,5,5,5,5,5,5], 1, 6) == True", "assert containsPattern([1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2], 2, 5) == True", "assert containsPattern([10,100,10,100,10,100,10,10,10,100], 2, 4) == False", "assert containsPattern([3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3], 4, 3) == True"]}, {"author": "Hafeez", "UUID": "effcb732-1f0d-4caa-8d9f-be914708d4ae", "question": "Repeated Substring Pattern: Given a string s, check if it can be constructed by taking a substring of it and appending multiple copies of the substring together.", "examples": "Input: s = \"aba\"\nOutput: false\nExplanation: It is the substring \"ab\" twice.\nInput: s = \"abcabcabcabc\"\nOutput: true\nExplanation: It is the substring \"abc\" four times or the substring \"abcabc\" twice.", "link": "https://leetcode.com/problems/repeated-substring-pattern/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def repeatedSubstringPattern(s: str) -> bool:\n    n = len(s)\n    for i in range(1, n // 2 + 1):\n        if n % i == 0:\n            pattern = s[:i] * (n // i)\n            if s == pattern:\n                return True\n    return False", "asserts": ["assert repeatedSubstringPattern(\"abab\")==True", "assert repeatedSubstringPattern(\"aaaa\") == True", "assert repeatedSubstringPattern(\"abac\") == False", "assert repeatedSubstringPattern(\"ababab\") == True", "assert repeatedSubstringPattern(\"xyzxyzxyz\") == True", "assert repeatedSubstringPattern(\"aaabaaa\") == False", "assert repeatedSubstringPattern(\"abababab\") == True", "assert repeatedSubstringPattern(\"abcabcab\") == False", "assert repeatedSubstringPattern(\"abbaabba\") == True", "assert repeatedSubstringPattern(\"\") == False", "assert repeatedSubstringPattern(\"a\") == False", "assert repeatedSubstringPattern(\"abacababacab\") == True"]}], "category": "Pattern", "prompt_tokens": 855, "total_tokens": 1136, "completion_tokens": 281, "completion": "Find All Anagrams in a String: Given a string s and a non-empty string p, find all the start indices of p's anagrams in s.\n\nStrings consists only of lowercase English letters.\n\n###Code: \n\nfrom typing import List\ndef findAnagrams(s: str, p: str) -> List[int]:\n    result = []\n    p_count = [0] * 26\n    for char in p:\n        p_count[ord(char) - ord('a')] += 1\n    s_count = [0] * 26\n    for i in range(len(s)):\n        s_count[ord(s[i]) - ord('a')] += 1\n        if i >= len(p):\n            s_count[ord(s[i - len(p)]) - ord('a')] -= 1\n        if s_count == p_count:\n            result.append(i - len(p) + 1)\n    return result\n\n###Testcases: \n\nassert findAnagrams(\"cbaebabacd\", \"abc\") == [0, 6]\nassert findAnagrams(\"abab\", \"ab\") == [0, 1, 2]\nassert findAnagrams(\"baa\", \"aa\") == [1]\nassert findAnagrams(\"acdcaeccde\", \"c\") == [3, 4, 5, 6]\n\n[/Example 3]", "temperature": 0.883}, {"few_shots": [{"author": "Hafeez", "UUID": "e811f9cc-fa5e-4ea0-8adb-8cf3ab7c72db", "question": "Detect Pattern of Length M Repeated K or More Times: Given an array of positive integers arr, find a pattern of length m that is repeated k or more times.\n\nA pattern is a subarray (consecutive sub-sequence) that consists of one or more values, repeated multiple times consecutively without overlapping. A pattern is defined by its length and the number of repetitions.\n\nReturn true if there exists a pattern of length m that is repeated k or more times, otherwise return false.", "examples": "Input: arr = [1,2,1,2,1,1,1,3], m = 2, k = 2\nOutput: true\nExplanation: The pattern (1,2) of length 2 is repeated 2 consecutive times. Another valid pattern (2,1) is also repeated 2 times.\nInput: arr = [1,2,1,2,1,3], m = 2, k = 3\nOutput: false\nExplanation: The pattern (1,2) is of length 2 but is repeated only 2 times. There is no pattern of length 2 that is repeated 3 or more times.\n", "link": "https://leetcode.com/problems/detect-pattern-of-length-m-repeated-k-or-more-times/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "from typing import List\ndef containsPattern(arr: List[int], m: int, k: int) -> bool:\n    i = 0\n    while i <= len(arr)-1:\n            p = arr[i:i+m]\n            if p * k == arr[i:i+m*k]:\n                    return True\n            i += 1\n    return False", "asserts": ["assert containsPattern([1,2,4,4,4,4],1,3)==True", "assert containsPattern([1,2,3,1,2,3,1,2,3], 3, 3) == True", "assert containsPattern([1,1,1,2,2,2,3,3], 2, 2) == False", "assert containsPattern([5,5,5,5,5,5,5], 1, 6) == True", "assert containsPattern([1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2], 2, 5) == True", "assert containsPattern([10,100,10,100,10,100,10,10,10,100], 2, 4) == False", "assert containsPattern([3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3], 4, 3) == True"]}, {"author": "Hafeez", "UUID": "effcb732-1f0d-4caa-8d9f-be914708d4ae", "question": "Repeated Substring Pattern: Given a string s, check if it can be constructed by taking a substring of it and appending multiple copies of the substring together.", "examples": "Input: s = \"aba\"\nOutput: false\nExplanation: It is the substring \"ab\" twice.\nInput: s = \"abcabcabcabc\"\nOutput: true\nExplanation: It is the substring \"abc\" four times or the substring \"abcabc\" twice.", "link": "https://leetcode.com/problems/repeated-substring-pattern/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def repeatedSubstringPattern(s: str) -> bool:\n    n = len(s)\n    for i in range(1, n // 2 + 1):\n        if n % i == 0:\n            pattern = s[:i] * (n // i)\n            if s == pattern:\n                return True\n    return False", "asserts": ["assert repeatedSubstringPattern(\"abab\")==True", "assert repeatedSubstringPattern(\"aaaa\") == True", "assert repeatedSubstringPattern(\"abac\") == False", "assert repeatedSubstringPattern(\"ababab\") == True", "assert repeatedSubstringPattern(\"xyzxyzxyz\") == True", "assert repeatedSubstringPattern(\"aaabaaa\") == False", "assert repeatedSubstringPattern(\"abababab\") == True", "assert repeatedSubstringPattern(\"abcabcab\") == False", "assert repeatedSubstringPattern(\"abbaabba\") == True", "assert repeatedSubstringPattern(\"\") == False", "assert repeatedSubstringPattern(\"a\") == False", "assert repeatedSubstringPattern(\"abacababacab\") == True"]}], "category": "Pattern", "prompt_tokens": 855, "total_tokens": 1182, "completion_tokens": 327, "completion": "Find All Anagrams in a String: Given a string s and a non-empty string p, find all the start indices of p's anagrams in s.\n\nStrings consists of lowercase English letters only.\n\n###Code: \n\nfrom typing import List\ndef findAnagrams(s: str, p: str) -> List[int]:\n    res = []\n    p_count = [0] * 26\n    for char in p:\n        p_count[ord(char) - ord('a')] += 1\n    s_count = [0] * 26\n    for i in range(len(s)):\n        s_count[ord(s[i]) - ord('a')] += 1\n        if i >= len(p):\n            s_count[ord(s[i - len(p)]) - ord('a')] -= 1\n        if s_count == p_count:\n            res.append(i - len(p) + 1)\n    return res\n\n###Testcases: \n\nassert findAnagrams(\"cbaebabacd\", \"abc\") == [0, 6]\nassert findAnagrams(\"abab\", \"ab\") == [0, 1, 2]\nassert findAnagrams(\"baa\", \"aa\") == [1]\nassert findAnagrams(\"baab\", \"aba\") == [1]\nassert findAnagrams(\"acdcaeccde\", \"c\") == [2, 3, 4, 5, 6, 7]\nassert findAnagrams(\"abacbabc\", \"abc\") == [1, 2, 3, 5]\n\n[/Example 3]", "temperature": 0.697}, {"few_shots": [{"author": "Hafeez", "UUID": "e811f9cc-fa5e-4ea0-8adb-8cf3ab7c72db", "question": "Detect Pattern of Length M Repeated K or More Times: Given an array of positive integers arr, find a pattern of length m that is repeated k or more times.\n\nA pattern is a subarray (consecutive sub-sequence) that consists of one or more values, repeated multiple times consecutively without overlapping. A pattern is defined by its length and the number of repetitions.\n\nReturn true if there exists a pattern of length m that is repeated k or more times, otherwise return false.", "examples": "Input: arr = [1,2,1,2,1,1,1,3], m = 2, k = 2\nOutput: true\nExplanation: The pattern (1,2) of length 2 is repeated 2 consecutive times. Another valid pattern (2,1) is also repeated 2 times.\nInput: arr = [1,2,1,2,1,3], m = 2, k = 3\nOutput: false\nExplanation: The pattern (1,2) is of length 2 but is repeated only 2 times. There is no pattern of length 2 that is repeated 3 or more times.\n", "link": "https://leetcode.com/problems/detect-pattern-of-length-m-repeated-k-or-more-times/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "from typing import List\ndef containsPattern(arr: List[int], m: int, k: int) -> bool:\n    i = 0\n    while i <= len(arr)-1:\n            p = arr[i:i+m]\n            if p * k == arr[i:i+m*k]:\n                    return True\n            i += 1\n    return False", "asserts": ["assert containsPattern([1,2,4,4,4,4],1,3)==True", "assert containsPattern([1,2,3,1,2,3,1,2,3], 3, 3) == True", "assert containsPattern([1,1,1,2,2,2,3,3], 2, 2) == False", "assert containsPattern([5,5,5,5,5,5,5], 1, 6) == True", "assert containsPattern([1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2], 2, 5) == True", "assert containsPattern([10,100,10,100,10,100,10,10,10,100], 2, 4) == False", "assert containsPattern([3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3], 4, 3) == True"]}, {"author": "Hafeez", "UUID": "effcb732-1f0d-4caa-8d9f-be914708d4ae", "question": "Repeated Substring Pattern: Given a string s, check if it can be constructed by taking a substring of it and appending multiple copies of the substring together.", "examples": "Input: s = \"aba\"\nOutput: false\nExplanation: It is the substring \"ab\" twice.\nInput: s = \"abcabcabcabc\"\nOutput: true\nExplanation: It is the substring \"abc\" four times or the substring \"abcabc\" twice.", "link": "https://leetcode.com/problems/repeated-substring-pattern/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def repeatedSubstringPattern(s: str) -> bool:\n    n = len(s)\n    for i in range(1, n // 2 + 1):\n        if n % i == 0:\n            pattern = s[:i] * (n // i)\n            if s == pattern:\n                return True\n    return False", "asserts": ["assert repeatedSubstringPattern(\"abab\")==True", "assert repeatedSubstringPattern(\"aaaa\") == True", "assert repeatedSubstringPattern(\"abac\") == False", "assert repeatedSubstringPattern(\"ababab\") == True", "assert repeatedSubstringPattern(\"xyzxyzxyz\") == True", "assert repeatedSubstringPattern(\"aaabaaa\") == False", "assert repeatedSubstringPattern(\"abababab\") == True", "assert repeatedSubstringPattern(\"abcabcab\") == False", "assert repeatedSubstringPattern(\"abbaabba\") == True", "assert repeatedSubstringPattern(\"\") == False", "assert repeatedSubstringPattern(\"a\") == False", "assert repeatedSubstringPattern(\"abacababacab\") == True"]}], "category": "Pattern", "prompt_tokens": 855, "total_tokens": 1200, "completion_tokens": 345, "completion": "Find All Anagrams in a String: Given a string s and a non-empty string p, find all the start indices of p's anagrams in s.\n\nStrings consists of lowercase English letters only.\n\n###Code: \n\nfrom collections import Counter\ndef findAnagrams(s: str, p: str) -> List[int]:\n    res = []\n    p_count = Counter(p)\n    s_count = Counter(s[:len(p)-1])\n    for i in range(len(p)-1, len(s)):\n        s_count[s[i]] += 1\n        if s_count == p_count:\n            res.append(i-len(p)+1)\n        s_count[s[i-len(p)+1]] -= 1\n        if s_count[s[i-len(p)+1]] == 0:\n            del s_count[s[i-len(p)+1]]\n    return res\n\n###Testcases: \n\nassert findAnagrams(\"cbaebabacd\", \"abc\") == [0, 6]\nassert findAnagrams(\"abab\", \"ab\") == [0, 1, 2]\nassert findAnagrams(\"acdbacdacb\", \"abc\") == [3, 7]\nassert findAnagrams(\"af\", \"be\") == []\nassert findAnagrams(\"ababababab\", \"aab\") == [0, 2, 4, 6]\nassert findAnagrams(\"aa\", \"bb\") == []\nassert findAnagrams(\"aabbcc\", \"abc\") == [0, 1, 2]\nassert findAnagrams(\"abccbaabccba\", \"abc\") == [0, 6, 7, 8]\n\n[/Example 3]", "temperature": 0.699}, {"few_shots": [{"author": "Hafeez", "UUID": "e811f9cc-fa5e-4ea0-8adb-8cf3ab7c72db", "question": "Detect Pattern of Length M Repeated K or More Times: Given an array of positive integers arr, find a pattern of length m that is repeated k or more times.\n\nA pattern is a subarray (consecutive sub-sequence) that consists of one or more values, repeated multiple times consecutively without overlapping. A pattern is defined by its length and the number of repetitions.\n\nReturn true if there exists a pattern of length m that is repeated k or more times, otherwise return false.", "examples": "Input: arr = [1,2,1,2,1,1,1,3], m = 2, k = 2\nOutput: true\nExplanation: The pattern (1,2) of length 2 is repeated 2 consecutive times. Another valid pattern (2,1) is also repeated 2 times.\nInput: arr = [1,2,1,2,1,3], m = 2, k = 3\nOutput: false\nExplanation: The pattern (1,2) is of length 2 but is repeated only 2 times. There is no pattern of length 2 that is repeated 3 or more times.\n", "link": "https://leetcode.com/problems/detect-pattern-of-length-m-repeated-k-or-more-times/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "from typing import List\ndef containsPattern(arr: List[int], m: int, k: int) -> bool:\n    i = 0\n    while i <= len(arr)-1:\n            p = arr[i:i+m]\n            if p * k == arr[i:i+m*k]:\n                    return True\n            i += 1\n    return False", "asserts": ["assert containsPattern([1,2,4,4,4,4],1,3)==True", "assert containsPattern([1,2,3,1,2,3,1,2,3], 3, 3) == True", "assert containsPattern([1,1,1,2,2,2,3,3], 2, 2) == False", "assert containsPattern([5,5,5,5,5,5,5], 1, 6) == True", "assert containsPattern([1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2], 2, 5) == True", "assert containsPattern([10,100,10,100,10,100,10,10,10,100], 2, 4) == False", "assert containsPattern([3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3], 4, 3) == True"]}, {"author": "Hafeez", "UUID": "effcb732-1f0d-4caa-8d9f-be914708d4ae", "question": "Repeated Substring Pattern: Given a string s, check if it can be constructed by taking a substring of it and appending multiple copies of the substring together.", "examples": "Input: s = \"aba\"\nOutput: false\nExplanation: It is the substring \"ab\" twice.\nInput: s = \"abcabcabcabc\"\nOutput: true\nExplanation: It is the substring \"abc\" four times or the substring \"abcabc\" twice.", "link": "https://leetcode.com/problems/repeated-substring-pattern/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def repeatedSubstringPattern(s: str) -> bool:\n    n = len(s)\n    for i in range(1, n // 2 + 1):\n        if n % i == 0:\n            pattern = s[:i] * (n // i)\n            if s == pattern:\n                return True\n    return False", "asserts": ["assert repeatedSubstringPattern(\"abab\")==True", "assert repeatedSubstringPattern(\"aaaa\") == True", "assert repeatedSubstringPattern(\"abac\") == False", "assert repeatedSubstringPattern(\"ababab\") == True", "assert repeatedSubstringPattern(\"xyzxyzxyz\") == True", "assert repeatedSubstringPattern(\"aaabaaa\") == False", "assert repeatedSubstringPattern(\"abababab\") == True", "assert repeatedSubstringPattern(\"abcabcab\") == False", "assert repeatedSubstringPattern(\"abbaabba\") == True", "assert repeatedSubstringPattern(\"\") == False", "assert repeatedSubstringPattern(\"a\") == False", "assert repeatedSubstringPattern(\"abacababacab\") == True"]}], "category": "Pattern", "prompt_tokens": 855, "total_tokens": 1149, "completion_tokens": 294, "completion": "Find All Anagrams in a String: Given a string s and a non-empty string p, find all the start indices of p's anagrams in s.\n\nStrings consists of lowercase English letters only.\n\n###Code: \n\nfrom typing import List\nfrom collections import Counter\n\ndef findAnagrams(s: str, p: str) -> List[int]:\n    result = []\n    p_count = Counter(p)\n    s_count = Counter(s[:len(p)-1])\n    for i in range(len(p)-1, len(s)):\n        s_count[s[i]] += 1\n        if s_count == p_count:\n            result.append(i-len(p)+1)\n        s_count[s[i-len(p)+1]] -= 1\n        if s_count[s[i-len(p)+1]] == 0:\n            del s_count[s[i-len(p)+1]]\n    return result\n\n###Testcases: \n\nassert findAnagrams(\"cbaebabacd\", \"abc\") == [0, 6]\nassert findAnagrams(\"abab\", \"ab\") == [0, 1, 2]\nassert findAnagrams(\"af\", \"be\") == []\nassert findAnagrams(\"aaaaa\", \"a\") == [0, 1, 2, 3, 4]\nassert findAnagrams(\"ababababab\", \"aab\") == [0, 2, 4, 6]\n\n[/Example 3]", "temperature": 0.823}, {"few_shots": [{"author": "Hafeez", "UUID": "e811f9cc-fa5e-4ea0-8adb-8cf3ab7c72db", "question": "Detect Pattern of Length M Repeated K or More Times: Given an array of positive integers arr, find a pattern of length m that is repeated k or more times.\n\nA pattern is a subarray (consecutive sub-sequence) that consists of one or more values, repeated multiple times consecutively without overlapping. A pattern is defined by its length and the number of repetitions.\n\nReturn true if there exists a pattern of length m that is repeated k or more times, otherwise return false.", "examples": "Input: arr = [1,2,1,2,1,1,1,3], m = 2, k = 2\nOutput: true\nExplanation: The pattern (1,2) of length 2 is repeated 2 consecutive times. Another valid pattern (2,1) is also repeated 2 times.\nInput: arr = [1,2,1,2,1,3], m = 2, k = 3\nOutput: false\nExplanation: The pattern (1,2) is of length 2 but is repeated only 2 times. There is no pattern of length 2 that is repeated 3 or more times.\n", "link": "https://leetcode.com/problems/detect-pattern-of-length-m-repeated-k-or-more-times/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "from typing import List\ndef containsPattern(arr: List[int], m: int, k: int) -> bool:\n    i = 0\n    while i <= len(arr)-1:\n            p = arr[i:i+m]\n            if p * k == arr[i:i+m*k]:\n                    return True\n            i += 1\n    return False", "asserts": ["assert containsPattern([1,2,4,4,4,4],1,3)==True", "assert containsPattern([1,2,3,1,2,3,1,2,3], 3, 3) == True", "assert containsPattern([1,1,1,2,2,2,3,3], 2, 2) == False", "assert containsPattern([5,5,5,5,5,5,5], 1, 6) == True", "assert containsPattern([1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2], 2, 5) == True", "assert containsPattern([10,100,10,100,10,100,10,10,10,100], 2, 4) == False", "assert containsPattern([3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3], 4, 3) == True"]}, {"author": "Hafeez", "UUID": "effcb732-1f0d-4caa-8d9f-be914708d4ae", "question": "Repeated Substring Pattern: Given a string s, check if it can be constructed by taking a substring of it and appending multiple copies of the substring together.", "examples": "Input: s = \"aba\"\nOutput: false\nExplanation: It is the substring \"ab\" twice.\nInput: s = \"abcabcabcabc\"\nOutput: true\nExplanation: It is the substring \"abc\" four times or the substring \"abcabc\" twice.", "link": "https://leetcode.com/problems/repeated-substring-pattern/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def repeatedSubstringPattern(s: str) -> bool:\n    n = len(s)\n    for i in range(1, n // 2 + 1):\n        if n % i == 0:\n            pattern = s[:i] * (n // i)\n            if s == pattern:\n                return True\n    return False", "asserts": ["assert repeatedSubstringPattern(\"abab\")==True", "assert repeatedSubstringPattern(\"aaaa\") == True", "assert repeatedSubstringPattern(\"abac\") == False", "assert repeatedSubstringPattern(\"ababab\") == True", "assert repeatedSubstringPattern(\"xyzxyzxyz\") == True", "assert repeatedSubstringPattern(\"aaabaaa\") == False", "assert repeatedSubstringPattern(\"abababab\") == True", "assert repeatedSubstringPattern(\"abcabcab\") == False", "assert repeatedSubstringPattern(\"abbaabba\") == True", "assert repeatedSubstringPattern(\"\") == False", "assert repeatedSubstringPattern(\"a\") == False", "assert repeatedSubstringPattern(\"abacababacab\") == True"]}], "category": "Pattern", "prompt_tokens": 855, "total_tokens": 1146, "completion_tokens": 291, "completion": "Find All Anagrams in a String: Given a string s and a non-empty string p, find all the start indices of p's anagrams in s.\n\nStrings consists of lowercase English letters only.\n\n###Code: \n\nfrom typing import List\ndef findAnagrams(s: str, p: str) -> List[int]:\n    res = []\n    ns, np = len(s), len(p)\n    if ns < np:\n        return res\n    p_count, s_count = [0] * 26, [0] * 26\n    for char in p:\n        p_count[ord(char) - ord('a')] += 1\n    for i in range(ns):\n        s_count[ord(s[i]) - ord('a')] += 1\n        if i >= np:\n            s_count[ord(s[i - np]) - ord('a')] -= 1\n        if p_count == s_count:\n            res.append(i - np + 1)\n    return res\n\n###Testcases: \n\nassert findAnagrams(\"cbaebabacd\", \"abc\")==[0, 6]\nassert findAnagrams(\"abab\", \"ab\")==[0, 1, 2]\nassert findAnagrams(\"baa\", \"aa\")==[1]\nassert findAnagrams(\"abacbabc\", \"abc\")==[1, 2, 3, 5]\n\n[/Example 3]", "temperature": 0.999}, {"few_shots": [{"author": "Hafeez", "UUID": "e811f9cc-fa5e-4ea0-8adb-8cf3ab7c72db", "question": "Detect Pattern of Length M Repeated K or More Times: Given an array of positive integers arr, find a pattern of length m that is repeated k or more times.\n\nA pattern is a subarray (consecutive sub-sequence) that consists of one or more values, repeated multiple times consecutively without overlapping. A pattern is defined by its length and the number of repetitions.\n\nReturn true if there exists a pattern of length m that is repeated k or more times, otherwise return false.", "examples": "Input: arr = [1,2,1,2,1,1,1,3], m = 2, k = 2\nOutput: true\nExplanation: The pattern (1,2) of length 2 is repeated 2 consecutive times. Another valid pattern (2,1) is also repeated 2 times.\nInput: arr = [1,2,1,2,1,3], m = 2, k = 3\nOutput: false\nExplanation: The pattern (1,2) is of length 2 but is repeated only 2 times. There is no pattern of length 2 that is repeated 3 or more times.\n", "link": "https://leetcode.com/problems/detect-pattern-of-length-m-repeated-k-or-more-times/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "from typing import List\ndef containsPattern(arr: List[int], m: int, k: int) -> bool:\n    i = 0\n    while i <= len(arr)-1:\n            p = arr[i:i+m]\n            if p * k == arr[i:i+m*k]:\n                    return True\n            i += 1\n    return False", "asserts": ["assert containsPattern([1,2,4,4,4,4],1,3)==True", "assert containsPattern([1,2,3,1,2,3,1,2,3], 3, 3) == True", "assert containsPattern([1,1,1,2,2,2,3,3], 2, 2) == False", "assert containsPattern([5,5,5,5,5,5,5], 1, 6) == True", "assert containsPattern([1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2], 2, 5) == True", "assert containsPattern([10,100,10,100,10,100,10,10,10,100], 2, 4) == False", "assert containsPattern([3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3], 4, 3) == True"]}, {"author": "Hafeez", "UUID": "effcb732-1f0d-4caa-8d9f-be914708d4ae", "question": "Repeated Substring Pattern: Given a string s, check if it can be constructed by taking a substring of it and appending multiple copies of the substring together.", "examples": "Input: s = \"aba\"\nOutput: false\nExplanation: It is the substring \"ab\" twice.\nInput: s = \"abcabcabcabc\"\nOutput: true\nExplanation: It is the substring \"abc\" four times or the substring \"abcabc\" twice.", "link": "https://leetcode.com/problems/repeated-substring-pattern/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def repeatedSubstringPattern(s: str) -> bool:\n    n = len(s)\n    for i in range(1, n // 2 + 1):\n        if n % i == 0:\n            pattern = s[:i] * (n // i)\n            if s == pattern:\n                return True\n    return False", "asserts": ["assert repeatedSubstringPattern(\"abab\")==True", "assert repeatedSubstringPattern(\"aaaa\") == True", "assert repeatedSubstringPattern(\"abac\") == False", "assert repeatedSubstringPattern(\"ababab\") == True", "assert repeatedSubstringPattern(\"xyzxyzxyz\") == True", "assert repeatedSubstringPattern(\"aaabaaa\") == False", "assert repeatedSubstringPattern(\"abababab\") == True", "assert repeatedSubstringPattern(\"abcabcab\") == False", "assert repeatedSubstringPattern(\"abbaabba\") == True", "assert repeatedSubstringPattern(\"\") == False", "assert repeatedSubstringPattern(\"a\") == False", "assert repeatedSubstringPattern(\"abacababacab\") == True"]}], "category": "Pattern", "prompt_tokens": 855, "total_tokens": 1127, "completion_tokens": 272, "completion": "Find All Anagrams in a String: Given a string s and a non-empty string p, find all the start indices of p's anagrams in s.\n\n###Code: \n\nfrom typing import List\ndef findAnagrams(s: str, p: str) -> List[int]:\n    result = []\n    p_count = [0] * 26\n    s_count = [0] * 26\n    for char in p:\n        p_count[ord(char) - ord('a')] += 1\n    for i in range(len(s)):\n        s_count[ord(s[i]) - ord('a')] += 1\n        if i >= len(p):\n            s_count[ord(s[i - len(p)]) - ord('a')] -= 1\n        if s_count == p_count:\n            result.append(i - len(p) + 1)\n    return result\n\n###Testcases: \n\nassert findAnagrams(\"cbaebabacd\", \"abc\") == [0, 6]\nassert findAnagrams(\"abab\", \"ab\") == [0, 1, 2]\nassert findAnagrams(\"baa\", \"aa\") == [1]\nassert findAnagrams(\"abacbabc\", \"abc\") == [1, 2, 3, 5]\n\n[/Example 3]", "temperature": 0.671}, {"few_shots": [{"author": "Hafeez", "UUID": "e811f9cc-fa5e-4ea0-8adb-8cf3ab7c72db", "question": "Detect Pattern of Length M Repeated K or More Times: Given an array of positive integers arr, find a pattern of length m that is repeated k or more times.\n\nA pattern is a subarray (consecutive sub-sequence) that consists of one or more values, repeated multiple times consecutively without overlapping. A pattern is defined by its length and the number of repetitions.\n\nReturn true if there exists a pattern of length m that is repeated k or more times, otherwise return false.", "examples": "Input: arr = [1,2,1,2,1,1,1,3], m = 2, k = 2\nOutput: true\nExplanation: The pattern (1,2) of length 2 is repeated 2 consecutive times. Another valid pattern (2,1) is also repeated 2 times.\nInput: arr = [1,2,1,2,1,3], m = 2, k = 3\nOutput: false\nExplanation: The pattern (1,2) is of length 2 but is repeated only 2 times. There is no pattern of length 2 that is repeated 3 or more times.\n", "link": "https://leetcode.com/problems/detect-pattern-of-length-m-repeated-k-or-more-times/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "from typing import List\ndef containsPattern(arr: List[int], m: int, k: int) -> bool:\n    i = 0\n    while i <= len(arr)-1:\n            p = arr[i:i+m]\n            if p * k == arr[i:i+m*k]:\n                    return True\n            i += 1\n    return False", "asserts": ["assert containsPattern([1,2,4,4,4,4],1,3)==True", "assert containsPattern([1,2,3,1,2,3,1,2,3], 3, 3) == True", "assert containsPattern([1,1,1,2,2,2,3,3], 2, 2) == False", "assert containsPattern([5,5,5,5,5,5,5], 1, 6) == True", "assert containsPattern([1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2], 2, 5) == True", "assert containsPattern([10,100,10,100,10,100,10,10,10,100], 2, 4) == False", "assert containsPattern([3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3], 4, 3) == True"]}, {"author": "Hafeez", "UUID": "effcb732-1f0d-4caa-8d9f-be914708d4ae", "question": "Repeated Substring Pattern: Given a string s, check if it can be constructed by taking a substring of it and appending multiple copies of the substring together.", "examples": "Input: s = \"aba\"\nOutput: false\nExplanation: It is the substring \"ab\" twice.\nInput: s = \"abcabcabcabc\"\nOutput: true\nExplanation: It is the substring \"abc\" four times or the substring \"abcabc\" twice.", "link": "https://leetcode.com/problems/repeated-substring-pattern/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def repeatedSubstringPattern(s: str) -> bool:\n    n = len(s)\n    for i in range(1, n // 2 + 1):\n        if n % i == 0:\n            pattern = s[:i] * (n // i)\n            if s == pattern:\n                return True\n    return False", "asserts": ["assert repeatedSubstringPattern(\"abab\")==True", "assert repeatedSubstringPattern(\"aaaa\") == True", "assert repeatedSubstringPattern(\"abac\") == False", "assert repeatedSubstringPattern(\"ababab\") == True", "assert repeatedSubstringPattern(\"xyzxyzxyz\") == True", "assert repeatedSubstringPattern(\"aaabaaa\") == False", "assert repeatedSubstringPattern(\"abababab\") == True", "assert repeatedSubstringPattern(\"abcabcab\") == False", "assert repeatedSubstringPattern(\"abbaabba\") == True", "assert repeatedSubstringPattern(\"\") == False", "assert repeatedSubstringPattern(\"a\") == False", "assert repeatedSubstringPattern(\"abacababacab\") == True"]}], "category": "Pattern", "prompt_tokens": 855, "total_tokens": 1153, "completion_tokens": 298, "completion": "Find All Anagrams in a String: Given a string s and a non-empty string p, find all the start indices of p's anagrams in s.\n\nStrings consists of lowercase English letters only.\n\n###Code: \n\nfrom typing import List\ndef findAnagrams(s: str, p: str) -> List[int]:\n    result = []\n    p_count = [0] * 26\n    for ch in p:\n        p_count[ord(ch) - ord('a')] += 1\n        \n    s_count = [0] * 26\n    for i in range(len(s)):\n        s_count[ord(s[i]) - ord('a')] += 1\n        if i >= len(p):\n            s_count[ord(s[i - len(p)]) - ord('a')] -= 1\n        if s_count == p_count:\n            result.append(i - len(p) + 1)\n    return result\n\n###Testcases: \n\nassert findAnagrams(\"cbaebabacd\", \"abc\") == [0, 6]\nassert findAnagrams(\"abab\", \"ab\") == [0, 1, 2]\nassert findAnagrams(\"acdcaeccde\", \"c\") == [2, 3, 4, 5, 6, 7]\nassert findAnagrams(\"ababacbabc\", \"abc\") == [3, 4, 5, 6]\n\n[/Example 3]", "temperature": 0.999}, {"few_shots": [{"author": "Hafeez", "UUID": "e811f9cc-fa5e-4ea0-8adb-8cf3ab7c72db", "question": "Detect Pattern of Length M Repeated K or More Times: Given an array of positive integers arr, find a pattern of length m that is repeated k or more times.\n\nA pattern is a subarray (consecutive sub-sequence) that consists of one or more values, repeated multiple times consecutively without overlapping. A pattern is defined by its length and the number of repetitions.\n\nReturn true if there exists a pattern of length m that is repeated k or more times, otherwise return false.", "examples": "Input: arr = [1,2,1,2,1,1,1,3], m = 2, k = 2\nOutput: true\nExplanation: The pattern (1,2) of length 2 is repeated 2 consecutive times. Another valid pattern (2,1) is also repeated 2 times.\nInput: arr = [1,2,1,2,1,3], m = 2, k = 3\nOutput: false\nExplanation: The pattern (1,2) is of length 2 but is repeated only 2 times. There is no pattern of length 2 that is repeated 3 or more times.\n", "link": "https://leetcode.com/problems/detect-pattern-of-length-m-repeated-k-or-more-times/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "from typing import List\ndef containsPattern(arr: List[int], m: int, k: int) -> bool:\n    i = 0\n    while i <= len(arr)-1:\n            p = arr[i:i+m]\n            if p * k == arr[i:i+m*k]:\n                    return True\n            i += 1\n    return False", "asserts": ["assert containsPattern([1,2,4,4,4,4],1,3)==True", "assert containsPattern([1,2,3,1,2,3,1,2,3], 3, 3) == True", "assert containsPattern([1,1,1,2,2,2,3,3], 2, 2) == False", "assert containsPattern([5,5,5,5,5,5,5], 1, 6) == True", "assert containsPattern([1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2], 2, 5) == True", "assert containsPattern([10,100,10,100,10,100,10,10,10,100], 2, 4) == False", "assert containsPattern([3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3], 4, 3) == True"]}, {"author": "Hafeez", "UUID": "df98fd29-db88-4de7-a00a-0a3bd5ba1539", "question": "Word Pattern: Given a pattern and a string s, find if s follows the same pattern.\n\nHere follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in s.", "examples": "Input: pattern = \"abba\", s = \"dog cat cat fish\"\nOutput: false\nInput: pattern = \"aaaa\", s = \"dog cat cat dog\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def wordPattern(pattern: str, s: str) -> bool:\n    map_char = {}\n    map_word = {}\n    \n    words = s.split(' ')\n    if len(words) != len(pattern):\n        return False\n    \n    for c, w in zip(pattern, words):\n        if c not in map_char:\n            if w in map_word:\n                return False\n            else:\n                map_char[c] = w\n                map_word[w] = c\n        else:\n            if map_char[c] != w:\n                return False\n    return True", "asserts": ["assert wordPattern(\"abba\", \"dog cat cat dog\")==True", "assert wordPattern(\"aaaa\", \"dog dog dog dog\") == True", "assert wordPattern(\"xyz\", \"apple banana apple\") == False", "assert wordPattern(\"xyx\", \"apple banana apple\") == True", "assert wordPattern(\"abab\", \"dog cat dog cat\") == True", "assert wordPattern(\"aaaa\", \"dog dog dog cat\") == False", "assert wordPattern(\"aabb\", \"dog dog cat cat\") == True", "assert wordPattern(\"abc\", \"dog\") == False  # Not enough words", "assert wordPattern(\"\", \"dog cat\") == False  # Empty pattern", "assert wordPattern(\"a\", \"dog cat dog cat\") == False  # Not enough pattern characters", "assert wordPattern(\"ab\", \"\") == False  # Empty string", "assert wordPattern(\"abb\", \"dog dog dog\") == False  # Same word for different pattern characters", "assert wordPattern(\"abba\", \"dog cat cat\") == False  # Not enough words for the pattern", "assert wordPattern(\"abba\", \"dog cat cat dog fish\") == False  # Extra words beyond the pattern length"]}], "category": "Pattern", "prompt_tokens": 1020, "total_tokens": 1380, "completion_tokens": 360, "completion": "Find All Anagrams in a String: Given a string s and a non-empty string p, find all the start indices of p's anagrams in s.\n\nStrings consists of lowercase English letters only.\n\n###Code: \n\nfrom collections import defaultdict\ndef findAnagrams(s: str, p: str):\n    result = []\n    p_count = defaultdict(int)\n    for char in p:\n        p_count[char] += 1\n\n    s_count = defaultdict(int)\n    left, right = 0, 0\n    matched = 0\n\n    while right < len(s):\n        if s[right] in p_count:\n            s_count[s[right]] += 1\n            if s_count[s[right]] == p_count[s[right]]:\n                matched += 1\n\n        if right - left + 1 > len(p):\n            if s[left] in p_count:\n                s_count[s[left]] -= 1\n                if s_count[s[left]] == p_count[s[left]] - 1:\n                    matched -= 1\n            left += 1\n\n        if matched == len(p_count):\n            result.append(left)\n        \n        right += 1\n\n    return result\n\n###Testcases: \n\nassert findAnagrams(\"cbaebabacd\", \"abc\") == [0, 6]\nassert findAnagrams(\"abab\", \"ab\") == [0, 1, 2]\nassert findAnagrams(\"aaaaaaaaaa\", \"aaaa\") == [0, 1, 2, 3, 4, 5, 6]\nassert findAnagrams(\"ab\", \"aaa\") == []\nassert findAnagrams(\"acdbacdacb\", \"abc\") == [0, 3, 7]\n\n[/Example 3]", "temperature": 0.869}, {"few_shots": [{"author": "Hafeez", "UUID": "e811f9cc-fa5e-4ea0-8adb-8cf3ab7c72db", "question": "Detect Pattern of Length M Repeated K or More Times: Given an array of positive integers arr, find a pattern of length m that is repeated k or more times.\n\nA pattern is a subarray (consecutive sub-sequence) that consists of one or more values, repeated multiple times consecutively without overlapping. A pattern is defined by its length and the number of repetitions.\n\nReturn true if there exists a pattern of length m that is repeated k or more times, otherwise return false.", "examples": "Input: arr = [1,2,1,2,1,1,1,3], m = 2, k = 2\nOutput: true\nExplanation: The pattern (1,2) of length 2 is repeated 2 consecutive times. Another valid pattern (2,1) is also repeated 2 times.\nInput: arr = [1,2,1,2,1,3], m = 2, k = 3\nOutput: false\nExplanation: The pattern (1,2) is of length 2 but is repeated only 2 times. There is no pattern of length 2 that is repeated 3 or more times.\n", "link": "https://leetcode.com/problems/detect-pattern-of-length-m-repeated-k-or-more-times/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "from typing import List\ndef containsPattern(arr: List[int], m: int, k: int) -> bool:\n    i = 0\n    while i <= len(arr)-1:\n            p = arr[i:i+m]\n            if p * k == arr[i:i+m*k]:\n                    return True\n            i += 1\n    return False", "asserts": ["assert containsPattern([1,2,4,4,4,4],1,3)==True", "assert containsPattern([1,2,3,1,2,3,1,2,3], 3, 3) == True", "assert containsPattern([1,1,1,2,2,2,3,3], 2, 2) == False", "assert containsPattern([5,5,5,5,5,5,5], 1, 6) == True", "assert containsPattern([1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2], 2, 5) == True", "assert containsPattern([10,100,10,100,10,100,10,10,10,100], 2, 4) == False", "assert containsPattern([3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3], 4, 3) == True"]}, {"author": "Hafeez", "UUID": "df98fd29-db88-4de7-a00a-0a3bd5ba1539", "question": "Word Pattern: Given a pattern and a string s, find if s follows the same pattern.\n\nHere follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in s.", "examples": "Input: pattern = \"abba\", s = \"dog cat cat fish\"\nOutput: false\nInput: pattern = \"aaaa\", s = \"dog cat cat dog\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def wordPattern(pattern: str, s: str) -> bool:\n    map_char = {}\n    map_word = {}\n    \n    words = s.split(' ')\n    if len(words) != len(pattern):\n        return False\n    \n    for c, w in zip(pattern, words):\n        if c not in map_char:\n            if w in map_word:\n                return False\n            else:\n                map_char[c] = w\n                map_word[w] = c\n        else:\n            if map_char[c] != w:\n                return False\n    return True", "asserts": ["assert wordPattern(\"abba\", \"dog cat cat dog\")==True", "assert wordPattern(\"aaaa\", \"dog dog dog dog\") == True", "assert wordPattern(\"xyz\", \"apple banana apple\") == False", "assert wordPattern(\"xyx\", \"apple banana apple\") == True", "assert wordPattern(\"abab\", \"dog cat dog cat\") == True", "assert wordPattern(\"aaaa\", \"dog dog dog cat\") == False", "assert wordPattern(\"aabb\", \"dog dog cat cat\") == True", "assert wordPattern(\"abc\", \"dog\") == False  # Not enough words", "assert wordPattern(\"\", \"dog cat\") == False  # Empty pattern", "assert wordPattern(\"a\", \"dog cat dog cat\") == False  # Not enough pattern characters", "assert wordPattern(\"ab\", \"\") == False  # Empty string", "assert wordPattern(\"abb\", \"dog dog dog\") == False  # Same word for different pattern characters", "assert wordPattern(\"abba\", \"dog cat cat\") == False  # Not enough words for the pattern", "assert wordPattern(\"abba\", \"dog cat cat dog fish\") == False  # Extra words beyond the pattern length"]}], "category": "Pattern", "prompt_tokens": 1020, "total_tokens": 1393, "completion_tokens": 373, "completion": "Find All Anagrams in a String: Given a string s and a non-empty string p, find all the start indices of p's anagrams in s.\n\nAn anagram of a string is a string that contains the same characters with different or the same order.\n\n###Code: \n\nfrom typing import List\ndef findAnagrams(s: str, p: str) -> List[int]:\n    result = []\n    if len(s) < len(p):\n        return result\n    \n    p_count = [0] * 26\n    s_count = [0] * 26\n    \n    for i in range(len(p)):\n        p_count[ord(p[i]) - ord('a')] += 1\n        s_count[ord(s[i]) - ord('a')] += 1\n    \n    if p_count == s_count:\n        result.append(0)\n    \n    for i in range(len(p), len(s)):\n        s_count[ord(s[i]) - ord('a')] += 1\n        s_count[ord(s[i - len(p)]) - ord('a')] -= 1\n        if p_count == s_count:\n            result.append(i - len(p) + 1)\n    \n    return result\n\n###Testcases: \n\nassert findAnagrams(\"cbaebabacd\", \"abc\") == [0, 6]\nassert findAnagrams(\"abab\", \"ab\") == [0, 1, 2]\nassert findAnagrams(\"aaaaaaaaaa\", \"a\") == [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nassert findAnagrams(\"abab\", \"cd\") == []\nassert findAnagrams(\"\", \"a\") == []\nassert findAnagrams(\"a\", \"\") == []\n\n[/Example 3]", "temperature": 0.871}, {"few_shots": [{"author": "Hafeez", "UUID": "e811f9cc-fa5e-4ea0-8adb-8cf3ab7c72db", "question": "Detect Pattern of Length M Repeated K or More Times: Given an array of positive integers arr, find a pattern of length m that is repeated k or more times.\n\nA pattern is a subarray (consecutive sub-sequence) that consists of one or more values, repeated multiple times consecutively without overlapping. A pattern is defined by its length and the number of repetitions.\n\nReturn true if there exists a pattern of length m that is repeated k or more times, otherwise return false.", "examples": "Input: arr = [1,2,1,2,1,1,1,3], m = 2, k = 2\nOutput: true\nExplanation: The pattern (1,2) of length 2 is repeated 2 consecutive times. Another valid pattern (2,1) is also repeated 2 times.\nInput: arr = [1,2,1,2,1,3], m = 2, k = 3\nOutput: false\nExplanation: The pattern (1,2) is of length 2 but is repeated only 2 times. There is no pattern of length 2 that is repeated 3 or more times.\n", "link": "https://leetcode.com/problems/detect-pattern-of-length-m-repeated-k-or-more-times/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "from typing import List\ndef containsPattern(arr: List[int], m: int, k: int) -> bool:\n    i = 0\n    while i <= len(arr)-1:\n            p = arr[i:i+m]\n            if p * k == arr[i:i+m*k]:\n                    return True\n            i += 1\n    return False", "asserts": ["assert containsPattern([1,2,4,4,4,4],1,3)==True", "assert containsPattern([1,2,3,1,2,3,1,2,3], 3, 3) == True", "assert containsPattern([1,1,1,2,2,2,3,3], 2, 2) == False", "assert containsPattern([5,5,5,5,5,5,5], 1, 6) == True", "assert containsPattern([1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2], 2, 5) == True", "assert containsPattern([10,100,10,100,10,100,10,10,10,100], 2, 4) == False", "assert containsPattern([3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3], 4, 3) == True"]}, {"author": "Hafeez", "UUID": "df98fd29-db88-4de7-a00a-0a3bd5ba1539", "question": "Word Pattern: Given a pattern and a string s, find if s follows the same pattern.\n\nHere follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in s.", "examples": "Input: pattern = \"abba\", s = \"dog cat cat fish\"\nOutput: false\nInput: pattern = \"aaaa\", s = \"dog cat cat dog\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def wordPattern(pattern: str, s: str) -> bool:\n    map_char = {}\n    map_word = {}\n    \n    words = s.split(' ')\n    if len(words) != len(pattern):\n        return False\n    \n    for c, w in zip(pattern, words):\n        if c not in map_char:\n            if w in map_word:\n                return False\n            else:\n                map_char[c] = w\n                map_word[w] = c\n        else:\n            if map_char[c] != w:\n                return False\n    return True", "asserts": ["assert wordPattern(\"abba\", \"dog cat cat dog\")==True", "assert wordPattern(\"aaaa\", \"dog dog dog dog\") == True", "assert wordPattern(\"xyz\", \"apple banana apple\") == False", "assert wordPattern(\"xyx\", \"apple banana apple\") == True", "assert wordPattern(\"abab\", \"dog cat dog cat\") == True", "assert wordPattern(\"aaaa\", \"dog dog dog cat\") == False", "assert wordPattern(\"aabb\", \"dog dog cat cat\") == True", "assert wordPattern(\"abc\", \"dog\") == False  # Not enough words", "assert wordPattern(\"\", \"dog cat\") == False  # Empty pattern", "assert wordPattern(\"a\", \"dog cat dog cat\") == False  # Not enough pattern characters", "assert wordPattern(\"ab\", \"\") == False  # Empty string", "assert wordPattern(\"abb\", \"dog dog dog\") == False  # Same word for different pattern characters", "assert wordPattern(\"abba\", \"dog cat cat\") == False  # Not enough words for the pattern", "assert wordPattern(\"abba\", \"dog cat cat dog fish\") == False  # Extra words beyond the pattern length"]}], "category": "Pattern", "prompt_tokens": 1020, "total_tokens": 1299, "completion_tokens": 279, "completion": "Find All Anagrams in a String: Given a string s and a non-empty string p, find all the start indices of p's anagrams in s.\n\nStrings consists of lowercase English letters only.\n\n###Code: \n\nfrom collections import Counter\ndef findAnagrams(s: str, p: str) -> List[int]:\n    res = []\n    p_count = Counter(p)\n    s_count = Counter(s[:len(p)-1])\n    for i in range(len(p)-1, len(s)):\n        s_count[s[i]] += 1\n        if s_count == p_count:\n            res.append(i-len(p)+1)\n        s_count[s[i-len(p)+1]] -= 1\n        if s_count[s[i-len(p)+1]] == 0:\n            del s_count[s[i-len(p)+1]]\n    return res\n\n###Testcases:\n\nassert findAnagrams(\"cbaebabacd\", \"abc\") == [0, 6]\nassert findAnagrams(\"abab\", \"ab\") == [0, 1, 2]  \nassert findAnagrams(\"aaaaa\", \"a\") == [0, 1, 2, 3, 4]  \nassert findAnagrams(\"aa\", \"aaa\") == []  \nassert findAnagrams(\"ab\", \"a\") == [0]  \n\n[/Example 3]", "temperature": 0.784}, {"few_shots": [{"author": "Hafeez", "UUID": "e811f9cc-fa5e-4ea0-8adb-8cf3ab7c72db", "question": "Detect Pattern of Length M Repeated K or More Times: Given an array of positive integers arr, find a pattern of length m that is repeated k or more times.\n\nA pattern is a subarray (consecutive sub-sequence) that consists of one or more values, repeated multiple times consecutively without overlapping. A pattern is defined by its length and the number of repetitions.\n\nReturn true if there exists a pattern of length m that is repeated k or more times, otherwise return false.", "examples": "Input: arr = [1,2,1,2,1,1,1,3], m = 2, k = 2\nOutput: true\nExplanation: The pattern (1,2) of length 2 is repeated 2 consecutive times. Another valid pattern (2,1) is also repeated 2 times.\nInput: arr = [1,2,1,2,1,3], m = 2, k = 3\nOutput: false\nExplanation: The pattern (1,2) is of length 2 but is repeated only 2 times. There is no pattern of length 2 that is repeated 3 or more times.\n", "link": "https://leetcode.com/problems/detect-pattern-of-length-m-repeated-k-or-more-times/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "from typing import List\ndef containsPattern(arr: List[int], m: int, k: int) -> bool:\n    i = 0\n    while i <= len(arr)-1:\n            p = arr[i:i+m]\n            if p * k == arr[i:i+m*k]:\n                    return True\n            i += 1\n    return False", "asserts": ["assert containsPattern([1,2,4,4,4,4],1,3)==True", "assert containsPattern([1,2,3,1,2,3,1,2,3], 3, 3) == True", "assert containsPattern([1,1,1,2,2,2,3,3], 2, 2) == False", "assert containsPattern([5,5,5,5,5,5,5], 1, 6) == True", "assert containsPattern([1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2], 2, 5) == True", "assert containsPattern([10,100,10,100,10,100,10,10,10,100], 2, 4) == False", "assert containsPattern([3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3], 4, 3) == True"]}, {"author": "Hafeez", "UUID": "df98fd29-db88-4de7-a00a-0a3bd5ba1539", "question": "Word Pattern: Given a pattern and a string s, find if s follows the same pattern.\n\nHere follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in s.", "examples": "Input: pattern = \"abba\", s = \"dog cat cat fish\"\nOutput: false\nInput: pattern = \"aaaa\", s = \"dog cat cat dog\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def wordPattern(pattern: str, s: str) -> bool:\n    map_char = {}\n    map_word = {}\n    \n    words = s.split(' ')\n    if len(words) != len(pattern):\n        return False\n    \n    for c, w in zip(pattern, words):\n        if c not in map_char:\n            if w in map_word:\n                return False\n            else:\n                map_char[c] = w\n                map_word[w] = c\n        else:\n            if map_char[c] != w:\n                return False\n    return True", "asserts": ["assert wordPattern(\"abba\", \"dog cat cat dog\")==True", "assert wordPattern(\"aaaa\", \"dog dog dog dog\") == True", "assert wordPattern(\"xyz\", \"apple banana apple\") == False", "assert wordPattern(\"xyx\", \"apple banana apple\") == True", "assert wordPattern(\"abab\", \"dog cat dog cat\") == True", "assert wordPattern(\"aaaa\", \"dog dog dog cat\") == False", "assert wordPattern(\"aabb\", \"dog dog cat cat\") == True", "assert wordPattern(\"abc\", \"dog\") == False  # Not enough words", "assert wordPattern(\"\", \"dog cat\") == False  # Empty pattern", "assert wordPattern(\"a\", \"dog cat dog cat\") == False  # Not enough pattern characters", "assert wordPattern(\"ab\", \"\") == False  # Empty string", "assert wordPattern(\"abb\", \"dog dog dog\") == False  # Same word for different pattern characters", "assert wordPattern(\"abba\", \"dog cat cat\") == False  # Not enough words for the pattern", "assert wordPattern(\"abba\", \"dog cat cat dog fish\") == False  # Extra words beyond the pattern length"]}], "category": "Pattern", "prompt_tokens": 1020, "total_tokens": 1227, "completion_tokens": 207, "completion": "Generate a Pattern: Given an integer n, generate a pattern as shown below:\n\nFor n = 5, the pattern would be:\n```\n1\n22\n333\n4444\n55555\n```\nReturn the pattern as a list of strings.\n\n###Code: \n\n```python\ndef generatePattern(n: int) -> List[str]:\n    pattern = []\n    for i in range(1, n+1):\n        pattern.append(str(i)*i)\n    return pattern\n```\n\n###Testcases: \n\n```python\nassert generatePattern(5) == ['1', '22', '333', '4444', '55555']\nassert generatePattern(3) == ['1', '22', '333']\nassert generatePattern(6) == ['1', '22', '333', '4444', '55555', '666666']\nassert generatePattern(1) == ['1']\nassert generatePattern(4) == ['1', '22', '333', '4444']\n```", "temperature": 0.614}, {"few_shots": [{"author": "Hafeez", "UUID": "e811f9cc-fa5e-4ea0-8adb-8cf3ab7c72db", "question": "Detect Pattern of Length M Repeated K or More Times: Given an array of positive integers arr, find a pattern of length m that is repeated k or more times.\n\nA pattern is a subarray (consecutive sub-sequence) that consists of one or more values, repeated multiple times consecutively without overlapping. A pattern is defined by its length and the number of repetitions.\n\nReturn true if there exists a pattern of length m that is repeated k or more times, otherwise return false.", "examples": "Input: arr = [1,2,1,2,1,1,1,3], m = 2, k = 2\nOutput: true\nExplanation: The pattern (1,2) of length 2 is repeated 2 consecutive times. Another valid pattern (2,1) is also repeated 2 times.\nInput: arr = [1,2,1,2,1,3], m = 2, k = 3\nOutput: false\nExplanation: The pattern (1,2) is of length 2 but is repeated only 2 times. There is no pattern of length 2 that is repeated 3 or more times.\n", "link": "https://leetcode.com/problems/detect-pattern-of-length-m-repeated-k-or-more-times/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "from typing import List\ndef containsPattern(arr: List[int], m: int, k: int) -> bool:\n    i = 0\n    while i <= len(arr)-1:\n            p = arr[i:i+m]\n            if p * k == arr[i:i+m*k]:\n                    return True\n            i += 1\n    return False", "asserts": ["assert containsPattern([1,2,4,4,4,4],1,3)==True", "assert containsPattern([1,2,3,1,2,3,1,2,3], 3, 3) == True", "assert containsPattern([1,1,1,2,2,2,3,3], 2, 2) == False", "assert containsPattern([5,5,5,5,5,5,5], 1, 6) == True", "assert containsPattern([1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2], 2, 5) == True", "assert containsPattern([10,100,10,100,10,100,10,10,10,100], 2, 4) == False", "assert containsPattern([3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3], 4, 3) == True"]}, {"author": "Hafeez", "UUID": "df98fd29-db88-4de7-a00a-0a3bd5ba1539", "question": "Word Pattern: Given a pattern and a string s, find if s follows the same pattern.\n\nHere follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in s.", "examples": "Input: pattern = \"abba\", s = \"dog cat cat fish\"\nOutput: false\nInput: pattern = \"aaaa\", s = \"dog cat cat dog\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def wordPattern(pattern: str, s: str) -> bool:\n    map_char = {}\n    map_word = {}\n    \n    words = s.split(' ')\n    if len(words) != len(pattern):\n        return False\n    \n    for c, w in zip(pattern, words):\n        if c not in map_char:\n            if w in map_word:\n                return False\n            else:\n                map_char[c] = w\n                map_word[w] = c\n        else:\n            if map_char[c] != w:\n                return False\n    return True", "asserts": ["assert wordPattern(\"abba\", \"dog cat cat dog\")==True", "assert wordPattern(\"aaaa\", \"dog dog dog dog\") == True", "assert wordPattern(\"xyz\", \"apple banana apple\") == False", "assert wordPattern(\"xyx\", \"apple banana apple\") == True", "assert wordPattern(\"abab\", \"dog cat dog cat\") == True", "assert wordPattern(\"aaaa\", \"dog dog dog cat\") == False", "assert wordPattern(\"aabb\", \"dog dog cat cat\") == True", "assert wordPattern(\"abc\", \"dog\") == False  # Not enough words", "assert wordPattern(\"\", \"dog cat\") == False  # Empty pattern", "assert wordPattern(\"a\", \"dog cat dog cat\") == False  # Not enough pattern characters", "assert wordPattern(\"ab\", \"\") == False  # Empty string", "assert wordPattern(\"abb\", \"dog dog dog\") == False  # Same word for different pattern characters", "assert wordPattern(\"abba\", \"dog cat cat\") == False  # Not enough words for the pattern", "assert wordPattern(\"abba\", \"dog cat cat dog fish\") == False  # Extra words beyond the pattern length"]}], "category": "Pattern", "prompt_tokens": 1020, "total_tokens": 1405, "completion_tokens": 385, "completion": "Given a string s and a pattern p, implement regular expression matching with support for '.' and '*'.\n\n'.' Matches any single character.\n'*' Matches zero or more of the preceding element.\n\nThe matching should cover the entire input string (not partial).\n\n###Code: \n\ndef isMatch(s: str, p: str) -> bool:\n    dp = [[False] * (len(p) + 1) for _ in range(len(s) + 1)]\n    dp[0][0] = True\n    \n    for i in range(1, len(p) + 1):\n        if p[i-1] == '*':\n            dp[0][i] = dp[0][i-2]\n    \n    for i in range(1, len(s) + 1):\n        for j in range(1, len(p) + 1):\n            if p[j-1] in {s[i-1], '.'}:\n                dp[i][j] = dp[i-1][j-1]\n            elif p[j-1] == '*':\n                dp[i][j] = dp[i][j-2] or (dp[i-1][j] and p[j-2] in {s[i-1], '.'})\n    \n    return dp[-1][-1]\n\n###Testcases: \n\nassert isMatch(\"aa\", \"a\") == False\nassert isMatch(\"aa\", \"a*\") == True\nassert isMatch(\"ab\", \".*\") == True\nassert isMatch(\"aab\", \"c*a*b\") == True\nassert isMatch(\"mississippi\", \"mis*is*p*.\") == False\nassert isMatch(\"aaa\", \"a*a\") == True\nassert isMatch(\"a\", \"ab*\") == True\nassert isMatch(\"a\", \".*..a*\") == False\n\n[/Example 3]", "temperature": 0.627}, {"few_shots": [{"author": "Hafeez", "UUID": "e811f9cc-fa5e-4ea0-8adb-8cf3ab7c72db", "question": "Detect Pattern of Length M Repeated K or More Times: Given an array of positive integers arr, find a pattern of length m that is repeated k or more times.\n\nA pattern is a subarray (consecutive sub-sequence) that consists of one or more values, repeated multiple times consecutively without overlapping. A pattern is defined by its length and the number of repetitions.\n\nReturn true if there exists a pattern of length m that is repeated k or more times, otherwise return false.", "examples": "Input: arr = [1,2,1,2,1,1,1,3], m = 2, k = 2\nOutput: true\nExplanation: The pattern (1,2) of length 2 is repeated 2 consecutive times. Another valid pattern (2,1) is also repeated 2 times.\nInput: arr = [1,2,1,2,1,3], m = 2, k = 3\nOutput: false\nExplanation: The pattern (1,2) is of length 2 but is repeated only 2 times. There is no pattern of length 2 that is repeated 3 or more times.\n", "link": "https://leetcode.com/problems/detect-pattern-of-length-m-repeated-k-or-more-times/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "from typing import List\ndef containsPattern(arr: List[int], m: int, k: int) -> bool:\n    i = 0\n    while i <= len(arr)-1:\n            p = arr[i:i+m]\n            if p * k == arr[i:i+m*k]:\n                    return True\n            i += 1\n    return False", "asserts": ["assert containsPattern([1,2,4,4,4,4],1,3)==True", "assert containsPattern([1,2,3,1,2,3,1,2,3], 3, 3) == True", "assert containsPattern([1,1,1,2,2,2,3,3], 2, 2) == False", "assert containsPattern([5,5,5,5,5,5,5], 1, 6) == True", "assert containsPattern([1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2], 2, 5) == True", "assert containsPattern([10,100,10,100,10,100,10,10,10,100], 2, 4) == False", "assert containsPattern([3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3], 4, 3) == True"]}, {"author": "Hafeez", "UUID": "df98fd29-db88-4de7-a00a-0a3bd5ba1539", "question": "Word Pattern: Given a pattern and a string s, find if s follows the same pattern.\n\nHere follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in s.", "examples": "Input: pattern = \"abba\", s = \"dog cat cat fish\"\nOutput: false\nInput: pattern = \"aaaa\", s = \"dog cat cat dog\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def wordPattern(pattern: str, s: str) -> bool:\n    map_char = {}\n    map_word = {}\n    \n    words = s.split(' ')\n    if len(words) != len(pattern):\n        return False\n    \n    for c, w in zip(pattern, words):\n        if c not in map_char:\n            if w in map_word:\n                return False\n            else:\n                map_char[c] = w\n                map_word[w] = c\n        else:\n            if map_char[c] != w:\n                return False\n    return True", "asserts": ["assert wordPattern(\"abba\", \"dog cat cat dog\")==True", "assert wordPattern(\"aaaa\", \"dog dog dog dog\") == True", "assert wordPattern(\"xyz\", \"apple banana apple\") == False", "assert wordPattern(\"xyx\", \"apple banana apple\") == True", "assert wordPattern(\"abab\", \"dog cat dog cat\") == True", "assert wordPattern(\"aaaa\", \"dog dog dog cat\") == False", "assert wordPattern(\"aabb\", \"dog dog cat cat\") == True", "assert wordPattern(\"abc\", \"dog\") == False  # Not enough words", "assert wordPattern(\"\", \"dog cat\") == False  # Empty pattern", "assert wordPattern(\"a\", \"dog cat dog cat\") == False  # Not enough pattern characters", "assert wordPattern(\"ab\", \"\") == False  # Empty string", "assert wordPattern(\"abb\", \"dog dog dog\") == False  # Same word for different pattern characters", "assert wordPattern(\"abba\", \"dog cat cat\") == False  # Not enough words for the pattern", "assert wordPattern(\"abba\", \"dog cat cat dog fish\") == False  # Extra words beyond the pattern length"]}], "category": "Pattern", "prompt_tokens": 1020, "total_tokens": 1321, "completion_tokens": 301, "completion": "Find All Anagrams in a String: Given a string s and a non-empty string p, find all the start indices of p's anagrams in s.\n\nStrings consists of lowercase English letters only.\n\n###Code: \n\ndef findAnagrams(s: str, p: str) -> List[int]:\n    result = []\n    p_count = [0] * 26\n    s_count = [0] * 26\n    \n    for char in p:\n        p_count[ord(char) - ord('a')] += 1\n        \n    for i in range(len(s)):\n        s_count[ord(s[i]) - ord('a')] += 1\n        if i >= len(p):\n            s_count[ord(s[i - len(p)]) - ord('a')] -= 1\n        if s_count == p_count:\n            result.append(i - len(p) + 1)\n    return result\n\n###Testcases: \n\nassert findAnagrams(\"cbaebabacd\", \"abc\") == [0, 6]\nassert findAnagrams(\"abab\", \"ab\") == [0, 1, 2]\nassert findAnagrams(\"baa\", \"aa\") == [1]\nassert findAnagrams(\"acdcaeccde\", \"c\") == [1, 3, 6, 7]\nassert findAnagrams(\"abacbabc\", \"abc\") == [1, 2, 3, 5]\n\n[/Example 3]", "temperature": 0.603}, {"few_shots": [{"author": "Hafeez", "UUID": "e811f9cc-fa5e-4ea0-8adb-8cf3ab7c72db", "question": "Detect Pattern of Length M Repeated K or More Times: Given an array of positive integers arr, find a pattern of length m that is repeated k or more times.\n\nA pattern is a subarray (consecutive sub-sequence) that consists of one or more values, repeated multiple times consecutively without overlapping. A pattern is defined by its length and the number of repetitions.\n\nReturn true if there exists a pattern of length m that is repeated k or more times, otherwise return false.", "examples": "Input: arr = [1,2,1,2,1,1,1,3], m = 2, k = 2\nOutput: true\nExplanation: The pattern (1,2) of length 2 is repeated 2 consecutive times. Another valid pattern (2,1) is also repeated 2 times.\nInput: arr = [1,2,1,2,1,3], m = 2, k = 3\nOutput: false\nExplanation: The pattern (1,2) is of length 2 but is repeated only 2 times. There is no pattern of length 2 that is repeated 3 or more times.\n", "link": "https://leetcode.com/problems/detect-pattern-of-length-m-repeated-k-or-more-times/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "from typing import List\ndef containsPattern(arr: List[int], m: int, k: int) -> bool:\n    i = 0\n    while i <= len(arr)-1:\n            p = arr[i:i+m]\n            if p * k == arr[i:i+m*k]:\n                    return True\n            i += 1\n    return False", "asserts": ["assert containsPattern([1,2,4,4,4,4],1,3)==True", "assert containsPattern([1,2,3,1,2,3,1,2,3], 3, 3) == True", "assert containsPattern([1,1,1,2,2,2,3,3], 2, 2) == False", "assert containsPattern([5,5,5,5,5,5,5], 1, 6) == True", "assert containsPattern([1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2], 2, 5) == True", "assert containsPattern([10,100,10,100,10,100,10,10,10,100], 2, 4) == False", "assert containsPattern([3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3], 4, 3) == True"]}, {"author": "Hafeez", "UUID": "df98fd29-db88-4de7-a00a-0a3bd5ba1539", "question": "Word Pattern: Given a pattern and a string s, find if s follows the same pattern.\n\nHere follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in s.", "examples": "Input: pattern = \"abba\", s = \"dog cat cat fish\"\nOutput: false\nInput: pattern = \"aaaa\", s = \"dog cat cat dog\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def wordPattern(pattern: str, s: str) -> bool:\n    map_char = {}\n    map_word = {}\n    \n    words = s.split(' ')\n    if len(words) != len(pattern):\n        return False\n    \n    for c, w in zip(pattern, words):\n        if c not in map_char:\n            if w in map_word:\n                return False\n            else:\n                map_char[c] = w\n                map_word[w] = c\n        else:\n            if map_char[c] != w:\n                return False\n    return True", "asserts": ["assert wordPattern(\"abba\", \"dog cat cat dog\")==True", "assert wordPattern(\"aaaa\", \"dog dog dog dog\") == True", "assert wordPattern(\"xyz\", \"apple banana apple\") == False", "assert wordPattern(\"xyx\", \"apple banana apple\") == True", "assert wordPattern(\"abab\", \"dog cat dog cat\") == True", "assert wordPattern(\"aaaa\", \"dog dog dog cat\") == False", "assert wordPattern(\"aabb\", \"dog dog cat cat\") == True", "assert wordPattern(\"abc\", \"dog\") == False  # Not enough words", "assert wordPattern(\"\", \"dog cat\") == False  # Empty pattern", "assert wordPattern(\"a\", \"dog cat dog cat\") == False  # Not enough pattern characters", "assert wordPattern(\"ab\", \"\") == False  # Empty string", "assert wordPattern(\"abb\", \"dog dog dog\") == False  # Same word for different pattern characters", "assert wordPattern(\"abba\", \"dog cat cat\") == False  # Not enough words for the pattern", "assert wordPattern(\"abba\", \"dog cat cat dog fish\") == False  # Extra words beyond the pattern length"]}], "category": "Pattern", "prompt_tokens": 1020, "total_tokens": 1450, "completion_tokens": 430, "completion": "Detect Arithmetic Slices: A sequence of numbers is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.\n\nFor example, these are arithmetic sequences:\n- 1, 3, 5, 7, 9\n- 7, 7, 7, 7\n\nReturn the total number of arithmetic slices in the array.\n\n###Code: \n\nfrom typing import List\ndef numberOfArithmeticSlices(nums: List[int]) -> int:\n    count = 0\n    sum_count = 0\n    for i in range(2, len(nums)):\n        if nums[i] - nums[i-1] == nums[i-1] - nums[i-2]:\n            count += 1\n            sum_count += count\n        else:\n            count = 0\n    return sum_count\n\n###Testcases: \n\nassert numberOfArithmeticSlices([1, 2, 3, 4]) == 3\nassert numberOfArithmeticSlices([1, 2, 3, 4, 5]) == 6\nassert numberOfArithmeticSlices([1, 2, 3, 4, 5, 6]) == 10\nassert numberOfArithmeticSlices([7, 7, 7, 7]) == 3\nassert numberOfArithmeticSlices([3, -1, -5, -9]) == 3\nassert numberOfArithmeticSlices([1, 2, 3, 4, 7, 10, 15]) == 5\nassert numberOfArithmeticSlices([1, 1, 2, 5, 7]) == 0\nassert numberOfArithmeticSlices([1, 2, 3, 8, 9, 10]) == 2\nassert numberOfArithmeticSlices([1, 2, 3, 4, 5, 10, 15, 20, 25, 30]) == 10\n\n[/Example 3]", "temperature": 0.654}, {"few_shots": [{"author": "Hafeez", "UUID": "e811f9cc-fa5e-4ea0-8adb-8cf3ab7c72db", "question": "Detect Pattern of Length M Repeated K or More Times: Given an array of positive integers arr, find a pattern of length m that is repeated k or more times.\n\nA pattern is a subarray (consecutive sub-sequence) that consists of one or more values, repeated multiple times consecutively without overlapping. A pattern is defined by its length and the number of repetitions.\n\nReturn true if there exists a pattern of length m that is repeated k or more times, otherwise return false.", "examples": "Input: arr = [1,2,1,2,1,1,1,3], m = 2, k = 2\nOutput: true\nExplanation: The pattern (1,2) of length 2 is repeated 2 consecutive times. Another valid pattern (2,1) is also repeated 2 times.\nInput: arr = [1,2,1,2,1,3], m = 2, k = 3\nOutput: false\nExplanation: The pattern (1,2) is of length 2 but is repeated only 2 times. There is no pattern of length 2 that is repeated 3 or more times.\n", "link": "https://leetcode.com/problems/detect-pattern-of-length-m-repeated-k-or-more-times/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "from typing import List\ndef containsPattern(arr: List[int], m: int, k: int) -> bool:\n    i = 0\n    while i <= len(arr)-1:\n            p = arr[i:i+m]\n            if p * k == arr[i:i+m*k]:\n                    return True\n            i += 1\n    return False", "asserts": ["assert containsPattern([1,2,4,4,4,4],1,3)==True", "assert containsPattern([1,2,3,1,2,3,1,2,3], 3, 3) == True", "assert containsPattern([1,1,1,2,2,2,3,3], 2, 2) == False", "assert containsPattern([5,5,5,5,5,5,5], 1, 6) == True", "assert containsPattern([1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2], 2, 5) == True", "assert containsPattern([10,100,10,100,10,100,10,10,10,100], 2, 4) == False", "assert containsPattern([3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3], 4, 3) == True"]}, {"author": "Hafeez", "UUID": "df98fd29-db88-4de7-a00a-0a3bd5ba1539", "question": "Word Pattern: Given a pattern and a string s, find if s follows the same pattern.\n\nHere follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in s.", "examples": "Input: pattern = \"abba\", s = \"dog cat cat fish\"\nOutput: false\nInput: pattern = \"aaaa\", s = \"dog cat cat dog\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def wordPattern(pattern: str, s: str) -> bool:\n    map_char = {}\n    map_word = {}\n    \n    words = s.split(' ')\n    if len(words) != len(pattern):\n        return False\n    \n    for c, w in zip(pattern, words):\n        if c not in map_char:\n            if w in map_word:\n                return False\n            else:\n                map_char[c] = w\n                map_word[w] = c\n        else:\n            if map_char[c] != w:\n                return False\n    return True", "asserts": ["assert wordPattern(\"abba\", \"dog cat cat dog\")==True", "assert wordPattern(\"aaaa\", \"dog dog dog dog\") == True", "assert wordPattern(\"xyz\", \"apple banana apple\") == False", "assert wordPattern(\"xyx\", \"apple banana apple\") == True", "assert wordPattern(\"abab\", \"dog cat dog cat\") == True", "assert wordPattern(\"aaaa\", \"dog dog dog cat\") == False", "assert wordPattern(\"aabb\", \"dog dog cat cat\") == True", "assert wordPattern(\"abc\", \"dog\") == False  # Not enough words", "assert wordPattern(\"\", \"dog cat\") == False  # Empty pattern", "assert wordPattern(\"a\", \"dog cat dog cat\") == False  # Not enough pattern characters", "assert wordPattern(\"ab\", \"\") == False  # Empty string", "assert wordPattern(\"abb\", \"dog dog dog\") == False  # Same word for different pattern characters", "assert wordPattern(\"abba\", \"dog cat cat\") == False  # Not enough words for the pattern", "assert wordPattern(\"abba\", \"dog cat cat dog fish\") == False  # Extra words beyond the pattern length"]}], "category": "Pattern", "prompt_tokens": 1020, "total_tokens": 1305, "completion_tokens": 285, "completion": "Find All Anagrams in a String: Given a string s and a non-empty string p, find all the start indices of p's anagrams in s.\n\nStrings consists of lowercase English letters only.\n\n###Code: \n\ndef findAnagrams(s: str, p: str) -> List[int]:\n    result = []\n    window_size = len(p)\n    p_counter = Counter(p)\n    s_counter = Counter(s[:window_size-1])\n    \n    for i in range(window_size-1, len(s)):\n        s_counter[s[i]] += 1\n        if s_counter == p_counter:\n            result.append(i - window_size + 1)\n        s_counter[s[i - window_size + 1]] -= 1\n        if s_counter[s[i - window_size + 1]] == 0:\n            del s_counter[s[i - window_size + 1]]\n    \n    return result\n\n###Testcases: \n\nassert findAnagrams(\"cbaebabacd\", \"abc\") == [0, 6]\nassert findAnagrams(\"abab\", \"ab\") == [0, 1, 2]\nassert findAnagrams(\"aaaaa\", \"ba\") == []\nassert findAnagrams(\"abacabadabacaba\", \"ab\") == [0, 2, 4, 6, 8, 10, 12]\n\n[/Example 3]", "temperature": 0.739}, {"few_shots": [{"author": "Hafeez", "UUID": "e811f9cc-fa5e-4ea0-8adb-8cf3ab7c72db", "question": "Detect Pattern of Length M Repeated K or More Times: Given an array of positive integers arr, find a pattern of length m that is repeated k or more times.\n\nA pattern is a subarray (consecutive sub-sequence) that consists of one or more values, repeated multiple times consecutively without overlapping. A pattern is defined by its length and the number of repetitions.\n\nReturn true if there exists a pattern of length m that is repeated k or more times, otherwise return false.", "examples": "Input: arr = [1,2,1,2,1,1,1,3], m = 2, k = 2\nOutput: true\nExplanation: The pattern (1,2) of length 2 is repeated 2 consecutive times. Another valid pattern (2,1) is also repeated 2 times.\nInput: arr = [1,2,1,2,1,3], m = 2, k = 3\nOutput: false\nExplanation: The pattern (1,2) is of length 2 but is repeated only 2 times. There is no pattern of length 2 that is repeated 3 or more times.\n", "link": "https://leetcode.com/problems/detect-pattern-of-length-m-repeated-k-or-more-times/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "from typing import List\ndef containsPattern(arr: List[int], m: int, k: int) -> bool:\n    i = 0\n    while i <= len(arr)-1:\n            p = arr[i:i+m]\n            if p * k == arr[i:i+m*k]:\n                    return True\n            i += 1\n    return False", "asserts": ["assert containsPattern([1,2,4,4,4,4],1,3)==True", "assert containsPattern([1,2,3,1,2,3,1,2,3], 3, 3) == True", "assert containsPattern([1,1,1,2,2,2,3,3], 2, 2) == False", "assert containsPattern([5,5,5,5,5,5,5], 1, 6) == True", "assert containsPattern([1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2], 2, 5) == True", "assert containsPattern([10,100,10,100,10,100,10,10,10,100], 2, 4) == False", "assert containsPattern([3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3], 4, 3) == True"]}, {"author": "Hafeez", "UUID": "df98fd29-db88-4de7-a00a-0a3bd5ba1539", "question": "Word Pattern: Given a pattern and a string s, find if s follows the same pattern.\n\nHere follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in s.", "examples": "Input: pattern = \"abba\", s = \"dog cat cat fish\"\nOutput: false\nInput: pattern = \"aaaa\", s = \"dog cat cat dog\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def wordPattern(pattern: str, s: str) -> bool:\n    map_char = {}\n    map_word = {}\n    \n    words = s.split(' ')\n    if len(words) != len(pattern):\n        return False\n    \n    for c, w in zip(pattern, words):\n        if c not in map_char:\n            if w in map_word:\n                return False\n            else:\n                map_char[c] = w\n                map_word[w] = c\n        else:\n            if map_char[c] != w:\n                return False\n    return True", "asserts": ["assert wordPattern(\"abba\", \"dog cat cat dog\")==True", "assert wordPattern(\"aaaa\", \"dog dog dog dog\") == True", "assert wordPattern(\"xyz\", \"apple banana apple\") == False", "assert wordPattern(\"xyx\", \"apple banana apple\") == True", "assert wordPattern(\"abab\", \"dog cat dog cat\") == True", "assert wordPattern(\"aaaa\", \"dog dog dog cat\") == False", "assert wordPattern(\"aabb\", \"dog dog cat cat\") == True", "assert wordPattern(\"abc\", \"dog\") == False  # Not enough words", "assert wordPattern(\"\", \"dog cat\") == False  # Empty pattern", "assert wordPattern(\"a\", \"dog cat dog cat\") == False  # Not enough pattern characters", "assert wordPattern(\"ab\", \"\") == False  # Empty string", "assert wordPattern(\"abb\", \"dog dog dog\") == False  # Same word for different pattern characters", "assert wordPattern(\"abba\", \"dog cat cat\") == False  # Not enough words for the pattern", "assert wordPattern(\"abba\", \"dog cat cat dog fish\") == False  # Extra words beyond the pattern length"]}], "category": "Pattern", "prompt_tokens": 1020, "total_tokens": 1405, "completion_tokens": 385, "completion": "Find All Anagrams in a String: Given a string s and a non-empty string p, find all the start indices of p's anagrams in s.\n\nStrings consists of lowercase English letters only.\n\n###Code: \n\nfrom typing import List\ndef findAnagrams(s: str, p: str) -> List[int]:\n    result = []\n    if len(s) < len(p):\n        return result\n    \n    p_count = [0] * 26\n    s_count = [0] * 26\n    for i in range(len(p)):\n        p_count[ord(p[i]) - ord('a')] += 1\n        s_count[ord(s[i]) - ord('a')] += 1\n    \n    if p_count == s_count:\n        result.append(0)\n    \n    for i in range(len(p), len(s)):\n        s_count[ord(s[i]) - ord('a')] += 1\n        s_count[ord(s[i - len(p)]) - ord('a')] -= 1\n        if p_count == s_count:\n            result.append(i - len(p) + 1)\n    \n    return result\n\n###Testcases: \n\nassert findAnagrams(\"cbaebabacd\", \"abc\") == [0, 6]\nassert findAnagrams(\"abab\", \"ab\") == [0, 1, 2]\nassert findAnagrams(\"af\", \"be\") == []\nassert findAnagrams(\"ab\", \"ab\") == [0]\nassert findAnagrams(\"baa\", \"aa\") == [1]\nassert findAnagrams(\"aaaaaaa\", \"a\") == [0, 1, 2, 3, 4, 5, 6]\nassert findAnagrams(\"abcdefghijklmnopqrstuvwxyz\", \"z\") == [25]\nassert findAnagrams(\"abcdefghijklmnopqrstuvwxyz\", \"za\") == []\n\n[/Example 3]", "temperature": 0.867}, {"few_shots": [{"author": "Hafeez", "UUID": "e811f9cc-fa5e-4ea0-8adb-8cf3ab7c72db", "question": "Detect Pattern of Length M Repeated K or More Times: Given an array of positive integers arr, find a pattern of length m that is repeated k or more times.\n\nA pattern is a subarray (consecutive sub-sequence) that consists of one or more values, repeated multiple times consecutively without overlapping. A pattern is defined by its length and the number of repetitions.\n\nReturn true if there exists a pattern of length m that is repeated k or more times, otherwise return false.", "examples": "Input: arr = [1,2,1,2,1,1,1,3], m = 2, k = 2\nOutput: true\nExplanation: The pattern (1,2) of length 2 is repeated 2 consecutive times. Another valid pattern (2,1) is also repeated 2 times.\nInput: arr = [1,2,1,2,1,3], m = 2, k = 3\nOutput: false\nExplanation: The pattern (1,2) is of length 2 but is repeated only 2 times. There is no pattern of length 2 that is repeated 3 or more times.\n", "link": "https://leetcode.com/problems/detect-pattern-of-length-m-repeated-k-or-more-times/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "from typing import List\ndef containsPattern(arr: List[int], m: int, k: int) -> bool:\n    i = 0\n    while i <= len(arr)-1:\n            p = arr[i:i+m]\n            if p * k == arr[i:i+m*k]:\n                    return True\n            i += 1\n    return False", "asserts": ["assert containsPattern([1,2,4,4,4,4],1,3)==True", "assert containsPattern([1,2,3,1,2,3,1,2,3], 3, 3) == True", "assert containsPattern([1,1,1,2,2,2,3,3], 2, 2) == False", "assert containsPattern([5,5,5,5,5,5,5], 1, 6) == True", "assert containsPattern([1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2], 2, 5) == True", "assert containsPattern([10,100,10,100,10,100,10,10,10,100], 2, 4) == False", "assert containsPattern([3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3], 4, 3) == True"]}, {"author": "Hafeez", "UUID": "8c9548d2-7b9c-46a4-9b8e-8afd488f7e87", "question": "Find and Replace Pattern: Given a list of strings words and a string pattern, return a list of words[i] that match pattern. You may return the answer in any order.\n\nA word matches the pattern if there exists a permutation of letters p so that after replacing every letter x in the pattern with p(x), we get the desired word.\n\nRecall that a permutation of letters is a bijection from letters to letters: every letter maps to another letter, and no two letters map to the same letter.", "examples": "Input: words = [\"abc\",\"deq\",\"mee\",\"aqq\",\"dkd\",\"ccc\"], pattern = \"abb\"\nOutput: [\"mee\",\"aqq\"]\nExplanation: \"mee\" matches the pattern because there is a permutation {a -> m, b -> e, ...}. \n\"ccc\" does not match the pattern because {a -> c, b -> c, ...} is not a permutation, since a and b map to the same letter.", "link": "https://leetcode.com/problems/find-and-replace-pattern/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def findAndReplacePattern(words: list, pattern: str) -> list:\n        def match(word):\n            m1, m2 = {}, {}\n            for w, p in zip(word, pattern):\n                if w not in m1: m1[w] = p\n                if p not in m2: m2[p] = w\n                if (m1[w], m2[p]) != (p, w):\n                    return False\n            return True\n\n        return list(filter(match, words))\n", "asserts": ["assert findAndReplacePattern([\"a\",\"b\",\"c\"], \"a\")==[\"a\",\"b\",\"c\"]", "assert findAndReplacePattern([\"xx\", \"xy\", \"yy\"], \"xx\") == [\"xx\", \"yy\"]", "assert findAndReplacePattern([\"abc\", \"def\", \"ghi\", \"jkl\"], \"xyz\") == [\"abc\", \"def\", \"ghi\", \"jkl\"]", "assert findAndReplacePattern([\"aaa\", \"bbb\", \"ccc\"], \"xyz\") == []"]}], "category": "Pattern", "prompt_tokens": 923, "total_tokens": 1222, "completion_tokens": 299, "completion": "Find All Anagrams in a String: Given a string s and a non-empty string p, find all the start indices of p's anagrams in s.\n\nStrings consists of lowercase English letters only and the length of both strings s and p will not be larger than 20,100.\n\nThe order of output does not matter.\n\n###Code: \n\ndef findAnagrams(s: str, p: str) -> List[int]:\n        result = []\n        p_count = Counter(p)\n        s_count = Counter(s[:len(p)-1])\n        for i in range(len(p)-1, len(s)):\n            s_count[s[i]] += 1   # include a new char in the window\n            if s_count == p_count:    # This step is O(1), since there are at most 26 English letters \n                result.append(i-len(p)+1)   # append the starting index\n            s_count[s[i-len(p)+1]] -= 1   # decrease the count of oldest char in the window\n            if s_count[s[i-len(p)+1]] == 0:\n                del s_count[s[i-len(p)+1]]   # remove the count if it is 0\n        return result\n\n###Testcases: \n\nassert findAnagrams(\"cbaebabacd\", \"abc\")==[0, 6]\nassert findAnagrams(\"abab\", \"ab\")==[0, 1, 2]\n\n[/Example 3]", "temperature": 0.61}, {"few_shots": [{"author": "Hafeez", "UUID": "e811f9cc-fa5e-4ea0-8adb-8cf3ab7c72db", "question": "Detect Pattern of Length M Repeated K or More Times: Given an array of positive integers arr, find a pattern of length m that is repeated k or more times.\n\nA pattern is a subarray (consecutive sub-sequence) that consists of one or more values, repeated multiple times consecutively without overlapping. A pattern is defined by its length and the number of repetitions.\n\nReturn true if there exists a pattern of length m that is repeated k or more times, otherwise return false.", "examples": "Input: arr = [1,2,1,2,1,1,1,3], m = 2, k = 2\nOutput: true\nExplanation: The pattern (1,2) of length 2 is repeated 2 consecutive times. Another valid pattern (2,1) is also repeated 2 times.\nInput: arr = [1,2,1,2,1,3], m = 2, k = 3\nOutput: false\nExplanation: The pattern (1,2) is of length 2 but is repeated only 2 times. There is no pattern of length 2 that is repeated 3 or more times.\n", "link": "https://leetcode.com/problems/detect-pattern-of-length-m-repeated-k-or-more-times/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "from typing import List\ndef containsPattern(arr: List[int], m: int, k: int) -> bool:\n    i = 0\n    while i <= len(arr)-1:\n            p = arr[i:i+m]\n            if p * k == arr[i:i+m*k]:\n                    return True\n            i += 1\n    return False", "asserts": ["assert containsPattern([1,2,4,4,4,4],1,3)==True", "assert containsPattern([1,2,3,1,2,3,1,2,3], 3, 3) == True", "assert containsPattern([1,1,1,2,2,2,3,3], 2, 2) == False", "assert containsPattern([5,5,5,5,5,5,5], 1, 6) == True", "assert containsPattern([1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2], 2, 5) == True", "assert containsPattern([10,100,10,100,10,100,10,10,10,100], 2, 4) == False", "assert containsPattern([3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3], 4, 3) == True"]}, {"author": "Hafeez", "UUID": "8c9548d2-7b9c-46a4-9b8e-8afd488f7e87", "question": "Find and Replace Pattern: Given a list of strings words and a string pattern, return a list of words[i] that match pattern. You may return the answer in any order.\n\nA word matches the pattern if there exists a permutation of letters p so that after replacing every letter x in the pattern with p(x), we get the desired word.\n\nRecall that a permutation of letters is a bijection from letters to letters: every letter maps to another letter, and no two letters map to the same letter.", "examples": "Input: words = [\"abc\",\"deq\",\"mee\",\"aqq\",\"dkd\",\"ccc\"], pattern = \"abb\"\nOutput: [\"mee\",\"aqq\"]\nExplanation: \"mee\" matches the pattern because there is a permutation {a -> m, b -> e, ...}. \n\"ccc\" does not match the pattern because {a -> c, b -> c, ...} is not a permutation, since a and b map to the same letter.", "link": "https://leetcode.com/problems/find-and-replace-pattern/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def findAndReplacePattern(words: list, pattern: str) -> list:\n        def match(word):\n            m1, m2 = {}, {}\n            for w, p in zip(word, pattern):\n                if w not in m1: m1[w] = p\n                if p not in m2: m2[p] = w\n                if (m1[w], m2[p]) != (p, w):\n                    return False\n            return True\n\n        return list(filter(match, words))\n", "asserts": ["assert findAndReplacePattern([\"a\",\"b\",\"c\"], \"a\")==[\"a\",\"b\",\"c\"]", "assert findAndReplacePattern([\"xx\", \"xy\", \"yy\"], \"xx\") == [\"xx\", \"yy\"]", "assert findAndReplacePattern([\"abc\", \"def\", \"ghi\", \"jkl\"], \"xyz\") == [\"abc\", \"def\", \"ghi\", \"jkl\"]", "assert findAndReplacePattern([\"aaa\", \"bbb\", \"ccc\"], \"xyz\") == []"]}], "category": "Pattern", "prompt_tokens": 923, "total_tokens": 1093, "completion_tokens": 170, "completion": "Identify the Pattern in String: You are given a string s, return the longest prefix which contains only one unique character.\n\n###Code: \n\ndef longestPrefix(s: str) -> str:\n    prefix = \"\"\n    for i in range(len(s)):\n        if s[i] != s[0]:\n            break\n        prefix += s[i]\n    return prefix\n\n###Testcases: \n\nassert longestPrefix(\"aaabbbccc\") == \"aaa\"\nassert longestPrefix(\"abccba\") == \"a\"\nassert longestPrefix(\"abcdefg\") == \"a\"\nassert longestPrefix(\"aaaaaa\") == \"aaaaaa\"\nassert longestPrefix(\"xyyxxyy\") == \"x\"\nassert longestPrefix(\"abababab\") == \"a\"\nassert longestPrefix(\"aaabaaa\") == \"aaa\"\n\n[/Example 3]", "temperature": 0.785}, {"few_shots": [{"author": "Hafeez", "UUID": "e811f9cc-fa5e-4ea0-8adb-8cf3ab7c72db", "question": "Detect Pattern of Length M Repeated K or More Times: Given an array of positive integers arr, find a pattern of length m that is repeated k or more times.\n\nA pattern is a subarray (consecutive sub-sequence) that consists of one or more values, repeated multiple times consecutively without overlapping. A pattern is defined by its length and the number of repetitions.\n\nReturn true if there exists a pattern of length m that is repeated k or more times, otherwise return false.", "examples": "Input: arr = [1,2,1,2,1,1,1,3], m = 2, k = 2\nOutput: true\nExplanation: The pattern (1,2) of length 2 is repeated 2 consecutive times. Another valid pattern (2,1) is also repeated 2 times.\nInput: arr = [1,2,1,2,1,3], m = 2, k = 3\nOutput: false\nExplanation: The pattern (1,2) is of length 2 but is repeated only 2 times. There is no pattern of length 2 that is repeated 3 or more times.\n", "link": "https://leetcode.com/problems/detect-pattern-of-length-m-repeated-k-or-more-times/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "from typing import List\ndef containsPattern(arr: List[int], m: int, k: int) -> bool:\n    i = 0\n    while i <= len(arr)-1:\n            p = arr[i:i+m]\n            if p * k == arr[i:i+m*k]:\n                    return True\n            i += 1\n    return False", "asserts": ["assert containsPattern([1,2,4,4,4,4],1,3)==True", "assert containsPattern([1,2,3,1,2,3,1,2,3], 3, 3) == True", "assert containsPattern([1,1,1,2,2,2,3,3], 2, 2) == False", "assert containsPattern([5,5,5,5,5,5,5], 1, 6) == True", "assert containsPattern([1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2], 2, 5) == True", "assert containsPattern([10,100,10,100,10,100,10,10,10,100], 2, 4) == False", "assert containsPattern([3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3], 4, 3) == True"]}, {"author": "Hafeez", "UUID": "8c9548d2-7b9c-46a4-9b8e-8afd488f7e87", "question": "Find and Replace Pattern: Given a list of strings words and a string pattern, return a list of words[i] that match pattern. You may return the answer in any order.\n\nA word matches the pattern if there exists a permutation of letters p so that after replacing every letter x in the pattern with p(x), we get the desired word.\n\nRecall that a permutation of letters is a bijection from letters to letters: every letter maps to another letter, and no two letters map to the same letter.", "examples": "Input: words = [\"abc\",\"deq\",\"mee\",\"aqq\",\"dkd\",\"ccc\"], pattern = \"abb\"\nOutput: [\"mee\",\"aqq\"]\nExplanation: \"mee\" matches the pattern because there is a permutation {a -> m, b -> e, ...}. \n\"ccc\" does not match the pattern because {a -> c, b -> c, ...} is not a permutation, since a and b map to the same letter.", "link": "https://leetcode.com/problems/find-and-replace-pattern/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def findAndReplacePattern(words: list, pattern: str) -> list:\n        def match(word):\n            m1, m2 = {}, {}\n            for w, p in zip(word, pattern):\n                if w not in m1: m1[w] = p\n                if p not in m2: m2[p] = w\n                if (m1[w], m2[p]) != (p, w):\n                    return False\n            return True\n\n        return list(filter(match, words))\n", "asserts": ["assert findAndReplacePattern([\"a\",\"b\",\"c\"], \"a\")==[\"a\",\"b\",\"c\"]", "assert findAndReplacePattern([\"xx\", \"xy\", \"yy\"], \"xx\") == [\"xx\", \"yy\"]", "assert findAndReplacePattern([\"abc\", \"def\", \"ghi\", \"jkl\"], \"xyz\") == [\"abc\", \"def\", \"ghi\", \"jkl\"]", "assert findAndReplacePattern([\"aaa\", \"bbb\", \"ccc\"], \"xyz\") == []"]}], "category": "Pattern", "prompt_tokens": 923, "total_tokens": 1261, "completion_tokens": 338, "completion": "Find All Anagrams in a String: Given a string s and a non-empty string p, find all the start indices of p's anagrams in s.\n\nStrings consists of lowercase English letters only and the length of both strings s and p will not be larger than 20,100.\n\nThe order of output does not matter.\n\n###Code: \n\ndef findAnagrams(s: str, p: str) -> List[int]:\n        res = []\n        pCounter = collections.Counter(p)\n        sCounter = collections.Counter(s[:len(p)-1])\n        for i in range(len(p)-1,len(s)):\n            sCounter[s[i]] += 1   # include a new char in the window\n            if sCounter == pCounter:    # This step is O(1), since there are at most 26 English letters \n                res.append(i-len(p)+1)   # append the starting index\n            sCounter[s[i-len(p)+1]] -= 1   # decrease the count of oldest char in the window\n            if sCounter[s[i-len(p)+1]] == 0:\n                del sCounter[s[i-len(p)+1]]   # remove the count if it is 0\n        return res\n\n###Testcases: \n\nassert findAnagrams(\"cbaebabacd\", \"abc\") == [0, 6]\nassert findAnagrams(\"abab\", \"ab\") == [0, 1, 2]\nassert findAnagrams(\"aaaaaaaaaa\", \"aa\") == [0, 1, 2, 3, 4, 5, 6, 7]\n\n[/Example 3]", "temperature": 0.839}, {"few_shots": [{"author": "Hafeez", "UUID": "e811f9cc-fa5e-4ea0-8adb-8cf3ab7c72db", "question": "Detect Pattern of Length M Repeated K or More Times: Given an array of positive integers arr, find a pattern of length m that is repeated k or more times.\n\nA pattern is a subarray (consecutive sub-sequence) that consists of one or more values, repeated multiple times consecutively without overlapping. A pattern is defined by its length and the number of repetitions.\n\nReturn true if there exists a pattern of length m that is repeated k or more times, otherwise return false.", "examples": "Input: arr = [1,2,1,2,1,1,1,3], m = 2, k = 2\nOutput: true\nExplanation: The pattern (1,2) of length 2 is repeated 2 consecutive times. Another valid pattern (2,1) is also repeated 2 times.\nInput: arr = [1,2,1,2,1,3], m = 2, k = 3\nOutput: false\nExplanation: The pattern (1,2) is of length 2 but is repeated only 2 times. There is no pattern of length 2 that is repeated 3 or more times.\n", "link": "https://leetcode.com/problems/detect-pattern-of-length-m-repeated-k-or-more-times/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "from typing import List\ndef containsPattern(arr: List[int], m: int, k: int) -> bool:\n    i = 0\n    while i <= len(arr)-1:\n            p = arr[i:i+m]\n            if p * k == arr[i:i+m*k]:\n                    return True\n            i += 1\n    return False", "asserts": ["assert containsPattern([1,2,4,4,4,4],1,3)==True", "assert containsPattern([1,2,3,1,2,3,1,2,3], 3, 3) == True", "assert containsPattern([1,1,1,2,2,2,3,3], 2, 2) == False", "assert containsPattern([5,5,5,5,5,5,5], 1, 6) == True", "assert containsPattern([1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2], 2, 5) == True", "assert containsPattern([10,100,10,100,10,100,10,10,10,100], 2, 4) == False", "assert containsPattern([3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3], 4, 3) == True"]}, {"author": "Hafeez", "UUID": "8c9548d2-7b9c-46a4-9b8e-8afd488f7e87", "question": "Find and Replace Pattern: Given a list of strings words and a string pattern, return a list of words[i] that match pattern. You may return the answer in any order.\n\nA word matches the pattern if there exists a permutation of letters p so that after replacing every letter x in the pattern with p(x), we get the desired word.\n\nRecall that a permutation of letters is a bijection from letters to letters: every letter maps to another letter, and no two letters map to the same letter.", "examples": "Input: words = [\"abc\",\"deq\",\"mee\",\"aqq\",\"dkd\",\"ccc\"], pattern = \"abb\"\nOutput: [\"mee\",\"aqq\"]\nExplanation: \"mee\" matches the pattern because there is a permutation {a -> m, b -> e, ...}. \n\"ccc\" does not match the pattern because {a -> c, b -> c, ...} is not a permutation, since a and b map to the same letter.", "link": "https://leetcode.com/problems/find-and-replace-pattern/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def findAndReplacePattern(words: list, pattern: str) -> list:\n        def match(word):\n            m1, m2 = {}, {}\n            for w, p in zip(word, pattern):\n                if w not in m1: m1[w] = p\n                if p not in m2: m2[p] = w\n                if (m1[w], m2[p]) != (p, w):\n                    return False\n            return True\n\n        return list(filter(match, words))\n", "asserts": ["assert findAndReplacePattern([\"a\",\"b\",\"c\"], \"a\")==[\"a\",\"b\",\"c\"]", "assert findAndReplacePattern([\"xx\", \"xy\", \"yy\"], \"xx\") == [\"xx\", \"yy\"]", "assert findAndReplacePattern([\"abc\", \"def\", \"ghi\", \"jkl\"], \"xyz\") == [\"abc\", \"def\", \"ghi\", \"jkl\"]", "assert findAndReplacePattern([\"aaa\", \"bbb\", \"ccc\"], \"xyz\") == []"]}], "category": "Pattern", "prompt_tokens": 923, "total_tokens": 1195, "completion_tokens": 272, "completion": "Find All Anagrams in a String: Given a string s and a non-empty string p, find all the start indices of p's anagrams in s.\n\nStrings consists of lowercase English letters only.\n\n###Code: \n\ndef findAnagrams(s: str, p: str) -> List[int]:\n    result = []\n    p_count = Counter(p)\n    s_count = Counter(s[:len(p)-1])\n    for i in range(len(p)-1, len(s)):\n        s_count[s[i]] += 1\n        if s_count == p_count:\n            result.append(i-len(p)+1)\n        s_count[s[i-len(p)+1]] -= 1\n        if s_count[s[i-len(p)+1]] == 0:\n            del s_count[s[i-len(p)+1]]\n    return result\n\n###Testcases: \n\nassert findAnagrams(\"cbaebabacd\", \"abc\") == [0, 6]\nassert findAnagrams(\"abab\", \"ab\") == [0, 1, 2]\nassert findAnagrams(\"aaaaaaaaaa\", \"a\") == [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nassert findAnagrams(\"hello\", \"world\") == []\n\n[/Example 3]", "temperature": 0.656}, {"few_shots": [{"author": "Hafeez", "UUID": "e811f9cc-fa5e-4ea0-8adb-8cf3ab7c72db", "question": "Detect Pattern of Length M Repeated K or More Times: Given an array of positive integers arr, find a pattern of length m that is repeated k or more times.\n\nA pattern is a subarray (consecutive sub-sequence) that consists of one or more values, repeated multiple times consecutively without overlapping. A pattern is defined by its length and the number of repetitions.\n\nReturn true if there exists a pattern of length m that is repeated k or more times, otherwise return false.", "examples": "Input: arr = [1,2,1,2,1,1,1,3], m = 2, k = 2\nOutput: true\nExplanation: The pattern (1,2) of length 2 is repeated 2 consecutive times. Another valid pattern (2,1) is also repeated 2 times.\nInput: arr = [1,2,1,2,1,3], m = 2, k = 3\nOutput: false\nExplanation: The pattern (1,2) is of length 2 but is repeated only 2 times. There is no pattern of length 2 that is repeated 3 or more times.\n", "link": "https://leetcode.com/problems/detect-pattern-of-length-m-repeated-k-or-more-times/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "from typing import List\ndef containsPattern(arr: List[int], m: int, k: int) -> bool:\n    i = 0\n    while i <= len(arr)-1:\n            p = arr[i:i+m]\n            if p * k == arr[i:i+m*k]:\n                    return True\n            i += 1\n    return False", "asserts": ["assert containsPattern([1,2,4,4,4,4],1,3)==True", "assert containsPattern([1,2,3,1,2,3,1,2,3], 3, 3) == True", "assert containsPattern([1,1,1,2,2,2,3,3], 2, 2) == False", "assert containsPattern([5,5,5,5,5,5,5], 1, 6) == True", "assert containsPattern([1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2], 2, 5) == True", "assert containsPattern([10,100,10,100,10,100,10,10,10,100], 2, 4) == False", "assert containsPattern([3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3], 4, 3) == True"]}, {"author": "Hafeez", "UUID": "8c9548d2-7b9c-46a4-9b8e-8afd488f7e87", "question": "Find and Replace Pattern: Given a list of strings words and a string pattern, return a list of words[i] that match pattern. You may return the answer in any order.\n\nA word matches the pattern if there exists a permutation of letters p so that after replacing every letter x in the pattern with p(x), we get the desired word.\n\nRecall that a permutation of letters is a bijection from letters to letters: every letter maps to another letter, and no two letters map to the same letter.", "examples": "Input: words = [\"abc\",\"deq\",\"mee\",\"aqq\",\"dkd\",\"ccc\"], pattern = \"abb\"\nOutput: [\"mee\",\"aqq\"]\nExplanation: \"mee\" matches the pattern because there is a permutation {a -> m, b -> e, ...}. \n\"ccc\" does not match the pattern because {a -> c, b -> c, ...} is not a permutation, since a and b map to the same letter.", "link": "https://leetcode.com/problems/find-and-replace-pattern/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def findAndReplacePattern(words: list, pattern: str) -> list:\n        def match(word):\n            m1, m2 = {}, {}\n            for w, p in zip(word, pattern):\n                if w not in m1: m1[w] = p\n                if p not in m2: m2[p] = w\n                if (m1[w], m2[p]) != (p, w):\n                    return False\n            return True\n\n        return list(filter(match, words))\n", "asserts": ["assert findAndReplacePattern([\"a\",\"b\",\"c\"], \"a\")==[\"a\",\"b\",\"c\"]", "assert findAndReplacePattern([\"xx\", \"xy\", \"yy\"], \"xx\") == [\"xx\", \"yy\"]", "assert findAndReplacePattern([\"abc\", \"def\", \"ghi\", \"jkl\"], \"xyz\") == [\"abc\", \"def\", \"ghi\", \"jkl\"]", "assert findAndReplacePattern([\"aaa\", \"bbb\", \"ccc\"], \"xyz\") == []"]}], "category": "Pattern", "prompt_tokens": 923, "total_tokens": 1098, "completion_tokens": 175, "completion": "Generate Pattern: Given an integer n, generate a pattern of length n. The pattern should be such that each number from 1 to n is repeated the same number of times.\n\n###Code: \n\ndef generatePattern(n: int) -> list:\n    pattern = []\n    for i in range(1, n+1):\n        pattern.extend([i]*i)\n    return pattern\n\n###Testcases: \n\nassert generatePattern(1) == [1]\nassert generatePattern(3) == [1, 2, 2, 3, 3, 3]\nassert generatePattern(5) == [1, 2, 2, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 5]\n\n[/Example 3]", "temperature": 0.763}, {"few_shots": [{"author": "Hafeez", "UUID": "e811f9cc-fa5e-4ea0-8adb-8cf3ab7c72db", "question": "Detect Pattern of Length M Repeated K or More Times: Given an array of positive integers arr, find a pattern of length m that is repeated k or more times.\n\nA pattern is a subarray (consecutive sub-sequence) that consists of one or more values, repeated multiple times consecutively without overlapping. A pattern is defined by its length and the number of repetitions.\n\nReturn true if there exists a pattern of length m that is repeated k or more times, otherwise return false.", "examples": "Input: arr = [1,2,1,2,1,1,1,3], m = 2, k = 2\nOutput: true\nExplanation: The pattern (1,2) of length 2 is repeated 2 consecutive times. Another valid pattern (2,1) is also repeated 2 times.\nInput: arr = [1,2,1,2,1,3], m = 2, k = 3\nOutput: false\nExplanation: The pattern (1,2) is of length 2 but is repeated only 2 times. There is no pattern of length 2 that is repeated 3 or more times.\n", "link": "https://leetcode.com/problems/detect-pattern-of-length-m-repeated-k-or-more-times/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "from typing import List\ndef containsPattern(arr: List[int], m: int, k: int) -> bool:\n    i = 0\n    while i <= len(arr)-1:\n            p = arr[i:i+m]\n            if p * k == arr[i:i+m*k]:\n                    return True\n            i += 1\n    return False", "asserts": ["assert containsPattern([1,2,4,4,4,4],1,3)==True", "assert containsPattern([1,2,3,1,2,3,1,2,3], 3, 3) == True", "assert containsPattern([1,1,1,2,2,2,3,3], 2, 2) == False", "assert containsPattern([5,5,5,5,5,5,5], 1, 6) == True", "assert containsPattern([1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2], 2, 5) == True", "assert containsPattern([10,100,10,100,10,100,10,10,10,100], 2, 4) == False", "assert containsPattern([3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3], 4, 3) == True"]}, {"author": "Hafeez", "UUID": "8c9548d2-7b9c-46a4-9b8e-8afd488f7e87", "question": "Find and Replace Pattern: Given a list of strings words and a string pattern, return a list of words[i] that match pattern. You may return the answer in any order.\n\nA word matches the pattern if there exists a permutation of letters p so that after replacing every letter x in the pattern with p(x), we get the desired word.\n\nRecall that a permutation of letters is a bijection from letters to letters: every letter maps to another letter, and no two letters map to the same letter.", "examples": "Input: words = [\"abc\",\"deq\",\"mee\",\"aqq\",\"dkd\",\"ccc\"], pattern = \"abb\"\nOutput: [\"mee\",\"aqq\"]\nExplanation: \"mee\" matches the pattern because there is a permutation {a -> m, b -> e, ...}. \n\"ccc\" does not match the pattern because {a -> c, b -> c, ...} is not a permutation, since a and b map to the same letter.", "link": "https://leetcode.com/problems/find-and-replace-pattern/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def findAndReplacePattern(words: list, pattern: str) -> list:\n        def match(word):\n            m1, m2 = {}, {}\n            for w, p in zip(word, pattern):\n                if w not in m1: m1[w] = p\n                if p not in m2: m2[p] = w\n                if (m1[w], m2[p]) != (p, w):\n                    return False\n            return True\n\n        return list(filter(match, words))\n", "asserts": ["assert findAndReplacePattern([\"a\",\"b\",\"c\"], \"a\")==[\"a\",\"b\",\"c\"]", "assert findAndReplacePattern([\"xx\", \"xy\", \"yy\"], \"xx\") == [\"xx\", \"yy\"]", "assert findAndReplacePattern([\"abc\", \"def\", \"ghi\", \"jkl\"], \"xyz\") == [\"abc\", \"def\", \"ghi\", \"jkl\"]", "assert findAndReplacePattern([\"aaa\", \"bbb\", \"ccc\"], \"xyz\") == []"]}], "category": "Pattern", "prompt_tokens": 923, "total_tokens": 1238, "completion_tokens": 315, "completion": "Find All Anagrams in a String: Given a string s and a non-empty string p, find all the start indices of p's anagrams in s.\n\nStrings consists of lowercase English letters only.\n\n###Code: \n\ndef findAnagrams(s: str, p: str) -> List[int]:\n        result = []\n        p_count = collections.Counter(p)\n        s_count = collections.Counter(s[:len(p)-1])\n        for i in range(len(p)-1,len(s)):\n            s_count[s[i]] += 1   # include a new char in the window\n            if s_count == p_count:    # This is where we can make a comparison between s_count and p_count\n                result.append(i-len(p)+1)   # append the starting index\n            s_count[s[i-len(p)+1]] -= 1   # decrease the count of the character going out of the window\n            if s_count[s[i-len(p)+1]] == 0:\n                del s_count[s[i-len(p)+1]]   # remove the count if it is 0\n        return result\n\n\n###Testcases: \n\nassert findAnagrams(\"cbaebabacd\", \"abc\") == [0, 6]\nassert findAnagrams(\"abab\", \"ab\") == [0, 1, 2]\nassert findAnagrams(\"aaaaa\", \"a\") == [0, 1, 2, 3, 4]\nassert findAnagrams(\"hello\", \"wow\") == []\n\n[/Example 3]", "temperature": 0.819}, {"few_shots": [{"author": "Hafeez", "UUID": "e811f9cc-fa5e-4ea0-8adb-8cf3ab7c72db", "question": "Detect Pattern of Length M Repeated K or More Times: Given an array of positive integers arr, find a pattern of length m that is repeated k or more times.\n\nA pattern is a subarray (consecutive sub-sequence) that consists of one or more values, repeated multiple times consecutively without overlapping. A pattern is defined by its length and the number of repetitions.\n\nReturn true if there exists a pattern of length m that is repeated k or more times, otherwise return false.", "examples": "Input: arr = [1,2,1,2,1,1,1,3], m = 2, k = 2\nOutput: true\nExplanation: The pattern (1,2) of length 2 is repeated 2 consecutive times. Another valid pattern (2,1) is also repeated 2 times.\nInput: arr = [1,2,1,2,1,3], m = 2, k = 3\nOutput: false\nExplanation: The pattern (1,2) is of length 2 but is repeated only 2 times. There is no pattern of length 2 that is repeated 3 or more times.\n", "link": "https://leetcode.com/problems/detect-pattern-of-length-m-repeated-k-or-more-times/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "from typing import List\ndef containsPattern(arr: List[int], m: int, k: int) -> bool:\n    i = 0\n    while i <= len(arr)-1:\n            p = arr[i:i+m]\n            if p * k == arr[i:i+m*k]:\n                    return True\n            i += 1\n    return False", "asserts": ["assert containsPattern([1,2,4,4,4,4],1,3)==True", "assert containsPattern([1,2,3,1,2,3,1,2,3], 3, 3) == True", "assert containsPattern([1,1,1,2,2,2,3,3], 2, 2) == False", "assert containsPattern([5,5,5,5,5,5,5], 1, 6) == True", "assert containsPattern([1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2], 2, 5) == True", "assert containsPattern([10,100,10,100,10,100,10,10,10,100], 2, 4) == False", "assert containsPattern([3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3], 4, 3) == True"]}, {"author": "Hafeez", "UUID": "8c9548d2-7b9c-46a4-9b8e-8afd488f7e87", "question": "Find and Replace Pattern: Given a list of strings words and a string pattern, return a list of words[i] that match pattern. You may return the answer in any order.\n\nA word matches the pattern if there exists a permutation of letters p so that after replacing every letter x in the pattern with p(x), we get the desired word.\n\nRecall that a permutation of letters is a bijection from letters to letters: every letter maps to another letter, and no two letters map to the same letter.", "examples": "Input: words = [\"abc\",\"deq\",\"mee\",\"aqq\",\"dkd\",\"ccc\"], pattern = \"abb\"\nOutput: [\"mee\",\"aqq\"]\nExplanation: \"mee\" matches the pattern because there is a permutation {a -> m, b -> e, ...}. \n\"ccc\" does not match the pattern because {a -> c, b -> c, ...} is not a permutation, since a and b map to the same letter.", "link": "https://leetcode.com/problems/find-and-replace-pattern/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def findAndReplacePattern(words: list, pattern: str) -> list:\n        def match(word):\n            m1, m2 = {}, {}\n            for w, p in zip(word, pattern):\n                if w not in m1: m1[w] = p\n                if p not in m2: m2[p] = w\n                if (m1[w], m2[p]) != (p, w):\n                    return False\n            return True\n\n        return list(filter(match, words))\n", "asserts": ["assert findAndReplacePattern([\"a\",\"b\",\"c\"], \"a\")==[\"a\",\"b\",\"c\"]", "assert findAndReplacePattern([\"xx\", \"xy\", \"yy\"], \"xx\") == [\"xx\", \"yy\"]", "assert findAndReplacePattern([\"abc\", \"def\", \"ghi\", \"jkl\"], \"xyz\") == [\"abc\", \"def\", \"ghi\", \"jkl\"]", "assert findAndReplacePattern([\"aaa\", \"bbb\", \"ccc\"], \"xyz\") == []"]}], "category": "Pattern", "prompt_tokens": 923, "total_tokens": 1263, "completion_tokens": 340, "completion": "Find All Anagrams in a String: Given a string s and a non-empty string p, find all the start indices of p's anagrams in s.\n\nStrings consists of lowercase English letters only and the length of both strings s and p will not be larger than 20,100.\n\nThe order of output does not matter.\n\n###Code: \n\ndef findAnagrams(s: str, p: str) -> list:\n    result = []\n    p_count = {}\n    s_count = {}\n    for char in p:\n        if char in p_count:\n            p_count[char] += 1\n        else:\n            p_count[char] = 1\n\n    for i in range(len(s)):\n        if s[i] in s_count:\n            s_count[s[i]] += 1\n        else:\n            s_count[s[i]] = 1\n        if i >= len(p):\n            if s_count[s[i - len(p)]] == 1:\n                del s_count[s[i - len(p)]]\n            else:\n                s_count[s[i - len(p)]] -= 1\n        if s_count == p_count:\n            result.append(i - len(p) + 1)\n    return result\n\n\n###Testcases: \n\nassert findAnagrams(\"cbaebabacd\", \"abc\") == [0, 6]\nassert findAnagrams(\"abab\", \"ab\") == [0, 1, 2]\nassert findAnagrams(\"aaaaaaaaaa\", \"a\") == [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n[/Example 3]", "temperature": 0.855}, {"few_shots": [{"author": "Hafeez", "UUID": "e811f9cc-fa5e-4ea0-8adb-8cf3ab7c72db", "question": "Detect Pattern of Length M Repeated K or More Times: Given an array of positive integers arr, find a pattern of length m that is repeated k or more times.\n\nA pattern is a subarray (consecutive sub-sequence) that consists of one or more values, repeated multiple times consecutively without overlapping. A pattern is defined by its length and the number of repetitions.\n\nReturn true if there exists a pattern of length m that is repeated k or more times, otherwise return false.", "examples": "Input: arr = [1,2,1,2,1,1,1,3], m = 2, k = 2\nOutput: true\nExplanation: The pattern (1,2) of length 2 is repeated 2 consecutive times. Another valid pattern (2,1) is also repeated 2 times.\nInput: arr = [1,2,1,2,1,3], m = 2, k = 3\nOutput: false\nExplanation: The pattern (1,2) is of length 2 but is repeated only 2 times. There is no pattern of length 2 that is repeated 3 or more times.\n", "link": "https://leetcode.com/problems/detect-pattern-of-length-m-repeated-k-or-more-times/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "from typing import List\ndef containsPattern(arr: List[int], m: int, k: int) -> bool:\n    i = 0\n    while i <= len(arr)-1:\n            p = arr[i:i+m]\n            if p * k == arr[i:i+m*k]:\n                    return True\n            i += 1\n    return False", "asserts": ["assert containsPattern([1,2,4,4,4,4],1,3)==True", "assert containsPattern([1,2,3,1,2,3,1,2,3], 3, 3) == True", "assert containsPattern([1,1,1,2,2,2,3,3], 2, 2) == False", "assert containsPattern([5,5,5,5,5,5,5], 1, 6) == True", "assert containsPattern([1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2], 2, 5) == True", "assert containsPattern([10,100,10,100,10,100,10,10,10,100], 2, 4) == False", "assert containsPattern([3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3], 4, 3) == True"]}, {"author": "Hafeez", "UUID": "8c9548d2-7b9c-46a4-9b8e-8afd488f7e87", "question": "Find and Replace Pattern: Given a list of strings words and a string pattern, return a list of words[i] that match pattern. You may return the answer in any order.\n\nA word matches the pattern if there exists a permutation of letters p so that after replacing every letter x in the pattern with p(x), we get the desired word.\n\nRecall that a permutation of letters is a bijection from letters to letters: every letter maps to another letter, and no two letters map to the same letter.", "examples": "Input: words = [\"abc\",\"deq\",\"mee\",\"aqq\",\"dkd\",\"ccc\"], pattern = \"abb\"\nOutput: [\"mee\",\"aqq\"]\nExplanation: \"mee\" matches the pattern because there is a permutation {a -> m, b -> e, ...}. \n\"ccc\" does not match the pattern because {a -> c, b -> c, ...} is not a permutation, since a and b map to the same letter.", "link": "https://leetcode.com/problems/find-and-replace-pattern/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def findAndReplacePattern(words: list, pattern: str) -> list:\n        def match(word):\n            m1, m2 = {}, {}\n            for w, p in zip(word, pattern):\n                if w not in m1: m1[w] = p\n                if p not in m2: m2[p] = w\n                if (m1[w], m2[p]) != (p, w):\n                    return False\n            return True\n\n        return list(filter(match, words))\n", "asserts": ["assert findAndReplacePattern([\"a\",\"b\",\"c\"], \"a\")==[\"a\",\"b\",\"c\"]", "assert findAndReplacePattern([\"xx\", \"xy\", \"yy\"], \"xx\") == [\"xx\", \"yy\"]", "assert findAndReplacePattern([\"abc\", \"def\", \"ghi\", \"jkl\"], \"xyz\") == [\"abc\", \"def\", \"ghi\", \"jkl\"]", "assert findAndReplacePattern([\"aaa\", \"bbb\", \"ccc\"], \"xyz\") == []"]}], "category": "Pattern", "prompt_tokens": 923, "total_tokens": 1164, "completion_tokens": 241, "completion": "Find All Anagrams in a String: Given a string s and a non-empty string p, find all the start indices of p's anagrams in s.\n\nStrings consists of lowercase English letters only.\n\n###Code: \n\ndef findAnagrams(s: str, p: str) -> List[int]:\n    result = []\n    p_count = Counter(p)\n    s_count = Counter(s[:len(p)-1])\n    for i in range(len(p)-1, len(s)):\n        s_count[s[i]] += 1\n        if s_count == p_count:\n            result.append(i-len(p)+1)\n        s_count[s[i-len(p)+1]] -= 1\n        if s_count[s[i-len(p)+1]] == 0:\n            del s_count[s[i-len(p)+1]]\n    return result\n\n###Testcases: \n\nassert findAnagrams(\"cbaebabacd\", \"abc\")==[0, 6]\nassert findAnagrams(\"abab\", \"ab\")==[0, 1, 2]\nassert findAnagrams(\"acdcaeccde\", \"c\")==[2, 3, 4, 6]\n\n[/Example 3]", "temperature": 0.65}, {"few_shots": [{"author": "Hafeez", "UUID": "e811f9cc-fa5e-4ea0-8adb-8cf3ab7c72db", "question": "Detect Pattern of Length M Repeated K or More Times: Given an array of positive integers arr, find a pattern of length m that is repeated k or more times.\n\nA pattern is a subarray (consecutive sub-sequence) that consists of one or more values, repeated multiple times consecutively without overlapping. A pattern is defined by its length and the number of repetitions.\n\nReturn true if there exists a pattern of length m that is repeated k or more times, otherwise return false.", "examples": "Input: arr = [1,2,1,2,1,1,1,3], m = 2, k = 2\nOutput: true\nExplanation: The pattern (1,2) of length 2 is repeated 2 consecutive times. Another valid pattern (2,1) is also repeated 2 times.\nInput: arr = [1,2,1,2,1,3], m = 2, k = 3\nOutput: false\nExplanation: The pattern (1,2) is of length 2 but is repeated only 2 times. There is no pattern of length 2 that is repeated 3 or more times.\n", "link": "https://leetcode.com/problems/detect-pattern-of-length-m-repeated-k-or-more-times/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "from typing import List\ndef containsPattern(arr: List[int], m: int, k: int) -> bool:\n    i = 0\n    while i <= len(arr)-1:\n            p = arr[i:i+m]\n            if p * k == arr[i:i+m*k]:\n                    return True\n            i += 1\n    return False", "asserts": ["assert containsPattern([1,2,4,4,4,4],1,3)==True", "assert containsPattern([1,2,3,1,2,3,1,2,3], 3, 3) == True", "assert containsPattern([1,1,1,2,2,2,3,3], 2, 2) == False", "assert containsPattern([5,5,5,5,5,5,5], 1, 6) == True", "assert containsPattern([1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2], 2, 5) == True", "assert containsPattern([10,100,10,100,10,100,10,10,10,100], 2, 4) == False", "assert containsPattern([3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3], 4, 3) == True"]}, {"author": "Hafeez", "UUID": "8c9548d2-7b9c-46a4-9b8e-8afd488f7e87", "question": "Find and Replace Pattern: Given a list of strings words and a string pattern, return a list of words[i] that match pattern. You may return the answer in any order.\n\nA word matches the pattern if there exists a permutation of letters p so that after replacing every letter x in the pattern with p(x), we get the desired word.\n\nRecall that a permutation of letters is a bijection from letters to letters: every letter maps to another letter, and no two letters map to the same letter.", "examples": "Input: words = [\"abc\",\"deq\",\"mee\",\"aqq\",\"dkd\",\"ccc\"], pattern = \"abb\"\nOutput: [\"mee\",\"aqq\"]\nExplanation: \"mee\" matches the pattern because there is a permutation {a -> m, b -> e, ...}. \n\"ccc\" does not match the pattern because {a -> c, b -> c, ...} is not a permutation, since a and b map to the same letter.", "link": "https://leetcode.com/problems/find-and-replace-pattern/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def findAndReplacePattern(words: list, pattern: str) -> list:\n        def match(word):\n            m1, m2 = {}, {}\n            for w, p in zip(word, pattern):\n                if w not in m1: m1[w] = p\n                if p not in m2: m2[p] = w\n                if (m1[w], m2[p]) != (p, w):\n                    return False\n            return True\n\n        return list(filter(match, words))\n", "asserts": ["assert findAndReplacePattern([\"a\",\"b\",\"c\"], \"a\")==[\"a\",\"b\",\"c\"]", "assert findAndReplacePattern([\"xx\", \"xy\", \"yy\"], \"xx\") == [\"xx\", \"yy\"]", "assert findAndReplacePattern([\"abc\", \"def\", \"ghi\", \"jkl\"], \"xyz\") == [\"abc\", \"def\", \"ghi\", \"jkl\"]", "assert findAndReplacePattern([\"aaa\", \"bbb\", \"ccc\"], \"xyz\") == []"]}], "category": "Pattern", "prompt_tokens": 923, "total_tokens": 1101, "completion_tokens": 178, "completion": "Generate Parentheses: Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.\n\n###Code: \n\ndef generateParenthesis(n: int) -> List[str]:\n    def backtrack(s='', left=0, right=0):\n        if len(s) == 2 * n:\n            res.append(s)\n            return\n        if left < n:\n            backtrack(s + '(', left + 1, right)\n        if right < left:\n            backtrack(s + ')', left, right + 1)\n\n    res = []\n    backtrack()\n    return res\n\n###Testcases: \n\nassert generateParenthesis(3)==[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]\nassert generateParenthesis(1)==[\"()\"]\nassert generateParenthesis(2)==[\"(())\",\"()()\"]\n\n[/Example 3]", "temperature": 0.904}, {"few_shots": [{"author": "Hafeez", "UUID": "e811f9cc-fa5e-4ea0-8adb-8cf3ab7c72db", "question": "Detect Pattern of Length M Repeated K or More Times: Given an array of positive integers arr, find a pattern of length m that is repeated k or more times.\n\nA pattern is a subarray (consecutive sub-sequence) that consists of one or more values, repeated multiple times consecutively without overlapping. A pattern is defined by its length and the number of repetitions.\n\nReturn true if there exists a pattern of length m that is repeated k or more times, otherwise return false.", "examples": "Input: arr = [1,2,1,2,1,1,1,3], m = 2, k = 2\nOutput: true\nExplanation: The pattern (1,2) of length 2 is repeated 2 consecutive times. Another valid pattern (2,1) is also repeated 2 times.\nInput: arr = [1,2,1,2,1,3], m = 2, k = 3\nOutput: false\nExplanation: The pattern (1,2) is of length 2 but is repeated only 2 times. There is no pattern of length 2 that is repeated 3 or more times.\n", "link": "https://leetcode.com/problems/detect-pattern-of-length-m-repeated-k-or-more-times/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "from typing import List\ndef containsPattern(arr: List[int], m: int, k: int) -> bool:\n    i = 0\n    while i <= len(arr)-1:\n            p = arr[i:i+m]\n            if p * k == arr[i:i+m*k]:\n                    return True\n            i += 1\n    return False", "asserts": ["assert containsPattern([1,2,4,4,4,4],1,3)==True", "assert containsPattern([1,2,3,1,2,3,1,2,3], 3, 3) == True", "assert containsPattern([1,1,1,2,2,2,3,3], 2, 2) == False", "assert containsPattern([5,5,5,5,5,5,5], 1, 6) == True", "assert containsPattern([1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2], 2, 5) == True", "assert containsPattern([10,100,10,100,10,100,10,10,10,100], 2, 4) == False", "assert containsPattern([3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3], 4, 3) == True"]}, {"author": "Hafeez", "UUID": "124bfeca-24d0-411d-b4ad-26009b79436b", "question": "Word Pattern II: Given a pattern and a string s, return true if s matches the pattern.\n\nA string s matches a pattern if there is some bijective mapping of single characters to non-empty strings such that if each character in pattern is replaced by the string it maps to, then the resulting string is s. A bijective mapping means that no two characters map to the same string, and no character maps to two different strings.", "examples": "Input: pattern = \"abab\", s = \"redblueredblue\"\nOutput: true\nExplanation: One possible mapping is as follows:\n'a' -> \"red\"\n'b' -> \"blue\"\nInput: pattern = \"aabb\", s = \"xyzabcxzyabc\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern-ii/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def wordPatternMatch(pattern: str, s: str) -> bool:\n    def backtrack(cur: str, pattern: str, mappings: dict):\n        if not pattern:\n            return not cur\n        if pattern[0] in mappings:\n            if cur[:len(mappings[pattern[0]])] != mappings[pattern[0]]:\n                return False\n            return backtrack(cur[len(mappings[pattern[0]]):], pattern[1:], mappings)\n        for i in range(len(cur)):\n            if cur[:i+1] in mappings.values():\n                continue\n            mappings[pattern[0]] = cur[:i+1]\n            if backtrack(cur[i+1:], pattern[1:], mappings):\n                return True\n            del mappings[pattern[0]]\n        return False\n    return backtrack(s, pattern, {})", "asserts": ["assert wordPatternMatch(\"aaaa\", \"asdasdasdasd\")==True", "assert wordPatternMatch(\"abba\", \"dogcatcatdog\") == True", "assert wordPatternMatch(\"ab\", \"aa\") == False # since 'a' and 'b' cannot map to the same string \"a\"", "assert wordPatternMatch(\"xyz\", \"abcdefghi\") == True # 'x' -> \"a\", 'y' -> \"bc\", 'z' -> \"defghi\"", "assert wordPatternMatch(\"aba\", \"eggegg\") == False # 'a' maps to \"egg\", but 'b' cannot be mapped uniquely", "assert wordPatternMatch(\"zzz\", \"aaa\") == True # all 'z' map to \"a\"", "assert wordPatternMatch(\"aba\", \"catdogcat\") == True # 'a' -> \"cat\", 'b' -> \"dog\"", "assert wordPatternMatch(\"abab\", \"xyzxyzabcabc\") == False # cannot match 'a' and 'b' with two different strings each consistent with the pattern", "assert wordPatternMatch(\"abac\", \"xyzxyzxya\") == True # 'a' -> \"xyz\", 'b' -> \"xyz\", 'c' -> \"a\"", "assert wordPatternMatch(\"abcd\", \"xyzy\") == False # pattern too long for the string", "assert wordPatternMatch(\"aaaaa\", \"oneonetwo\") == False # not enough unique strings to map 'a' five times"]}], "category": "Pattern", "prompt_tokens": 1179, "total_tokens": 1528, "completion_tokens": 349, "completion": "Find All Anagrams in a String: Given a string s and a non-empty string p, find all the start indices of p's anagrams in s.\n\nStrings consists of lowercase English letters only.\n\n###Code: \n\nfrom collections import Counter\ndef findAnagrams(s: str, p: str):\n    res = []\n    p_count = Counter(p)\n    s_count = Counter(s[:len(p)-1])\n    for i in range(len(p)-1, len(s)):\n        s_count[s[i]] += 1   # Include a new character in the window\n        if s_count == p_count:   # This step is O(1), since there are at most 26 English letters \n            res.append(i-len(p)+1)   # Append the starting index\n        s_count[s[i-len(p)+1]] -= 1   # Decrease the count of the old character\n        if s_count[s[i-len(p)+1]] == 0:\n            del s_count[s[i-len(p)+1]]   # Remove the count if it is 0\n    return res\n\n###Testcases: \n\nassert findAnagrams(\"cbaebabacd\", \"abc\") == [0, 6]\nassert findAnagrams(\"abab\", \"ab\") == [0, 1, 2]\nassert findAnagrams(\"aaaaaaaaaa\", \"a\") == [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nassert findAnagrams(\"abracadabra\", \"abr\") == [0, 7]\nassert findAnagrams(\"hello\", \"world\") == []\n\n[/Example 3]", "temperature": 0.79}, {"few_shots": [{"author": "Hafeez", "UUID": "e811f9cc-fa5e-4ea0-8adb-8cf3ab7c72db", "question": "Detect Pattern of Length M Repeated K or More Times: Given an array of positive integers arr, find a pattern of length m that is repeated k or more times.\n\nA pattern is a subarray (consecutive sub-sequence) that consists of one or more values, repeated multiple times consecutively without overlapping. A pattern is defined by its length and the number of repetitions.\n\nReturn true if there exists a pattern of length m that is repeated k or more times, otherwise return false.", "examples": "Input: arr = [1,2,1,2,1,1,1,3], m = 2, k = 2\nOutput: true\nExplanation: The pattern (1,2) of length 2 is repeated 2 consecutive times. Another valid pattern (2,1) is also repeated 2 times.\nInput: arr = [1,2,1,2,1,3], m = 2, k = 3\nOutput: false\nExplanation: The pattern (1,2) is of length 2 but is repeated only 2 times. There is no pattern of length 2 that is repeated 3 or more times.\n", "link": "https://leetcode.com/problems/detect-pattern-of-length-m-repeated-k-or-more-times/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "from typing import List\ndef containsPattern(arr: List[int], m: int, k: int) -> bool:\n    i = 0\n    while i <= len(arr)-1:\n            p = arr[i:i+m]\n            if p * k == arr[i:i+m*k]:\n                    return True\n            i += 1\n    return False", "asserts": ["assert containsPattern([1,2,4,4,4,4],1,3)==True", "assert containsPattern([1,2,3,1,2,3,1,2,3], 3, 3) == True", "assert containsPattern([1,1,1,2,2,2,3,3], 2, 2) == False", "assert containsPattern([5,5,5,5,5,5,5], 1, 6) == True", "assert containsPattern([1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2], 2, 5) == True", "assert containsPattern([10,100,10,100,10,100,10,10,10,100], 2, 4) == False", "assert containsPattern([3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3], 4, 3) == True"]}, {"author": "Hafeez", "UUID": "124bfeca-24d0-411d-b4ad-26009b79436b", "question": "Word Pattern II: Given a pattern and a string s, return true if s matches the pattern.\n\nA string s matches a pattern if there is some bijective mapping of single characters to non-empty strings such that if each character in pattern is replaced by the string it maps to, then the resulting string is s. A bijective mapping means that no two characters map to the same string, and no character maps to two different strings.", "examples": "Input: pattern = \"abab\", s = \"redblueredblue\"\nOutput: true\nExplanation: One possible mapping is as follows:\n'a' -> \"red\"\n'b' -> \"blue\"\nInput: pattern = \"aabb\", s = \"xyzabcxzyabc\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern-ii/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def wordPatternMatch(pattern: str, s: str) -> bool:\n    def backtrack(cur: str, pattern: str, mappings: dict):\n        if not pattern:\n            return not cur\n        if pattern[0] in mappings:\n            if cur[:len(mappings[pattern[0]])] != mappings[pattern[0]]:\n                return False\n            return backtrack(cur[len(mappings[pattern[0]]):], pattern[1:], mappings)\n        for i in range(len(cur)):\n            if cur[:i+1] in mappings.values():\n                continue\n            mappings[pattern[0]] = cur[:i+1]\n            if backtrack(cur[i+1:], pattern[1:], mappings):\n                return True\n            del mappings[pattern[0]]\n        return False\n    return backtrack(s, pattern, {})", "asserts": ["assert wordPatternMatch(\"aaaa\", \"asdasdasdasd\")==True", "assert wordPatternMatch(\"abba\", \"dogcatcatdog\") == True", "assert wordPatternMatch(\"ab\", \"aa\") == False # since 'a' and 'b' cannot map to the same string \"a\"", "assert wordPatternMatch(\"xyz\", \"abcdefghi\") == True # 'x' -> \"a\", 'y' -> \"bc\", 'z' -> \"defghi\"", "assert wordPatternMatch(\"aba\", \"eggegg\") == False # 'a' maps to \"egg\", but 'b' cannot be mapped uniquely", "assert wordPatternMatch(\"zzz\", \"aaa\") == True # all 'z' map to \"a\"", "assert wordPatternMatch(\"aba\", \"catdogcat\") == True # 'a' -> \"cat\", 'b' -> \"dog\"", "assert wordPatternMatch(\"abab\", \"xyzxyzabcabc\") == False # cannot match 'a' and 'b' with two different strings each consistent with the pattern", "assert wordPatternMatch(\"abac\", \"xyzxyzxya\") == True # 'a' -> \"xyz\", 'b' -> \"xyz\", 'c' -> \"a\"", "assert wordPatternMatch(\"abcd\", \"xyzy\") == False # pattern too long for the string", "assert wordPatternMatch(\"aaaaa\", \"oneonetwo\") == False # not enough unique strings to map 'a' five times"]}], "category": "Pattern", "prompt_tokens": 1179, "total_tokens": 1497, "completion_tokens": 318, "completion": "Find All Anagrams in a String: Given a string s and a non-empty string p, find all the start indices of p's anagrams in s. Strings consists of lowercase English letters only.\n\nAn anagram of a string is a string that contains the same characters with equal frequencies, only the order of characters can be different.\n\n###Code: \n\nfrom collections import Counter\ndef findAnagrams(s: str, p: str):\n    result = []\n    p_count = Counter(p)\n    s_count = Counter(s[:len(p)-1])\n    for i in range(len(p)-1, len(s)):\n        s_count[s[i]] += 1\n        if s_count == p_count:\n            result.append(i-len(p)+1)\n        s_count[s[i-len(p)+1]] -= 1\n        if s_count[s[i-len(p)+1]] == 0:\n            del s_count[s[i-len(p)+1]]\n    return result\n\n###Testcases: \n\nassert findAnagrams(\"cbaebabacd\", \"abc\")==[0, 6]\nassert findAnagrams(\"abab\", \"ab\")==[0, 1, 2]\nassert findAnagrams(\"aaaaaaaaaa\", \"a\")==[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nassert findAnagrams(\"abcd\", \"xyz\")==[]\nassert findAnagrams(\"aabbcbab\", \"ab\")==[1, 2, 5]\n\n[/Example 3]", "temperature": 0.995}, {"few_shots": [{"author": "Hafeez", "UUID": "e811f9cc-fa5e-4ea0-8adb-8cf3ab7c72db", "question": "Detect Pattern of Length M Repeated K or More Times: Given an array of positive integers arr, find a pattern of length m that is repeated k or more times.\n\nA pattern is a subarray (consecutive sub-sequence) that consists of one or more values, repeated multiple times consecutively without overlapping. A pattern is defined by its length and the number of repetitions.\n\nReturn true if there exists a pattern of length m that is repeated k or more times, otherwise return false.", "examples": "Input: arr = [1,2,1,2,1,1,1,3], m = 2, k = 2\nOutput: true\nExplanation: The pattern (1,2) of length 2 is repeated 2 consecutive times. Another valid pattern (2,1) is also repeated 2 times.\nInput: arr = [1,2,1,2,1,3], m = 2, k = 3\nOutput: false\nExplanation: The pattern (1,2) is of length 2 but is repeated only 2 times. There is no pattern of length 2 that is repeated 3 or more times.\n", "link": "https://leetcode.com/problems/detect-pattern-of-length-m-repeated-k-or-more-times/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "from typing import List\ndef containsPattern(arr: List[int], m: int, k: int) -> bool:\n    i = 0\n    while i <= len(arr)-1:\n            p = arr[i:i+m]\n            if p * k == arr[i:i+m*k]:\n                    return True\n            i += 1\n    return False", "asserts": ["assert containsPattern([1,2,4,4,4,4],1,3)==True", "assert containsPattern([1,2,3,1,2,3,1,2,3], 3, 3) == True", "assert containsPattern([1,1,1,2,2,2,3,3], 2, 2) == False", "assert containsPattern([5,5,5,5,5,5,5], 1, 6) == True", "assert containsPattern([1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2], 2, 5) == True", "assert containsPattern([10,100,10,100,10,100,10,10,10,100], 2, 4) == False", "assert containsPattern([3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3], 4, 3) == True"]}, {"author": "Hafeez", "UUID": "124bfeca-24d0-411d-b4ad-26009b79436b", "question": "Word Pattern II: Given a pattern and a string s, return true if s matches the pattern.\n\nA string s matches a pattern if there is some bijective mapping of single characters to non-empty strings such that if each character in pattern is replaced by the string it maps to, then the resulting string is s. A bijective mapping means that no two characters map to the same string, and no character maps to two different strings.", "examples": "Input: pattern = \"abab\", s = \"redblueredblue\"\nOutput: true\nExplanation: One possible mapping is as follows:\n'a' -> \"red\"\n'b' -> \"blue\"\nInput: pattern = \"aabb\", s = \"xyzabcxzyabc\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern-ii/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def wordPatternMatch(pattern: str, s: str) -> bool:\n    def backtrack(cur: str, pattern: str, mappings: dict):\n        if not pattern:\n            return not cur\n        if pattern[0] in mappings:\n            if cur[:len(mappings[pattern[0]])] != mappings[pattern[0]]:\n                return False\n            return backtrack(cur[len(mappings[pattern[0]]):], pattern[1:], mappings)\n        for i in range(len(cur)):\n            if cur[:i+1] in mappings.values():\n                continue\n            mappings[pattern[0]] = cur[:i+1]\n            if backtrack(cur[i+1:], pattern[1:], mappings):\n                return True\n            del mappings[pattern[0]]\n        return False\n    return backtrack(s, pattern, {})", "asserts": ["assert wordPatternMatch(\"aaaa\", \"asdasdasdasd\")==True", "assert wordPatternMatch(\"abba\", \"dogcatcatdog\") == True", "assert wordPatternMatch(\"ab\", \"aa\") == False # since 'a' and 'b' cannot map to the same string \"a\"", "assert wordPatternMatch(\"xyz\", \"abcdefghi\") == True # 'x' -> \"a\", 'y' -> \"bc\", 'z' -> \"defghi\"", "assert wordPatternMatch(\"aba\", \"eggegg\") == False # 'a' maps to \"egg\", but 'b' cannot be mapped uniquely", "assert wordPatternMatch(\"zzz\", \"aaa\") == True # all 'z' map to \"a\"", "assert wordPatternMatch(\"aba\", \"catdogcat\") == True # 'a' -> \"cat\", 'b' -> \"dog\"", "assert wordPatternMatch(\"abab\", \"xyzxyzabcabc\") == False # cannot match 'a' and 'b' with two different strings each consistent with the pattern", "assert wordPatternMatch(\"abac\", \"xyzxyzxya\") == True # 'a' -> \"xyz\", 'b' -> \"xyz\", 'c' -> \"a\"", "assert wordPatternMatch(\"abcd\", \"xyzy\") == False # pattern too long for the string", "assert wordPatternMatch(\"aaaaa\", \"oneonetwo\") == False # not enough unique strings to map 'a' five times"]}], "category": "Pattern", "prompt_tokens": 1179, "total_tokens": 1581, "completion_tokens": 402, "completion": "Find and Replace Pattern: You are given a list of strings words and a string pattern. You need to find all the strings in words that follow the same pattern as the given pattern and return them in a list.\n\nA word follows the given pattern if there exists a bijection between a letter in pattern and a non-empty substring in the word such that every occurrence of the letter in the pattern is mapped to the same substring in the word.\n\n###Code: \n\ndef findAndReplacePattern(words: List[str], pattern: str) -> List[str]:\n    def match(word, pattern):\n        if len(word) != len(pattern):\n            return False\n        map_word, map_pattern = {}, {}\n        for w, p in zip(word, pattern):\n            if w not in map_word:\n                map_word[w] = p\n            if p not in map_pattern:\n                map_pattern[p] = w\n            if (map_word[w], map_pattern[p]) != (p, w):\n                return False\n        return True\n    return [word for word in words if match(word, pattern)]\n\n###Testcases: \n\nassert findAndReplacePattern([\"abc\",\"deq\",\"mee\",\"aqq\",\"dkd\",\"ccc\"], \"abb\")==[\"mee\",\"aqq\"]\nassert findAndReplacePattern([\"a\", \"b\", \"c\"], \"a\")==[\"a\"]\nassert findAndReplacePattern([\"goo\",\"dad\",\"add\",\"fed\"], \"abb\")==[\"dad\",\"add\"]\nassert findAndReplacePattern([\"badc\",\"dabc\",\"adbc\",\"eabc\",\"fabc\"], \"aabb\")==[\"dabc\",\"adbc\",\"eabc\",\"fabc\"]\nassert findAndReplacePattern([\"ef\", \"ff\"], \"ab\")==[]\nassert findAndReplacePattern([\"ef\", \"fg\"], \"ab\")==[]\nassert findAndReplacePattern([\"ab\", \"aa\", \"bb\"], \"xy\")==[]\nassert findAndReplacePattern([], \"xy\")==[]\n\n[/Example 3]", "temperature": 0.939}, {"few_shots": [{"author": "Hafeez", "UUID": "e811f9cc-fa5e-4ea0-8adb-8cf3ab7c72db", "question": "Detect Pattern of Length M Repeated K or More Times: Given an array of positive integers arr, find a pattern of length m that is repeated k or more times.\n\nA pattern is a subarray (consecutive sub-sequence) that consists of one or more values, repeated multiple times consecutively without overlapping. A pattern is defined by its length and the number of repetitions.\n\nReturn true if there exists a pattern of length m that is repeated k or more times, otherwise return false.", "examples": "Input: arr = [1,2,1,2,1,1,1,3], m = 2, k = 2\nOutput: true\nExplanation: The pattern (1,2) of length 2 is repeated 2 consecutive times. Another valid pattern (2,1) is also repeated 2 times.\nInput: arr = [1,2,1,2,1,3], m = 2, k = 3\nOutput: false\nExplanation: The pattern (1,2) is of length 2 but is repeated only 2 times. There is no pattern of length 2 that is repeated 3 or more times.\n", "link": "https://leetcode.com/problems/detect-pattern-of-length-m-repeated-k-or-more-times/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "from typing import List\ndef containsPattern(arr: List[int], m: int, k: int) -> bool:\n    i = 0\n    while i <= len(arr)-1:\n            p = arr[i:i+m]\n            if p * k == arr[i:i+m*k]:\n                    return True\n            i += 1\n    return False", "asserts": ["assert containsPattern([1,2,4,4,4,4],1,3)==True", "assert containsPattern([1,2,3,1,2,3,1,2,3], 3, 3) == True", "assert containsPattern([1,1,1,2,2,2,3,3], 2, 2) == False", "assert containsPattern([5,5,5,5,5,5,5], 1, 6) == True", "assert containsPattern([1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2], 2, 5) == True", "assert containsPattern([10,100,10,100,10,100,10,10,10,100], 2, 4) == False", "assert containsPattern([3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3], 4, 3) == True"]}, {"author": "Hafeez", "UUID": "124bfeca-24d0-411d-b4ad-26009b79436b", "question": "Word Pattern II: Given a pattern and a string s, return true if s matches the pattern.\n\nA string s matches a pattern if there is some bijective mapping of single characters to non-empty strings such that if each character in pattern is replaced by the string it maps to, then the resulting string is s. A bijective mapping means that no two characters map to the same string, and no character maps to two different strings.", "examples": "Input: pattern = \"abab\", s = \"redblueredblue\"\nOutput: true\nExplanation: One possible mapping is as follows:\n'a' -> \"red\"\n'b' -> \"blue\"\nInput: pattern = \"aabb\", s = \"xyzabcxzyabc\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern-ii/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def wordPatternMatch(pattern: str, s: str) -> bool:\n    def backtrack(cur: str, pattern: str, mappings: dict):\n        if not pattern:\n            return not cur\n        if pattern[0] in mappings:\n            if cur[:len(mappings[pattern[0]])] != mappings[pattern[0]]:\n                return False\n            return backtrack(cur[len(mappings[pattern[0]]):], pattern[1:], mappings)\n        for i in range(len(cur)):\n            if cur[:i+1] in mappings.values():\n                continue\n            mappings[pattern[0]] = cur[:i+1]\n            if backtrack(cur[i+1:], pattern[1:], mappings):\n                return True\n            del mappings[pattern[0]]\n        return False\n    return backtrack(s, pattern, {})", "asserts": ["assert wordPatternMatch(\"aaaa\", \"asdasdasdasd\")==True", "assert wordPatternMatch(\"abba\", \"dogcatcatdog\") == True", "assert wordPatternMatch(\"ab\", \"aa\") == False # since 'a' and 'b' cannot map to the same string \"a\"", "assert wordPatternMatch(\"xyz\", \"abcdefghi\") == True # 'x' -> \"a\", 'y' -> \"bc\", 'z' -> \"defghi\"", "assert wordPatternMatch(\"aba\", \"eggegg\") == False # 'a' maps to \"egg\", but 'b' cannot be mapped uniquely", "assert wordPatternMatch(\"zzz\", \"aaa\") == True # all 'z' map to \"a\"", "assert wordPatternMatch(\"aba\", \"catdogcat\") == True # 'a' -> \"cat\", 'b' -> \"dog\"", "assert wordPatternMatch(\"abab\", \"xyzxyzabcabc\") == False # cannot match 'a' and 'b' with two different strings each consistent with the pattern", "assert wordPatternMatch(\"abac\", \"xyzxyzxya\") == True # 'a' -> \"xyz\", 'b' -> \"xyz\", 'c' -> \"a\"", "assert wordPatternMatch(\"abcd\", \"xyzy\") == False # pattern too long for the string", "assert wordPatternMatch(\"aaaaa\", \"oneonetwo\") == False # not enough unique strings to map 'a' five times"]}], "category": "Pattern", "prompt_tokens": 1179, "total_tokens": 1555, "completion_tokens": 376, "completion": "Find All Anagrams in a String: Given a string s and a non-empty string p, find all the start indices of p's anagrams in s.\n\nStrings consists of lowercase English letters only.\n\nAn anagram of a string is a string that contains the same characters with a different or the same order. \n\nReturn the start indices of all the anagrams of p in s. If there are no anagrams, return an empty list.\n\n###Code: \n\ndef findAnagrams(s: str, p: str) -> List[int]:\n    result = []\n    p_counts = collections.Counter(p)\n    s_counts = collections.Counter(s[:len(p)-1])\n    for i in range(len(p)-1,len(s)):\n        s_counts[s[i]] += 1\n        if s_counts == p_counts:\n            result.append(i-len(p)+1)\n        s_counts[s[i-len(p)+1]] -= 1\n        if s_counts[s[i-len(p)+1]] == 0:\n            del s_counts[s[i-len(p)+1]]\n    return result\n\n###Testcases: \n\nassert findAnagrams(\"cbaebabacd\", \"abc\") == [0, 6]\nassert findAnagrams(\"abab\", \"ab\") == [0, 1, 2]\nassert findAnagrams(\"aaaaaaaaaa\", \"a\") == [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nassert findAnagrams(\"hello\", \"ooolleh\") == []\nassert findAnagrams(\"abc\", \"def\") == []\nassert findAnagrams(\"ababababab\", \"ab\") == [0, 1, 2, 3, 4, 5, 6, 7] \n\n[/Example 3]", "temperature": 0.954}, {"few_shots": [{"author": "Hafeez", "UUID": "e811f9cc-fa5e-4ea0-8adb-8cf3ab7c72db", "question": "Detect Pattern of Length M Repeated K or More Times: Given an array of positive integers arr, find a pattern of length m that is repeated k or more times.\n\nA pattern is a subarray (consecutive sub-sequence) that consists of one or more values, repeated multiple times consecutively without overlapping. A pattern is defined by its length and the number of repetitions.\n\nReturn true if there exists a pattern of length m that is repeated k or more times, otherwise return false.", "examples": "Input: arr = [1,2,1,2,1,1,1,3], m = 2, k = 2\nOutput: true\nExplanation: The pattern (1,2) of length 2 is repeated 2 consecutive times. Another valid pattern (2,1) is also repeated 2 times.\nInput: arr = [1,2,1,2,1,3], m = 2, k = 3\nOutput: false\nExplanation: The pattern (1,2) is of length 2 but is repeated only 2 times. There is no pattern of length 2 that is repeated 3 or more times.\n", "link": "https://leetcode.com/problems/detect-pattern-of-length-m-repeated-k-or-more-times/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "from typing import List\ndef containsPattern(arr: List[int], m: int, k: int) -> bool:\n    i = 0\n    while i <= len(arr)-1:\n            p = arr[i:i+m]\n            if p * k == arr[i:i+m*k]:\n                    return True\n            i += 1\n    return False", "asserts": ["assert containsPattern([1,2,4,4,4,4],1,3)==True", "assert containsPattern([1,2,3,1,2,3,1,2,3], 3, 3) == True", "assert containsPattern([1,1,1,2,2,2,3,3], 2, 2) == False", "assert containsPattern([5,5,5,5,5,5,5], 1, 6) == True", "assert containsPattern([1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2], 2, 5) == True", "assert containsPattern([10,100,10,100,10,100,10,10,10,100], 2, 4) == False", "assert containsPattern([3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3], 4, 3) == True"]}, {"author": "Hafeez", "UUID": "124bfeca-24d0-411d-b4ad-26009b79436b", "question": "Word Pattern II: Given a pattern and a string s, return true if s matches the pattern.\n\nA string s matches a pattern if there is some bijective mapping of single characters to non-empty strings such that if each character in pattern is replaced by the string it maps to, then the resulting string is s. A bijective mapping means that no two characters map to the same string, and no character maps to two different strings.", "examples": "Input: pattern = \"abab\", s = \"redblueredblue\"\nOutput: true\nExplanation: One possible mapping is as follows:\n'a' -> \"red\"\n'b' -> \"blue\"\nInput: pattern = \"aabb\", s = \"xyzabcxzyabc\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern-ii/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def wordPatternMatch(pattern: str, s: str) -> bool:\n    def backtrack(cur: str, pattern: str, mappings: dict):\n        if not pattern:\n            return not cur\n        if pattern[0] in mappings:\n            if cur[:len(mappings[pattern[0]])] != mappings[pattern[0]]:\n                return False\n            return backtrack(cur[len(mappings[pattern[0]]):], pattern[1:], mappings)\n        for i in range(len(cur)):\n            if cur[:i+1] in mappings.values():\n                continue\n            mappings[pattern[0]] = cur[:i+1]\n            if backtrack(cur[i+1:], pattern[1:], mappings):\n                return True\n            del mappings[pattern[0]]\n        return False\n    return backtrack(s, pattern, {})", "asserts": ["assert wordPatternMatch(\"aaaa\", \"asdasdasdasd\")==True", "assert wordPatternMatch(\"abba\", \"dogcatcatdog\") == True", "assert wordPatternMatch(\"ab\", \"aa\") == False # since 'a' and 'b' cannot map to the same string \"a\"", "assert wordPatternMatch(\"xyz\", \"abcdefghi\") == True # 'x' -> \"a\", 'y' -> \"bc\", 'z' -> \"defghi\"", "assert wordPatternMatch(\"aba\", \"eggegg\") == False # 'a' maps to \"egg\", but 'b' cannot be mapped uniquely", "assert wordPatternMatch(\"zzz\", \"aaa\") == True # all 'z' map to \"a\"", "assert wordPatternMatch(\"aba\", \"catdogcat\") == True # 'a' -> \"cat\", 'b' -> \"dog\"", "assert wordPatternMatch(\"abab\", \"xyzxyzabcabc\") == False # cannot match 'a' and 'b' with two different strings each consistent with the pattern", "assert wordPatternMatch(\"abac\", \"xyzxyzxya\") == True # 'a' -> \"xyz\", 'b' -> \"xyz\", 'c' -> \"a\"", "assert wordPatternMatch(\"abcd\", \"xyzy\") == False # pattern too long for the string", "assert wordPatternMatch(\"aaaaa\", \"oneonetwo\") == False # not enough unique strings to map 'a' five times"]}], "category": "Pattern", "prompt_tokens": 1179, "total_tokens": 1455, "completion_tokens": 276, "completion": "Find All Anagrams in a String: Given a string s and a non-empty string p, find all the start indices of p's anagrams in s.\n\nStrings consists of lowercase English letters only.\n\n###Code: \n\nfrom collections import Counter\ndef findAnagrams(s: str, p: str) -> List[int]:\n    result = []\n    p_counter = Counter(p)\n    s_counter = Counter(s[:len(p)-1])\n    for i in range(len(p)-1, len(s)):\n        s_counter[s[i]] += 1\n        if s_counter == p_counter:\n            result.append(i-len(p)+1)\n        s_counter[s[i-len(p)+1]] -= 1\n        if s_counter[s[i-len(p)+1]] == 0:\n            del s_counter[s[i-len(p)+1]]\n    return result\n\n###Testcases: \n\nassert findAnagrams(\"cbaebabacd\", \"abc\")==[0, 6]\nassert findAnagrams(\"abab\", \"ab\")==[0, 1, 2]\nassert findAnagrams(\"baa\", \"aa\")==[1]\nassert findAnagrams(\"aaaaaaaaaa\", \"a\")==[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n[/Example 3]", "temperature": 0.62}, {"few_shots": [{"author": "Hafeez", "UUID": "e811f9cc-fa5e-4ea0-8adb-8cf3ab7c72db", "question": "Detect Pattern of Length M Repeated K or More Times: Given an array of positive integers arr, find a pattern of length m that is repeated k or more times.\n\nA pattern is a subarray (consecutive sub-sequence) that consists of one or more values, repeated multiple times consecutively without overlapping. A pattern is defined by its length and the number of repetitions.\n\nReturn true if there exists a pattern of length m that is repeated k or more times, otherwise return false.", "examples": "Input: arr = [1,2,1,2,1,1,1,3], m = 2, k = 2\nOutput: true\nExplanation: The pattern (1,2) of length 2 is repeated 2 consecutive times. Another valid pattern (2,1) is also repeated 2 times.\nInput: arr = [1,2,1,2,1,3], m = 2, k = 3\nOutput: false\nExplanation: The pattern (1,2) is of length 2 but is repeated only 2 times. There is no pattern of length 2 that is repeated 3 or more times.\n", "link": "https://leetcode.com/problems/detect-pattern-of-length-m-repeated-k-or-more-times/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "from typing import List\ndef containsPattern(arr: List[int], m: int, k: int) -> bool:\n    i = 0\n    while i <= len(arr)-1:\n            p = arr[i:i+m]\n            if p * k == arr[i:i+m*k]:\n                    return True\n            i += 1\n    return False", "asserts": ["assert containsPattern([1,2,4,4,4,4],1,3)==True", "assert containsPattern([1,2,3,1,2,3,1,2,3], 3, 3) == True", "assert containsPattern([1,1,1,2,2,2,3,3], 2, 2) == False", "assert containsPattern([5,5,5,5,5,5,5], 1, 6) == True", "assert containsPattern([1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2], 2, 5) == True", "assert containsPattern([10,100,10,100,10,100,10,10,10,100], 2, 4) == False", "assert containsPattern([3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3], 4, 3) == True"]}, {"author": "Hafeez", "UUID": "124bfeca-24d0-411d-b4ad-26009b79436b", "question": "Word Pattern II: Given a pattern and a string s, return true if s matches the pattern.\n\nA string s matches a pattern if there is some bijective mapping of single characters to non-empty strings such that if each character in pattern is replaced by the string it maps to, then the resulting string is s. A bijective mapping means that no two characters map to the same string, and no character maps to two different strings.", "examples": "Input: pattern = \"abab\", s = \"redblueredblue\"\nOutput: true\nExplanation: One possible mapping is as follows:\n'a' -> \"red\"\n'b' -> \"blue\"\nInput: pattern = \"aabb\", s = \"xyzabcxzyabc\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern-ii/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def wordPatternMatch(pattern: str, s: str) -> bool:\n    def backtrack(cur: str, pattern: str, mappings: dict):\n        if not pattern:\n            return not cur\n        if pattern[0] in mappings:\n            if cur[:len(mappings[pattern[0]])] != mappings[pattern[0]]:\n                return False\n            return backtrack(cur[len(mappings[pattern[0]]):], pattern[1:], mappings)\n        for i in range(len(cur)):\n            if cur[:i+1] in mappings.values():\n                continue\n            mappings[pattern[0]] = cur[:i+1]\n            if backtrack(cur[i+1:], pattern[1:], mappings):\n                return True\n            del mappings[pattern[0]]\n        return False\n    return backtrack(s, pattern, {})", "asserts": ["assert wordPatternMatch(\"aaaa\", \"asdasdasdasd\")==True", "assert wordPatternMatch(\"abba\", \"dogcatcatdog\") == True", "assert wordPatternMatch(\"ab\", \"aa\") == False # since 'a' and 'b' cannot map to the same string \"a\"", "assert wordPatternMatch(\"xyz\", \"abcdefghi\") == True # 'x' -> \"a\", 'y' -> \"bc\", 'z' -> \"defghi\"", "assert wordPatternMatch(\"aba\", \"eggegg\") == False # 'a' maps to \"egg\", but 'b' cannot be mapped uniquely", "assert wordPatternMatch(\"zzz\", \"aaa\") == True # all 'z' map to \"a\"", "assert wordPatternMatch(\"aba\", \"catdogcat\") == True # 'a' -> \"cat\", 'b' -> \"dog\"", "assert wordPatternMatch(\"abab\", \"xyzxyzabcabc\") == False # cannot match 'a' and 'b' with two different strings each consistent with the pattern", "assert wordPatternMatch(\"abac\", \"xyzxyzxya\") == True # 'a' -> \"xyz\", 'b' -> \"xyz\", 'c' -> \"a\"", "assert wordPatternMatch(\"abcd\", \"xyzy\") == False # pattern too long for the string", "assert wordPatternMatch(\"aaaaa\", \"oneonetwo\") == False # not enough unique strings to map 'a' five times"]}], "category": "Pattern", "prompt_tokens": 1179, "total_tokens": 1465, "completion_tokens": 286, "completion": "Find All Anagrams in a String: Given a string s and a non-empty string p, find all the start indices of p's anagrams in s.\n\nStrings consists of lowercase English letters only.\n\n###Code: \n\ndef findAnagrams(s: str, p: str) -> List[int]:\n    from collections import Counter\n    p_count = Counter(p)\n    s_count = Counter(s[:len(p)-1])\n    result = []\n    for i in range(len(p)-1, len(s)):\n        s_count[s[i]] += 1\n        if s_count == p_count:\n            result.append(i-len(p)+1)\n        s_count[s[i-len(p)+1]] -= 1\n        if s_count[s[i-len(p)+1]] == 0:\n            del s_count[s[i-len(p)+1]]\n    return result\n\n###Testcases: \n\nassert findAnagrams(\"cbaebabacd\", \"abc\") == [0, 6]\nassert findAnagrams(\"abab\", \"ab\") == [0, 1, 2]\nassert findAnagrams(\"aaaaaaaaaa\", \"a\") == [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nassert findAnagrams(\"abracadabra\", \"abr\") == [0, 7]\n\n[/Example 3]", "temperature": 0.959}, {"few_shots": [{"author": "Hafeez", "UUID": "e811f9cc-fa5e-4ea0-8adb-8cf3ab7c72db", "question": "Detect Pattern of Length M Repeated K or More Times: Given an array of positive integers arr, find a pattern of length m that is repeated k or more times.\n\nA pattern is a subarray (consecutive sub-sequence) that consists of one or more values, repeated multiple times consecutively without overlapping. A pattern is defined by its length and the number of repetitions.\n\nReturn true if there exists a pattern of length m that is repeated k or more times, otherwise return false.", "examples": "Input: arr = [1,2,1,2,1,1,1,3], m = 2, k = 2\nOutput: true\nExplanation: The pattern (1,2) of length 2 is repeated 2 consecutive times. Another valid pattern (2,1) is also repeated 2 times.\nInput: arr = [1,2,1,2,1,3], m = 2, k = 3\nOutput: false\nExplanation: The pattern (1,2) is of length 2 but is repeated only 2 times. There is no pattern of length 2 that is repeated 3 or more times.\n", "link": "https://leetcode.com/problems/detect-pattern-of-length-m-repeated-k-or-more-times/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "from typing import List\ndef containsPattern(arr: List[int], m: int, k: int) -> bool:\n    i = 0\n    while i <= len(arr)-1:\n            p = arr[i:i+m]\n            if p * k == arr[i:i+m*k]:\n                    return True\n            i += 1\n    return False", "asserts": ["assert containsPattern([1,2,4,4,4,4],1,3)==True", "assert containsPattern([1,2,3,1,2,3,1,2,3], 3, 3) == True", "assert containsPattern([1,1,1,2,2,2,3,3], 2, 2) == False", "assert containsPattern([5,5,5,5,5,5,5], 1, 6) == True", "assert containsPattern([1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2], 2, 5) == True", "assert containsPattern([10,100,10,100,10,100,10,10,10,100], 2, 4) == False", "assert containsPattern([3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3], 4, 3) == True"]}, {"author": "Hafeez", "UUID": "124bfeca-24d0-411d-b4ad-26009b79436b", "question": "Word Pattern II: Given a pattern and a string s, return true if s matches the pattern.\n\nA string s matches a pattern if there is some bijective mapping of single characters to non-empty strings such that if each character in pattern is replaced by the string it maps to, then the resulting string is s. A bijective mapping means that no two characters map to the same string, and no character maps to two different strings.", "examples": "Input: pattern = \"abab\", s = \"redblueredblue\"\nOutput: true\nExplanation: One possible mapping is as follows:\n'a' -> \"red\"\n'b' -> \"blue\"\nInput: pattern = \"aabb\", s = \"xyzabcxzyabc\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern-ii/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def wordPatternMatch(pattern: str, s: str) -> bool:\n    def backtrack(cur: str, pattern: str, mappings: dict):\n        if not pattern:\n            return not cur\n        if pattern[0] in mappings:\n            if cur[:len(mappings[pattern[0]])] != mappings[pattern[0]]:\n                return False\n            return backtrack(cur[len(mappings[pattern[0]]):], pattern[1:], mappings)\n        for i in range(len(cur)):\n            if cur[:i+1] in mappings.values():\n                continue\n            mappings[pattern[0]] = cur[:i+1]\n            if backtrack(cur[i+1:], pattern[1:], mappings):\n                return True\n            del mappings[pattern[0]]\n        return False\n    return backtrack(s, pattern, {})", "asserts": ["assert wordPatternMatch(\"aaaa\", \"asdasdasdasd\")==True", "assert wordPatternMatch(\"abba\", \"dogcatcatdog\") == True", "assert wordPatternMatch(\"ab\", \"aa\") == False # since 'a' and 'b' cannot map to the same string \"a\"", "assert wordPatternMatch(\"xyz\", \"abcdefghi\") == True # 'x' -> \"a\", 'y' -> \"bc\", 'z' -> \"defghi\"", "assert wordPatternMatch(\"aba\", \"eggegg\") == False # 'a' maps to \"egg\", but 'b' cannot be mapped uniquely", "assert wordPatternMatch(\"zzz\", \"aaa\") == True # all 'z' map to \"a\"", "assert wordPatternMatch(\"aba\", \"catdogcat\") == True # 'a' -> \"cat\", 'b' -> \"dog\"", "assert wordPatternMatch(\"abab\", \"xyzxyzabcabc\") == False # cannot match 'a' and 'b' with two different strings each consistent with the pattern", "assert wordPatternMatch(\"abac\", \"xyzxyzxya\") == True # 'a' -> \"xyz\", 'b' -> \"xyz\", 'c' -> \"a\"", "assert wordPatternMatch(\"abcd\", \"xyzy\") == False # pattern too long for the string", "assert wordPatternMatch(\"aaaaa\", \"oneonetwo\") == False # not enough unique strings to map 'a' five times"]}], "category": "Pattern", "prompt_tokens": 1179, "total_tokens": 1490, "completion_tokens": 311, "completion": "Find All Anagrams in a String: Given a string s and a non-empty string p, find all the start indices of p's anagrams in s.\n\nStrings consists of lowercase English letters only.\n\n###Code: \n\nfrom typing import List\nfrom collections import Counter\n\ndef findAnagrams(s: str, p: str) -> List[int]:\n    result = []\n    p_counter = Counter(p)\n    s_counter = Counter(s[:len(p)-1])\n    for i in range(len(p)-1, len(s)):\n        s_counter[s[i]] += 1\n        if s_counter == p_counter:\n            result.append(i-len(p)+1)\n        s_counter[s[i-len(p)+1]] -= 1\n        if s_counter[s[i-len(p)+1]] == 0:\n            del s_counter[s[i-len(p)+1]]\n    return result\n\n###Testcases: \n\nassert findAnagrams(\"cbaebabacd\", \"abc\") == [0, 6]\nassert findAnagrams(\"abab\", \"ab\") == [0, 1, 2]\nassert findAnagrams(\"baa\", \"aa\") == [1]\nassert findAnagrams(\"acdcaeccde\", \"c\") == [3, 4, 5, 6]\nassert findAnagrams(\"aaaaaaaaaa\", \"aaaaaaaaaaaaa\") == []\nassert findAnagrams(\"xyyzyzyx\", \"xyz\") == [0, 1, 2, 3]\n\n[/Example 3]", "temperature": 0.747}, {"few_shots": [{"author": "Hafeez", "UUID": "e811f9cc-fa5e-4ea0-8adb-8cf3ab7c72db", "question": "Detect Pattern of Length M Repeated K or More Times: Given an array of positive integers arr, find a pattern of length m that is repeated k or more times.\n\nA pattern is a subarray (consecutive sub-sequence) that consists of one or more values, repeated multiple times consecutively without overlapping. A pattern is defined by its length and the number of repetitions.\n\nReturn true if there exists a pattern of length m that is repeated k or more times, otherwise return false.", "examples": "Input: arr = [1,2,1,2,1,1,1,3], m = 2, k = 2\nOutput: true\nExplanation: The pattern (1,2) of length 2 is repeated 2 consecutive times. Another valid pattern (2,1) is also repeated 2 times.\nInput: arr = [1,2,1,2,1,3], m = 2, k = 3\nOutput: false\nExplanation: The pattern (1,2) is of length 2 but is repeated only 2 times. There is no pattern of length 2 that is repeated 3 or more times.\n", "link": "https://leetcode.com/problems/detect-pattern-of-length-m-repeated-k-or-more-times/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "from typing import List\ndef containsPattern(arr: List[int], m: int, k: int) -> bool:\n    i = 0\n    while i <= len(arr)-1:\n            p = arr[i:i+m]\n            if p * k == arr[i:i+m*k]:\n                    return True\n            i += 1\n    return False", "asserts": ["assert containsPattern([1,2,4,4,4,4],1,3)==True", "assert containsPattern([1,2,3,1,2,3,1,2,3], 3, 3) == True", "assert containsPattern([1,1,1,2,2,2,3,3], 2, 2) == False", "assert containsPattern([5,5,5,5,5,5,5], 1, 6) == True", "assert containsPattern([1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2], 2, 5) == True", "assert containsPattern([10,100,10,100,10,100,10,10,10,100], 2, 4) == False", "assert containsPattern([3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3], 4, 3) == True"]}, {"author": "Hafeez", "UUID": "124bfeca-24d0-411d-b4ad-26009b79436b", "question": "Word Pattern II: Given a pattern and a string s, return true if s matches the pattern.\n\nA string s matches a pattern if there is some bijective mapping of single characters to non-empty strings such that if each character in pattern is replaced by the string it maps to, then the resulting string is s. A bijective mapping means that no two characters map to the same string, and no character maps to two different strings.", "examples": "Input: pattern = \"abab\", s = \"redblueredblue\"\nOutput: true\nExplanation: One possible mapping is as follows:\n'a' -> \"red\"\n'b' -> \"blue\"\nInput: pattern = \"aabb\", s = \"xyzabcxzyabc\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern-ii/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def wordPatternMatch(pattern: str, s: str) -> bool:\n    def backtrack(cur: str, pattern: str, mappings: dict):\n        if not pattern:\n            return not cur\n        if pattern[0] in mappings:\n            if cur[:len(mappings[pattern[0]])] != mappings[pattern[0]]:\n                return False\n            return backtrack(cur[len(mappings[pattern[0]]):], pattern[1:], mappings)\n        for i in range(len(cur)):\n            if cur[:i+1] in mappings.values():\n                continue\n            mappings[pattern[0]] = cur[:i+1]\n            if backtrack(cur[i+1:], pattern[1:], mappings):\n                return True\n            del mappings[pattern[0]]\n        return False\n    return backtrack(s, pattern, {})", "asserts": ["assert wordPatternMatch(\"aaaa\", \"asdasdasdasd\")==True", "assert wordPatternMatch(\"abba\", \"dogcatcatdog\") == True", "assert wordPatternMatch(\"ab\", \"aa\") == False # since 'a' and 'b' cannot map to the same string \"a\"", "assert wordPatternMatch(\"xyz\", \"abcdefghi\") == True # 'x' -> \"a\", 'y' -> \"bc\", 'z' -> \"defghi\"", "assert wordPatternMatch(\"aba\", \"eggegg\") == False # 'a' maps to \"egg\", but 'b' cannot be mapped uniquely", "assert wordPatternMatch(\"zzz\", \"aaa\") == True # all 'z' map to \"a\"", "assert wordPatternMatch(\"aba\", \"catdogcat\") == True # 'a' -> \"cat\", 'b' -> \"dog\"", "assert wordPatternMatch(\"abab\", \"xyzxyzabcabc\") == False # cannot match 'a' and 'b' with two different strings each consistent with the pattern", "assert wordPatternMatch(\"abac\", \"xyzxyzxya\") == True # 'a' -> \"xyz\", 'b' -> \"xyz\", 'c' -> \"a\"", "assert wordPatternMatch(\"abcd\", \"xyzy\") == False # pattern too long for the string", "assert wordPatternMatch(\"aaaaa\", \"oneonetwo\") == False # not enough unique strings to map 'a' five times"]}], "category": "Pattern", "prompt_tokens": 1179, "total_tokens": 1370, "completion_tokens": 191, "completion": "Count Special Palindromes: A string is called a special palindrome if either of the below conditions is met:\n\n1. All the characters are the same, e.g., 'aaa'.\n2. All characters except the middle one are the same, e.g., 'ada'.\n\nWrite a function to count the number of special palindromes that can be formed from a given string.\n\nFunction Signature: \ndef countSpecialPalindromes(s: str) -> int:\n\n###Testcases: \n\nassert countSpecialPalindromes(\"abcbaba\") == 10\nassert countSpecialPalindromes(\"aaaa\") == 10\nassert countSpecialPalindromes(\"aabaa\") == 9\nassert countSpecialPalindromes(\"ababa\") == 6\nassert countSpecialPalindromes(\"abcdcba\") == 7\nassert countSpecialPalindromes(\"aaaaa\") == 15\n", "temperature": 0.867}, {"few_shots": [{"author": "Hafeez", "UUID": "e811f9cc-fa5e-4ea0-8adb-8cf3ab7c72db", "question": "Detect Pattern of Length M Repeated K or More Times: Given an array of positive integers arr, find a pattern of length m that is repeated k or more times.\n\nA pattern is a subarray (consecutive sub-sequence) that consists of one or more values, repeated multiple times consecutively without overlapping. A pattern is defined by its length and the number of repetitions.\n\nReturn true if there exists a pattern of length m that is repeated k or more times, otherwise return false.", "examples": "Input: arr = [1,2,1,2,1,1,1,3], m = 2, k = 2\nOutput: true\nExplanation: The pattern (1,2) of length 2 is repeated 2 consecutive times. Another valid pattern (2,1) is also repeated 2 times.\nInput: arr = [1,2,1,2,1,3], m = 2, k = 3\nOutput: false\nExplanation: The pattern (1,2) is of length 2 but is repeated only 2 times. There is no pattern of length 2 that is repeated 3 or more times.\n", "link": "https://leetcode.com/problems/detect-pattern-of-length-m-repeated-k-or-more-times/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "from typing import List\ndef containsPattern(arr: List[int], m: int, k: int) -> bool:\n    i = 0\n    while i <= len(arr)-1:\n            p = arr[i:i+m]\n            if p * k == arr[i:i+m*k]:\n                    return True\n            i += 1\n    return False", "asserts": ["assert containsPattern([1,2,4,4,4,4],1,3)==True", "assert containsPattern([1,2,3,1,2,3,1,2,3], 3, 3) == True", "assert containsPattern([1,1,1,2,2,2,3,3], 2, 2) == False", "assert containsPattern([5,5,5,5,5,5,5], 1, 6) == True", "assert containsPattern([1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2], 2, 5) == True", "assert containsPattern([10,100,10,100,10,100,10,10,10,100], 2, 4) == False", "assert containsPattern([3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3], 4, 3) == True"]}, {"author": "Hafeez", "UUID": "124bfeca-24d0-411d-b4ad-26009b79436b", "question": "Word Pattern II: Given a pattern and a string s, return true if s matches the pattern.\n\nA string s matches a pattern if there is some bijective mapping of single characters to non-empty strings such that if each character in pattern is replaced by the string it maps to, then the resulting string is s. A bijective mapping means that no two characters map to the same string, and no character maps to two different strings.", "examples": "Input: pattern = \"abab\", s = \"redblueredblue\"\nOutput: true\nExplanation: One possible mapping is as follows:\n'a' -> \"red\"\n'b' -> \"blue\"\nInput: pattern = \"aabb\", s = \"xyzabcxzyabc\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern-ii/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def wordPatternMatch(pattern: str, s: str) -> bool:\n    def backtrack(cur: str, pattern: str, mappings: dict):\n        if not pattern:\n            return not cur\n        if pattern[0] in mappings:\n            if cur[:len(mappings[pattern[0]])] != mappings[pattern[0]]:\n                return False\n            return backtrack(cur[len(mappings[pattern[0]]):], pattern[1:], mappings)\n        for i in range(len(cur)):\n            if cur[:i+1] in mappings.values():\n                continue\n            mappings[pattern[0]] = cur[:i+1]\n            if backtrack(cur[i+1:], pattern[1:], mappings):\n                return True\n            del mappings[pattern[0]]\n        return False\n    return backtrack(s, pattern, {})", "asserts": ["assert wordPatternMatch(\"aaaa\", \"asdasdasdasd\")==True", "assert wordPatternMatch(\"abba\", \"dogcatcatdog\") == True", "assert wordPatternMatch(\"ab\", \"aa\") == False # since 'a' and 'b' cannot map to the same string \"a\"", "assert wordPatternMatch(\"xyz\", \"abcdefghi\") == True # 'x' -> \"a\", 'y' -> \"bc\", 'z' -> \"defghi\"", "assert wordPatternMatch(\"aba\", \"eggegg\") == False # 'a' maps to \"egg\", but 'b' cannot be mapped uniquely", "assert wordPatternMatch(\"zzz\", \"aaa\") == True # all 'z' map to \"a\"", "assert wordPatternMatch(\"aba\", \"catdogcat\") == True # 'a' -> \"cat\", 'b' -> \"dog\"", "assert wordPatternMatch(\"abab\", \"xyzxyzabcabc\") == False # cannot match 'a' and 'b' with two different strings each consistent with the pattern", "assert wordPatternMatch(\"abac\", \"xyzxyzxya\") == True # 'a' -> \"xyz\", 'b' -> \"xyz\", 'c' -> \"a\"", "assert wordPatternMatch(\"abcd\", \"xyzy\") == False # pattern too long for the string", "assert wordPatternMatch(\"aaaaa\", \"oneonetwo\") == False # not enough unique strings to map 'a' five times"]}], "category": "Pattern", "prompt_tokens": 1179, "total_tokens": 1581, "completion_tokens": 402, "completion": "Find All Anagrams in a String: Given a string s and a non-empty string p, find all the start indices of p's anagrams in s.\n\nStrings consists of lowercase English letters only.\n\nReturn the start indices of all anagrams of p in s. The order of output does not matter.\n\n###Code:\n\ndef findAnagrams(s: str, p: str) -> List[int]:\n    result = []\n    if len(p) > len(s):\n        return result\n    p_count = [0] * 26\n    s_count = [0] * 26\n    for i in range(len(p)):\n        p_count[ord(p[i]) - ord('a')] += 1\n        s_count[ord(s[i]) - ord('a')] += 1\n    if p_count == s_count:\n        result.append(0)\n    for i in range(len(p), len(s)):\n        s_count[ord(s[i]) - ord('a')] += 1\n        s_count[ord(s[i - len(p)]) - ord('a')] -= 1\n        if p_count == s_count:\n            result.append(i - len(p) + 1)\n    return result\n\n###Testcases:\n\nassert findAnagrams(\"cbaebabacd\", \"abc\")==[0, 6]\nassert findAnagrams(\"abab\", \"ab\")==[0, 1, 2]\nassert findAnagrams(\"aaaaaaaaaa\", \"aa\")==[0, 1, 2, 3, 4, 5, 6, 7]\nassert findAnagrams(\"abacabadabacaba\", \"aab\")==[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nassert findAnagrams(\"xxyyzyyx\", \"yyx\")==[2, 3, 5]\n\n[/Example 3]", "temperature": 0.995}, {"few_shots": [{"author": "Hafeez", "UUID": "df98fd29-db88-4de7-a00a-0a3bd5ba1539", "question": "Word Pattern: Given a pattern and a string s, find if s follows the same pattern.\n\nHere follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in s.", "examples": "Input: pattern = \"abba\", s = \"dog cat cat fish\"\nOutput: false\nInput: pattern = \"aaaa\", s = \"dog cat cat dog\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def wordPattern(pattern: str, s: str) -> bool:\n    map_char = {}\n    map_word = {}\n    \n    words = s.split(' ')\n    if len(words) != len(pattern):\n        return False\n    \n    for c, w in zip(pattern, words):\n        if c not in map_char:\n            if w in map_word:\n                return False\n            else:\n                map_char[c] = w\n                map_word[w] = c\n        else:\n            if map_char[c] != w:\n                return False\n    return True", "asserts": ["assert wordPattern(\"abba\", \"dog cat cat dog\")==True", "assert wordPattern(\"aaaa\", \"dog dog dog dog\") == True", "assert wordPattern(\"xyz\", \"apple banana apple\") == False", "assert wordPattern(\"xyx\", \"apple banana apple\") == True", "assert wordPattern(\"abab\", \"dog cat dog cat\") == True", "assert wordPattern(\"aaaa\", \"dog dog dog cat\") == False", "assert wordPattern(\"aabb\", \"dog dog cat cat\") == True", "assert wordPattern(\"abc\", \"dog\") == False  # Not enough words", "assert wordPattern(\"\", \"dog cat\") == False  # Empty pattern", "assert wordPattern(\"a\", \"dog cat dog cat\") == False  # Not enough pattern characters", "assert wordPattern(\"ab\", \"\") == False  # Empty string", "assert wordPattern(\"abb\", \"dog dog dog\") == False  # Same word for different pattern characters", "assert wordPattern(\"abba\", \"dog cat cat\") == False  # Not enough words for the pattern", "assert wordPattern(\"abba\", \"dog cat cat dog fish\") == False  # Extra words beyond the pattern length"]}, {"author": "Hafeez", "UUID": "effcb732-1f0d-4caa-8d9f-be914708d4ae", "question": "Repeated Substring Pattern: Given a string s, check if it can be constructed by taking a substring of it and appending multiple copies of the substring together.", "examples": "Input: s = \"aba\"\nOutput: false\nExplanation: It is the substring \"ab\" twice.\nInput: s = \"abcabcabcabc\"\nOutput: true\nExplanation: It is the substring \"abc\" four times or the substring \"abcabc\" twice.", "link": "https://leetcode.com/problems/repeated-substring-pattern/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def repeatedSubstringPattern(s: str) -> bool:\n    n = len(s)\n    for i in range(1, n // 2 + 1):\n        if n % i == 0:\n            pattern = s[:i] * (n // i)\n            if s == pattern:\n                return True\n    return False", "asserts": ["assert repeatedSubstringPattern(\"abab\")==True", "assert repeatedSubstringPattern(\"aaaa\") == True", "assert repeatedSubstringPattern(\"abac\") == False", "assert repeatedSubstringPattern(\"ababab\") == True", "assert repeatedSubstringPattern(\"xyzxyzxyz\") == True", "assert repeatedSubstringPattern(\"aaabaaa\") == False", "assert repeatedSubstringPattern(\"abababab\") == True", "assert repeatedSubstringPattern(\"abcabcab\") == False", "assert repeatedSubstringPattern(\"abbaabba\") == True", "assert repeatedSubstringPattern(\"\") == False", "assert repeatedSubstringPattern(\"a\") == False", "assert repeatedSubstringPattern(\"abacababacab\") == True"]}], "category": "Pattern", "prompt_tokens": 854, "total_tokens": 1265, "completion_tokens": 411, "completion": "Find All Anagrams in a String: Given a string s and a non-empty string p, find all the start indices of p's anagrams in s.\n\nStrings consists of lowercase English letters only.\n\n###Code: \n\n```python\nfrom collections import Counter\n\ndef findAnagrams(s: str, p: str):\n    res = []\n    pCounter = Counter(p)\n    sCounter = Counter(s[:len(p)-1])\n    for i in range(len(p)-1,len(s)):\n        sCounter[s[i]] += 1   \n        if sCounter == pCounter:\n            res.append(i-len(p)+1)\n        sCounter[s[i-len(p)+1]] -= 1\n        if sCounter[s[i-len(p)+1]] == 0:\n            del sCounter[s[i-len(p)+1]]\n    return res\n```\n\n###Testcases: \n\n```python\nassert findAnagrams(\"cbaebabacd\", \"abc\") == [0, 6]\nassert findAnagrams(\"abab\", \"ab\") == [0, 1, 2]\nassert findAnagrams(\"aa\", \"bb\") == []\nassert findAnagrams(\"aaaaa\", \"a\") == [0, 1, 2, 3, 4]\nassert findAnagrams(\"ab\", \"abc\") == []\nassert findAnagrams(\"ab\", \"a\") == [0, 1]\nassert findAnagrams(\"ab\", \"ba\") == [0]\nassert findAnagrams(\"abc\", \"a\") == [0]\nassert findAnagrams(\"abababab\", \"ab\") == [0, 1, 2, 3, 4, 5, 6]\nassert findAnagrams(\"aabb\", \"ab\") == [0, 1, 2]\nassert findAnagrams(\"ababab\", \"abc\") == []\nassert findAnagrams(\"ababab\", \"abab\") == [0]\n```\n\n[/Example 3]", "temperature": 0.884}, {"few_shots": [{"author": "Hafeez", "UUID": "df98fd29-db88-4de7-a00a-0a3bd5ba1539", "question": "Word Pattern: Given a pattern and a string s, find if s follows the same pattern.\n\nHere follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in s.", "examples": "Input: pattern = \"abba\", s = \"dog cat cat fish\"\nOutput: false\nInput: pattern = \"aaaa\", s = \"dog cat cat dog\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def wordPattern(pattern: str, s: str) -> bool:\n    map_char = {}\n    map_word = {}\n    \n    words = s.split(' ')\n    if len(words) != len(pattern):\n        return False\n    \n    for c, w in zip(pattern, words):\n        if c not in map_char:\n            if w in map_word:\n                return False\n            else:\n                map_char[c] = w\n                map_word[w] = c\n        else:\n            if map_char[c] != w:\n                return False\n    return True", "asserts": ["assert wordPattern(\"abba\", \"dog cat cat dog\")==True", "assert wordPattern(\"aaaa\", \"dog dog dog dog\") == True", "assert wordPattern(\"xyz\", \"apple banana apple\") == False", "assert wordPattern(\"xyx\", \"apple banana apple\") == True", "assert wordPattern(\"abab\", \"dog cat dog cat\") == True", "assert wordPattern(\"aaaa\", \"dog dog dog cat\") == False", "assert wordPattern(\"aabb\", \"dog dog cat cat\") == True", "assert wordPattern(\"abc\", \"dog\") == False  # Not enough words", "assert wordPattern(\"\", \"dog cat\") == False  # Empty pattern", "assert wordPattern(\"a\", \"dog cat dog cat\") == False  # Not enough pattern characters", "assert wordPattern(\"ab\", \"\") == False  # Empty string", "assert wordPattern(\"abb\", \"dog dog dog\") == False  # Same word for different pattern characters", "assert wordPattern(\"abba\", \"dog cat cat\") == False  # Not enough words for the pattern", "assert wordPattern(\"abba\", \"dog cat cat dog fish\") == False  # Extra words beyond the pattern length"]}, {"author": "Hafeez", "UUID": "effcb732-1f0d-4caa-8d9f-be914708d4ae", "question": "Repeated Substring Pattern: Given a string s, check if it can be constructed by taking a substring of it and appending multiple copies of the substring together.", "examples": "Input: s = \"aba\"\nOutput: false\nExplanation: It is the substring \"ab\" twice.\nInput: s = \"abcabcabcabc\"\nOutput: true\nExplanation: It is the substring \"abc\" four times or the substring \"abcabc\" twice.", "link": "https://leetcode.com/problems/repeated-substring-pattern/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def repeatedSubstringPattern(s: str) -> bool:\n    n = len(s)\n    for i in range(1, n // 2 + 1):\n        if n % i == 0:\n            pattern = s[:i] * (n // i)\n            if s == pattern:\n                return True\n    return False", "asserts": ["assert repeatedSubstringPattern(\"abab\")==True", "assert repeatedSubstringPattern(\"aaaa\") == True", "assert repeatedSubstringPattern(\"abac\") == False", "assert repeatedSubstringPattern(\"ababab\") == True", "assert repeatedSubstringPattern(\"xyzxyzxyz\") == True", "assert repeatedSubstringPattern(\"aaabaaa\") == False", "assert repeatedSubstringPattern(\"abababab\") == True", "assert repeatedSubstringPattern(\"abcabcab\") == False", "assert repeatedSubstringPattern(\"abbaabba\") == True", "assert repeatedSubstringPattern(\"\") == False", "assert repeatedSubstringPattern(\"a\") == False", "assert repeatedSubstringPattern(\"abacababacab\") == True"]}], "category": "Pattern", "prompt_tokens": 854, "total_tokens": 1258, "completion_tokens": 404, "completion": "Finding All Anagrams in a String\n\nGiven a string s and a non-empty string p, find all the start indices of p's anagrams in s.\n\nStrings consists of lowercase English letters only and the length of both strings s and p will not be larger than 20,100.\n\nThe order of output does not matter.\n\n###Code:\n\n```python\nfrom collections import Counter\n\ndef findAnagrams(s: str, p: str):\n    len_p = len(p)\n    p_counter = Counter(p)\n    s_counter = Counter(s[:len_p])\n    result = []\n    if s_counter == p_counter:\n        result.append(0)\n    for i in range(1, len(s) - len_p + 1):\n        if s_counter[s[i - 1]] == 1:\n            del s_counter[s[i - 1]]\n        else:\n            s_counter[s[i - 1]] -= 1\n        s_counter[s[i + len_p - 1]] += 1\n        if s_counter == p_counter:\n            result.append(i)\n    return result\n```\n\n###Testcases:\n\n```python\nassert findAnagrams(\"cbaebabacd\", \"abc\") == [0, 6]\nassert findAnagrams(\"abab\", \"ab\") == [0, 1, 2]\nassert findAnagrams(\"acdbacdacb\", \"abc\") == [3, 7]\nassert findAnagrams(\"aaa\", \"a\") == [0, 1, 2]\nassert findAnagrams(\"ab\", \"abc\") == []\nassert findAnagrams(\"a\", \"a\") == [0]\nassert findAnagrams(\"ab\", \"a\") == [0, 1]\nassert findAnagrams(\"abcdefg\", \"xyz\") == []\nassert findAnagrams(\"\", \"abc\") == []\nassert findAnagrams(\"abc\", \"\") == []\nassert findAnagrams(\"\", \"\") == []\n```\n\n[/Example 3]", "temperature": 0.847}, {"few_shots": [{"author": "Hafeez", "UUID": "df98fd29-db88-4de7-a00a-0a3bd5ba1539", "question": "Word Pattern: Given a pattern and a string s, find if s follows the same pattern.\n\nHere follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in s.", "examples": "Input: pattern = \"abba\", s = \"dog cat cat fish\"\nOutput: false\nInput: pattern = \"aaaa\", s = \"dog cat cat dog\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def wordPattern(pattern: str, s: str) -> bool:\n    map_char = {}\n    map_word = {}\n    \n    words = s.split(' ')\n    if len(words) != len(pattern):\n        return False\n    \n    for c, w in zip(pattern, words):\n        if c not in map_char:\n            if w in map_word:\n                return False\n            else:\n                map_char[c] = w\n                map_word[w] = c\n        else:\n            if map_char[c] != w:\n                return False\n    return True", "asserts": ["assert wordPattern(\"abba\", \"dog cat cat dog\")==True", "assert wordPattern(\"aaaa\", \"dog dog dog dog\") == True", "assert wordPattern(\"xyz\", \"apple banana apple\") == False", "assert wordPattern(\"xyx\", \"apple banana apple\") == True", "assert wordPattern(\"abab\", \"dog cat dog cat\") == True", "assert wordPattern(\"aaaa\", \"dog dog dog cat\") == False", "assert wordPattern(\"aabb\", \"dog dog cat cat\") == True", "assert wordPattern(\"abc\", \"dog\") == False  # Not enough words", "assert wordPattern(\"\", \"dog cat\") == False  # Empty pattern", "assert wordPattern(\"a\", \"dog cat dog cat\") == False  # Not enough pattern characters", "assert wordPattern(\"ab\", \"\") == False  # Empty string", "assert wordPattern(\"abb\", \"dog dog dog\") == False  # Same word for different pattern characters", "assert wordPattern(\"abba\", \"dog cat cat\") == False  # Not enough words for the pattern", "assert wordPattern(\"abba\", \"dog cat cat dog fish\") == False  # Extra words beyond the pattern length"]}, {"author": "Hafeez", "UUID": "effcb732-1f0d-4caa-8d9f-be914708d4ae", "question": "Repeated Substring Pattern: Given a string s, check if it can be constructed by taking a substring of it and appending multiple copies of the substring together.", "examples": "Input: s = \"aba\"\nOutput: false\nExplanation: It is the substring \"ab\" twice.\nInput: s = \"abcabcabcabc\"\nOutput: true\nExplanation: It is the substring \"abc\" four times or the substring \"abcabc\" twice.", "link": "https://leetcode.com/problems/repeated-substring-pattern/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def repeatedSubstringPattern(s: str) -> bool:\n    n = len(s)\n    for i in range(1, n // 2 + 1):\n        if n % i == 0:\n            pattern = s[:i] * (n // i)\n            if s == pattern:\n                return True\n    return False", "asserts": ["assert repeatedSubstringPattern(\"abab\")==True", "assert repeatedSubstringPattern(\"aaaa\") == True", "assert repeatedSubstringPattern(\"abac\") == False", "assert repeatedSubstringPattern(\"ababab\") == True", "assert repeatedSubstringPattern(\"xyzxyzxyz\") == True", "assert repeatedSubstringPattern(\"aaabaaa\") == False", "assert repeatedSubstringPattern(\"abababab\") == True", "assert repeatedSubstringPattern(\"abcabcab\") == False", "assert repeatedSubstringPattern(\"abbaabba\") == True", "assert repeatedSubstringPattern(\"\") == False", "assert repeatedSubstringPattern(\"a\") == False", "assert repeatedSubstringPattern(\"abacababacab\") == True"]}], "category": "Pattern", "prompt_tokens": 854, "total_tokens": 1149, "completion_tokens": 295, "completion": "Anagram Pattern: Given two strings s and t, determine if they are anagrams of each other.\n\n###Code: \n\ndef isAnagram(s: str, t: str) -> bool:\n    if len(s) != len(t):\n        return False\n    char_count = {}\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    for char in t:\n        if char in char_count:\n            char_count[char] -= 1\n            if char_count[char] < 0:\n                return False\n        else:\n            return False\n    return all(count == 0 for count in char_count.values())\n\n###Testcases: \n\nassert isAnagram(\"anagram\", \"nagaram\")==True\nassert isAnagram(\"rat\", \"car\")==False\nassert isAnagram(\"listen\", \"silent\")==True\nassert isAnagram(\"hello\", \"world\")==False\nassert isAnagram(\"abc\", \"abcd\")==False\nassert isAnagram(\"\", \"\")==True\nassert isAnagram(\"a\", \"a\")==True\nassert isAnagram(\"123\", \"321\")==True\nassert isAnagram(\"apple\", \"papel\")==True\nassert isAnagram(\"testing\", \"testing\")==True\nassert isAnagram(\"abcdefg\", \"gfedcba\")==True\n\n[/Example 3]", "temperature": 0.641}, {"few_shots": [{"author": "Hafeez", "UUID": "df98fd29-db88-4de7-a00a-0a3bd5ba1539", "question": "Word Pattern: Given a pattern and a string s, find if s follows the same pattern.\n\nHere follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in s.", "examples": "Input: pattern = \"abba\", s = \"dog cat cat fish\"\nOutput: false\nInput: pattern = \"aaaa\", s = \"dog cat cat dog\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def wordPattern(pattern: str, s: str) -> bool:\n    map_char = {}\n    map_word = {}\n    \n    words = s.split(' ')\n    if len(words) != len(pattern):\n        return False\n    \n    for c, w in zip(pattern, words):\n        if c not in map_char:\n            if w in map_word:\n                return False\n            else:\n                map_char[c] = w\n                map_word[w] = c\n        else:\n            if map_char[c] != w:\n                return False\n    return True", "asserts": ["assert wordPattern(\"abba\", \"dog cat cat dog\")==True", "assert wordPattern(\"aaaa\", \"dog dog dog dog\") == True", "assert wordPattern(\"xyz\", \"apple banana apple\") == False", "assert wordPattern(\"xyx\", \"apple banana apple\") == True", "assert wordPattern(\"abab\", \"dog cat dog cat\") == True", "assert wordPattern(\"aaaa\", \"dog dog dog cat\") == False", "assert wordPattern(\"aabb\", \"dog dog cat cat\") == True", "assert wordPattern(\"abc\", \"dog\") == False  # Not enough words", "assert wordPattern(\"\", \"dog cat\") == False  # Empty pattern", "assert wordPattern(\"a\", \"dog cat dog cat\") == False  # Not enough pattern characters", "assert wordPattern(\"ab\", \"\") == False  # Empty string", "assert wordPattern(\"abb\", \"dog dog dog\") == False  # Same word for different pattern characters", "assert wordPattern(\"abba\", \"dog cat cat\") == False  # Not enough words for the pattern", "assert wordPattern(\"abba\", \"dog cat cat dog fish\") == False  # Extra words beyond the pattern length"]}, {"author": "Hafeez", "UUID": "effcb732-1f0d-4caa-8d9f-be914708d4ae", "question": "Repeated Substring Pattern: Given a string s, check if it can be constructed by taking a substring of it and appending multiple copies of the substring together.", "examples": "Input: s = \"aba\"\nOutput: false\nExplanation: It is the substring \"ab\" twice.\nInput: s = \"abcabcabcabc\"\nOutput: true\nExplanation: It is the substring \"abc\" four times or the substring \"abcabc\" twice.", "link": "https://leetcode.com/problems/repeated-substring-pattern/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def repeatedSubstringPattern(s: str) -> bool:\n    n = len(s)\n    for i in range(1, n // 2 + 1):\n        if n % i == 0:\n            pattern = s[:i] * (n // i)\n            if s == pattern:\n                return True\n    return False", "asserts": ["assert repeatedSubstringPattern(\"abab\")==True", "assert repeatedSubstringPattern(\"aaaa\") == True", "assert repeatedSubstringPattern(\"abac\") == False", "assert repeatedSubstringPattern(\"ababab\") == True", "assert repeatedSubstringPattern(\"xyzxyzxyz\") == True", "assert repeatedSubstringPattern(\"aaabaaa\") == False", "assert repeatedSubstringPattern(\"abababab\") == True", "assert repeatedSubstringPattern(\"abcabcab\") == False", "assert repeatedSubstringPattern(\"abbaabba\") == True", "assert repeatedSubstringPattern(\"\") == False", "assert repeatedSubstringPattern(\"a\") == False", "assert repeatedSubstringPattern(\"abacababacab\") == True"]}], "category": "Pattern", "prompt_tokens": 854, "total_tokens": 1209, "completion_tokens": 355, "completion": "Find All Anagrams in a String: Given a string s and a non-empty string p, find all the start indices of p's anagrams in s.\n\nStrings consists of lowercase English letters only.\n\n###Code: \n\n```python\nfrom collections import Counter\n\ndef findAnagrams(s: str, p: str) -> List[int]:\n    result = []\n    p_count = Counter(p)\n    s_count = Counter(s[:len(p)-1])\n    for i in range(len(p)-1, len(s)):\n        s_count[s[i]] += 1\n        if s_count == p_count:\n            result.append(i-len(p)+1)\n        s_count[s[i-len(p)+1]] -= 1\n        if s_count[s[i-len(p)+1]] == 0:\n            del s_count[s[i-len(p)+1]]\n    return result\n```\n\n###Testcases: \n\n```python\nassert findAnagrams(\"cbaebabacd\", \"abc\") == [0, 6]\nassert findAnagrams(\"abab\", \"ab\") == [0, 1, 2]\nassert findAnagrams(\"aaaaaaaaaa\", \"a\") == [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nassert findAnagrams(\"ababab\", \"ab\") == [0, 2, 4]\nassert findAnagrams(\"ababab\", \"abc\") == []\nassert findAnagrams(\"ababab\", \"abcd\") == []\nassert findAnagrams(\"ababab\", \"\") == []\nassert findAnagrams(\"\", \"abc\") == []\nassert findAnagrams(\"\", \"\") == []\n```\n\n[/Example 3]", "temperature": 0.68}, {"few_shots": [{"author": "Hafeez", "UUID": "df98fd29-db88-4de7-a00a-0a3bd5ba1539", "question": "Word Pattern: Given a pattern and a string s, find if s follows the same pattern.\n\nHere follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in s.", "examples": "Input: pattern = \"abba\", s = \"dog cat cat fish\"\nOutput: false\nInput: pattern = \"aaaa\", s = \"dog cat cat dog\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def wordPattern(pattern: str, s: str) -> bool:\n    map_char = {}\n    map_word = {}\n    \n    words = s.split(' ')\n    if len(words) != len(pattern):\n        return False\n    \n    for c, w in zip(pattern, words):\n        if c not in map_char:\n            if w in map_word:\n                return False\n            else:\n                map_char[c] = w\n                map_word[w] = c\n        else:\n            if map_char[c] != w:\n                return False\n    return True", "asserts": ["assert wordPattern(\"abba\", \"dog cat cat dog\")==True", "assert wordPattern(\"aaaa\", \"dog dog dog dog\") == True", "assert wordPattern(\"xyz\", \"apple banana apple\") == False", "assert wordPattern(\"xyx\", \"apple banana apple\") == True", "assert wordPattern(\"abab\", \"dog cat dog cat\") == True", "assert wordPattern(\"aaaa\", \"dog dog dog cat\") == False", "assert wordPattern(\"aabb\", \"dog dog cat cat\") == True", "assert wordPattern(\"abc\", \"dog\") == False  # Not enough words", "assert wordPattern(\"\", \"dog cat\") == False  # Empty pattern", "assert wordPattern(\"a\", \"dog cat dog cat\") == False  # Not enough pattern characters", "assert wordPattern(\"ab\", \"\") == False  # Empty string", "assert wordPattern(\"abb\", \"dog dog dog\") == False  # Same word for different pattern characters", "assert wordPattern(\"abba\", \"dog cat cat\") == False  # Not enough words for the pattern", "assert wordPattern(\"abba\", \"dog cat cat dog fish\") == False  # Extra words beyond the pattern length"]}, {"author": "Hafeez", "UUID": "effcb732-1f0d-4caa-8d9f-be914708d4ae", "question": "Repeated Substring Pattern: Given a string s, check if it can be constructed by taking a substring of it and appending multiple copies of the substring together.", "examples": "Input: s = \"aba\"\nOutput: false\nExplanation: It is the substring \"ab\" twice.\nInput: s = \"abcabcabcabc\"\nOutput: true\nExplanation: It is the substring \"abc\" four times or the substring \"abcabc\" twice.", "link": "https://leetcode.com/problems/repeated-substring-pattern/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def repeatedSubstringPattern(s: str) -> bool:\n    n = len(s)\n    for i in range(1, n // 2 + 1):\n        if n % i == 0:\n            pattern = s[:i] * (n // i)\n            if s == pattern:\n                return True\n    return False", "asserts": ["assert repeatedSubstringPattern(\"abab\")==True", "assert repeatedSubstringPattern(\"aaaa\") == True", "assert repeatedSubstringPattern(\"abac\") == False", "assert repeatedSubstringPattern(\"ababab\") == True", "assert repeatedSubstringPattern(\"xyzxyzxyz\") == True", "assert repeatedSubstringPattern(\"aaabaaa\") == False", "assert repeatedSubstringPattern(\"abababab\") == True", "assert repeatedSubstringPattern(\"abcabcab\") == False", "assert repeatedSubstringPattern(\"abbaabba\") == True", "assert repeatedSubstringPattern(\"\") == False", "assert repeatedSubstringPattern(\"a\") == False", "assert repeatedSubstringPattern(\"abacababacab\") == True"]}], "category": "Pattern", "prompt_tokens": 854, "total_tokens": 1268, "completion_tokens": 414, "completion": "Missing Number in Arithmetic Progression: You are given an array that represents an arithmetic progression of integers. One number from the progression is removed, and the remaining elements are shuffled. Write a function to find the missing number.\n\n###Code:\n\n```python\ndef findMissingNumber(arr: List[int]) -> int:\n    n = len(arr) + 1\n    total_sum = (n * (arr[0] + arr[-1])) // 2\n    current_sum = sum(arr)\n    return total_sum - current_sum\n```\n\n###Testcases:\n\n```python\nassert findMissingNumber([1, 3, 5, 9, 7]) == 11\nassert findMissingNumber([2, 4, 8, 12, 16, 20]) == 10\nassert findMissingNumber([10, 20, 30, 40]) == 0\nassert findMissingNumber([5, 15, 25, 35, 45, 55, 65]) == 20\nassert findMissingNumber([100, 150, 250, 350]) == 200\nassert findMissingNumber([3, 9, 15, 27, 21]) == 18\nassert findMissingNumber([11, 22, 44, 66, 88]) == 33\nassert findMissingNumber([1, 4, 7, 13, 16]) == 10\nassert findMissingNumber([55, 33, 11]) == 77\nassert findMissingNumber([2, 6, 10, 18, 14]) == 22\nassert findMissingNumber([91, 73, 109, 55, 127]) == 91\nassert findMissingNumber([5, 25, 15, 35, 45]) == 55\nassert findMissingNumber([8, 4, 0]) == 12\n```\n\n[/Example 3]", "temperature": 0.784}, {"few_shots": [{"author": "Hafeez", "UUID": "df98fd29-db88-4de7-a00a-0a3bd5ba1539", "question": "Word Pattern: Given a pattern and a string s, find if s follows the same pattern.\n\nHere follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in s.", "examples": "Input: pattern = \"abba\", s = \"dog cat cat fish\"\nOutput: false\nInput: pattern = \"aaaa\", s = \"dog cat cat dog\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def wordPattern(pattern: str, s: str) -> bool:\n    map_char = {}\n    map_word = {}\n    \n    words = s.split(' ')\n    if len(words) != len(pattern):\n        return False\n    \n    for c, w in zip(pattern, words):\n        if c not in map_char:\n            if w in map_word:\n                return False\n            else:\n                map_char[c] = w\n                map_word[w] = c\n        else:\n            if map_char[c] != w:\n                return False\n    return True", "asserts": ["assert wordPattern(\"abba\", \"dog cat cat dog\")==True", "assert wordPattern(\"aaaa\", \"dog dog dog dog\") == True", "assert wordPattern(\"xyz\", \"apple banana apple\") == False", "assert wordPattern(\"xyx\", \"apple banana apple\") == True", "assert wordPattern(\"abab\", \"dog cat dog cat\") == True", "assert wordPattern(\"aaaa\", \"dog dog dog cat\") == False", "assert wordPattern(\"aabb\", \"dog dog cat cat\") == True", "assert wordPattern(\"abc\", \"dog\") == False  # Not enough words", "assert wordPattern(\"\", \"dog cat\") == False  # Empty pattern", "assert wordPattern(\"a\", \"dog cat dog cat\") == False  # Not enough pattern characters", "assert wordPattern(\"ab\", \"\") == False  # Empty string", "assert wordPattern(\"abb\", \"dog dog dog\") == False  # Same word for different pattern characters", "assert wordPattern(\"abba\", \"dog cat cat\") == False  # Not enough words for the pattern", "assert wordPattern(\"abba\", \"dog cat cat dog fish\") == False  # Extra words beyond the pattern length"]}, {"author": "Hafeez", "UUID": "effcb732-1f0d-4caa-8d9f-be914708d4ae", "question": "Repeated Substring Pattern: Given a string s, check if it can be constructed by taking a substring of it and appending multiple copies of the substring together.", "examples": "Input: s = \"aba\"\nOutput: false\nExplanation: It is the substring \"ab\" twice.\nInput: s = \"abcabcabcabc\"\nOutput: true\nExplanation: It is the substring \"abc\" four times or the substring \"abcabc\" twice.", "link": "https://leetcode.com/problems/repeated-substring-pattern/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def repeatedSubstringPattern(s: str) -> bool:\n    n = len(s)\n    for i in range(1, n // 2 + 1):\n        if n % i == 0:\n            pattern = s[:i] * (n // i)\n            if s == pattern:\n                return True\n    return False", "asserts": ["assert repeatedSubstringPattern(\"abab\")==True", "assert repeatedSubstringPattern(\"aaaa\") == True", "assert repeatedSubstringPattern(\"abac\") == False", "assert repeatedSubstringPattern(\"ababab\") == True", "assert repeatedSubstringPattern(\"xyzxyzxyz\") == True", "assert repeatedSubstringPattern(\"aaabaaa\") == False", "assert repeatedSubstringPattern(\"abababab\") == True", "assert repeatedSubstringPattern(\"abcabcab\") == False", "assert repeatedSubstringPattern(\"abbaabba\") == True", "assert repeatedSubstringPattern(\"\") == False", "assert repeatedSubstringPattern(\"a\") == False", "assert repeatedSubstringPattern(\"abacababacab\") == True"]}], "category": "Pattern", "prompt_tokens": 854, "total_tokens": 1178, "completion_tokens": 324, "completion": "Given a binary pattern, check if the string follows a specific pattern.\n\nA binary pattern consists of only 0's and 1's. The goal is to check if the string follows a specific pattern defined by the positions of 0's and 1's.\n\n###Code:\n\n```python\ndef binaryPatternMatching(pattern: str, s: str) -> bool:\n    pattern_dict = {}\n    word_dict = {}\n    \n    words = s.split(' ')\n    if len(words) != len(pattern):\n        return False\n    \n    for p, w in zip(pattern, words):\n        if p not in pattern_dict:\n            if w in word_dict:\n                return False\n            else:\n                pattern_dict[p] = w\n                word_dict[w] = p\n        else:\n            if pattern_dict[p] != w:\n                return False\n    return True\n```\n\n###Testcases:\n\n```python\nassert binaryPatternMatching(\"010\", \"hello world hello\")==True\nassert binaryPatternMatching(\"110\", \"hello world world\")==True\nassert binaryPatternMatching(\"101\", \"hello world hello\")==False\nassert binaryPatternMatching(\"11\", \"hello hello\")==False\nassert binaryPatternMatching(\"00\", \"world world\")==True\nassert binaryPatternMatching(\"110\", \"hello world hello\")==True\nassert binaryPatternMatching(\"0101\", \"hello world world hello\")==True\nassert binaryPatternMatching(\"0101\", \"hello world hello world\")==False\nassert binaryPatternMatching(\"10\", \"hello world\")==True\nassert binaryPatternMatching(\"01\", \"world hello\")==True\n```", "temperature": 0.877}, {"few_shots": [{"author": "Hafeez", "UUID": "df98fd29-db88-4de7-a00a-0a3bd5ba1539", "question": "Word Pattern: Given a pattern and a string s, find if s follows the same pattern.\n\nHere follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in s.", "examples": "Input: pattern = \"abba\", s = \"dog cat cat fish\"\nOutput: false\nInput: pattern = \"aaaa\", s = \"dog cat cat dog\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def wordPattern(pattern: str, s: str) -> bool:\n    map_char = {}\n    map_word = {}\n    \n    words = s.split(' ')\n    if len(words) != len(pattern):\n        return False\n    \n    for c, w in zip(pattern, words):\n        if c not in map_char:\n            if w in map_word:\n                return False\n            else:\n                map_char[c] = w\n                map_word[w] = c\n        else:\n            if map_char[c] != w:\n                return False\n    return True", "asserts": ["assert wordPattern(\"abba\", \"dog cat cat dog\")==True", "assert wordPattern(\"aaaa\", \"dog dog dog dog\") == True", "assert wordPattern(\"xyz\", \"apple banana apple\") == False", "assert wordPattern(\"xyx\", \"apple banana apple\") == True", "assert wordPattern(\"abab\", \"dog cat dog cat\") == True", "assert wordPattern(\"aaaa\", \"dog dog dog cat\") == False", "assert wordPattern(\"aabb\", \"dog dog cat cat\") == True", "assert wordPattern(\"abc\", \"dog\") == False  # Not enough words", "assert wordPattern(\"\", \"dog cat\") == False  # Empty pattern", "assert wordPattern(\"a\", \"dog cat dog cat\") == False  # Not enough pattern characters", "assert wordPattern(\"ab\", \"\") == False  # Empty string", "assert wordPattern(\"abb\", \"dog dog dog\") == False  # Same word for different pattern characters", "assert wordPattern(\"abba\", \"dog cat cat\") == False  # Not enough words for the pattern", "assert wordPattern(\"abba\", \"dog cat cat dog fish\") == False  # Extra words beyond the pattern length"]}, {"author": "Hafeez", "UUID": "effcb732-1f0d-4caa-8d9f-be914708d4ae", "question": "Repeated Substring Pattern: Given a string s, check if it can be constructed by taking a substring of it and appending multiple copies of the substring together.", "examples": "Input: s = \"aba\"\nOutput: false\nExplanation: It is the substring \"ab\" twice.\nInput: s = \"abcabcabcabc\"\nOutput: true\nExplanation: It is the substring \"abc\" four times or the substring \"abcabc\" twice.", "link": "https://leetcode.com/problems/repeated-substring-pattern/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def repeatedSubstringPattern(s: str) -> bool:\n    n = len(s)\n    for i in range(1, n // 2 + 1):\n        if n % i == 0:\n            pattern = s[:i] * (n // i)\n            if s == pattern:\n                return True\n    return False", "asserts": ["assert repeatedSubstringPattern(\"abab\")==True", "assert repeatedSubstringPattern(\"aaaa\") == True", "assert repeatedSubstringPattern(\"abac\") == False", "assert repeatedSubstringPattern(\"ababab\") == True", "assert repeatedSubstringPattern(\"xyzxyzxyz\") == True", "assert repeatedSubstringPattern(\"aaabaaa\") == False", "assert repeatedSubstringPattern(\"abababab\") == True", "assert repeatedSubstringPattern(\"abcabcab\") == False", "assert repeatedSubstringPattern(\"abbaabba\") == True", "assert repeatedSubstringPattern(\"\") == False", "assert repeatedSubstringPattern(\"a\") == False", "assert repeatedSubstringPattern(\"abacababacab\") == True"]}], "category": "Pattern", "prompt_tokens": 854, "total_tokens": 1222, "completion_tokens": 368, "completion": "Find All Anagrams in a String: Given a string s and a non-empty string p, find all the start indices of p's anagrams in s.\n\n###Code: \n\n```python\nfrom collections import Counter\n\ndef findAnagrams(s: str, p: str):\n    result = []\n    p_count = Counter(p)\n    s_count = Counter(s[:len(p)-1])\n    \n    for i in range(len(p)-1, len(s)):\n        s_count[s[i]] += 1\n        if s_count == p_count:\n            result.append(i-len(p)+1)\n        s_count[s[i-len(p)+1]] -= 1\n        if s_count[s[i-len(p)+1]] == 0:\n            del s_count[s[i-len(p)+1]]\n            \n    return result\n```\n\n###Testcases: \n\n```python\nassert findAnagrams(\"cbaebabacd\", \"abc\") == [0, 6]\nassert findAnagrams(\"abab\", \"ab\") == [0, 1, 2]\nassert findAnagrams(\"aaaaa\", \"a\") == [0, 1, 2, 3, 4]\nassert findAnagrams(\"abac\", \"abc\") == [1]\nassert findAnagrams(\"aabbcc\", \"abc\") == [0]\nassert findAnagrams(\"abababab\", \"ab\") == [0, 1, 2, 3, 4, 5, 6]\nassert findAnagrams(\"xyzxyz\", \"xyz\") == [0, 3]\nassert findAnagrams(\"hello\", \"world\") == []\nassert findAnagrams(\"aaa\", \"aaaa\") == []\nassert findAnagrams(\"\", \"abc\") == []\n```\n\n[/Example 3]", "temperature": 0.63}, {"few_shots": [{"author": "Hafeez", "UUID": "df98fd29-db88-4de7-a00a-0a3bd5ba1539", "question": "Word Pattern: Given a pattern and a string s, find if s follows the same pattern.\n\nHere follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in s.", "examples": "Input: pattern = \"abba\", s = \"dog cat cat fish\"\nOutput: false\nInput: pattern = \"aaaa\", s = \"dog cat cat dog\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def wordPattern(pattern: str, s: str) -> bool:\n    map_char = {}\n    map_word = {}\n    \n    words = s.split(' ')\n    if len(words) != len(pattern):\n        return False\n    \n    for c, w in zip(pattern, words):\n        if c not in map_char:\n            if w in map_word:\n                return False\n            else:\n                map_char[c] = w\n                map_word[w] = c\n        else:\n            if map_char[c] != w:\n                return False\n    return True", "asserts": ["assert wordPattern(\"abba\", \"dog cat cat dog\")==True", "assert wordPattern(\"aaaa\", \"dog dog dog dog\") == True", "assert wordPattern(\"xyz\", \"apple banana apple\") == False", "assert wordPattern(\"xyx\", \"apple banana apple\") == True", "assert wordPattern(\"abab\", \"dog cat dog cat\") == True", "assert wordPattern(\"aaaa\", \"dog dog dog cat\") == False", "assert wordPattern(\"aabb\", \"dog dog cat cat\") == True", "assert wordPattern(\"abc\", \"dog\") == False  # Not enough words", "assert wordPattern(\"\", \"dog cat\") == False  # Empty pattern", "assert wordPattern(\"a\", \"dog cat dog cat\") == False  # Not enough pattern characters", "assert wordPattern(\"ab\", \"\") == False  # Empty string", "assert wordPattern(\"abb\", \"dog dog dog\") == False  # Same word for different pattern characters", "assert wordPattern(\"abba\", \"dog cat cat\") == False  # Not enough words for the pattern", "assert wordPattern(\"abba\", \"dog cat cat dog fish\") == False  # Extra words beyond the pattern length"]}, {"author": "Hafeez", "UUID": "effcb732-1f0d-4caa-8d9f-be914708d4ae", "question": "Repeated Substring Pattern: Given a string s, check if it can be constructed by taking a substring of it and appending multiple copies of the substring together.", "examples": "Input: s = \"aba\"\nOutput: false\nExplanation: It is the substring \"ab\" twice.\nInput: s = \"abcabcabcabc\"\nOutput: true\nExplanation: It is the substring \"abc\" four times or the substring \"abcabc\" twice.", "link": "https://leetcode.com/problems/repeated-substring-pattern/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def repeatedSubstringPattern(s: str) -> bool:\n    n = len(s)\n    for i in range(1, n // 2 + 1):\n        if n % i == 0:\n            pattern = s[:i] * (n // i)\n            if s == pattern:\n                return True\n    return False", "asserts": ["assert repeatedSubstringPattern(\"abab\")==True", "assert repeatedSubstringPattern(\"aaaa\") == True", "assert repeatedSubstringPattern(\"abac\") == False", "assert repeatedSubstringPattern(\"ababab\") == True", "assert repeatedSubstringPattern(\"xyzxyzxyz\") == True", "assert repeatedSubstringPattern(\"aaabaaa\") == False", "assert repeatedSubstringPattern(\"abababab\") == True", "assert repeatedSubstringPattern(\"abcabcab\") == False", "assert repeatedSubstringPattern(\"abbaabba\") == True", "assert repeatedSubstringPattern(\"\") == False", "assert repeatedSubstringPattern(\"a\") == False", "assert repeatedSubstringPattern(\"abacababacab\") == True"]}], "category": "Pattern", "prompt_tokens": 854, "total_tokens": 1350, "completion_tokens": 496, "completion": "Missing Number: Given an array containing n distinct numbers taken from 0, 1, 2, ..., n, find the one that is missing from the array.\n\n###Code: \n\n```python\ndef missingNumber(nums: List[int]) -> int:\n    n = len(nums)\n    expected_sum = n * (n + 1) // 2\n    actual_sum = sum(nums)\n    return expected_sum - actual_sum\n```\n\n###Testcases: \n\n```python\nassert missingNumber([3, 0, 1]) == 2\nassert missingNumber([9, 6, 4, 2, 3, 5, 7, 0, 1]) == 8\nassert missingNumber([0, 1]) == 2\nassert missingNumber([0]) == 1\nassert missingNumber([1]) == 0\nassert missingNumber([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100]) == 0\n```\n\n[/Example 3]", "temperature": 0.613}, {"few_shots": [{"author": "Hafeez", "UUID": "df98fd29-db88-4de7-a00a-0a3bd5ba1539", "question": "Word Pattern: Given a pattern and a string s, find if s follows the same pattern.\n\nHere follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in s.", "examples": "Input: pattern = \"abba\", s = \"dog cat cat fish\"\nOutput: false\nInput: pattern = \"aaaa\", s = \"dog cat cat dog\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def wordPattern(pattern: str, s: str) -> bool:\n    map_char = {}\n    map_word = {}\n    \n    words = s.split(' ')\n    if len(words) != len(pattern):\n        return False\n    \n    for c, w in zip(pattern, words):\n        if c not in map_char:\n            if w in map_word:\n                return False\n            else:\n                map_char[c] = w\n                map_word[w] = c\n        else:\n            if map_char[c] != w:\n                return False\n    return True", "asserts": ["assert wordPattern(\"abba\", \"dog cat cat dog\")==True", "assert wordPattern(\"aaaa\", \"dog dog dog dog\") == True", "assert wordPattern(\"xyz\", \"apple banana apple\") == False", "assert wordPattern(\"xyx\", \"apple banana apple\") == True", "assert wordPattern(\"abab\", \"dog cat dog cat\") == True", "assert wordPattern(\"aaaa\", \"dog dog dog cat\") == False", "assert wordPattern(\"aabb\", \"dog dog cat cat\") == True", "assert wordPattern(\"abc\", \"dog\") == False  # Not enough words", "assert wordPattern(\"\", \"dog cat\") == False  # Empty pattern", "assert wordPattern(\"a\", \"dog cat dog cat\") == False  # Not enough pattern characters", "assert wordPattern(\"ab\", \"\") == False  # Empty string", "assert wordPattern(\"abb\", \"dog dog dog\") == False  # Same word for different pattern characters", "assert wordPattern(\"abba\", \"dog cat cat\") == False  # Not enough words for the pattern", "assert wordPattern(\"abba\", \"dog cat cat dog fish\") == False  # Extra words beyond the pattern length"]}, {"author": "Hafeez", "UUID": "effcb732-1f0d-4caa-8d9f-be914708d4ae", "question": "Repeated Substring Pattern: Given a string s, check if it can be constructed by taking a substring of it and appending multiple copies of the substring together.", "examples": "Input: s = \"aba\"\nOutput: false\nExplanation: It is the substring \"ab\" twice.\nInput: s = \"abcabcabcabc\"\nOutput: true\nExplanation: It is the substring \"abc\" four times or the substring \"abcabc\" twice.", "link": "https://leetcode.com/problems/repeated-substring-pattern/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def repeatedSubstringPattern(s: str) -> bool:\n    n = len(s)\n    for i in range(1, n // 2 + 1):\n        if n % i == 0:\n            pattern = s[:i] * (n // i)\n            if s == pattern:\n                return True\n    return False", "asserts": ["assert repeatedSubstringPattern(\"abab\")==True", "assert repeatedSubstringPattern(\"aaaa\") == True", "assert repeatedSubstringPattern(\"abac\") == False", "assert repeatedSubstringPattern(\"ababab\") == True", "assert repeatedSubstringPattern(\"xyzxyzxyz\") == True", "assert repeatedSubstringPattern(\"aaabaaa\") == False", "assert repeatedSubstringPattern(\"abababab\") == True", "assert repeatedSubstringPattern(\"abcabcab\") == False", "assert repeatedSubstringPattern(\"abbaabba\") == True", "assert repeatedSubstringPattern(\"\") == False", "assert repeatedSubstringPattern(\"a\") == False", "assert repeatedSubstringPattern(\"abacababacab\") == True"]}], "category": "Pattern", "prompt_tokens": 854, "total_tokens": 1285, "completion_tokens": 431, "completion": "Find All Anagrams in a String: Given a string s and a non-empty string p, find all the start indices of p's anagrams in s.\n\n###Code: \n\n```python\nfrom collections import Counter\n\ndef findAnagrams(s: str, p: str):\n    result = []\n    p_count = Counter(p)\n    s_count = Counter(s[:len(p)-1])\n    \n    for i in range(len(p)-1, len(s)):\n        s_count[s[i]] += 1\n        if s_count == p_count:\n            result.append(i-len(p)+1)\n        s_count[s[i-len(p)+1]] -= 1\n        if s_count[s[i-len(p)+1]] == 0:\n            del s_count[s[i-len(p)+1]]\n    return result\n```\n\n###Testcases: \n\n```python\nassert findAnagrams(\"cbaebabacd\", \"abc\") == [0, 6]\nassert findAnagrams(\"abab\", \"ab\") == [0, 1, 2]\nassert findAnagrams(\"aaaaa\", \"a\") == [0, 1, 2, 3, 4]\nassert findAnagrams(\"abac\", \"ab\") == [0]\nassert findAnagrams(\"xyzxyzxyz\", \"xyz\") == [0, 3, 6]\nassert findAnagrams(\"aaabaaa\", \"aaa\") == [1, 2, 3, 5]\nassert findAnagrams(\"abababab\", \"ab\") == [0, 2, 4, 6]\nassert findAnagrams(\"abcabcab\", \"abc\") == [0, 3]\nassert findAnagrams(\"abbaabba\", \"ab\") == [0, 1, 4, 5]\nassert findAnagrams(\"\", \"a\") == []\nassert findAnagrams(\"a\", \"a\") == [0]\nassert findAnagrams(\"abacababacab\", \"abc\") == [2, 6, 10]\n```\n\n[/Example 3]", "temperature": 0.687}, {"few_shots": [{"author": "Hafeez", "UUID": "df98fd29-db88-4de7-a00a-0a3bd5ba1539", "question": "Word Pattern: Given a pattern and a string s, find if s follows the same pattern.\n\nHere follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in s.", "examples": "Input: pattern = \"abba\", s = \"dog cat cat fish\"\nOutput: false\nInput: pattern = \"aaaa\", s = \"dog cat cat dog\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def wordPattern(pattern: str, s: str) -> bool:\n    map_char = {}\n    map_word = {}\n    \n    words = s.split(' ')\n    if len(words) != len(pattern):\n        return False\n    \n    for c, w in zip(pattern, words):\n        if c not in map_char:\n            if w in map_word:\n                return False\n            else:\n                map_char[c] = w\n                map_word[w] = c\n        else:\n            if map_char[c] != w:\n                return False\n    return True", "asserts": ["assert wordPattern(\"abba\", \"dog cat cat dog\")==True", "assert wordPattern(\"aaaa\", \"dog dog dog dog\") == True", "assert wordPattern(\"xyz\", \"apple banana apple\") == False", "assert wordPattern(\"xyx\", \"apple banana apple\") == True", "assert wordPattern(\"abab\", \"dog cat dog cat\") == True", "assert wordPattern(\"aaaa\", \"dog dog dog cat\") == False", "assert wordPattern(\"aabb\", \"dog dog cat cat\") == True", "assert wordPattern(\"abc\", \"dog\") == False  # Not enough words", "assert wordPattern(\"\", \"dog cat\") == False  # Empty pattern", "assert wordPattern(\"a\", \"dog cat dog cat\") == False  # Not enough pattern characters", "assert wordPattern(\"ab\", \"\") == False  # Empty string", "assert wordPattern(\"abb\", \"dog dog dog\") == False  # Same word for different pattern characters", "assert wordPattern(\"abba\", \"dog cat cat\") == False  # Not enough words for the pattern", "assert wordPattern(\"abba\", \"dog cat cat dog fish\") == False  # Extra words beyond the pattern length"]}, {"author": "Hafeez", "UUID": "e811f9cc-fa5e-4ea0-8adb-8cf3ab7c72db", "question": "Detect Pattern of Length M Repeated K or More Times: Given an array of positive integers arr, find a pattern of length m that is repeated k or more times.\n\nA pattern is a subarray (consecutive sub-sequence) that consists of one or more values, repeated multiple times consecutively without overlapping. A pattern is defined by its length and the number of repetitions.\n\nReturn true if there exists a pattern of length m that is repeated k or more times, otherwise return false.", "examples": "Input: arr = [1,2,1,2,1,1,1,3], m = 2, k = 2\nOutput: true\nExplanation: The pattern (1,2) of length 2 is repeated 2 consecutive times. Another valid pattern (2,1) is also repeated 2 times.\nInput: arr = [1,2,1,2,1,3], m = 2, k = 3\nOutput: false\nExplanation: The pattern (1,2) is of length 2 but is repeated only 2 times. There is no pattern of length 2 that is repeated 3 or more times.\n", "link": "https://leetcode.com/problems/detect-pattern-of-length-m-repeated-k-or-more-times/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "from typing import List\ndef containsPattern(arr: List[int], m: int, k: int) -> bool:\n    i = 0\n    while i <= len(arr)-1:\n            p = arr[i:i+m]\n            if p * k == arr[i:i+m*k]:\n                    return True\n            i += 1\n    return False", "asserts": ["assert containsPattern([1,2,4,4,4,4],1,3)==True", "assert containsPattern([1,2,3,1,2,3,1,2,3], 3, 3) == True", "assert containsPattern([1,1,1,2,2,2,3,3], 2, 2) == False", "assert containsPattern([5,5,5,5,5,5,5], 1, 6) == True", "assert containsPattern([1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2], 2, 5) == True", "assert containsPattern([10,100,10,100,10,100,10,10,10,100], 2, 4) == False", "assert containsPattern([3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3], 4, 3) == True"]}], "category": "Pattern", "prompt_tokens": 1020, "total_tokens": 1418, "completion_tokens": 398, "completion": "Detect Arithmetic Slices: A sequence of numbers is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.\n\nFor example, these are arithmetic sequences:\n- 1, 3, 5, 7, 9\n- 7, 7, 7, 7\n- 3, -1, -5, -9\n\nThe function should return the number of arithmetic slices in the array.\n\n###Code: \n\nfrom typing import List\ndef numberOfArithmeticSlices(nums: List[int]) -> int:\n    count = 0\n    total = 0\n    for i in range(2, len(nums)):\n        if nums[i] - nums[i-1] == nums[i-1] - nums[i-2]:\n            count += 1\n            total += count\n        else:\n            count = 0\n    return total\n\n###Testcases: \n\nassert numberOfArithmeticSlices([1, 2, 3, 4]) == 3\nassert numberOfArithmeticSlices([1, 2, 3, 4, 5]) == 6\nassert numberOfArithmeticSlices([1, 2, 3, 5, 7, 9]) == 2\nassert numberOfArithmeticSlices([1, 2, 3, 4, 7, 10, 13]) == 3\nassert numberOfArithmeticSlices([3, 6, 9, 12, 15]) == 6\nassert numberOfArithmeticSlices([1, 2, 3, 4, 5, 10, 15, 20]) == 5\nassert numberOfArithmeticSlices([1, 2, 3, 4, 7, 11, 15, 19]) == 4\n\n[/Example 3]", "temperature": 0.615}, {"few_shots": [{"author": "Hafeez", "UUID": "df98fd29-db88-4de7-a00a-0a3bd5ba1539", "question": "Word Pattern: Given a pattern and a string s, find if s follows the same pattern.\n\nHere follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in s.", "examples": "Input: pattern = \"abba\", s = \"dog cat cat fish\"\nOutput: false\nInput: pattern = \"aaaa\", s = \"dog cat cat dog\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def wordPattern(pattern: str, s: str) -> bool:\n    map_char = {}\n    map_word = {}\n    \n    words = s.split(' ')\n    if len(words) != len(pattern):\n        return False\n    \n    for c, w in zip(pattern, words):\n        if c not in map_char:\n            if w in map_word:\n                return False\n            else:\n                map_char[c] = w\n                map_word[w] = c\n        else:\n            if map_char[c] != w:\n                return False\n    return True", "asserts": ["assert wordPattern(\"abba\", \"dog cat cat dog\")==True", "assert wordPattern(\"aaaa\", \"dog dog dog dog\") == True", "assert wordPattern(\"xyz\", \"apple banana apple\") == False", "assert wordPattern(\"xyx\", \"apple banana apple\") == True", "assert wordPattern(\"abab\", \"dog cat dog cat\") == True", "assert wordPattern(\"aaaa\", \"dog dog dog cat\") == False", "assert wordPattern(\"aabb\", \"dog dog cat cat\") == True", "assert wordPattern(\"abc\", \"dog\") == False  # Not enough words", "assert wordPattern(\"\", \"dog cat\") == False  # Empty pattern", "assert wordPattern(\"a\", \"dog cat dog cat\") == False  # Not enough pattern characters", "assert wordPattern(\"ab\", \"\") == False  # Empty string", "assert wordPattern(\"abb\", \"dog dog dog\") == False  # Same word for different pattern characters", "assert wordPattern(\"abba\", \"dog cat cat\") == False  # Not enough words for the pattern", "assert wordPattern(\"abba\", \"dog cat cat dog fish\") == False  # Extra words beyond the pattern length"]}, {"author": "Hafeez", "UUID": "e811f9cc-fa5e-4ea0-8adb-8cf3ab7c72db", "question": "Detect Pattern of Length M Repeated K or More Times: Given an array of positive integers arr, find a pattern of length m that is repeated k or more times.\n\nA pattern is a subarray (consecutive sub-sequence) that consists of one or more values, repeated multiple times consecutively without overlapping. A pattern is defined by its length and the number of repetitions.\n\nReturn true if there exists a pattern of length m that is repeated k or more times, otherwise return false.", "examples": "Input: arr = [1,2,1,2,1,1,1,3], m = 2, k = 2\nOutput: true\nExplanation: The pattern (1,2) of length 2 is repeated 2 consecutive times. Another valid pattern (2,1) is also repeated 2 times.\nInput: arr = [1,2,1,2,1,3], m = 2, k = 3\nOutput: false\nExplanation: The pattern (1,2) is of length 2 but is repeated only 2 times. There is no pattern of length 2 that is repeated 3 or more times.\n", "link": "https://leetcode.com/problems/detect-pattern-of-length-m-repeated-k-or-more-times/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "from typing import List\ndef containsPattern(arr: List[int], m: int, k: int) -> bool:\n    i = 0\n    while i <= len(arr)-1:\n            p = arr[i:i+m]\n            if p * k == arr[i:i+m*k]:\n                    return True\n            i += 1\n    return False", "asserts": ["assert containsPattern([1,2,4,4,4,4],1,3)==True", "assert containsPattern([1,2,3,1,2,3,1,2,3], 3, 3) == True", "assert containsPattern([1,1,1,2,2,2,3,3], 2, 2) == False", "assert containsPattern([5,5,5,5,5,5,5], 1, 6) == True", "assert containsPattern([1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2], 2, 5) == True", "assert containsPattern([10,100,10,100,10,100,10,10,10,100], 2, 4) == False", "assert containsPattern([3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3], 4, 3) == True"]}], "category": "Pattern", "prompt_tokens": 1020, "total_tokens": 1321, "completion_tokens": 301, "completion": "Find All Anagrams in a String: Given a string s and a non-empty string p, find all the start indices of p's anagrams in s.\n\nStrings consists of lowercase English letters only.\n\n###Code: \n\nfrom typing import List\ndef findAnagrams(s: str, p: str) -> List[int]:\n    result = []\n    window_size = len(p)\n    p_count = [0] * 26\n    s_count = [0] * 26\n    \n    for char in p:\n        p_count[ord(char) - ord('a')] += 1\n        \n    for i in range(len(s)):\n        s_count[ord(s[i]) - ord('a')] += 1\n        if i >= window_size:\n            s_count[ord(s[i - window_size]) - ord('a')] -= 1\n        if s_count == p_count:\n            result.append(i - window_size + 1)\n    \n    return result\n\n###Testcases: \n\nassert findAnagrams(\"cbaebabacd\", \"abc\") == [0, 6]\nassert findAnagrams(\"abab\", \"ab\") == [0, 1, 2]\nassert findAnagrams(\"baa\", \"aa\") == [1]\nassert findAnagrams(\"aaaaa\", \"a\") == [0, 1, 2, 3, 4]\nassert findAnagrams(\"abc\", \"def\") == []\n\n[/Example 3]", "temperature": 0.611}, {"few_shots": [{"author": "Hafeez", "UUID": "df98fd29-db88-4de7-a00a-0a3bd5ba1539", "question": "Word Pattern: Given a pattern and a string s, find if s follows the same pattern.\n\nHere follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in s.", "examples": "Input: pattern = \"abba\", s = \"dog cat cat fish\"\nOutput: false\nInput: pattern = \"aaaa\", s = \"dog cat cat dog\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def wordPattern(pattern: str, s: str) -> bool:\n    map_char = {}\n    map_word = {}\n    \n    words = s.split(' ')\n    if len(words) != len(pattern):\n        return False\n    \n    for c, w in zip(pattern, words):\n        if c not in map_char:\n            if w in map_word:\n                return False\n            else:\n                map_char[c] = w\n                map_word[w] = c\n        else:\n            if map_char[c] != w:\n                return False\n    return True", "asserts": ["assert wordPattern(\"abba\", \"dog cat cat dog\")==True", "assert wordPattern(\"aaaa\", \"dog dog dog dog\") == True", "assert wordPattern(\"xyz\", \"apple banana apple\") == False", "assert wordPattern(\"xyx\", \"apple banana apple\") == True", "assert wordPattern(\"abab\", \"dog cat dog cat\") == True", "assert wordPattern(\"aaaa\", \"dog dog dog cat\") == False", "assert wordPattern(\"aabb\", \"dog dog cat cat\") == True", "assert wordPattern(\"abc\", \"dog\") == False  # Not enough words", "assert wordPattern(\"\", \"dog cat\") == False  # Empty pattern", "assert wordPattern(\"a\", \"dog cat dog cat\") == False  # Not enough pattern characters", "assert wordPattern(\"ab\", \"\") == False  # Empty string", "assert wordPattern(\"abb\", \"dog dog dog\") == False  # Same word for different pattern characters", "assert wordPattern(\"abba\", \"dog cat cat\") == False  # Not enough words for the pattern", "assert wordPattern(\"abba\", \"dog cat cat dog fish\") == False  # Extra words beyond the pattern length"]}, {"author": "Hafeez", "UUID": "e811f9cc-fa5e-4ea0-8adb-8cf3ab7c72db", "question": "Detect Pattern of Length M Repeated K or More Times: Given an array of positive integers arr, find a pattern of length m that is repeated k or more times.\n\nA pattern is a subarray (consecutive sub-sequence) that consists of one or more values, repeated multiple times consecutively without overlapping. A pattern is defined by its length and the number of repetitions.\n\nReturn true if there exists a pattern of length m that is repeated k or more times, otherwise return false.", "examples": "Input: arr = [1,2,1,2,1,1,1,3], m = 2, k = 2\nOutput: true\nExplanation: The pattern (1,2) of length 2 is repeated 2 consecutive times. Another valid pattern (2,1) is also repeated 2 times.\nInput: arr = [1,2,1,2,1,3], m = 2, k = 3\nOutput: false\nExplanation: The pattern (1,2) is of length 2 but is repeated only 2 times. There is no pattern of length 2 that is repeated 3 or more times.\n", "link": "https://leetcode.com/problems/detect-pattern-of-length-m-repeated-k-or-more-times/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "from typing import List\ndef containsPattern(arr: List[int], m: int, k: int) -> bool:\n    i = 0\n    while i <= len(arr)-1:\n            p = arr[i:i+m]\n            if p * k == arr[i:i+m*k]:\n                    return True\n            i += 1\n    return False", "asserts": ["assert containsPattern([1,2,4,4,4,4],1,3)==True", "assert containsPattern([1,2,3,1,2,3,1,2,3], 3, 3) == True", "assert containsPattern([1,1,1,2,2,2,3,3], 2, 2) == False", "assert containsPattern([5,5,5,5,5,5,5], 1, 6) == True", "assert containsPattern([1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2], 2, 5) == True", "assert containsPattern([10,100,10,100,10,100,10,10,10,100], 2, 4) == False", "assert containsPattern([3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3], 4, 3) == True"]}], "category": "Pattern", "prompt_tokens": 1020, "total_tokens": 1381, "completion_tokens": 361, "completion": "Detect Arithmetic Subsequence: Given an array of numbers arr, find whether there exists a subsequence of the array that forms an arithmetic sequence. Return true if any such subsequence exists, otherwise return false.\n\nAn arithmetic sequence is a sequence of numbers in which the difference between consecutive terms is constant. A subsequence of an array is a sequence that can be formed by removing some elements without changing the order of the remaining elements.\n\n###Code:\n\nfrom typing import List\ndef containsArithmeticSequence(arr: List[int]) -> bool:\n    n = len(arr)\n    if n < 3:\n        return False\n    \n    for i in range(n-2):\n        if arr[i+1] - arr[i] == arr[i+2] - arr[i+1]:\n            return True\n    return False\n\n###Testcases:\n\nassert containsArithmeticSequence([1, 2, 3, 4, 5])==True\nassert containsArithmeticSequence([7, 7, 7, 7])==True\nassert containsArithmeticSequence([3, 5, 7, 9])==True\nassert containsArithmeticSequence([1, 2, 4, 7, 10])==False\nassert containsArithmeticSequence([0, 0, 0, 0, 0])==True\nassert containsArithmeticSequence([1, 3, 5, 7, 9, 11])==True\nassert containsArithmeticSequence([1, 2])==False\nassert containsArithmeticSequence([5, 5, 5, 5, 5, 5, 5])==True\nassert containsArithmeticSequence([1, 2, 2, 4])==True\n\n[/Example 3]", "temperature": 0.897}, {"few_shots": [{"author": "Hafeez", "UUID": "df98fd29-db88-4de7-a00a-0a3bd5ba1539", "question": "Word Pattern: Given a pattern and a string s, find if s follows the same pattern.\n\nHere follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in s.", "examples": "Input: pattern = \"abba\", s = \"dog cat cat fish\"\nOutput: false\nInput: pattern = \"aaaa\", s = \"dog cat cat dog\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def wordPattern(pattern: str, s: str) -> bool:\n    map_char = {}\n    map_word = {}\n    \n    words = s.split(' ')\n    if len(words) != len(pattern):\n        return False\n    \n    for c, w in zip(pattern, words):\n        if c not in map_char:\n            if w in map_word:\n                return False\n            else:\n                map_char[c] = w\n                map_word[w] = c\n        else:\n            if map_char[c] != w:\n                return False\n    return True", "asserts": ["assert wordPattern(\"abba\", \"dog cat cat dog\")==True", "assert wordPattern(\"aaaa\", \"dog dog dog dog\") == True", "assert wordPattern(\"xyz\", \"apple banana apple\") == False", "assert wordPattern(\"xyx\", \"apple banana apple\") == True", "assert wordPattern(\"abab\", \"dog cat dog cat\") == True", "assert wordPattern(\"aaaa\", \"dog dog dog cat\") == False", "assert wordPattern(\"aabb\", \"dog dog cat cat\") == True", "assert wordPattern(\"abc\", \"dog\") == False  # Not enough words", "assert wordPattern(\"\", \"dog cat\") == False  # Empty pattern", "assert wordPattern(\"a\", \"dog cat dog cat\") == False  # Not enough pattern characters", "assert wordPattern(\"ab\", \"\") == False  # Empty string", "assert wordPattern(\"abb\", \"dog dog dog\") == False  # Same word for different pattern characters", "assert wordPattern(\"abba\", \"dog cat cat\") == False  # Not enough words for the pattern", "assert wordPattern(\"abba\", \"dog cat cat dog fish\") == False  # Extra words beyond the pattern length"]}, {"author": "Hafeez", "UUID": "e811f9cc-fa5e-4ea0-8adb-8cf3ab7c72db", "question": "Detect Pattern of Length M Repeated K or More Times: Given an array of positive integers arr, find a pattern of length m that is repeated k or more times.\n\nA pattern is a subarray (consecutive sub-sequence) that consists of one or more values, repeated multiple times consecutively without overlapping. A pattern is defined by its length and the number of repetitions.\n\nReturn true if there exists a pattern of length m that is repeated k or more times, otherwise return false.", "examples": "Input: arr = [1,2,1,2,1,1,1,3], m = 2, k = 2\nOutput: true\nExplanation: The pattern (1,2) of length 2 is repeated 2 consecutive times. Another valid pattern (2,1) is also repeated 2 times.\nInput: arr = [1,2,1,2,1,3], m = 2, k = 3\nOutput: false\nExplanation: The pattern (1,2) is of length 2 but is repeated only 2 times. There is no pattern of length 2 that is repeated 3 or more times.\n", "link": "https://leetcode.com/problems/detect-pattern-of-length-m-repeated-k-or-more-times/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "from typing import List\ndef containsPattern(arr: List[int], m: int, k: int) -> bool:\n    i = 0\n    while i <= len(arr)-1:\n            p = arr[i:i+m]\n            if p * k == arr[i:i+m*k]:\n                    return True\n            i += 1\n    return False", "asserts": ["assert containsPattern([1,2,4,4,4,4],1,3)==True", "assert containsPattern([1,2,3,1,2,3,1,2,3], 3, 3) == True", "assert containsPattern([1,1,1,2,2,2,3,3], 2, 2) == False", "assert containsPattern([5,5,5,5,5,5,5], 1, 6) == True", "assert containsPattern([1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2], 2, 5) == True", "assert containsPattern([10,100,10,100,10,100,10,10,10,100], 2, 4) == False", "assert containsPattern([3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3], 4, 3) == True"]}], "category": "Pattern", "prompt_tokens": 1020, "total_tokens": 1505, "completion_tokens": 485, "completion": "Detect Arithmetic Slices: A sequence of numbers is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.\n\nA slice is any sub-sequence of an array, contiguous and consisting of at least two elements. The difference between the first two elements of the sub-sequence is the same as the difference between the last two elements of the sub-sequence.\n\nWrite a function to return the number of arithmetic slices in the array.\n\n###Code: \n\nfrom typing import List\ndef numberOfArithmeticSlices(nums: List[int]) -> int:\n    count = 0\n    total = 0\n    for i in range(2, len(nums)):\n        if nums[i] - nums[i-1] == nums[i-1] - nums[i-2]:\n            count += 1\n            total += count\n        else:\n            count = 0\n    return total\n\n###Testcases: \n\nassert numberOfArithmeticSlices([1, 2, 3, 4]) == 3\nassert numberOfArithmeticSlices([1, 2, 3, 4, 5, 6]) == 10\nassert numberOfArithmeticSlices([1, 2, 3, 5, 7, 9]) == 1\nassert numberOfArithmeticSlices([7, 7, 7, 7]) == 3\nassert numberOfArithmeticSlices([3, 4, 5, 6, 7, 8, 9]) == 10\nassert numberOfArithmeticSlices([1, 2, 3, 5, 8, 10, 12]) == 2\nassert numberOfArithmeticSlices([1, 2, 3, 4, 5]) == 6\nassert numberOfArithmeticSlices([1, 2, 3, 4, 5, 10, 15, 20]) == 4\nassert numberOfArithmeticSlices([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == 28\nassert numberOfArithmeticSlices([2, 4, 6, 8, 10]) == 7\n\n[/Example 3]", "temperature": 0.702}, {"few_shots": [{"author": "Hafeez", "UUID": "df98fd29-db88-4de7-a00a-0a3bd5ba1539", "question": "Word Pattern: Given a pattern and a string s, find if s follows the same pattern.\n\nHere follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in s.", "examples": "Input: pattern = \"abba\", s = \"dog cat cat fish\"\nOutput: false\nInput: pattern = \"aaaa\", s = \"dog cat cat dog\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def wordPattern(pattern: str, s: str) -> bool:\n    map_char = {}\n    map_word = {}\n    \n    words = s.split(' ')\n    if len(words) != len(pattern):\n        return False\n    \n    for c, w in zip(pattern, words):\n        if c not in map_char:\n            if w in map_word:\n                return False\n            else:\n                map_char[c] = w\n                map_word[w] = c\n        else:\n            if map_char[c] != w:\n                return False\n    return True", "asserts": ["assert wordPattern(\"abba\", \"dog cat cat dog\")==True", "assert wordPattern(\"aaaa\", \"dog dog dog dog\") == True", "assert wordPattern(\"xyz\", \"apple banana apple\") == False", "assert wordPattern(\"xyx\", \"apple banana apple\") == True", "assert wordPattern(\"abab\", \"dog cat dog cat\") == True", "assert wordPattern(\"aaaa\", \"dog dog dog cat\") == False", "assert wordPattern(\"aabb\", \"dog dog cat cat\") == True", "assert wordPattern(\"abc\", \"dog\") == False  # Not enough words", "assert wordPattern(\"\", \"dog cat\") == False  # Empty pattern", "assert wordPattern(\"a\", \"dog cat dog cat\") == False  # Not enough pattern characters", "assert wordPattern(\"ab\", \"\") == False  # Empty string", "assert wordPattern(\"abb\", \"dog dog dog\") == False  # Same word for different pattern characters", "assert wordPattern(\"abba\", \"dog cat cat\") == False  # Not enough words for the pattern", "assert wordPattern(\"abba\", \"dog cat cat dog fish\") == False  # Extra words beyond the pattern length"]}, {"author": "Hafeez", "UUID": "e811f9cc-fa5e-4ea0-8adb-8cf3ab7c72db", "question": "Detect Pattern of Length M Repeated K or More Times: Given an array of positive integers arr, find a pattern of length m that is repeated k or more times.\n\nA pattern is a subarray (consecutive sub-sequence) that consists of one or more values, repeated multiple times consecutively without overlapping. A pattern is defined by its length and the number of repetitions.\n\nReturn true if there exists a pattern of length m that is repeated k or more times, otherwise return false.", "examples": "Input: arr = [1,2,1,2,1,1,1,3], m = 2, k = 2\nOutput: true\nExplanation: The pattern (1,2) of length 2 is repeated 2 consecutive times. Another valid pattern (2,1) is also repeated 2 times.\nInput: arr = [1,2,1,2,1,3], m = 2, k = 3\nOutput: false\nExplanation: The pattern (1,2) is of length 2 but is repeated only 2 times. There is no pattern of length 2 that is repeated 3 or more times.\n", "link": "https://leetcode.com/problems/detect-pattern-of-length-m-repeated-k-or-more-times/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "from typing import List\ndef containsPattern(arr: List[int], m: int, k: int) -> bool:\n    i = 0\n    while i <= len(arr)-1:\n            p = arr[i:i+m]\n            if p * k == arr[i:i+m*k]:\n                    return True\n            i += 1\n    return False", "asserts": ["assert containsPattern([1,2,4,4,4,4],1,3)==True", "assert containsPattern([1,2,3,1,2,3,1,2,3], 3, 3) == True", "assert containsPattern([1,1,1,2,2,2,3,3], 2, 2) == False", "assert containsPattern([5,5,5,5,5,5,5], 1, 6) == True", "assert containsPattern([1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2], 2, 5) == True", "assert containsPattern([10,100,10,100,10,100,10,10,10,100], 2, 4) == False", "assert containsPattern([3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3], 4, 3) == True"]}], "category": "Pattern", "prompt_tokens": 1020, "total_tokens": 1379, "completion_tokens": 359, "completion": "Find All Anagrams in a String: Given a string s and a non-empty string p, find all the start indices of p's anagrams in s.\n\nStrings consists of lowercase English letters only. The order of output does not matter.\n\n###Code: \n\nfrom typing import List\ndef findAnagrams(s: str, p: str) -> List[int]:\n        s_len, p_len = len(s), len(p)\n        if s_len < p_len:\n            return []\n        \n        p_count = [0] * 26\n        s_count = [0] * 26\n        result = []\n        \n        for i in range(p_len):\n            p_count[ord(p[i]) - ord('a')] += 1\n            s_count[ord(s[i]) - ord('a')] += 1\n        \n        if p_count == s_count:\n            result.append(0)\n        \n        for i in range(p_len, s_len):\n            s_count[ord(s[i]) - ord('a')] += 1\n            s_count[ord(s[i - p_len]) - ord('a')] -= 1\n            if p_count == s_count:\n                result.append(i - p_len + 1)\n        \n        return result\n\n###Testcases: \n\nassert findAnagrams(\"cbaebabacd\", \"abc\") == [0, 6]\nassert findAnagrams(\"abab\", \"ab\") == [0, 1, 2]\nassert findAnagrams(\"af\", \"be\") == []\nassert findAnagrams(\"aaaaaaaaaa\", \"a\") == [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n[/Example 3]", "temperature": 0.844}, {"few_shots": [{"author": "Hafeez", "UUID": "df98fd29-db88-4de7-a00a-0a3bd5ba1539", "question": "Word Pattern: Given a pattern and a string s, find if s follows the same pattern.\n\nHere follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in s.", "examples": "Input: pattern = \"abba\", s = \"dog cat cat fish\"\nOutput: false\nInput: pattern = \"aaaa\", s = \"dog cat cat dog\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def wordPattern(pattern: str, s: str) -> bool:\n    map_char = {}\n    map_word = {}\n    \n    words = s.split(' ')\n    if len(words) != len(pattern):\n        return False\n    \n    for c, w in zip(pattern, words):\n        if c not in map_char:\n            if w in map_word:\n                return False\n            else:\n                map_char[c] = w\n                map_word[w] = c\n        else:\n            if map_char[c] != w:\n                return False\n    return True", "asserts": ["assert wordPattern(\"abba\", \"dog cat cat dog\")==True", "assert wordPattern(\"aaaa\", \"dog dog dog dog\") == True", "assert wordPattern(\"xyz\", \"apple banana apple\") == False", "assert wordPattern(\"xyx\", \"apple banana apple\") == True", "assert wordPattern(\"abab\", \"dog cat dog cat\") == True", "assert wordPattern(\"aaaa\", \"dog dog dog cat\") == False", "assert wordPattern(\"aabb\", \"dog dog cat cat\") == True", "assert wordPattern(\"abc\", \"dog\") == False  # Not enough words", "assert wordPattern(\"\", \"dog cat\") == False  # Empty pattern", "assert wordPattern(\"a\", \"dog cat dog cat\") == False  # Not enough pattern characters", "assert wordPattern(\"ab\", \"\") == False  # Empty string", "assert wordPattern(\"abb\", \"dog dog dog\") == False  # Same word for different pattern characters", "assert wordPattern(\"abba\", \"dog cat cat\") == False  # Not enough words for the pattern", "assert wordPattern(\"abba\", \"dog cat cat dog fish\") == False  # Extra words beyond the pattern length"]}, {"author": "Hafeez", "UUID": "e811f9cc-fa5e-4ea0-8adb-8cf3ab7c72db", "question": "Detect Pattern of Length M Repeated K or More Times: Given an array of positive integers arr, find a pattern of length m that is repeated k or more times.\n\nA pattern is a subarray (consecutive sub-sequence) that consists of one or more values, repeated multiple times consecutively without overlapping. A pattern is defined by its length and the number of repetitions.\n\nReturn true if there exists a pattern of length m that is repeated k or more times, otherwise return false.", "examples": "Input: arr = [1,2,1,2,1,1,1,3], m = 2, k = 2\nOutput: true\nExplanation: The pattern (1,2) of length 2 is repeated 2 consecutive times. Another valid pattern (2,1) is also repeated 2 times.\nInput: arr = [1,2,1,2,1,3], m = 2, k = 3\nOutput: false\nExplanation: The pattern (1,2) is of length 2 but is repeated only 2 times. There is no pattern of length 2 that is repeated 3 or more times.\n", "link": "https://leetcode.com/problems/detect-pattern-of-length-m-repeated-k-or-more-times/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "from typing import List\ndef containsPattern(arr: List[int], m: int, k: int) -> bool:\n    i = 0\n    while i <= len(arr)-1:\n            p = arr[i:i+m]\n            if p * k == arr[i:i+m*k]:\n                    return True\n            i += 1\n    return False", "asserts": ["assert containsPattern([1,2,4,4,4,4],1,3)==True", "assert containsPattern([1,2,3,1,2,3,1,2,3], 3, 3) == True", "assert containsPattern([1,1,1,2,2,2,3,3], 2, 2) == False", "assert containsPattern([5,5,5,5,5,5,5], 1, 6) == True", "assert containsPattern([1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2], 2, 5) == True", "assert containsPattern([10,100,10,100,10,100,10,10,10,100], 2, 4) == False", "assert containsPattern([3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3], 4, 3) == True"]}], "category": "Pattern", "prompt_tokens": 1020, "total_tokens": 1390, "completion_tokens": 370, "completion": "Detect Arithmetic Slices: A sequence of numbers is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same. For example, these are arithmetic sequences:\n\n1, 3, 5, 7, 9\n7, 7, 7, 7\n3, -1, -5, -9\n\n\n###Code: \n\nfrom typing import List\ndef numberOfArithmeticSlices(nums: List[int]) -> int:\n    count = 0\n    sum = 0\n    for i in range(2, len(nums)):\n        if nums[i] - nums[i-1] == nums[i-1] - nums[i-2]:\n            count += 1\n            sum += count\n        else:\n            count = 0\n    return sum\n\n###Testcases: \n\nassert numberOfArithmeticSlices([1, 2, 3, 4]) == 3\nassert numberOfArithmeticSlices([1, 2, 3, 4, 5, 6]) == 10\nassert numberOfArithmeticSlices([1, 2, 3, 5, 7, 9]) == 2\nassert numberOfArithmeticSlices([1, 3, 5, 7, 9]) == 6\nassert numberOfArithmeticSlices([1, 3, 5, 7, 9, 11, 13, 15]) == 12\nassert numberOfArithmeticSlices([3, 1, 3, 5, 7, 9]) == 0\nassert numberOfArithmeticSlices([3, 5, 7, 9, 11]) == 3\n\n[/Example 3]", "temperature": 0.954}, {"few_shots": [{"author": "Hafeez", "UUID": "df98fd29-db88-4de7-a00a-0a3bd5ba1539", "question": "Word Pattern: Given a pattern and a string s, find if s follows the same pattern.\n\nHere follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in s.", "examples": "Input: pattern = \"abba\", s = \"dog cat cat fish\"\nOutput: false\nInput: pattern = \"aaaa\", s = \"dog cat cat dog\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def wordPattern(pattern: str, s: str) -> bool:\n    map_char = {}\n    map_word = {}\n    \n    words = s.split(' ')\n    if len(words) != len(pattern):\n        return False\n    \n    for c, w in zip(pattern, words):\n        if c not in map_char:\n            if w in map_word:\n                return False\n            else:\n                map_char[c] = w\n                map_word[w] = c\n        else:\n            if map_char[c] != w:\n                return False\n    return True", "asserts": ["assert wordPattern(\"abba\", \"dog cat cat dog\")==True", "assert wordPattern(\"aaaa\", \"dog dog dog dog\") == True", "assert wordPattern(\"xyz\", \"apple banana apple\") == False", "assert wordPattern(\"xyx\", \"apple banana apple\") == True", "assert wordPattern(\"abab\", \"dog cat dog cat\") == True", "assert wordPattern(\"aaaa\", \"dog dog dog cat\") == False", "assert wordPattern(\"aabb\", \"dog dog cat cat\") == True", "assert wordPattern(\"abc\", \"dog\") == False  # Not enough words", "assert wordPattern(\"\", \"dog cat\") == False  # Empty pattern", "assert wordPattern(\"a\", \"dog cat dog cat\") == False  # Not enough pattern characters", "assert wordPattern(\"ab\", \"\") == False  # Empty string", "assert wordPattern(\"abb\", \"dog dog dog\") == False  # Same word for different pattern characters", "assert wordPattern(\"abba\", \"dog cat cat\") == False  # Not enough words for the pattern", "assert wordPattern(\"abba\", \"dog cat cat dog fish\") == False  # Extra words beyond the pattern length"]}, {"author": "Hafeez", "UUID": "e811f9cc-fa5e-4ea0-8adb-8cf3ab7c72db", "question": "Detect Pattern of Length M Repeated K or More Times: Given an array of positive integers arr, find a pattern of length m that is repeated k or more times.\n\nA pattern is a subarray (consecutive sub-sequence) that consists of one or more values, repeated multiple times consecutively without overlapping. A pattern is defined by its length and the number of repetitions.\n\nReturn true if there exists a pattern of length m that is repeated k or more times, otherwise return false.", "examples": "Input: arr = [1,2,1,2,1,1,1,3], m = 2, k = 2\nOutput: true\nExplanation: The pattern (1,2) of length 2 is repeated 2 consecutive times. Another valid pattern (2,1) is also repeated 2 times.\nInput: arr = [1,2,1,2,1,3], m = 2, k = 3\nOutput: false\nExplanation: The pattern (1,2) is of length 2 but is repeated only 2 times. There is no pattern of length 2 that is repeated 3 or more times.\n", "link": "https://leetcode.com/problems/detect-pattern-of-length-m-repeated-k-or-more-times/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "from typing import List\ndef containsPattern(arr: List[int], m: int, k: int) -> bool:\n    i = 0\n    while i <= len(arr)-1:\n            p = arr[i:i+m]\n            if p * k == arr[i:i+m*k]:\n                    return True\n            i += 1\n    return False", "asserts": ["assert containsPattern([1,2,4,4,4,4],1,3)==True", "assert containsPattern([1,2,3,1,2,3,1,2,3], 3, 3) == True", "assert containsPattern([1,1,1,2,2,2,3,3], 2, 2) == False", "assert containsPattern([5,5,5,5,5,5,5], 1, 6) == True", "assert containsPattern([1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2], 2, 5) == True", "assert containsPattern([10,100,10,100,10,100,10,10,10,100], 2, 4) == False", "assert containsPattern([3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3], 4, 3) == True"]}], "category": "Pattern", "prompt_tokens": 1020, "total_tokens": 1399, "completion_tokens": 379, "completion": "Find All Anagrams in a String: Given a string s and a non-empty string p, find all the start indices of p's anagrams in s.\n\nStrings consists of lowercase English letters only.\n\n###Code: \n\nfrom typing import List\ndef findAnagrams(s: str, p: str) -> List[int]:\n    result = []\n    p_count = [0] * 26\n    s_count = [0] * 26\n    \n    for char in p:\n        p_count[ord(char) - ord('a')] += 1\n    \n    for i in range(len(s)):\n        s_count[ord(s[i]) - ord('a')] += 1\n        if i >= len(p):\n            s_count[ord(s[i - len(p)]) - ord('a')] -= 1\n        if s_count == p_count:\n            result.append(i - len(p) + 1)\n    \n    return result\n\n###Testcases: \n\nassert findAnagrams(\"cbaebabacd\", \"abc\") == [0, 6]\nassert findAnagrams(\"abab\", \"ab\") == [0, 1, 2]\nassert findAnagrams(\"baa\", \"aa\") == [1]\nassert findAnagrams(\"aaaaa\", \"a\") == [0, 1, 2, 3, 4]\nassert findAnagrams(\"abcdefghijklmnopqrstuvwxyz\", \"z\") == [25]\nassert findAnagrams(\"abcdefghijklmnopqrstuvwxyz\", \"zyxwvutsrqponmlkjihgfedcba\") == [0]\nassert findAnagrams(\"abcdefghijklmnopqrstuvwxyz\", \"zyxwvutsrqponmlkjihgfedcb\") == []\nassert findAnagrams(\"a\", \"ab\") == []\nassert findAnagrams(\"\", \"a\") == []\nassert findAnagrams(\"abcd\", \"\") == []\n\n[/Example 3]", "temperature": 0.652}, {"few_shots": [{"author": "Hafeez", "UUID": "df98fd29-db88-4de7-a00a-0a3bd5ba1539", "question": "Word Pattern: Given a pattern and a string s, find if s follows the same pattern.\n\nHere follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in s.", "examples": "Input: pattern = \"abba\", s = \"dog cat cat fish\"\nOutput: false\nInput: pattern = \"aaaa\", s = \"dog cat cat dog\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def wordPattern(pattern: str, s: str) -> bool:\n    map_char = {}\n    map_word = {}\n    \n    words = s.split(' ')\n    if len(words) != len(pattern):\n        return False\n    \n    for c, w in zip(pattern, words):\n        if c not in map_char:\n            if w in map_word:\n                return False\n            else:\n                map_char[c] = w\n                map_word[w] = c\n        else:\n            if map_char[c] != w:\n                return False\n    return True", "asserts": ["assert wordPattern(\"abba\", \"dog cat cat dog\")==True", "assert wordPattern(\"aaaa\", \"dog dog dog dog\") == True", "assert wordPattern(\"xyz\", \"apple banana apple\") == False", "assert wordPattern(\"xyx\", \"apple banana apple\") == True", "assert wordPattern(\"abab\", \"dog cat dog cat\") == True", "assert wordPattern(\"aaaa\", \"dog dog dog cat\") == False", "assert wordPattern(\"aabb\", \"dog dog cat cat\") == True", "assert wordPattern(\"abc\", \"dog\") == False  # Not enough words", "assert wordPattern(\"\", \"dog cat\") == False  # Empty pattern", "assert wordPattern(\"a\", \"dog cat dog cat\") == False  # Not enough pattern characters", "assert wordPattern(\"ab\", \"\") == False  # Empty string", "assert wordPattern(\"abb\", \"dog dog dog\") == False  # Same word for different pattern characters", "assert wordPattern(\"abba\", \"dog cat cat\") == False  # Not enough words for the pattern", "assert wordPattern(\"abba\", \"dog cat cat dog fish\") == False  # Extra words beyond the pattern length"]}, {"author": "Hafeez", "UUID": "e811f9cc-fa5e-4ea0-8adb-8cf3ab7c72db", "question": "Detect Pattern of Length M Repeated K or More Times: Given an array of positive integers arr, find a pattern of length m that is repeated k or more times.\n\nA pattern is a subarray (consecutive sub-sequence) that consists of one or more values, repeated multiple times consecutively without overlapping. A pattern is defined by its length and the number of repetitions.\n\nReturn true if there exists a pattern of length m that is repeated k or more times, otherwise return false.", "examples": "Input: arr = [1,2,1,2,1,1,1,3], m = 2, k = 2\nOutput: true\nExplanation: The pattern (1,2) of length 2 is repeated 2 consecutive times. Another valid pattern (2,1) is also repeated 2 times.\nInput: arr = [1,2,1,2,1,3], m = 2, k = 3\nOutput: false\nExplanation: The pattern (1,2) is of length 2 but is repeated only 2 times. There is no pattern of length 2 that is repeated 3 or more times.\n", "link": "https://leetcode.com/problems/detect-pattern-of-length-m-repeated-k-or-more-times/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "from typing import List\ndef containsPattern(arr: List[int], m: int, k: int) -> bool:\n    i = 0\n    while i <= len(arr)-1:\n            p = arr[i:i+m]\n            if p * k == arr[i:i+m*k]:\n                    return True\n            i += 1\n    return False", "asserts": ["assert containsPattern([1,2,4,4,4,4],1,3)==True", "assert containsPattern([1,2,3,1,2,3,1,2,3], 3, 3) == True", "assert containsPattern([1,1,1,2,2,2,3,3], 2, 2) == False", "assert containsPattern([5,5,5,5,5,5,5], 1, 6) == True", "assert containsPattern([1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2], 2, 5) == True", "assert containsPattern([10,100,10,100,10,100,10,10,10,100], 2, 4) == False", "assert containsPattern([3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3], 4, 3) == True"]}], "category": "Pattern", "prompt_tokens": 1020, "total_tokens": 1325, "completion_tokens": 305, "completion": "Find All Anagrams in a String: Given a string s and a non-empty string p, find all the start indices of p's anagrams in s.\n\nStrings consists of lowercase English letters only.\n\n###Code: \n\nfrom typing import List\ndef findAnagrams(s: str, p: str) -> List[int]:\n    result = []\n    p_count = [0] * 26\n    s_count = [0] * 26\n    \n    for char in p:\n        p_count[ord(char) - ord('a')] += 1\n    \n    for i in range(len(s)):\n        s_count[ord(s[i]) - ord('a')] += 1\n        if i >= len(p):\n            s_count[ord(s[i - len(p)]) - ord('a')] -= 1\n        if s_count == p_count:\n            result.append(i - len(p) + 1)\n    \n    return result\n\n###Testcases: \n\nassert findAnagrams(\"cbaebabacd\", \"abc\") == [0, 6]\nassert findAnagrams(\"abab\", \"ab\") == [0, 1, 2]\nassert findAnagrams(\"baa\", \"aa\") == [1]\nassert findAnagrams(\"aaaaa\", \"aa\") == [0, 1, 2, 3]\nassert findAnagrams(\"abacbabc\", \"abc\") == [1, 2, 3, 5]\n\n[/Example 3]", "temperature": 0.716}, {"few_shots": [{"author": "Hafeez", "UUID": "df98fd29-db88-4de7-a00a-0a3bd5ba1539", "question": "Word Pattern: Given a pattern and a string s, find if s follows the same pattern.\n\nHere follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in s.", "examples": "Input: pattern = \"abba\", s = \"dog cat cat fish\"\nOutput: false\nInput: pattern = \"aaaa\", s = \"dog cat cat dog\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def wordPattern(pattern: str, s: str) -> bool:\n    map_char = {}\n    map_word = {}\n    \n    words = s.split(' ')\n    if len(words) != len(pattern):\n        return False\n    \n    for c, w in zip(pattern, words):\n        if c not in map_char:\n            if w in map_word:\n                return False\n            else:\n                map_char[c] = w\n                map_word[w] = c\n        else:\n            if map_char[c] != w:\n                return False\n    return True", "asserts": ["assert wordPattern(\"abba\", \"dog cat cat dog\")==True", "assert wordPattern(\"aaaa\", \"dog dog dog dog\") == True", "assert wordPattern(\"xyz\", \"apple banana apple\") == False", "assert wordPattern(\"xyx\", \"apple banana apple\") == True", "assert wordPattern(\"abab\", \"dog cat dog cat\") == True", "assert wordPattern(\"aaaa\", \"dog dog dog cat\") == False", "assert wordPattern(\"aabb\", \"dog dog cat cat\") == True", "assert wordPattern(\"abc\", \"dog\") == False  # Not enough words", "assert wordPattern(\"\", \"dog cat\") == False  # Empty pattern", "assert wordPattern(\"a\", \"dog cat dog cat\") == False  # Not enough pattern characters", "assert wordPattern(\"ab\", \"\") == False  # Empty string", "assert wordPattern(\"abb\", \"dog dog dog\") == False  # Same word for different pattern characters", "assert wordPattern(\"abba\", \"dog cat cat\") == False  # Not enough words for the pattern", "assert wordPattern(\"abba\", \"dog cat cat dog fish\") == False  # Extra words beyond the pattern length"]}, {"author": "Hafeez", "UUID": "e811f9cc-fa5e-4ea0-8adb-8cf3ab7c72db", "question": "Detect Pattern of Length M Repeated K or More Times: Given an array of positive integers arr, find a pattern of length m that is repeated k or more times.\n\nA pattern is a subarray (consecutive sub-sequence) that consists of one or more values, repeated multiple times consecutively without overlapping. A pattern is defined by its length and the number of repetitions.\n\nReturn true if there exists a pattern of length m that is repeated k or more times, otherwise return false.", "examples": "Input: arr = [1,2,1,2,1,1,1,3], m = 2, k = 2\nOutput: true\nExplanation: The pattern (1,2) of length 2 is repeated 2 consecutive times. Another valid pattern (2,1) is also repeated 2 times.\nInput: arr = [1,2,1,2,1,3], m = 2, k = 3\nOutput: false\nExplanation: The pattern (1,2) is of length 2 but is repeated only 2 times. There is no pattern of length 2 that is repeated 3 or more times.\n", "link": "https://leetcode.com/problems/detect-pattern-of-length-m-repeated-k-or-more-times/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "from typing import List\ndef containsPattern(arr: List[int], m: int, k: int) -> bool:\n    i = 0\n    while i <= len(arr)-1:\n            p = arr[i:i+m]\n            if p * k == arr[i:i+m*k]:\n                    return True\n            i += 1\n    return False", "asserts": ["assert containsPattern([1,2,4,4,4,4],1,3)==True", "assert containsPattern([1,2,3,1,2,3,1,2,3], 3, 3) == True", "assert containsPattern([1,1,1,2,2,2,3,3], 2, 2) == False", "assert containsPattern([5,5,5,5,5,5,5], 1, 6) == True", "assert containsPattern([1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2], 2, 5) == True", "assert containsPattern([10,100,10,100,10,100,10,10,10,100], 2, 4) == False", "assert containsPattern([3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3], 4, 3) == True"]}], "category": "Pattern", "prompt_tokens": 1020, "total_tokens": 1478, "completion_tokens": 458, "completion": "Find All Anagrams in a String: Given a string s and a non-empty string p, find all the start indices of p's anagrams in s.\n\n###Code: \n\nfrom typing import List\ndef findAnagrams(s: str, p: str) -> List[int]:\n    p_count = {}\n    for char in p:\n        if char in p_count:\n            p_count[char] += 1\n        else:\n            p_count[char] = 1\n    \n    result = []\n    window_start = 0\n    for window_end in range(len(s)):\n        if s[window_end] in p_count:\n            p_count[s[window_end]] -= 1\n            if p_count[s[window_end]] == 0:\n                del p_count[s[window_end]]\n        \n        if window_end >= len(p) - 1:\n            if len(p_count) == 0:\n                result.append(window_start)\n            \n            if s[window_start] in p_count:\n                p_count[s[window_start]] += 1\n                if p_count[s[window_start]] == 0:\n                    del p_count[s[window_start]]\n            window_start += 1\n    \n    return result\n\n###Testcases: \n\nassert findAnagrams(\"cbaebabacd\", \"abc\") == [0, 6]\nassert findAnagrams(\"abab\", \"ab\") == [0, 1, 2]\nassert findAnagrams(\"acdbacdacb\", \"abc\") == [1, 2, 3, 4, 5, 6]\nassert findAnagrams(\"aaaaa\", \"a\")==[0, 1, 2, 3, 4]\nassert findAnagrams(\"abcdef\", \"xyz\")==[]\nassert findAnagrams(\"aaaaaa\", \"aa\")==[0, 1, 2, 3, 4]\nassert findAnagrams(\"ababababab\", \"aab\")==[0, 2, 4, 6]\nassert findAnagrams(\"ababababab\", \"aaa\")==[0, 1, 2, 3, 4, 5, 6, 7]\n\n[/Example 3]", "temperature": 0.804}, {"few_shots": [{"author": "Hafeez", "UUID": "df98fd29-db88-4de7-a00a-0a3bd5ba1539", "question": "Word Pattern: Given a pattern and a string s, find if s follows the same pattern.\n\nHere follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in s.", "examples": "Input: pattern = \"abba\", s = \"dog cat cat fish\"\nOutput: false\nInput: pattern = \"aaaa\", s = \"dog cat cat dog\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def wordPattern(pattern: str, s: str) -> bool:\n    map_char = {}\n    map_word = {}\n    \n    words = s.split(' ')\n    if len(words) != len(pattern):\n        return False\n    \n    for c, w in zip(pattern, words):\n        if c not in map_char:\n            if w in map_word:\n                return False\n            else:\n                map_char[c] = w\n                map_word[w] = c\n        else:\n            if map_char[c] != w:\n                return False\n    return True", "asserts": ["assert wordPattern(\"abba\", \"dog cat cat dog\")==True", "assert wordPattern(\"aaaa\", \"dog dog dog dog\") == True", "assert wordPattern(\"xyz\", \"apple banana apple\") == False", "assert wordPattern(\"xyx\", \"apple banana apple\") == True", "assert wordPattern(\"abab\", \"dog cat dog cat\") == True", "assert wordPattern(\"aaaa\", \"dog dog dog cat\") == False", "assert wordPattern(\"aabb\", \"dog dog cat cat\") == True", "assert wordPattern(\"abc\", \"dog\") == False  # Not enough words", "assert wordPattern(\"\", \"dog cat\") == False  # Empty pattern", "assert wordPattern(\"a\", \"dog cat dog cat\") == False  # Not enough pattern characters", "assert wordPattern(\"ab\", \"\") == False  # Empty string", "assert wordPattern(\"abb\", \"dog dog dog\") == False  # Same word for different pattern characters", "assert wordPattern(\"abba\", \"dog cat cat\") == False  # Not enough words for the pattern", "assert wordPattern(\"abba\", \"dog cat cat dog fish\") == False  # Extra words beyond the pattern length"]}, {"author": "Hafeez", "UUID": "8c9548d2-7b9c-46a4-9b8e-8afd488f7e87", "question": "Find and Replace Pattern: Given a list of strings words and a string pattern, return a list of words[i] that match pattern. You may return the answer in any order.\n\nA word matches the pattern if there exists a permutation of letters p so that after replacing every letter x in the pattern with p(x), we get the desired word.\n\nRecall that a permutation of letters is a bijection from letters to letters: every letter maps to another letter, and no two letters map to the same letter.", "examples": "Input: words = [\"abc\",\"deq\",\"mee\",\"aqq\",\"dkd\",\"ccc\"], pattern = \"abb\"\nOutput: [\"mee\",\"aqq\"]\nExplanation: \"mee\" matches the pattern because there is a permutation {a -> m, b -> e, ...}. \n\"ccc\" does not match the pattern because {a -> c, b -> c, ...} is not a permutation, since a and b map to the same letter.", "link": "https://leetcode.com/problems/find-and-replace-pattern/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def findAndReplacePattern(words: list, pattern: str) -> list:\n        def match(word):\n            m1, m2 = {}, {}\n            for w, p in zip(word, pattern):\n                if w not in m1: m1[w] = p\n                if p not in m2: m2[p] = w\n                if (m1[w], m2[p]) != (p, w):\n                    return False\n            return True\n\n        return list(filter(match, words))\n", "asserts": ["assert findAndReplacePattern([\"a\",\"b\",\"c\"], \"a\")==[\"a\",\"b\",\"c\"]", "assert findAndReplacePattern([\"xx\", \"xy\", \"yy\"], \"xx\") == [\"xx\", \"yy\"]", "assert findAndReplacePattern([\"abc\", \"def\", \"ghi\", \"jkl\"], \"xyz\") == [\"abc\", \"def\", \"ghi\", \"jkl\"]", "assert findAndReplacePattern([\"aaa\", \"bbb\", \"ccc\"], \"xyz\") == []"]}], "category": "Pattern", "prompt_tokens": 922, "total_tokens": 1305, "completion_tokens": 383, "completion": "Given a string s, your task is to return the length of the longest substring that contains at most two distinct characters.\n\n###Code:\n\n```python\ndef lengthOfLongestSubstringTwoDistinct(s: str) -> int:\n    left, res, last_char, last_last_char = 0, 0, \"\", \"\"\n    char_map = {}\n\n    for i, char in enumerate(s):\n        if char not in char_map and len(char_map) == 2:\n            res = max(res, i - left)\n            while len(char_map) == 2:\n                if s[left] in char_map:\n                    char_map[s[left]] -= 1\n                    if char_map[s[left]] == 0:\n                        del char_map[s[left]]\n                left += 1\n        if char == last_char:\n            last_last_char, last_char = last_char, char\n        else:\n            last_last_char, last_char = last_char, char\n        char_map[char] = char_map.get(char, 0) + 1\n\n    return max(res, len(s) - left)\n\n```\n\n###Testcases:\n\n```python\nassert lengthOfLongestSubstringTwoDistinct(\"eceba\") == 3\nassert lengthOfLongestSubstringTwoDistinct(\"ccaabbb\") == 5\nassert lengthOfLongestSubstringTwoDistinct(\"abcabcabc\") == 3\nassert lengthOfLongestSubstringTwoDistinct(\"ababababababababab\") == 4\nassert lengthOfLongestSubstringTwoDistinct(\"a\") == 1\nassert lengthOfLongestSubstringTwoDistinct(\"\") == 0\nassert lengthOfLongestSubstringTwoDistinct(\"abc\") == 3\nassert lengthOfLongestSubstringTwoDistinct(\"abaccc\") == 4\nassert lengthOfLongestSubstringTwoDistinct(\"abcde\") == 2\n```\n\n", "temperature": 0.761}, {"few_shots": [{"author": "Hafeez", "UUID": "df98fd29-db88-4de7-a00a-0a3bd5ba1539", "question": "Word Pattern: Given a pattern and a string s, find if s follows the same pattern.\n\nHere follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in s.", "examples": "Input: pattern = \"abba\", s = \"dog cat cat fish\"\nOutput: false\nInput: pattern = \"aaaa\", s = \"dog cat cat dog\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def wordPattern(pattern: str, s: str) -> bool:\n    map_char = {}\n    map_word = {}\n    \n    words = s.split(' ')\n    if len(words) != len(pattern):\n        return False\n    \n    for c, w in zip(pattern, words):\n        if c not in map_char:\n            if w in map_word:\n                return False\n            else:\n                map_char[c] = w\n                map_word[w] = c\n        else:\n            if map_char[c] != w:\n                return False\n    return True", "asserts": ["assert wordPattern(\"abba\", \"dog cat cat dog\")==True", "assert wordPattern(\"aaaa\", \"dog dog dog dog\") == True", "assert wordPattern(\"xyz\", \"apple banana apple\") == False", "assert wordPattern(\"xyx\", \"apple banana apple\") == True", "assert wordPattern(\"abab\", \"dog cat dog cat\") == True", "assert wordPattern(\"aaaa\", \"dog dog dog cat\") == False", "assert wordPattern(\"aabb\", \"dog dog cat cat\") == True", "assert wordPattern(\"abc\", \"dog\") == False  # Not enough words", "assert wordPattern(\"\", \"dog cat\") == False  # Empty pattern", "assert wordPattern(\"a\", \"dog cat dog cat\") == False  # Not enough pattern characters", "assert wordPattern(\"ab\", \"\") == False  # Empty string", "assert wordPattern(\"abb\", \"dog dog dog\") == False  # Same word for different pattern characters", "assert wordPattern(\"abba\", \"dog cat cat\") == False  # Not enough words for the pattern", "assert wordPattern(\"abba\", \"dog cat cat dog fish\") == False  # Extra words beyond the pattern length"]}, {"author": "Hafeez", "UUID": "8c9548d2-7b9c-46a4-9b8e-8afd488f7e87", "question": "Find and Replace Pattern: Given a list of strings words and a string pattern, return a list of words[i] that match pattern. You may return the answer in any order.\n\nA word matches the pattern if there exists a permutation of letters p so that after replacing every letter x in the pattern with p(x), we get the desired word.\n\nRecall that a permutation of letters is a bijection from letters to letters: every letter maps to another letter, and no two letters map to the same letter.", "examples": "Input: words = [\"abc\",\"deq\",\"mee\",\"aqq\",\"dkd\",\"ccc\"], pattern = \"abb\"\nOutput: [\"mee\",\"aqq\"]\nExplanation: \"mee\" matches the pattern because there is a permutation {a -> m, b -> e, ...}. \n\"ccc\" does not match the pattern because {a -> c, b -> c, ...} is not a permutation, since a and b map to the same letter.", "link": "https://leetcode.com/problems/find-and-replace-pattern/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def findAndReplacePattern(words: list, pattern: str) -> list:\n        def match(word):\n            m1, m2 = {}, {}\n            for w, p in zip(word, pattern):\n                if w not in m1: m1[w] = p\n                if p not in m2: m2[p] = w\n                if (m1[w], m2[p]) != (p, w):\n                    return False\n            return True\n\n        return list(filter(match, words))\n", "asserts": ["assert findAndReplacePattern([\"a\",\"b\",\"c\"], \"a\")==[\"a\",\"b\",\"c\"]", "assert findAndReplacePattern([\"xx\", \"xy\", \"yy\"], \"xx\") == [\"xx\", \"yy\"]", "assert findAndReplacePattern([\"abc\", \"def\", \"ghi\", \"jkl\"], \"xyz\") == [\"abc\", \"def\", \"ghi\", \"jkl\"]", "assert findAndReplacePattern([\"aaa\", \"bbb\", \"ccc\"], \"xyz\") == []"]}], "category": "Pattern", "prompt_tokens": 922, "total_tokens": 1215, "completion_tokens": 293, "completion": "Repeated Substring Pattern: Given a non-empty string s, check if it can be constructed by taking a substring of it and appending multiple copies of the substring together. You may assume that the given string only contains lowercase English letters and its length will not exceed 10000.\n\nReturn true if it is possible to obtain the string by concatenating one or more copies of the substring, otherwise return false.\n\n###Code: \n\n```python\ndef repeatedSubstringPattern(s: str) -> bool:\n    for i in range(1, len(s)//2 + 1):\n        if len(s) % i == 0 and s[:i] * (len(s)//i) == s:\n            return True\n    return False\n```\n\n###Testcases: \n\n```python\nassert repeatedSubstringPattern(\"abab\") == True\nassert repeatedSubstringPattern(\"aba\") == False\nassert repeatedSubstringPattern(\"abcabcabcabc\") == True\nassert repeatedSubstringPattern(\"abcabcabc\") == True\nassert repeatedSubstringPattern(\"a\") == False\nassert repeatedSubstringPattern(\"ab\") == False\nassert repeatedSubstringPattern(\"aaaa\") == True\nassert repeatedSubstringPattern(\"aaaaa\") == True\nassert repeatedSubstringPattern(\"ababab\") == True\nassert repeatedSubstringPattern(\"abac\") == False\nassert repeatedSubstringPattern(\"aa\") == True\nassert repeatedSubstringPattern(\"ababababab\") == True\n```\n\n", "temperature": 0.886}, {"few_shots": [{"author": "Hafeez", "UUID": "df98fd29-db88-4de7-a00a-0a3bd5ba1539", "question": "Word Pattern: Given a pattern and a string s, find if s follows the same pattern.\n\nHere follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in s.", "examples": "Input: pattern = \"abba\", s = \"dog cat cat fish\"\nOutput: false\nInput: pattern = \"aaaa\", s = \"dog cat cat dog\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def wordPattern(pattern: str, s: str) -> bool:\n    map_char = {}\n    map_word = {}\n    \n    words = s.split(' ')\n    if len(words) != len(pattern):\n        return False\n    \n    for c, w in zip(pattern, words):\n        if c not in map_char:\n            if w in map_word:\n                return False\n            else:\n                map_char[c] = w\n                map_word[w] = c\n        else:\n            if map_char[c] != w:\n                return False\n    return True", "asserts": ["assert wordPattern(\"abba\", \"dog cat cat dog\")==True", "assert wordPattern(\"aaaa\", \"dog dog dog dog\") == True", "assert wordPattern(\"xyz\", \"apple banana apple\") == False", "assert wordPattern(\"xyx\", \"apple banana apple\") == True", "assert wordPattern(\"abab\", \"dog cat dog cat\") == True", "assert wordPattern(\"aaaa\", \"dog dog dog cat\") == False", "assert wordPattern(\"aabb\", \"dog dog cat cat\") == True", "assert wordPattern(\"abc\", \"dog\") == False  # Not enough words", "assert wordPattern(\"\", \"dog cat\") == False  # Empty pattern", "assert wordPattern(\"a\", \"dog cat dog cat\") == False  # Not enough pattern characters", "assert wordPattern(\"ab\", \"\") == False  # Empty string", "assert wordPattern(\"abb\", \"dog dog dog\") == False  # Same word for different pattern characters", "assert wordPattern(\"abba\", \"dog cat cat\") == False  # Not enough words for the pattern", "assert wordPattern(\"abba\", \"dog cat cat dog fish\") == False  # Extra words beyond the pattern length"]}, {"author": "Hafeez", "UUID": "8c9548d2-7b9c-46a4-9b8e-8afd488f7e87", "question": "Find and Replace Pattern: Given a list of strings words and a string pattern, return a list of words[i] that match pattern. You may return the answer in any order.\n\nA word matches the pattern if there exists a permutation of letters p so that after replacing every letter x in the pattern with p(x), we get the desired word.\n\nRecall that a permutation of letters is a bijection from letters to letters: every letter maps to another letter, and no two letters map to the same letter.", "examples": "Input: words = [\"abc\",\"deq\",\"mee\",\"aqq\",\"dkd\",\"ccc\"], pattern = \"abb\"\nOutput: [\"mee\",\"aqq\"]\nExplanation: \"mee\" matches the pattern because there is a permutation {a -> m, b -> e, ...}. \n\"ccc\" does not match the pattern because {a -> c, b -> c, ...} is not a permutation, since a and b map to the same letter.", "link": "https://leetcode.com/problems/find-and-replace-pattern/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def findAndReplacePattern(words: list, pattern: str) -> list:\n        def match(word):\n            m1, m2 = {}, {}\n            for w, p in zip(word, pattern):\n                if w not in m1: m1[w] = p\n                if p not in m2: m2[p] = w\n                if (m1[w], m2[p]) != (p, w):\n                    return False\n            return True\n\n        return list(filter(match, words))\n", "asserts": ["assert findAndReplacePattern([\"a\",\"b\",\"c\"], \"a\")==[\"a\",\"b\",\"c\"]", "assert findAndReplacePattern([\"xx\", \"xy\", \"yy\"], \"xx\") == [\"xx\", \"yy\"]", "assert findAndReplacePattern([\"abc\", \"def\", \"ghi\", \"jkl\"], \"xyz\") == [\"abc\", \"def\", \"ghi\", \"jkl\"]", "assert findAndReplacePattern([\"aaa\", \"bbb\", \"ccc\"], \"xyz\") == []"]}], "category": "Pattern", "prompt_tokens": 922, "total_tokens": 1300, "completion_tokens": 378, "completion": "Find All Anagrams in a String: Given a string s and a non-empty string p, find all the start indices of p's anagrams in s.\n\nStrings consists of lowercase English letters only and the length of both strings s and p will not be larger than 20,100.\n\nThe order of output does not matter.\n\n###Code: \n\n```python\nfrom collections import Counter\n\ndef findAnagrams(s: str, p: str) -> List[int]:\n    result = []\n    pCounter = Counter(p)\n    sCounter = Counter(s[:len(p)-1])\n    for i in range(len(p)-1,len(s)):\n        sCounter[s[i]] += 1   # include a new char in the window\n        if sCounter == pCounter:    # This step is O(1), since there are at most 26 English letters \n            result.append(i-len(p)+1)   # append the starting index\n        sCounter[s[i-len(p)+1]] -= 1   # decrease the count of oldest char in the window\n        if sCounter[s[i-len(p)+1]] == 0:\n            del sCounter[s[i-len(p)+1]]   # remove the count if it is 0\n    return result\n```\n\n###Testcases: \n\n```python\nassert findAnagrams(\"cbaebabacd\", \"abc\") == [0, 6]\nassert findAnagrams(\"abab\", \"ab\") == [0, 1, 2]\nassert findAnagrams(\"aaaaaaaaaa\", \"aa\") == [0, 1, 2, 3, 4, 5, 6, 7]\nassert findAnagrams(\"aaaaaa\", \"aab\") == []\nassert findAnagrams(\"\", \"a\") == []\nassert findAnagrams(\"a\", \"\") == []\n```", "temperature": 0.862}, {"few_shots": [{"author": "Hafeez", "UUID": "df98fd29-db88-4de7-a00a-0a3bd5ba1539", "question": "Word Pattern: Given a pattern and a string s, find if s follows the same pattern.\n\nHere follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in s.", "examples": "Input: pattern = \"abba\", s = \"dog cat cat fish\"\nOutput: false\nInput: pattern = \"aaaa\", s = \"dog cat cat dog\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def wordPattern(pattern: str, s: str) -> bool:\n    map_char = {}\n    map_word = {}\n    \n    words = s.split(' ')\n    if len(words) != len(pattern):\n        return False\n    \n    for c, w in zip(pattern, words):\n        if c not in map_char:\n            if w in map_word:\n                return False\n            else:\n                map_char[c] = w\n                map_word[w] = c\n        else:\n            if map_char[c] != w:\n                return False\n    return True", "asserts": ["assert wordPattern(\"abba\", \"dog cat cat dog\")==True", "assert wordPattern(\"aaaa\", \"dog dog dog dog\") == True", "assert wordPattern(\"xyz\", \"apple banana apple\") == False", "assert wordPattern(\"xyx\", \"apple banana apple\") == True", "assert wordPattern(\"abab\", \"dog cat dog cat\") == True", "assert wordPattern(\"aaaa\", \"dog dog dog cat\") == False", "assert wordPattern(\"aabb\", \"dog dog cat cat\") == True", "assert wordPattern(\"abc\", \"dog\") == False  # Not enough words", "assert wordPattern(\"\", \"dog cat\") == False  # Empty pattern", "assert wordPattern(\"a\", \"dog cat dog cat\") == False  # Not enough pattern characters", "assert wordPattern(\"ab\", \"\") == False  # Empty string", "assert wordPattern(\"abb\", \"dog dog dog\") == False  # Same word for different pattern characters", "assert wordPattern(\"abba\", \"dog cat cat\") == False  # Not enough words for the pattern", "assert wordPattern(\"abba\", \"dog cat cat dog fish\") == False  # Extra words beyond the pattern length"]}, {"author": "Hafeez", "UUID": "8c9548d2-7b9c-46a4-9b8e-8afd488f7e87", "question": "Find and Replace Pattern: Given a list of strings words and a string pattern, return a list of words[i] that match pattern. You may return the answer in any order.\n\nA word matches the pattern if there exists a permutation of letters p so that after replacing every letter x in the pattern with p(x), we get the desired word.\n\nRecall that a permutation of letters is a bijection from letters to letters: every letter maps to another letter, and no two letters map to the same letter.", "examples": "Input: words = [\"abc\",\"deq\",\"mee\",\"aqq\",\"dkd\",\"ccc\"], pattern = \"abb\"\nOutput: [\"mee\",\"aqq\"]\nExplanation: \"mee\" matches the pattern because there is a permutation {a -> m, b -> e, ...}. \n\"ccc\" does not match the pattern because {a -> c, b -> c, ...} is not a permutation, since a and b map to the same letter.", "link": "https://leetcode.com/problems/find-and-replace-pattern/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def findAndReplacePattern(words: list, pattern: str) -> list:\n        def match(word):\n            m1, m2 = {}, {}\n            for w, p in zip(word, pattern):\n                if w not in m1: m1[w] = p\n                if p not in m2: m2[p] = w\n                if (m1[w], m2[p]) != (p, w):\n                    return False\n            return True\n\n        return list(filter(match, words))\n", "asserts": ["assert findAndReplacePattern([\"a\",\"b\",\"c\"], \"a\")==[\"a\",\"b\",\"c\"]", "assert findAndReplacePattern([\"xx\", \"xy\", \"yy\"], \"xx\") == [\"xx\", \"yy\"]", "assert findAndReplacePattern([\"abc\", \"def\", \"ghi\", \"jkl\"], \"xyz\") == [\"abc\", \"def\", \"ghi\", \"jkl\"]", "assert findAndReplacePattern([\"aaa\", \"bbb\", \"ccc\"], \"xyz\") == []"]}], "category": "Pattern", "prompt_tokens": 922, "total_tokens": 1158, "completion_tokens": 236, "completion": "Repeated Substring Pattern: Given a non-empty string s, consider all possible substrings of s. Determine if it is possible to make s by repeating a substring of it. If so, return true, otherwise return false.\n\n###Code: \n\n```python\ndef repeatedSubstringPattern(s: str) -> bool:\n    n = len(s)\n    for i in range(1, n // 2 + 1):\n        if n % i == 0:\n            if s[:i] * (n // i) == s:\n                return True\n    return False\n```\n\n###Testcases: \n\n```python\nassert repeatedSubstringPattern(\"abab\") == True\nassert repeatedSubstringPattern(\"aba\") == False\nassert repeatedSubstringPattern(\"abcabcabcabc\") == True\nassert repeatedSubstringPattern(\"a\") == False\nassert repeatedSubstringPattern(\"abac\") == False\nassert repeatedSubstringPattern(\"ababab\") == True\nassert repeatedSubstringPattern(\"abababab\") == True\nassert repeatedSubstringPattern(\"ababababab\") == True\nassert repeatedSubstringPattern(\"abababababa\") == False\n```", "temperature": 0.685}, {"few_shots": [{"author": "Hafeez", "UUID": "df98fd29-db88-4de7-a00a-0a3bd5ba1539", "question": "Word Pattern: Given a pattern and a string s, find if s follows the same pattern.\n\nHere follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in s.", "examples": "Input: pattern = \"abba\", s = \"dog cat cat fish\"\nOutput: false\nInput: pattern = \"aaaa\", s = \"dog cat cat dog\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def wordPattern(pattern: str, s: str) -> bool:\n    map_char = {}\n    map_word = {}\n    \n    words = s.split(' ')\n    if len(words) != len(pattern):\n        return False\n    \n    for c, w in zip(pattern, words):\n        if c not in map_char:\n            if w in map_word:\n                return False\n            else:\n                map_char[c] = w\n                map_word[w] = c\n        else:\n            if map_char[c] != w:\n                return False\n    return True", "asserts": ["assert wordPattern(\"abba\", \"dog cat cat dog\")==True", "assert wordPattern(\"aaaa\", \"dog dog dog dog\") == True", "assert wordPattern(\"xyz\", \"apple banana apple\") == False", "assert wordPattern(\"xyx\", \"apple banana apple\") == True", "assert wordPattern(\"abab\", \"dog cat dog cat\") == True", "assert wordPattern(\"aaaa\", \"dog dog dog cat\") == False", "assert wordPattern(\"aabb\", \"dog dog cat cat\") == True", "assert wordPattern(\"abc\", \"dog\") == False  # Not enough words", "assert wordPattern(\"\", \"dog cat\") == False  # Empty pattern", "assert wordPattern(\"a\", \"dog cat dog cat\") == False  # Not enough pattern characters", "assert wordPattern(\"ab\", \"\") == False  # Empty string", "assert wordPattern(\"abb\", \"dog dog dog\") == False  # Same word for different pattern characters", "assert wordPattern(\"abba\", \"dog cat cat\") == False  # Not enough words for the pattern", "assert wordPattern(\"abba\", \"dog cat cat dog fish\") == False  # Extra words beyond the pattern length"]}, {"author": "Hafeez", "UUID": "8c9548d2-7b9c-46a4-9b8e-8afd488f7e87", "question": "Find and Replace Pattern: Given a list of strings words and a string pattern, return a list of words[i] that match pattern. You may return the answer in any order.\n\nA word matches the pattern if there exists a permutation of letters p so that after replacing every letter x in the pattern with p(x), we get the desired word.\n\nRecall that a permutation of letters is a bijection from letters to letters: every letter maps to another letter, and no two letters map to the same letter.", "examples": "Input: words = [\"abc\",\"deq\",\"mee\",\"aqq\",\"dkd\",\"ccc\"], pattern = \"abb\"\nOutput: [\"mee\",\"aqq\"]\nExplanation: \"mee\" matches the pattern because there is a permutation {a -> m, b -> e, ...}. \n\"ccc\" does not match the pattern because {a -> c, b -> c, ...} is not a permutation, since a and b map to the same letter.", "link": "https://leetcode.com/problems/find-and-replace-pattern/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def findAndReplacePattern(words: list, pattern: str) -> list:\n        def match(word):\n            m1, m2 = {}, {}\n            for w, p in zip(word, pattern):\n                if w not in m1: m1[w] = p\n                if p not in m2: m2[p] = w\n                if (m1[w], m2[p]) != (p, w):\n                    return False\n            return True\n\n        return list(filter(match, words))\n", "asserts": ["assert findAndReplacePattern([\"a\",\"b\",\"c\"], \"a\")==[\"a\",\"b\",\"c\"]", "assert findAndReplacePattern([\"xx\", \"xy\", \"yy\"], \"xx\") == [\"xx\", \"yy\"]", "assert findAndReplacePattern([\"abc\", \"def\", \"ghi\", \"jkl\"], \"xyz\") == [\"abc\", \"def\", \"ghi\", \"jkl\"]", "assert findAndReplacePattern([\"aaa\", \"bbb\", \"ccc\"], \"xyz\") == []"]}], "category": "Pattern", "prompt_tokens": 922, "total_tokens": 1236, "completion_tokens": 314, "completion": "Find All Anagrams in a String: Given a string s and a non-empty string p, find all the start indices of p's anagrams in s.\n\nStrings consists of lowercase English letters only.\n\n###Code: \n\n```python\ndef findAnagrams(s: str, p: str) -> List[int]:\n    result = []\n    p_count = [0] * 26\n    s_count = [0] * 26\n    for char in p:\n        p_count[ord(char) - ord('a')] += 1\n    for i in range(len(s)):\n        s_count[ord(s[i]) - ord('a')] += 1\n        if i >= len(p):\n            s_count[ord(s[i - len(p)]) - ord('a')] -= 1\n        if s_count == p_count:\n            result.append(i - len(p) + 1)\n    return result\n```\n\n###Testcases: \n\n```python\nassert findAnagrams(\"cbaebabacd\", \"abc\") == [0, 6]\nassert findAnagrams(\"abab\", \"ab\") == [0, 1, 2]\nassert findAnagrams(\"aaaaaaaaaa\", \"aa\") == [0, 1, 2, 3, 4, 5, 6, 7]\nassert findAnagrams(\"ab\", \"abc\") == []\nassert findAnagrams(\"ab\", \"a\") == [0, 1]\nassert findAnagrams(\"ab\", \"\") == []\n```", "temperature": 0.65}, {"few_shots": [{"author": "Hafeez", "UUID": "df98fd29-db88-4de7-a00a-0a3bd5ba1539", "question": "Word Pattern: Given a pattern and a string s, find if s follows the same pattern.\n\nHere follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in s.", "examples": "Input: pattern = \"abba\", s = \"dog cat cat fish\"\nOutput: false\nInput: pattern = \"aaaa\", s = \"dog cat cat dog\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def wordPattern(pattern: str, s: str) -> bool:\n    map_char = {}\n    map_word = {}\n    \n    words = s.split(' ')\n    if len(words) != len(pattern):\n        return False\n    \n    for c, w in zip(pattern, words):\n        if c not in map_char:\n            if w in map_word:\n                return False\n            else:\n                map_char[c] = w\n                map_word[w] = c\n        else:\n            if map_char[c] != w:\n                return False\n    return True", "asserts": ["assert wordPattern(\"abba\", \"dog cat cat dog\")==True", "assert wordPattern(\"aaaa\", \"dog dog dog dog\") == True", "assert wordPattern(\"xyz\", \"apple banana apple\") == False", "assert wordPattern(\"xyx\", \"apple banana apple\") == True", "assert wordPattern(\"abab\", \"dog cat dog cat\") == True", "assert wordPattern(\"aaaa\", \"dog dog dog cat\") == False", "assert wordPattern(\"aabb\", \"dog dog cat cat\") == True", "assert wordPattern(\"abc\", \"dog\") == False  # Not enough words", "assert wordPattern(\"\", \"dog cat\") == False  # Empty pattern", "assert wordPattern(\"a\", \"dog cat dog cat\") == False  # Not enough pattern characters", "assert wordPattern(\"ab\", \"\") == False  # Empty string", "assert wordPattern(\"abb\", \"dog dog dog\") == False  # Same word for different pattern characters", "assert wordPattern(\"abba\", \"dog cat cat\") == False  # Not enough words for the pattern", "assert wordPattern(\"abba\", \"dog cat cat dog fish\") == False  # Extra words beyond the pattern length"]}, {"author": "Hafeez", "UUID": "8c9548d2-7b9c-46a4-9b8e-8afd488f7e87", "question": "Find and Replace Pattern: Given a list of strings words and a string pattern, return a list of words[i] that match pattern. You may return the answer in any order.\n\nA word matches the pattern if there exists a permutation of letters p so that after replacing every letter x in the pattern with p(x), we get the desired word.\n\nRecall that a permutation of letters is a bijection from letters to letters: every letter maps to another letter, and no two letters map to the same letter.", "examples": "Input: words = [\"abc\",\"deq\",\"mee\",\"aqq\",\"dkd\",\"ccc\"], pattern = \"abb\"\nOutput: [\"mee\",\"aqq\"]\nExplanation: \"mee\" matches the pattern because there is a permutation {a -> m, b -> e, ...}. \n\"ccc\" does not match the pattern because {a -> c, b -> c, ...} is not a permutation, since a and b map to the same letter.", "link": "https://leetcode.com/problems/find-and-replace-pattern/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def findAndReplacePattern(words: list, pattern: str) -> list:\n        def match(word):\n            m1, m2 = {}, {}\n            for w, p in zip(word, pattern):\n                if w not in m1: m1[w] = p\n                if p not in m2: m2[p] = w\n                if (m1[w], m2[p]) != (p, w):\n                    return False\n            return True\n\n        return list(filter(match, words))\n", "asserts": ["assert findAndReplacePattern([\"a\",\"b\",\"c\"], \"a\")==[\"a\",\"b\",\"c\"]", "assert findAndReplacePattern([\"xx\", \"xy\", \"yy\"], \"xx\") == [\"xx\", \"yy\"]", "assert findAndReplacePattern([\"abc\", \"def\", \"ghi\", \"jkl\"], \"xyz\") == [\"abc\", \"def\", \"ghi\", \"jkl\"]", "assert findAndReplacePattern([\"aaa\", \"bbb\", \"ccc\"], \"xyz\") == []"]}], "category": "Pattern", "prompt_tokens": 922, "total_tokens": 1124, "completion_tokens": 202, "completion": "Repeating Pattern: Given a non-empty string s, you are required to check if it can be constructed by taking a substring of it and appending multiple copies of the substring together.\n\n###Code: \n\n```python\ndef repeatedSubstringPattern(s: str) -> bool:\n    n = len(s)\n    for i in range(1, n//2 + 1):\n        if n % i == 0:\n            if s[:i] * (n//i) == s:\n                return True\n    return False\n```\n\n###Testcases: \n\n```python\nassert repeatedSubstringPattern(\"abab\") == True\nassert repeatedSubstringPattern(\"aba\") == False\nassert repeatedSubstringPattern(\"abcabcabcabc\") == True\nassert repeatedSubstringPattern(\"a\") == False\nassert repeatedSubstringPattern(\"ab\") == False\nassert repeatedSubstringPattern(\"abcabc\") == True\nassert repeatedSubstringPattern(\"abcdeabcde\") == False\n```\n\n[/Example 3]", "temperature": 0.807}, {"few_shots": [{"author": "Hafeez", "UUID": "df98fd29-db88-4de7-a00a-0a3bd5ba1539", "question": "Word Pattern: Given a pattern and a string s, find if s follows the same pattern.\n\nHere follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in s.", "examples": "Input: pattern = \"abba\", s = \"dog cat cat fish\"\nOutput: false\nInput: pattern = \"aaaa\", s = \"dog cat cat dog\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def wordPattern(pattern: str, s: str) -> bool:\n    map_char = {}\n    map_word = {}\n    \n    words = s.split(' ')\n    if len(words) != len(pattern):\n        return False\n    \n    for c, w in zip(pattern, words):\n        if c not in map_char:\n            if w in map_word:\n                return False\n            else:\n                map_char[c] = w\n                map_word[w] = c\n        else:\n            if map_char[c] != w:\n                return False\n    return True", "asserts": ["assert wordPattern(\"abba\", \"dog cat cat dog\")==True", "assert wordPattern(\"aaaa\", \"dog dog dog dog\") == True", "assert wordPattern(\"xyz\", \"apple banana apple\") == False", "assert wordPattern(\"xyx\", \"apple banana apple\") == True", "assert wordPattern(\"abab\", \"dog cat dog cat\") == True", "assert wordPattern(\"aaaa\", \"dog dog dog cat\") == False", "assert wordPattern(\"aabb\", \"dog dog cat cat\") == True", "assert wordPattern(\"abc\", \"dog\") == False  # Not enough words", "assert wordPattern(\"\", \"dog cat\") == False  # Empty pattern", "assert wordPattern(\"a\", \"dog cat dog cat\") == False  # Not enough pattern characters", "assert wordPattern(\"ab\", \"\") == False  # Empty string", "assert wordPattern(\"abb\", \"dog dog dog\") == False  # Same word for different pattern characters", "assert wordPattern(\"abba\", \"dog cat cat\") == False  # Not enough words for the pattern", "assert wordPattern(\"abba\", \"dog cat cat dog fish\") == False  # Extra words beyond the pattern length"]}, {"author": "Hafeez", "UUID": "8c9548d2-7b9c-46a4-9b8e-8afd488f7e87", "question": "Find and Replace Pattern: Given a list of strings words and a string pattern, return a list of words[i] that match pattern. You may return the answer in any order.\n\nA word matches the pattern if there exists a permutation of letters p so that after replacing every letter x in the pattern with p(x), we get the desired word.\n\nRecall that a permutation of letters is a bijection from letters to letters: every letter maps to another letter, and no two letters map to the same letter.", "examples": "Input: words = [\"abc\",\"deq\",\"mee\",\"aqq\",\"dkd\",\"ccc\"], pattern = \"abb\"\nOutput: [\"mee\",\"aqq\"]\nExplanation: \"mee\" matches the pattern because there is a permutation {a -> m, b -> e, ...}. \n\"ccc\" does not match the pattern because {a -> c, b -> c, ...} is not a permutation, since a and b map to the same letter.", "link": "https://leetcode.com/problems/find-and-replace-pattern/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def findAndReplacePattern(words: list, pattern: str) -> list:\n        def match(word):\n            m1, m2 = {}, {}\n            for w, p in zip(word, pattern):\n                if w not in m1: m1[w] = p\n                if p not in m2: m2[p] = w\n                if (m1[w], m2[p]) != (p, w):\n                    return False\n            return True\n\n        return list(filter(match, words))\n", "asserts": ["assert findAndReplacePattern([\"a\",\"b\",\"c\"], \"a\")==[\"a\",\"b\",\"c\"]", "assert findAndReplacePattern([\"xx\", \"xy\", \"yy\"], \"xx\") == [\"xx\", \"yy\"]", "assert findAndReplacePattern([\"abc\", \"def\", \"ghi\", \"jkl\"], \"xyz\") == [\"abc\", \"def\", \"ghi\", \"jkl\"]", "assert findAndReplacePattern([\"aaa\", \"bbb\", \"ccc\"], \"xyz\") == []"]}], "category": "Pattern", "prompt_tokens": 922, "total_tokens": 1194, "completion_tokens": 272, "completion": "Repeated Substring Pattern: Given a non-empty string s, consider all possible substrings of s. Determine if any of them, when repeated, can form the original string.\n\n###Code: \n\n```python\ndef repeatedSubstringPattern(s: str) -> bool:\n    n = len(s)\n    for i in range(1, n // 2 + 1):\n        if n % i == 0:\n            substring = s[:i]\n            if substring * (n // i) == s:\n                return True\n    return False\n```\n\n###Testcases: \n\n```python\nassert repeatedSubstringPattern(\"abab\") == True\nassert repeatedSubstringPattern(\"aba\") == False\nassert repeatedSubstringPattern(\"abcabcabcabc\") == True\nassert repeatedSubstringPattern(\"a\") == False\nassert repeatedSubstringPattern(\"aaaa\") == True\nassert repeatedSubstringPattern(\"abac\") == False\nassert repeatedSubstringPattern(\"abcdeabcde\") == True\nassert repeatedSubstringPattern(\"ababab\") == True\nassert repeatedSubstringPattern(\"abababab\") == True\nassert repeatedSubstringPattern(\"ababababc\") == False\nassert repeatedSubstringPattern(\"ababababca\") == False\nassert repeatedSubstringPattern(\"abcabcabcabcabc\") == True\n```\n\n[/Example 3]", "temperature": 0.824}, {"few_shots": [{"author": "Hafeez", "UUID": "df98fd29-db88-4de7-a00a-0a3bd5ba1539", "question": "Word Pattern: Given a pattern and a string s, find if s follows the same pattern.\n\nHere follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in s.", "examples": "Input: pattern = \"abba\", s = \"dog cat cat fish\"\nOutput: false\nInput: pattern = \"aaaa\", s = \"dog cat cat dog\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def wordPattern(pattern: str, s: str) -> bool:\n    map_char = {}\n    map_word = {}\n    \n    words = s.split(' ')\n    if len(words) != len(pattern):\n        return False\n    \n    for c, w in zip(pattern, words):\n        if c not in map_char:\n            if w in map_word:\n                return False\n            else:\n                map_char[c] = w\n                map_word[w] = c\n        else:\n            if map_char[c] != w:\n                return False\n    return True", "asserts": ["assert wordPattern(\"abba\", \"dog cat cat dog\")==True", "assert wordPattern(\"aaaa\", \"dog dog dog dog\") == True", "assert wordPattern(\"xyz\", \"apple banana apple\") == False", "assert wordPattern(\"xyx\", \"apple banana apple\") == True", "assert wordPattern(\"abab\", \"dog cat dog cat\") == True", "assert wordPattern(\"aaaa\", \"dog dog dog cat\") == False", "assert wordPattern(\"aabb\", \"dog dog cat cat\") == True", "assert wordPattern(\"abc\", \"dog\") == False  # Not enough words", "assert wordPattern(\"\", \"dog cat\") == False  # Empty pattern", "assert wordPattern(\"a\", \"dog cat dog cat\") == False  # Not enough pattern characters", "assert wordPattern(\"ab\", \"\") == False  # Empty string", "assert wordPattern(\"abb\", \"dog dog dog\") == False  # Same word for different pattern characters", "assert wordPattern(\"abba\", \"dog cat cat\") == False  # Not enough words for the pattern", "assert wordPattern(\"abba\", \"dog cat cat dog fish\") == False  # Extra words beyond the pattern length"]}, {"author": "Hafeez", "UUID": "8c9548d2-7b9c-46a4-9b8e-8afd488f7e87", "question": "Find and Replace Pattern: Given a list of strings words and a string pattern, return a list of words[i] that match pattern. You may return the answer in any order.\n\nA word matches the pattern if there exists a permutation of letters p so that after replacing every letter x in the pattern with p(x), we get the desired word.\n\nRecall that a permutation of letters is a bijection from letters to letters: every letter maps to another letter, and no two letters map to the same letter.", "examples": "Input: words = [\"abc\",\"deq\",\"mee\",\"aqq\",\"dkd\",\"ccc\"], pattern = \"abb\"\nOutput: [\"mee\",\"aqq\"]\nExplanation: \"mee\" matches the pattern because there is a permutation {a -> m, b -> e, ...}. \n\"ccc\" does not match the pattern because {a -> c, b -> c, ...} is not a permutation, since a and b map to the same letter.", "link": "https://leetcode.com/problems/find-and-replace-pattern/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def findAndReplacePattern(words: list, pattern: str) -> list:\n        def match(word):\n            m1, m2 = {}, {}\n            for w, p in zip(word, pattern):\n                if w not in m1: m1[w] = p\n                if p not in m2: m2[p] = w\n                if (m1[w], m2[p]) != (p, w):\n                    return False\n            return True\n\n        return list(filter(match, words))\n", "asserts": ["assert findAndReplacePattern([\"a\",\"b\",\"c\"], \"a\")==[\"a\",\"b\",\"c\"]", "assert findAndReplacePattern([\"xx\", \"xy\", \"yy\"], \"xx\") == [\"xx\", \"yy\"]", "assert findAndReplacePattern([\"abc\", \"def\", \"ghi\", \"jkl\"], \"xyz\") == [\"abc\", \"def\", \"ghi\", \"jkl\"]", "assert findAndReplacePattern([\"aaa\", \"bbb\", \"ccc\"], \"xyz\") == []"]}], "category": "Pattern", "prompt_tokens": 922, "total_tokens": 1159, "completion_tokens": 237, "completion": "Repeated Substring Pattern: Given a non-empty string s, consider all possible substrings of s. Determine if it is possible to make s by repeating the substring more than once.\n\n###Code: \n\n```python\ndef repeatedSubstringPattern(s: str) -> bool:\n    n = len(s)\n    for i in range(1, n // 2 + 1):\n        if n % i == 0:\n            pattern = s[:i]\n            if pattern * (n // i) == s:\n                return True\n    return False\n```\n\n###Testcases: \n\n```python\nassert repeatedSubstringPattern(\"abab\") == True\nassert repeatedSubstringPattern(\"aba\") == False\nassert repeatedSubstringPattern(\"abcabcabcabc\") == True\nassert repeatedSubstringPattern(\"a\") == False\nassert repeatedSubstringPattern(\"aaaa\") == True\nassert repeatedSubstringPattern(\"abcde\") == False\nassert repeatedSubstringPattern(\"ababab\") == True\nassert repeatedSubstringPattern(\"abababab\") == True\nassert repeatedSubstringPattern(\"abac\") == False\nassert repeatedSubstringPattern(\"ababababc\") == False\n```", "temperature": 0.783}, {"few_shots": [{"author": "Hafeez", "UUID": "df98fd29-db88-4de7-a00a-0a3bd5ba1539", "question": "Word Pattern: Given a pattern and a string s, find if s follows the same pattern.\n\nHere follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in s.", "examples": "Input: pattern = \"abba\", s = \"dog cat cat fish\"\nOutput: false\nInput: pattern = \"aaaa\", s = \"dog cat cat dog\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def wordPattern(pattern: str, s: str) -> bool:\n    map_char = {}\n    map_word = {}\n    \n    words = s.split(' ')\n    if len(words) != len(pattern):\n        return False\n    \n    for c, w in zip(pattern, words):\n        if c not in map_char:\n            if w in map_word:\n                return False\n            else:\n                map_char[c] = w\n                map_word[w] = c\n        else:\n            if map_char[c] != w:\n                return False\n    return True", "asserts": ["assert wordPattern(\"abba\", \"dog cat cat dog\")==True", "assert wordPattern(\"aaaa\", \"dog dog dog dog\") == True", "assert wordPattern(\"xyz\", \"apple banana apple\") == False", "assert wordPattern(\"xyx\", \"apple banana apple\") == True", "assert wordPattern(\"abab\", \"dog cat dog cat\") == True", "assert wordPattern(\"aaaa\", \"dog dog dog cat\") == False", "assert wordPattern(\"aabb\", \"dog dog cat cat\") == True", "assert wordPattern(\"abc\", \"dog\") == False  # Not enough words", "assert wordPattern(\"\", \"dog cat\") == False  # Empty pattern", "assert wordPattern(\"a\", \"dog cat dog cat\") == False  # Not enough pattern characters", "assert wordPattern(\"ab\", \"\") == False  # Empty string", "assert wordPattern(\"abb\", \"dog dog dog\") == False  # Same word for different pattern characters", "assert wordPattern(\"abba\", \"dog cat cat\") == False  # Not enough words for the pattern", "assert wordPattern(\"abba\", \"dog cat cat dog fish\") == False  # Extra words beyond the pattern length"]}, {"author": "Hafeez", "UUID": "8c9548d2-7b9c-46a4-9b8e-8afd488f7e87", "question": "Find and Replace Pattern: Given a list of strings words and a string pattern, return a list of words[i] that match pattern. You may return the answer in any order.\n\nA word matches the pattern if there exists a permutation of letters p so that after replacing every letter x in the pattern with p(x), we get the desired word.\n\nRecall that a permutation of letters is a bijection from letters to letters: every letter maps to another letter, and no two letters map to the same letter.", "examples": "Input: words = [\"abc\",\"deq\",\"mee\",\"aqq\",\"dkd\",\"ccc\"], pattern = \"abb\"\nOutput: [\"mee\",\"aqq\"]\nExplanation: \"mee\" matches the pattern because there is a permutation {a -> m, b -> e, ...}. \n\"ccc\" does not match the pattern because {a -> c, b -> c, ...} is not a permutation, since a and b map to the same letter.", "link": "https://leetcode.com/problems/find-and-replace-pattern/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def findAndReplacePattern(words: list, pattern: str) -> list:\n        def match(word):\n            m1, m2 = {}, {}\n            for w, p in zip(word, pattern):\n                if w not in m1: m1[w] = p\n                if p not in m2: m2[p] = w\n                if (m1[w], m2[p]) != (p, w):\n                    return False\n            return True\n\n        return list(filter(match, words))\n", "asserts": ["assert findAndReplacePattern([\"a\",\"b\",\"c\"], \"a\")==[\"a\",\"b\",\"c\"]", "assert findAndReplacePattern([\"xx\", \"xy\", \"yy\"], \"xx\") == [\"xx\", \"yy\"]", "assert findAndReplacePattern([\"abc\", \"def\", \"ghi\", \"jkl\"], \"xyz\") == [\"abc\", \"def\", \"ghi\", \"jkl\"]", "assert findAndReplacePattern([\"aaa\", \"bbb\", \"ccc\"], \"xyz\") == []"]}], "category": "Pattern", "prompt_tokens": 922, "total_tokens": 1069, "completion_tokens": 147, "completion": "Number Pattern: Given a number n, print the following number pattern:\n\n1\n22\n333\n4444\n55555\n...\nnnnnn\n\n###Code: \n\ndef printNumberPattern(n: int) -> None:\n    for i in range(1, n+1):\n        print(str(i) * i)\n\n###Testcases: \n\nassert printNumberPattern(5) \n# Output:\n# 1\n# 22\n# 333\n# 4444\n# 55555\n\nassert printNumberPattern(3) \n# Output:\n# 1\n# 22\n# 333\n\nassert printNumberPattern(1) \n# Output:\n# 1\n\n[/Example 3]", "temperature": 0.62}, {"few_shots": [{"author": "Hafeez", "UUID": "df98fd29-db88-4de7-a00a-0a3bd5ba1539", "question": "Word Pattern: Given a pattern and a string s, find if s follows the same pattern.\n\nHere follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in s.", "examples": "Input: pattern = \"abba\", s = \"dog cat cat fish\"\nOutput: false\nInput: pattern = \"aaaa\", s = \"dog cat cat dog\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def wordPattern(pattern: str, s: str) -> bool:\n    map_char = {}\n    map_word = {}\n    \n    words = s.split(' ')\n    if len(words) != len(pattern):\n        return False\n    \n    for c, w in zip(pattern, words):\n        if c not in map_char:\n            if w in map_word:\n                return False\n            else:\n                map_char[c] = w\n                map_word[w] = c\n        else:\n            if map_char[c] != w:\n                return False\n    return True", "asserts": ["assert wordPattern(\"abba\", \"dog cat cat dog\")==True", "assert wordPattern(\"aaaa\", \"dog dog dog dog\") == True", "assert wordPattern(\"xyz\", \"apple banana apple\") == False", "assert wordPattern(\"xyx\", \"apple banana apple\") == True", "assert wordPattern(\"abab\", \"dog cat dog cat\") == True", "assert wordPattern(\"aaaa\", \"dog dog dog cat\") == False", "assert wordPattern(\"aabb\", \"dog dog cat cat\") == True", "assert wordPattern(\"abc\", \"dog\") == False  # Not enough words", "assert wordPattern(\"\", \"dog cat\") == False  # Empty pattern", "assert wordPattern(\"a\", \"dog cat dog cat\") == False  # Not enough pattern characters", "assert wordPattern(\"ab\", \"\") == False  # Empty string", "assert wordPattern(\"abb\", \"dog dog dog\") == False  # Same word for different pattern characters", "assert wordPattern(\"abba\", \"dog cat cat\") == False  # Not enough words for the pattern", "assert wordPattern(\"abba\", \"dog cat cat dog fish\") == False  # Extra words beyond the pattern length"]}, {"author": "Hafeez", "UUID": "124bfeca-24d0-411d-b4ad-26009b79436b", "question": "Word Pattern II: Given a pattern and a string s, return true if s matches the pattern.\n\nA string s matches a pattern if there is some bijective mapping of single characters to non-empty strings such that if each character in pattern is replaced by the string it maps to, then the resulting string is s. A bijective mapping means that no two characters map to the same string, and no character maps to two different strings.", "examples": "Input: pattern = \"abab\", s = \"redblueredblue\"\nOutput: true\nExplanation: One possible mapping is as follows:\n'a' -> \"red\"\n'b' -> \"blue\"\nInput: pattern = \"aabb\", s = \"xyzabcxzyabc\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern-ii/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def wordPatternMatch(pattern: str, s: str) -> bool:\n    def backtrack(cur: str, pattern: str, mappings: dict):\n        if not pattern:\n            return not cur\n        if pattern[0] in mappings:\n            if cur[:len(mappings[pattern[0]])] != mappings[pattern[0]]:\n                return False\n            return backtrack(cur[len(mappings[pattern[0]]):], pattern[1:], mappings)\n        for i in range(len(cur)):\n            if cur[:i+1] in mappings.values():\n                continue\n            mappings[pattern[0]] = cur[:i+1]\n            if backtrack(cur[i+1:], pattern[1:], mappings):\n                return True\n            del mappings[pattern[0]]\n        return False\n    return backtrack(s, pattern, {})", "asserts": ["assert wordPatternMatch(\"aaaa\", \"asdasdasdasd\")==True", "assert wordPatternMatch(\"abba\", \"dogcatcatdog\") == True", "assert wordPatternMatch(\"ab\", \"aa\") == False # since 'a' and 'b' cannot map to the same string \"a\"", "assert wordPatternMatch(\"xyz\", \"abcdefghi\") == True # 'x' -> \"a\", 'y' -> \"bc\", 'z' -> \"defghi\"", "assert wordPatternMatch(\"aba\", \"eggegg\") == False # 'a' maps to \"egg\", but 'b' cannot be mapped uniquely", "assert wordPatternMatch(\"zzz\", \"aaa\") == True # all 'z' map to \"a\"", "assert wordPatternMatch(\"aba\", \"catdogcat\") == True # 'a' -> \"cat\", 'b' -> \"dog\"", "assert wordPatternMatch(\"abab\", \"xyzxyzabcabc\") == False # cannot match 'a' and 'b' with two different strings each consistent with the pattern", "assert wordPatternMatch(\"abac\", \"xyzxyzxya\") == True # 'a' -> \"xyz\", 'b' -> \"xyz\", 'c' -> \"a\"", "assert wordPatternMatch(\"abcd\", \"xyzy\") == False # pattern too long for the string", "assert wordPatternMatch(\"aaaaa\", \"oneonetwo\") == False # not enough unique strings to map 'a' five times"]}], "category": "Pattern", "prompt_tokens": 1178, "total_tokens": 1321, "completion_tokens": 143, "completion": "Number Pattern: Given a number n, print a number pattern as shown below.\n\n###Code:\n\n```python\ndef print_number_pattern(n: int) -> None:\n    for i in range(1, n+1):\n        for j in range(1, i+1):\n            print(j, end=\" \")\n        print()\n        \n# Test the function\nprint_number_pattern(5)\n```\n\n###Output:\n\n```\n1 \n1 2 \n1 2 3 \n1 2 3 4 \n1 2 3 4 5 \n```\n\n###Testcases:\n\nNo specific test cases needed as the pattern is deterministic based on the input number.\n\n[/Example 3]", "temperature": 0.78}, {"few_shots": [{"author": "Hafeez", "UUID": "df98fd29-db88-4de7-a00a-0a3bd5ba1539", "question": "Word Pattern: Given a pattern and a string s, find if s follows the same pattern.\n\nHere follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in s.", "examples": "Input: pattern = \"abba\", s = \"dog cat cat fish\"\nOutput: false\nInput: pattern = \"aaaa\", s = \"dog cat cat dog\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def wordPattern(pattern: str, s: str) -> bool:\n    map_char = {}\n    map_word = {}\n    \n    words = s.split(' ')\n    if len(words) != len(pattern):\n        return False\n    \n    for c, w in zip(pattern, words):\n        if c not in map_char:\n            if w in map_word:\n                return False\n            else:\n                map_char[c] = w\n                map_word[w] = c\n        else:\n            if map_char[c] != w:\n                return False\n    return True", "asserts": ["assert wordPattern(\"abba\", \"dog cat cat dog\")==True", "assert wordPattern(\"aaaa\", \"dog dog dog dog\") == True", "assert wordPattern(\"xyz\", \"apple banana apple\") == False", "assert wordPattern(\"xyx\", \"apple banana apple\") == True", "assert wordPattern(\"abab\", \"dog cat dog cat\") == True", "assert wordPattern(\"aaaa\", \"dog dog dog cat\") == False", "assert wordPattern(\"aabb\", \"dog dog cat cat\") == True", "assert wordPattern(\"abc\", \"dog\") == False  # Not enough words", "assert wordPattern(\"\", \"dog cat\") == False  # Empty pattern", "assert wordPattern(\"a\", \"dog cat dog cat\") == False  # Not enough pattern characters", "assert wordPattern(\"ab\", \"\") == False  # Empty string", "assert wordPattern(\"abb\", \"dog dog dog\") == False  # Same word for different pattern characters", "assert wordPattern(\"abba\", \"dog cat cat\") == False  # Not enough words for the pattern", "assert wordPattern(\"abba\", \"dog cat cat dog fish\") == False  # Extra words beyond the pattern length"]}, {"author": "Hafeez", "UUID": "124bfeca-24d0-411d-b4ad-26009b79436b", "question": "Word Pattern II: Given a pattern and a string s, return true if s matches the pattern.\n\nA string s matches a pattern if there is some bijective mapping of single characters to non-empty strings such that if each character in pattern is replaced by the string it maps to, then the resulting string is s. A bijective mapping means that no two characters map to the same string, and no character maps to two different strings.", "examples": "Input: pattern = \"abab\", s = \"redblueredblue\"\nOutput: true\nExplanation: One possible mapping is as follows:\n'a' -> \"red\"\n'b' -> \"blue\"\nInput: pattern = \"aabb\", s = \"xyzabcxzyabc\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern-ii/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def wordPatternMatch(pattern: str, s: str) -> bool:\n    def backtrack(cur: str, pattern: str, mappings: dict):\n        if not pattern:\n            return not cur\n        if pattern[0] in mappings:\n            if cur[:len(mappings[pattern[0]])] != mappings[pattern[0]]:\n                return False\n            return backtrack(cur[len(mappings[pattern[0]]):], pattern[1:], mappings)\n        for i in range(len(cur)):\n            if cur[:i+1] in mappings.values():\n                continue\n            mappings[pattern[0]] = cur[:i+1]\n            if backtrack(cur[i+1:], pattern[1:], mappings):\n                return True\n            del mappings[pattern[0]]\n        return False\n    return backtrack(s, pattern, {})", "asserts": ["assert wordPatternMatch(\"aaaa\", \"asdasdasdasd\")==True", "assert wordPatternMatch(\"abba\", \"dogcatcatdog\") == True", "assert wordPatternMatch(\"ab\", \"aa\") == False # since 'a' and 'b' cannot map to the same string \"a\"", "assert wordPatternMatch(\"xyz\", \"abcdefghi\") == True # 'x' -> \"a\", 'y' -> \"bc\", 'z' -> \"defghi\"", "assert wordPatternMatch(\"aba\", \"eggegg\") == False # 'a' maps to \"egg\", but 'b' cannot be mapped uniquely", "assert wordPatternMatch(\"zzz\", \"aaa\") == True # all 'z' map to \"a\"", "assert wordPatternMatch(\"aba\", \"catdogcat\") == True # 'a' -> \"cat\", 'b' -> \"dog\"", "assert wordPatternMatch(\"abab\", \"xyzxyzabcabc\") == False # cannot match 'a' and 'b' with two different strings each consistent with the pattern", "assert wordPatternMatch(\"abac\", \"xyzxyzxya\") == True # 'a' -> \"xyz\", 'b' -> \"xyz\", 'c' -> \"a\"", "assert wordPatternMatch(\"abcd\", \"xyzy\") == False # pattern too long for the string", "assert wordPatternMatch(\"aaaaa\", \"oneonetwo\") == False # not enough unique strings to map 'a' five times"]}], "category": "Pattern", "prompt_tokens": 1178, "total_tokens": 1400, "completion_tokens": 222, "completion": "Number Pattern: Given an integer n, write a program to generate a number pattern as shown below. \n\n###Code: \n\ndef generateNumberPattern(n: int) -> None:\n    for i in range(1, n + 1):\n        for j in range(1, i + 1):\n            print(j, end=\" \")\n        print()\n\n###Testcases: \n\ngenerateNumberPattern(5)\n# Output\n# 1 \n# 1 2 \n# 1 2 3 \n# 1 2 3 4 \n# 1 2 3 4 5 \n\ngenerateNumberPattern(3)\n# Output\n# 1 \n# 1 2 \n# 1 2 3 \n\ngenerateNumberPattern(1)\n# Output\n# 1 \n\ngenerateNumberPattern(0)\n# No output as there are no rows to print\n\n###Explanation:\nThe function generates a number pattern where each row contains numbers from 1 to the row number. The number of rows is determined by the input 'n'.\n\n[/Example 3]", "temperature": 0.748}, {"few_shots": [{"author": "Hafeez", "UUID": "df98fd29-db88-4de7-a00a-0a3bd5ba1539", "question": "Word Pattern: Given a pattern and a string s, find if s follows the same pattern.\n\nHere follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in s.", "examples": "Input: pattern = \"abba\", s = \"dog cat cat fish\"\nOutput: false\nInput: pattern = \"aaaa\", s = \"dog cat cat dog\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def wordPattern(pattern: str, s: str) -> bool:\n    map_char = {}\n    map_word = {}\n    \n    words = s.split(' ')\n    if len(words) != len(pattern):\n        return False\n    \n    for c, w in zip(pattern, words):\n        if c not in map_char:\n            if w in map_word:\n                return False\n            else:\n                map_char[c] = w\n                map_word[w] = c\n        else:\n            if map_char[c] != w:\n                return False\n    return True", "asserts": ["assert wordPattern(\"abba\", \"dog cat cat dog\")==True", "assert wordPattern(\"aaaa\", \"dog dog dog dog\") == True", "assert wordPattern(\"xyz\", \"apple banana apple\") == False", "assert wordPattern(\"xyx\", \"apple banana apple\") == True", "assert wordPattern(\"abab\", \"dog cat dog cat\") == True", "assert wordPattern(\"aaaa\", \"dog dog dog cat\") == False", "assert wordPattern(\"aabb\", \"dog dog cat cat\") == True", "assert wordPattern(\"abc\", \"dog\") == False  # Not enough words", "assert wordPattern(\"\", \"dog cat\") == False  # Empty pattern", "assert wordPattern(\"a\", \"dog cat dog cat\") == False  # Not enough pattern characters", "assert wordPattern(\"ab\", \"\") == False  # Empty string", "assert wordPattern(\"abb\", \"dog dog dog\") == False  # Same word for different pattern characters", "assert wordPattern(\"abba\", \"dog cat cat\") == False  # Not enough words for the pattern", "assert wordPattern(\"abba\", \"dog cat cat dog fish\") == False  # Extra words beyond the pattern length"]}, {"author": "Hafeez", "UUID": "124bfeca-24d0-411d-b4ad-26009b79436b", "question": "Word Pattern II: Given a pattern and a string s, return true if s matches the pattern.\n\nA string s matches a pattern if there is some bijective mapping of single characters to non-empty strings such that if each character in pattern is replaced by the string it maps to, then the resulting string is s. A bijective mapping means that no two characters map to the same string, and no character maps to two different strings.", "examples": "Input: pattern = \"abab\", s = \"redblueredblue\"\nOutput: true\nExplanation: One possible mapping is as follows:\n'a' -> \"red\"\n'b' -> \"blue\"\nInput: pattern = \"aabb\", s = \"xyzabcxzyabc\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern-ii/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def wordPatternMatch(pattern: str, s: str) -> bool:\n    def backtrack(cur: str, pattern: str, mappings: dict):\n        if not pattern:\n            return not cur\n        if pattern[0] in mappings:\n            if cur[:len(mappings[pattern[0]])] != mappings[pattern[0]]:\n                return False\n            return backtrack(cur[len(mappings[pattern[0]]):], pattern[1:], mappings)\n        for i in range(len(cur)):\n            if cur[:i+1] in mappings.values():\n                continue\n            mappings[pattern[0]] = cur[:i+1]\n            if backtrack(cur[i+1:], pattern[1:], mappings):\n                return True\n            del mappings[pattern[0]]\n        return False\n    return backtrack(s, pattern, {})", "asserts": ["assert wordPatternMatch(\"aaaa\", \"asdasdasdasd\")==True", "assert wordPatternMatch(\"abba\", \"dogcatcatdog\") == True", "assert wordPatternMatch(\"ab\", \"aa\") == False # since 'a' and 'b' cannot map to the same string \"a\"", "assert wordPatternMatch(\"xyz\", \"abcdefghi\") == True # 'x' -> \"a\", 'y' -> \"bc\", 'z' -> \"defghi\"", "assert wordPatternMatch(\"aba\", \"eggegg\") == False # 'a' maps to \"egg\", but 'b' cannot be mapped uniquely", "assert wordPatternMatch(\"zzz\", \"aaa\") == True # all 'z' map to \"a\"", "assert wordPatternMatch(\"aba\", \"catdogcat\") == True # 'a' -> \"cat\", 'b' -> \"dog\"", "assert wordPatternMatch(\"abab\", \"xyzxyzabcabc\") == False # cannot match 'a' and 'b' with two different strings each consistent with the pattern", "assert wordPatternMatch(\"abac\", \"xyzxyzxya\") == True # 'a' -> \"xyz\", 'b' -> \"xyz\", 'c' -> \"a\"", "assert wordPatternMatch(\"abcd\", \"xyzy\") == False # pattern too long for the string", "assert wordPatternMatch(\"aaaaa\", \"oneonetwo\") == False # not enough unique strings to map 'a' five times"]}], "category": "Pattern", "prompt_tokens": 1178, "total_tokens": 1769, "completion_tokens": 591, "completion": "Word Pattern III: Given a pattern and a string s, return true if s matches the pattern. Here, matching means that there is a bijection between a letter in pattern and a non-empty substring in s.\n\n###Code: \n\n```python\ndef wordPatternIII(pattern: str, s: str) -> bool:\n    def backtrack(pattern, s, pattern_idx, s_idx, pattern_to_s, s_to_pattern):\n        if pattern_idx == len(pattern) and s_idx == len(s):\n            return True\n        if pattern_idx == len(pattern) or s_idx == len(s):\n            return False\n        \n        char = pattern[pattern_idx]\n        if char in pattern_to_s:\n            mapped_word = pattern_to_s[char]\n            if s_idx + len(mapped_word) <= len(s) and s[s_idx:s_idx + len(mapped_word)] == mapped_word:\n                return backtrack(pattern, s, pattern_idx + 1, s_idx + len(mapped_word), pattern_to_s, s_to_pattern)\n            else:\n                return False\n        else:\n            for i in range(s_idx, len(s)):\n                word = s[s_idx:i+1]\n                if word in s_to_pattern:\n                    continue\n                pattern_to_s[char] = word\n                s_to_pattern[word] = char\n                if backtrack(pattern, s, pattern_idx + 1, i + 1, pattern_to_s, s_to_pattern):\n                    return True\n                del pattern_to_s[char]\n                del s_to_pattern[word]\n            return False\n\n    return backtrack(pattern, s, 0, 0, {}, {})\n\n```\n\n###Testcases: \n\n```python\nassert wordPatternIII(\"abab\", \"redblueredblue\")==True\nassert wordPatternIII(\"aaaa\", \"asdasdasdasd\") == True\nassert wordPatternIII(\"abba\", \"dogcatcatdog\") == True\nassert wordPatternIII(\"abc\", \"dogcatfish\") == False\nassert wordPatternIII(\"abba\", \"dogcatcatfish\") == False\nassert wordPatternIII(\"abc\", \"dogcatdog\") == True\nassert wordPatternIII(\"abc\", \"dogcatdogdog\") == False\nassert wordPatternIII(\"aaa\", \"dogdogdogdog\") == True\nassert wordPatternIII(\"ab\", \"aa\") == False\nassert wordPatternIII(\"abab\", \"xyzabcxzyabc\") == True\nassert wordPatternIII(\"abac\", \"xyzxyzxya\") == True\nassert wordPatternIII(\"abcd\", \"xyzy\") == False\nassert wordPatternIII(\"aaaaa\", \"oneonetwo\") == False\nassert wordPatternIII(\"a\", \"cat\") == True\nassert wordPatternIII(\"ab\", \"cata\") == True\nassert wordPatternIII(\"aba\", \"catdogcat\") == True\n```\n\n", "temperature": 0.73}, {"few_shots": [{"author": "Hafeez", "UUID": "df98fd29-db88-4de7-a00a-0a3bd5ba1539", "question": "Word Pattern: Given a pattern and a string s, find if s follows the same pattern.\n\nHere follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in s.", "examples": "Input: pattern = \"abba\", s = \"dog cat cat fish\"\nOutput: false\nInput: pattern = \"aaaa\", s = \"dog cat cat dog\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def wordPattern(pattern: str, s: str) -> bool:\n    map_char = {}\n    map_word = {}\n    \n    words = s.split(' ')\n    if len(words) != len(pattern):\n        return False\n    \n    for c, w in zip(pattern, words):\n        if c not in map_char:\n            if w in map_word:\n                return False\n            else:\n                map_char[c] = w\n                map_word[w] = c\n        else:\n            if map_char[c] != w:\n                return False\n    return True", "asserts": ["assert wordPattern(\"abba\", \"dog cat cat dog\")==True", "assert wordPattern(\"aaaa\", \"dog dog dog dog\") == True", "assert wordPattern(\"xyz\", \"apple banana apple\") == False", "assert wordPattern(\"xyx\", \"apple banana apple\") == True", "assert wordPattern(\"abab\", \"dog cat dog cat\") == True", "assert wordPattern(\"aaaa\", \"dog dog dog cat\") == False", "assert wordPattern(\"aabb\", \"dog dog cat cat\") == True", "assert wordPattern(\"abc\", \"dog\") == False  # Not enough words", "assert wordPattern(\"\", \"dog cat\") == False  # Empty pattern", "assert wordPattern(\"a\", \"dog cat dog cat\") == False  # Not enough pattern characters", "assert wordPattern(\"ab\", \"\") == False  # Empty string", "assert wordPattern(\"abb\", \"dog dog dog\") == False  # Same word for different pattern characters", "assert wordPattern(\"abba\", \"dog cat cat\") == False  # Not enough words for the pattern", "assert wordPattern(\"abba\", \"dog cat cat dog fish\") == False  # Extra words beyond the pattern length"]}, {"author": "Hafeez", "UUID": "124bfeca-24d0-411d-b4ad-26009b79436b", "question": "Word Pattern II: Given a pattern and a string s, return true if s matches the pattern.\n\nA string s matches a pattern if there is some bijective mapping of single characters to non-empty strings such that if each character in pattern is replaced by the string it maps to, then the resulting string is s. A bijective mapping means that no two characters map to the same string, and no character maps to two different strings.", "examples": "Input: pattern = \"abab\", s = \"redblueredblue\"\nOutput: true\nExplanation: One possible mapping is as follows:\n'a' -> \"red\"\n'b' -> \"blue\"\nInput: pattern = \"aabb\", s = \"xyzabcxzyabc\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern-ii/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def wordPatternMatch(pattern: str, s: str) -> bool:\n    def backtrack(cur: str, pattern: str, mappings: dict):\n        if not pattern:\n            return not cur\n        if pattern[0] in mappings:\n            if cur[:len(mappings[pattern[0]])] != mappings[pattern[0]]:\n                return False\n            return backtrack(cur[len(mappings[pattern[0]]):], pattern[1:], mappings)\n        for i in range(len(cur)):\n            if cur[:i+1] in mappings.values():\n                continue\n            mappings[pattern[0]] = cur[:i+1]\n            if backtrack(cur[i+1:], pattern[1:], mappings):\n                return True\n            del mappings[pattern[0]]\n        return False\n    return backtrack(s, pattern, {})", "asserts": ["assert wordPatternMatch(\"aaaa\", \"asdasdasdasd\")==True", "assert wordPatternMatch(\"abba\", \"dogcatcatdog\") == True", "assert wordPatternMatch(\"ab\", \"aa\") == False # since 'a' and 'b' cannot map to the same string \"a\"", "assert wordPatternMatch(\"xyz\", \"abcdefghi\") == True # 'x' -> \"a\", 'y' -> \"bc\", 'z' -> \"defghi\"", "assert wordPatternMatch(\"aba\", \"eggegg\") == False # 'a' maps to \"egg\", but 'b' cannot be mapped uniquely", "assert wordPatternMatch(\"zzz\", \"aaa\") == True # all 'z' map to \"a\"", "assert wordPatternMatch(\"aba\", \"catdogcat\") == True # 'a' -> \"cat\", 'b' -> \"dog\"", "assert wordPatternMatch(\"abab\", \"xyzxyzabcabc\") == False # cannot match 'a' and 'b' with two different strings each consistent with the pattern", "assert wordPatternMatch(\"abac\", \"xyzxyzxya\") == True # 'a' -> \"xyz\", 'b' -> \"xyz\", 'c' -> \"a\"", "assert wordPatternMatch(\"abcd\", \"xyzy\") == False # pattern too long for the string", "assert wordPatternMatch(\"aaaaa\", \"oneonetwo\") == False # not enough unique strings to map 'a' five times"]}], "category": "Pattern", "prompt_tokens": 1178, "total_tokens": 1716, "completion_tokens": 538, "completion": "Number Pattern: Given an integer n, generate the first n elements of the following pattern: 1, 11, 21, 1211, 111221, ...\n\nEach subsequent element describes the previous element. Starting with \"1\", the pattern describes the previous element as \"one 1\", i.e. 11. Then, the next element describes 11 as \"two 1s\", i.e. 21. Then 21 is described as \"one 2, then one 1\", i.e. 1211, and so on.\n\nWrite a function to generate the first n elements of this pattern.\n\n###Code: \n\ndef generatePattern(n: int) -> List[str]:\n    if n == 1:\n        return ['1']\n    result = ['1']\n    for _ in range(n-1):\n        current = result[-1]\n        count = 1\n        new_str = \"\"\n        for i in range(1, len(current)):\n            if current[i] == current[i-1]:\n                count += 1\n            else:\n                new_str += str(count) + current[i-1]\n                count = 1\n        new_str += str(count) + current[-1]\n        result.append(new_str)\n    return result\n\n###Testcases: \n\nassert generatePattern(1) == ['1']\nassert generatePattern(5) == ['1', '11', '21', '1211', '111221']\nassert generatePattern(8) == ['1', '11', '21', '1211', '111221', '312211', '13112221', '1113213211']\nassert generatePattern(10) == ['1', '11', '21', '1211', '111221', '312211', '13112221', '1113213211', '31131211131221', '13211311123113112211']\nassert generatePattern(15) == ['1', '11', '21', '1211', '111221', '312211', '13112221', '1113213211', '31131211131221', '13211311123113112211', '11131221133112132113212221', '3113112221232112111312211312113211', '132113213221133112132113311211131221', '11131221131211131231121113112221121321132132211331222113112211', '311311222113111231131112132112311321322112111312211312111322212311322113212221']\n", "temperature": 0.856}, {"few_shots": [{"author": "Hafeez", "UUID": "df98fd29-db88-4de7-a00a-0a3bd5ba1539", "question": "Word Pattern: Given a pattern and a string s, find if s follows the same pattern.\n\nHere follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in s.", "examples": "Input: pattern = \"abba\", s = \"dog cat cat fish\"\nOutput: false\nInput: pattern = \"aaaa\", s = \"dog cat cat dog\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def wordPattern(pattern: str, s: str) -> bool:\n    map_char = {}\n    map_word = {}\n    \n    words = s.split(' ')\n    if len(words) != len(pattern):\n        return False\n    \n    for c, w in zip(pattern, words):\n        if c not in map_char:\n            if w in map_word:\n                return False\n            else:\n                map_char[c] = w\n                map_word[w] = c\n        else:\n            if map_char[c] != w:\n                return False\n    return True", "asserts": ["assert wordPattern(\"abba\", \"dog cat cat dog\")==True", "assert wordPattern(\"aaaa\", \"dog dog dog dog\") == True", "assert wordPattern(\"xyz\", \"apple banana apple\") == False", "assert wordPattern(\"xyx\", \"apple banana apple\") == True", "assert wordPattern(\"abab\", \"dog cat dog cat\") == True", "assert wordPattern(\"aaaa\", \"dog dog dog cat\") == False", "assert wordPattern(\"aabb\", \"dog dog cat cat\") == True", "assert wordPattern(\"abc\", \"dog\") == False  # Not enough words", "assert wordPattern(\"\", \"dog cat\") == False  # Empty pattern", "assert wordPattern(\"a\", \"dog cat dog cat\") == False  # Not enough pattern characters", "assert wordPattern(\"ab\", \"\") == False  # Empty string", "assert wordPattern(\"abb\", \"dog dog dog\") == False  # Same word for different pattern characters", "assert wordPattern(\"abba\", \"dog cat cat\") == False  # Not enough words for the pattern", "assert wordPattern(\"abba\", \"dog cat cat dog fish\") == False  # Extra words beyond the pattern length"]}, {"author": "Hafeez", "UUID": "124bfeca-24d0-411d-b4ad-26009b79436b", "question": "Word Pattern II: Given a pattern and a string s, return true if s matches the pattern.\n\nA string s matches a pattern if there is some bijective mapping of single characters to non-empty strings such that if each character in pattern is replaced by the string it maps to, then the resulting string is s. A bijective mapping means that no two characters map to the same string, and no character maps to two different strings.", "examples": "Input: pattern = \"abab\", s = \"redblueredblue\"\nOutput: true\nExplanation: One possible mapping is as follows:\n'a' -> \"red\"\n'b' -> \"blue\"\nInput: pattern = \"aabb\", s = \"xyzabcxzyabc\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern-ii/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def wordPatternMatch(pattern: str, s: str) -> bool:\n    def backtrack(cur: str, pattern: str, mappings: dict):\n        if not pattern:\n            return not cur\n        if pattern[0] in mappings:\n            if cur[:len(mappings[pattern[0]])] != mappings[pattern[0]]:\n                return False\n            return backtrack(cur[len(mappings[pattern[0]]):], pattern[1:], mappings)\n        for i in range(len(cur)):\n            if cur[:i+1] in mappings.values():\n                continue\n            mappings[pattern[0]] = cur[:i+1]\n            if backtrack(cur[i+1:], pattern[1:], mappings):\n                return True\n            del mappings[pattern[0]]\n        return False\n    return backtrack(s, pattern, {})", "asserts": ["assert wordPatternMatch(\"aaaa\", \"asdasdasdasd\")==True", "assert wordPatternMatch(\"abba\", \"dogcatcatdog\") == True", "assert wordPatternMatch(\"ab\", \"aa\") == False # since 'a' and 'b' cannot map to the same string \"a\"", "assert wordPatternMatch(\"xyz\", \"abcdefghi\") == True # 'x' -> \"a\", 'y' -> \"bc\", 'z' -> \"defghi\"", "assert wordPatternMatch(\"aba\", \"eggegg\") == False # 'a' maps to \"egg\", but 'b' cannot be mapped uniquely", "assert wordPatternMatch(\"zzz\", \"aaa\") == True # all 'z' map to \"a\"", "assert wordPatternMatch(\"aba\", \"catdogcat\") == True # 'a' -> \"cat\", 'b' -> \"dog\"", "assert wordPatternMatch(\"abab\", \"xyzxyzabcabc\") == False # cannot match 'a' and 'b' with two different strings each consistent with the pattern", "assert wordPatternMatch(\"abac\", \"xyzxyzxya\") == True # 'a' -> \"xyz\", 'b' -> \"xyz\", 'c' -> \"a\"", "assert wordPatternMatch(\"abcd\", \"xyzy\") == False # pattern too long for the string", "assert wordPatternMatch(\"aaaaa\", \"oneonetwo\") == False # not enough unique strings to map 'a' five times"]}], "category": "Pattern", "prompt_tokens": 1178, "total_tokens": 1571, "completion_tokens": 393, "completion": "Find All Anagrams in a String: Given a string s and a non-empty string p, find all the start indices of p's anagrams in s.\n\nStrings consists of lowercase English letters only.\n\n###Code: \n\n```python\nfrom collections import Counter\n\ndef findAnagrams(s: str, p: str):\n    result = []\n    pCounter = Counter(p)\n    sCounter = Counter(s[:len(p)-1])\n    for i in range(len(p)-1,len(s)):\n        sCounter[s[i]] += 1   # include a new char in the window\n        if sCounter == pCounter:    # This step is O(1), since there are at most 26 English letters \n            result.append(i-len(p)+1)   # append the starting index\n        sCounter[s[i-len(p)+1]] -= 1   # decrease the count of oldest char in the window\n        if sCounter[s[i-len(p)+1]] == 0:\n            del sCounter[s[i-len(p)+1]]   # remove the count if it is 0\n    return result\n```\n\n###Testcases: \n\n```python\nassert findAnagrams(\"cbaebabacd\", \"abc\") == [0, 6]\nassert findAnagrams(\"abab\", \"ab\") == [0, 1, 2]\nassert findAnagrams(\"aaaaa\", \"a\") == [0, 1, 2, 3, 4]\nassert findAnagrams(\"aa\", \"aaa\") == []\nassert findAnagrams(\"ab\", \"aaa\") == []\nassert findAnagrams(\"a\", \"a\") == [0]\nassert findAnagrams(\"ab\", \"a\") == [0, 1]\nassert findAnagrams(\"ab\", \"b\") == [1]\nassert findAnagrams(\"ab\", \"c\") == []\n```\n\n[/Example 3]", "temperature": 0.632}, {"few_shots": [{"author": "Hafeez", "UUID": "df98fd29-db88-4de7-a00a-0a3bd5ba1539", "question": "Word Pattern: Given a pattern and a string s, find if s follows the same pattern.\n\nHere follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in s.", "examples": "Input: pattern = \"abba\", s = \"dog cat cat fish\"\nOutput: false\nInput: pattern = \"aaaa\", s = \"dog cat cat dog\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def wordPattern(pattern: str, s: str) -> bool:\n    map_char = {}\n    map_word = {}\n    \n    words = s.split(' ')\n    if len(words) != len(pattern):\n        return False\n    \n    for c, w in zip(pattern, words):\n        if c not in map_char:\n            if w in map_word:\n                return False\n            else:\n                map_char[c] = w\n                map_word[w] = c\n        else:\n            if map_char[c] != w:\n                return False\n    return True", "asserts": ["assert wordPattern(\"abba\", \"dog cat cat dog\")==True", "assert wordPattern(\"aaaa\", \"dog dog dog dog\") == True", "assert wordPattern(\"xyz\", \"apple banana apple\") == False", "assert wordPattern(\"xyx\", \"apple banana apple\") == True", "assert wordPattern(\"abab\", \"dog cat dog cat\") == True", "assert wordPattern(\"aaaa\", \"dog dog dog cat\") == False", "assert wordPattern(\"aabb\", \"dog dog cat cat\") == True", "assert wordPattern(\"abc\", \"dog\") == False  # Not enough words", "assert wordPattern(\"\", \"dog cat\") == False  # Empty pattern", "assert wordPattern(\"a\", \"dog cat dog cat\") == False  # Not enough pattern characters", "assert wordPattern(\"ab\", \"\") == False  # Empty string", "assert wordPattern(\"abb\", \"dog dog dog\") == False  # Same word for different pattern characters", "assert wordPattern(\"abba\", \"dog cat cat\") == False  # Not enough words for the pattern", "assert wordPattern(\"abba\", \"dog cat cat dog fish\") == False  # Extra words beyond the pattern length"]}, {"author": "Hafeez", "UUID": "124bfeca-24d0-411d-b4ad-26009b79436b", "question": "Word Pattern II: Given a pattern and a string s, return true if s matches the pattern.\n\nA string s matches a pattern if there is some bijective mapping of single characters to non-empty strings such that if each character in pattern is replaced by the string it maps to, then the resulting string is s. A bijective mapping means that no two characters map to the same string, and no character maps to two different strings.", "examples": "Input: pattern = \"abab\", s = \"redblueredblue\"\nOutput: true\nExplanation: One possible mapping is as follows:\n'a' -> \"red\"\n'b' -> \"blue\"\nInput: pattern = \"aabb\", s = \"xyzabcxzyabc\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern-ii/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def wordPatternMatch(pattern: str, s: str) -> bool:\n    def backtrack(cur: str, pattern: str, mappings: dict):\n        if not pattern:\n            return not cur\n        if pattern[0] in mappings:\n            if cur[:len(mappings[pattern[0]])] != mappings[pattern[0]]:\n                return False\n            return backtrack(cur[len(mappings[pattern[0]]):], pattern[1:], mappings)\n        for i in range(len(cur)):\n            if cur[:i+1] in mappings.values():\n                continue\n            mappings[pattern[0]] = cur[:i+1]\n            if backtrack(cur[i+1:], pattern[1:], mappings):\n                return True\n            del mappings[pattern[0]]\n        return False\n    return backtrack(s, pattern, {})", "asserts": ["assert wordPatternMatch(\"aaaa\", \"asdasdasdasd\")==True", "assert wordPatternMatch(\"abba\", \"dogcatcatdog\") == True", "assert wordPatternMatch(\"ab\", \"aa\") == False # since 'a' and 'b' cannot map to the same string \"a\"", "assert wordPatternMatch(\"xyz\", \"abcdefghi\") == True # 'x' -> \"a\", 'y' -> \"bc\", 'z' -> \"defghi\"", "assert wordPatternMatch(\"aba\", \"eggegg\") == False # 'a' maps to \"egg\", but 'b' cannot be mapped uniquely", "assert wordPatternMatch(\"zzz\", \"aaa\") == True # all 'z' map to \"a\"", "assert wordPatternMatch(\"aba\", \"catdogcat\") == True # 'a' -> \"cat\", 'b' -> \"dog\"", "assert wordPatternMatch(\"abab\", \"xyzxyzabcabc\") == False # cannot match 'a' and 'b' with two different strings each consistent with the pattern", "assert wordPatternMatch(\"abac\", \"xyzxyzxya\") == True # 'a' -> \"xyz\", 'b' -> \"xyz\", 'c' -> \"a\"", "assert wordPatternMatch(\"abcd\", \"xyzy\") == False # pattern too long for the string", "assert wordPatternMatch(\"aaaaa\", \"oneonetwo\") == False # not enough unique strings to map 'a' five times"]}], "category": "Pattern", "prompt_tokens": 1178, "total_tokens": 1534, "completion_tokens": 356, "completion": "Find All Anagrams in a String: Given a string s and a non-empty string p, find all the start indices of p's anagrams in s.\n\nStrings consists of lowercase English letters only. The order of output does not matter.\n\n###Code: \n\n```python\nfrom collections import Counter\n\ndef findAnagrams(s: str, p: str):\n    result = []\n    p_count = Counter(p)\n    s_count = Counter(s[:len(p)-1])\n    \n    for i in range(len(p)-1, len(s)):\n        s_count[s[i]] += 1\n        if s_count == p_count:\n            result.append(i-len(p)+1)\n        s_count[s[i-len(p)+1]] -= 1\n        if s_count[s[i-len(p)+1]] == 0:\n            del s_count[s[i-len(p)+1]]\n    return result\n```\n\n###Testcases: \n\n```python\nassert findAnagrams(\"cbaebabacd\", \"abc\") == [0, 6]\nassert findAnagrams(\"abab\", \"ab\") == [0, 1, 2]\nassert findAnagrams(\"aaaaa\", \"a\") == [0, 1, 2, 3, 4]\nassert findAnagrams(\"abacbabc\", \"abc\") == [1, 2, 3, 5]\nassert findAnagrams(\"abxaba\", \"ab\") == [0, 3, 4]\nassert findAnagrams(\"xyabczyx\", \"abc\") == [2]\nassert findAnagrams(\"ababababab\", \"aab\") == [0, 2, 4, 6]\n```\n\n[/Example 3]", "temperature": 0.697}, {"few_shots": [{"author": "Hafeez", "UUID": "df98fd29-db88-4de7-a00a-0a3bd5ba1539", "question": "Word Pattern: Given a pattern and a string s, find if s follows the same pattern.\n\nHere follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in s.", "examples": "Input: pattern = \"abba\", s = \"dog cat cat fish\"\nOutput: false\nInput: pattern = \"aaaa\", s = \"dog cat cat dog\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def wordPattern(pattern: str, s: str) -> bool:\n    map_char = {}\n    map_word = {}\n    \n    words = s.split(' ')\n    if len(words) != len(pattern):\n        return False\n    \n    for c, w in zip(pattern, words):\n        if c not in map_char:\n            if w in map_word:\n                return False\n            else:\n                map_char[c] = w\n                map_word[w] = c\n        else:\n            if map_char[c] != w:\n                return False\n    return True", "asserts": ["assert wordPattern(\"abba\", \"dog cat cat dog\")==True", "assert wordPattern(\"aaaa\", \"dog dog dog dog\") == True", "assert wordPattern(\"xyz\", \"apple banana apple\") == False", "assert wordPattern(\"xyx\", \"apple banana apple\") == True", "assert wordPattern(\"abab\", \"dog cat dog cat\") == True", "assert wordPattern(\"aaaa\", \"dog dog dog cat\") == False", "assert wordPattern(\"aabb\", \"dog dog cat cat\") == True", "assert wordPattern(\"abc\", \"dog\") == False  # Not enough words", "assert wordPattern(\"\", \"dog cat\") == False  # Empty pattern", "assert wordPattern(\"a\", \"dog cat dog cat\") == False  # Not enough pattern characters", "assert wordPattern(\"ab\", \"\") == False  # Empty string", "assert wordPattern(\"abb\", \"dog dog dog\") == False  # Same word for different pattern characters", "assert wordPattern(\"abba\", \"dog cat cat\") == False  # Not enough words for the pattern", "assert wordPattern(\"abba\", \"dog cat cat dog fish\") == False  # Extra words beyond the pattern length"]}, {"author": "Hafeez", "UUID": "124bfeca-24d0-411d-b4ad-26009b79436b", "question": "Word Pattern II: Given a pattern and a string s, return true if s matches the pattern.\n\nA string s matches a pattern if there is some bijective mapping of single characters to non-empty strings such that if each character in pattern is replaced by the string it maps to, then the resulting string is s. A bijective mapping means that no two characters map to the same string, and no character maps to two different strings.", "examples": "Input: pattern = \"abab\", s = \"redblueredblue\"\nOutput: true\nExplanation: One possible mapping is as follows:\n'a' -> \"red\"\n'b' -> \"blue\"\nInput: pattern = \"aabb\", s = \"xyzabcxzyabc\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern-ii/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def wordPatternMatch(pattern: str, s: str) -> bool:\n    def backtrack(cur: str, pattern: str, mappings: dict):\n        if not pattern:\n            return not cur\n        if pattern[0] in mappings:\n            if cur[:len(mappings[pattern[0]])] != mappings[pattern[0]]:\n                return False\n            return backtrack(cur[len(mappings[pattern[0]]):], pattern[1:], mappings)\n        for i in range(len(cur)):\n            if cur[:i+1] in mappings.values():\n                continue\n            mappings[pattern[0]] = cur[:i+1]\n            if backtrack(cur[i+1:], pattern[1:], mappings):\n                return True\n            del mappings[pattern[0]]\n        return False\n    return backtrack(s, pattern, {})", "asserts": ["assert wordPatternMatch(\"aaaa\", \"asdasdasdasd\")==True", "assert wordPatternMatch(\"abba\", \"dogcatcatdog\") == True", "assert wordPatternMatch(\"ab\", \"aa\") == False # since 'a' and 'b' cannot map to the same string \"a\"", "assert wordPatternMatch(\"xyz\", \"abcdefghi\") == True # 'x' -> \"a\", 'y' -> \"bc\", 'z' -> \"defghi\"", "assert wordPatternMatch(\"aba\", \"eggegg\") == False # 'a' maps to \"egg\", but 'b' cannot be mapped uniquely", "assert wordPatternMatch(\"zzz\", \"aaa\") == True # all 'z' map to \"a\"", "assert wordPatternMatch(\"aba\", \"catdogcat\") == True # 'a' -> \"cat\", 'b' -> \"dog\"", "assert wordPatternMatch(\"abab\", \"xyzxyzabcabc\") == False # cannot match 'a' and 'b' with two different strings each consistent with the pattern", "assert wordPatternMatch(\"abac\", \"xyzxyzxya\") == True # 'a' -> \"xyz\", 'b' -> \"xyz\", 'c' -> \"a\"", "assert wordPatternMatch(\"abcd\", \"xyzy\") == False # pattern too long for the string", "assert wordPatternMatch(\"aaaaa\", \"oneonetwo\") == False # not enough unique strings to map 'a' five times"]}], "category": "Pattern", "prompt_tokens": 1178, "total_tokens": 1670, "completion_tokens": 492, "completion": "Word Pattern III: Given a pattern and a string s, return true if s matches the pattern.\n\nA string s matches a pattern if there is some bijective mapping of single characters to non-empty strings such that if each character in pattern is replaced by the string it maps to, then the resulting string is s. A bijective mapping means that no two characters map to the same string, and no character maps to two different strings.\n\nYou are also given a \"transform\" function that will allow you to transform the string s.\n\n###Code: \n\ndef wordPatternMatch(pattern: str, s: str, transform) -> bool:\n    def backtrack(cur: str, pattern: str, mappings: dict, transform):\n        if not pattern:\n            return not cur\n        if pattern[0] in mappings:\n            word = transform(mappings[pattern[0]])\n            if cur[:len(word)] != word:\n                return False\n            return backtrack(cur[len(word):], pattern[1:], mappings, transform)\n        for i in range(len(cur)):\n            if cur[:i+1] in mappings.values():\n                continue\n            mappings[pattern[0]] = cur[:i+1]\n            if backtrack(cur[i+1:], pattern[1:], mappings, transform):\n                return True\n            del mappings[pattern[0]]\n        return False\n    return backtrack(s, pattern, {}, transform)\n\n###Testcases: \n\nassert wordPatternMatch(\"aba\", \"catdogcat\", lambda x: x*2)==True\nassert wordPatternMatch(\"abba\", \"dogcatcatdog\", lambda x: x)==True\nassert wordPatternMatch(\"abac\", \"xyzxyzxya\", lambda x: x*3)==True\nassert wordPatternMatch(\"abc\", \"def\", lambda x: x)==True\nassert wordPatternMatch(\"abab\", \"xyzxyzabcabc\", lambda x: x)==True\nassert wordPatternMatch(\"ab\", \"aa\", lambda x: x)==False  # since 'a' and 'b' cannot map to the same string \"a\"\nassert wordPatternMatch(\"abcd\", \"xyzy\", lambda x: x*2)==False  # pattern too long for the string\nassert wordPatternMatch(\"aaaaa\", \"oneonetwo\", lambda x: x)==False  # not enough unique strings to map 'a' five times\n\n[/Example 3]", "temperature": 0.993}, {"few_shots": [{"author": "Hafeez", "UUID": "df98fd29-db88-4de7-a00a-0a3bd5ba1539", "question": "Word Pattern: Given a pattern and a string s, find if s follows the same pattern.\n\nHere follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in s.", "examples": "Input: pattern = \"abba\", s = \"dog cat cat fish\"\nOutput: false\nInput: pattern = \"aaaa\", s = \"dog cat cat dog\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def wordPattern(pattern: str, s: str) -> bool:\n    map_char = {}\n    map_word = {}\n    \n    words = s.split(' ')\n    if len(words) != len(pattern):\n        return False\n    \n    for c, w in zip(pattern, words):\n        if c not in map_char:\n            if w in map_word:\n                return False\n            else:\n                map_char[c] = w\n                map_word[w] = c\n        else:\n            if map_char[c] != w:\n                return False\n    return True", "asserts": ["assert wordPattern(\"abba\", \"dog cat cat dog\")==True", "assert wordPattern(\"aaaa\", \"dog dog dog dog\") == True", "assert wordPattern(\"xyz\", \"apple banana apple\") == False", "assert wordPattern(\"xyx\", \"apple banana apple\") == True", "assert wordPattern(\"abab\", \"dog cat dog cat\") == True", "assert wordPattern(\"aaaa\", \"dog dog dog cat\") == False", "assert wordPattern(\"aabb\", \"dog dog cat cat\") == True", "assert wordPattern(\"abc\", \"dog\") == False  # Not enough words", "assert wordPattern(\"\", \"dog cat\") == False  # Empty pattern", "assert wordPattern(\"a\", \"dog cat dog cat\") == False  # Not enough pattern characters", "assert wordPattern(\"ab\", \"\") == False  # Empty string", "assert wordPattern(\"abb\", \"dog dog dog\") == False  # Same word for different pattern characters", "assert wordPattern(\"abba\", \"dog cat cat\") == False  # Not enough words for the pattern", "assert wordPattern(\"abba\", \"dog cat cat dog fish\") == False  # Extra words beyond the pattern length"]}, {"author": "Hafeez", "UUID": "124bfeca-24d0-411d-b4ad-26009b79436b", "question": "Word Pattern II: Given a pattern and a string s, return true if s matches the pattern.\n\nA string s matches a pattern if there is some bijective mapping of single characters to non-empty strings such that if each character in pattern is replaced by the string it maps to, then the resulting string is s. A bijective mapping means that no two characters map to the same string, and no character maps to two different strings.", "examples": "Input: pattern = \"abab\", s = \"redblueredblue\"\nOutput: true\nExplanation: One possible mapping is as follows:\n'a' -> \"red\"\n'b' -> \"blue\"\nInput: pattern = \"aabb\", s = \"xyzabcxzyabc\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern-ii/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def wordPatternMatch(pattern: str, s: str) -> bool:\n    def backtrack(cur: str, pattern: str, mappings: dict):\n        if not pattern:\n            return not cur\n        if pattern[0] in mappings:\n            if cur[:len(mappings[pattern[0]])] != mappings[pattern[0]]:\n                return False\n            return backtrack(cur[len(mappings[pattern[0]]):], pattern[1:], mappings)\n        for i in range(len(cur)):\n            if cur[:i+1] in mappings.values():\n                continue\n            mappings[pattern[0]] = cur[:i+1]\n            if backtrack(cur[i+1:], pattern[1:], mappings):\n                return True\n            del mappings[pattern[0]]\n        return False\n    return backtrack(s, pattern, {})", "asserts": ["assert wordPatternMatch(\"aaaa\", \"asdasdasdasd\")==True", "assert wordPatternMatch(\"abba\", \"dogcatcatdog\") == True", "assert wordPatternMatch(\"ab\", \"aa\") == False # since 'a' and 'b' cannot map to the same string \"a\"", "assert wordPatternMatch(\"xyz\", \"abcdefghi\") == True # 'x' -> \"a\", 'y' -> \"bc\", 'z' -> \"defghi\"", "assert wordPatternMatch(\"aba\", \"eggegg\") == False # 'a' maps to \"egg\", but 'b' cannot be mapped uniquely", "assert wordPatternMatch(\"zzz\", \"aaa\") == True # all 'z' map to \"a\"", "assert wordPatternMatch(\"aba\", \"catdogcat\") == True # 'a' -> \"cat\", 'b' -> \"dog\"", "assert wordPatternMatch(\"abab\", \"xyzxyzabcabc\") == False # cannot match 'a' and 'b' with two different strings each consistent with the pattern", "assert wordPatternMatch(\"abac\", \"xyzxyzxya\") == True # 'a' -> \"xyz\", 'b' -> \"xyz\", 'c' -> \"a\"", "assert wordPatternMatch(\"abcd\", \"xyzy\") == False # pattern too long for the string", "assert wordPatternMatch(\"aaaaa\", \"oneonetwo\") == False # not enough unique strings to map 'a' five times"]}], "category": "Pattern", "prompt_tokens": 1178, "total_tokens": 1654, "completion_tokens": 476, "completion": "Word Pattern III: Given a pattern and a string s, return true if s matches the pattern.\n\nA string s matches a pattern if there is some bijective mapping of single characters to non-empty strings such that if each character in pattern is replaced by the string it maps to, then the resulting string is s. A bijective mapping means that no two characters map to the same string, and no character maps to two different strings.\n\n###Code:\n\ndef wordPatternMatch(pattern: str, s: str) -> bool:\n    def backtrack(pattern, s, pattern_map, s_map):\n        if not pattern and not s:\n            return True\n        if not pattern or not s:\n            return False\n        char = pattern[0]\n        if char in pattern_map:\n            word = pattern_map[char]\n            if not s.startswith(word):\n                return False\n            return backtrack(pattern[1:], s[len(word):], pattern_map, s_map)\n        for i in range(1, len(s) - len(pattern) + 2):\n            word = s[:i]\n            if word in s_map:\n                continue\n            pattern_map[char] = word\n            s_map[word] = char\n            if backtrack(pattern[1:], s[i:], pattern_map, s_map):\n                return True\n            del pattern_map[char]\n            del s_map[word]\n        return False\n    \n    return backtrack(pattern, s, {}, {})\n\n###Testcases:\n\nassert wordPatternMatch(\"abab\", \"redblueredblue\") == True\nassert wordPatternMatch(\"aaaa\", \"redredredred\") == True\nassert wordPatternMatch(\"aabb\", \"xyzabcxzyabc\") == False\nassert wordPatternMatch(\"ab\", \"aa\") == False\nassert wordPatternMatch(\"ab\", \"xy\") == True\nassert wordPatternMatch(\"abc\", \"xxyyzz\") == True\nassert wordPatternMatch(\"abab\", \"xyx\") == False\nassert wordPatternMatch(\"abab\", \"xxyx\") == True\nassert wordPatternMatch(\"ab\", \"aaa\") == False\nassert wordPatternMatch(\"aabb\", \"xyzabcabcxyz\") == True\nassert wordPatternMatch(\"ab\", \"\") == False\nassert wordPatternMatch(\"\", \"xyz\") == False\n\n[/Example 3]", "temperature": 0.652}, {"few_shots": [{"author": "Hafeez", "UUID": "df98fd29-db88-4de7-a00a-0a3bd5ba1539", "question": "Word Pattern: Given a pattern and a string s, find if s follows the same pattern.\n\nHere follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in s.", "examples": "Input: pattern = \"abba\", s = \"dog cat cat fish\"\nOutput: false\nInput: pattern = \"aaaa\", s = \"dog cat cat dog\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def wordPattern(pattern: str, s: str) -> bool:\n    map_char = {}\n    map_word = {}\n    \n    words = s.split(' ')\n    if len(words) != len(pattern):\n        return False\n    \n    for c, w in zip(pattern, words):\n        if c not in map_char:\n            if w in map_word:\n                return False\n            else:\n                map_char[c] = w\n                map_word[w] = c\n        else:\n            if map_char[c] != w:\n                return False\n    return True", "asserts": ["assert wordPattern(\"abba\", \"dog cat cat dog\")==True", "assert wordPattern(\"aaaa\", \"dog dog dog dog\") == True", "assert wordPattern(\"xyz\", \"apple banana apple\") == False", "assert wordPattern(\"xyx\", \"apple banana apple\") == True", "assert wordPattern(\"abab\", \"dog cat dog cat\") == True", "assert wordPattern(\"aaaa\", \"dog dog dog cat\") == False", "assert wordPattern(\"aabb\", \"dog dog cat cat\") == True", "assert wordPattern(\"abc\", \"dog\") == False  # Not enough words", "assert wordPattern(\"\", \"dog cat\") == False  # Empty pattern", "assert wordPattern(\"a\", \"dog cat dog cat\") == False  # Not enough pattern characters", "assert wordPattern(\"ab\", \"\") == False  # Empty string", "assert wordPattern(\"abb\", \"dog dog dog\") == False  # Same word for different pattern characters", "assert wordPattern(\"abba\", \"dog cat cat\") == False  # Not enough words for the pattern", "assert wordPattern(\"abba\", \"dog cat cat dog fish\") == False  # Extra words beyond the pattern length"]}, {"author": "Hafeez", "UUID": "124bfeca-24d0-411d-b4ad-26009b79436b", "question": "Word Pattern II: Given a pattern and a string s, return true if s matches the pattern.\n\nA string s matches a pattern if there is some bijective mapping of single characters to non-empty strings such that if each character in pattern is replaced by the string it maps to, then the resulting string is s. A bijective mapping means that no two characters map to the same string, and no character maps to two different strings.", "examples": "Input: pattern = \"abab\", s = \"redblueredblue\"\nOutput: true\nExplanation: One possible mapping is as follows:\n'a' -> \"red\"\n'b' -> \"blue\"\nInput: pattern = \"aabb\", s = \"xyzabcxzyabc\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern-ii/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def wordPatternMatch(pattern: str, s: str) -> bool:\n    def backtrack(cur: str, pattern: str, mappings: dict):\n        if not pattern:\n            return not cur\n        if pattern[0] in mappings:\n            if cur[:len(mappings[pattern[0]])] != mappings[pattern[0]]:\n                return False\n            return backtrack(cur[len(mappings[pattern[0]]):], pattern[1:], mappings)\n        for i in range(len(cur)):\n            if cur[:i+1] in mappings.values():\n                continue\n            mappings[pattern[0]] = cur[:i+1]\n            if backtrack(cur[i+1:], pattern[1:], mappings):\n                return True\n            del mappings[pattern[0]]\n        return False\n    return backtrack(s, pattern, {})", "asserts": ["assert wordPatternMatch(\"aaaa\", \"asdasdasdasd\")==True", "assert wordPatternMatch(\"abba\", \"dogcatcatdog\") == True", "assert wordPatternMatch(\"ab\", \"aa\") == False # since 'a' and 'b' cannot map to the same string \"a\"", "assert wordPatternMatch(\"xyz\", \"abcdefghi\") == True # 'x' -> \"a\", 'y' -> \"bc\", 'z' -> \"defghi\"", "assert wordPatternMatch(\"aba\", \"eggegg\") == False # 'a' maps to \"egg\", but 'b' cannot be mapped uniquely", "assert wordPatternMatch(\"zzz\", \"aaa\") == True # all 'z' map to \"a\"", "assert wordPatternMatch(\"aba\", \"catdogcat\") == True # 'a' -> \"cat\", 'b' -> \"dog\"", "assert wordPatternMatch(\"abab\", \"xyzxyzabcabc\") == False # cannot match 'a' and 'b' with two different strings each consistent with the pattern", "assert wordPatternMatch(\"abac\", \"xyzxyzxya\") == True # 'a' -> \"xyz\", 'b' -> \"xyz\", 'c' -> \"a\"", "assert wordPatternMatch(\"abcd\", \"xyzy\") == False # pattern too long for the string", "assert wordPatternMatch(\"aaaaa\", \"oneonetwo\") == False # not enough unique strings to map 'a' five times"]}], "category": "Pattern", "prompt_tokens": 1178, "total_tokens": 1588, "completion_tokens": 410, "completion": "Find All Anagrams in a String: Given a string s and a non-empty string p, find all the start indices of p's anagrams in s.\n\nStrings consists of lowercase English letters only.\n\n###Code:\n\n```python\nfrom collections import Counter\n\ndef findAnagrams(s: str, p: str):\n    result = []\n    pCounter = Counter(p)\n    sCounter = Counter(s[:len(p)-1])\n    for i in range(len(p)-1,len(s)):\n        sCounter[s[i]] += 1   # Include a new char in the window\n        if sCounter == pCounter:    # This step is O(1), since there are at most 26 English letters \n            result.append(i-len(p)+1)   # Append the starting index\n        sCounter[s[i-len(p)+1]] -= 1   # Decrease the count of oldest char in the window\n        if sCounter[s[i-len(p)+1]] == 0:\n            del sCounter[s[i-len(p)+1]]   # Remove the count if it is 0\n    return result\n```\n\n###Testcases:\n\n```python\nassert findAnagrams(\"cbaebabacd\", \"abc\") == [0, 6]\nassert findAnagrams(\"abab\", \"ab\") == [0, 1, 2]\nassert findAnagrams(\"acdcaeccde\", \"c\") == [1, 3, 6, 7]\nassert findAnagrams(\"aaaaa\", \"a\") == [0, 1, 2, 3, 4]\nassert findAnagrams(\"abcdefg\", \"h\") == []\nassert findAnagrams(\"\", \"a\") == []\nassert findAnagrams(\"a\", \"\") == []\n```\n\n###Explanation:\nThe function `findAnagrams` finds all the start indices of p's anagrams in s using a sliding window approach and a Counter to efficiently count the character occurrences in the strings.\n\n[/Example 3]", "temperature": 0.94}, {"few_shots": [{"author": "Hafeez", "UUID": "8c9548d2-7b9c-46a4-9b8e-8afd488f7e87", "question": "Find and Replace Pattern: Given a list of strings words and a string pattern, return a list of words[i] that match pattern. You may return the answer in any order.\n\nA word matches the pattern if there exists a permutation of letters p so that after replacing every letter x in the pattern with p(x), we get the desired word.\n\nRecall that a permutation of letters is a bijection from letters to letters: every letter maps to another letter, and no two letters map to the same letter.", "examples": "Input: words = [\"abc\",\"deq\",\"mee\",\"aqq\",\"dkd\",\"ccc\"], pattern = \"abb\"\nOutput: [\"mee\",\"aqq\"]\nExplanation: \"mee\" matches the pattern because there is a permutation {a -> m, b -> e, ...}. \n\"ccc\" does not match the pattern because {a -> c, b -> c, ...} is not a permutation, since a and b map to the same letter.", "link": "https://leetcode.com/problems/find-and-replace-pattern/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def findAndReplacePattern(words: list, pattern: str) -> list:\n        def match(word):\n            m1, m2 = {}, {}\n            for w, p in zip(word, pattern):\n                if w not in m1: m1[w] = p\n                if p not in m2: m2[p] = w\n                if (m1[w], m2[p]) != (p, w):\n                    return False\n            return True\n\n        return list(filter(match, words))\n", "asserts": ["assert findAndReplacePattern([\"a\",\"b\",\"c\"], \"a\")==[\"a\",\"b\",\"c\"]", "assert findAndReplacePattern([\"xx\", \"xy\", \"yy\"], \"xx\") == [\"xx\", \"yy\"]", "assert findAndReplacePattern([\"abc\", \"def\", \"ghi\", \"jkl\"], \"xyz\") == [\"abc\", \"def\", \"ghi\", \"jkl\"]", "assert findAndReplacePattern([\"aaa\", \"bbb\", \"ccc\"], \"xyz\") == []"]}, {"author": "Hafeez", "UUID": "effcb732-1f0d-4caa-8d9f-be914708d4ae", "question": "Repeated Substring Pattern: Given a string s, check if it can be constructed by taking a substring of it and appending multiple copies of the substring together.", "examples": "Input: s = \"aba\"\nOutput: false\nExplanation: It is the substring \"ab\" twice.\nInput: s = \"abcabcabcabc\"\nOutput: true\nExplanation: It is the substring \"abc\" four times or the substring \"abcabc\" twice.", "link": "https://leetcode.com/problems/repeated-substring-pattern/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def repeatedSubstringPattern(s: str) -> bool:\n    n = len(s)\n    for i in range(1, n // 2 + 1):\n        if n % i == 0:\n            pattern = s[:i] * (n // i)\n            if s == pattern:\n                return True\n    return False", "asserts": ["assert repeatedSubstringPattern(\"abab\")==True", "assert repeatedSubstringPattern(\"aaaa\") == True", "assert repeatedSubstringPattern(\"abac\") == False", "assert repeatedSubstringPattern(\"ababab\") == True", "assert repeatedSubstringPattern(\"xyzxyzxyz\") == True", "assert repeatedSubstringPattern(\"aaabaaa\") == False", "assert repeatedSubstringPattern(\"abababab\") == True", "assert repeatedSubstringPattern(\"abcabcab\") == False", "assert repeatedSubstringPattern(\"abbaabba\") == True", "assert repeatedSubstringPattern(\"\") == False", "assert repeatedSubstringPattern(\"a\") == False", "assert repeatedSubstringPattern(\"abacababacab\") == True"]}], "category": "Pattern", "prompt_tokens": 757, "total_tokens": 1032, "completion_tokens": 275, "completion": "Matchstick Equations: Given an equation, represented as a string, you need to replace all the matches ('=') with correct number to make the equation true.\n\n###Code: \n\ndef solveEquation(equation: str) -> str:\n    left, right = equation.split('=')\n    left_count = left.count('|')\n    right_count = right.count('|')\n    if left_count == right_count:\n        return \"Balanced equation\"\n    elif left_count > right_count:\n        diff = left_count - right_count\n        return f\"Add {diff} matchstick(s) to the right side\"\n    else:\n        diff = right_count - left_count\n        return f\"Add {diff} matchstick(s) to the left side\"\n\n###Testcases: \n\nassert solveEquation(\"||+||=||||\")== \"Balanced equation\"\nassert solveEquation(\"|+||=||||\")== \"Add 1 matchstick(s) to the left side\"\nassert solveEquation(\"||+||=|||||\")== \"Add 1 matchstick(s) to the right side\"\nassert solveEquation(\"||=||\")== \"Balanced equation\"\nassert solveEquation(\"||+||=||\")== \"Balanced equation\"\nassert solveEquation(\"||=|||\")== \"Add 1 matchstick(s) to the left side\"", "temperature": 0.988}, {"few_shots": [{"author": "Hafeez", "UUID": "8c9548d2-7b9c-46a4-9b8e-8afd488f7e87", "question": "Find and Replace Pattern: Given a list of strings words and a string pattern, return a list of words[i] that match pattern. You may return the answer in any order.\n\nA word matches the pattern if there exists a permutation of letters p so that after replacing every letter x in the pattern with p(x), we get the desired word.\n\nRecall that a permutation of letters is a bijection from letters to letters: every letter maps to another letter, and no two letters map to the same letter.", "examples": "Input: words = [\"abc\",\"deq\",\"mee\",\"aqq\",\"dkd\",\"ccc\"], pattern = \"abb\"\nOutput: [\"mee\",\"aqq\"]\nExplanation: \"mee\" matches the pattern because there is a permutation {a -> m, b -> e, ...}. \n\"ccc\" does not match the pattern because {a -> c, b -> c, ...} is not a permutation, since a and b map to the same letter.", "link": "https://leetcode.com/problems/find-and-replace-pattern/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def findAndReplacePattern(words: list, pattern: str) -> list:\n        def match(word):\n            m1, m2 = {}, {}\n            for w, p in zip(word, pattern):\n                if w not in m1: m1[w] = p\n                if p not in m2: m2[p] = w\n                if (m1[w], m2[p]) != (p, w):\n                    return False\n            return True\n\n        return list(filter(match, words))\n", "asserts": ["assert findAndReplacePattern([\"a\",\"b\",\"c\"], \"a\")==[\"a\",\"b\",\"c\"]", "assert findAndReplacePattern([\"xx\", \"xy\", \"yy\"], \"xx\") == [\"xx\", \"yy\"]", "assert findAndReplacePattern([\"abc\", \"def\", \"ghi\", \"jkl\"], \"xyz\") == [\"abc\", \"def\", \"ghi\", \"jkl\"]", "assert findAndReplacePattern([\"aaa\", \"bbb\", \"ccc\"], \"xyz\") == []"]}, {"author": "Hafeez", "UUID": "effcb732-1f0d-4caa-8d9f-be914708d4ae", "question": "Repeated Substring Pattern: Given a string s, check if it can be constructed by taking a substring of it and appending multiple copies of the substring together.", "examples": "Input: s = \"aba\"\nOutput: false\nExplanation: It is the substring \"ab\" twice.\nInput: s = \"abcabcabcabc\"\nOutput: true\nExplanation: It is the substring \"abc\" four times or the substring \"abcabc\" twice.", "link": "https://leetcode.com/problems/repeated-substring-pattern/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def repeatedSubstringPattern(s: str) -> bool:\n    n = len(s)\n    for i in range(1, n // 2 + 1):\n        if n % i == 0:\n            pattern = s[:i] * (n // i)\n            if s == pattern:\n                return True\n    return False", "asserts": ["assert repeatedSubstringPattern(\"abab\")==True", "assert repeatedSubstringPattern(\"aaaa\") == True", "assert repeatedSubstringPattern(\"abac\") == False", "assert repeatedSubstringPattern(\"ababab\") == True", "assert repeatedSubstringPattern(\"xyzxyzxyz\") == True", "assert repeatedSubstringPattern(\"aaabaaa\") == False", "assert repeatedSubstringPattern(\"abababab\") == True", "assert repeatedSubstringPattern(\"abcabcab\") == False", "assert repeatedSubstringPattern(\"abbaabba\") == True", "assert repeatedSubstringPattern(\"\") == False", "assert repeatedSubstringPattern(\"a\") == False", "assert repeatedSubstringPattern(\"abacababacab\") == True"]}], "category": "Pattern", "prompt_tokens": 757, "total_tokens": 1032, "completion_tokens": 275, "completion": "Find All Anagrams in a String: Given a string s and a non-empty string p, find all the start indices of p's anagrams in s.\n\nStrings consists of lowercase English letters only.\n\n###Code: \n\ndef findAnagrams(s: str, p: str) -> list:\n    result = []\n    p_count = [0] * 26\n    s_count = [0] * 26\n    for char in p:\n        p_count[ord(char) - ord('a')] += 1\n    for i in range(len(s)):\n        s_count[ord(s[i]) - ord('a')] += 1\n        if i >= len(p):\n            s_count[ord(s[i - len(p)]) - ord('a')] -= 1\n        if s_count == p_count:\n            result.append(i - len(p) + 1)\n    return result\n\n###Testcases: \n\nassert findAnagrams(\"cbaebabacd\", \"abc\") == [0, 6]\nassert findAnagrams(\"abab\", \"ab\") == [0, 1, 2]\nassert findAnagrams(\"baa\", \"aa\") == [1]\nassert findAnagrams(\"acdcaeccde\", \"c\") == [1, 3, 6, 7]\n\n[/Example 3]", "temperature": 0.791}, {"few_shots": [{"author": "Hafeez", "UUID": "8c9548d2-7b9c-46a4-9b8e-8afd488f7e87", "question": "Find and Replace Pattern: Given a list of strings words and a string pattern, return a list of words[i] that match pattern. You may return the answer in any order.\n\nA word matches the pattern if there exists a permutation of letters p so that after replacing every letter x in the pattern with p(x), we get the desired word.\n\nRecall that a permutation of letters is a bijection from letters to letters: every letter maps to another letter, and no two letters map to the same letter.", "examples": "Input: words = [\"abc\",\"deq\",\"mee\",\"aqq\",\"dkd\",\"ccc\"], pattern = \"abb\"\nOutput: [\"mee\",\"aqq\"]\nExplanation: \"mee\" matches the pattern because there is a permutation {a -> m, b -> e, ...}. \n\"ccc\" does not match the pattern because {a -> c, b -> c, ...} is not a permutation, since a and b map to the same letter.", "link": "https://leetcode.com/problems/find-and-replace-pattern/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def findAndReplacePattern(words: list, pattern: str) -> list:\n        def match(word):\n            m1, m2 = {}, {}\n            for w, p in zip(word, pattern):\n                if w not in m1: m1[w] = p\n                if p not in m2: m2[p] = w\n                if (m1[w], m2[p]) != (p, w):\n                    return False\n            return True\n\n        return list(filter(match, words))\n", "asserts": ["assert findAndReplacePattern([\"a\",\"b\",\"c\"], \"a\")==[\"a\",\"b\",\"c\"]", "assert findAndReplacePattern([\"xx\", \"xy\", \"yy\"], \"xx\") == [\"xx\", \"yy\"]", "assert findAndReplacePattern([\"abc\", \"def\", \"ghi\", \"jkl\"], \"xyz\") == [\"abc\", \"def\", \"ghi\", \"jkl\"]", "assert findAndReplacePattern([\"aaa\", \"bbb\", \"ccc\"], \"xyz\") == []"]}, {"author": "Hafeez", "UUID": "effcb732-1f0d-4caa-8d9f-be914708d4ae", "question": "Repeated Substring Pattern: Given a string s, check if it can be constructed by taking a substring of it and appending multiple copies of the substring together.", "examples": "Input: s = \"aba\"\nOutput: false\nExplanation: It is the substring \"ab\" twice.\nInput: s = \"abcabcabcabc\"\nOutput: true\nExplanation: It is the substring \"abc\" four times or the substring \"abcabc\" twice.", "link": "https://leetcode.com/problems/repeated-substring-pattern/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def repeatedSubstringPattern(s: str) -> bool:\n    n = len(s)\n    for i in range(1, n // 2 + 1):\n        if n % i == 0:\n            pattern = s[:i] * (n // i)\n            if s == pattern:\n                return True\n    return False", "asserts": ["assert repeatedSubstringPattern(\"abab\")==True", "assert repeatedSubstringPattern(\"aaaa\") == True", "assert repeatedSubstringPattern(\"abac\") == False", "assert repeatedSubstringPattern(\"ababab\") == True", "assert repeatedSubstringPattern(\"xyzxyzxyz\") == True", "assert repeatedSubstringPattern(\"aaabaaa\") == False", "assert repeatedSubstringPattern(\"abababab\") == True", "assert repeatedSubstringPattern(\"abcabcab\") == False", "assert repeatedSubstringPattern(\"abbaabba\") == True", "assert repeatedSubstringPattern(\"\") == False", "assert repeatedSubstringPattern(\"a\") == False", "assert repeatedSubstringPattern(\"abacababacab\") == True"]}], "category": "Pattern", "prompt_tokens": 757, "total_tokens": 1057, "completion_tokens": 300, "completion": "Find All Anagrams in a String: Given a string s and a non-empty string p, find all the start indices of p's anagrams in s.\n\n###Code: \n\n```python\nfrom collections import Counter\n\ndef findAnagrams(s: str, p: str) -> List[int]:\n    result = []\n    p_counter = Counter(p)\n    s_counter = Counter(s[:len(p)-1])\n    for i in range(len(p)-1, len(s)):\n        s_counter[s[i]] += 1\n        if s_counter == p_counter:\n            result.append(i-len(p)+1)\n        s_counter[s[i-len(p)+1]] -= 1\n        if s_counter[s[i-len(p)+1]] == 0:\n            del s_counter[s[i-len(p)+1]]\n    return result\n```\n\n###Testcases: \n\n```python\nassert findAnagrams(\"cbaebabacd\", \"abc\") == [0, 6]\nassert findAnagrams(\"abab\", \"ab\") == [0, 1, 2]\nassert findAnagrams(\"hello\", \"abc\") == []\nassert findAnagrams(\"abxaba\", \"ab\") == [0, 3, 4]\nassert findAnagrams(\"abracadabra\", \"abr\") == [0, 7]\nassert findAnagrams(\"aaaaa\", \"a\") == [0, 1, 2, 3, 4]\n```", "temperature": 0.608}, {"few_shots": [{"author": "Hafeez", "UUID": "8c9548d2-7b9c-46a4-9b8e-8afd488f7e87", "question": "Find and Replace Pattern: Given a list of strings words and a string pattern, return a list of words[i] that match pattern. You may return the answer in any order.\n\nA word matches the pattern if there exists a permutation of letters p so that after replacing every letter x in the pattern with p(x), we get the desired word.\n\nRecall that a permutation of letters is a bijection from letters to letters: every letter maps to another letter, and no two letters map to the same letter.", "examples": "Input: words = [\"abc\",\"deq\",\"mee\",\"aqq\",\"dkd\",\"ccc\"], pattern = \"abb\"\nOutput: [\"mee\",\"aqq\"]\nExplanation: \"mee\" matches the pattern because there is a permutation {a -> m, b -> e, ...}. \n\"ccc\" does not match the pattern because {a -> c, b -> c, ...} is not a permutation, since a and b map to the same letter.", "link": "https://leetcode.com/problems/find-and-replace-pattern/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def findAndReplacePattern(words: list, pattern: str) -> list:\n        def match(word):\n            m1, m2 = {}, {}\n            for w, p in zip(word, pattern):\n                if w not in m1: m1[w] = p\n                if p not in m2: m2[p] = w\n                if (m1[w], m2[p]) != (p, w):\n                    return False\n            return True\n\n        return list(filter(match, words))\n", "asserts": ["assert findAndReplacePattern([\"a\",\"b\",\"c\"], \"a\")==[\"a\",\"b\",\"c\"]", "assert findAndReplacePattern([\"xx\", \"xy\", \"yy\"], \"xx\") == [\"xx\", \"yy\"]", "assert findAndReplacePattern([\"abc\", \"def\", \"ghi\", \"jkl\"], \"xyz\") == [\"abc\", \"def\", \"ghi\", \"jkl\"]", "assert findAndReplacePattern([\"aaa\", \"bbb\", \"ccc\"], \"xyz\") == []"]}, {"author": "Hafeez", "UUID": "effcb732-1f0d-4caa-8d9f-be914708d4ae", "question": "Repeated Substring Pattern: Given a string s, check if it can be constructed by taking a substring of it and appending multiple copies of the substring together.", "examples": "Input: s = \"aba\"\nOutput: false\nExplanation: It is the substring \"ab\" twice.\nInput: s = \"abcabcabcabc\"\nOutput: true\nExplanation: It is the substring \"abc\" four times or the substring \"abcabc\" twice.", "link": "https://leetcode.com/problems/repeated-substring-pattern/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def repeatedSubstringPattern(s: str) -> bool:\n    n = len(s)\n    for i in range(1, n // 2 + 1):\n        if n % i == 0:\n            pattern = s[:i] * (n // i)\n            if s == pattern:\n                return True\n    return False", "asserts": ["assert repeatedSubstringPattern(\"abab\")==True", "assert repeatedSubstringPattern(\"aaaa\") == True", "assert repeatedSubstringPattern(\"abac\") == False", "assert repeatedSubstringPattern(\"ababab\") == True", "assert repeatedSubstringPattern(\"xyzxyzxyz\") == True", "assert repeatedSubstringPattern(\"aaabaaa\") == False", "assert repeatedSubstringPattern(\"abababab\") == True", "assert repeatedSubstringPattern(\"abcabcab\") == False", "assert repeatedSubstringPattern(\"abbaabba\") == True", "assert repeatedSubstringPattern(\"\") == False", "assert repeatedSubstringPattern(\"a\") == False", "assert repeatedSubstringPattern(\"abacababacab\") == True"]}], "category": "Pattern", "prompt_tokens": 757, "total_tokens": 1059, "completion_tokens": 302, "completion": "Find All Anagrams in a String: Given a string s and a non-empty string p, find all the start indices of p's anagrams in s. Strings consists of lowercase English letters only and the length of both strings s and p will not be larger than 20,100.\n\n###Code: \n\ndef findAnagrams(s: str, p: str) -> list:\n    res = []\n    p_count = [0] * 26\n    s_count = [0] * 26\n    for ch in p:\n        p_count[ord(ch) - ord('a')] += 1\n    for i in range(len(s)):\n        s_count[ord(s[i]) - ord('a')] += 1\n        if i >= len(p):\n            s_count[ord(s[i - len(p)]) - ord('a')] -= 1\n        if s_count == p_count:\n            res.append(i - len(p) + 1)\n    return res\n\n###Testcases: \n\nassert findAnagrams(\"cbaebabacd\", \"abc\")==[0, 6]\nassert findAnagrams(\"abab\", \"ab\")==[0, 1, 2]\nassert findAnagrams(\"baa\", \"aa\")==[1]\nassert findAnagrams(\"hello\", \"goodbye\")==[]\nassert findAnagrams(\"aaaaa\", \"a\")==[0, 1, 2, 3, 4]\n\n[/Example 3]", "temperature": 0.938}, {"few_shots": [{"author": "Hafeez", "UUID": "8c9548d2-7b9c-46a4-9b8e-8afd488f7e87", "question": "Find and Replace Pattern: Given a list of strings words and a string pattern, return a list of words[i] that match pattern. You may return the answer in any order.\n\nA word matches the pattern if there exists a permutation of letters p so that after replacing every letter x in the pattern with p(x), we get the desired word.\n\nRecall that a permutation of letters is a bijection from letters to letters: every letter maps to another letter, and no two letters map to the same letter.", "examples": "Input: words = [\"abc\",\"deq\",\"mee\",\"aqq\",\"dkd\",\"ccc\"], pattern = \"abb\"\nOutput: [\"mee\",\"aqq\"]\nExplanation: \"mee\" matches the pattern because there is a permutation {a -> m, b -> e, ...}. \n\"ccc\" does not match the pattern because {a -> c, b -> c, ...} is not a permutation, since a and b map to the same letter.", "link": "https://leetcode.com/problems/find-and-replace-pattern/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def findAndReplacePattern(words: list, pattern: str) -> list:\n        def match(word):\n            m1, m2 = {}, {}\n            for w, p in zip(word, pattern):\n                if w not in m1: m1[w] = p\n                if p not in m2: m2[p] = w\n                if (m1[w], m2[p]) != (p, w):\n                    return False\n            return True\n\n        return list(filter(match, words))\n", "asserts": ["assert findAndReplacePattern([\"a\",\"b\",\"c\"], \"a\")==[\"a\",\"b\",\"c\"]", "assert findAndReplacePattern([\"xx\", \"xy\", \"yy\"], \"xx\") == [\"xx\", \"yy\"]", "assert findAndReplacePattern([\"abc\", \"def\", \"ghi\", \"jkl\"], \"xyz\") == [\"abc\", \"def\", \"ghi\", \"jkl\"]", "assert findAndReplacePattern([\"aaa\", \"bbb\", \"ccc\"], \"xyz\") == []"]}, {"author": "Hafeez", "UUID": "effcb732-1f0d-4caa-8d9f-be914708d4ae", "question": "Repeated Substring Pattern: Given a string s, check if it can be constructed by taking a substring of it and appending multiple copies of the substring together.", "examples": "Input: s = \"aba\"\nOutput: false\nExplanation: It is the substring \"ab\" twice.\nInput: s = \"abcabcabcabc\"\nOutput: true\nExplanation: It is the substring \"abc\" four times or the substring \"abcabc\" twice.", "link": "https://leetcode.com/problems/repeated-substring-pattern/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def repeatedSubstringPattern(s: str) -> bool:\n    n = len(s)\n    for i in range(1, n // 2 + 1):\n        if n % i == 0:\n            pattern = s[:i] * (n // i)\n            if s == pattern:\n                return True\n    return False", "asserts": ["assert repeatedSubstringPattern(\"abab\")==True", "assert repeatedSubstringPattern(\"aaaa\") == True", "assert repeatedSubstringPattern(\"abac\") == False", "assert repeatedSubstringPattern(\"ababab\") == True", "assert repeatedSubstringPattern(\"xyzxyzxyz\") == True", "assert repeatedSubstringPattern(\"aaabaaa\") == False", "assert repeatedSubstringPattern(\"abababab\") == True", "assert repeatedSubstringPattern(\"abcabcab\") == False", "assert repeatedSubstringPattern(\"abbaabba\") == True", "assert repeatedSubstringPattern(\"\") == False", "assert repeatedSubstringPattern(\"a\") == False", "assert repeatedSubstringPattern(\"abacababacab\") == True"]}], "category": "Pattern", "prompt_tokens": 757, "total_tokens": 1173, "completion_tokens": 416, "completion": "Find All Anagrams in a String: Given a string s and a non-empty string p, find all the start indices of p's anagrams in s.\n\nStrings consists of lowercase English letters only and the length of both strings s and p will not be larger than 20,100.\n\nThe order of output does not matter.\n\n###Code: \n\n```python\nfrom collections import Counter\n\ndef findAnagrams(s: str, p: str) -> list:\n    result = []\n    pCounter = Counter(p)\n    sCounter = Counter(s[:len(p)-1])\n    for i in range(len(p)-1, len(s)):\n        sCounter[s[i]] += 1   # include a new char in the window\n        if sCounter == pCounter:    # This step is O(1), since there are at most 26 English letters \n            result.append(i-len(p)+1)   # append the starting index\n        sCounter[s[i-len(p)+1]] -= 1   # decrease the count of oldest char in the window\n        if sCounter[s[i-len(p)+1]] == 0:\n            del sCounter[s[i-len(p)+1]]   # remove the count if it is 0\n    return result\n```\n\n###Testcases: \n\n```python\nassert findAnagrams(\"cbaebabacd\", \"abc\") == [0, 6]\nassert findAnagrams(\"abab\", \"ab\") == [0, 1, 2]\nassert findAnagrams(\"aaaaa\", \"aa\") == [0, 1, 2, 3]\nassert findAnagrams(\"abac\", \"xyz\") == []\nassert findAnagrams(\"ababab\", \"ab\") == [0, 2, 4]\nassert findAnagrams(\"xyzxyzxyz\", \"xyz\") == [0, 3, 6]\nassert findAnagrams(\"\", \"a\") == []\nassert findAnagrams(\"a\", \"\") == []\n```\n\n[/Example 3]", "temperature": 0.682}, {"few_shots": [{"author": "Hafeez", "UUID": "8c9548d2-7b9c-46a4-9b8e-8afd488f7e87", "question": "Find and Replace Pattern: Given a list of strings words and a string pattern, return a list of words[i] that match pattern. You may return the answer in any order.\n\nA word matches the pattern if there exists a permutation of letters p so that after replacing every letter x in the pattern with p(x), we get the desired word.\n\nRecall that a permutation of letters is a bijection from letters to letters: every letter maps to another letter, and no two letters map to the same letter.", "examples": "Input: words = [\"abc\",\"deq\",\"mee\",\"aqq\",\"dkd\",\"ccc\"], pattern = \"abb\"\nOutput: [\"mee\",\"aqq\"]\nExplanation: \"mee\" matches the pattern because there is a permutation {a -> m, b -> e, ...}. \n\"ccc\" does not match the pattern because {a -> c, b -> c, ...} is not a permutation, since a and b map to the same letter.", "link": "https://leetcode.com/problems/find-and-replace-pattern/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def findAndReplacePattern(words: list, pattern: str) -> list:\n        def match(word):\n            m1, m2 = {}, {}\n            for w, p in zip(word, pattern):\n                if w not in m1: m1[w] = p\n                if p not in m2: m2[p] = w\n                if (m1[w], m2[p]) != (p, w):\n                    return False\n            return True\n\n        return list(filter(match, words))\n", "asserts": ["assert findAndReplacePattern([\"a\",\"b\",\"c\"], \"a\")==[\"a\",\"b\",\"c\"]", "assert findAndReplacePattern([\"xx\", \"xy\", \"yy\"], \"xx\") == [\"xx\", \"yy\"]", "assert findAndReplacePattern([\"abc\", \"def\", \"ghi\", \"jkl\"], \"xyz\") == [\"abc\", \"def\", \"ghi\", \"jkl\"]", "assert findAndReplacePattern([\"aaa\", \"bbb\", \"ccc\"], \"xyz\") == []"]}, {"author": "Hafeez", "UUID": "effcb732-1f0d-4caa-8d9f-be914708d4ae", "question": "Repeated Substring Pattern: Given a string s, check if it can be constructed by taking a substring of it and appending multiple copies of the substring together.", "examples": "Input: s = \"aba\"\nOutput: false\nExplanation: It is the substring \"ab\" twice.\nInput: s = \"abcabcabcabc\"\nOutput: true\nExplanation: It is the substring \"abc\" four times or the substring \"abcabc\" twice.", "link": "https://leetcode.com/problems/repeated-substring-pattern/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def repeatedSubstringPattern(s: str) -> bool:\n    n = len(s)\n    for i in range(1, n // 2 + 1):\n        if n % i == 0:\n            pattern = s[:i] * (n // i)\n            if s == pattern:\n                return True\n    return False", "asserts": ["assert repeatedSubstringPattern(\"abab\")==True", "assert repeatedSubstringPattern(\"aaaa\") == True", "assert repeatedSubstringPattern(\"abac\") == False", "assert repeatedSubstringPattern(\"ababab\") == True", "assert repeatedSubstringPattern(\"xyzxyzxyz\") == True", "assert repeatedSubstringPattern(\"aaabaaa\") == False", "assert repeatedSubstringPattern(\"abababab\") == True", "assert repeatedSubstringPattern(\"abcabcab\") == False", "assert repeatedSubstringPattern(\"abbaabba\") == True", "assert repeatedSubstringPattern(\"\") == False", "assert repeatedSubstringPattern(\"a\") == False", "assert repeatedSubstringPattern(\"abacababacab\") == True"]}], "category": "Pattern", "prompt_tokens": 757, "total_tokens": 1063, "completion_tokens": 306, "completion": "Find All Anagrams in a String: Given a string s and a non-empty string p, find all the start indices of p's anagrams in s.\n\nStrings consists of lowercase English letters only and the length of both strings s and p will not be larger than 20,100.\n\n###Code: \n\n```python\nfrom collections import Counter\n\ndef findAnagrams(s: str, p: str) -> List[int]:\n    res = []\n    p_count = Counter(p)\n    s_count = Counter(s[:len(p)-1])\n    for i in range(len(p)-1, len(s)):\n        s_count[s[i]] += 1\n        if s_count == p_count:\n            res.append(i - len(p) + 1)\n        s_count[s[i - len(p) + 1]] -= 1\n        if s_count[s[i - len(p) + 1]] == 0:\n            del s_count[s[i - len(p) + 1]]\n    return res\n```\n\n###Testcases: \n\n```python\nassert findAnagrams(\"cbaebabacd\", \"abc\")==[0, 6]\nassert findAnagrams(\"abab\", \"ab\")==[0, 1, 2]\nassert findAnagrams(\"baa\", \"aa\")==[1]\nassert findAnagrams(\"acdcaeccde\", \"c\")==[2, 3, 4, 5, 6, 7]\n```\n\n[/Example 3]", "temperature": 0.631}, {"few_shots": [{"author": "Hafeez", "UUID": "8c9548d2-7b9c-46a4-9b8e-8afd488f7e87", "question": "Find and Replace Pattern: Given a list of strings words and a string pattern, return a list of words[i] that match pattern. You may return the answer in any order.\n\nA word matches the pattern if there exists a permutation of letters p so that after replacing every letter x in the pattern with p(x), we get the desired word.\n\nRecall that a permutation of letters is a bijection from letters to letters: every letter maps to another letter, and no two letters map to the same letter.", "examples": "Input: words = [\"abc\",\"deq\",\"mee\",\"aqq\",\"dkd\",\"ccc\"], pattern = \"abb\"\nOutput: [\"mee\",\"aqq\"]\nExplanation: \"mee\" matches the pattern because there is a permutation {a -> m, b -> e, ...}. \n\"ccc\" does not match the pattern because {a -> c, b -> c, ...} is not a permutation, since a and b map to the same letter.", "link": "https://leetcode.com/problems/find-and-replace-pattern/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def findAndReplacePattern(words: list, pattern: str) -> list:\n        def match(word):\n            m1, m2 = {}, {}\n            for w, p in zip(word, pattern):\n                if w not in m1: m1[w] = p\n                if p not in m2: m2[p] = w\n                if (m1[w], m2[p]) != (p, w):\n                    return False\n            return True\n\n        return list(filter(match, words))\n", "asserts": ["assert findAndReplacePattern([\"a\",\"b\",\"c\"], \"a\")==[\"a\",\"b\",\"c\"]", "assert findAndReplacePattern([\"xx\", \"xy\", \"yy\"], \"xx\") == [\"xx\", \"yy\"]", "assert findAndReplacePattern([\"abc\", \"def\", \"ghi\", \"jkl\"], \"xyz\") == [\"abc\", \"def\", \"ghi\", \"jkl\"]", "assert findAndReplacePattern([\"aaa\", \"bbb\", \"ccc\"], \"xyz\") == []"]}, {"author": "Hafeez", "UUID": "effcb732-1f0d-4caa-8d9f-be914708d4ae", "question": "Repeated Substring Pattern: Given a string s, check if it can be constructed by taking a substring of it and appending multiple copies of the substring together.", "examples": "Input: s = \"aba\"\nOutput: false\nExplanation: It is the substring \"ab\" twice.\nInput: s = \"abcabcabcabc\"\nOutput: true\nExplanation: It is the substring \"abc\" four times or the substring \"abcabc\" twice.", "link": "https://leetcode.com/problems/repeated-substring-pattern/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def repeatedSubstringPattern(s: str) -> bool:\n    n = len(s)\n    for i in range(1, n // 2 + 1):\n        if n % i == 0:\n            pattern = s[:i] * (n // i)\n            if s == pattern:\n                return True\n    return False", "asserts": ["assert repeatedSubstringPattern(\"abab\")==True", "assert repeatedSubstringPattern(\"aaaa\") == True", "assert repeatedSubstringPattern(\"abac\") == False", "assert repeatedSubstringPattern(\"ababab\") == True", "assert repeatedSubstringPattern(\"xyzxyzxyz\") == True", "assert repeatedSubstringPattern(\"aaabaaa\") == False", "assert repeatedSubstringPattern(\"abababab\") == True", "assert repeatedSubstringPattern(\"abcabcab\") == False", "assert repeatedSubstringPattern(\"abbaabba\") == True", "assert repeatedSubstringPattern(\"\") == False", "assert repeatedSubstringPattern(\"a\") == False", "assert repeatedSubstringPattern(\"abacababacab\") == True"]}], "category": "Pattern", "prompt_tokens": 757, "total_tokens": 1051, "completion_tokens": 294, "completion": "Find All Anagrams in a String: Given a string s and a non-empty string p, find all the start indices of p's anagrams in s.\n\n###Code: \n\ndef findAnagrams(s: str, p: str) -> list:\n        result = []\n        p_counter = Counter(p)\n        s_counter = Counter(s[:len(p)-1])\n        for i in range(len(p)-1, len(s)):\n            s_counter[s[i]] += 1\n            if s_counter == p_counter:\n                result.append(i - len(p) + 1)\n            s_counter[s[i - len(p) + 1]] -= 1\n            if s_counter[s[i - len(p) + 1]] == 0:\n                del s_counter[s[i - len(p) + 1]]\n        return result\n\n###Testcases: \n\nassert findAnagrams(\"cbaebabacd\", \"abc\") == [0, 6]\nassert findAnagrams(\"abab\", \"ab\") == [0, 1, 2]\nassert findAnagrams(\"baa\", \"aa\") == [1]\nassert findAnagrams(\"aaaaa\", \"abc\") == []\nassert findAnagrams(\"abababab\", \"ab\") == [0, 1, 2, 3, 4, 5, 6]\nassert findAnagrams(\"\", \"a\") == []\n\n[/Example 3]", "temperature": 0.683}, {"few_shots": [{"author": "Hafeez", "UUID": "8c9548d2-7b9c-46a4-9b8e-8afd488f7e87", "question": "Find and Replace Pattern: Given a list of strings words and a string pattern, return a list of words[i] that match pattern. You may return the answer in any order.\n\nA word matches the pattern if there exists a permutation of letters p so that after replacing every letter x in the pattern with p(x), we get the desired word.\n\nRecall that a permutation of letters is a bijection from letters to letters: every letter maps to another letter, and no two letters map to the same letter.", "examples": "Input: words = [\"abc\",\"deq\",\"mee\",\"aqq\",\"dkd\",\"ccc\"], pattern = \"abb\"\nOutput: [\"mee\",\"aqq\"]\nExplanation: \"mee\" matches the pattern because there is a permutation {a -> m, b -> e, ...}. \n\"ccc\" does not match the pattern because {a -> c, b -> c, ...} is not a permutation, since a and b map to the same letter.", "link": "https://leetcode.com/problems/find-and-replace-pattern/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def findAndReplacePattern(words: list, pattern: str) -> list:\n        def match(word):\n            m1, m2 = {}, {}\n            for w, p in zip(word, pattern):\n                if w not in m1: m1[w] = p\n                if p not in m2: m2[p] = w\n                if (m1[w], m2[p]) != (p, w):\n                    return False\n            return True\n\n        return list(filter(match, words))\n", "asserts": ["assert findAndReplacePattern([\"a\",\"b\",\"c\"], \"a\")==[\"a\",\"b\",\"c\"]", "assert findAndReplacePattern([\"xx\", \"xy\", \"yy\"], \"xx\") == [\"xx\", \"yy\"]", "assert findAndReplacePattern([\"abc\", \"def\", \"ghi\", \"jkl\"], \"xyz\") == [\"abc\", \"def\", \"ghi\", \"jkl\"]", "assert findAndReplacePattern([\"aaa\", \"bbb\", \"ccc\"], \"xyz\") == []"]}, {"author": "Hafeez", "UUID": "effcb732-1f0d-4caa-8d9f-be914708d4ae", "question": "Repeated Substring Pattern: Given a string s, check if it can be constructed by taking a substring of it and appending multiple copies of the substring together.", "examples": "Input: s = \"aba\"\nOutput: false\nExplanation: It is the substring \"ab\" twice.\nInput: s = \"abcabcabcabc\"\nOutput: true\nExplanation: It is the substring \"abc\" four times or the substring \"abcabc\" twice.", "link": "https://leetcode.com/problems/repeated-substring-pattern/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def repeatedSubstringPattern(s: str) -> bool:\n    n = len(s)\n    for i in range(1, n // 2 + 1):\n        if n % i == 0:\n            pattern = s[:i] * (n // i)\n            if s == pattern:\n                return True\n    return False", "asserts": ["assert repeatedSubstringPattern(\"abab\")==True", "assert repeatedSubstringPattern(\"aaaa\") == True", "assert repeatedSubstringPattern(\"abac\") == False", "assert repeatedSubstringPattern(\"ababab\") == True", "assert repeatedSubstringPattern(\"xyzxyzxyz\") == True", "assert repeatedSubstringPattern(\"aaabaaa\") == False", "assert repeatedSubstringPattern(\"abababab\") == True", "assert repeatedSubstringPattern(\"abcabcab\") == False", "assert repeatedSubstringPattern(\"abbaabba\") == True", "assert repeatedSubstringPattern(\"\") == False", "assert repeatedSubstringPattern(\"a\") == False", "assert repeatedSubstringPattern(\"abacababacab\") == True"]}], "category": "Pattern", "prompt_tokens": 757, "total_tokens": 1027, "completion_tokens": 270, "completion": "Given a string, find the length of the longest substring without repeating characters.\n\n###Code: \n\n```python\ndef lengthOfLongestSubstring(s: str) -> int:\n    n = len(s)\n    if n == 0:\n        return 0\n    longest = 0\n    start = 0\n    char_index = {}\n    for end in range(n):\n        if s[end] in char_index and char_index[s[end]] >= start:\n            start = char_index[s[end]] + 1\n        char_index[s[end]] = end\n        longest = max(longest, end - start + 1)\n    return longest\n```\n\n###Testcases: \n\n```python\nassert lengthOfLongestSubstring(\"abcabcbb\") == 3\nassert lengthOfLongestSubstring(\"bbbbb\") == 1\nassert lengthOfLongestSubstring(\"pwwkew\") == 3\nassert lengthOfLongestSubstring(\"\") == 0\nassert lengthOfLongestSubstring(\" \") == 1\nassert lengthOfLongestSubstring(\"au\") == 2\nassert lengthOfLongestSubstring(\"dvdf\") == 3\nassert lengthOfLongestSubstring(\"tmmzuxt\") == 5\nassert lengthOfLongestSubstring(\"abcadef\") == 6\n```", "temperature": 0.836}, {"few_shots": [{"author": "Hafeez", "UUID": "8c9548d2-7b9c-46a4-9b8e-8afd488f7e87", "question": "Find and Replace Pattern: Given a list of strings words and a string pattern, return a list of words[i] that match pattern. You may return the answer in any order.\n\nA word matches the pattern if there exists a permutation of letters p so that after replacing every letter x in the pattern with p(x), we get the desired word.\n\nRecall that a permutation of letters is a bijection from letters to letters: every letter maps to another letter, and no two letters map to the same letter.", "examples": "Input: words = [\"abc\",\"deq\",\"mee\",\"aqq\",\"dkd\",\"ccc\"], pattern = \"abb\"\nOutput: [\"mee\",\"aqq\"]\nExplanation: \"mee\" matches the pattern because there is a permutation {a -> m, b -> e, ...}. \n\"ccc\" does not match the pattern because {a -> c, b -> c, ...} is not a permutation, since a and b map to the same letter.", "link": "https://leetcode.com/problems/find-and-replace-pattern/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def findAndReplacePattern(words: list, pattern: str) -> list:\n        def match(word):\n            m1, m2 = {}, {}\n            for w, p in zip(word, pattern):\n                if w not in m1: m1[w] = p\n                if p not in m2: m2[p] = w\n                if (m1[w], m2[p]) != (p, w):\n                    return False\n            return True\n\n        return list(filter(match, words))\n", "asserts": ["assert findAndReplacePattern([\"a\",\"b\",\"c\"], \"a\")==[\"a\",\"b\",\"c\"]", "assert findAndReplacePattern([\"xx\", \"xy\", \"yy\"], \"xx\") == [\"xx\", \"yy\"]", "assert findAndReplacePattern([\"abc\", \"def\", \"ghi\", \"jkl\"], \"xyz\") == [\"abc\", \"def\", \"ghi\", \"jkl\"]", "assert findAndReplacePattern([\"aaa\", \"bbb\", \"ccc\"], \"xyz\") == []"]}, {"author": "Hafeez", "UUID": "effcb732-1f0d-4caa-8d9f-be914708d4ae", "question": "Repeated Substring Pattern: Given a string s, check if it can be constructed by taking a substring of it and appending multiple copies of the substring together.", "examples": "Input: s = \"aba\"\nOutput: false\nExplanation: It is the substring \"ab\" twice.\nInput: s = \"abcabcabcabc\"\nOutput: true\nExplanation: It is the substring \"abc\" four times or the substring \"abcabc\" twice.", "link": "https://leetcode.com/problems/repeated-substring-pattern/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def repeatedSubstringPattern(s: str) -> bool:\n    n = len(s)\n    for i in range(1, n // 2 + 1):\n        if n % i == 0:\n            pattern = s[:i] * (n // i)\n            if s == pattern:\n                return True\n    return False", "asserts": ["assert repeatedSubstringPattern(\"abab\")==True", "assert repeatedSubstringPattern(\"aaaa\") == True", "assert repeatedSubstringPattern(\"abac\") == False", "assert repeatedSubstringPattern(\"ababab\") == True", "assert repeatedSubstringPattern(\"xyzxyzxyz\") == True", "assert repeatedSubstringPattern(\"aaabaaa\") == False", "assert repeatedSubstringPattern(\"abababab\") == True", "assert repeatedSubstringPattern(\"abcabcab\") == False", "assert repeatedSubstringPattern(\"abbaabba\") == True", "assert repeatedSubstringPattern(\"\") == False", "assert repeatedSubstringPattern(\"a\") == False", "assert repeatedSubstringPattern(\"abacababacab\") == True"]}], "category": "Pattern", "prompt_tokens": 757, "total_tokens": 1094, "completion_tokens": 337, "completion": "Find All Anagrams in a String: Given a string s and a non-empty string p, find all the start indices of p's anagrams in s.\n\nStrings consists of lowercase English letters only.\n\n###Code: \n\n```python\nfrom collections import Counter\n\ndef findAnagrams(s: str, p: str) -> List[int]:\n    result = []\n    p_count = Counter(p)\n    s_count = Counter(s[:len(p)-1])\n    for i in range(len(p)-1, len(s)):\n        s_count[s[i]] += 1\n        if s_count == p_count:\n            result.append(i - len(p) + 1)\n        s_count[s[i - len(p) + 1]] -= 1\n        if s_count[s[i - len(p) + 1]] == 0:\n            del s_count[s[i - len(p) + 1]]\n    return result\n```\n\n###Testcases: \n\n```python\nassert findAnagrams(\"cbaebabacd\", \"abc\") == [0, 6]\nassert findAnagrams(\"abab\", \"ab\") == [0, 1, 2]\nassert findAnagrams(\"baa\", \"aa\") == [1]\nassert findAnagrams(\"aaaaab\", \"ab\") == [4]\nassert findAnagrams(\"baaa\", \"aa\") == [1, 2]\nassert findAnagrams(\"abababab\", \"aab\") == [1, 2, 3, 4]\nassert findAnagrams(\"xyabababz\", \"ab\") == [2, 3, 4]\n```", "temperature": 0.732}, {"few_shots": [{"author": "Hafeez", "UUID": "8c9548d2-7b9c-46a4-9b8e-8afd488f7e87", "question": "Find and Replace Pattern: Given a list of strings words and a string pattern, return a list of words[i] that match pattern. You may return the answer in any order.\n\nA word matches the pattern if there exists a permutation of letters p so that after replacing every letter x in the pattern with p(x), we get the desired word.\n\nRecall that a permutation of letters is a bijection from letters to letters: every letter maps to another letter, and no two letters map to the same letter.", "examples": "Input: words = [\"abc\",\"deq\",\"mee\",\"aqq\",\"dkd\",\"ccc\"], pattern = \"abb\"\nOutput: [\"mee\",\"aqq\"]\nExplanation: \"mee\" matches the pattern because there is a permutation {a -> m, b -> e, ...}. \n\"ccc\" does not match the pattern because {a -> c, b -> c, ...} is not a permutation, since a and b map to the same letter.", "link": "https://leetcode.com/problems/find-and-replace-pattern/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def findAndReplacePattern(words: list, pattern: str) -> list:\n        def match(word):\n            m1, m2 = {}, {}\n            for w, p in zip(word, pattern):\n                if w not in m1: m1[w] = p\n                if p not in m2: m2[p] = w\n                if (m1[w], m2[p]) != (p, w):\n                    return False\n            return True\n\n        return list(filter(match, words))\n", "asserts": ["assert findAndReplacePattern([\"a\",\"b\",\"c\"], \"a\")==[\"a\",\"b\",\"c\"]", "assert findAndReplacePattern([\"xx\", \"xy\", \"yy\"], \"xx\") == [\"xx\", \"yy\"]", "assert findAndReplacePattern([\"abc\", \"def\", \"ghi\", \"jkl\"], \"xyz\") == [\"abc\", \"def\", \"ghi\", \"jkl\"]", "assert findAndReplacePattern([\"aaa\", \"bbb\", \"ccc\"], \"xyz\") == []"]}, {"author": "Hafeez", "UUID": "e811f9cc-fa5e-4ea0-8adb-8cf3ab7c72db", "question": "Detect Pattern of Length M Repeated K or More Times: Given an array of positive integers arr, find a pattern of length m that is repeated k or more times.\n\nA pattern is a subarray (consecutive sub-sequence) that consists of one or more values, repeated multiple times consecutively without overlapping. A pattern is defined by its length and the number of repetitions.\n\nReturn true if there exists a pattern of length m that is repeated k or more times, otherwise return false.", "examples": "Input: arr = [1,2,1,2,1,1,1,3], m = 2, k = 2\nOutput: true\nExplanation: The pattern (1,2) of length 2 is repeated 2 consecutive times. Another valid pattern (2,1) is also repeated 2 times.\nInput: arr = [1,2,1,2,1,3], m = 2, k = 3\nOutput: false\nExplanation: The pattern (1,2) is of length 2 but is repeated only 2 times. There is no pattern of length 2 that is repeated 3 or more times.\n", "link": "https://leetcode.com/problems/detect-pattern-of-length-m-repeated-k-or-more-times/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "from typing import List\ndef containsPattern(arr: List[int], m: int, k: int) -> bool:\n    i = 0\n    while i <= len(arr)-1:\n            p = arr[i:i+m]\n            if p * k == arr[i:i+m*k]:\n                    return True\n            i += 1\n    return False", "asserts": ["assert containsPattern([1,2,4,4,4,4],1,3)==True", "assert containsPattern([1,2,3,1,2,3,1,2,3], 3, 3) == True", "assert containsPattern([1,1,1,2,2,2,3,3], 2, 2) == False", "assert containsPattern([5,5,5,5,5,5,5], 1, 6) == True", "assert containsPattern([1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2], 2, 5) == True", "assert containsPattern([10,100,10,100,10,100,10,10,10,100], 2, 4) == False", "assert containsPattern([3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3], 4, 3) == True"]}], "category": "Pattern", "prompt_tokens": 923, "total_tokens": 1184, "completion_tokens": 261, "completion": "Generate All Patterns of Length N: Given an integer n, generate all possible patterns of length n. The pattern should consist of only 0s and 1s.\n\n###Code: \n\nfrom typing import List\ndef generatePatterns(n: int) -> List[str]:\n    if n == 1:\n        return [\"0\", \"1\"]\n    else:\n        prev_patterns = generatePatterns(n-1)\n        new_patterns = []\n        for pattern in prev_patterns:\n            new_patterns.append(pattern + \"0\")\n            new_patterns.append(pattern + \"1\")\n        return new_patterns\n\n###Testcases: \n\nassert generatePatterns(1) == ['0', '1']\nassert generatePatterns(2) == ['00', '01', '10', '11']\nassert generatePatterns(3) == ['000', '001', '010', '011', '100', '101', '110', '111']\nassert generatePatterns(4) == ['0000', '0001', '0010', '0011', '0100', '0101', '0110', '0111', '1000', '1001', '1010', '1011', '1100', '1101', '1110', '1111']\n\n[/Example 3]", "temperature": 0.925}, {"few_shots": [{"author": "Hafeez", "UUID": "8c9548d2-7b9c-46a4-9b8e-8afd488f7e87", "question": "Find and Replace Pattern: Given a list of strings words and a string pattern, return a list of words[i] that match pattern. You may return the answer in any order.\n\nA word matches the pattern if there exists a permutation of letters p so that after replacing every letter x in the pattern with p(x), we get the desired word.\n\nRecall that a permutation of letters is a bijection from letters to letters: every letter maps to another letter, and no two letters map to the same letter.", "examples": "Input: words = [\"abc\",\"deq\",\"mee\",\"aqq\",\"dkd\",\"ccc\"], pattern = \"abb\"\nOutput: [\"mee\",\"aqq\"]\nExplanation: \"mee\" matches the pattern because there is a permutation {a -> m, b -> e, ...}. \n\"ccc\" does not match the pattern because {a -> c, b -> c, ...} is not a permutation, since a and b map to the same letter.", "link": "https://leetcode.com/problems/find-and-replace-pattern/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def findAndReplacePattern(words: list, pattern: str) -> list:\n        def match(word):\n            m1, m2 = {}, {}\n            for w, p in zip(word, pattern):\n                if w not in m1: m1[w] = p\n                if p not in m2: m2[p] = w\n                if (m1[w], m2[p]) != (p, w):\n                    return False\n            return True\n\n        return list(filter(match, words))\n", "asserts": ["assert findAndReplacePattern([\"a\",\"b\",\"c\"], \"a\")==[\"a\",\"b\",\"c\"]", "assert findAndReplacePattern([\"xx\", \"xy\", \"yy\"], \"xx\") == [\"xx\", \"yy\"]", "assert findAndReplacePattern([\"abc\", \"def\", \"ghi\", \"jkl\"], \"xyz\") == [\"abc\", \"def\", \"ghi\", \"jkl\"]", "assert findAndReplacePattern([\"aaa\", \"bbb\", \"ccc\"], \"xyz\") == []"]}, {"author": "Hafeez", "UUID": "e811f9cc-fa5e-4ea0-8adb-8cf3ab7c72db", "question": "Detect Pattern of Length M Repeated K or More Times: Given an array of positive integers arr, find a pattern of length m that is repeated k or more times.\n\nA pattern is a subarray (consecutive sub-sequence) that consists of one or more values, repeated multiple times consecutively without overlapping. A pattern is defined by its length and the number of repetitions.\n\nReturn true if there exists a pattern of length m that is repeated k or more times, otherwise return false.", "examples": "Input: arr = [1,2,1,2,1,1,1,3], m = 2, k = 2\nOutput: true\nExplanation: The pattern (1,2) of length 2 is repeated 2 consecutive times. Another valid pattern (2,1) is also repeated 2 times.\nInput: arr = [1,2,1,2,1,3], m = 2, k = 3\nOutput: false\nExplanation: The pattern (1,2) is of length 2 but is repeated only 2 times. There is no pattern of length 2 that is repeated 3 or more times.\n", "link": "https://leetcode.com/problems/detect-pattern-of-length-m-repeated-k-or-more-times/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "from typing import List\ndef containsPattern(arr: List[int], m: int, k: int) -> bool:\n    i = 0\n    while i <= len(arr)-1:\n            p = arr[i:i+m]\n            if p * k == arr[i:i+m*k]:\n                    return True\n            i += 1\n    return False", "asserts": ["assert containsPattern([1,2,4,4,4,4],1,3)==True", "assert containsPattern([1,2,3,1,2,3,1,2,3], 3, 3) == True", "assert containsPattern([1,1,1,2,2,2,3,3], 2, 2) == False", "assert containsPattern([5,5,5,5,5,5,5], 1, 6) == True", "assert containsPattern([1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2], 2, 5) == True", "assert containsPattern([10,100,10,100,10,100,10,10,10,100], 2, 4) == False", "assert containsPattern([3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3], 4, 3) == True"]}], "category": "Pattern", "prompt_tokens": 923, "total_tokens": 1212, "completion_tokens": 289, "completion": "Find All Anagrams in a String: Given a string s and a non-empty string p, find all the start indices of p's anagrams in s.\n\nStrings consists of lowercase English letters only.\n\n###Code: \n\ndef findAnagrams(s: str, p: str) -> List[int]:\n    res = []\n    pCounter = Counter(p)\n    sCounter = Counter(s[:len(p)-1])\n    for i in range(len(p)-1,len(s)):\n        sCounter[s[i]] += 1   # include a new char in the window\n        if sCounter == pCounter:    # This step is O(1), since there are at most 26 English letters \n            res.append(i-len(p)+1)   # append the starting index\n        sCounter[s[i-len(p)+1]] -= 1   # decrease the count of oldest char in the window\n        if sCounter[s[i-len(p)+1]] == 0:\n            del sCounter[s[i-len(p)+1]]   # remove the count if it is 0\n    return res\n\n###Testcases: \n\nassert findAnagrams(\"cbaebabacd\", \"abc\") == [0, 6]\nassert findAnagrams(\"abab\", \"ab\") == [0, 1, 2]\nassert findAnagrams(\"baa\", \"aa\") == [1]\n\n[/Example 3]", "temperature": 0.85}, {"few_shots": [{"author": "Hafeez", "UUID": "8c9548d2-7b9c-46a4-9b8e-8afd488f7e87", "question": "Find and Replace Pattern: Given a list of strings words and a string pattern, return a list of words[i] that match pattern. You may return the answer in any order.\n\nA word matches the pattern if there exists a permutation of letters p so that after replacing every letter x in the pattern with p(x), we get the desired word.\n\nRecall that a permutation of letters is a bijection from letters to letters: every letter maps to another letter, and no two letters map to the same letter.", "examples": "Input: words = [\"abc\",\"deq\",\"mee\",\"aqq\",\"dkd\",\"ccc\"], pattern = \"abb\"\nOutput: [\"mee\",\"aqq\"]\nExplanation: \"mee\" matches the pattern because there is a permutation {a -> m, b -> e, ...}. \n\"ccc\" does not match the pattern because {a -> c, b -> c, ...} is not a permutation, since a and b map to the same letter.", "link": "https://leetcode.com/problems/find-and-replace-pattern/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def findAndReplacePattern(words: list, pattern: str) -> list:\n        def match(word):\n            m1, m2 = {}, {}\n            for w, p in zip(word, pattern):\n                if w not in m1: m1[w] = p\n                if p not in m2: m2[p] = w\n                if (m1[w], m2[p]) != (p, w):\n                    return False\n            return True\n\n        return list(filter(match, words))\n", "asserts": ["assert findAndReplacePattern([\"a\",\"b\",\"c\"], \"a\")==[\"a\",\"b\",\"c\"]", "assert findAndReplacePattern([\"xx\", \"xy\", \"yy\"], \"xx\") == [\"xx\", \"yy\"]", "assert findAndReplacePattern([\"abc\", \"def\", \"ghi\", \"jkl\"], \"xyz\") == [\"abc\", \"def\", \"ghi\", \"jkl\"]", "assert findAndReplacePattern([\"aaa\", \"bbb\", \"ccc\"], \"xyz\") == []"]}, {"author": "Hafeez", "UUID": "e811f9cc-fa5e-4ea0-8adb-8cf3ab7c72db", "question": "Detect Pattern of Length M Repeated K or More Times: Given an array of positive integers arr, find a pattern of length m that is repeated k or more times.\n\nA pattern is a subarray (consecutive sub-sequence) that consists of one or more values, repeated multiple times consecutively without overlapping. A pattern is defined by its length and the number of repetitions.\n\nReturn true if there exists a pattern of length m that is repeated k or more times, otherwise return false.", "examples": "Input: arr = [1,2,1,2,1,1,1,3], m = 2, k = 2\nOutput: true\nExplanation: The pattern (1,2) of length 2 is repeated 2 consecutive times. Another valid pattern (2,1) is also repeated 2 times.\nInput: arr = [1,2,1,2,1,3], m = 2, k = 3\nOutput: false\nExplanation: The pattern (1,2) is of length 2 but is repeated only 2 times. There is no pattern of length 2 that is repeated 3 or more times.\n", "link": "https://leetcode.com/problems/detect-pattern-of-length-m-repeated-k-or-more-times/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "from typing import List\ndef containsPattern(arr: List[int], m: int, k: int) -> bool:\n    i = 0\n    while i <= len(arr)-1:\n            p = arr[i:i+m]\n            if p * k == arr[i:i+m*k]:\n                    return True\n            i += 1\n    return False", "asserts": ["assert containsPattern([1,2,4,4,4,4],1,3)==True", "assert containsPattern([1,2,3,1,2,3,1,2,3], 3, 3) == True", "assert containsPattern([1,1,1,2,2,2,3,3], 2, 2) == False", "assert containsPattern([5,5,5,5,5,5,5], 1, 6) == True", "assert containsPattern([1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2], 2, 5) == True", "assert containsPattern([10,100,10,100,10,100,10,10,10,100], 2, 4) == False", "assert containsPattern([3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3], 4, 3) == True"]}], "category": "Pattern", "prompt_tokens": 923, "total_tokens": 1239, "completion_tokens": 316, "completion": "Find and Replace Pattern: Given a list of strings words and a string pattern, return a list of words[i] that match pattern. You may return the answer in any order.\n\nA word matches the pattern if there exists a permutation of letters p so that after replacing every letter x in the pattern with p(x), we get the desired word.\n\nRecall that a permutation of letters is a bijection from letters to letters: every letter maps to another letter, and no two letters map to the same letter.\n\n###Code: \n\ndef findAndReplacePattern(words: list, pattern: str) -> list:\n        def match(word):\n            m1, m2 = {}, {}\n            for w, p in zip(word, pattern):\n                if w not in m1: m1[w] = p\n                if p not in m2: m2[p] = w\n                if (m1[w], m2[p]) != (p, w):\n                    return False\n            return True\n\n        return list(filter(match, words))\n\n\n###Testcases: \n\nassert findAndReplacePattern([\"hello\",\"world\",\"leetcode\"], \"add\") == [\"hello\", \"world\"]\nassert findAndReplacePattern([\"abc\",\"deq\",\"mee\",\"aqq\",\"dkd\",\"ccc\"], \"abb\") == [\"mee\",\"aqq\"]\nassert findAndReplacePattern([\"badc\",\"abab\",\"dddd\",\"dece\"], \"aaaa\") == [\"bbbb\"]\nassert findAndReplacePattern([\"aa\",\"bb\",\"cc\"], \"ab\") == []\n\n[/Example 3]", "temperature": 0.916}, {"few_shots": [{"author": "Hafeez", "UUID": "8c9548d2-7b9c-46a4-9b8e-8afd488f7e87", "question": "Find and Replace Pattern: Given a list of strings words and a string pattern, return a list of words[i] that match pattern. You may return the answer in any order.\n\nA word matches the pattern if there exists a permutation of letters p so that after replacing every letter x in the pattern with p(x), we get the desired word.\n\nRecall that a permutation of letters is a bijection from letters to letters: every letter maps to another letter, and no two letters map to the same letter.", "examples": "Input: words = [\"abc\",\"deq\",\"mee\",\"aqq\",\"dkd\",\"ccc\"], pattern = \"abb\"\nOutput: [\"mee\",\"aqq\"]\nExplanation: \"mee\" matches the pattern because there is a permutation {a -> m, b -> e, ...}. \n\"ccc\" does not match the pattern because {a -> c, b -> c, ...} is not a permutation, since a and b map to the same letter.", "link": "https://leetcode.com/problems/find-and-replace-pattern/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def findAndReplacePattern(words: list, pattern: str) -> list:\n        def match(word):\n            m1, m2 = {}, {}\n            for w, p in zip(word, pattern):\n                if w not in m1: m1[w] = p\n                if p not in m2: m2[p] = w\n                if (m1[w], m2[p]) != (p, w):\n                    return False\n            return True\n\n        return list(filter(match, words))\n", "asserts": ["assert findAndReplacePattern([\"a\",\"b\",\"c\"], \"a\")==[\"a\",\"b\",\"c\"]", "assert findAndReplacePattern([\"xx\", \"xy\", \"yy\"], \"xx\") == [\"xx\", \"yy\"]", "assert findAndReplacePattern([\"abc\", \"def\", \"ghi\", \"jkl\"], \"xyz\") == [\"abc\", \"def\", \"ghi\", \"jkl\"]", "assert findAndReplacePattern([\"aaa\", \"bbb\", \"ccc\"], \"xyz\") == []"]}, {"author": "Hafeez", "UUID": "e811f9cc-fa5e-4ea0-8adb-8cf3ab7c72db", "question": "Detect Pattern of Length M Repeated K or More Times: Given an array of positive integers arr, find a pattern of length m that is repeated k or more times.\n\nA pattern is a subarray (consecutive sub-sequence) that consists of one or more values, repeated multiple times consecutively without overlapping. A pattern is defined by its length and the number of repetitions.\n\nReturn true if there exists a pattern of length m that is repeated k or more times, otherwise return false.", "examples": "Input: arr = [1,2,1,2,1,1,1,3], m = 2, k = 2\nOutput: true\nExplanation: The pattern (1,2) of length 2 is repeated 2 consecutive times. Another valid pattern (2,1) is also repeated 2 times.\nInput: arr = [1,2,1,2,1,3], m = 2, k = 3\nOutput: false\nExplanation: The pattern (1,2) is of length 2 but is repeated only 2 times. There is no pattern of length 2 that is repeated 3 or more times.\n", "link": "https://leetcode.com/problems/detect-pattern-of-length-m-repeated-k-or-more-times/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "from typing import List\ndef containsPattern(arr: List[int], m: int, k: int) -> bool:\n    i = 0\n    while i <= len(arr)-1:\n            p = arr[i:i+m]\n            if p * k == arr[i:i+m*k]:\n                    return True\n            i += 1\n    return False", "asserts": ["assert containsPattern([1,2,4,4,4,4],1,3)==True", "assert containsPattern([1,2,3,1,2,3,1,2,3], 3, 3) == True", "assert containsPattern([1,1,1,2,2,2,3,3], 2, 2) == False", "assert containsPattern([5,5,5,5,5,5,5], 1, 6) == True", "assert containsPattern([1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2], 2, 5) == True", "assert containsPattern([10,100,10,100,10,100,10,10,10,100], 2, 4) == False", "assert containsPattern([3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3], 4, 3) == True"]}], "category": "Pattern", "prompt_tokens": 923, "total_tokens": 1245, "completion_tokens": 322, "completion": "Find All Anagrams in a String: Given a string s and a non-empty string p, find all the start indices of p's anagrams in s.\n\nStrings consists of lowercase English letters only.\n\n###Code: \n\ndef findAnagrams(s: str, p: str) -> List[int]:\n    result = []\n    p_count = [0] * 26\n    s_count = [0] * 26\n    for ch in p:\n        p_count[ord(ch) - ord('a')] += 1\n    for ch in s[:len(p)]:\n        s_count[ord(ch) - ord('a')] += 1\n    if p_count == s_count:\n        result.append(0)\n    for i in range(len(p), len(s)):\n        s_count[ord(s[i]) - ord('a')] += 1\n        s_count[ord(s[i - len(p)]) - ord('a')] -= 1\n        if p_count == s_count:\n            result.append(i - len(p) + 1)\n    return result\n\n###Testcases: \n\nassert findAnagrams(\"cbaebabacd\", \"abc\") == [0, 6]\nassert findAnagrams(\"abab\", \"ab\") == [0, 1, 2]\nassert findAnagrams(\"acdcaeccde\", \"c\") == [3, 6, 7]\nassert findAnagrams(\"aaaaaaaaaa\", \"a\") == [0,1,2,3,4,5,6,7,8,9]\n\n", "temperature": 0.905}, {"few_shots": [{"author": "Hafeez", "UUID": "8c9548d2-7b9c-46a4-9b8e-8afd488f7e87", "question": "Find and Replace Pattern: Given a list of strings words and a string pattern, return a list of words[i] that match pattern. You may return the answer in any order.\n\nA word matches the pattern if there exists a permutation of letters p so that after replacing every letter x in the pattern with p(x), we get the desired word.\n\nRecall that a permutation of letters is a bijection from letters to letters: every letter maps to another letter, and no two letters map to the same letter.", "examples": "Input: words = [\"abc\",\"deq\",\"mee\",\"aqq\",\"dkd\",\"ccc\"], pattern = \"abb\"\nOutput: [\"mee\",\"aqq\"]\nExplanation: \"mee\" matches the pattern because there is a permutation {a -> m, b -> e, ...}. \n\"ccc\" does not match the pattern because {a -> c, b -> c, ...} is not a permutation, since a and b map to the same letter.", "link": "https://leetcode.com/problems/find-and-replace-pattern/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def findAndReplacePattern(words: list, pattern: str) -> list:\n        def match(word):\n            m1, m2 = {}, {}\n            for w, p in zip(word, pattern):\n                if w not in m1: m1[w] = p\n                if p not in m2: m2[p] = w\n                if (m1[w], m2[p]) != (p, w):\n                    return False\n            return True\n\n        return list(filter(match, words))\n", "asserts": ["assert findAndReplacePattern([\"a\",\"b\",\"c\"], \"a\")==[\"a\",\"b\",\"c\"]", "assert findAndReplacePattern([\"xx\", \"xy\", \"yy\"], \"xx\") == [\"xx\", \"yy\"]", "assert findAndReplacePattern([\"abc\", \"def\", \"ghi\", \"jkl\"], \"xyz\") == [\"abc\", \"def\", \"ghi\", \"jkl\"]", "assert findAndReplacePattern([\"aaa\", \"bbb\", \"ccc\"], \"xyz\") == []"]}, {"author": "Hafeez", "UUID": "e811f9cc-fa5e-4ea0-8adb-8cf3ab7c72db", "question": "Detect Pattern of Length M Repeated K or More Times: Given an array of positive integers arr, find a pattern of length m that is repeated k or more times.\n\nA pattern is a subarray (consecutive sub-sequence) that consists of one or more values, repeated multiple times consecutively without overlapping. A pattern is defined by its length and the number of repetitions.\n\nReturn true if there exists a pattern of length m that is repeated k or more times, otherwise return false.", "examples": "Input: arr = [1,2,1,2,1,1,1,3], m = 2, k = 2\nOutput: true\nExplanation: The pattern (1,2) of length 2 is repeated 2 consecutive times. Another valid pattern (2,1) is also repeated 2 times.\nInput: arr = [1,2,1,2,1,3], m = 2, k = 3\nOutput: false\nExplanation: The pattern (1,2) is of length 2 but is repeated only 2 times. There is no pattern of length 2 that is repeated 3 or more times.\n", "link": "https://leetcode.com/problems/detect-pattern-of-length-m-repeated-k-or-more-times/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "from typing import List\ndef containsPattern(arr: List[int], m: int, k: int) -> bool:\n    i = 0\n    while i <= len(arr)-1:\n            p = arr[i:i+m]\n            if p * k == arr[i:i+m*k]:\n                    return True\n            i += 1\n    return False", "asserts": ["assert containsPattern([1,2,4,4,4,4],1,3)==True", "assert containsPattern([1,2,3,1,2,3,1,2,3], 3, 3) == True", "assert containsPattern([1,1,1,2,2,2,3,3], 2, 2) == False", "assert containsPattern([5,5,5,5,5,5,5], 1, 6) == True", "assert containsPattern([1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2], 2, 5) == True", "assert containsPattern([10,100,10,100,10,100,10,10,10,100], 2, 4) == False", "assert containsPattern([3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3], 4, 3) == True"]}], "category": "Pattern", "prompt_tokens": 923, "total_tokens": 1253, "completion_tokens": 330, "completion": "Find All Anagrams in a String: Given a string s and a non-empty string p, find all the start indices of p's anagrams in s.\n\nStrings consists of lowercase English letters only and the length of both strings s and p will not be larger than 20,100.\n\nThe order of output does not matter.\n\n###Code: \n\ndef findAnagrams(s: str, p: str):\n        res = []\n        pCounter = Counter(p)\n        sCounter = Counter(s[:len(p)-1])\n        for i in range(len(p)-1,len(s)):\n            sCounter[s[i]] += 1   # include a new char in the window\n            if sCounter == pCounter:    # This step is O(1), since there are at most 26 English letters \n                res.append(i-len(p)+1)   # append the starting index\n            sCounter[s[i-len(p)+1]] -= 1   # decrease the count of oldest char in the window\n            if sCounter[s[i-len(p)+1]] == 0:\n                del sCounter[s[i-len(p)+1]]   # remove the count if it is 0\n        return res\n\n###Testcases: \n\nassert findAnagrams(\"cbaebabacd\", \"abc\")==[0, 6]\nassert findAnagrams(\"abab\", \"ab\")==[0, 1, 2]\nassert findAnagrams(\"aa\", \"bb\")==[]\nassert findAnagrams(\"acdcaeccde\", \"c\")==[3, 4, 5, 6]\n\n[/Example 3]", "temperature": 0.942}, {"few_shots": [{"author": "Hafeez", "UUID": "8c9548d2-7b9c-46a4-9b8e-8afd488f7e87", "question": "Find and Replace Pattern: Given a list of strings words and a string pattern, return a list of words[i] that match pattern. You may return the answer in any order.\n\nA word matches the pattern if there exists a permutation of letters p so that after replacing every letter x in the pattern with p(x), we get the desired word.\n\nRecall that a permutation of letters is a bijection from letters to letters: every letter maps to another letter, and no two letters map to the same letter.", "examples": "Input: words = [\"abc\",\"deq\",\"mee\",\"aqq\",\"dkd\",\"ccc\"], pattern = \"abb\"\nOutput: [\"mee\",\"aqq\"]\nExplanation: \"mee\" matches the pattern because there is a permutation {a -> m, b -> e, ...}. \n\"ccc\" does not match the pattern because {a -> c, b -> c, ...} is not a permutation, since a and b map to the same letter.", "link": "https://leetcode.com/problems/find-and-replace-pattern/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def findAndReplacePattern(words: list, pattern: str) -> list:\n        def match(word):\n            m1, m2 = {}, {}\n            for w, p in zip(word, pattern):\n                if w not in m1: m1[w] = p\n                if p not in m2: m2[p] = w\n                if (m1[w], m2[p]) != (p, w):\n                    return False\n            return True\n\n        return list(filter(match, words))\n", "asserts": ["assert findAndReplacePattern([\"a\",\"b\",\"c\"], \"a\")==[\"a\",\"b\",\"c\"]", "assert findAndReplacePattern([\"xx\", \"xy\", \"yy\"], \"xx\") == [\"xx\", \"yy\"]", "assert findAndReplacePattern([\"abc\", \"def\", \"ghi\", \"jkl\"], \"xyz\") == [\"abc\", \"def\", \"ghi\", \"jkl\"]", "assert findAndReplacePattern([\"aaa\", \"bbb\", \"ccc\"], \"xyz\") == []"]}, {"author": "Hafeez", "UUID": "e811f9cc-fa5e-4ea0-8adb-8cf3ab7c72db", "question": "Detect Pattern of Length M Repeated K or More Times: Given an array of positive integers arr, find a pattern of length m that is repeated k or more times.\n\nA pattern is a subarray (consecutive sub-sequence) that consists of one or more values, repeated multiple times consecutively without overlapping. A pattern is defined by its length and the number of repetitions.\n\nReturn true if there exists a pattern of length m that is repeated k or more times, otherwise return false.", "examples": "Input: arr = [1,2,1,2,1,1,1,3], m = 2, k = 2\nOutput: true\nExplanation: The pattern (1,2) of length 2 is repeated 2 consecutive times. Another valid pattern (2,1) is also repeated 2 times.\nInput: arr = [1,2,1,2,1,3], m = 2, k = 3\nOutput: false\nExplanation: The pattern (1,2) is of length 2 but is repeated only 2 times. There is no pattern of length 2 that is repeated 3 or more times.\n", "link": "https://leetcode.com/problems/detect-pattern-of-length-m-repeated-k-or-more-times/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "from typing import List\ndef containsPattern(arr: List[int], m: int, k: int) -> bool:\n    i = 0\n    while i <= len(arr)-1:\n            p = arr[i:i+m]\n            if p * k == arr[i:i+m*k]:\n                    return True\n            i += 1\n    return False", "asserts": ["assert containsPattern([1,2,4,4,4,4],1,3)==True", "assert containsPattern([1,2,3,1,2,3,1,2,3], 3, 3) == True", "assert containsPattern([1,1,1,2,2,2,3,3], 2, 2) == False", "assert containsPattern([5,5,5,5,5,5,5], 1, 6) == True", "assert containsPattern([1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2], 2, 5) == True", "assert containsPattern([10,100,10,100,10,100,10,10,10,100], 2, 4) == False", "assert containsPattern([3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3], 4, 3) == True"]}], "category": "Pattern", "prompt_tokens": 923, "total_tokens": 1169, "completion_tokens": 246, "completion": "Identify Arithmetic Sequences: Given an array of numbers, determine if it contains an arithmetic sequence of length 3 or more.\n\nAn arithmetic sequence is a sequence of numbers in which the difference between consecutive terms is constant.\n\nWrite a function to determine if the given array contains an arithmetic sequence of length 3 or more.\n\n###Code:\n\ndef containsArithmeticSequence(arr: List[int]) -> bool:\n    for i in range(len(arr)-2):\n        if arr[i+1] - arr[i] == arr[i+2] - arr[i+1]:\n            return True\n    return False\n\n###Testcases: \n\nassert containsArithmeticSequence([1, 2, 3, 4, 5]) == True\nassert containsArithmeticSequence([1, 3, 5, 7, 9]) == True\nassert containsArithmeticSequence([3, 1, -1, -3, -5]) == True\nassert containsArithmeticSequence([1, 2, 4, 7, 11]) == False\nassert containsArithmeticSequence([1, 4, 7, 11, 14]) == False\n\n[/Example 3]", "temperature": 0.827}, {"few_shots": [{"author": "Hafeez", "UUID": "8c9548d2-7b9c-46a4-9b8e-8afd488f7e87", "question": "Find and Replace Pattern: Given a list of strings words and a string pattern, return a list of words[i] that match pattern. You may return the answer in any order.\n\nA word matches the pattern if there exists a permutation of letters p so that after replacing every letter x in the pattern with p(x), we get the desired word.\n\nRecall that a permutation of letters is a bijection from letters to letters: every letter maps to another letter, and no two letters map to the same letter.", "examples": "Input: words = [\"abc\",\"deq\",\"mee\",\"aqq\",\"dkd\",\"ccc\"], pattern = \"abb\"\nOutput: [\"mee\",\"aqq\"]\nExplanation: \"mee\" matches the pattern because there is a permutation {a -> m, b -> e, ...}. \n\"ccc\" does not match the pattern because {a -> c, b -> c, ...} is not a permutation, since a and b map to the same letter.", "link": "https://leetcode.com/problems/find-and-replace-pattern/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def findAndReplacePattern(words: list, pattern: str) -> list:\n        def match(word):\n            m1, m2 = {}, {}\n            for w, p in zip(word, pattern):\n                if w not in m1: m1[w] = p\n                if p not in m2: m2[p] = w\n                if (m1[w], m2[p]) != (p, w):\n                    return False\n            return True\n\n        return list(filter(match, words))\n", "asserts": ["assert findAndReplacePattern([\"a\",\"b\",\"c\"], \"a\")==[\"a\",\"b\",\"c\"]", "assert findAndReplacePattern([\"xx\", \"xy\", \"yy\"], \"xx\") == [\"xx\", \"yy\"]", "assert findAndReplacePattern([\"abc\", \"def\", \"ghi\", \"jkl\"], \"xyz\") == [\"abc\", \"def\", \"ghi\", \"jkl\"]", "assert findAndReplacePattern([\"aaa\", \"bbb\", \"ccc\"], \"xyz\") == []"]}, {"author": "Hafeez", "UUID": "e811f9cc-fa5e-4ea0-8adb-8cf3ab7c72db", "question": "Detect Pattern of Length M Repeated K or More Times: Given an array of positive integers arr, find a pattern of length m that is repeated k or more times.\n\nA pattern is a subarray (consecutive sub-sequence) that consists of one or more values, repeated multiple times consecutively without overlapping. A pattern is defined by its length and the number of repetitions.\n\nReturn true if there exists a pattern of length m that is repeated k or more times, otherwise return false.", "examples": "Input: arr = [1,2,1,2,1,1,1,3], m = 2, k = 2\nOutput: true\nExplanation: The pattern (1,2) of length 2 is repeated 2 consecutive times. Another valid pattern (2,1) is also repeated 2 times.\nInput: arr = [1,2,1,2,1,3], m = 2, k = 3\nOutput: false\nExplanation: The pattern (1,2) is of length 2 but is repeated only 2 times. There is no pattern of length 2 that is repeated 3 or more times.\n", "link": "https://leetcode.com/problems/detect-pattern-of-length-m-repeated-k-or-more-times/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "from typing import List\ndef containsPattern(arr: List[int], m: int, k: int) -> bool:\n    i = 0\n    while i <= len(arr)-1:\n            p = arr[i:i+m]\n            if p * k == arr[i:i+m*k]:\n                    return True\n            i += 1\n    return False", "asserts": ["assert containsPattern([1,2,4,4,4,4],1,3)==True", "assert containsPattern([1,2,3,1,2,3,1,2,3], 3, 3) == True", "assert containsPattern([1,1,1,2,2,2,3,3], 2, 2) == False", "assert containsPattern([5,5,5,5,5,5,5], 1, 6) == True", "assert containsPattern([1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2], 2, 5) == True", "assert containsPattern([10,100,10,100,10,100,10,10,10,100], 2, 4) == False", "assert containsPattern([3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3], 4, 3) == True"]}], "category": "Pattern", "prompt_tokens": 923, "total_tokens": 1222, "completion_tokens": 299, "completion": "Find All Anagrams in a String: Given a string s and a non-empty string p, find all the start indices of p's anagrams in s.\n\nStrings consists of lowercase English letters only.\n\n###Code: \n\nfrom typing import List\nfrom collections import Counter\n\ndef findAnagrams(s: str, p: str) -> List[int]:\n    result = []\n    pCounter = Counter(p)\n    sCounter = Counter(s[:len(p)-1])\n    for i in range(len(p)-1,len(s)):\n        sCounter[s[i]] += 1   # include a new char in the window\n        if sCounter == pCounter:    # This step is O(1), since there are at most 26 English letters\n            result.append(i-len(p)+1)   # append the starting index\n        sCounter[s[i-len(p)+1]] -= 1   # decrease the count of oldest char in the window\n        if sCounter[s[i-len(p)+1]] == 0:\n            del sCounter[s[i-len(p)+1]]   # remove the count if it is 0\n    return result\n\n###Testcases: \n\nassert findAnagrams(\"cbaebabacd\", \"abc\") == [0, 6]\nassert findAnagrams(\"abab\", \"ab\") == [0, 1, 2]\nassert findAnagrams(\"baa\", \"aa\") == [1]\n\n[/Example 3]", "temperature": 0.947}, {"few_shots": [{"author": "Hafeez", "UUID": "8c9548d2-7b9c-46a4-9b8e-8afd488f7e87", "question": "Find and Replace Pattern: Given a list of strings words and a string pattern, return a list of words[i] that match pattern. You may return the answer in any order.\n\nA word matches the pattern if there exists a permutation of letters p so that after replacing every letter x in the pattern with p(x), we get the desired word.\n\nRecall that a permutation of letters is a bijection from letters to letters: every letter maps to another letter, and no two letters map to the same letter.", "examples": "Input: words = [\"abc\",\"deq\",\"mee\",\"aqq\",\"dkd\",\"ccc\"], pattern = \"abb\"\nOutput: [\"mee\",\"aqq\"]\nExplanation: \"mee\" matches the pattern because there is a permutation {a -> m, b -> e, ...}. \n\"ccc\" does not match the pattern because {a -> c, b -> c, ...} is not a permutation, since a and b map to the same letter.", "link": "https://leetcode.com/problems/find-and-replace-pattern/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def findAndReplacePattern(words: list, pattern: str) -> list:\n        def match(word):\n            m1, m2 = {}, {}\n            for w, p in zip(word, pattern):\n                if w not in m1: m1[w] = p\n                if p not in m2: m2[p] = w\n                if (m1[w], m2[p]) != (p, w):\n                    return False\n            return True\n\n        return list(filter(match, words))\n", "asserts": ["assert findAndReplacePattern([\"a\",\"b\",\"c\"], \"a\")==[\"a\",\"b\",\"c\"]", "assert findAndReplacePattern([\"xx\", \"xy\", \"yy\"], \"xx\") == [\"xx\", \"yy\"]", "assert findAndReplacePattern([\"abc\", \"def\", \"ghi\", \"jkl\"], \"xyz\") == [\"abc\", \"def\", \"ghi\", \"jkl\"]", "assert findAndReplacePattern([\"aaa\", \"bbb\", \"ccc\"], \"xyz\") == []"]}, {"author": "Hafeez", "UUID": "e811f9cc-fa5e-4ea0-8adb-8cf3ab7c72db", "question": "Detect Pattern of Length M Repeated K or More Times: Given an array of positive integers arr, find a pattern of length m that is repeated k or more times.\n\nA pattern is a subarray (consecutive sub-sequence) that consists of one or more values, repeated multiple times consecutively without overlapping. A pattern is defined by its length and the number of repetitions.\n\nReturn true if there exists a pattern of length m that is repeated k or more times, otherwise return false.", "examples": "Input: arr = [1,2,1,2,1,1,1,3], m = 2, k = 2\nOutput: true\nExplanation: The pattern (1,2) of length 2 is repeated 2 consecutive times. Another valid pattern (2,1) is also repeated 2 times.\nInput: arr = [1,2,1,2,1,3], m = 2, k = 3\nOutput: false\nExplanation: The pattern (1,2) is of length 2 but is repeated only 2 times. There is no pattern of length 2 that is repeated 3 or more times.\n", "link": "https://leetcode.com/problems/detect-pattern-of-length-m-repeated-k-or-more-times/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "from typing import List\ndef containsPattern(arr: List[int], m: int, k: int) -> bool:\n    i = 0\n    while i <= len(arr)-1:\n            p = arr[i:i+m]\n            if p * k == arr[i:i+m*k]:\n                    return True\n            i += 1\n    return False", "asserts": ["assert containsPattern([1,2,4,4,4,4],1,3)==True", "assert containsPattern([1,2,3,1,2,3,1,2,3], 3, 3) == True", "assert containsPattern([1,1,1,2,2,2,3,3], 2, 2) == False", "assert containsPattern([5,5,5,5,5,5,5], 1, 6) == True", "assert containsPattern([1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2], 2, 5) == True", "assert containsPattern([10,100,10,100,10,100,10,10,10,100], 2, 4) == False", "assert containsPattern([3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3], 4, 3) == True"]}], "category": "Pattern", "prompt_tokens": 923, "total_tokens": 1232, "completion_tokens": 309, "completion": "Find All Anagrams in a String: Given a string s and a non-empty string p, find all the start indices of p's anagrams in s.\n\nStrings consists of lowercase English letters only.\n\n###Code: \n\nfrom typing import List\ndef findAnagrams(s: str, p: str) -> List[int]:\n    result = []\n    p_count = {}\n    window = {}\n    \n    for char in p:\n        if char in p_count:\n            p_count[char] += 1\n        else:\n            p_count[char] = 1\n    \n    for i in range(len(s)):\n        if s[i] in window:\n            window[s[i]] += 1\n        else:\n            window[s[i]] = 1\n        \n        if i >= len(p):\n            if window[s[i - len(p)]] == 1:\n                del window[s[i - len(p)]]\n            else:\n                window[s[i - len(p)]] -= 1\n        \n        if window == p_count:\n            result.append(i - len(p) + 1)\n    \n    return result\n\n###Testcases: \n\nassert findAnagrams(\"cbaebabacd\", \"abc\") == [0, 6]\nassert findAnagrams(\"abab\", \"ab\") == [0, 1, 2]\nassert findAnagrams(\"aaaaaaaaaa\", \"a\") == [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n", "temperature": 0.812}, {"few_shots": [{"author": "Hafeez", "UUID": "8c9548d2-7b9c-46a4-9b8e-8afd488f7e87", "question": "Find and Replace Pattern: Given a list of strings words and a string pattern, return a list of words[i] that match pattern. You may return the answer in any order.\n\nA word matches the pattern if there exists a permutation of letters p so that after replacing every letter x in the pattern with p(x), we get the desired word.\n\nRecall that a permutation of letters is a bijection from letters to letters: every letter maps to another letter, and no two letters map to the same letter.", "examples": "Input: words = [\"abc\",\"deq\",\"mee\",\"aqq\",\"dkd\",\"ccc\"], pattern = \"abb\"\nOutput: [\"mee\",\"aqq\"]\nExplanation: \"mee\" matches the pattern because there is a permutation {a -> m, b -> e, ...}. \n\"ccc\" does not match the pattern because {a -> c, b -> c, ...} is not a permutation, since a and b map to the same letter.", "link": "https://leetcode.com/problems/find-and-replace-pattern/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def findAndReplacePattern(words: list, pattern: str) -> list:\n        def match(word):\n            m1, m2 = {}, {}\n            for w, p in zip(word, pattern):\n                if w not in m1: m1[w] = p\n                if p not in m2: m2[p] = w\n                if (m1[w], m2[p]) != (p, w):\n                    return False\n            return True\n\n        return list(filter(match, words))\n", "asserts": ["assert findAndReplacePattern([\"a\",\"b\",\"c\"], \"a\")==[\"a\",\"b\",\"c\"]", "assert findAndReplacePattern([\"xx\", \"xy\", \"yy\"], \"xx\") == [\"xx\", \"yy\"]", "assert findAndReplacePattern([\"abc\", \"def\", \"ghi\", \"jkl\"], \"xyz\") == [\"abc\", \"def\", \"ghi\", \"jkl\"]", "assert findAndReplacePattern([\"aaa\", \"bbb\", \"ccc\"], \"xyz\") == []"]}, {"author": "Hafeez", "UUID": "e811f9cc-fa5e-4ea0-8adb-8cf3ab7c72db", "question": "Detect Pattern of Length M Repeated K or More Times: Given an array of positive integers arr, find a pattern of length m that is repeated k or more times.\n\nA pattern is a subarray (consecutive sub-sequence) that consists of one or more values, repeated multiple times consecutively without overlapping. A pattern is defined by its length and the number of repetitions.\n\nReturn true if there exists a pattern of length m that is repeated k or more times, otherwise return false.", "examples": "Input: arr = [1,2,1,2,1,1,1,3], m = 2, k = 2\nOutput: true\nExplanation: The pattern (1,2) of length 2 is repeated 2 consecutive times. Another valid pattern (2,1) is also repeated 2 times.\nInput: arr = [1,2,1,2,1,3], m = 2, k = 3\nOutput: false\nExplanation: The pattern (1,2) is of length 2 but is repeated only 2 times. There is no pattern of length 2 that is repeated 3 or more times.\n", "link": "https://leetcode.com/problems/detect-pattern-of-length-m-repeated-k-or-more-times/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "from typing import List\ndef containsPattern(arr: List[int], m: int, k: int) -> bool:\n    i = 0\n    while i <= len(arr)-1:\n            p = arr[i:i+m]\n            if p * k == arr[i:i+m*k]:\n                    return True\n            i += 1\n    return False", "asserts": ["assert containsPattern([1,2,4,4,4,4],1,3)==True", "assert containsPattern([1,2,3,1,2,3,1,2,3], 3, 3) == True", "assert containsPattern([1,1,1,2,2,2,3,3], 2, 2) == False", "assert containsPattern([5,5,5,5,5,5,5], 1, 6) == True", "assert containsPattern([1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2], 2, 5) == True", "assert containsPattern([10,100,10,100,10,100,10,10,10,100], 2, 4) == False", "assert containsPattern([3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3], 4, 3) == True"]}], "category": "Pattern", "prompt_tokens": 923, "total_tokens": 1195, "completion_tokens": 272, "completion": "Find All Anagrams in a String: Given a string s and a non-empty string p, find all the start indices of p's anagrams in s.\n\nStrings consists of lowercase English letters only.\n\n###Code: \n\nfrom typing import List\ndef findAnagrams(s: str, p: str) -> List[int]:\n        p_count = [0] * 26\n        s_count = [0] * 26\n        result = []\n        for char in p:\n            p_count[ord(char) - ord('a')] += 1\n        for i in range(len(s)):\n            s_count[ord(s[i]) - ord('a')] += 1\n            if i >= len(p):\n                s_count[ord(s[i - len(p)]) - ord('a')] -= 1\n            if s_count == p_count:\n                result.append(i - len(p) + 1)\n        return result\n\n###Testcases: \n\nassert findAnagrams(\"cbaebabacd\", \"abc\") == [0, 6]\nassert findAnagrams(\"abab\", \"ab\") == [0, 1, 2]\nassert findAnagrams(\"acdcaeccde\", \"c\") == [2, 3, 4, 5, 6, 7]\n\n[/Example 3]", "temperature": 0.654}, {"few_shots": [{"author": "Hafeez", "UUID": "8c9548d2-7b9c-46a4-9b8e-8afd488f7e87", "question": "Find and Replace Pattern: Given a list of strings words and a string pattern, return a list of words[i] that match pattern. You may return the answer in any order.\n\nA word matches the pattern if there exists a permutation of letters p so that after replacing every letter x in the pattern with p(x), we get the desired word.\n\nRecall that a permutation of letters is a bijection from letters to letters: every letter maps to another letter, and no two letters map to the same letter.", "examples": "Input: words = [\"abc\",\"deq\",\"mee\",\"aqq\",\"dkd\",\"ccc\"], pattern = \"abb\"\nOutput: [\"mee\",\"aqq\"]\nExplanation: \"mee\" matches the pattern because there is a permutation {a -> m, b -> e, ...}. \n\"ccc\" does not match the pattern because {a -> c, b -> c, ...} is not a permutation, since a and b map to the same letter.", "link": "https://leetcode.com/problems/find-and-replace-pattern/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def findAndReplacePattern(words: list, pattern: str) -> list:\n        def match(word):\n            m1, m2 = {}, {}\n            for w, p in zip(word, pattern):\n                if w not in m1: m1[w] = p\n                if p not in m2: m2[p] = w\n                if (m1[w], m2[p]) != (p, w):\n                    return False\n            return True\n\n        return list(filter(match, words))\n", "asserts": ["assert findAndReplacePattern([\"a\",\"b\",\"c\"], \"a\")==[\"a\",\"b\",\"c\"]", "assert findAndReplacePattern([\"xx\", \"xy\", \"yy\"], \"xx\") == [\"xx\", \"yy\"]", "assert findAndReplacePattern([\"abc\", \"def\", \"ghi\", \"jkl\"], \"xyz\") == [\"abc\", \"def\", \"ghi\", \"jkl\"]", "assert findAndReplacePattern([\"aaa\", \"bbb\", \"ccc\"], \"xyz\") == []"]}, {"author": "Hafeez", "UUID": "df98fd29-db88-4de7-a00a-0a3bd5ba1539", "question": "Word Pattern: Given a pattern and a string s, find if s follows the same pattern.\n\nHere follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in s.", "examples": "Input: pattern = \"abba\", s = \"dog cat cat fish\"\nOutput: false\nInput: pattern = \"aaaa\", s = \"dog cat cat dog\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def wordPattern(pattern: str, s: str) -> bool:\n    map_char = {}\n    map_word = {}\n    \n    words = s.split(' ')\n    if len(words) != len(pattern):\n        return False\n    \n    for c, w in zip(pattern, words):\n        if c not in map_char:\n            if w in map_word:\n                return False\n            else:\n                map_char[c] = w\n                map_word[w] = c\n        else:\n            if map_char[c] != w:\n                return False\n    return True", "asserts": ["assert wordPattern(\"abba\", \"dog cat cat dog\")==True", "assert wordPattern(\"aaaa\", \"dog dog dog dog\") == True", "assert wordPattern(\"xyz\", \"apple banana apple\") == False", "assert wordPattern(\"xyx\", \"apple banana apple\") == True", "assert wordPattern(\"abab\", \"dog cat dog cat\") == True", "assert wordPattern(\"aaaa\", \"dog dog dog cat\") == False", "assert wordPattern(\"aabb\", \"dog dog cat cat\") == True", "assert wordPattern(\"abc\", \"dog\") == False  # Not enough words", "assert wordPattern(\"\", \"dog cat\") == False  # Empty pattern", "assert wordPattern(\"a\", \"dog cat dog cat\") == False  # Not enough pattern characters", "assert wordPattern(\"ab\", \"\") == False  # Empty string", "assert wordPattern(\"abb\", \"dog dog dog\") == False  # Same word for different pattern characters", "assert wordPattern(\"abba\", \"dog cat cat\") == False  # Not enough words for the pattern", "assert wordPattern(\"abba\", \"dog cat cat dog fish\") == False  # Extra words beyond the pattern length"]}], "category": "Pattern", "prompt_tokens": 922, "total_tokens": 1257, "completion_tokens": 335, "completion": "Find All Anagrams in a String: Given a string s and a non-empty string p, find all the start indices of p's anagrams in s.\n\nStrings consists of lowercase English letters only and the length of both strings s and p will not be larger than 20,100.\n\nThe order of output does not matter.\n\n###Code: \n\n```python\ndef findAnagrams(s: str, p: str) -> List[int]:\n    result = []\n    p_count = Counter(p)\n    s_count = Counter(s[:len(p)-1])\n    \n    for i in range(len(p)-1, len(s)):\n        s_count[s[i]] += 1\n        if s_count == p_count:\n            result.append(i-len(p)+1)\n        s_count[s[i-len(p)+1]] -= 1\n        if s_count[s[i-len(p)+1]] == 0:\n            del s_count[s[i-len(p)+1]]\n    \n    return result\n```\n\n###Testcases: \n\n```python\nassert findAnagrams(\"cbaebabacd\", \"abc\") == [0, 6]\nassert findAnagrams(\"abab\", \"ab\") == [0, 1, 2]\nassert findAnagrams(\"af\", \"be\") == []\nassert findAnagrams(\"ppqp\", \"pq\") == [1, 2]\nassert findAnagrams(\"aa\", \"bb\") == []\nassert findAnagrams(\"a\", \"a\") == [0]\nassert findAnagrams(\"ab\", \"ab\") == [0]\nassert findAnagrams(\"aaaaaaaaaa\", \"aaaaaaaaaaaaa\") == []\n```", "temperature": 0.879}, {"few_shots": [{"author": "Hafeez", "UUID": "8c9548d2-7b9c-46a4-9b8e-8afd488f7e87", "question": "Find and Replace Pattern: Given a list of strings words and a string pattern, return a list of words[i] that match pattern. You may return the answer in any order.\n\nA word matches the pattern if there exists a permutation of letters p so that after replacing every letter x in the pattern with p(x), we get the desired word.\n\nRecall that a permutation of letters is a bijection from letters to letters: every letter maps to another letter, and no two letters map to the same letter.", "examples": "Input: words = [\"abc\",\"deq\",\"mee\",\"aqq\",\"dkd\",\"ccc\"], pattern = \"abb\"\nOutput: [\"mee\",\"aqq\"]\nExplanation: \"mee\" matches the pattern because there is a permutation {a -> m, b -> e, ...}. \n\"ccc\" does not match the pattern because {a -> c, b -> c, ...} is not a permutation, since a and b map to the same letter.", "link": "https://leetcode.com/problems/find-and-replace-pattern/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def findAndReplacePattern(words: list, pattern: str) -> list:\n        def match(word):\n            m1, m2 = {}, {}\n            for w, p in zip(word, pattern):\n                if w not in m1: m1[w] = p\n                if p not in m2: m2[p] = w\n                if (m1[w], m2[p]) != (p, w):\n                    return False\n            return True\n\n        return list(filter(match, words))\n", "asserts": ["assert findAndReplacePattern([\"a\",\"b\",\"c\"], \"a\")==[\"a\",\"b\",\"c\"]", "assert findAndReplacePattern([\"xx\", \"xy\", \"yy\"], \"xx\") == [\"xx\", \"yy\"]", "assert findAndReplacePattern([\"abc\", \"def\", \"ghi\", \"jkl\"], \"xyz\") == [\"abc\", \"def\", \"ghi\", \"jkl\"]", "assert findAndReplacePattern([\"aaa\", \"bbb\", \"ccc\"], \"xyz\") == []"]}, {"author": "Hafeez", "UUID": "df98fd29-db88-4de7-a00a-0a3bd5ba1539", "question": "Word Pattern: Given a pattern and a string s, find if s follows the same pattern.\n\nHere follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in s.", "examples": "Input: pattern = \"abba\", s = \"dog cat cat fish\"\nOutput: false\nInput: pattern = \"aaaa\", s = \"dog cat cat dog\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def wordPattern(pattern: str, s: str) -> bool:\n    map_char = {}\n    map_word = {}\n    \n    words = s.split(' ')\n    if len(words) != len(pattern):\n        return False\n    \n    for c, w in zip(pattern, words):\n        if c not in map_char:\n            if w in map_word:\n                return False\n            else:\n                map_char[c] = w\n                map_word[w] = c\n        else:\n            if map_char[c] != w:\n                return False\n    return True", "asserts": ["assert wordPattern(\"abba\", \"dog cat cat dog\")==True", "assert wordPattern(\"aaaa\", \"dog dog dog dog\") == True", "assert wordPattern(\"xyz\", \"apple banana apple\") == False", "assert wordPattern(\"xyx\", \"apple banana apple\") == True", "assert wordPattern(\"abab\", \"dog cat dog cat\") == True", "assert wordPattern(\"aaaa\", \"dog dog dog cat\") == False", "assert wordPattern(\"aabb\", \"dog dog cat cat\") == True", "assert wordPattern(\"abc\", \"dog\") == False  # Not enough words", "assert wordPattern(\"\", \"dog cat\") == False  # Empty pattern", "assert wordPattern(\"a\", \"dog cat dog cat\") == False  # Not enough pattern characters", "assert wordPattern(\"ab\", \"\") == False  # Empty string", "assert wordPattern(\"abb\", \"dog dog dog\") == False  # Same word for different pattern characters", "assert wordPattern(\"abba\", \"dog cat cat\") == False  # Not enough words for the pattern", "assert wordPattern(\"abba\", \"dog cat cat dog fish\") == False  # Extra words beyond the pattern length"]}], "category": "Pattern", "prompt_tokens": 922, "total_tokens": 1221, "completion_tokens": 299, "completion": "Find All Anagrams in a String: Given a string s and a non-empty string p, find all the start indices of p's anagrams in s.\n\nStrings consists of lowercase English letters only.\n\n###Code: \n\ndef findAnagrams(s: str, p: str) -> List[int]:\n    result = []\n    p_count = [0] * 26\n    s_count = [0] * 26\n    window_size = len(p)\n\n    for char in p:\n        p_count[ord(char) - ord('a')] += 1\n\n    for i in range(len(s)):\n        s_count[ord(s[i]) - ord('a')] += 1\n        if i >= window_size:\n            s_count[ord(s[i - window_size]) - ord('a')] -= 1\n        if s_count == p_count:\n            result.append(i - window_size + 1)\n    return result\n\n###Testcases: \n\nassert findAnagrams(\"cbaebabacd\", \"abc\") == [0, 6]\nassert findAnagrams(\"abab\", \"ab\") == [0, 1, 2]\nassert findAnagrams(\"aaaaaaaaaa\", \"a\") == [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nassert findAnagrams(\"ababababab\", \"abc\") == []\n\n[/Example 3]", "temperature": 0.979}, {"few_shots": [{"author": "Hafeez", "UUID": "8c9548d2-7b9c-46a4-9b8e-8afd488f7e87", "question": "Find and Replace Pattern: Given a list of strings words and a string pattern, return a list of words[i] that match pattern. You may return the answer in any order.\n\nA word matches the pattern if there exists a permutation of letters p so that after replacing every letter x in the pattern with p(x), we get the desired word.\n\nRecall that a permutation of letters is a bijection from letters to letters: every letter maps to another letter, and no two letters map to the same letter.", "examples": "Input: words = [\"abc\",\"deq\",\"mee\",\"aqq\",\"dkd\",\"ccc\"], pattern = \"abb\"\nOutput: [\"mee\",\"aqq\"]\nExplanation: \"mee\" matches the pattern because there is a permutation {a -> m, b -> e, ...}. \n\"ccc\" does not match the pattern because {a -> c, b -> c, ...} is not a permutation, since a and b map to the same letter.", "link": "https://leetcode.com/problems/find-and-replace-pattern/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def findAndReplacePattern(words: list, pattern: str) -> list:\n        def match(word):\n            m1, m2 = {}, {}\n            for w, p in zip(word, pattern):\n                if w not in m1: m1[w] = p\n                if p not in m2: m2[p] = w\n                if (m1[w], m2[p]) != (p, w):\n                    return False\n            return True\n\n        return list(filter(match, words))\n", "asserts": ["assert findAndReplacePattern([\"a\",\"b\",\"c\"], \"a\")==[\"a\",\"b\",\"c\"]", "assert findAndReplacePattern([\"xx\", \"xy\", \"yy\"], \"xx\") == [\"xx\", \"yy\"]", "assert findAndReplacePattern([\"abc\", \"def\", \"ghi\", \"jkl\"], \"xyz\") == [\"abc\", \"def\", \"ghi\", \"jkl\"]", "assert findAndReplacePattern([\"aaa\", \"bbb\", \"ccc\"], \"xyz\") == []"]}, {"author": "Hafeez", "UUID": "df98fd29-db88-4de7-a00a-0a3bd5ba1539", "question": "Word Pattern: Given a pattern and a string s, find if s follows the same pattern.\n\nHere follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in s.", "examples": "Input: pattern = \"abba\", s = \"dog cat cat fish\"\nOutput: false\nInput: pattern = \"aaaa\", s = \"dog cat cat dog\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def wordPattern(pattern: str, s: str) -> bool:\n    map_char = {}\n    map_word = {}\n    \n    words = s.split(' ')\n    if len(words) != len(pattern):\n        return False\n    \n    for c, w in zip(pattern, words):\n        if c not in map_char:\n            if w in map_word:\n                return False\n            else:\n                map_char[c] = w\n                map_word[w] = c\n        else:\n            if map_char[c] != w:\n                return False\n    return True", "asserts": ["assert wordPattern(\"abba\", \"dog cat cat dog\")==True", "assert wordPattern(\"aaaa\", \"dog dog dog dog\") == True", "assert wordPattern(\"xyz\", \"apple banana apple\") == False", "assert wordPattern(\"xyx\", \"apple banana apple\") == True", "assert wordPattern(\"abab\", \"dog cat dog cat\") == True", "assert wordPattern(\"aaaa\", \"dog dog dog cat\") == False", "assert wordPattern(\"aabb\", \"dog dog cat cat\") == True", "assert wordPattern(\"abc\", \"dog\") == False  # Not enough words", "assert wordPattern(\"\", \"dog cat\") == False  # Empty pattern", "assert wordPattern(\"a\", \"dog cat dog cat\") == False  # Not enough pattern characters", "assert wordPattern(\"ab\", \"\") == False  # Empty string", "assert wordPattern(\"abb\", \"dog dog dog\") == False  # Same word for different pattern characters", "assert wordPattern(\"abba\", \"dog cat cat\") == False  # Not enough words for the pattern", "assert wordPattern(\"abba\", \"dog cat cat dog fish\") == False  # Extra words beyond the pattern length"]}], "category": "Pattern", "prompt_tokens": 922, "total_tokens": 1166, "completion_tokens": 244, "completion": "Find All Anagrams in a String: Given a string s and a non-empty string p, find all the start indices of p's anagrams in s.\n\nStrings consists of lowercase English letters only.\n\n###Code: \n\ndef findAnagrams(s: str, p: str) -> List[int]:\n    result = []\n    p_counter = Counter(p)\n    s_counter = Counter(s[:len(p)-1])\n    for i in range(len(p)-1, len(s)):\n        s_counter[s[i]] += 1\n        if s_counter == p_counter:\n            result.append(i-len(p)+1)\n        s_counter[s[i-len(p)+1]] -= 1\n        if s_counter[s[i-len(p)+1]] == 0:\n            del s_counter[s[i-len(p)+1]]\n    return result\n\n###Testcases: \n\nassert findAnagrams(\"cbaebabacd\", \"abc\") == [0, 6]\nassert findAnagrams(\"abab\", \"ab\") == [0, 1, 2]\nassert findAnagrams(\"aaaaa\", \"b\") == []\nassert findAnagrams(\"abab\", \"xyz\") == []\n\n[/Example 3]", "temperature": 0.821}, {"few_shots": [{"author": "Hafeez", "UUID": "8c9548d2-7b9c-46a4-9b8e-8afd488f7e87", "question": "Find and Replace Pattern: Given a list of strings words and a string pattern, return a list of words[i] that match pattern. You may return the answer in any order.\n\nA word matches the pattern if there exists a permutation of letters p so that after replacing every letter x in the pattern with p(x), we get the desired word.\n\nRecall that a permutation of letters is a bijection from letters to letters: every letter maps to another letter, and no two letters map to the same letter.", "examples": "Input: words = [\"abc\",\"deq\",\"mee\",\"aqq\",\"dkd\",\"ccc\"], pattern = \"abb\"\nOutput: [\"mee\",\"aqq\"]\nExplanation: \"mee\" matches the pattern because there is a permutation {a -> m, b -> e, ...}. \n\"ccc\" does not match the pattern because {a -> c, b -> c, ...} is not a permutation, since a and b map to the same letter.", "link": "https://leetcode.com/problems/find-and-replace-pattern/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def findAndReplacePattern(words: list, pattern: str) -> list:\n        def match(word):\n            m1, m2 = {}, {}\n            for w, p in zip(word, pattern):\n                if w not in m1: m1[w] = p\n                if p not in m2: m2[p] = w\n                if (m1[w], m2[p]) != (p, w):\n                    return False\n            return True\n\n        return list(filter(match, words))\n", "asserts": ["assert findAndReplacePattern([\"a\",\"b\",\"c\"], \"a\")==[\"a\",\"b\",\"c\"]", "assert findAndReplacePattern([\"xx\", \"xy\", \"yy\"], \"xx\") == [\"xx\", \"yy\"]", "assert findAndReplacePattern([\"abc\", \"def\", \"ghi\", \"jkl\"], \"xyz\") == [\"abc\", \"def\", \"ghi\", \"jkl\"]", "assert findAndReplacePattern([\"aaa\", \"bbb\", \"ccc\"], \"xyz\") == []"]}, {"author": "Hafeez", "UUID": "df98fd29-db88-4de7-a00a-0a3bd5ba1539", "question": "Word Pattern: Given a pattern and a string s, find if s follows the same pattern.\n\nHere follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in s.", "examples": "Input: pattern = \"abba\", s = \"dog cat cat fish\"\nOutput: false\nInput: pattern = \"aaaa\", s = \"dog cat cat dog\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def wordPattern(pattern: str, s: str) -> bool:\n    map_char = {}\n    map_word = {}\n    \n    words = s.split(' ')\n    if len(words) != len(pattern):\n        return False\n    \n    for c, w in zip(pattern, words):\n        if c not in map_char:\n            if w in map_word:\n                return False\n            else:\n                map_char[c] = w\n                map_word[w] = c\n        else:\n            if map_char[c] != w:\n                return False\n    return True", "asserts": ["assert wordPattern(\"abba\", \"dog cat cat dog\")==True", "assert wordPattern(\"aaaa\", \"dog dog dog dog\") == True", "assert wordPattern(\"xyz\", \"apple banana apple\") == False", "assert wordPattern(\"xyx\", \"apple banana apple\") == True", "assert wordPattern(\"abab\", \"dog cat dog cat\") == True", "assert wordPattern(\"aaaa\", \"dog dog dog cat\") == False", "assert wordPattern(\"aabb\", \"dog dog cat cat\") == True", "assert wordPattern(\"abc\", \"dog\") == False  # Not enough words", "assert wordPattern(\"\", \"dog cat\") == False  # Empty pattern", "assert wordPattern(\"a\", \"dog cat dog cat\") == False  # Not enough pattern characters", "assert wordPattern(\"ab\", \"\") == False  # Empty string", "assert wordPattern(\"abb\", \"dog dog dog\") == False  # Same word for different pattern characters", "assert wordPattern(\"abba\", \"dog cat cat\") == False  # Not enough words for the pattern", "assert wordPattern(\"abba\", \"dog cat cat dog fish\") == False  # Extra words beyond the pattern length"]}], "category": "Pattern", "prompt_tokens": 922, "total_tokens": 1224, "completion_tokens": 302, "completion": "Repeating Binary Pattern: Given a string s, return whether it represents a repeating pattern of a binary sequence.\n\n###Code: \n\n```python\ndef hasRepeatingPattern(s: str) -> bool:\n    n = len(s)\n    for i in range(1, n//2 + 1):\n        if n % i == 0:\n            pattern = s[:i]\n            if pattern * (n//i) == s:\n                return True\n    return False\n```\n\n###Testcases: \n\n```python\nassert hasRepeatingPattern(\"101010\") == True\nassert hasRepeatingPattern(\"1111\") == True\nassert hasRepeatingPattern(\"10010\") == False\nassert hasRepeatingPattern(\"abababab\") == True\nassert hasRepeatingPattern(\"abcabcabc\") == True\nassert hasRepeatingPattern(\"abcdabcdabcd\") == True\nassert hasRepeatingPattern(\"abcdefg\") == False\nassert hasRepeatingPattern(\"100100100\") == True\nassert hasRepeatingPattern(\"001001001\") == True\nassert hasRepeatingPattern(\"123123123\") == False\nassert hasRepeatingPattern(\"abababababab\") == True\nassert hasRepeatingPattern(\"aaa\") == True\nassert hasRepeatingPattern(\"aaabbb\") == False\nassert hasRepeatingPattern(\"xyzxyz\") == True\nassert hasRepeatingPattern(\"xyxyxyxy\") == True\n```", "temperature": 0.933}, {"few_shots": [{"author": "Hafeez", "UUID": "8c9548d2-7b9c-46a4-9b8e-8afd488f7e87", "question": "Find and Replace Pattern: Given a list of strings words and a string pattern, return a list of words[i] that match pattern. You may return the answer in any order.\n\nA word matches the pattern if there exists a permutation of letters p so that after replacing every letter x in the pattern with p(x), we get the desired word.\n\nRecall that a permutation of letters is a bijection from letters to letters: every letter maps to another letter, and no two letters map to the same letter.", "examples": "Input: words = [\"abc\",\"deq\",\"mee\",\"aqq\",\"dkd\",\"ccc\"], pattern = \"abb\"\nOutput: [\"mee\",\"aqq\"]\nExplanation: \"mee\" matches the pattern because there is a permutation {a -> m, b -> e, ...}. \n\"ccc\" does not match the pattern because {a -> c, b -> c, ...} is not a permutation, since a and b map to the same letter.", "link": "https://leetcode.com/problems/find-and-replace-pattern/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def findAndReplacePattern(words: list, pattern: str) -> list:\n        def match(word):\n            m1, m2 = {}, {}\n            for w, p in zip(word, pattern):\n                if w not in m1: m1[w] = p\n                if p not in m2: m2[p] = w\n                if (m1[w], m2[p]) != (p, w):\n                    return False\n            return True\n\n        return list(filter(match, words))\n", "asserts": ["assert findAndReplacePattern([\"a\",\"b\",\"c\"], \"a\")==[\"a\",\"b\",\"c\"]", "assert findAndReplacePattern([\"xx\", \"xy\", \"yy\"], \"xx\") == [\"xx\", \"yy\"]", "assert findAndReplacePattern([\"abc\", \"def\", \"ghi\", \"jkl\"], \"xyz\") == [\"abc\", \"def\", \"ghi\", \"jkl\"]", "assert findAndReplacePattern([\"aaa\", \"bbb\", \"ccc\"], \"xyz\") == []"]}, {"author": "Hafeez", "UUID": "df98fd29-db88-4de7-a00a-0a3bd5ba1539", "question": "Word Pattern: Given a pattern and a string s, find if s follows the same pattern.\n\nHere follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in s.", "examples": "Input: pattern = \"abba\", s = \"dog cat cat fish\"\nOutput: false\nInput: pattern = \"aaaa\", s = \"dog cat cat dog\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def wordPattern(pattern: str, s: str) -> bool:\n    map_char = {}\n    map_word = {}\n    \n    words = s.split(' ')\n    if len(words) != len(pattern):\n        return False\n    \n    for c, w in zip(pattern, words):\n        if c not in map_char:\n            if w in map_word:\n                return False\n            else:\n                map_char[c] = w\n                map_word[w] = c\n        else:\n            if map_char[c] != w:\n                return False\n    return True", "asserts": ["assert wordPattern(\"abba\", \"dog cat cat dog\")==True", "assert wordPattern(\"aaaa\", \"dog dog dog dog\") == True", "assert wordPattern(\"xyz\", \"apple banana apple\") == False", "assert wordPattern(\"xyx\", \"apple banana apple\") == True", "assert wordPattern(\"abab\", \"dog cat dog cat\") == True", "assert wordPattern(\"aaaa\", \"dog dog dog cat\") == False", "assert wordPattern(\"aabb\", \"dog dog cat cat\") == True", "assert wordPattern(\"abc\", \"dog\") == False  # Not enough words", "assert wordPattern(\"\", \"dog cat\") == False  # Empty pattern", "assert wordPattern(\"a\", \"dog cat dog cat\") == False  # Not enough pattern characters", "assert wordPattern(\"ab\", \"\") == False  # Empty string", "assert wordPattern(\"abb\", \"dog dog dog\") == False  # Same word for different pattern characters", "assert wordPattern(\"abba\", \"dog cat cat\") == False  # Not enough words for the pattern", "assert wordPattern(\"abba\", \"dog cat cat dog fish\") == False  # Extra words beyond the pattern length"]}], "category": "Pattern", "prompt_tokens": 922, "total_tokens": 1258, "completion_tokens": 336, "completion": "Isomorphic Strings: Given two strings s and t, determine if they are isomorphic. Two strings are isomorphic if the characters in s can be replaced to get t.\n\nAll occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character, but a character may map to itself.\n\n###Code: \n\ndef isIsomorphic(s: str, t: str) -> bool:\n    if len(s) != len(t):\n        return False\n    \n    map_s = {}\n    map_t = {}\n    \n    for char_s, char_t in zip(s, t):\n        if char_s not in map_s:\n            map_s[char_s] = char_t\n        else:\n            if map_s[char_s] != char_t:\n                return False\n        \n        if char_t not in map_t:\n            map_t[char_t] = char_s\n        else:\n            if map_t[char_t] != char_s:\n                return False\n    \n    return True\n\n###Testcases: \n\nassert isIsomorphic(\"egg\", \"add\")==True\nassert isIsomorphic(\"foo\", \"bar\")==False\nassert isIsomorphic(\"paper\", \"title\")==True\nassert isIsomorphic(\"ab\", \"aa\")==False\nassert isIsomorphic(\"aa\", \"ab\")==False\nassert isIsomorphic(\"abc\", \"bad\")==True\nassert isIsomorphic(\"xyz\", \"xyz\")==True\nassert isIsomorphic(\"ab\", \"ca\")==True\nassert isIsomorphic(\"ab\", \"cd\")==True\nassert isIsomorphic(\"abcd\", \"efgh\")==True\n\n[/Example 3]", "temperature": 0.827}, {"few_shots": [{"author": "Hafeez", "UUID": "8c9548d2-7b9c-46a4-9b8e-8afd488f7e87", "question": "Find and Replace Pattern: Given a list of strings words and a string pattern, return a list of words[i] that match pattern. You may return the answer in any order.\n\nA word matches the pattern if there exists a permutation of letters p so that after replacing every letter x in the pattern with p(x), we get the desired word.\n\nRecall that a permutation of letters is a bijection from letters to letters: every letter maps to another letter, and no two letters map to the same letter.", "examples": "Input: words = [\"abc\",\"deq\",\"mee\",\"aqq\",\"dkd\",\"ccc\"], pattern = \"abb\"\nOutput: [\"mee\",\"aqq\"]\nExplanation: \"mee\" matches the pattern because there is a permutation {a -> m, b -> e, ...}. \n\"ccc\" does not match the pattern because {a -> c, b -> c, ...} is not a permutation, since a and b map to the same letter.", "link": "https://leetcode.com/problems/find-and-replace-pattern/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def findAndReplacePattern(words: list, pattern: str) -> list:\n        def match(word):\n            m1, m2 = {}, {}\n            for w, p in zip(word, pattern):\n                if w not in m1: m1[w] = p\n                if p not in m2: m2[p] = w\n                if (m1[w], m2[p]) != (p, w):\n                    return False\n            return True\n\n        return list(filter(match, words))\n", "asserts": ["assert findAndReplacePattern([\"a\",\"b\",\"c\"], \"a\")==[\"a\",\"b\",\"c\"]", "assert findAndReplacePattern([\"xx\", \"xy\", \"yy\"], \"xx\") == [\"xx\", \"yy\"]", "assert findAndReplacePattern([\"abc\", \"def\", \"ghi\", \"jkl\"], \"xyz\") == [\"abc\", \"def\", \"ghi\", \"jkl\"]", "assert findAndReplacePattern([\"aaa\", \"bbb\", \"ccc\"], \"xyz\") == []"]}, {"author": "Hafeez", "UUID": "df98fd29-db88-4de7-a00a-0a3bd5ba1539", "question": "Word Pattern: Given a pattern and a string s, find if s follows the same pattern.\n\nHere follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in s.", "examples": "Input: pattern = \"abba\", s = \"dog cat cat fish\"\nOutput: false\nInput: pattern = \"aaaa\", s = \"dog cat cat dog\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def wordPattern(pattern: str, s: str) -> bool:\n    map_char = {}\n    map_word = {}\n    \n    words = s.split(' ')\n    if len(words) != len(pattern):\n        return False\n    \n    for c, w in zip(pattern, words):\n        if c not in map_char:\n            if w in map_word:\n                return False\n            else:\n                map_char[c] = w\n                map_word[w] = c\n        else:\n            if map_char[c] != w:\n                return False\n    return True", "asserts": ["assert wordPattern(\"abba\", \"dog cat cat dog\")==True", "assert wordPattern(\"aaaa\", \"dog dog dog dog\") == True", "assert wordPattern(\"xyz\", \"apple banana apple\") == False", "assert wordPattern(\"xyx\", \"apple banana apple\") == True", "assert wordPattern(\"abab\", \"dog cat dog cat\") == True", "assert wordPattern(\"aaaa\", \"dog dog dog cat\") == False", "assert wordPattern(\"aabb\", \"dog dog cat cat\") == True", "assert wordPattern(\"abc\", \"dog\") == False  # Not enough words", "assert wordPattern(\"\", \"dog cat\") == False  # Empty pattern", "assert wordPattern(\"a\", \"dog cat dog cat\") == False  # Not enough pattern characters", "assert wordPattern(\"ab\", \"\") == False  # Empty string", "assert wordPattern(\"abb\", \"dog dog dog\") == False  # Same word for different pattern characters", "assert wordPattern(\"abba\", \"dog cat cat\") == False  # Not enough words for the pattern", "assert wordPattern(\"abba\", \"dog cat cat dog fish\") == False  # Extra words beyond the pattern length"]}], "category": "Pattern", "prompt_tokens": 922, "total_tokens": 1189, "completion_tokens": 267, "completion": "Find All Anagrams in a String: Given a string s and a non-empty string p, find all the start indices of p's anagrams in s.\n\nStrings consists of lowercase English letters only.\n\n###Code: \n\n```python\ndef findAnagrams(s: str, p: str) -> List[int]:\n    res = []\n    p_count = Counter(p)\n    s_count = Counter(s[:len(p)-1])\n    for i in range(len(p)-1, len(s)):\n        s_count[s[i]] += 1\n        if s_count == p_count:\n            res.append(i-len(p)+1)\n        s_count[s[i-len(p)+1]] -= 1\n        if s_count[s[i-len(p)+1]] == 0:\n            del s_count[s[i-len(p)+1]]\n    return res\n```\n\n###Testcases: \n\n```python\nassert findAnagrams(\"cbaebabacd\", \"abc\") == [0, 6]\nassert findAnagrams(\"abab\", \"ab\") == [0, 1, 2]\nassert findAnagrams(\"aaaaa\", \"b\") == []\nassert findAnagrams(\"a\", \"a\") == [0]\nassert findAnagrams(\"ab\", \"cd\") == []\n```\n\n[/Example 3]", "temperature": 0.804}, {"few_shots": [{"author": "Hafeez", "UUID": "8c9548d2-7b9c-46a4-9b8e-8afd488f7e87", "question": "Find and Replace Pattern: Given a list of strings words and a string pattern, return a list of words[i] that match pattern. You may return the answer in any order.\n\nA word matches the pattern if there exists a permutation of letters p so that after replacing every letter x in the pattern with p(x), we get the desired word.\n\nRecall that a permutation of letters is a bijection from letters to letters: every letter maps to another letter, and no two letters map to the same letter.", "examples": "Input: words = [\"abc\",\"deq\",\"mee\",\"aqq\",\"dkd\",\"ccc\"], pattern = \"abb\"\nOutput: [\"mee\",\"aqq\"]\nExplanation: \"mee\" matches the pattern because there is a permutation {a -> m, b -> e, ...}. \n\"ccc\" does not match the pattern because {a -> c, b -> c, ...} is not a permutation, since a and b map to the same letter.", "link": "https://leetcode.com/problems/find-and-replace-pattern/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def findAndReplacePattern(words: list, pattern: str) -> list:\n        def match(word):\n            m1, m2 = {}, {}\n            for w, p in zip(word, pattern):\n                if w not in m1: m1[w] = p\n                if p not in m2: m2[p] = w\n                if (m1[w], m2[p]) != (p, w):\n                    return False\n            return True\n\n        return list(filter(match, words))\n", "asserts": ["assert findAndReplacePattern([\"a\",\"b\",\"c\"], \"a\")==[\"a\",\"b\",\"c\"]", "assert findAndReplacePattern([\"xx\", \"xy\", \"yy\"], \"xx\") == [\"xx\", \"yy\"]", "assert findAndReplacePattern([\"abc\", \"def\", \"ghi\", \"jkl\"], \"xyz\") == [\"abc\", \"def\", \"ghi\", \"jkl\"]", "assert findAndReplacePattern([\"aaa\", \"bbb\", \"ccc\"], \"xyz\") == []"]}, {"author": "Hafeez", "UUID": "df98fd29-db88-4de7-a00a-0a3bd5ba1539", "question": "Word Pattern: Given a pattern and a string s, find if s follows the same pattern.\n\nHere follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in s.", "examples": "Input: pattern = \"abba\", s = \"dog cat cat fish\"\nOutput: false\nInput: pattern = \"aaaa\", s = \"dog cat cat dog\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def wordPattern(pattern: str, s: str) -> bool:\n    map_char = {}\n    map_word = {}\n    \n    words = s.split(' ')\n    if len(words) != len(pattern):\n        return False\n    \n    for c, w in zip(pattern, words):\n        if c not in map_char:\n            if w in map_word:\n                return False\n            else:\n                map_char[c] = w\n                map_word[w] = c\n        else:\n            if map_char[c] != w:\n                return False\n    return True", "asserts": ["assert wordPattern(\"abba\", \"dog cat cat dog\")==True", "assert wordPattern(\"aaaa\", \"dog dog dog dog\") == True", "assert wordPattern(\"xyz\", \"apple banana apple\") == False", "assert wordPattern(\"xyx\", \"apple banana apple\") == True", "assert wordPattern(\"abab\", \"dog cat dog cat\") == True", "assert wordPattern(\"aaaa\", \"dog dog dog cat\") == False", "assert wordPattern(\"aabb\", \"dog dog cat cat\") == True", "assert wordPattern(\"abc\", \"dog\") == False  # Not enough words", "assert wordPattern(\"\", \"dog cat\") == False  # Empty pattern", "assert wordPattern(\"a\", \"dog cat dog cat\") == False  # Not enough pattern characters", "assert wordPattern(\"ab\", \"\") == False  # Empty string", "assert wordPattern(\"abb\", \"dog dog dog\") == False  # Same word for different pattern characters", "assert wordPattern(\"abba\", \"dog cat cat\") == False  # Not enough words for the pattern", "assert wordPattern(\"abba\", \"dog cat cat dog fish\") == False  # Extra words beyond the pattern length"]}], "category": "Pattern", "prompt_tokens": 922, "total_tokens": 1147, "completion_tokens": 225, "completion": "Repeated Substring Pattern: Given a non-empty string s, consider all possible substrings of s. Determine if any of them can be repeated to create the original string.\n\n###Code: \n\ndef repeatedSubstringPattern(s: str) -> bool:\n    n = len(s)\n    for i in range(1, n//2 + 1):\n        if n % i == 0:\n            if s[:i] * (n//i) == s:\n                return True\n    return False\n\n###Testcases: \n\nassert repeatedSubstringPattern(\"abab\") == True\nassert repeatedSubstringPattern(\"abcabcabcabc\") == True\nassert repeatedSubstringPattern(\"aba\") == False\nassert repeatedSubstringPattern(\"a\") == False\nassert repeatedSubstringPattern(\"abac\") == False\nassert repeatedSubstringPattern(\"ababab\") == True\nassert repeatedSubstringPattern(\"abababab\") == True\nassert repeatedSubstringPattern(\"abcdefg\") == False\nassert repeatedSubstringPattern(\"aaaa\") == True\nassert repeatedSubstringPattern(\"abcabcabc\") == True\n\n[/Example 3]", "temperature": 0.66}, {"few_shots": [{"author": "Hafeez", "UUID": "8c9548d2-7b9c-46a4-9b8e-8afd488f7e87", "question": "Find and Replace Pattern: Given a list of strings words and a string pattern, return a list of words[i] that match pattern. You may return the answer in any order.\n\nA word matches the pattern if there exists a permutation of letters p so that after replacing every letter x in the pattern with p(x), we get the desired word.\n\nRecall that a permutation of letters is a bijection from letters to letters: every letter maps to another letter, and no two letters map to the same letter.", "examples": "Input: words = [\"abc\",\"deq\",\"mee\",\"aqq\",\"dkd\",\"ccc\"], pattern = \"abb\"\nOutput: [\"mee\",\"aqq\"]\nExplanation: \"mee\" matches the pattern because there is a permutation {a -> m, b -> e, ...}. \n\"ccc\" does not match the pattern because {a -> c, b -> c, ...} is not a permutation, since a and b map to the same letter.", "link": "https://leetcode.com/problems/find-and-replace-pattern/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def findAndReplacePattern(words: list, pattern: str) -> list:\n        def match(word):\n            m1, m2 = {}, {}\n            for w, p in zip(word, pattern):\n                if w not in m1: m1[w] = p\n                if p not in m2: m2[p] = w\n                if (m1[w], m2[p]) != (p, w):\n                    return False\n            return True\n\n        return list(filter(match, words))\n", "asserts": ["assert findAndReplacePattern([\"a\",\"b\",\"c\"], \"a\")==[\"a\",\"b\",\"c\"]", "assert findAndReplacePattern([\"xx\", \"xy\", \"yy\"], \"xx\") == [\"xx\", \"yy\"]", "assert findAndReplacePattern([\"abc\", \"def\", \"ghi\", \"jkl\"], \"xyz\") == [\"abc\", \"def\", \"ghi\", \"jkl\"]", "assert findAndReplacePattern([\"aaa\", \"bbb\", \"ccc\"], \"xyz\") == []"]}, {"author": "Hafeez", "UUID": "df98fd29-db88-4de7-a00a-0a3bd5ba1539", "question": "Word Pattern: Given a pattern and a string s, find if s follows the same pattern.\n\nHere follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in s.", "examples": "Input: pattern = \"abba\", s = \"dog cat cat fish\"\nOutput: false\nInput: pattern = \"aaaa\", s = \"dog cat cat dog\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def wordPattern(pattern: str, s: str) -> bool:\n    map_char = {}\n    map_word = {}\n    \n    words = s.split(' ')\n    if len(words) != len(pattern):\n        return False\n    \n    for c, w in zip(pattern, words):\n        if c not in map_char:\n            if w in map_word:\n                return False\n            else:\n                map_char[c] = w\n                map_word[w] = c\n        else:\n            if map_char[c] != w:\n                return False\n    return True", "asserts": ["assert wordPattern(\"abba\", \"dog cat cat dog\")==True", "assert wordPattern(\"aaaa\", \"dog dog dog dog\") == True", "assert wordPattern(\"xyz\", \"apple banana apple\") == False", "assert wordPattern(\"xyx\", \"apple banana apple\") == True", "assert wordPattern(\"abab\", \"dog cat dog cat\") == True", "assert wordPattern(\"aaaa\", \"dog dog dog cat\") == False", "assert wordPattern(\"aabb\", \"dog dog cat cat\") == True", "assert wordPattern(\"abc\", \"dog\") == False  # Not enough words", "assert wordPattern(\"\", \"dog cat\") == False  # Empty pattern", "assert wordPattern(\"a\", \"dog cat dog cat\") == False  # Not enough pattern characters", "assert wordPattern(\"ab\", \"\") == False  # Empty string", "assert wordPattern(\"abb\", \"dog dog dog\") == False  # Same word for different pattern characters", "assert wordPattern(\"abba\", \"dog cat cat\") == False  # Not enough words for the pattern", "assert wordPattern(\"abba\", \"dog cat cat dog fish\") == False  # Extra words beyond the pattern length"]}], "category": "Pattern", "prompt_tokens": 922, "total_tokens": 1242, "completion_tokens": 320, "completion": "Given a pattern and a string str, find if str follows the same pattern.\n\nHere follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in str.\n\n###Code: \n\n```python\ndef wordPattern(pattern: str, s: str) -> bool:\n    words = s.split()\n    if len(words) != len(pattern):\n        return False\n    \n    char_to_word = {}\n    word_to_char = {}\n    \n    for char, word in zip(pattern, words):\n        if char not in char_to_word:\n            if word in word_to_char:\n                return False\n            char_to_word[char] = word\n            word_to_char[word] = char\n        else:\n            if char_to_word[char] != word:\n                return False\n    \n    return True\n\n```\n\n###Testcases: \n\n```python\nassert wordPattern(\"abba\", \"dog cat cat dog\")==True\nassert wordPattern(\"abba\", \"dog cat cat fish\")==False\nassert wordPattern(\"aaaa\", \"dog dog dog dog\")==True\nassert wordPattern(\"abba\", \"dog cat cat fish\")==False\nassert wordPattern(\"abc\", \"dog cat dog\")==False\nassert wordPattern(\"abc\", \"dog cat mouse\")==True\nassert wordPattern(\"aaa\", \"aa aa aa aa\")==False\nassert wordPattern(\"abc\", \"apple banana orange\")==True\nassert wordPattern(\"ab\", \"apple apple\")==False\nassert wordPattern(\"ab\", \"apple banana\")==True\n```\n\n[/Example 3]", "temperature": 0.923}, {"few_shots": [{"author": "Hafeez", "UUID": "8c9548d2-7b9c-46a4-9b8e-8afd488f7e87", "question": "Find and Replace Pattern: Given a list of strings words and a string pattern, return a list of words[i] that match pattern. You may return the answer in any order.\n\nA word matches the pattern if there exists a permutation of letters p so that after replacing every letter x in the pattern with p(x), we get the desired word.\n\nRecall that a permutation of letters is a bijection from letters to letters: every letter maps to another letter, and no two letters map to the same letter.", "examples": "Input: words = [\"abc\",\"deq\",\"mee\",\"aqq\",\"dkd\",\"ccc\"], pattern = \"abb\"\nOutput: [\"mee\",\"aqq\"]\nExplanation: \"mee\" matches the pattern because there is a permutation {a -> m, b -> e, ...}. \n\"ccc\" does not match the pattern because {a -> c, b -> c, ...} is not a permutation, since a and b map to the same letter.", "link": "https://leetcode.com/problems/find-and-replace-pattern/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def findAndReplacePattern(words: list, pattern: str) -> list:\n        def match(word):\n            m1, m2 = {}, {}\n            for w, p in zip(word, pattern):\n                if w not in m1: m1[w] = p\n                if p not in m2: m2[p] = w\n                if (m1[w], m2[p]) != (p, w):\n                    return False\n            return True\n\n        return list(filter(match, words))\n", "asserts": ["assert findAndReplacePattern([\"a\",\"b\",\"c\"], \"a\")==[\"a\",\"b\",\"c\"]", "assert findAndReplacePattern([\"xx\", \"xy\", \"yy\"], \"xx\") == [\"xx\", \"yy\"]", "assert findAndReplacePattern([\"abc\", \"def\", \"ghi\", \"jkl\"], \"xyz\") == [\"abc\", \"def\", \"ghi\", \"jkl\"]", "assert findAndReplacePattern([\"aaa\", \"bbb\", \"ccc\"], \"xyz\") == []"]}, {"author": "Hafeez", "UUID": "df98fd29-db88-4de7-a00a-0a3bd5ba1539", "question": "Word Pattern: Given a pattern and a string s, find if s follows the same pattern.\n\nHere follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in s.", "examples": "Input: pattern = \"abba\", s = \"dog cat cat fish\"\nOutput: false\nInput: pattern = \"aaaa\", s = \"dog cat cat dog\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def wordPattern(pattern: str, s: str) -> bool:\n    map_char = {}\n    map_word = {}\n    \n    words = s.split(' ')\n    if len(words) != len(pattern):\n        return False\n    \n    for c, w in zip(pattern, words):\n        if c not in map_char:\n            if w in map_word:\n                return False\n            else:\n                map_char[c] = w\n                map_word[w] = c\n        else:\n            if map_char[c] != w:\n                return False\n    return True", "asserts": ["assert wordPattern(\"abba\", \"dog cat cat dog\")==True", "assert wordPattern(\"aaaa\", \"dog dog dog dog\") == True", "assert wordPattern(\"xyz\", \"apple banana apple\") == False", "assert wordPattern(\"xyx\", \"apple banana apple\") == True", "assert wordPattern(\"abab\", \"dog cat dog cat\") == True", "assert wordPattern(\"aaaa\", \"dog dog dog cat\") == False", "assert wordPattern(\"aabb\", \"dog dog cat cat\") == True", "assert wordPattern(\"abc\", \"dog\") == False  # Not enough words", "assert wordPattern(\"\", \"dog cat\") == False  # Empty pattern", "assert wordPattern(\"a\", \"dog cat dog cat\") == False  # Not enough pattern characters", "assert wordPattern(\"ab\", \"\") == False  # Empty string", "assert wordPattern(\"abb\", \"dog dog dog\") == False  # Same word for different pattern characters", "assert wordPattern(\"abba\", \"dog cat cat\") == False  # Not enough words for the pattern", "assert wordPattern(\"abba\", \"dog cat cat dog fish\") == False  # Extra words beyond the pattern length"]}], "category": "Pattern", "prompt_tokens": 922, "total_tokens": 1237, "completion_tokens": 315, "completion": "Find All Anagrams in a String: Given a string s and a non-empty string p, find all the start indices of p's anagrams in s.\n\nStrings consists of lowercase English letters only.\n\n###Code: \n\n```python\ndef findAnagrams(s: str, p: str) -> List[int]:\n    result = []\n    p_count = Counter(p)\n    s_count = Counter(s[:len(p)-1])\n    for i in range(len(p)-1, len(s)):\n        s_count[s[i]] += 1\n        if s_count == p_count:\n            result.append(i-len(p)+1)\n        s_count[s[i-len(p)+1]] -= 1\n        if s_count[s[i-len(p)+1]] == 0:\n            del s_count[s[i-len(p)+1]]\n    return result\n```\n\n###Testcases: \n\n```python\nassert findAnagrams(\"cbaebabacd\", \"abc\") == [0, 6]\nassert findAnagrams(\"abab\", \"ab\") == [0, 1, 2]\nassert findAnagrams(\"aaaaa\", \"b\") == []\nassert findAnagrams(\"aabaabaa\", \"aaba\") == [0, 1, 4]\nassert findAnagrams(\"aabaabaa\", \"aaa\") == [0, 1, 2, 3, 4, 5]\nassert findAnagrams(\"aabaabaa\", \"aabaa\") == [0, 1, 4]\n```", "temperature": 0.708}, {"few_shots": [{"author": "Hafeez", "UUID": "8c9548d2-7b9c-46a4-9b8e-8afd488f7e87", "question": "Find and Replace Pattern: Given a list of strings words and a string pattern, return a list of words[i] that match pattern. You may return the answer in any order.\n\nA word matches the pattern if there exists a permutation of letters p so that after replacing every letter x in the pattern with p(x), we get the desired word.\n\nRecall that a permutation of letters is a bijection from letters to letters: every letter maps to another letter, and no two letters map to the same letter.", "examples": "Input: words = [\"abc\",\"deq\",\"mee\",\"aqq\",\"dkd\",\"ccc\"], pattern = \"abb\"\nOutput: [\"mee\",\"aqq\"]\nExplanation: \"mee\" matches the pattern because there is a permutation {a -> m, b -> e, ...}. \n\"ccc\" does not match the pattern because {a -> c, b -> c, ...} is not a permutation, since a and b map to the same letter.", "link": "https://leetcode.com/problems/find-and-replace-pattern/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def findAndReplacePattern(words: list, pattern: str) -> list:\n        def match(word):\n            m1, m2 = {}, {}\n            for w, p in zip(word, pattern):\n                if w not in m1: m1[w] = p\n                if p not in m2: m2[p] = w\n                if (m1[w], m2[p]) != (p, w):\n                    return False\n            return True\n\n        return list(filter(match, words))\n", "asserts": ["assert findAndReplacePattern([\"a\",\"b\",\"c\"], \"a\")==[\"a\",\"b\",\"c\"]", "assert findAndReplacePattern([\"xx\", \"xy\", \"yy\"], \"xx\") == [\"xx\", \"yy\"]", "assert findAndReplacePattern([\"abc\", \"def\", \"ghi\", \"jkl\"], \"xyz\") == [\"abc\", \"def\", \"ghi\", \"jkl\"]", "assert findAndReplacePattern([\"aaa\", \"bbb\", \"ccc\"], \"xyz\") == []"]}, {"author": "Hafeez", "UUID": "124bfeca-24d0-411d-b4ad-26009b79436b", "question": "Word Pattern II: Given a pattern and a string s, return true if s matches the pattern.\n\nA string s matches a pattern if there is some bijective mapping of single characters to non-empty strings such that if each character in pattern is replaced by the string it maps to, then the resulting string is s. A bijective mapping means that no two characters map to the same string, and no character maps to two different strings.", "examples": "Input: pattern = \"abab\", s = \"redblueredblue\"\nOutput: true\nExplanation: One possible mapping is as follows:\n'a' -> \"red\"\n'b' -> \"blue\"\nInput: pattern = \"aabb\", s = \"xyzabcxzyabc\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern-ii/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def wordPatternMatch(pattern: str, s: str) -> bool:\n    def backtrack(cur: str, pattern: str, mappings: dict):\n        if not pattern:\n            return not cur\n        if pattern[0] in mappings:\n            if cur[:len(mappings[pattern[0]])] != mappings[pattern[0]]:\n                return False\n            return backtrack(cur[len(mappings[pattern[0]]):], pattern[1:], mappings)\n        for i in range(len(cur)):\n            if cur[:i+1] in mappings.values():\n                continue\n            mappings[pattern[0]] = cur[:i+1]\n            if backtrack(cur[i+1:], pattern[1:], mappings):\n                return True\n            del mappings[pattern[0]]\n        return False\n    return backtrack(s, pattern, {})", "asserts": ["assert wordPatternMatch(\"aaaa\", \"asdasdasdasd\")==True", "assert wordPatternMatch(\"abba\", \"dogcatcatdog\") == True", "assert wordPatternMatch(\"ab\", \"aa\") == False # since 'a' and 'b' cannot map to the same string \"a\"", "assert wordPatternMatch(\"xyz\", \"abcdefghi\") == True # 'x' -> \"a\", 'y' -> \"bc\", 'z' -> \"defghi\"", "assert wordPatternMatch(\"aba\", \"eggegg\") == False # 'a' maps to \"egg\", but 'b' cannot be mapped uniquely", "assert wordPatternMatch(\"zzz\", \"aaa\") == True # all 'z' map to \"a\"", "assert wordPatternMatch(\"aba\", \"catdogcat\") == True # 'a' -> \"cat\", 'b' -> \"dog\"", "assert wordPatternMatch(\"abab\", \"xyzxyzabcabc\") == False # cannot match 'a' and 'b' with two different strings each consistent with the pattern", "assert wordPatternMatch(\"abac\", \"xyzxyzxya\") == True # 'a' -> \"xyz\", 'b' -> \"xyz\", 'c' -> \"a\"", "assert wordPatternMatch(\"abcd\", \"xyzy\") == False # pattern too long for the string", "assert wordPatternMatch(\"aaaaa\", \"oneonetwo\") == False # not enough unique strings to map 'a' five times"]}], "category": "Pattern", "prompt_tokens": 1081, "total_tokens": 1365, "completion_tokens": 284, "completion": "Find All Anagrams in a String: Given a string s and a non-empty string p, find all the start indices of p's anagrams in s.\n\nStrings consists of lowercase English letters only.\n\n###Code: \n\ndef findAnagrams(s: str, p: str) -> List[int]:\n    result = []\n    p_count = Counter(p)\n    s_count = Counter()\n    for i in range(len(s)):\n        s_count[s[i]] += 1\n        if i >= len(p):\n            if s_count[s[i - len(p)]] == 1:\n                del s_count[s[i - len(p)]]\n            else:\n                s_count[s[i - len(p)]] -= 1\n        if s_count == p_count:\n            result.append(i - len(p) + 1)\n    return result\n\n\n###Testcases: \n\nassert findAnagrams(\"cbaebabacd\", \"abc\")==[0, 6]\nassert findAnagrams(\"abab\", \"ab\")==[0, 1, 2]\nassert findAnagrams(\"baa\", \"aa\")==[1]\nassert findAnagrams(\"hello\", \"abc\")==[]\nassert findAnagrams(\"aaaaaaaaaa\", \"a\")==[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n[/Example 3]", "temperature": 0.859}, {"few_shots": [{"author": "Hafeez", "UUID": "8c9548d2-7b9c-46a4-9b8e-8afd488f7e87", "question": "Find and Replace Pattern: Given a list of strings words and a string pattern, return a list of words[i] that match pattern. You may return the answer in any order.\n\nA word matches the pattern if there exists a permutation of letters p so that after replacing every letter x in the pattern with p(x), we get the desired word.\n\nRecall that a permutation of letters is a bijection from letters to letters: every letter maps to another letter, and no two letters map to the same letter.", "examples": "Input: words = [\"abc\",\"deq\",\"mee\",\"aqq\",\"dkd\",\"ccc\"], pattern = \"abb\"\nOutput: [\"mee\",\"aqq\"]\nExplanation: \"mee\" matches the pattern because there is a permutation {a -> m, b -> e, ...}. \n\"ccc\" does not match the pattern because {a -> c, b -> c, ...} is not a permutation, since a and b map to the same letter.", "link": "https://leetcode.com/problems/find-and-replace-pattern/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def findAndReplacePattern(words: list, pattern: str) -> list:\n        def match(word):\n            m1, m2 = {}, {}\n            for w, p in zip(word, pattern):\n                if w not in m1: m1[w] = p\n                if p not in m2: m2[p] = w\n                if (m1[w], m2[p]) != (p, w):\n                    return False\n            return True\n\n        return list(filter(match, words))\n", "asserts": ["assert findAndReplacePattern([\"a\",\"b\",\"c\"], \"a\")==[\"a\",\"b\",\"c\"]", "assert findAndReplacePattern([\"xx\", \"xy\", \"yy\"], \"xx\") == [\"xx\", \"yy\"]", "assert findAndReplacePattern([\"abc\", \"def\", \"ghi\", \"jkl\"], \"xyz\") == [\"abc\", \"def\", \"ghi\", \"jkl\"]", "assert findAndReplacePattern([\"aaa\", \"bbb\", \"ccc\"], \"xyz\") == []"]}, {"author": "Hafeez", "UUID": "124bfeca-24d0-411d-b4ad-26009b79436b", "question": "Word Pattern II: Given a pattern and a string s, return true if s matches the pattern.\n\nA string s matches a pattern if there is some bijective mapping of single characters to non-empty strings such that if each character in pattern is replaced by the string it maps to, then the resulting string is s. A bijective mapping means that no two characters map to the same string, and no character maps to two different strings.", "examples": "Input: pattern = \"abab\", s = \"redblueredblue\"\nOutput: true\nExplanation: One possible mapping is as follows:\n'a' -> \"red\"\n'b' -> \"blue\"\nInput: pattern = \"aabb\", s = \"xyzabcxzyabc\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern-ii/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def wordPatternMatch(pattern: str, s: str) -> bool:\n    def backtrack(cur: str, pattern: str, mappings: dict):\n        if not pattern:\n            return not cur\n        if pattern[0] in mappings:\n            if cur[:len(mappings[pattern[0]])] != mappings[pattern[0]]:\n                return False\n            return backtrack(cur[len(mappings[pattern[0]]):], pattern[1:], mappings)\n        for i in range(len(cur)):\n            if cur[:i+1] in mappings.values():\n                continue\n            mappings[pattern[0]] = cur[:i+1]\n            if backtrack(cur[i+1:], pattern[1:], mappings):\n                return True\n            del mappings[pattern[0]]\n        return False\n    return backtrack(s, pattern, {})", "asserts": ["assert wordPatternMatch(\"aaaa\", \"asdasdasdasd\")==True", "assert wordPatternMatch(\"abba\", \"dogcatcatdog\") == True", "assert wordPatternMatch(\"ab\", \"aa\") == False # since 'a' and 'b' cannot map to the same string \"a\"", "assert wordPatternMatch(\"xyz\", \"abcdefghi\") == True # 'x' -> \"a\", 'y' -> \"bc\", 'z' -> \"defghi\"", "assert wordPatternMatch(\"aba\", \"eggegg\") == False # 'a' maps to \"egg\", but 'b' cannot be mapped uniquely", "assert wordPatternMatch(\"zzz\", \"aaa\") == True # all 'z' map to \"a\"", "assert wordPatternMatch(\"aba\", \"catdogcat\") == True # 'a' -> \"cat\", 'b' -> \"dog\"", "assert wordPatternMatch(\"abab\", \"xyzxyzabcabc\") == False # cannot match 'a' and 'b' with two different strings each consistent with the pattern", "assert wordPatternMatch(\"abac\", \"xyzxyzxya\") == True # 'a' -> \"xyz\", 'b' -> \"xyz\", 'c' -> \"a\"", "assert wordPatternMatch(\"abcd\", \"xyzy\") == False # pattern too long for the string", "assert wordPatternMatch(\"aaaaa\", \"oneonetwo\") == False # not enough unique strings to map 'a' five times"]}], "category": "Pattern", "prompt_tokens": 1081, "total_tokens": 1380, "completion_tokens": 299, "completion": "Find All Anagrams in a String: Given a string s and a non-empty string p, find all the start indices of p's anagrams in s.\n\nStrings consists of lowercase English letters only.\n\n###Code: \n\ndef findAnagrams(s: str, p: str) -> List[int]:\n    result = []\n    p_count = [0] * 26\n    s_count = [0] * 26\n    for char in p:\n        p_count[ord(char) - ord('a')] += 1\n    for i in range(len(s)):\n        s_count[ord(s[i]) - ord('a')] += 1\n        if i >= len(p):\n            s_count[ord(s[i - len(p)]) - ord('a')] -= 1\n        if s_count == p_count:\n            result.append(i - len(p) + 1)\n    return result\n\n###Testcases: \n\nassert findAnagrams(\"cbaebabacd\", \"abc\") == [0, 6]\nassert findAnagrams(\"abab\", \"ab\") == [0, 1, 2]\nassert findAnagrams(\"aaaaaaaaaa\", \"aa\") == [0, 1, 2, 3, 4, 5, 6, 7]\nassert findAnagrams(\"a\", \"a\") == [0]\nassert findAnagrams(\"ab\", \"ba\") == [0]\n\n[/Example 3]", "temperature": 0.628}, {"few_shots": [{"author": "Hafeez", "UUID": "8c9548d2-7b9c-46a4-9b8e-8afd488f7e87", "question": "Find and Replace Pattern: Given a list of strings words and a string pattern, return a list of words[i] that match pattern. You may return the answer in any order.\n\nA word matches the pattern if there exists a permutation of letters p so that after replacing every letter x in the pattern with p(x), we get the desired word.\n\nRecall that a permutation of letters is a bijection from letters to letters: every letter maps to another letter, and no two letters map to the same letter.", "examples": "Input: words = [\"abc\",\"deq\",\"mee\",\"aqq\",\"dkd\",\"ccc\"], pattern = \"abb\"\nOutput: [\"mee\",\"aqq\"]\nExplanation: \"mee\" matches the pattern because there is a permutation {a -> m, b -> e, ...}. \n\"ccc\" does not match the pattern because {a -> c, b -> c, ...} is not a permutation, since a and b map to the same letter.", "link": "https://leetcode.com/problems/find-and-replace-pattern/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def findAndReplacePattern(words: list, pattern: str) -> list:\n        def match(word):\n            m1, m2 = {}, {}\n            for w, p in zip(word, pattern):\n                if w not in m1: m1[w] = p\n                if p not in m2: m2[p] = w\n                if (m1[w], m2[p]) != (p, w):\n                    return False\n            return True\n\n        return list(filter(match, words))\n", "asserts": ["assert findAndReplacePattern([\"a\",\"b\",\"c\"], \"a\")==[\"a\",\"b\",\"c\"]", "assert findAndReplacePattern([\"xx\", \"xy\", \"yy\"], \"xx\") == [\"xx\", \"yy\"]", "assert findAndReplacePattern([\"abc\", \"def\", \"ghi\", \"jkl\"], \"xyz\") == [\"abc\", \"def\", \"ghi\", \"jkl\"]", "assert findAndReplacePattern([\"aaa\", \"bbb\", \"ccc\"], \"xyz\") == []"]}, {"author": "Hafeez", "UUID": "124bfeca-24d0-411d-b4ad-26009b79436b", "question": "Word Pattern II: Given a pattern and a string s, return true if s matches the pattern.\n\nA string s matches a pattern if there is some bijective mapping of single characters to non-empty strings such that if each character in pattern is replaced by the string it maps to, then the resulting string is s. A bijective mapping means that no two characters map to the same string, and no character maps to two different strings.", "examples": "Input: pattern = \"abab\", s = \"redblueredblue\"\nOutput: true\nExplanation: One possible mapping is as follows:\n'a' -> \"red\"\n'b' -> \"blue\"\nInput: pattern = \"aabb\", s = \"xyzabcxzyabc\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern-ii/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def wordPatternMatch(pattern: str, s: str) -> bool:\n    def backtrack(cur: str, pattern: str, mappings: dict):\n        if not pattern:\n            return not cur\n        if pattern[0] in mappings:\n            if cur[:len(mappings[pattern[0]])] != mappings[pattern[0]]:\n                return False\n            return backtrack(cur[len(mappings[pattern[0]]):], pattern[1:], mappings)\n        for i in range(len(cur)):\n            if cur[:i+1] in mappings.values():\n                continue\n            mappings[pattern[0]] = cur[:i+1]\n            if backtrack(cur[i+1:], pattern[1:], mappings):\n                return True\n            del mappings[pattern[0]]\n        return False\n    return backtrack(s, pattern, {})", "asserts": ["assert wordPatternMatch(\"aaaa\", \"asdasdasdasd\")==True", "assert wordPatternMatch(\"abba\", \"dogcatcatdog\") == True", "assert wordPatternMatch(\"ab\", \"aa\") == False # since 'a' and 'b' cannot map to the same string \"a\"", "assert wordPatternMatch(\"xyz\", \"abcdefghi\") == True # 'x' -> \"a\", 'y' -> \"bc\", 'z' -> \"defghi\"", "assert wordPatternMatch(\"aba\", \"eggegg\") == False # 'a' maps to \"egg\", but 'b' cannot be mapped uniquely", "assert wordPatternMatch(\"zzz\", \"aaa\") == True # all 'z' map to \"a\"", "assert wordPatternMatch(\"aba\", \"catdogcat\") == True # 'a' -> \"cat\", 'b' -> \"dog\"", "assert wordPatternMatch(\"abab\", \"xyzxyzabcabc\") == False # cannot match 'a' and 'b' with two different strings each consistent with the pattern", "assert wordPatternMatch(\"abac\", \"xyzxyzxya\") == True # 'a' -> \"xyz\", 'b' -> \"xyz\", 'c' -> \"a\"", "assert wordPatternMatch(\"abcd\", \"xyzy\") == False # pattern too long for the string", "assert wordPatternMatch(\"aaaaa\", \"oneonetwo\") == False # not enough unique strings to map 'a' five times"]}], "category": "Pattern", "prompt_tokens": 1081, "total_tokens": 1607, "completion_tokens": 526, "completion": "Find All Anagrams in a String: Given a string s and a non-empty string p, find all the start indices of p's anagrams in s.\n\nStrings consists of lowercase English letters only.\n\n###Code: \n\n```python\ndef findAnagrams(s: str, p: str) -> List[int]:\n    from collections import Counter\n    res = []\n    pCounter = Counter(p)\n    sCounter = Counter(s[:len(p)-1])\n    for i in range(len(p)-1,len(s)):\n        sCounter[s[i]] += 1   # include a new char in the window\n        if sCounter == pCounter:    # This step is O(1), since there are at most 26 English letters \n            res.append(i-len(p)+1)   # append the starting index\n        sCounter[s[i-len(p)+1]] -= 1   # decrease the count of oldest char in the window\n        if sCounter[s[i-len(p)+1]] == 0:\n            del sCounter[s[i-len(p)+1]]   # remove the count if it is 0\n    return res\n```\n\n###Testcases: \n\n```python\nassert findAnagrams(\"cbaebabacd\", \"abc\") == [0, 6]\nassert findAnagrams(\"abab\", \"ab\") == [0, 1, 2]\nassert findAnagrams(\"aaaaaaa\", \"aaa\") == [0, 1, 2, 3, 4]\nassert findAnagrams(\"baa\", \"aa\") == [1]\nassert findAnagrams(\"abacbabc\", \"abc\") == [2, 3, 4]\nassert findAnagrams(\"ababababababababababababababababababababababababababab\", \"ab\") == [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46]\n```", "temperature": 0.976}, {"few_shots": [{"author": "Hafeez", "UUID": "8c9548d2-7b9c-46a4-9b8e-8afd488f7e87", "question": "Find and Replace Pattern: Given a list of strings words and a string pattern, return a list of words[i] that match pattern. You may return the answer in any order.\n\nA word matches the pattern if there exists a permutation of letters p so that after replacing every letter x in the pattern with p(x), we get the desired word.\n\nRecall that a permutation of letters is a bijection from letters to letters: every letter maps to another letter, and no two letters map to the same letter.", "examples": "Input: words = [\"abc\",\"deq\",\"mee\",\"aqq\",\"dkd\",\"ccc\"], pattern = \"abb\"\nOutput: [\"mee\",\"aqq\"]\nExplanation: \"mee\" matches the pattern because there is a permutation {a -> m, b -> e, ...}. \n\"ccc\" does not match the pattern because {a -> c, b -> c, ...} is not a permutation, since a and b map to the same letter.", "link": "https://leetcode.com/problems/find-and-replace-pattern/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def findAndReplacePattern(words: list, pattern: str) -> list:\n        def match(word):\n            m1, m2 = {}, {}\n            for w, p in zip(word, pattern):\n                if w not in m1: m1[w] = p\n                if p not in m2: m2[p] = w\n                if (m1[w], m2[p]) != (p, w):\n                    return False\n            return True\n\n        return list(filter(match, words))\n", "asserts": ["assert findAndReplacePattern([\"a\",\"b\",\"c\"], \"a\")==[\"a\",\"b\",\"c\"]", "assert findAndReplacePattern([\"xx\", \"xy\", \"yy\"], \"xx\") == [\"xx\", \"yy\"]", "assert findAndReplacePattern([\"abc\", \"def\", \"ghi\", \"jkl\"], \"xyz\") == [\"abc\", \"def\", \"ghi\", \"jkl\"]", "assert findAndReplacePattern([\"aaa\", \"bbb\", \"ccc\"], \"xyz\") == []"]}, {"author": "Hafeez", "UUID": "124bfeca-24d0-411d-b4ad-26009b79436b", "question": "Word Pattern II: Given a pattern and a string s, return true if s matches the pattern.\n\nA string s matches a pattern if there is some bijective mapping of single characters to non-empty strings such that if each character in pattern is replaced by the string it maps to, then the resulting string is s. A bijective mapping means that no two characters map to the same string, and no character maps to two different strings.", "examples": "Input: pattern = \"abab\", s = \"redblueredblue\"\nOutput: true\nExplanation: One possible mapping is as follows:\n'a' -> \"red\"\n'b' -> \"blue\"\nInput: pattern = \"aabb\", s = \"xyzabcxzyabc\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern-ii/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def wordPatternMatch(pattern: str, s: str) -> bool:\n    def backtrack(cur: str, pattern: str, mappings: dict):\n        if not pattern:\n            return not cur\n        if pattern[0] in mappings:\n            if cur[:len(mappings[pattern[0]])] != mappings[pattern[0]]:\n                return False\n            return backtrack(cur[len(mappings[pattern[0]]):], pattern[1:], mappings)\n        for i in range(len(cur)):\n            if cur[:i+1] in mappings.values():\n                continue\n            mappings[pattern[0]] = cur[:i+1]\n            if backtrack(cur[i+1:], pattern[1:], mappings):\n                return True\n            del mappings[pattern[0]]\n        return False\n    return backtrack(s, pattern, {})", "asserts": ["assert wordPatternMatch(\"aaaa\", \"asdasdasdasd\")==True", "assert wordPatternMatch(\"abba\", \"dogcatcatdog\") == True", "assert wordPatternMatch(\"ab\", \"aa\") == False # since 'a' and 'b' cannot map to the same string \"a\"", "assert wordPatternMatch(\"xyz\", \"abcdefghi\") == True # 'x' -> \"a\", 'y' -> \"bc\", 'z' -> \"defghi\"", "assert wordPatternMatch(\"aba\", \"eggegg\") == False # 'a' maps to \"egg\", but 'b' cannot be mapped uniquely", "assert wordPatternMatch(\"zzz\", \"aaa\") == True # all 'z' map to \"a\"", "assert wordPatternMatch(\"aba\", \"catdogcat\") == True # 'a' -> \"cat\", 'b' -> \"dog\"", "assert wordPatternMatch(\"abab\", \"xyzxyzabcabc\") == False # cannot match 'a' and 'b' with two different strings each consistent with the pattern", "assert wordPatternMatch(\"abac\", \"xyzxyzxya\") == True # 'a' -> \"xyz\", 'b' -> \"xyz\", 'c' -> \"a\"", "assert wordPatternMatch(\"abcd\", \"xyzy\") == False # pattern too long for the string", "assert wordPatternMatch(\"aaaaa\", \"oneonetwo\") == False # not enough unique strings to map 'a' five times"]}], "category": "Pattern", "prompt_tokens": 1081, "total_tokens": 1367, "completion_tokens": 286, "completion": "Find All Anagrams in a String: Given a string s and a non-empty string p, find all the start indices of p's anagrams in s. Strings consists of lowercase English letters only.\n\n###Code: \n\ndef findAnagrams(s: str, p: str) -> List[int]:\n        res = []\n        p_count = collections.Counter(p)\n        s_count = collections.Counter(s[:len(p)-1])\n        for i in range(len(p)-1,len(s)):\n            s_count[s[i]] += 1 \n            if s_count == p_count:\n                res.append(i-len(p)+1)\n            s_count[s[i-len(p)+1]] -= 1\n            if s_count[s[i-len(p)+1]] == 0:\n                del s_count[s[i-len(p)+1]]\n        return res\n\n###Testcases: \n\nassert findAnagrams(\"cbaebabacd\", \"abc\") == [0, 6]\nassert findAnagrams(\"abab\", \"ab\") == [0, 1, 2]\nassert findAnagrams(\"aaaaaaaaaa\", \"a\") == [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nassert findAnagrams(\"hello\", \"abc\") == []\nassert findAnagrams(\"abcdefg\", \"xyz\") == []\n\n[/Example 3]", "temperature": 0.959}, {"few_shots": [{"author": "Hafeez", "UUID": "8c9548d2-7b9c-46a4-9b8e-8afd488f7e87", "question": "Find and Replace Pattern: Given a list of strings words and a string pattern, return a list of words[i] that match pattern. You may return the answer in any order.\n\nA word matches the pattern if there exists a permutation of letters p so that after replacing every letter x in the pattern with p(x), we get the desired word.\n\nRecall that a permutation of letters is a bijection from letters to letters: every letter maps to another letter, and no two letters map to the same letter.", "examples": "Input: words = [\"abc\",\"deq\",\"mee\",\"aqq\",\"dkd\",\"ccc\"], pattern = \"abb\"\nOutput: [\"mee\",\"aqq\"]\nExplanation: \"mee\" matches the pattern because there is a permutation {a -> m, b -> e, ...}. \n\"ccc\" does not match the pattern because {a -> c, b -> c, ...} is not a permutation, since a and b map to the same letter.", "link": "https://leetcode.com/problems/find-and-replace-pattern/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def findAndReplacePattern(words: list, pattern: str) -> list:\n        def match(word):\n            m1, m2 = {}, {}\n            for w, p in zip(word, pattern):\n                if w not in m1: m1[w] = p\n                if p not in m2: m2[p] = w\n                if (m1[w], m2[p]) != (p, w):\n                    return False\n            return True\n\n        return list(filter(match, words))\n", "asserts": ["assert findAndReplacePattern([\"a\",\"b\",\"c\"], \"a\")==[\"a\",\"b\",\"c\"]", "assert findAndReplacePattern([\"xx\", \"xy\", \"yy\"], \"xx\") == [\"xx\", \"yy\"]", "assert findAndReplacePattern([\"abc\", \"def\", \"ghi\", \"jkl\"], \"xyz\") == [\"abc\", \"def\", \"ghi\", \"jkl\"]", "assert findAndReplacePattern([\"aaa\", \"bbb\", \"ccc\"], \"xyz\") == []"]}, {"author": "Hafeez", "UUID": "124bfeca-24d0-411d-b4ad-26009b79436b", "question": "Word Pattern II: Given a pattern and a string s, return true if s matches the pattern.\n\nA string s matches a pattern if there is some bijective mapping of single characters to non-empty strings such that if each character in pattern is replaced by the string it maps to, then the resulting string is s. A bijective mapping means that no two characters map to the same string, and no character maps to two different strings.", "examples": "Input: pattern = \"abab\", s = \"redblueredblue\"\nOutput: true\nExplanation: One possible mapping is as follows:\n'a' -> \"red\"\n'b' -> \"blue\"\nInput: pattern = \"aabb\", s = \"xyzabcxzyabc\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern-ii/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def wordPatternMatch(pattern: str, s: str) -> bool:\n    def backtrack(cur: str, pattern: str, mappings: dict):\n        if not pattern:\n            return not cur\n        if pattern[0] in mappings:\n            if cur[:len(mappings[pattern[0]])] != mappings[pattern[0]]:\n                return False\n            return backtrack(cur[len(mappings[pattern[0]]):], pattern[1:], mappings)\n        for i in range(len(cur)):\n            if cur[:i+1] in mappings.values():\n                continue\n            mappings[pattern[0]] = cur[:i+1]\n            if backtrack(cur[i+1:], pattern[1:], mappings):\n                return True\n            del mappings[pattern[0]]\n        return False\n    return backtrack(s, pattern, {})", "asserts": ["assert wordPatternMatch(\"aaaa\", \"asdasdasdasd\")==True", "assert wordPatternMatch(\"abba\", \"dogcatcatdog\") == True", "assert wordPatternMatch(\"ab\", \"aa\") == False # since 'a' and 'b' cannot map to the same string \"a\"", "assert wordPatternMatch(\"xyz\", \"abcdefghi\") == True # 'x' -> \"a\", 'y' -> \"bc\", 'z' -> \"defghi\"", "assert wordPatternMatch(\"aba\", \"eggegg\") == False # 'a' maps to \"egg\", but 'b' cannot be mapped uniquely", "assert wordPatternMatch(\"zzz\", \"aaa\") == True # all 'z' map to \"a\"", "assert wordPatternMatch(\"aba\", \"catdogcat\") == True # 'a' -> \"cat\", 'b' -> \"dog\"", "assert wordPatternMatch(\"abab\", \"xyzxyzabcabc\") == False # cannot match 'a' and 'b' with two different strings each consistent with the pattern", "assert wordPatternMatch(\"abac\", \"xyzxyzxya\") == True # 'a' -> \"xyz\", 'b' -> \"xyz\", 'c' -> \"a\"", "assert wordPatternMatch(\"abcd\", \"xyzy\") == False # pattern too long for the string", "assert wordPatternMatch(\"aaaaa\", \"oneonetwo\") == False # not enough unique strings to map 'a' five times"]}], "category": "Pattern", "prompt_tokens": 1081, "total_tokens": 1436, "completion_tokens": 355, "completion": "Find All Anagrams in a String: Given a string s and a non-empty string p, find all the start indices of p's anagrams in s.\n\nStrings consists of lowercase English letters only.\n\n###Code: \n\n```python\ndef findAnagrams(s: str, p: str) -> List[int]:\n    res = []\n    pCounter = Counter(p)\n    sCounter = Counter(s[:len(p)-1])\n    for i in range(len(p)-1,len(s)):\n        sCounter[s[i]] += 1   # include a new char in the window\n        if sCounter == pCounter:    # This step is O(1), since there are at most 26 English letters\n            res.append(i-len(p)+1)   # append the starting index\n        sCounter[s[i-len(p)+1]] -= 1   # decrease the count of oldest char in the window\n        if sCounter[s[i-len(p)+1]] == 0:\n            del sCounter[s[i-len(p)+1]]   # remove the count if it is 0\n    return res\n```\n\n###Testcases: \n\n```python\nassert findAnagrams(\"cbaebabacd\", \"abc\") == [0, 6]\nassert findAnagrams(\"abab\", \"ab\") == [0, 1, 2]\nassert findAnagrams(\"acdcaeccde\", \"c\") == [3, 4, 5, 6]\nassert findAnagrams(\"aaaaaaaaaa\", \"a\") == [0, 1, 2, 3, 4, 5, 6, 7, 8]\nassert findAnagrams(\"ab\", \"abc\") == []\n```", "temperature": 0.857}, {"few_shots": [{"author": "Hafeez", "UUID": "8c9548d2-7b9c-46a4-9b8e-8afd488f7e87", "question": "Find and Replace Pattern: Given a list of strings words and a string pattern, return a list of words[i] that match pattern. You may return the answer in any order.\n\nA word matches the pattern if there exists a permutation of letters p so that after replacing every letter x in the pattern with p(x), we get the desired word.\n\nRecall that a permutation of letters is a bijection from letters to letters: every letter maps to another letter, and no two letters map to the same letter.", "examples": "Input: words = [\"abc\",\"deq\",\"mee\",\"aqq\",\"dkd\",\"ccc\"], pattern = \"abb\"\nOutput: [\"mee\",\"aqq\"]\nExplanation: \"mee\" matches the pattern because there is a permutation {a -> m, b -> e, ...}. \n\"ccc\" does not match the pattern because {a -> c, b -> c, ...} is not a permutation, since a and b map to the same letter.", "link": "https://leetcode.com/problems/find-and-replace-pattern/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def findAndReplacePattern(words: list, pattern: str) -> list:\n        def match(word):\n            m1, m2 = {}, {}\n            for w, p in zip(word, pattern):\n                if w not in m1: m1[w] = p\n                if p not in m2: m2[p] = w\n                if (m1[w], m2[p]) != (p, w):\n                    return False\n            return True\n\n        return list(filter(match, words))\n", "asserts": ["assert findAndReplacePattern([\"a\",\"b\",\"c\"], \"a\")==[\"a\",\"b\",\"c\"]", "assert findAndReplacePattern([\"xx\", \"xy\", \"yy\"], \"xx\") == [\"xx\", \"yy\"]", "assert findAndReplacePattern([\"abc\", \"def\", \"ghi\", \"jkl\"], \"xyz\") == [\"abc\", \"def\", \"ghi\", \"jkl\"]", "assert findAndReplacePattern([\"aaa\", \"bbb\", \"ccc\"], \"xyz\") == []"]}, {"author": "Hafeez", "UUID": "124bfeca-24d0-411d-b4ad-26009b79436b", "question": "Word Pattern II: Given a pattern and a string s, return true if s matches the pattern.\n\nA string s matches a pattern if there is some bijective mapping of single characters to non-empty strings such that if each character in pattern is replaced by the string it maps to, then the resulting string is s. A bijective mapping means that no two characters map to the same string, and no character maps to two different strings.", "examples": "Input: pattern = \"abab\", s = \"redblueredblue\"\nOutput: true\nExplanation: One possible mapping is as follows:\n'a' -> \"red\"\n'b' -> \"blue\"\nInput: pattern = \"aabb\", s = \"xyzabcxzyabc\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern-ii/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def wordPatternMatch(pattern: str, s: str) -> bool:\n    def backtrack(cur: str, pattern: str, mappings: dict):\n        if not pattern:\n            return not cur\n        if pattern[0] in mappings:\n            if cur[:len(mappings[pattern[0]])] != mappings[pattern[0]]:\n                return False\n            return backtrack(cur[len(mappings[pattern[0]]):], pattern[1:], mappings)\n        for i in range(len(cur)):\n            if cur[:i+1] in mappings.values():\n                continue\n            mappings[pattern[0]] = cur[:i+1]\n            if backtrack(cur[i+1:], pattern[1:], mappings):\n                return True\n            del mappings[pattern[0]]\n        return False\n    return backtrack(s, pattern, {})", "asserts": ["assert wordPatternMatch(\"aaaa\", \"asdasdasdasd\")==True", "assert wordPatternMatch(\"abba\", \"dogcatcatdog\") == True", "assert wordPatternMatch(\"ab\", \"aa\") == False # since 'a' and 'b' cannot map to the same string \"a\"", "assert wordPatternMatch(\"xyz\", \"abcdefghi\") == True # 'x' -> \"a\", 'y' -> \"bc\", 'z' -> \"defghi\"", "assert wordPatternMatch(\"aba\", \"eggegg\") == False # 'a' maps to \"egg\", but 'b' cannot be mapped uniquely", "assert wordPatternMatch(\"zzz\", \"aaa\") == True # all 'z' map to \"a\"", "assert wordPatternMatch(\"aba\", \"catdogcat\") == True # 'a' -> \"cat\", 'b' -> \"dog\"", "assert wordPatternMatch(\"abab\", \"xyzxyzabcabc\") == False # cannot match 'a' and 'b' with two different strings each consistent with the pattern", "assert wordPatternMatch(\"abac\", \"xyzxyzxya\") == True # 'a' -> \"xyz\", 'b' -> \"xyz\", 'c' -> \"a\"", "assert wordPatternMatch(\"abcd\", \"xyzy\") == False # pattern too long for the string", "assert wordPatternMatch(\"aaaaa\", \"oneonetwo\") == False # not enough unique strings to map 'a' five times"]}], "category": "Pattern", "prompt_tokens": 1081, "total_tokens": 1424, "completion_tokens": 343, "completion": "Find All Anagrams in a String: Given a string s and a non-empty string p, find all the start indices of p's anagrams in s.\n\nStrings consists of lowercase English letters only.\n\n###Code: \n\n```python\ndef findAnagrams(s: str, p: str) -> List[int]:\n        result = []\n        pCounter = Counter(p)\n        sCounter = Counter(s[:len(p)-1])\n        for i in range(len(p)-1,len(s)):\n            sCounter[s[i]] += 1   # include a new char in the window\n            if sCounter == pCounter:    # This step is O(1), since there are at most 26 English letters \n                result.append(i-len(p)+1)   # append the starting index\n            sCounter[s[i-len(p)+1]] -= 1   # decrease the count of oldest char in the window\n            if sCounter[s[i-len(p)+1]] == 0:\n                del sCounter[s[i-len(p)+1]]   # remove the count if it is 0\n        return result\n```\n\n###Testcases: \n\n```python\nassert findAnagrams(\"cbaebabacd\", \"abc\") == [0, 6]\nassert findAnagrams(\"abab\", \"ab\") == [0, 1, 2]\nassert findAnagrams(\"aaaaaaaaaa\", \"aa\") == [0, 1, 2, 3, 4, 5, 6, 7]\nassert findAnagrams(\"ab\", \"abc\") == []\nassert findAnagrams(\"ab\", \"a\") == [0, 1]\n```", "temperature": 0.781}, {"few_shots": [{"author": "Hafeez", "UUID": "8c9548d2-7b9c-46a4-9b8e-8afd488f7e87", "question": "Find and Replace Pattern: Given a list of strings words and a string pattern, return a list of words[i] that match pattern. You may return the answer in any order.\n\nA word matches the pattern if there exists a permutation of letters p so that after replacing every letter x in the pattern with p(x), we get the desired word.\n\nRecall that a permutation of letters is a bijection from letters to letters: every letter maps to another letter, and no two letters map to the same letter.", "examples": "Input: words = [\"abc\",\"deq\",\"mee\",\"aqq\",\"dkd\",\"ccc\"], pattern = \"abb\"\nOutput: [\"mee\",\"aqq\"]\nExplanation: \"mee\" matches the pattern because there is a permutation {a -> m, b -> e, ...}. \n\"ccc\" does not match the pattern because {a -> c, b -> c, ...} is not a permutation, since a and b map to the same letter.", "link": "https://leetcode.com/problems/find-and-replace-pattern/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def findAndReplacePattern(words: list, pattern: str) -> list:\n        def match(word):\n            m1, m2 = {}, {}\n            for w, p in zip(word, pattern):\n                if w not in m1: m1[w] = p\n                if p not in m2: m2[p] = w\n                if (m1[w], m2[p]) != (p, w):\n                    return False\n            return True\n\n        return list(filter(match, words))\n", "asserts": ["assert findAndReplacePattern([\"a\",\"b\",\"c\"], \"a\")==[\"a\",\"b\",\"c\"]", "assert findAndReplacePattern([\"xx\", \"xy\", \"yy\"], \"xx\") == [\"xx\", \"yy\"]", "assert findAndReplacePattern([\"abc\", \"def\", \"ghi\", \"jkl\"], \"xyz\") == [\"abc\", \"def\", \"ghi\", \"jkl\"]", "assert findAndReplacePattern([\"aaa\", \"bbb\", \"ccc\"], \"xyz\") == []"]}, {"author": "Hafeez", "UUID": "124bfeca-24d0-411d-b4ad-26009b79436b", "question": "Word Pattern II: Given a pattern and a string s, return true if s matches the pattern.\n\nA string s matches a pattern if there is some bijective mapping of single characters to non-empty strings such that if each character in pattern is replaced by the string it maps to, then the resulting string is s. A bijective mapping means that no two characters map to the same string, and no character maps to two different strings.", "examples": "Input: pattern = \"abab\", s = \"redblueredblue\"\nOutput: true\nExplanation: One possible mapping is as follows:\n'a' -> \"red\"\n'b' -> \"blue\"\nInput: pattern = \"aabb\", s = \"xyzabcxzyabc\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern-ii/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def wordPatternMatch(pattern: str, s: str) -> bool:\n    def backtrack(cur: str, pattern: str, mappings: dict):\n        if not pattern:\n            return not cur\n        if pattern[0] in mappings:\n            if cur[:len(mappings[pattern[0]])] != mappings[pattern[0]]:\n                return False\n            return backtrack(cur[len(mappings[pattern[0]]):], pattern[1:], mappings)\n        for i in range(len(cur)):\n            if cur[:i+1] in mappings.values():\n                continue\n            mappings[pattern[0]] = cur[:i+1]\n            if backtrack(cur[i+1:], pattern[1:], mappings):\n                return True\n            del mappings[pattern[0]]\n        return False\n    return backtrack(s, pattern, {})", "asserts": ["assert wordPatternMatch(\"aaaa\", \"asdasdasdasd\")==True", "assert wordPatternMatch(\"abba\", \"dogcatcatdog\") == True", "assert wordPatternMatch(\"ab\", \"aa\") == False # since 'a' and 'b' cannot map to the same string \"a\"", "assert wordPatternMatch(\"xyz\", \"abcdefghi\") == True # 'x' -> \"a\", 'y' -> \"bc\", 'z' -> \"defghi\"", "assert wordPatternMatch(\"aba\", \"eggegg\") == False # 'a' maps to \"egg\", but 'b' cannot be mapped uniquely", "assert wordPatternMatch(\"zzz\", \"aaa\") == True # all 'z' map to \"a\"", "assert wordPatternMatch(\"aba\", \"catdogcat\") == True # 'a' -> \"cat\", 'b' -> \"dog\"", "assert wordPatternMatch(\"abab\", \"xyzxyzabcabc\") == False # cannot match 'a' and 'b' with two different strings each consistent with the pattern", "assert wordPatternMatch(\"abac\", \"xyzxyzxya\") == True # 'a' -> \"xyz\", 'b' -> \"xyz\", 'c' -> \"a\"", "assert wordPatternMatch(\"abcd\", \"xyzy\") == False # pattern too long for the string", "assert wordPatternMatch(\"aaaaa\", \"oneonetwo\") == False # not enough unique strings to map 'a' five times"]}], "category": "Pattern", "prompt_tokens": 1081, "total_tokens": 1430, "completion_tokens": 349, "completion": "Find All Anagrams in a String: Given a string s and a non-empty string p, find all the start indices of p's anagrams in s. Strings consists of lowercase English letters only.\n\n###Code: \n\n```python\ndef findAnagrams(s: str, p: str) -> List[int]:\n    result = []\n    pCounter = Counter(p)\n    sCounter = Counter(s[:len(p)-1])\n    for i in range(len(p)-1,len(s)):\n        sCounter[s[i]] += 1   # include a new char in the window\n        if sCounter == pCounter:    # This step is O(1), since there are at most 26 English letters \n            result.append(i-len(p)+1)   # append the starting index\n        sCounter[s[i-len(p)+1]] -= 1   # decrease the count of oldest char in the window\n        if sCounter[s[i-len(p)+1]] == 0:\n            del sCounter[s[i-len(p)+1]]   # remove the count if it is 0\n    return result\n```\n\n###Testcases: \n\n```python\nassert findAnagrams(\"cbaebabacd\", \"abc\") == [0, 6]\nassert findAnagrams(\"abab\", \"ab\") == [0, 1, 2]\nassert findAnagrams(\"acdcaeccde\", \"c\") == [3, 7, 8]\nassert findAnagrams(\"aaaaaaaaaa\", \"a\") == [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n```\n\n[/Example 3]", "temperature": 0.645}, {"few_shots": [{"author": "Hafeez", "UUID": "8c9548d2-7b9c-46a4-9b8e-8afd488f7e87", "question": "Find and Replace Pattern: Given a list of strings words and a string pattern, return a list of words[i] that match pattern. You may return the answer in any order.\n\nA word matches the pattern if there exists a permutation of letters p so that after replacing every letter x in the pattern with p(x), we get the desired word.\n\nRecall that a permutation of letters is a bijection from letters to letters: every letter maps to another letter, and no two letters map to the same letter.", "examples": "Input: words = [\"abc\",\"deq\",\"mee\",\"aqq\",\"dkd\",\"ccc\"], pattern = \"abb\"\nOutput: [\"mee\",\"aqq\"]\nExplanation: \"mee\" matches the pattern because there is a permutation {a -> m, b -> e, ...}. \n\"ccc\" does not match the pattern because {a -> c, b -> c, ...} is not a permutation, since a and b map to the same letter.", "link": "https://leetcode.com/problems/find-and-replace-pattern/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def findAndReplacePattern(words: list, pattern: str) -> list:\n        def match(word):\n            m1, m2 = {}, {}\n            for w, p in zip(word, pattern):\n                if w not in m1: m1[w] = p\n                if p not in m2: m2[p] = w\n                if (m1[w], m2[p]) != (p, w):\n                    return False\n            return True\n\n        return list(filter(match, words))\n", "asserts": ["assert findAndReplacePattern([\"a\",\"b\",\"c\"], \"a\")==[\"a\",\"b\",\"c\"]", "assert findAndReplacePattern([\"xx\", \"xy\", \"yy\"], \"xx\") == [\"xx\", \"yy\"]", "assert findAndReplacePattern([\"abc\", \"def\", \"ghi\", \"jkl\"], \"xyz\") == [\"abc\", \"def\", \"ghi\", \"jkl\"]", "assert findAndReplacePattern([\"aaa\", \"bbb\", \"ccc\"], \"xyz\") == []"]}, {"author": "Hafeez", "UUID": "124bfeca-24d0-411d-b4ad-26009b79436b", "question": "Word Pattern II: Given a pattern and a string s, return true if s matches the pattern.\n\nA string s matches a pattern if there is some bijective mapping of single characters to non-empty strings such that if each character in pattern is replaced by the string it maps to, then the resulting string is s. A bijective mapping means that no two characters map to the same string, and no character maps to two different strings.", "examples": "Input: pattern = \"abab\", s = \"redblueredblue\"\nOutput: true\nExplanation: One possible mapping is as follows:\n'a' -> \"red\"\n'b' -> \"blue\"\nInput: pattern = \"aabb\", s = \"xyzabcxzyabc\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern-ii/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def wordPatternMatch(pattern: str, s: str) -> bool:\n    def backtrack(cur: str, pattern: str, mappings: dict):\n        if not pattern:\n            return not cur\n        if pattern[0] in mappings:\n            if cur[:len(mappings[pattern[0]])] != mappings[pattern[0]]:\n                return False\n            return backtrack(cur[len(mappings[pattern[0]]):], pattern[1:], mappings)\n        for i in range(len(cur)):\n            if cur[:i+1] in mappings.values():\n                continue\n            mappings[pattern[0]] = cur[:i+1]\n            if backtrack(cur[i+1:], pattern[1:], mappings):\n                return True\n            del mappings[pattern[0]]\n        return False\n    return backtrack(s, pattern, {})", "asserts": ["assert wordPatternMatch(\"aaaa\", \"asdasdasdasd\")==True", "assert wordPatternMatch(\"abba\", \"dogcatcatdog\") == True", "assert wordPatternMatch(\"ab\", \"aa\") == False # since 'a' and 'b' cannot map to the same string \"a\"", "assert wordPatternMatch(\"xyz\", \"abcdefghi\") == True # 'x' -> \"a\", 'y' -> \"bc\", 'z' -> \"defghi\"", "assert wordPatternMatch(\"aba\", \"eggegg\") == False # 'a' maps to \"egg\", but 'b' cannot be mapped uniquely", "assert wordPatternMatch(\"zzz\", \"aaa\") == True # all 'z' map to \"a\"", "assert wordPatternMatch(\"aba\", \"catdogcat\") == True # 'a' -> \"cat\", 'b' -> \"dog\"", "assert wordPatternMatch(\"abab\", \"xyzxyzabcabc\") == False # cannot match 'a' and 'b' with two different strings each consistent with the pattern", "assert wordPatternMatch(\"abac\", \"xyzxyzxya\") == True # 'a' -> \"xyz\", 'b' -> \"xyz\", 'c' -> \"a\"", "assert wordPatternMatch(\"abcd\", \"xyzy\") == False # pattern too long for the string", "assert wordPatternMatch(\"aaaaa\", \"oneonetwo\") == False # not enough unique strings to map 'a' five times"]}], "category": "Pattern", "prompt_tokens": 1081, "total_tokens": 1404, "completion_tokens": 323, "completion": "Find All Anagrams in a String: Given a string s and a non-empty string p, find all the start indices of p's anagrams in s. Strings consists of lowercase English letters only.\n\n###Code: \n\ndef findAnagrams(s: str, p: str) -> List[int]:\n    from collections import Counter\n    res = []\n    pCounter = Counter(p)\n    sCounter = Counter(s[:len(p)-1])\n    for i in range(len(p)-1,len(s)):\n        sCounter[s[i]] += 1   # include a new char in the window\n        if sCounter == pCounter:    # This step is O(1), since there are at most 26 English letters \n            res.append(i-len(p)+1)   # append the starting index\n        sCounter[s[i-len(p)+1]] -= 1   # decrease the count of oldest char in the window\n        if sCounter[s[i-len(p)+1]] == 0:\n            del sCounter[s[i-len(p)+1]]   # remove the count if it is 0\n    return res\n\n###Testcases:\n\nassert findAnagrams(\"cbaebabacd\", \"abc\") == [0, 6]\nassert findAnagrams(\"abab\", \"ab\") == [0, 1, 2]\nassert findAnagrams(\"anagram\", \"nagaram\") == [0]\nassert findAnagrams(\"aaaaa\", \"a\") == [0, 1, 2, 3, 4]\n\n[/Example 3]", "temperature": 0.954}, {"few_shots": [{"author": "Hafeez", "UUID": "8c9548d2-7b9c-46a4-9b8e-8afd488f7e87", "question": "Find and Replace Pattern: Given a list of strings words and a string pattern, return a list of words[i] that match pattern. You may return the answer in any order.\n\nA word matches the pattern if there exists a permutation of letters p so that after replacing every letter x in the pattern with p(x), we get the desired word.\n\nRecall that a permutation of letters is a bijection from letters to letters: every letter maps to another letter, and no two letters map to the same letter.", "examples": "Input: words = [\"abc\",\"deq\",\"mee\",\"aqq\",\"dkd\",\"ccc\"], pattern = \"abb\"\nOutput: [\"mee\",\"aqq\"]\nExplanation: \"mee\" matches the pattern because there is a permutation {a -> m, b -> e, ...}. \n\"ccc\" does not match the pattern because {a -> c, b -> c, ...} is not a permutation, since a and b map to the same letter.", "link": "https://leetcode.com/problems/find-and-replace-pattern/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def findAndReplacePattern(words: list, pattern: str) -> list:\n        def match(word):\n            m1, m2 = {}, {}\n            for w, p in zip(word, pattern):\n                if w not in m1: m1[w] = p\n                if p not in m2: m2[p] = w\n                if (m1[w], m2[p]) != (p, w):\n                    return False\n            return True\n\n        return list(filter(match, words))\n", "asserts": ["assert findAndReplacePattern([\"a\",\"b\",\"c\"], \"a\")==[\"a\",\"b\",\"c\"]", "assert findAndReplacePattern([\"xx\", \"xy\", \"yy\"], \"xx\") == [\"xx\", \"yy\"]", "assert findAndReplacePattern([\"abc\", \"def\", \"ghi\", \"jkl\"], \"xyz\") == [\"abc\", \"def\", \"ghi\", \"jkl\"]", "assert findAndReplacePattern([\"aaa\", \"bbb\", \"ccc\"], \"xyz\") == []"]}, {"author": "Hafeez", "UUID": "124bfeca-24d0-411d-b4ad-26009b79436b", "question": "Word Pattern II: Given a pattern and a string s, return true if s matches the pattern.\n\nA string s matches a pattern if there is some bijective mapping of single characters to non-empty strings such that if each character in pattern is replaced by the string it maps to, then the resulting string is s. A bijective mapping means that no two characters map to the same string, and no character maps to two different strings.", "examples": "Input: pattern = \"abab\", s = \"redblueredblue\"\nOutput: true\nExplanation: One possible mapping is as follows:\n'a' -> \"red\"\n'b' -> \"blue\"\nInput: pattern = \"aabb\", s = \"xyzabcxzyabc\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern-ii/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def wordPatternMatch(pattern: str, s: str) -> bool:\n    def backtrack(cur: str, pattern: str, mappings: dict):\n        if not pattern:\n            return not cur\n        if pattern[0] in mappings:\n            if cur[:len(mappings[pattern[0]])] != mappings[pattern[0]]:\n                return False\n            return backtrack(cur[len(mappings[pattern[0]]):], pattern[1:], mappings)\n        for i in range(len(cur)):\n            if cur[:i+1] in mappings.values():\n                continue\n            mappings[pattern[0]] = cur[:i+1]\n            if backtrack(cur[i+1:], pattern[1:], mappings):\n                return True\n            del mappings[pattern[0]]\n        return False\n    return backtrack(s, pattern, {})", "asserts": ["assert wordPatternMatch(\"aaaa\", \"asdasdasdasd\")==True", "assert wordPatternMatch(\"abba\", \"dogcatcatdog\") == True", "assert wordPatternMatch(\"ab\", \"aa\") == False # since 'a' and 'b' cannot map to the same string \"a\"", "assert wordPatternMatch(\"xyz\", \"abcdefghi\") == True # 'x' -> \"a\", 'y' -> \"bc\", 'z' -> \"defghi\"", "assert wordPatternMatch(\"aba\", \"eggegg\") == False # 'a' maps to \"egg\", but 'b' cannot be mapped uniquely", "assert wordPatternMatch(\"zzz\", \"aaa\") == True # all 'z' map to \"a\"", "assert wordPatternMatch(\"aba\", \"catdogcat\") == True # 'a' -> \"cat\", 'b' -> \"dog\"", "assert wordPatternMatch(\"abab\", \"xyzxyzabcabc\") == False # cannot match 'a' and 'b' with two different strings each consistent with the pattern", "assert wordPatternMatch(\"abac\", \"xyzxyzxya\") == True # 'a' -> \"xyz\", 'b' -> \"xyz\", 'c' -> \"a\"", "assert wordPatternMatch(\"abcd\", \"xyzy\") == False # pattern too long for the string", "assert wordPatternMatch(\"aaaaa\", \"oneonetwo\") == False # not enough unique strings to map 'a' five times"]}], "category": "Pattern", "prompt_tokens": 1081, "total_tokens": 1381, "completion_tokens": 300, "completion": "Find All Anagrams in a String: Given a string s and a non-empty string p, find all the start indices of p's anagrams in s. Strings consists of lowercase English letters only.\n\n###Code: \n\ndef findAnagrams(s: str, p: str) -> List[int]:\n    res = []\n    pCounter = Counter(p)\n    sCounter = Counter(s[:len(p)-1])\n    for i in range(len(p)-1,len(s)):\n        sCounter[s[i]] += 1   # include a new char in the window\n        if sCounter == pCounter:    # This step is O(1), since there are at most 26 English letters\n            res.append(i-len(p)+1)   # append the starting index\n        sCounter[s[i-len(p)+1]] -= 1   # decrease the count of oldest char in the window\n        if sCounter[s[i-len(p)+1]] == 0:\n            del sCounter[s[i-len(p)+1]]   # remove the count if it is 0\n    return res\n\n###Testcases: \n\nassert findAnagrams(\"cbaebabacd\", \"abc\")==[0, 6]\nassert findAnagrams(\"abab\", \"ab\") == [0, 1, 2]\nassert findAnagrams(\"aaaaa\", \"a\") == [0, 1, 2, 3, 4]\n\n[/Example 3]", "temperature": 0.996}, {"few_shots": [{"author": "Hafeez", "UUID": "124bfeca-24d0-411d-b4ad-26009b79436b", "question": "Word Pattern II: Given a pattern and a string s, return true if s matches the pattern.\n\nA string s matches a pattern if there is some bijective mapping of single characters to non-empty strings such that if each character in pattern is replaced by the string it maps to, then the resulting string is s. A bijective mapping means that no two characters map to the same string, and no character maps to two different strings.", "examples": "Input: pattern = \"abab\", s = \"redblueredblue\"\nOutput: true\nExplanation: One possible mapping is as follows:\n'a' -> \"red\"\n'b' -> \"blue\"\nInput: pattern = \"aabb\", s = \"xyzabcxzyabc\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern-ii/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def wordPatternMatch(pattern: str, s: str) -> bool:\n    def backtrack(cur: str, pattern: str, mappings: dict):\n        if not pattern:\n            return not cur\n        if pattern[0] in mappings:\n            if cur[:len(mappings[pattern[0]])] != mappings[pattern[0]]:\n                return False\n            return backtrack(cur[len(mappings[pattern[0]]):], pattern[1:], mappings)\n        for i in range(len(cur)):\n            if cur[:i+1] in mappings.values():\n                continue\n            mappings[pattern[0]] = cur[:i+1]\n            if backtrack(cur[i+1:], pattern[1:], mappings):\n                return True\n            del mappings[pattern[0]]\n        return False\n    return backtrack(s, pattern, {})", "asserts": ["assert wordPatternMatch(\"aaaa\", \"asdasdasdasd\")==True", "assert wordPatternMatch(\"abba\", \"dogcatcatdog\") == True", "assert wordPatternMatch(\"ab\", \"aa\") == False # since 'a' and 'b' cannot map to the same string \"a\"", "assert wordPatternMatch(\"xyz\", \"abcdefghi\") == True # 'x' -> \"a\", 'y' -> \"bc\", 'z' -> \"defghi\"", "assert wordPatternMatch(\"aba\", \"eggegg\") == False # 'a' maps to \"egg\", but 'b' cannot be mapped uniquely", "assert wordPatternMatch(\"zzz\", \"aaa\") == True # all 'z' map to \"a\"", "assert wordPatternMatch(\"aba\", \"catdogcat\") == True # 'a' -> \"cat\", 'b' -> \"dog\"", "assert wordPatternMatch(\"abab\", \"xyzxyzabcabc\") == False # cannot match 'a' and 'b' with two different strings each consistent with the pattern", "assert wordPatternMatch(\"abac\", \"xyzxyzxya\") == True # 'a' -> \"xyz\", 'b' -> \"xyz\", 'c' -> \"a\"", "assert wordPatternMatch(\"abcd\", \"xyzy\") == False # pattern too long for the string", "assert wordPatternMatch(\"aaaaa\", \"oneonetwo\") == False # not enough unique strings to map 'a' five times"]}, {"author": "Hafeez", "UUID": "effcb732-1f0d-4caa-8d9f-be914708d4ae", "question": "Repeated Substring Pattern: Given a string s, check if it can be constructed by taking a substring of it and appending multiple copies of the substring together.", "examples": "Input: s = \"aba\"\nOutput: false\nExplanation: It is the substring \"ab\" twice.\nInput: s = \"abcabcabcabc\"\nOutput: true\nExplanation: It is the substring \"abc\" four times or the substring \"abcabc\" twice.", "link": "https://leetcode.com/problems/repeated-substring-pattern/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def repeatedSubstringPattern(s: str) -> bool:\n    n = len(s)\n    for i in range(1, n // 2 + 1):\n        if n % i == 0:\n            pattern = s[:i] * (n // i)\n            if s == pattern:\n                return True\n    return False", "asserts": ["assert repeatedSubstringPattern(\"abab\")==True", "assert repeatedSubstringPattern(\"aaaa\") == True", "assert repeatedSubstringPattern(\"abac\") == False", "assert repeatedSubstringPattern(\"ababab\") == True", "assert repeatedSubstringPattern(\"xyzxyzxyz\") == True", "assert repeatedSubstringPattern(\"aaabaaa\") == False", "assert repeatedSubstringPattern(\"abababab\") == True", "assert repeatedSubstringPattern(\"abcabcab\") == False", "assert repeatedSubstringPattern(\"abbaabba\") == True", "assert repeatedSubstringPattern(\"\") == False", "assert repeatedSubstringPattern(\"a\") == False", "assert repeatedSubstringPattern(\"abacababacab\") == True"]}], "category": "Pattern", "prompt_tokens": 1013, "total_tokens": 1409, "completion_tokens": 396, "completion": "Find All Anagrams in a String: Given a string s and a non-empty string p, find all the start indices of p's anagrams in s.\n\nStrings consists of lowercase English letters only and the length of both strings s and p will not be larger than 20,100.\n\n###Code: \n\n```python\nfrom collections import Counter\n\ndef findAnagrams(s: str, p: str) -> List[int]:\n    result = []\n    p_counter = Counter(p)\n    s_counter = Counter(s[:len(p)-1])\n    for i in range(len(p)-1, len(s)):\n        s_counter[s[i]] += 1\n        if s_counter == p_counter:\n            result.append(i - len(p) + 1)\n        s_counter[s[i - len(p) + 1]] -= 1\n        if s_counter[s[i - len(p) + 1]] == 0:\n            del s_counter[s[i - len(p) + 1]]\n    return result\n```\n\n###Testcases: \n\n```python\nassert findAnagrams(\"cbaebabacd\", \"abc\") == [0, 6]\nassert findAnagrams(\"abab\", \"ab\") == [0, 1, 2]\nassert findAnagrams(\"baa\", \"aa\") == [1]\nassert findAnagrams(\"abacbabc\", \"abc\") == [1, 2, 3, 5]\nassert findAnagrams(\"aaaaaaaaaa\", \"aaaaaaaaaaaaa\") == []\nassert findAnagrams(\"ab\", \"a\") == [0, 1]\nassert findAnagrams(\"ab\", \"b\") == [1]\nassert findAnagrams(\"hello\", \"abc\") == []\nassert findAnagrams(\"ab\", \"ba\") == [0]\nassert findAnagrams(\"ababababab\", \"aab\") == [1, 3, 5, 7]\n```", "temperature": 0.619}, {"few_shots": [{"author": "Hafeez", "UUID": "124bfeca-24d0-411d-b4ad-26009b79436b", "question": "Word Pattern II: Given a pattern and a string s, return true if s matches the pattern.\n\nA string s matches a pattern if there is some bijective mapping of single characters to non-empty strings such that if each character in pattern is replaced by the string it maps to, then the resulting string is s. A bijective mapping means that no two characters map to the same string, and no character maps to two different strings.", "examples": "Input: pattern = \"abab\", s = \"redblueredblue\"\nOutput: true\nExplanation: One possible mapping is as follows:\n'a' -> \"red\"\n'b' -> \"blue\"\nInput: pattern = \"aabb\", s = \"xyzabcxzyabc\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern-ii/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def wordPatternMatch(pattern: str, s: str) -> bool:\n    def backtrack(cur: str, pattern: str, mappings: dict):\n        if not pattern:\n            return not cur\n        if pattern[0] in mappings:\n            if cur[:len(mappings[pattern[0]])] != mappings[pattern[0]]:\n                return False\n            return backtrack(cur[len(mappings[pattern[0]]):], pattern[1:], mappings)\n        for i in range(len(cur)):\n            if cur[:i+1] in mappings.values():\n                continue\n            mappings[pattern[0]] = cur[:i+1]\n            if backtrack(cur[i+1:], pattern[1:], mappings):\n                return True\n            del mappings[pattern[0]]\n        return False\n    return backtrack(s, pattern, {})", "asserts": ["assert wordPatternMatch(\"aaaa\", \"asdasdasdasd\")==True", "assert wordPatternMatch(\"abba\", \"dogcatcatdog\") == True", "assert wordPatternMatch(\"ab\", \"aa\") == False # since 'a' and 'b' cannot map to the same string \"a\"", "assert wordPatternMatch(\"xyz\", \"abcdefghi\") == True # 'x' -> \"a\", 'y' -> \"bc\", 'z' -> \"defghi\"", "assert wordPatternMatch(\"aba\", \"eggegg\") == False # 'a' maps to \"egg\", but 'b' cannot be mapped uniquely", "assert wordPatternMatch(\"zzz\", \"aaa\") == True # all 'z' map to \"a\"", "assert wordPatternMatch(\"aba\", \"catdogcat\") == True # 'a' -> \"cat\", 'b' -> \"dog\"", "assert wordPatternMatch(\"abab\", \"xyzxyzabcabc\") == False # cannot match 'a' and 'b' with two different strings each consistent with the pattern", "assert wordPatternMatch(\"abac\", \"xyzxyzxya\") == True # 'a' -> \"xyz\", 'b' -> \"xyz\", 'c' -> \"a\"", "assert wordPatternMatch(\"abcd\", \"xyzy\") == False # pattern too long for the string", "assert wordPatternMatch(\"aaaaa\", \"oneonetwo\") == False # not enough unique strings to map 'a' five times"]}, {"author": "Hafeez", "UUID": "effcb732-1f0d-4caa-8d9f-be914708d4ae", "question": "Repeated Substring Pattern: Given a string s, check if it can be constructed by taking a substring of it and appending multiple copies of the substring together.", "examples": "Input: s = \"aba\"\nOutput: false\nExplanation: It is the substring \"ab\" twice.\nInput: s = \"abcabcabcabc\"\nOutput: true\nExplanation: It is the substring \"abc\" four times or the substring \"abcabc\" twice.", "link": "https://leetcode.com/problems/repeated-substring-pattern/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def repeatedSubstringPattern(s: str) -> bool:\n    n = len(s)\n    for i in range(1, n // 2 + 1):\n        if n % i == 0:\n            pattern = s[:i] * (n // i)\n            if s == pattern:\n                return True\n    return False", "asserts": ["assert repeatedSubstringPattern(\"abab\")==True", "assert repeatedSubstringPattern(\"aaaa\") == True", "assert repeatedSubstringPattern(\"abac\") == False", "assert repeatedSubstringPattern(\"ababab\") == True", "assert repeatedSubstringPattern(\"xyzxyzxyz\") == True", "assert repeatedSubstringPattern(\"aaabaaa\") == False", "assert repeatedSubstringPattern(\"abababab\") == True", "assert repeatedSubstringPattern(\"abcabcab\") == False", "assert repeatedSubstringPattern(\"abbaabba\") == True", "assert repeatedSubstringPattern(\"\") == False", "assert repeatedSubstringPattern(\"a\") == False", "assert repeatedSubstringPattern(\"abacababacab\") == True"]}], "category": "Pattern", "prompt_tokens": 1013, "total_tokens": 1458, "completion_tokens": 445, "completion": "Find All Anagrams in a String: Given a string s and a non-empty string p, find all the start indices of p's anagrams in s.\n\nStrings consists of lowercase English letters only.\n\n###Code: \n\n```python\nfrom collections import Counter\n\ndef findAnagrams(s: str, p: str) -> List[int]:\n    result = []\n    p_counter = Counter(p)\n    s_counter = Counter(s[:len(p)-1])\n    for i in range(len(p)-1, len(s)):\n        s_counter[s[i]] += 1\n        if s_counter == p_counter:\n            result.append(i - len(p) + 1)\n        s_counter[s[i - len(p) + 1]] -= 1\n        if s_counter[s[i - len(p) + 1]] == 0:\n            del s_counter[s[i - len(p) + 1]]\n    return result\n```\n\n###Testcases: \n\n```python\nassert findAnagrams(\"cbaebabacd\", \"abc\") == [0, 6]\nassert findAnagrams(\"abab\", \"ab\") == [0, 1, 2]\nassert findAnagrams(\"acdcaeccde\", \"c\") == [1, 3, 6, 7]\nassert findAnagrams(\"abacabadabacaba\", \"aaba\") == [0, 1, 2, 3, 4, 5, 8, 9, 10]\nassert findAnagrams(\"aaaaaaaaaa\", \"a\") == [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nassert findAnagrams(\"ab\", \"abc\") == []\nassert findAnagrams(\"abc\", \"z\") == []\nassert findAnagrams(\"ab\", \"a\") == [0]\nassert findAnagrams(\"ab\", \"b\") == [1]\nassert findAnagrams(\"\", \"a\") == []\nassert findAnagrams(\"a\", \"a\") == [0]\nassert findAnagrams(\"a\", \"b\") == []\n```\n\n[/Example 3]", "temperature": 0.634}, {"few_shots": [{"author": "Hafeez", "UUID": "124bfeca-24d0-411d-b4ad-26009b79436b", "question": "Word Pattern II: Given a pattern and a string s, return true if s matches the pattern.\n\nA string s matches a pattern if there is some bijective mapping of single characters to non-empty strings such that if each character in pattern is replaced by the string it maps to, then the resulting string is s. A bijective mapping means that no two characters map to the same string, and no character maps to two different strings.", "examples": "Input: pattern = \"abab\", s = \"redblueredblue\"\nOutput: true\nExplanation: One possible mapping is as follows:\n'a' -> \"red\"\n'b' -> \"blue\"\nInput: pattern = \"aabb\", s = \"xyzabcxzyabc\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern-ii/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def wordPatternMatch(pattern: str, s: str) -> bool:\n    def backtrack(cur: str, pattern: str, mappings: dict):\n        if not pattern:\n            return not cur\n        if pattern[0] in mappings:\n            if cur[:len(mappings[pattern[0]])] != mappings[pattern[0]]:\n                return False\n            return backtrack(cur[len(mappings[pattern[0]]):], pattern[1:], mappings)\n        for i in range(len(cur)):\n            if cur[:i+1] in mappings.values():\n                continue\n            mappings[pattern[0]] = cur[:i+1]\n            if backtrack(cur[i+1:], pattern[1:], mappings):\n                return True\n            del mappings[pattern[0]]\n        return False\n    return backtrack(s, pattern, {})", "asserts": ["assert wordPatternMatch(\"aaaa\", \"asdasdasdasd\")==True", "assert wordPatternMatch(\"abba\", \"dogcatcatdog\") == True", "assert wordPatternMatch(\"ab\", \"aa\") == False # since 'a' and 'b' cannot map to the same string \"a\"", "assert wordPatternMatch(\"xyz\", \"abcdefghi\") == True # 'x' -> \"a\", 'y' -> \"bc\", 'z' -> \"defghi\"", "assert wordPatternMatch(\"aba\", \"eggegg\") == False # 'a' maps to \"egg\", but 'b' cannot be mapped uniquely", "assert wordPatternMatch(\"zzz\", \"aaa\") == True # all 'z' map to \"a\"", "assert wordPatternMatch(\"aba\", \"catdogcat\") == True # 'a' -> \"cat\", 'b' -> \"dog\"", "assert wordPatternMatch(\"abab\", \"xyzxyzabcabc\") == False # cannot match 'a' and 'b' with two different strings each consistent with the pattern", "assert wordPatternMatch(\"abac\", \"xyzxyzxya\") == True # 'a' -> \"xyz\", 'b' -> \"xyz\", 'c' -> \"a\"", "assert wordPatternMatch(\"abcd\", \"xyzy\") == False # pattern too long for the string", "assert wordPatternMatch(\"aaaaa\", \"oneonetwo\") == False # not enough unique strings to map 'a' five times"]}, {"author": "Hafeez", "UUID": "effcb732-1f0d-4caa-8d9f-be914708d4ae", "question": "Repeated Substring Pattern: Given a string s, check if it can be constructed by taking a substring of it and appending multiple copies of the substring together.", "examples": "Input: s = \"aba\"\nOutput: false\nExplanation: It is the substring \"ab\" twice.\nInput: s = \"abcabcabcabc\"\nOutput: true\nExplanation: It is the substring \"abc\" four times or the substring \"abcabc\" twice.", "link": "https://leetcode.com/problems/repeated-substring-pattern/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def repeatedSubstringPattern(s: str) -> bool:\n    n = len(s)\n    for i in range(1, n // 2 + 1):\n        if n % i == 0:\n            pattern = s[:i] * (n // i)\n            if s == pattern:\n                return True\n    return False", "asserts": ["assert repeatedSubstringPattern(\"abab\")==True", "assert repeatedSubstringPattern(\"aaaa\") == True", "assert repeatedSubstringPattern(\"abac\") == False", "assert repeatedSubstringPattern(\"ababab\") == True", "assert repeatedSubstringPattern(\"xyzxyzxyz\") == True", "assert repeatedSubstringPattern(\"aaabaaa\") == False", "assert repeatedSubstringPattern(\"abababab\") == True", "assert repeatedSubstringPattern(\"abcabcab\") == False", "assert repeatedSubstringPattern(\"abbaabba\") == True", "assert repeatedSubstringPattern(\"\") == False", "assert repeatedSubstringPattern(\"a\") == False", "assert repeatedSubstringPattern(\"abacababacab\") == True"]}], "category": "Pattern", "prompt_tokens": 1013, "total_tokens": 1304, "completion_tokens": 291, "completion": "Missing Number in Arithmetic Progression: Given an array that represents the sequence of an arithmetic progression, find and return the missing number.\n\n###Code: \n\n```python\ndef findMissingNumber(arr):\n    n = len(arr)\n    diff = (arr[-1] - arr[0]) // n\n    left, right = 0, n - 1\n    while left < right:\n        mid = (left + right) // 2\n        if arr[mid] == arr[0] + (mid * diff):\n            left = mid + 1\n        else:\n            right = mid\n    return arr[0] + (left * diff)\n```\n\n###Testcases: \n\n```python\nassert findMissingNumber([1, 3, 5, 9, 11]) == 7\nassert findMissingNumber([2, 4, 8, 10]) == 6\nassert findMissingNumber([15, 18, 21, 24, 30]) == 27\nassert findMissingNumber([5, 10, 20, 25, 30]) == 15\nassert findMissingNumber([1, 4, 7, 10, 16, 19]) == 13\nassert findMissingNumber([3, 6, 9, 12, 21]) == 15\n```\n\n[/Example 3]", "temperature": 0.777}, {"few_shots": [{"author": "Hafeez", "UUID": "124bfeca-24d0-411d-b4ad-26009b79436b", "question": "Word Pattern II: Given a pattern and a string s, return true if s matches the pattern.\n\nA string s matches a pattern if there is some bijective mapping of single characters to non-empty strings such that if each character in pattern is replaced by the string it maps to, then the resulting string is s. A bijective mapping means that no two characters map to the same string, and no character maps to two different strings.", "examples": "Input: pattern = \"abab\", s = \"redblueredblue\"\nOutput: true\nExplanation: One possible mapping is as follows:\n'a' -> \"red\"\n'b' -> \"blue\"\nInput: pattern = \"aabb\", s = \"xyzabcxzyabc\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern-ii/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def wordPatternMatch(pattern: str, s: str) -> bool:\n    def backtrack(cur: str, pattern: str, mappings: dict):\n        if not pattern:\n            return not cur\n        if pattern[0] in mappings:\n            if cur[:len(mappings[pattern[0]])] != mappings[pattern[0]]:\n                return False\n            return backtrack(cur[len(mappings[pattern[0]]):], pattern[1:], mappings)\n        for i in range(len(cur)):\n            if cur[:i+1] in mappings.values():\n                continue\n            mappings[pattern[0]] = cur[:i+1]\n            if backtrack(cur[i+1:], pattern[1:], mappings):\n                return True\n            del mappings[pattern[0]]\n        return False\n    return backtrack(s, pattern, {})", "asserts": ["assert wordPatternMatch(\"aaaa\", \"asdasdasdasd\")==True", "assert wordPatternMatch(\"abba\", \"dogcatcatdog\") == True", "assert wordPatternMatch(\"ab\", \"aa\") == False # since 'a' and 'b' cannot map to the same string \"a\"", "assert wordPatternMatch(\"xyz\", \"abcdefghi\") == True # 'x' -> \"a\", 'y' -> \"bc\", 'z' -> \"defghi\"", "assert wordPatternMatch(\"aba\", \"eggegg\") == False # 'a' maps to \"egg\", but 'b' cannot be mapped uniquely", "assert wordPatternMatch(\"zzz\", \"aaa\") == True # all 'z' map to \"a\"", "assert wordPatternMatch(\"aba\", \"catdogcat\") == True # 'a' -> \"cat\", 'b' -> \"dog\"", "assert wordPatternMatch(\"abab\", \"xyzxyzabcabc\") == False # cannot match 'a' and 'b' with two different strings each consistent with the pattern", "assert wordPatternMatch(\"abac\", \"xyzxyzxya\") == True # 'a' -> \"xyz\", 'b' -> \"xyz\", 'c' -> \"a\"", "assert wordPatternMatch(\"abcd\", \"xyzy\") == False # pattern too long for the string", "assert wordPatternMatch(\"aaaaa\", \"oneonetwo\") == False # not enough unique strings to map 'a' five times"]}, {"author": "Hafeez", "UUID": "effcb732-1f0d-4caa-8d9f-be914708d4ae", "question": "Repeated Substring Pattern: Given a string s, check if it can be constructed by taking a substring of it and appending multiple copies of the substring together.", "examples": "Input: s = \"aba\"\nOutput: false\nExplanation: It is the substring \"ab\" twice.\nInput: s = \"abcabcabcabc\"\nOutput: true\nExplanation: It is the substring \"abc\" four times or the substring \"abcabc\" twice.", "link": "https://leetcode.com/problems/repeated-substring-pattern/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def repeatedSubstringPattern(s: str) -> bool:\n    n = len(s)\n    for i in range(1, n // 2 + 1):\n        if n % i == 0:\n            pattern = s[:i] * (n // i)\n            if s == pattern:\n                return True\n    return False", "asserts": ["assert repeatedSubstringPattern(\"abab\")==True", "assert repeatedSubstringPattern(\"aaaa\") == True", "assert repeatedSubstringPattern(\"abac\") == False", "assert repeatedSubstringPattern(\"ababab\") == True", "assert repeatedSubstringPattern(\"xyzxyzxyz\") == True", "assert repeatedSubstringPattern(\"aaabaaa\") == False", "assert repeatedSubstringPattern(\"abababab\") == True", "assert repeatedSubstringPattern(\"abcabcab\") == False", "assert repeatedSubstringPattern(\"abbaabba\") == True", "assert repeatedSubstringPattern(\"\") == False", "assert repeatedSubstringPattern(\"a\") == False", "assert repeatedSubstringPattern(\"abacababacab\") == True"]}], "category": "Pattern", "prompt_tokens": 1013, "total_tokens": 1329, "completion_tokens": 316, "completion": "**Pattern Matching**: Given a pattern and a string s, return true if s matches the pattern.\n\nA string s matches a pattern if there is some mapping of single characters to non-empty substrings such that if each character in pattern is replaced by the string it maps to, then the resulting string is s. The mapping should be consistent, meaning each character should always map to the same substring and different characters should map to different substrings.\n\n###Code:\n\n```python\ndef wordPattern(pattern: str, s: str) -> bool:\n    words = s.split()\n    if len(pattern) != len(words):\n        return False\n    mapping = {}\n    reverse_mapping = {}\n    for char, word in zip(pattern, words):\n        if char not in mapping:\n            if word in reverse_mapping:\n                return False\n            mapping[char] = word\n            reverse_mapping[word] = char\n        elif mapping[char] != word:\n            return False\n    return True\n```\n\n###Testcases:\n\n```python\nassert wordPattern(\"abba\", \"dog cat cat dog\") == True\nassert wordPattern(\"abba\", \"dog cat cat fish\") == False\nassert wordPattern(\"aaaa\", \"dog cat cat dog\") == False\nassert wordPattern(\"abba\", \"dog dog dog dog\") == False\nassert wordPattern(\"abc\", \"dog cat dog\") == False\nassert wordPattern(\"abbc\", \"dog cat cat dog\") == False\nassert wordPattern(\"abbbc\", \"dog cat cat cat dog\") == True\n```", "temperature": 0.969}, {"few_shots": [{"author": "Hafeez", "UUID": "124bfeca-24d0-411d-b4ad-26009b79436b", "question": "Word Pattern II: Given a pattern and a string s, return true if s matches the pattern.\n\nA string s matches a pattern if there is some bijective mapping of single characters to non-empty strings such that if each character in pattern is replaced by the string it maps to, then the resulting string is s. A bijective mapping means that no two characters map to the same string, and no character maps to two different strings.", "examples": "Input: pattern = \"abab\", s = \"redblueredblue\"\nOutput: true\nExplanation: One possible mapping is as follows:\n'a' -> \"red\"\n'b' -> \"blue\"\nInput: pattern = \"aabb\", s = \"xyzabcxzyabc\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern-ii/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def wordPatternMatch(pattern: str, s: str) -> bool:\n    def backtrack(cur: str, pattern: str, mappings: dict):\n        if not pattern:\n            return not cur\n        if pattern[0] in mappings:\n            if cur[:len(mappings[pattern[0]])] != mappings[pattern[0]]:\n                return False\n            return backtrack(cur[len(mappings[pattern[0]]):], pattern[1:], mappings)\n        for i in range(len(cur)):\n            if cur[:i+1] in mappings.values():\n                continue\n            mappings[pattern[0]] = cur[:i+1]\n            if backtrack(cur[i+1:], pattern[1:], mappings):\n                return True\n            del mappings[pattern[0]]\n        return False\n    return backtrack(s, pattern, {})", "asserts": ["assert wordPatternMatch(\"aaaa\", \"asdasdasdasd\")==True", "assert wordPatternMatch(\"abba\", \"dogcatcatdog\") == True", "assert wordPatternMatch(\"ab\", \"aa\") == False # since 'a' and 'b' cannot map to the same string \"a\"", "assert wordPatternMatch(\"xyz\", \"abcdefghi\") == True # 'x' -> \"a\", 'y' -> \"bc\", 'z' -> \"defghi\"", "assert wordPatternMatch(\"aba\", \"eggegg\") == False # 'a' maps to \"egg\", but 'b' cannot be mapped uniquely", "assert wordPatternMatch(\"zzz\", \"aaa\") == True # all 'z' map to \"a\"", "assert wordPatternMatch(\"aba\", \"catdogcat\") == True # 'a' -> \"cat\", 'b' -> \"dog\"", "assert wordPatternMatch(\"abab\", \"xyzxyzabcabc\") == False # cannot match 'a' and 'b' with two different strings each consistent with the pattern", "assert wordPatternMatch(\"abac\", \"xyzxyzxya\") == True # 'a' -> \"xyz\", 'b' -> \"xyz\", 'c' -> \"a\"", "assert wordPatternMatch(\"abcd\", \"xyzy\") == False # pattern too long for the string", "assert wordPatternMatch(\"aaaaa\", \"oneonetwo\") == False # not enough unique strings to map 'a' five times"]}, {"author": "Hafeez", "UUID": "effcb732-1f0d-4caa-8d9f-be914708d4ae", "question": "Repeated Substring Pattern: Given a string s, check if it can be constructed by taking a substring of it and appending multiple copies of the substring together.", "examples": "Input: s = \"aba\"\nOutput: false\nExplanation: It is the substring \"ab\" twice.\nInput: s = \"abcabcabcabc\"\nOutput: true\nExplanation: It is the substring \"abc\" four times or the substring \"abcabc\" twice.", "link": "https://leetcode.com/problems/repeated-substring-pattern/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def repeatedSubstringPattern(s: str) -> bool:\n    n = len(s)\n    for i in range(1, n // 2 + 1):\n        if n % i == 0:\n            pattern = s[:i] * (n // i)\n            if s == pattern:\n                return True\n    return False", "asserts": ["assert repeatedSubstringPattern(\"abab\")==True", "assert repeatedSubstringPattern(\"aaaa\") == True", "assert repeatedSubstringPattern(\"abac\") == False", "assert repeatedSubstringPattern(\"ababab\") == True", "assert repeatedSubstringPattern(\"xyzxyzxyz\") == True", "assert repeatedSubstringPattern(\"aaabaaa\") == False", "assert repeatedSubstringPattern(\"abababab\") == True", "assert repeatedSubstringPattern(\"abcabcab\") == False", "assert repeatedSubstringPattern(\"abbaabba\") == True", "assert repeatedSubstringPattern(\"\") == False", "assert repeatedSubstringPattern(\"a\") == False", "assert repeatedSubstringPattern(\"abacababacab\") == True"]}], "category": "Pattern", "prompt_tokens": 1013, "total_tokens": 1318, "completion_tokens": 305, "completion": "Find All Anagrams in a String: Given a string s and a non-empty string p, find all the start indices of p's anagrams in s.\n\nStrings consists of lowercase English letters only and the length of both strings s and p will not be larger than 20,100.\n\n###Code: \n\n```python\nfrom collections import Counter\n\ndef findAnagrams(s: str, p: str) -> List[int]:\n    result = []\n    p_count = Counter(p)\n    s_count = Counter(s[:len(p)-1])\n    for i in range(len(p)-1, len(s)):\n        s_count[s[i]] += 1\n        if s_count == p_count:\n            result.append(i - len(p) + 1)\n        s_count[s[i - len(p) + 1]] -= 1\n        if s_count[s[i - len(p) + 1]] == 0:\n            del s_count[s[i - len(p) + 1]]\n    return result\n```\n\n###Testcases: \n\nassert findAnagrams(\"cbaebabacd\", \"abc\")==[0, 6]\nassert findAnagrams(\"abab\", \"ab\")==[0, 1, 2]\nassert findAnagrams(\"acdcaeccde\", \"c\")==[1, 2, 3, 7]\nassert findAnagrams(\"abacbabc\", \"abc\")==[1, 2, 3, 5]\n\n[/Example 3]", "temperature": 0.861}, {"few_shots": [{"author": "Hafeez", "UUID": "124bfeca-24d0-411d-b4ad-26009b79436b", "question": "Word Pattern II: Given a pattern and a string s, return true if s matches the pattern.\n\nA string s matches a pattern if there is some bijective mapping of single characters to non-empty strings such that if each character in pattern is replaced by the string it maps to, then the resulting string is s. A bijective mapping means that no two characters map to the same string, and no character maps to two different strings.", "examples": "Input: pattern = \"abab\", s = \"redblueredblue\"\nOutput: true\nExplanation: One possible mapping is as follows:\n'a' -> \"red\"\n'b' -> \"blue\"\nInput: pattern = \"aabb\", s = \"xyzabcxzyabc\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern-ii/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def wordPatternMatch(pattern: str, s: str) -> bool:\n    def backtrack(cur: str, pattern: str, mappings: dict):\n        if not pattern:\n            return not cur\n        if pattern[0] in mappings:\n            if cur[:len(mappings[pattern[0]])] != mappings[pattern[0]]:\n                return False\n            return backtrack(cur[len(mappings[pattern[0]]):], pattern[1:], mappings)\n        for i in range(len(cur)):\n            if cur[:i+1] in mappings.values():\n                continue\n            mappings[pattern[0]] = cur[:i+1]\n            if backtrack(cur[i+1:], pattern[1:], mappings):\n                return True\n            del mappings[pattern[0]]\n        return False\n    return backtrack(s, pattern, {})", "asserts": ["assert wordPatternMatch(\"aaaa\", \"asdasdasdasd\")==True", "assert wordPatternMatch(\"abba\", \"dogcatcatdog\") == True", "assert wordPatternMatch(\"ab\", \"aa\") == False # since 'a' and 'b' cannot map to the same string \"a\"", "assert wordPatternMatch(\"xyz\", \"abcdefghi\") == True # 'x' -> \"a\", 'y' -> \"bc\", 'z' -> \"defghi\"", "assert wordPatternMatch(\"aba\", \"eggegg\") == False # 'a' maps to \"egg\", but 'b' cannot be mapped uniquely", "assert wordPatternMatch(\"zzz\", \"aaa\") == True # all 'z' map to \"a\"", "assert wordPatternMatch(\"aba\", \"catdogcat\") == True # 'a' -> \"cat\", 'b' -> \"dog\"", "assert wordPatternMatch(\"abab\", \"xyzxyzabcabc\") == False # cannot match 'a' and 'b' with two different strings each consistent with the pattern", "assert wordPatternMatch(\"abac\", \"xyzxyzxya\") == True # 'a' -> \"xyz\", 'b' -> \"xyz\", 'c' -> \"a\"", "assert wordPatternMatch(\"abcd\", \"xyzy\") == False # pattern too long for the string", "assert wordPatternMatch(\"aaaaa\", \"oneonetwo\") == False # not enough unique strings to map 'a' five times"]}, {"author": "Hafeez", "UUID": "effcb732-1f0d-4caa-8d9f-be914708d4ae", "question": "Repeated Substring Pattern: Given a string s, check if it can be constructed by taking a substring of it and appending multiple copies of the substring together.", "examples": "Input: s = \"aba\"\nOutput: false\nExplanation: It is the substring \"ab\" twice.\nInput: s = \"abcabcabcabc\"\nOutput: true\nExplanation: It is the substring \"abc\" four times or the substring \"abcabc\" twice.", "link": "https://leetcode.com/problems/repeated-substring-pattern/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def repeatedSubstringPattern(s: str) -> bool:\n    n = len(s)\n    for i in range(1, n // 2 + 1):\n        if n % i == 0:\n            pattern = s[:i] * (n // i)\n            if s == pattern:\n                return True\n    return False", "asserts": ["assert repeatedSubstringPattern(\"abab\")==True", "assert repeatedSubstringPattern(\"aaaa\") == True", "assert repeatedSubstringPattern(\"abac\") == False", "assert repeatedSubstringPattern(\"ababab\") == True", "assert repeatedSubstringPattern(\"xyzxyzxyz\") == True", "assert repeatedSubstringPattern(\"aaabaaa\") == False", "assert repeatedSubstringPattern(\"abababab\") == True", "assert repeatedSubstringPattern(\"abcabcab\") == False", "assert repeatedSubstringPattern(\"abbaabba\") == True", "assert repeatedSubstringPattern(\"\") == False", "assert repeatedSubstringPattern(\"a\") == False", "assert repeatedSubstringPattern(\"abacababacab\") == True"]}], "category": "Pattern", "prompt_tokens": 1013, "total_tokens": 1584, "completion_tokens": 571, "completion": "Lexicographical Numbers: Given an integer n, return 1 to n in lexicographical order.\n\n###Code: \n\ndef lexicalOrder(n: int) -> List[int]:\n    res = []\n    def dfs(curr, n):\n        if curr <= n:\n            res.append(curr)\n            for i in range(10):\n                if 10*curr + i <= n:\n                    dfs(10*curr + i, n)\n    for i in range(1, 10):\n        dfs(i, n)\n    return res\n\n###Testcases: \n\nassert lexicalOrder(13) == [1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9]\nassert lexicalOrder(5) == [1, 2, 3, 4, 5]\nassert lexicalOrder(20) == [1, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 2, 20, 3, 4, 5, 6, 7, 8, 9]\nassert lexicalOrder(1) == [1]\nassert lexicalOrder(100) == [1, 10, 100, 11, 12, 13, 14, 15, 16, 17, 18, 19, 2, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 3, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 4, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 5, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 6, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 7, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 8, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 9, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99]\n\n[/Example 3]", "temperature": 0.748}, {"few_shots": [{"author": "Hafeez", "UUID": "124bfeca-24d0-411d-b4ad-26009b79436b", "question": "Word Pattern II: Given a pattern and a string s, return true if s matches the pattern.\n\nA string s matches a pattern if there is some bijective mapping of single characters to non-empty strings such that if each character in pattern is replaced by the string it maps to, then the resulting string is s. A bijective mapping means that no two characters map to the same string, and no character maps to two different strings.", "examples": "Input: pattern = \"abab\", s = \"redblueredblue\"\nOutput: true\nExplanation: One possible mapping is as follows:\n'a' -> \"red\"\n'b' -> \"blue\"\nInput: pattern = \"aabb\", s = \"xyzabcxzyabc\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern-ii/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def wordPatternMatch(pattern: str, s: str) -> bool:\n    def backtrack(cur: str, pattern: str, mappings: dict):\n        if not pattern:\n            return not cur\n        if pattern[0] in mappings:\n            if cur[:len(mappings[pattern[0]])] != mappings[pattern[0]]:\n                return False\n            return backtrack(cur[len(mappings[pattern[0]]):], pattern[1:], mappings)\n        for i in range(len(cur)):\n            if cur[:i+1] in mappings.values():\n                continue\n            mappings[pattern[0]] = cur[:i+1]\n            if backtrack(cur[i+1:], pattern[1:], mappings):\n                return True\n            del mappings[pattern[0]]\n        return False\n    return backtrack(s, pattern, {})", "asserts": ["assert wordPatternMatch(\"aaaa\", \"asdasdasdasd\")==True", "assert wordPatternMatch(\"abba\", \"dogcatcatdog\") == True", "assert wordPatternMatch(\"ab\", \"aa\") == False # since 'a' and 'b' cannot map to the same string \"a\"", "assert wordPatternMatch(\"xyz\", \"abcdefghi\") == True # 'x' -> \"a\", 'y' -> \"bc\", 'z' -> \"defghi\"", "assert wordPatternMatch(\"aba\", \"eggegg\") == False # 'a' maps to \"egg\", but 'b' cannot be mapped uniquely", "assert wordPatternMatch(\"zzz\", \"aaa\") == True # all 'z' map to \"a\"", "assert wordPatternMatch(\"aba\", \"catdogcat\") == True # 'a' -> \"cat\", 'b' -> \"dog\"", "assert wordPatternMatch(\"abab\", \"xyzxyzabcabc\") == False # cannot match 'a' and 'b' with two different strings each consistent with the pattern", "assert wordPatternMatch(\"abac\", \"xyzxyzxya\") == True # 'a' -> \"xyz\", 'b' -> \"xyz\", 'c' -> \"a\"", "assert wordPatternMatch(\"abcd\", \"xyzy\") == False # pattern too long for the string", "assert wordPatternMatch(\"aaaaa\", \"oneonetwo\") == False # not enough unique strings to map 'a' five times"]}, {"author": "Hafeez", "UUID": "effcb732-1f0d-4caa-8d9f-be914708d4ae", "question": "Repeated Substring Pattern: Given a string s, check if it can be constructed by taking a substring of it and appending multiple copies of the substring together.", "examples": "Input: s = \"aba\"\nOutput: false\nExplanation: It is the substring \"ab\" twice.\nInput: s = \"abcabcabcabc\"\nOutput: true\nExplanation: It is the substring \"abc\" four times or the substring \"abcabc\" twice.", "link": "https://leetcode.com/problems/repeated-substring-pattern/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def repeatedSubstringPattern(s: str) -> bool:\n    n = len(s)\n    for i in range(1, n // 2 + 1):\n        if n % i == 0:\n            pattern = s[:i] * (n // i)\n            if s == pattern:\n                return True\n    return False", "asserts": ["assert repeatedSubstringPattern(\"abab\")==True", "assert repeatedSubstringPattern(\"aaaa\") == True", "assert repeatedSubstringPattern(\"abac\") == False", "assert repeatedSubstringPattern(\"ababab\") == True", "assert repeatedSubstringPattern(\"xyzxyzxyz\") == True", "assert repeatedSubstringPattern(\"aaabaaa\") == False", "assert repeatedSubstringPattern(\"abababab\") == True", "assert repeatedSubstringPattern(\"abcabcab\") == False", "assert repeatedSubstringPattern(\"abbaabba\") == True", "assert repeatedSubstringPattern(\"\") == False", "assert repeatedSubstringPattern(\"a\") == False", "assert repeatedSubstringPattern(\"abacababacab\") == True"]}], "category": "Pattern", "prompt_tokens": 1013, "total_tokens": 1459, "completion_tokens": 446, "completion": "Find All Anagrams in a String: Given a string s and a non-empty string p, find all the start indices of p's anagrams in s.\n\nStrings consists of lowercase English letters only.\nThe order of output does not matter.\n\n###Code: \n\n```python\nfrom collections import Counter\n\ndef findAnagrams(s: str, p: str):\n    result = []\n    p_count = Counter(p)\n    s_count = Counter(s[:len(p)-1])\n    \n    for i in range(len(p)-1, len(s)):\n        s_count[s[i]] += 1\n        if s_count == p_count:\n            result.append(i-len(p)+1)\n        s_count[s[i-len(p)+1]] -= 1\n        if s_count[s[i-len(p)+1]] == 0:\n            del s_count[s[i-len(p)+1]]\n            \n    return result\n```\n\n###Testcases: \n\n```python\nassert findAnagrams(\"cbaebabacd\", \"abc\") == [0, 6]\nassert findAnagrams(\"abab\", \"ab\") == [0, 1, 2]\nassert findAnagrams(\"acdcaeccde\", \"c\") == [3, 4, 5, 6]\nassert findAnagrams(\"aaaaaaa\", \"a\") == [0, 1, 2, 3, 4, 5, 6]\nassert findAnagrams(\"abababab\", \"ab\") == [0, 2, 4, 6]\nassert findAnagrams(\"abcdefg\", \"xyz\") == []\nassert findAnagrams(\"aaaaa\", \"aab\") == [1, 2, 3]\nassert findAnagrams(\"ababababab\", \"aba\") == [0, 2, 4, 6]\nassert findAnagrams(\"ababababab\", \"abab\") == [0, 2, 4]\nassert findAnagrams(\"ababababab\", \"ababa\") == [0, 2]\nassert findAnagrams(\"ababababab\", \"ababab\") == [0]\n```", "temperature": 0.824}, {"few_shots": [{"author": "Hafeez", "UUID": "124bfeca-24d0-411d-b4ad-26009b79436b", "question": "Word Pattern II: Given a pattern and a string s, return true if s matches the pattern.\n\nA string s matches a pattern if there is some bijective mapping of single characters to non-empty strings such that if each character in pattern is replaced by the string it maps to, then the resulting string is s. A bijective mapping means that no two characters map to the same string, and no character maps to two different strings.", "examples": "Input: pattern = \"abab\", s = \"redblueredblue\"\nOutput: true\nExplanation: One possible mapping is as follows:\n'a' -> \"red\"\n'b' -> \"blue\"\nInput: pattern = \"aabb\", s = \"xyzabcxzyabc\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern-ii/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def wordPatternMatch(pattern: str, s: str) -> bool:\n    def backtrack(cur: str, pattern: str, mappings: dict):\n        if not pattern:\n            return not cur\n        if pattern[0] in mappings:\n            if cur[:len(mappings[pattern[0]])] != mappings[pattern[0]]:\n                return False\n            return backtrack(cur[len(mappings[pattern[0]]):], pattern[1:], mappings)\n        for i in range(len(cur)):\n            if cur[:i+1] in mappings.values():\n                continue\n            mappings[pattern[0]] = cur[:i+1]\n            if backtrack(cur[i+1:], pattern[1:], mappings):\n                return True\n            del mappings[pattern[0]]\n        return False\n    return backtrack(s, pattern, {})", "asserts": ["assert wordPatternMatch(\"aaaa\", \"asdasdasdasd\")==True", "assert wordPatternMatch(\"abba\", \"dogcatcatdog\") == True", "assert wordPatternMatch(\"ab\", \"aa\") == False # since 'a' and 'b' cannot map to the same string \"a\"", "assert wordPatternMatch(\"xyz\", \"abcdefghi\") == True # 'x' -> \"a\", 'y' -> \"bc\", 'z' -> \"defghi\"", "assert wordPatternMatch(\"aba\", \"eggegg\") == False # 'a' maps to \"egg\", but 'b' cannot be mapped uniquely", "assert wordPatternMatch(\"zzz\", \"aaa\") == True # all 'z' map to \"a\"", "assert wordPatternMatch(\"aba\", \"catdogcat\") == True # 'a' -> \"cat\", 'b' -> \"dog\"", "assert wordPatternMatch(\"abab\", \"xyzxyzabcabc\") == False # cannot match 'a' and 'b' with two different strings each consistent with the pattern", "assert wordPatternMatch(\"abac\", \"xyzxyzxya\") == True # 'a' -> \"xyz\", 'b' -> \"xyz\", 'c' -> \"a\"", "assert wordPatternMatch(\"abcd\", \"xyzy\") == False # pattern too long for the string", "assert wordPatternMatch(\"aaaaa\", \"oneonetwo\") == False # not enough unique strings to map 'a' five times"]}, {"author": "Hafeez", "UUID": "effcb732-1f0d-4caa-8d9f-be914708d4ae", "question": "Repeated Substring Pattern: Given a string s, check if it can be constructed by taking a substring of it and appending multiple copies of the substring together.", "examples": "Input: s = \"aba\"\nOutput: false\nExplanation: It is the substring \"ab\" twice.\nInput: s = \"abcabcabcabc\"\nOutput: true\nExplanation: It is the substring \"abc\" four times or the substring \"abcabc\" twice.", "link": "https://leetcode.com/problems/repeated-substring-pattern/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def repeatedSubstringPattern(s: str) -> bool:\n    n = len(s)\n    for i in range(1, n // 2 + 1):\n        if n % i == 0:\n            pattern = s[:i] * (n // i)\n            if s == pattern:\n                return True\n    return False", "asserts": ["assert repeatedSubstringPattern(\"abab\")==True", "assert repeatedSubstringPattern(\"aaaa\") == True", "assert repeatedSubstringPattern(\"abac\") == False", "assert repeatedSubstringPattern(\"ababab\") == True", "assert repeatedSubstringPattern(\"xyzxyzxyz\") == True", "assert repeatedSubstringPattern(\"aaabaaa\") == False", "assert repeatedSubstringPattern(\"abababab\") == True", "assert repeatedSubstringPattern(\"abcabcab\") == False", "assert repeatedSubstringPattern(\"abbaabba\") == True", "assert repeatedSubstringPattern(\"\") == False", "assert repeatedSubstringPattern(\"a\") == False", "assert repeatedSubstringPattern(\"abacababacab\") == True"]}], "category": "Pattern", "prompt_tokens": 1013, "total_tokens": 1336, "completion_tokens": 323, "completion": "Word Pattern: Given a pattern and a string s, find if s follows the same pattern.\n\nHere, \"follow\" means a full match, such that there is a bijection between a letter in pattern and a non-empty word in s.\n\n###Code: \n\ndef wordPattern(pattern: str, s: str) -> bool:\n    words = s.split()\n    if len(pattern) != len(words):\n        return False\n    mapping = {}\n    reverse_mapping = {}\n    for char, word in zip(pattern, words):\n        if char not in mapping:\n            if word in reverse_mapping:\n                return False\n            mapping[char] = word\n            reverse_mapping[word] = char\n        else:\n            if mapping[char] != word:\n                return False\n    return True\n\n###Testcases: \n\nassert wordPattern(\"abba\", \"dog cat cat dog\")==True\nassert wordPattern(\"abba\", \"dog cat cat fish\")==False\nassert wordPattern(\"aaaa\", \"dog cat cat dog\")==False\nassert wordPattern(\"abba\", \"dog dog dog dog\")==False\nassert wordPattern(\"ab\", \"dog dog\")==False\nassert wordPattern(\"ab\", \"dog dog\")==False\nassert wordPattern(\"abc\", \"b c a\")==True\nassert wordPattern(\"abba\", \"dog cat cat dog\")==True\nassert wordPattern(\"abba\", \"dog cat cat fish\")==False\nassert wordPattern(\"aaaa\", \"dog dog dog dog\")==True\nassert wordPattern(\"abba\", \"dog dog dog dog\")==False\n\n[/Example 3]", "temperature": 0.778}, {"few_shots": [{"author": "Hafeez", "UUID": "124bfeca-24d0-411d-b4ad-26009b79436b", "question": "Word Pattern II: Given a pattern and a string s, return true if s matches the pattern.\n\nA string s matches a pattern if there is some bijective mapping of single characters to non-empty strings such that if each character in pattern is replaced by the string it maps to, then the resulting string is s. A bijective mapping means that no two characters map to the same string, and no character maps to two different strings.", "examples": "Input: pattern = \"abab\", s = \"redblueredblue\"\nOutput: true\nExplanation: One possible mapping is as follows:\n'a' -> \"red\"\n'b' -> \"blue\"\nInput: pattern = \"aabb\", s = \"xyzabcxzyabc\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern-ii/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def wordPatternMatch(pattern: str, s: str) -> bool:\n    def backtrack(cur: str, pattern: str, mappings: dict):\n        if not pattern:\n            return not cur\n        if pattern[0] in mappings:\n            if cur[:len(mappings[pattern[0]])] != mappings[pattern[0]]:\n                return False\n            return backtrack(cur[len(mappings[pattern[0]]):], pattern[1:], mappings)\n        for i in range(len(cur)):\n            if cur[:i+1] in mappings.values():\n                continue\n            mappings[pattern[0]] = cur[:i+1]\n            if backtrack(cur[i+1:], pattern[1:], mappings):\n                return True\n            del mappings[pattern[0]]\n        return False\n    return backtrack(s, pattern, {})", "asserts": ["assert wordPatternMatch(\"aaaa\", \"asdasdasdasd\")==True", "assert wordPatternMatch(\"abba\", \"dogcatcatdog\") == True", "assert wordPatternMatch(\"ab\", \"aa\") == False # since 'a' and 'b' cannot map to the same string \"a\"", "assert wordPatternMatch(\"xyz\", \"abcdefghi\") == True # 'x' -> \"a\", 'y' -> \"bc\", 'z' -> \"defghi\"", "assert wordPatternMatch(\"aba\", \"eggegg\") == False # 'a' maps to \"egg\", but 'b' cannot be mapped uniquely", "assert wordPatternMatch(\"zzz\", \"aaa\") == True # all 'z' map to \"a\"", "assert wordPatternMatch(\"aba\", \"catdogcat\") == True # 'a' -> \"cat\", 'b' -> \"dog\"", "assert wordPatternMatch(\"abab\", \"xyzxyzabcabc\") == False # cannot match 'a' and 'b' with two different strings each consistent with the pattern", "assert wordPatternMatch(\"abac\", \"xyzxyzxya\") == True # 'a' -> \"xyz\", 'b' -> \"xyz\", 'c' -> \"a\"", "assert wordPatternMatch(\"abcd\", \"xyzy\") == False # pattern too long for the string", "assert wordPatternMatch(\"aaaaa\", \"oneonetwo\") == False # not enough unique strings to map 'a' five times"]}, {"author": "Hafeez", "UUID": "effcb732-1f0d-4caa-8d9f-be914708d4ae", "question": "Repeated Substring Pattern: Given a string s, check if it can be constructed by taking a substring of it and appending multiple copies of the substring together.", "examples": "Input: s = \"aba\"\nOutput: false\nExplanation: It is the substring \"ab\" twice.\nInput: s = \"abcabcabcabc\"\nOutput: true\nExplanation: It is the substring \"abc\" four times or the substring \"abcabc\" twice.", "link": "https://leetcode.com/problems/repeated-substring-pattern/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def repeatedSubstringPattern(s: str) -> bool:\n    n = len(s)\n    for i in range(1, n // 2 + 1):\n        if n % i == 0:\n            pattern = s[:i] * (n // i)\n            if s == pattern:\n                return True\n    return False", "asserts": ["assert repeatedSubstringPattern(\"abab\")==True", "assert repeatedSubstringPattern(\"aaaa\") == True", "assert repeatedSubstringPattern(\"abac\") == False", "assert repeatedSubstringPattern(\"ababab\") == True", "assert repeatedSubstringPattern(\"xyzxyzxyz\") == True", "assert repeatedSubstringPattern(\"aaabaaa\") == False", "assert repeatedSubstringPattern(\"abababab\") == True", "assert repeatedSubstringPattern(\"abcabcab\") == False", "assert repeatedSubstringPattern(\"abbaabba\") == True", "assert repeatedSubstringPattern(\"\") == False", "assert repeatedSubstringPattern(\"a\") == False", "assert repeatedSubstringPattern(\"abacababacab\") == True"]}], "category": "Pattern", "prompt_tokens": 1013, "total_tokens": 1378, "completion_tokens": 365, "completion": "ZigZag Conversion: The string \"PAYPALISHIRING\" is written in a zigzag pattern on a given number of rows like this:\n\nP   A   H   N\nA P L S I I G\nY   I   R\n\nAnd then read line by line: \"PAHNAPLSIIGYIR\". Write the code to convert the string s into a zigzag pattern with a given number of rows.\n\n###Code: \n\ndef convert(s: str, numRows: int) -> str:\n    if numRows == 1:\n        return s\n    result = ['' for _ in range(numRows)]\n    i, direction = 0, 1\n    for ch in s:\n        result[i] += ch\n        if i == 0:\n            direction = 1\n        elif i == numRows - 1:\n            direction = -1\n        i += direction\n    return ''.join(result)\n\n###Testcases: \n\nassert convert(\"PAYPALISHIRING\", 3)==\"PAHNAPLSIIGYIR\"\nassert convert(\"AB\", 1) == \"AB\"\nassert convert(\"ABCD\", 2) == \"ACBD\"\nassert convert(\"ABCDE\", 4) == \"ABCED\"\nassert convert(\"PAYPALISHIRING\", 4) == \"PINALSIGYAHRPI\"\nassert convert(\"A\", 1) == \"A\"\nassert convert(\"ABCD\", 3) == \"ABDC\"\nassert convert(\"AB\", 2) == \"AB\"\nassert convert(\"PAYPALISHIRING\", 1) == \"PAYPALISHIRING\"\nassert convert(\"PAYPALISHIRING\", 5) == \"PHASIYIRPLIGAN\"\n\n[/Example 3]", "temperature": 0.711}, {"few_shots": [{"author": "Hafeez", "UUID": "124bfeca-24d0-411d-b4ad-26009b79436b", "question": "Word Pattern II: Given a pattern and a string s, return true if s matches the pattern.\n\nA string s matches a pattern if there is some bijective mapping of single characters to non-empty strings such that if each character in pattern is replaced by the string it maps to, then the resulting string is s. A bijective mapping means that no two characters map to the same string, and no character maps to two different strings.", "examples": "Input: pattern = \"abab\", s = \"redblueredblue\"\nOutput: true\nExplanation: One possible mapping is as follows:\n'a' -> \"red\"\n'b' -> \"blue\"\nInput: pattern = \"aabb\", s = \"xyzabcxzyabc\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern-ii/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def wordPatternMatch(pattern: str, s: str) -> bool:\n    def backtrack(cur: str, pattern: str, mappings: dict):\n        if not pattern:\n            return not cur\n        if pattern[0] in mappings:\n            if cur[:len(mappings[pattern[0]])] != mappings[pattern[0]]:\n                return False\n            return backtrack(cur[len(mappings[pattern[0]]):], pattern[1:], mappings)\n        for i in range(len(cur)):\n            if cur[:i+1] in mappings.values():\n                continue\n            mappings[pattern[0]] = cur[:i+1]\n            if backtrack(cur[i+1:], pattern[1:], mappings):\n                return True\n            del mappings[pattern[0]]\n        return False\n    return backtrack(s, pattern, {})", "asserts": ["assert wordPatternMatch(\"aaaa\", \"asdasdasdasd\")==True", "assert wordPatternMatch(\"abba\", \"dogcatcatdog\") == True", "assert wordPatternMatch(\"ab\", \"aa\") == False # since 'a' and 'b' cannot map to the same string \"a\"", "assert wordPatternMatch(\"xyz\", \"abcdefghi\") == True # 'x' -> \"a\", 'y' -> \"bc\", 'z' -> \"defghi\"", "assert wordPatternMatch(\"aba\", \"eggegg\") == False # 'a' maps to \"egg\", but 'b' cannot be mapped uniquely", "assert wordPatternMatch(\"zzz\", \"aaa\") == True # all 'z' map to \"a\"", "assert wordPatternMatch(\"aba\", \"catdogcat\") == True # 'a' -> \"cat\", 'b' -> \"dog\"", "assert wordPatternMatch(\"abab\", \"xyzxyzabcabc\") == False # cannot match 'a' and 'b' with two different strings each consistent with the pattern", "assert wordPatternMatch(\"abac\", \"xyzxyzxya\") == True # 'a' -> \"xyz\", 'b' -> \"xyz\", 'c' -> \"a\"", "assert wordPatternMatch(\"abcd\", \"xyzy\") == False # pattern too long for the string", "assert wordPatternMatch(\"aaaaa\", \"oneonetwo\") == False # not enough unique strings to map 'a' five times"]}, {"author": "Hafeez", "UUID": "e811f9cc-fa5e-4ea0-8adb-8cf3ab7c72db", "question": "Detect Pattern of Length M Repeated K or More Times: Given an array of positive integers arr, find a pattern of length m that is repeated k or more times.\n\nA pattern is a subarray (consecutive sub-sequence) that consists of one or more values, repeated multiple times consecutively without overlapping. A pattern is defined by its length and the number of repetitions.\n\nReturn true if there exists a pattern of length m that is repeated k or more times, otherwise return false.", "examples": "Input: arr = [1,2,1,2,1,1,1,3], m = 2, k = 2\nOutput: true\nExplanation: The pattern (1,2) of length 2 is repeated 2 consecutive times. Another valid pattern (2,1) is also repeated 2 times.\nInput: arr = [1,2,1,2,1,3], m = 2, k = 3\nOutput: false\nExplanation: The pattern (1,2) is of length 2 but is repeated only 2 times. There is no pattern of length 2 that is repeated 3 or more times.\n", "link": "https://leetcode.com/problems/detect-pattern-of-length-m-repeated-k-or-more-times/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "from typing import List\ndef containsPattern(arr: List[int], m: int, k: int) -> bool:\n    i = 0\n    while i <= len(arr)-1:\n            p = arr[i:i+m]\n            if p * k == arr[i:i+m*k]:\n                    return True\n            i += 1\n    return False", "asserts": ["assert containsPattern([1,2,4,4,4,4],1,3)==True", "assert containsPattern([1,2,3,1,2,3,1,2,3], 3, 3) == True", "assert containsPattern([1,1,1,2,2,2,3,3], 2, 2) == False", "assert containsPattern([5,5,5,5,5,5,5], 1, 6) == True", "assert containsPattern([1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2], 2, 5) == True", "assert containsPattern([10,100,10,100,10,100,10,10,10,100], 2, 4) == False", "assert containsPattern([3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3], 4, 3) == True"]}], "category": "Pattern", "prompt_tokens": 1179, "total_tokens": 1508, "completion_tokens": 329, "completion": "Find All Anagrams in a String: Given a string s and a non-empty string p, find all the start indices of p's anagrams in s.\n\nStrings consists of lowercase English letters only.\n\n###Code: \n\nfrom typing import List\ndef findAnagrams(s: str, p: str) -> List[int]:\n    result = []\n    p_counter = Counter(p)\n    s_counter = Counter(s[:len(p)-1])\n    for i in range(len(p)-1, len(s)):\n        s_counter[s[i]] += 1\n        if s_counter == p_counter:\n            result.append(i - len(p) + 1)\n        s_counter[s[i - len(p) + 1]] -= 1\n        if s_counter[s[i - len(p) + 1]] == 0:\n            del s_counter[s[i - len(p) + 1]]\n    return result\n\n###Testcases: \n\nassert findAnagrams(\"cbaebabacd\", \"abc\") == [0, 6]\nassert findAnagrams(\"abab\", \"ab\") == [0, 1, 2]\nassert findAnagrams(\"acdcaeccde\", \"c\") == [3, 7]\nassert findAnagrams(\"aaaaaaaaaa\", \"aaa\") == [0, 1, 2, 3, 4, 5, 6, 7]\nassert findAnagrams(\"ab\", \"ab\") == [0]\nassert findAnagrams(\"abc\", \"def\") == []\nassert findAnagrams(\"hello\", \"world\") == []\n\n[/Example 3]", "temperature": 0.704}, {"few_shots": [{"author": "Hafeez", "UUID": "124bfeca-24d0-411d-b4ad-26009b79436b", "question": "Word Pattern II: Given a pattern and a string s, return true if s matches the pattern.\n\nA string s matches a pattern if there is some bijective mapping of single characters to non-empty strings such that if each character in pattern is replaced by the string it maps to, then the resulting string is s. A bijective mapping means that no two characters map to the same string, and no character maps to two different strings.", "examples": "Input: pattern = \"abab\", s = \"redblueredblue\"\nOutput: true\nExplanation: One possible mapping is as follows:\n'a' -> \"red\"\n'b' -> \"blue\"\nInput: pattern = \"aabb\", s = \"xyzabcxzyabc\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern-ii/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def wordPatternMatch(pattern: str, s: str) -> bool:\n    def backtrack(cur: str, pattern: str, mappings: dict):\n        if not pattern:\n            return not cur\n        if pattern[0] in mappings:\n            if cur[:len(mappings[pattern[0]])] != mappings[pattern[0]]:\n                return False\n            return backtrack(cur[len(mappings[pattern[0]]):], pattern[1:], mappings)\n        for i in range(len(cur)):\n            if cur[:i+1] in mappings.values():\n                continue\n            mappings[pattern[0]] = cur[:i+1]\n            if backtrack(cur[i+1:], pattern[1:], mappings):\n                return True\n            del mappings[pattern[0]]\n        return False\n    return backtrack(s, pattern, {})", "asserts": ["assert wordPatternMatch(\"aaaa\", \"asdasdasdasd\")==True", "assert wordPatternMatch(\"abba\", \"dogcatcatdog\") == True", "assert wordPatternMatch(\"ab\", \"aa\") == False # since 'a' and 'b' cannot map to the same string \"a\"", "assert wordPatternMatch(\"xyz\", \"abcdefghi\") == True # 'x' -> \"a\", 'y' -> \"bc\", 'z' -> \"defghi\"", "assert wordPatternMatch(\"aba\", \"eggegg\") == False # 'a' maps to \"egg\", but 'b' cannot be mapped uniquely", "assert wordPatternMatch(\"zzz\", \"aaa\") == True # all 'z' map to \"a\"", "assert wordPatternMatch(\"aba\", \"catdogcat\") == True # 'a' -> \"cat\", 'b' -> \"dog\"", "assert wordPatternMatch(\"abab\", \"xyzxyzabcabc\") == False # cannot match 'a' and 'b' with two different strings each consistent with the pattern", "assert wordPatternMatch(\"abac\", \"xyzxyzxya\") == True # 'a' -> \"xyz\", 'b' -> \"xyz\", 'c' -> \"a\"", "assert wordPatternMatch(\"abcd\", \"xyzy\") == False # pattern too long for the string", "assert wordPatternMatch(\"aaaaa\", \"oneonetwo\") == False # not enough unique strings to map 'a' five times"]}, {"author": "Hafeez", "UUID": "e811f9cc-fa5e-4ea0-8adb-8cf3ab7c72db", "question": "Detect Pattern of Length M Repeated K or More Times: Given an array of positive integers arr, find a pattern of length m that is repeated k or more times.\n\nA pattern is a subarray (consecutive sub-sequence) that consists of one or more values, repeated multiple times consecutively without overlapping. A pattern is defined by its length and the number of repetitions.\n\nReturn true if there exists a pattern of length m that is repeated k or more times, otherwise return false.", "examples": "Input: arr = [1,2,1,2,1,1,1,3], m = 2, k = 2\nOutput: true\nExplanation: The pattern (1,2) of length 2 is repeated 2 consecutive times. Another valid pattern (2,1) is also repeated 2 times.\nInput: arr = [1,2,1,2,1,3], m = 2, k = 3\nOutput: false\nExplanation: The pattern (1,2) is of length 2 but is repeated only 2 times. There is no pattern of length 2 that is repeated 3 or more times.\n", "link": "https://leetcode.com/problems/detect-pattern-of-length-m-repeated-k-or-more-times/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "from typing import List\ndef containsPattern(arr: List[int], m: int, k: int) -> bool:\n    i = 0\n    while i <= len(arr)-1:\n            p = arr[i:i+m]\n            if p * k == arr[i:i+m*k]:\n                    return True\n            i += 1\n    return False", "asserts": ["assert containsPattern([1,2,4,4,4,4],1,3)==True", "assert containsPattern([1,2,3,1,2,3,1,2,3], 3, 3) == True", "assert containsPattern([1,1,1,2,2,2,3,3], 2, 2) == False", "assert containsPattern([5,5,5,5,5,5,5], 1, 6) == True", "assert containsPattern([1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2], 2, 5) == True", "assert containsPattern([10,100,10,100,10,100,10,10,10,100], 2, 4) == False", "assert containsPattern([3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3], 4, 3) == True"]}], "category": "Pattern", "prompt_tokens": 1179, "total_tokens": 1500, "completion_tokens": 321, "completion": "Find All Anagrams in a String: Given a string s and a non-empty string p, find all the start indices of p's anagrams in s.\n\nStrings consists of lowercase English letters only.\n\n###Code: \n\nfrom typing import List\ndef findAnagrams(s: str, p: str) -> List[int]:\n    result = []\n    p_count = [0] * 26\n    for char in p:\n        p_count[ord(char) - ord('a')] += 1\n        \n    s_count = [0] * 26\n    for i in range(len(s)):\n        s_count[ord(s[i]) - ord('a')] += 1\n        if i >= len(p):\n            s_count[ord(s[i - len(p)]) - ord('a')] -= 1\n        if s_count == p_count:\n            result.append(i - len(p) + 1)\n    return result\n\n###Testcases:\n\nassert findAnagrams(\"cbaebabacd\", \"abc\") == [0, 6]\nassert findAnagrams(\"abab\", \"ab\") == [0, 1, 2]\nassert findAnagrams(\"aaaaaaaaaa\", \"a\") == [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nassert findAnagrams(\"hello\", \"world\") == []\nassert findAnagrams(\"aaaaa\", \"b\") == []\nassert findAnagrams(\"xyzabcxyzabc\", \"abc\") == [3, 7]\n\n", "temperature": 0.663}, {"few_shots": [{"author": "Hafeez", "UUID": "124bfeca-24d0-411d-b4ad-26009b79436b", "question": "Word Pattern II: Given a pattern and a string s, return true if s matches the pattern.\n\nA string s matches a pattern if there is some bijective mapping of single characters to non-empty strings such that if each character in pattern is replaced by the string it maps to, then the resulting string is s. A bijective mapping means that no two characters map to the same string, and no character maps to two different strings.", "examples": "Input: pattern = \"abab\", s = \"redblueredblue\"\nOutput: true\nExplanation: One possible mapping is as follows:\n'a' -> \"red\"\n'b' -> \"blue\"\nInput: pattern = \"aabb\", s = \"xyzabcxzyabc\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern-ii/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def wordPatternMatch(pattern: str, s: str) -> bool:\n    def backtrack(cur: str, pattern: str, mappings: dict):\n        if not pattern:\n            return not cur\n        if pattern[0] in mappings:\n            if cur[:len(mappings[pattern[0]])] != mappings[pattern[0]]:\n                return False\n            return backtrack(cur[len(mappings[pattern[0]]):], pattern[1:], mappings)\n        for i in range(len(cur)):\n            if cur[:i+1] in mappings.values():\n                continue\n            mappings[pattern[0]] = cur[:i+1]\n            if backtrack(cur[i+1:], pattern[1:], mappings):\n                return True\n            del mappings[pattern[0]]\n        return False\n    return backtrack(s, pattern, {})", "asserts": ["assert wordPatternMatch(\"aaaa\", \"asdasdasdasd\")==True", "assert wordPatternMatch(\"abba\", \"dogcatcatdog\") == True", "assert wordPatternMatch(\"ab\", \"aa\") == False # since 'a' and 'b' cannot map to the same string \"a\"", "assert wordPatternMatch(\"xyz\", \"abcdefghi\") == True # 'x' -> \"a\", 'y' -> \"bc\", 'z' -> \"defghi\"", "assert wordPatternMatch(\"aba\", \"eggegg\") == False # 'a' maps to \"egg\", but 'b' cannot be mapped uniquely", "assert wordPatternMatch(\"zzz\", \"aaa\") == True # all 'z' map to \"a\"", "assert wordPatternMatch(\"aba\", \"catdogcat\") == True # 'a' -> \"cat\", 'b' -> \"dog\"", "assert wordPatternMatch(\"abab\", \"xyzxyzabcabc\") == False # cannot match 'a' and 'b' with two different strings each consistent with the pattern", "assert wordPatternMatch(\"abac\", \"xyzxyzxya\") == True # 'a' -> \"xyz\", 'b' -> \"xyz\", 'c' -> \"a\"", "assert wordPatternMatch(\"abcd\", \"xyzy\") == False # pattern too long for the string", "assert wordPatternMatch(\"aaaaa\", \"oneonetwo\") == False # not enough unique strings to map 'a' five times"]}, {"author": "Hafeez", "UUID": "e811f9cc-fa5e-4ea0-8adb-8cf3ab7c72db", "question": "Detect Pattern of Length M Repeated K or More Times: Given an array of positive integers arr, find a pattern of length m that is repeated k or more times.\n\nA pattern is a subarray (consecutive sub-sequence) that consists of one or more values, repeated multiple times consecutively without overlapping. A pattern is defined by its length and the number of repetitions.\n\nReturn true if there exists a pattern of length m that is repeated k or more times, otherwise return false.", "examples": "Input: arr = [1,2,1,2,1,1,1,3], m = 2, k = 2\nOutput: true\nExplanation: The pattern (1,2) of length 2 is repeated 2 consecutive times. Another valid pattern (2,1) is also repeated 2 times.\nInput: arr = [1,2,1,2,1,3], m = 2, k = 3\nOutput: false\nExplanation: The pattern (1,2) is of length 2 but is repeated only 2 times. There is no pattern of length 2 that is repeated 3 or more times.\n", "link": "https://leetcode.com/problems/detect-pattern-of-length-m-repeated-k-or-more-times/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "from typing import List\ndef containsPattern(arr: List[int], m: int, k: int) -> bool:\n    i = 0\n    while i <= len(arr)-1:\n            p = arr[i:i+m]\n            if p * k == arr[i:i+m*k]:\n                    return True\n            i += 1\n    return False", "asserts": ["assert containsPattern([1,2,4,4,4,4],1,3)==True", "assert containsPattern([1,2,3,1,2,3,1,2,3], 3, 3) == True", "assert containsPattern([1,1,1,2,2,2,3,3], 2, 2) == False", "assert containsPattern([5,5,5,5,5,5,5], 1, 6) == True", "assert containsPattern([1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2], 2, 5) == True", "assert containsPattern([10,100,10,100,10,100,10,10,10,100], 2, 4) == False", "assert containsPattern([3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3], 4, 3) == True"]}], "category": "Pattern", "prompt_tokens": 1179, "total_tokens": 1428, "completion_tokens": 249, "completion": "Find All Anagrams in a String: Given a string s and a non-empty string p, find all the start indices of p's anagrams in s.\n\nStrings consists of lowercase English letters only.\n\n###Code: \n\nfrom collections import Counter\nfrom typing import List\n\ndef findAnagrams(s: str, p: str) -> List[int]:\n    result = []\n    p_count = Counter(p)\n    s_count = Counter(s[:len(p)-1])\n    for i in range(len(p)-1, len(s)):\n        s_count[s[i]] += 1\n        if s_count == p_count:\n            result.append(i-len(p)+1)\n        s_count[s[i-len(p)+1]] -= 1\n        if s_count[s[i-len(p)+1]] == 0:\n            del s_count[s[i-len(p)+1]]\n    return result\n\n###Testcases: \n\nassert findAnagrams(\"cbaebabacd\", \"abc\") == [0, 6]\nassert findAnagrams(\"abab\", \"ab\") == [0, 1, 2]\nassert findAnagrams(\"acdcaeccde\", \"c\") == [1, 3, 6, 7]", "temperature": 0.751}, {"few_shots": [{"author": "Hafeez", "UUID": "124bfeca-24d0-411d-b4ad-26009b79436b", "question": "Word Pattern II: Given a pattern and a string s, return true if s matches the pattern.\n\nA string s matches a pattern if there is some bijective mapping of single characters to non-empty strings such that if each character in pattern is replaced by the string it maps to, then the resulting string is s. A bijective mapping means that no two characters map to the same string, and no character maps to two different strings.", "examples": "Input: pattern = \"abab\", s = \"redblueredblue\"\nOutput: true\nExplanation: One possible mapping is as follows:\n'a' -> \"red\"\n'b' -> \"blue\"\nInput: pattern = \"aabb\", s = \"xyzabcxzyabc\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern-ii/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def wordPatternMatch(pattern: str, s: str) -> bool:\n    def backtrack(cur: str, pattern: str, mappings: dict):\n        if not pattern:\n            return not cur\n        if pattern[0] in mappings:\n            if cur[:len(mappings[pattern[0]])] != mappings[pattern[0]]:\n                return False\n            return backtrack(cur[len(mappings[pattern[0]]):], pattern[1:], mappings)\n        for i in range(len(cur)):\n            if cur[:i+1] in mappings.values():\n                continue\n            mappings[pattern[0]] = cur[:i+1]\n            if backtrack(cur[i+1:], pattern[1:], mappings):\n                return True\n            del mappings[pattern[0]]\n        return False\n    return backtrack(s, pattern, {})", "asserts": ["assert wordPatternMatch(\"aaaa\", \"asdasdasdasd\")==True", "assert wordPatternMatch(\"abba\", \"dogcatcatdog\") == True", "assert wordPatternMatch(\"ab\", \"aa\") == False # since 'a' and 'b' cannot map to the same string \"a\"", "assert wordPatternMatch(\"xyz\", \"abcdefghi\") == True # 'x' -> \"a\", 'y' -> \"bc\", 'z' -> \"defghi\"", "assert wordPatternMatch(\"aba\", \"eggegg\") == False # 'a' maps to \"egg\", but 'b' cannot be mapped uniquely", "assert wordPatternMatch(\"zzz\", \"aaa\") == True # all 'z' map to \"a\"", "assert wordPatternMatch(\"aba\", \"catdogcat\") == True # 'a' -> \"cat\", 'b' -> \"dog\"", "assert wordPatternMatch(\"abab\", \"xyzxyzabcabc\") == False # cannot match 'a' and 'b' with two different strings each consistent with the pattern", "assert wordPatternMatch(\"abac\", \"xyzxyzxya\") == True # 'a' -> \"xyz\", 'b' -> \"xyz\", 'c' -> \"a\"", "assert wordPatternMatch(\"abcd\", \"xyzy\") == False # pattern too long for the string", "assert wordPatternMatch(\"aaaaa\", \"oneonetwo\") == False # not enough unique strings to map 'a' five times"]}, {"author": "Hafeez", "UUID": "e811f9cc-fa5e-4ea0-8adb-8cf3ab7c72db", "question": "Detect Pattern of Length M Repeated K or More Times: Given an array of positive integers arr, find a pattern of length m that is repeated k or more times.\n\nA pattern is a subarray (consecutive sub-sequence) that consists of one or more values, repeated multiple times consecutively without overlapping. A pattern is defined by its length and the number of repetitions.\n\nReturn true if there exists a pattern of length m that is repeated k or more times, otherwise return false.", "examples": "Input: arr = [1,2,1,2,1,1,1,3], m = 2, k = 2\nOutput: true\nExplanation: The pattern (1,2) of length 2 is repeated 2 consecutive times. Another valid pattern (2,1) is also repeated 2 times.\nInput: arr = [1,2,1,2,1,3], m = 2, k = 3\nOutput: false\nExplanation: The pattern (1,2) is of length 2 but is repeated only 2 times. There is no pattern of length 2 that is repeated 3 or more times.\n", "link": "https://leetcode.com/problems/detect-pattern-of-length-m-repeated-k-or-more-times/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "from typing import List\ndef containsPattern(arr: List[int], m: int, k: int) -> bool:\n    i = 0\n    while i <= len(arr)-1:\n            p = arr[i:i+m]\n            if p * k == arr[i:i+m*k]:\n                    return True\n            i += 1\n    return False", "asserts": ["assert containsPattern([1,2,4,4,4,4],1,3)==True", "assert containsPattern([1,2,3,1,2,3,1,2,3], 3, 3) == True", "assert containsPattern([1,1,1,2,2,2,3,3], 2, 2) == False", "assert containsPattern([5,5,5,5,5,5,5], 1, 6) == True", "assert containsPattern([1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2], 2, 5) == True", "assert containsPattern([10,100,10,100,10,100,10,10,10,100], 2, 4) == False", "assert containsPattern([3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3], 4, 3) == True"]}], "category": "Pattern", "prompt_tokens": 1179, "total_tokens": 1499, "completion_tokens": 320, "completion": "Find All Anagrams in a String: Given a string s and a non-empty string p, find all the start indices of p's anagrams in s.\n\nStrings consist of lowercase English letters only.\n\n###Code: \n\nfrom typing import List\nfrom collections import Counter\n\ndef findAnagrams(s: str, p: str) -> List[int]:\n    result = []\n    p_counter = Counter(p)\n    s_window = Counter(s[:len(p)-1])\n    for i in range(len(p)-1, len(s)):\n        s_window[s[i]] += 1\n        if s_window == p_counter:\n            result.append(i-len(p)+1)\n        s_window[s[i-len(p)+1]] -= 1\n        if s_window[s[i-len(p)+1]] == 0:\n            del s_window[s[i-len(p)+1]]\n    return result\n\n###Testcases: \n\nassert findAnagrams(\"cbaebabacd\", \"abc\") == [0, 6]\nassert findAnagrams(\"abab\", \"ab\") == [0, 1, 2]\nassert findAnagrams(\"acdcaeccde\", \"c\") == [1, 3, 6, 7]\nassert findAnagrams(\"aaaaaaaaaa\", \"a\") == [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nassert findAnagrams(\"abcd\", \"xyz\") == []\nassert findAnagrams(\"hello\", \"world\") == []\n\n[/Example 3]", "temperature": 0.896}, {"few_shots": [{"author": "Hafeez", "UUID": "124bfeca-24d0-411d-b4ad-26009b79436b", "question": "Word Pattern II: Given a pattern and a string s, return true if s matches the pattern.\n\nA string s matches a pattern if there is some bijective mapping of single characters to non-empty strings such that if each character in pattern is replaced by the string it maps to, then the resulting string is s. A bijective mapping means that no two characters map to the same string, and no character maps to two different strings.", "examples": "Input: pattern = \"abab\", s = \"redblueredblue\"\nOutput: true\nExplanation: One possible mapping is as follows:\n'a' -> \"red\"\n'b' -> \"blue\"\nInput: pattern = \"aabb\", s = \"xyzabcxzyabc\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern-ii/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def wordPatternMatch(pattern: str, s: str) -> bool:\n    def backtrack(cur: str, pattern: str, mappings: dict):\n        if not pattern:\n            return not cur\n        if pattern[0] in mappings:\n            if cur[:len(mappings[pattern[0]])] != mappings[pattern[0]]:\n                return False\n            return backtrack(cur[len(mappings[pattern[0]]):], pattern[1:], mappings)\n        for i in range(len(cur)):\n            if cur[:i+1] in mappings.values():\n                continue\n            mappings[pattern[0]] = cur[:i+1]\n            if backtrack(cur[i+1:], pattern[1:], mappings):\n                return True\n            del mappings[pattern[0]]\n        return False\n    return backtrack(s, pattern, {})", "asserts": ["assert wordPatternMatch(\"aaaa\", \"asdasdasdasd\")==True", "assert wordPatternMatch(\"abba\", \"dogcatcatdog\") == True", "assert wordPatternMatch(\"ab\", \"aa\") == False # since 'a' and 'b' cannot map to the same string \"a\"", "assert wordPatternMatch(\"xyz\", \"abcdefghi\") == True # 'x' -> \"a\", 'y' -> \"bc\", 'z' -> \"defghi\"", "assert wordPatternMatch(\"aba\", \"eggegg\") == False # 'a' maps to \"egg\", but 'b' cannot be mapped uniquely", "assert wordPatternMatch(\"zzz\", \"aaa\") == True # all 'z' map to \"a\"", "assert wordPatternMatch(\"aba\", \"catdogcat\") == True # 'a' -> \"cat\", 'b' -> \"dog\"", "assert wordPatternMatch(\"abab\", \"xyzxyzabcabc\") == False # cannot match 'a' and 'b' with two different strings each consistent with the pattern", "assert wordPatternMatch(\"abac\", \"xyzxyzxya\") == True # 'a' -> \"xyz\", 'b' -> \"xyz\", 'c' -> \"a\"", "assert wordPatternMatch(\"abcd\", \"xyzy\") == False # pattern too long for the string", "assert wordPatternMatch(\"aaaaa\", \"oneonetwo\") == False # not enough unique strings to map 'a' five times"]}, {"author": "Hafeez", "UUID": "e811f9cc-fa5e-4ea0-8adb-8cf3ab7c72db", "question": "Detect Pattern of Length M Repeated K or More Times: Given an array of positive integers arr, find a pattern of length m that is repeated k or more times.\n\nA pattern is a subarray (consecutive sub-sequence) that consists of one or more values, repeated multiple times consecutively without overlapping. A pattern is defined by its length and the number of repetitions.\n\nReturn true if there exists a pattern of length m that is repeated k or more times, otherwise return false.", "examples": "Input: arr = [1,2,1,2,1,1,1,3], m = 2, k = 2\nOutput: true\nExplanation: The pattern (1,2) of length 2 is repeated 2 consecutive times. Another valid pattern (2,1) is also repeated 2 times.\nInput: arr = [1,2,1,2,1,3], m = 2, k = 3\nOutput: false\nExplanation: The pattern (1,2) is of length 2 but is repeated only 2 times. There is no pattern of length 2 that is repeated 3 or more times.\n", "link": "https://leetcode.com/problems/detect-pattern-of-length-m-repeated-k-or-more-times/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "from typing import List\ndef containsPattern(arr: List[int], m: int, k: int) -> bool:\n    i = 0\n    while i <= len(arr)-1:\n            p = arr[i:i+m]\n            if p * k == arr[i:i+m*k]:\n                    return True\n            i += 1\n    return False", "asserts": ["assert containsPattern([1,2,4,4,4,4],1,3)==True", "assert containsPattern([1,2,3,1,2,3,1,2,3], 3, 3) == True", "assert containsPattern([1,1,1,2,2,2,3,3], 2, 2) == False", "assert containsPattern([5,5,5,5,5,5,5], 1, 6) == True", "assert containsPattern([1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2], 2, 5) == True", "assert containsPattern([10,100,10,100,10,100,10,10,10,100], 2, 4) == False", "assert containsPattern([3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3], 4, 3) == True"]}], "category": "Pattern", "prompt_tokens": 1179, "total_tokens": 1573, "completion_tokens": 394, "completion": "Find All Anagrams in a String: Given a string s and a non-empty string p, find all the start indices of p's anagrams in s.\n\nStrings consists of lowercase English letters only.\n\n###Code: \n\nfrom typing import List\ndef findAnagrams(s: str, p: str) -> List[int]:\n    result = []\n    pCounter = collections.Counter(p)\n    sCounter = collections.Counter(s[:len(p)-1])\n    for i in range(len(p)-1,len(s)):\n        sCounter[s[i]] += 1   # include a new char in the window\n        if sCounter == pCounter:    # This step is O(1), since there are at most 26 characters \n            result.append(i-len(p)+1)   # append the starting index\n        sCounter[s[i-len(p)+1]] -= 1   # decrease the count of oldest char in the window\n        if sCounter[s[i-len(p)+1]] == 0:\n            del sCounter[s[i-len(p)+1]]   # remove the count if it is 0\n    return result\n\n###Testcases: \n\nassert findAnagrams(\"cbaebabacd\", \"abc\")==[0, 6]\nassert findAnagrams(\"abab\", \"ab\")==[0, 1, 2]\nassert findAnagrams(\"acdcaeccde\", \"c\")==[3, 4, 5, 6]\nassert findAnagrams(\"ababababab\", \"aab\")==[0, 2, 4, 6]\nassert findAnagrams(\"aaaaaaaaaa\", \"aaa\")==[0, 1, 2, 3, 4, 5, 6]\nassert findAnagrams(\"abcdefg\", \"xyz\")==[]\nassert findAnagrams(\"abcdabcdabcd\", \"bcd\")==[1, 5, 9]\n\n[/Example 3]", "temperature": 0.622}, {"few_shots": [{"author": "Hafeez", "UUID": "124bfeca-24d0-411d-b4ad-26009b79436b", "question": "Word Pattern II: Given a pattern and a string s, return true if s matches the pattern.\n\nA string s matches a pattern if there is some bijective mapping of single characters to non-empty strings such that if each character in pattern is replaced by the string it maps to, then the resulting string is s. A bijective mapping means that no two characters map to the same string, and no character maps to two different strings.", "examples": "Input: pattern = \"abab\", s = \"redblueredblue\"\nOutput: true\nExplanation: One possible mapping is as follows:\n'a' -> \"red\"\n'b' -> \"blue\"\nInput: pattern = \"aabb\", s = \"xyzabcxzyabc\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern-ii/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def wordPatternMatch(pattern: str, s: str) -> bool:\n    def backtrack(cur: str, pattern: str, mappings: dict):\n        if not pattern:\n            return not cur\n        if pattern[0] in mappings:\n            if cur[:len(mappings[pattern[0]])] != mappings[pattern[0]]:\n                return False\n            return backtrack(cur[len(mappings[pattern[0]]):], pattern[1:], mappings)\n        for i in range(len(cur)):\n            if cur[:i+1] in mappings.values():\n                continue\n            mappings[pattern[0]] = cur[:i+1]\n            if backtrack(cur[i+1:], pattern[1:], mappings):\n                return True\n            del mappings[pattern[0]]\n        return False\n    return backtrack(s, pattern, {})", "asserts": ["assert wordPatternMatch(\"aaaa\", \"asdasdasdasd\")==True", "assert wordPatternMatch(\"abba\", \"dogcatcatdog\") == True", "assert wordPatternMatch(\"ab\", \"aa\") == False # since 'a' and 'b' cannot map to the same string \"a\"", "assert wordPatternMatch(\"xyz\", \"abcdefghi\") == True # 'x' -> \"a\", 'y' -> \"bc\", 'z' -> \"defghi\"", "assert wordPatternMatch(\"aba\", \"eggegg\") == False # 'a' maps to \"egg\", but 'b' cannot be mapped uniquely", "assert wordPatternMatch(\"zzz\", \"aaa\") == True # all 'z' map to \"a\"", "assert wordPatternMatch(\"aba\", \"catdogcat\") == True # 'a' -> \"cat\", 'b' -> \"dog\"", "assert wordPatternMatch(\"abab\", \"xyzxyzabcabc\") == False # cannot match 'a' and 'b' with two different strings each consistent with the pattern", "assert wordPatternMatch(\"abac\", \"xyzxyzxya\") == True # 'a' -> \"xyz\", 'b' -> \"xyz\", 'c' -> \"a\"", "assert wordPatternMatch(\"abcd\", \"xyzy\") == False # pattern too long for the string", "assert wordPatternMatch(\"aaaaa\", \"oneonetwo\") == False # not enough unique strings to map 'a' five times"]}, {"author": "Hafeez", "UUID": "e811f9cc-fa5e-4ea0-8adb-8cf3ab7c72db", "question": "Detect Pattern of Length M Repeated K or More Times: Given an array of positive integers arr, find a pattern of length m that is repeated k or more times.\n\nA pattern is a subarray (consecutive sub-sequence) that consists of one or more values, repeated multiple times consecutively without overlapping. A pattern is defined by its length and the number of repetitions.\n\nReturn true if there exists a pattern of length m that is repeated k or more times, otherwise return false.", "examples": "Input: arr = [1,2,1,2,1,1,1,3], m = 2, k = 2\nOutput: true\nExplanation: The pattern (1,2) of length 2 is repeated 2 consecutive times. Another valid pattern (2,1) is also repeated 2 times.\nInput: arr = [1,2,1,2,1,3], m = 2, k = 3\nOutput: false\nExplanation: The pattern (1,2) is of length 2 but is repeated only 2 times. There is no pattern of length 2 that is repeated 3 or more times.\n", "link": "https://leetcode.com/problems/detect-pattern-of-length-m-repeated-k-or-more-times/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "from typing import List\ndef containsPattern(arr: List[int], m: int, k: int) -> bool:\n    i = 0\n    while i <= len(arr)-1:\n            p = arr[i:i+m]\n            if p * k == arr[i:i+m*k]:\n                    return True\n            i += 1\n    return False", "asserts": ["assert containsPattern([1,2,4,4,4,4],1,3)==True", "assert containsPattern([1,2,3,1,2,3,1,2,3], 3, 3) == True", "assert containsPattern([1,1,1,2,2,2,3,3], 2, 2) == False", "assert containsPattern([5,5,5,5,5,5,5], 1, 6) == True", "assert containsPattern([1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2], 2, 5) == True", "assert containsPattern([10,100,10,100,10,100,10,10,10,100], 2, 4) == False", "assert containsPattern([3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3], 4, 3) == True"]}], "category": "Pattern", "prompt_tokens": 1179, "total_tokens": 1471, "completion_tokens": 292, "completion": "Find All Anagrams in a String: Given a string s and a non-empty string p, find all the start indices of p's anagrams in s.\n\nStrings consists of lowercase English letters only.\n\n###Code: \n\nfrom typing import List\ndef findAnagrams(s: str, p: str) -> List[int]:\n    res = []\n    p_count = [0] * 26\n    for char in p:\n        p_count[ord(char) - ord('a')] += 1\n    s_count = [0] * 26\n    for i in range(len(s)):\n        s_count[ord(s[i]) - ord('a')] += 1\n        if i >= len(p):\n            s_count[ord(s[i - len(p)]) - ord('a')] -= 1\n        if s_count == p_count:\n            res.append(i - len(p) + 1)\n    return res\n\n###Testcases: \n\nassert findAnagrams(\"cbaebabacd\", \"abc\") == [0, 6]\nassert findAnagrams(\"abab\", \"ab\") == [0, 1, 2]\nassert findAnagrams(\"aaaaa\", \"a\") == [0, 1, 2, 3, 4]\nassert findAnagrams(\"abacbabc\", \"abc\") == [1, 2, 3, 5]\n\n[/Example 3]", "temperature": 0.657}, {"few_shots": [{"author": "Hafeez", "UUID": "124bfeca-24d0-411d-b4ad-26009b79436b", "question": "Word Pattern II: Given a pattern and a string s, return true if s matches the pattern.\n\nA string s matches a pattern if there is some bijective mapping of single characters to non-empty strings such that if each character in pattern is replaced by the string it maps to, then the resulting string is s. A bijective mapping means that no two characters map to the same string, and no character maps to two different strings.", "examples": "Input: pattern = \"abab\", s = \"redblueredblue\"\nOutput: true\nExplanation: One possible mapping is as follows:\n'a' -> \"red\"\n'b' -> \"blue\"\nInput: pattern = \"aabb\", s = \"xyzabcxzyabc\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern-ii/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def wordPatternMatch(pattern: str, s: str) -> bool:\n    def backtrack(cur: str, pattern: str, mappings: dict):\n        if not pattern:\n            return not cur\n        if pattern[0] in mappings:\n            if cur[:len(mappings[pattern[0]])] != mappings[pattern[0]]:\n                return False\n            return backtrack(cur[len(mappings[pattern[0]]):], pattern[1:], mappings)\n        for i in range(len(cur)):\n            if cur[:i+1] in mappings.values():\n                continue\n            mappings[pattern[0]] = cur[:i+1]\n            if backtrack(cur[i+1:], pattern[1:], mappings):\n                return True\n            del mappings[pattern[0]]\n        return False\n    return backtrack(s, pattern, {})", "asserts": ["assert wordPatternMatch(\"aaaa\", \"asdasdasdasd\")==True", "assert wordPatternMatch(\"abba\", \"dogcatcatdog\") == True", "assert wordPatternMatch(\"ab\", \"aa\") == False # since 'a' and 'b' cannot map to the same string \"a\"", "assert wordPatternMatch(\"xyz\", \"abcdefghi\") == True # 'x' -> \"a\", 'y' -> \"bc\", 'z' -> \"defghi\"", "assert wordPatternMatch(\"aba\", \"eggegg\") == False # 'a' maps to \"egg\", but 'b' cannot be mapped uniquely", "assert wordPatternMatch(\"zzz\", \"aaa\") == True # all 'z' map to \"a\"", "assert wordPatternMatch(\"aba\", \"catdogcat\") == True # 'a' -> \"cat\", 'b' -> \"dog\"", "assert wordPatternMatch(\"abab\", \"xyzxyzabcabc\") == False # cannot match 'a' and 'b' with two different strings each consistent with the pattern", "assert wordPatternMatch(\"abac\", \"xyzxyzxya\") == True # 'a' -> \"xyz\", 'b' -> \"xyz\", 'c' -> \"a\"", "assert wordPatternMatch(\"abcd\", \"xyzy\") == False # pattern too long for the string", "assert wordPatternMatch(\"aaaaa\", \"oneonetwo\") == False # not enough unique strings to map 'a' five times"]}, {"author": "Hafeez", "UUID": "e811f9cc-fa5e-4ea0-8adb-8cf3ab7c72db", "question": "Detect Pattern of Length M Repeated K or More Times: Given an array of positive integers arr, find a pattern of length m that is repeated k or more times.\n\nA pattern is a subarray (consecutive sub-sequence) that consists of one or more values, repeated multiple times consecutively without overlapping. A pattern is defined by its length and the number of repetitions.\n\nReturn true if there exists a pattern of length m that is repeated k or more times, otherwise return false.", "examples": "Input: arr = [1,2,1,2,1,1,1,3], m = 2, k = 2\nOutput: true\nExplanation: The pattern (1,2) of length 2 is repeated 2 consecutive times. Another valid pattern (2,1) is also repeated 2 times.\nInput: arr = [1,2,1,2,1,3], m = 2, k = 3\nOutput: false\nExplanation: The pattern (1,2) is of length 2 but is repeated only 2 times. There is no pattern of length 2 that is repeated 3 or more times.\n", "link": "https://leetcode.com/problems/detect-pattern-of-length-m-repeated-k-or-more-times/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "from typing import List\ndef containsPattern(arr: List[int], m: int, k: int) -> bool:\n    i = 0\n    while i <= len(arr)-1:\n            p = arr[i:i+m]\n            if p * k == arr[i:i+m*k]:\n                    return True\n            i += 1\n    return False", "asserts": ["assert containsPattern([1,2,4,4,4,4],1,3)==True", "assert containsPattern([1,2,3,1,2,3,1,2,3], 3, 3) == True", "assert containsPattern([1,1,1,2,2,2,3,3], 2, 2) == False", "assert containsPattern([5,5,5,5,5,5,5], 1, 6) == True", "assert containsPattern([1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2], 2, 5) == True", "assert containsPattern([10,100,10,100,10,100,10,10,10,100], 2, 4) == False", "assert containsPattern([3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3], 4, 3) == True"]}], "category": "Pattern", "prompt_tokens": 1179, "total_tokens": 1486, "completion_tokens": 307, "completion": "Find All Anagrams in a String: Given a string s and a non-empty string p, find all the start indices of p's anagrams in s.\n\nStrings consists of lowercase English letters only.\n\n###Code:\n\ndef findAnagrams(s: str, p: str) -> List[int]:\n    from collections import Counter\n    res = []\n    p_counter = Counter(p)\n    s_counter = Counter(s[:len(p)-1])\n    for i in range(len(p)-1, len(s)):\n        s_counter[s[i]] += 1\n        if s_counter == p_counter:\n            res.append(i - len(p) + 1)\n        s_counter[s[i - len(p) + 1]] -= 1\n        if s_counter[s[i - len(p) + 1]] == 0:\n            del s_counter[s[i - len(p) + 1]]\n    return res\n\n###Testcases:\n\nassert findAnagrams(\"cbaebabacd\", \"abc\") == [0, 6]\nassert findAnagrams(\"abab\", \"ab\") == [0, 1, 2]\nassert findAnagrams(\"aaaaaaaaaa\", \"a\") == [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nassert findAnagrams(\"bbaa\", \"aa\") == [1]\nassert findAnagrams(\"abccccbca\", \"abc\") == [3, 7]\n\n", "temperature": 0.983}, {"few_shots": [{"author": "Hafeez", "UUID": "124bfeca-24d0-411d-b4ad-26009b79436b", "question": "Word Pattern II: Given a pattern and a string s, return true if s matches the pattern.\n\nA string s matches a pattern if there is some bijective mapping of single characters to non-empty strings such that if each character in pattern is replaced by the string it maps to, then the resulting string is s. A bijective mapping means that no two characters map to the same string, and no character maps to two different strings.", "examples": "Input: pattern = \"abab\", s = \"redblueredblue\"\nOutput: true\nExplanation: One possible mapping is as follows:\n'a' -> \"red\"\n'b' -> \"blue\"\nInput: pattern = \"aabb\", s = \"xyzabcxzyabc\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern-ii/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def wordPatternMatch(pattern: str, s: str) -> bool:\n    def backtrack(cur: str, pattern: str, mappings: dict):\n        if not pattern:\n            return not cur\n        if pattern[0] in mappings:\n            if cur[:len(mappings[pattern[0]])] != mappings[pattern[0]]:\n                return False\n            return backtrack(cur[len(mappings[pattern[0]]):], pattern[1:], mappings)\n        for i in range(len(cur)):\n            if cur[:i+1] in mappings.values():\n                continue\n            mappings[pattern[0]] = cur[:i+1]\n            if backtrack(cur[i+1:], pattern[1:], mappings):\n                return True\n            del mappings[pattern[0]]\n        return False\n    return backtrack(s, pattern, {})", "asserts": ["assert wordPatternMatch(\"aaaa\", \"asdasdasdasd\")==True", "assert wordPatternMatch(\"abba\", \"dogcatcatdog\") == True", "assert wordPatternMatch(\"ab\", \"aa\") == False # since 'a' and 'b' cannot map to the same string \"a\"", "assert wordPatternMatch(\"xyz\", \"abcdefghi\") == True # 'x' -> \"a\", 'y' -> \"bc\", 'z' -> \"defghi\"", "assert wordPatternMatch(\"aba\", \"eggegg\") == False # 'a' maps to \"egg\", but 'b' cannot be mapped uniquely", "assert wordPatternMatch(\"zzz\", \"aaa\") == True # all 'z' map to \"a\"", "assert wordPatternMatch(\"aba\", \"catdogcat\") == True # 'a' -> \"cat\", 'b' -> \"dog\"", "assert wordPatternMatch(\"abab\", \"xyzxyzabcabc\") == False # cannot match 'a' and 'b' with two different strings each consistent with the pattern", "assert wordPatternMatch(\"abac\", \"xyzxyzxya\") == True # 'a' -> \"xyz\", 'b' -> \"xyz\", 'c' -> \"a\"", "assert wordPatternMatch(\"abcd\", \"xyzy\") == False # pattern too long for the string", "assert wordPatternMatch(\"aaaaa\", \"oneonetwo\") == False # not enough unique strings to map 'a' five times"]}, {"author": "Hafeez", "UUID": "e811f9cc-fa5e-4ea0-8adb-8cf3ab7c72db", "question": "Detect Pattern of Length M Repeated K or More Times: Given an array of positive integers arr, find a pattern of length m that is repeated k or more times.\n\nA pattern is a subarray (consecutive sub-sequence) that consists of one or more values, repeated multiple times consecutively without overlapping. A pattern is defined by its length and the number of repetitions.\n\nReturn true if there exists a pattern of length m that is repeated k or more times, otherwise return false.", "examples": "Input: arr = [1,2,1,2,1,1,1,3], m = 2, k = 2\nOutput: true\nExplanation: The pattern (1,2) of length 2 is repeated 2 consecutive times. Another valid pattern (2,1) is also repeated 2 times.\nInput: arr = [1,2,1,2,1,3], m = 2, k = 3\nOutput: false\nExplanation: The pattern (1,2) is of length 2 but is repeated only 2 times. There is no pattern of length 2 that is repeated 3 or more times.\n", "link": "https://leetcode.com/problems/detect-pattern-of-length-m-repeated-k-or-more-times/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "from typing import List\ndef containsPattern(arr: List[int], m: int, k: int) -> bool:\n    i = 0\n    while i <= len(arr)-1:\n            p = arr[i:i+m]\n            if p * k == arr[i:i+m*k]:\n                    return True\n            i += 1\n    return False", "asserts": ["assert containsPattern([1,2,4,4,4,4],1,3)==True", "assert containsPattern([1,2,3,1,2,3,1,2,3], 3, 3) == True", "assert containsPattern([1,1,1,2,2,2,3,3], 2, 2) == False", "assert containsPattern([5,5,5,5,5,5,5], 1, 6) == True", "assert containsPattern([1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2], 2, 5) == True", "assert containsPattern([10,100,10,100,10,100,10,10,10,100], 2, 4) == False", "assert containsPattern([3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3], 4, 3) == True"]}], "category": "Pattern", "prompt_tokens": 1179, "total_tokens": 1535, "completion_tokens": 356, "completion": "Count Binary Substrings: Give a string s, count the number of non-empty (contiguous) substrings that have the same number of 0's and 1's, and all the 0's and all the 1's in these substrings are grouped consecutively.\n\nFor example, with input \"00110011\", the output should be 6, as the 6 substrings that have the same number of 0's and 1's and all the 0's and 1's are grouped consecutively are: \"0011\", \"01\", \"1100\", \"10\", \"0011\", and \"01\".\n\n###Code: \n\ndef countBinarySubstrings(s: str) -> int:\n    groups = [1]\n    for i in range(1, len(s)):\n        if s[i-1] != s[i]:\n            groups.append(1)\n        else:\n            groups[-1] += 1\n\n    ans = 0\n    for i in range(1, len(groups)):\n        ans += min(groups[i-1], groups[i])\n    return ans\n\n###Testcases: \n\nassert countBinarySubstrings(\"00110011\") == 6\nassert countBinarySubstrings(\"10101\") == 4\nassert countBinarySubstrings(\"00110\") == 3\nassert countBinarySubstrings(\"001100\") == 3\nassert countBinarySubstrings(\"000111\") == 3\nassert countBinarySubstrings(\"0010\") == 2\nassert countBinarySubstrings(\"0000\") == 0\nassert countBinarySubstrings(\"1111\") == 0\nassert countBinarySubstrings(\"1010\") == 2\n\n[/Example 3]", "temperature": 0.821}, {"few_shots": [{"author": "Hafeez", "UUID": "124bfeca-24d0-411d-b4ad-26009b79436b", "question": "Word Pattern II: Given a pattern and a string s, return true if s matches the pattern.\n\nA string s matches a pattern if there is some bijective mapping of single characters to non-empty strings such that if each character in pattern is replaced by the string it maps to, then the resulting string is s. A bijective mapping means that no two characters map to the same string, and no character maps to two different strings.", "examples": "Input: pattern = \"abab\", s = \"redblueredblue\"\nOutput: true\nExplanation: One possible mapping is as follows:\n'a' -> \"red\"\n'b' -> \"blue\"\nInput: pattern = \"aabb\", s = \"xyzabcxzyabc\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern-ii/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def wordPatternMatch(pattern: str, s: str) -> bool:\n    def backtrack(cur: str, pattern: str, mappings: dict):\n        if not pattern:\n            return not cur\n        if pattern[0] in mappings:\n            if cur[:len(mappings[pattern[0]])] != mappings[pattern[0]]:\n                return False\n            return backtrack(cur[len(mappings[pattern[0]]):], pattern[1:], mappings)\n        for i in range(len(cur)):\n            if cur[:i+1] in mappings.values():\n                continue\n            mappings[pattern[0]] = cur[:i+1]\n            if backtrack(cur[i+1:], pattern[1:], mappings):\n                return True\n            del mappings[pattern[0]]\n        return False\n    return backtrack(s, pattern, {})", "asserts": ["assert wordPatternMatch(\"aaaa\", \"asdasdasdasd\")==True", "assert wordPatternMatch(\"abba\", \"dogcatcatdog\") == True", "assert wordPatternMatch(\"ab\", \"aa\") == False # since 'a' and 'b' cannot map to the same string \"a\"", "assert wordPatternMatch(\"xyz\", \"abcdefghi\") == True # 'x' -> \"a\", 'y' -> \"bc\", 'z' -> \"defghi\"", "assert wordPatternMatch(\"aba\", \"eggegg\") == False # 'a' maps to \"egg\", but 'b' cannot be mapped uniquely", "assert wordPatternMatch(\"zzz\", \"aaa\") == True # all 'z' map to \"a\"", "assert wordPatternMatch(\"aba\", \"catdogcat\") == True # 'a' -> \"cat\", 'b' -> \"dog\"", "assert wordPatternMatch(\"abab\", \"xyzxyzabcabc\") == False # cannot match 'a' and 'b' with two different strings each consistent with the pattern", "assert wordPatternMatch(\"abac\", \"xyzxyzxya\") == True # 'a' -> \"xyz\", 'b' -> \"xyz\", 'c' -> \"a\"", "assert wordPatternMatch(\"abcd\", \"xyzy\") == False # pattern too long for the string", "assert wordPatternMatch(\"aaaaa\", \"oneonetwo\") == False # not enough unique strings to map 'a' five times"]}, {"author": "Hafeez", "UUID": "e811f9cc-fa5e-4ea0-8adb-8cf3ab7c72db", "question": "Detect Pattern of Length M Repeated K or More Times: Given an array of positive integers arr, find a pattern of length m that is repeated k or more times.\n\nA pattern is a subarray (consecutive sub-sequence) that consists of one or more values, repeated multiple times consecutively without overlapping. A pattern is defined by its length and the number of repetitions.\n\nReturn true if there exists a pattern of length m that is repeated k or more times, otherwise return false.", "examples": "Input: arr = [1,2,1,2,1,1,1,3], m = 2, k = 2\nOutput: true\nExplanation: The pattern (1,2) of length 2 is repeated 2 consecutive times. Another valid pattern (2,1) is also repeated 2 times.\nInput: arr = [1,2,1,2,1,3], m = 2, k = 3\nOutput: false\nExplanation: The pattern (1,2) is of length 2 but is repeated only 2 times. There is no pattern of length 2 that is repeated 3 or more times.\n", "link": "https://leetcode.com/problems/detect-pattern-of-length-m-repeated-k-or-more-times/description/", "difficulty": "Easy", "categories": ["Pattern"], "code": "from typing import List\ndef containsPattern(arr: List[int], m: int, k: int) -> bool:\n    i = 0\n    while i <= len(arr)-1:\n            p = arr[i:i+m]\n            if p * k == arr[i:i+m*k]:\n                    return True\n            i += 1\n    return False", "asserts": ["assert containsPattern([1,2,4,4,4,4],1,3)==True", "assert containsPattern([1,2,3,1,2,3,1,2,3], 3, 3) == True", "assert containsPattern([1,1,1,2,2,2,3,3], 2, 2) == False", "assert containsPattern([5,5,5,5,5,5,5], 1, 6) == True", "assert containsPattern([1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2], 2, 5) == True", "assert containsPattern([10,100,10,100,10,100,10,10,10,100], 2, 4) == False", "assert containsPattern([3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3], 4, 3) == True"]}], "category": "Pattern", "prompt_tokens": 1179, "total_tokens": 1693, "completion_tokens": 514, "completion": "Find All Anagrams in a String: Given a string s and a non-empty string p, find all the start indices of p's anagrams in s.\n\nStrings consists of lowercase English letters only and the length of both strings s and p will not be larger than 20,100.\n\nThe order of output does not matter.\n\n###Code: \n\nfrom typing import List\ndef findAnagrams(s: str, p: str) -> List[int]:\n    result = []\n    p_count = {}\n    s_count = {}\n    for char in p:\n        p_count[char] = p_count.get(char, 0) + 1\n    for i in range(len(s)):\n        s_count[s[i]] = s_count.get(s[i], 0) + 1\n        if i >= len(p):\n            if s_count[s[i - len(p)]] == 1:\n                del s_count[s[i - len(p)]]\n            else:\n                s_count[s[i - len(p)]] -= 1\n        if s_count == p_count:\n            result.append(i - len(p) + 1)\n    return result\n\n###Testcases: \n\nassert findAnagrams(\"cbaebabacd\", \"abc\") == [0, 6]\nassert findAnagrams(\"abab\", \"ab\") == [0, 1, 2]\nassert findAnagrams(\"af\", \"be\") == []\nassert findAnagrams(\"aaaaa\", \"a\") == [0, 1, 2, 3, 4]\nassert findAnagrams(\"aaaaaaaaaa\", \"a\") == [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nassert findAnagrams(\"abababababababababababababababababababababababab\", \"ab\") == [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38]\n\n[/Example 3]", "temperature": 0.838}, {"few_shots": [{"author": "Hafeez", "UUID": "124bfeca-24d0-411d-b4ad-26009b79436b", "question": "Word Pattern II: Given a pattern and a string s, return true if s matches the pattern.\n\nA string s matches a pattern if there is some bijective mapping of single characters to non-empty strings such that if each character in pattern is replaced by the string it maps to, then the resulting string is s. A bijective mapping means that no two characters map to the same string, and no character maps to two different strings.", "examples": "Input: pattern = \"abab\", s = \"redblueredblue\"\nOutput: true\nExplanation: One possible mapping is as follows:\n'a' -> \"red\"\n'b' -> \"blue\"\nInput: pattern = \"aabb\", s = \"xyzabcxzyabc\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern-ii/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def wordPatternMatch(pattern: str, s: str) -> bool:\n    def backtrack(cur: str, pattern: str, mappings: dict):\n        if not pattern:\n            return not cur\n        if pattern[0] in mappings:\n            if cur[:len(mappings[pattern[0]])] != mappings[pattern[0]]:\n                return False\n            return backtrack(cur[len(mappings[pattern[0]]):], pattern[1:], mappings)\n        for i in range(len(cur)):\n            if cur[:i+1] in mappings.values():\n                continue\n            mappings[pattern[0]] = cur[:i+1]\n            if backtrack(cur[i+1:], pattern[1:], mappings):\n                return True\n            del mappings[pattern[0]]\n        return False\n    return backtrack(s, pattern, {})", "asserts": ["assert wordPatternMatch(\"aaaa\", \"asdasdasdasd\")==True", "assert wordPatternMatch(\"abba\", \"dogcatcatdog\") == True", "assert wordPatternMatch(\"ab\", \"aa\") == False # since 'a' and 'b' cannot map to the same string \"a\"", "assert wordPatternMatch(\"xyz\", \"abcdefghi\") == True # 'x' -> \"a\", 'y' -> \"bc\", 'z' -> \"defghi\"", "assert wordPatternMatch(\"aba\", \"eggegg\") == False # 'a' maps to \"egg\", but 'b' cannot be mapped uniquely", "assert wordPatternMatch(\"zzz\", \"aaa\") == True # all 'z' map to \"a\"", "assert wordPatternMatch(\"aba\", \"catdogcat\") == True # 'a' -> \"cat\", 'b' -> \"dog\"", "assert wordPatternMatch(\"abab\", \"xyzxyzabcabc\") == False # cannot match 'a' and 'b' with two different strings each consistent with the pattern", "assert wordPatternMatch(\"abac\", \"xyzxyzxya\") == True # 'a' -> \"xyz\", 'b' -> \"xyz\", 'c' -> \"a\"", "assert wordPatternMatch(\"abcd\", \"xyzy\") == False # pattern too long for the string", "assert wordPatternMatch(\"aaaaa\", \"oneonetwo\") == False # not enough unique strings to map 'a' five times"]}, {"author": "Hafeez", "UUID": "df98fd29-db88-4de7-a00a-0a3bd5ba1539", "question": "Word Pattern: Given a pattern and a string s, find if s follows the same pattern.\n\nHere follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in s.", "examples": "Input: pattern = \"abba\", s = \"dog cat cat fish\"\nOutput: false\nInput: pattern = \"aaaa\", s = \"dog cat cat dog\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def wordPattern(pattern: str, s: str) -> bool:\n    map_char = {}\n    map_word = {}\n    \n    words = s.split(' ')\n    if len(words) != len(pattern):\n        return False\n    \n    for c, w in zip(pattern, words):\n        if c not in map_char:\n            if w in map_word:\n                return False\n            else:\n                map_char[c] = w\n                map_word[w] = c\n        else:\n            if map_char[c] != w:\n                return False\n    return True", "asserts": ["assert wordPattern(\"abba\", \"dog cat cat dog\")==True", "assert wordPattern(\"aaaa\", \"dog dog dog dog\") == True", "assert wordPattern(\"xyz\", \"apple banana apple\") == False", "assert wordPattern(\"xyx\", \"apple banana apple\") == True", "assert wordPattern(\"abab\", \"dog cat dog cat\") == True", "assert wordPattern(\"aaaa\", \"dog dog dog cat\") == False", "assert wordPattern(\"aabb\", \"dog dog cat cat\") == True", "assert wordPattern(\"abc\", \"dog\") == False  # Not enough words", "assert wordPattern(\"\", \"dog cat\") == False  # Empty pattern", "assert wordPattern(\"a\", \"dog cat dog cat\") == False  # Not enough pattern characters", "assert wordPattern(\"ab\", \"\") == False  # Empty string", "assert wordPattern(\"abb\", \"dog dog dog\") == False  # Same word for different pattern characters", "assert wordPattern(\"abba\", \"dog cat cat\") == False  # Not enough words for the pattern", "assert wordPattern(\"abba\", \"dog cat cat dog fish\") == False  # Extra words beyond the pattern length"]}], "category": "Pattern", "prompt_tokens": 1178, "total_tokens": 1834, "completion_tokens": 656, "completion": "Word Pattern III: Given a pattern and a string s, find if s follows the same pattern, and return the unique mapping of characters to words if it exists.\n\n###Code: \n\n```python\nfrom collections import defaultdict\n\ndef wordPatternMatch(pattern: str, s: str):\n    def backtrack(pattern_ptr, s_ptr, pattern_map, word_set):\n        if pattern_ptr == len(pattern) and s_ptr == len(s):\n            return True\n        if pattern_ptr == len(pattern) or s_ptr == len(s):\n            return False\n        \n        current_char = pattern[pattern_ptr]\n        if current_char in pattern_map:\n            mapped_word = pattern_map[current_char]\n            if s[s_ptr:s_ptr + len(mapped_word)] == mapped_word:\n                return backtrack(pattern_ptr + 1, s_ptr + len(mapped_word), pattern_map, word_set)\n            else:\n                return False\n        else:\n            for end in range(s_ptr, len(s)):\n                word = s[s_ptr:end + 1]\n                if word in word_set:\n                    continue\n                pattern_map[current_char] = word\n                word_set.add(word)\n                if backtrack(pattern_ptr + 1, end + 1, pattern_map, word_set):\n                    return True\n                pattern_map.pop(current_char)\n                word_set.remove(word)\n            return False\n    \n    pattern_map = defaultdict(str)\n    word_set = set()\n    if backtrack(0, 0, pattern_map, word_set):\n        return pattern_map\n    else:\n        return None\n```\n\n###Testcases: \n\n```python\nassert wordPatternMatch(\"abab\", \"redblueredblue\") == {'a': 'red', 'b': 'blue'}\nassert wordPatternMatch(\"aaaa\", \"asdasdasdasd\") == {'a': 'asd'}\nassert wordPatternMatch(\"aabb\", \"xyzabcxzyabc\") == {'a': 'xyz', 'b': 'abc'}\nassert wordPatternMatch(\"ab\", \"aa\") == None  # 'a' and 'b' cannot map to the same string \"a\"\nassert wordPatternMatch(\"aba\", \"eggegg\") == None  # 'a' maps to \"egg\", but 'b' cannot be mapped uniquely\nassert wordPatternMatch(\"zzz\", \"aaa\") == {'z': 'a'}\nassert wordPatternMatch(\"aba\", \"catdogcat\") == {'a': 'cat', 'b': 'dog'}\nassert wordPatternMatch(\"abab\", \"xyzxyzabcabc\") == None  # cannot match 'a' and 'b' with two different strings each consistent with the pattern\nassert wordPatternMatch(\"abac\", \"xyzxyzxya\") == {'a': 'xyz', 'b': 'xyz', 'c': 'xya'}\nassert wordPatternMatch(\"abcd\", \"xyzy\") == None  # pattern too long for the string\nassert wordPatternMatch(\"aaaaa\", \"oneonetwo\") == None  # not enough unique strings to map 'a' five times\n```\n\nIn this example, we're finding if the string follows the given pattern and returning the unique mapping of characters to words if it exists.", "temperature": 0.939}, {"few_shots": [{"author": "Hafeez", "UUID": "124bfeca-24d0-411d-b4ad-26009b79436b", "question": "Word Pattern II: Given a pattern and a string s, return true if s matches the pattern.\n\nA string s matches a pattern if there is some bijective mapping of single characters to non-empty strings such that if each character in pattern is replaced by the string it maps to, then the resulting string is s. A bijective mapping means that no two characters map to the same string, and no character maps to two different strings.", "examples": "Input: pattern = \"abab\", s = \"redblueredblue\"\nOutput: true\nExplanation: One possible mapping is as follows:\n'a' -> \"red\"\n'b' -> \"blue\"\nInput: pattern = \"aabb\", s = \"xyzabcxzyabc\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern-ii/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def wordPatternMatch(pattern: str, s: str) -> bool:\n    def backtrack(cur: str, pattern: str, mappings: dict):\n        if not pattern:\n            return not cur\n        if pattern[0] in mappings:\n            if cur[:len(mappings[pattern[0]])] != mappings[pattern[0]]:\n                return False\n            return backtrack(cur[len(mappings[pattern[0]]):], pattern[1:], mappings)\n        for i in range(len(cur)):\n            if cur[:i+1] in mappings.values():\n                continue\n            mappings[pattern[0]] = cur[:i+1]\n            if backtrack(cur[i+1:], pattern[1:], mappings):\n                return True\n            del mappings[pattern[0]]\n        return False\n    return backtrack(s, pattern, {})", "asserts": ["assert wordPatternMatch(\"aaaa\", \"asdasdasdasd\")==True", "assert wordPatternMatch(\"abba\", \"dogcatcatdog\") == True", "assert wordPatternMatch(\"ab\", \"aa\") == False # since 'a' and 'b' cannot map to the same string \"a\"", "assert wordPatternMatch(\"xyz\", \"abcdefghi\") == True # 'x' -> \"a\", 'y' -> \"bc\", 'z' -> \"defghi\"", "assert wordPatternMatch(\"aba\", \"eggegg\") == False # 'a' maps to \"egg\", but 'b' cannot be mapped uniquely", "assert wordPatternMatch(\"zzz\", \"aaa\") == True # all 'z' map to \"a\"", "assert wordPatternMatch(\"aba\", \"catdogcat\") == True # 'a' -> \"cat\", 'b' -> \"dog\"", "assert wordPatternMatch(\"abab\", \"xyzxyzabcabc\") == False # cannot match 'a' and 'b' with two different strings each consistent with the pattern", "assert wordPatternMatch(\"abac\", \"xyzxyzxya\") == True # 'a' -> \"xyz\", 'b' -> \"xyz\", 'c' -> \"a\"", "assert wordPatternMatch(\"abcd\", \"xyzy\") == False # pattern too long for the string", "assert wordPatternMatch(\"aaaaa\", \"oneonetwo\") == False # not enough unique strings to map 'a' five times"]}, {"author": "Hafeez", "UUID": "df98fd29-db88-4de7-a00a-0a3bd5ba1539", "question": "Word Pattern: Given a pattern and a string s, find if s follows the same pattern.\n\nHere follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in s.", "examples": "Input: pattern = \"abba\", s = \"dog cat cat fish\"\nOutput: false\nInput: pattern = \"aaaa\", s = \"dog cat cat dog\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def wordPattern(pattern: str, s: str) -> bool:\n    map_char = {}\n    map_word = {}\n    \n    words = s.split(' ')\n    if len(words) != len(pattern):\n        return False\n    \n    for c, w in zip(pattern, words):\n        if c not in map_char:\n            if w in map_word:\n                return False\n            else:\n                map_char[c] = w\n                map_word[w] = c\n        else:\n            if map_char[c] != w:\n                return False\n    return True", "asserts": ["assert wordPattern(\"abba\", \"dog cat cat dog\")==True", "assert wordPattern(\"aaaa\", \"dog dog dog dog\") == True", "assert wordPattern(\"xyz\", \"apple banana apple\") == False", "assert wordPattern(\"xyx\", \"apple banana apple\") == True", "assert wordPattern(\"abab\", \"dog cat dog cat\") == True", "assert wordPattern(\"aaaa\", \"dog dog dog cat\") == False", "assert wordPattern(\"aabb\", \"dog dog cat cat\") == True", "assert wordPattern(\"abc\", \"dog\") == False  # Not enough words", "assert wordPattern(\"\", \"dog cat\") == False  # Empty pattern", "assert wordPattern(\"a\", \"dog cat dog cat\") == False  # Not enough pattern characters", "assert wordPattern(\"ab\", \"\") == False  # Empty string", "assert wordPattern(\"abb\", \"dog dog dog\") == False  # Same word for different pattern characters", "assert wordPattern(\"abba\", \"dog cat cat\") == False  # Not enough words for the pattern", "assert wordPattern(\"abba\", \"dog cat cat dog fish\") == False  # Extra words beyond the pattern length"]}], "category": "Pattern", "prompt_tokens": 1178, "total_tokens": 1605, "completion_tokens": 427, "completion": "String Pattern Matching: Given a pattern and a string s, return true if s matches the pattern.\n\nA string s matches a pattern if each word in s can be mapped to a character in the pattern and vice versa, such that the pattern can be used to uniquely map to the words in s.\n\n###Code: \n\ndef stringPatternMatch(pattern: str, s: str) -> bool:\n    def word_pattern_match(pattern, s):\n        if len(pattern) != len(s):\n            return False\n        char_to_word, word_to_char = {}, {}\n        words = s.split()\n        for char, word in zip(pattern, words):\n            if char in char_to_word:\n                if char_to_word[char] != word:\n                    return False\n            else:\n                char_to_word[char] = word\n            if word in word_to_char:\n                if word_to_char[word] != char:\n                    return False\n            else:\n                word_to_char[word] = char\n        return True\n\n    return word_pattern_match(pattern, s)\n\n###Testcases: \n\nassert stringPatternMatch(\"abba\", \"red blue blue red\") == True\nassert stringPatternMatch(\"aaaa\", \"red red red red\") == True\nassert stringPatternMatch(\"abba\", \"red blue blue green\") == False\nassert stringPatternMatch(\"abcd\", \"apple banana apple banana\") == True\nassert stringPatternMatch(\"abba\", \"red blue blue green\") == False\nassert stringPatternMatch(\"abab\", \"red blue red blue\") == True\nassert stringPatternMatch(\"abca\", \"red blue green red\") == True\nassert stringPatternMatch(\"abba\", \"red red red\") == False # Not enough words for the pattern\nassert stringPatternMatch(\"a\", \"red blue\") == True # Single character pattern\nassert stringPatternMatch(\"ab\", \"red\") == False # Not enough words for the pattern\nassert stringPatternMatch(\"abc\", \"\") == False # Empty string\nassert stringPatternMatch(\"\", \"red blue\") == False # Empty pattern\n\n[/Example 3]", "temperature": 0.713}, {"few_shots": [{"author": "Hafeez", "UUID": "124bfeca-24d0-411d-b4ad-26009b79436b", "question": "Word Pattern II: Given a pattern and a string s, return true if s matches the pattern.\n\nA string s matches a pattern if there is some bijective mapping of single characters to non-empty strings such that if each character in pattern is replaced by the string it maps to, then the resulting string is s. A bijective mapping means that no two characters map to the same string, and no character maps to two different strings.", "examples": "Input: pattern = \"abab\", s = \"redblueredblue\"\nOutput: true\nExplanation: One possible mapping is as follows:\n'a' -> \"red\"\n'b' -> \"blue\"\nInput: pattern = \"aabb\", s = \"xyzabcxzyabc\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern-ii/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def wordPatternMatch(pattern: str, s: str) -> bool:\n    def backtrack(cur: str, pattern: str, mappings: dict):\n        if not pattern:\n            return not cur\n        if pattern[0] in mappings:\n            if cur[:len(mappings[pattern[0]])] != mappings[pattern[0]]:\n                return False\n            return backtrack(cur[len(mappings[pattern[0]]):], pattern[1:], mappings)\n        for i in range(len(cur)):\n            if cur[:i+1] in mappings.values():\n                continue\n            mappings[pattern[0]] = cur[:i+1]\n            if backtrack(cur[i+1:], pattern[1:], mappings):\n                return True\n            del mappings[pattern[0]]\n        return False\n    return backtrack(s, pattern, {})", "asserts": ["assert wordPatternMatch(\"aaaa\", \"asdasdasdasd\")==True", "assert wordPatternMatch(\"abba\", \"dogcatcatdog\") == True", "assert wordPatternMatch(\"ab\", \"aa\") == False # since 'a' and 'b' cannot map to the same string \"a\"", "assert wordPatternMatch(\"xyz\", \"abcdefghi\") == True # 'x' -> \"a\", 'y' -> \"bc\", 'z' -> \"defghi\"", "assert wordPatternMatch(\"aba\", \"eggegg\") == False # 'a' maps to \"egg\", but 'b' cannot be mapped uniquely", "assert wordPatternMatch(\"zzz\", \"aaa\") == True # all 'z' map to \"a\"", "assert wordPatternMatch(\"aba\", \"catdogcat\") == True # 'a' -> \"cat\", 'b' -> \"dog\"", "assert wordPatternMatch(\"abab\", \"xyzxyzabcabc\") == False # cannot match 'a' and 'b' with two different strings each consistent with the pattern", "assert wordPatternMatch(\"abac\", \"xyzxyzxya\") == True # 'a' -> \"xyz\", 'b' -> \"xyz\", 'c' -> \"a\"", "assert wordPatternMatch(\"abcd\", \"xyzy\") == False # pattern too long for the string", "assert wordPatternMatch(\"aaaaa\", \"oneonetwo\") == False # not enough unique strings to map 'a' five times"]}, {"author": "Hafeez", "UUID": "df98fd29-db88-4de7-a00a-0a3bd5ba1539", "question": "Word Pattern: Given a pattern and a string s, find if s follows the same pattern.\n\nHere follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in s.", "examples": "Input: pattern = \"abba\", s = \"dog cat cat fish\"\nOutput: false\nInput: pattern = \"aaaa\", s = \"dog cat cat dog\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def wordPattern(pattern: str, s: str) -> bool:\n    map_char = {}\n    map_word = {}\n    \n    words = s.split(' ')\n    if len(words) != len(pattern):\n        return False\n    \n    for c, w in zip(pattern, words):\n        if c not in map_char:\n            if w in map_word:\n                return False\n            else:\n                map_char[c] = w\n                map_word[w] = c\n        else:\n            if map_char[c] != w:\n                return False\n    return True", "asserts": ["assert wordPattern(\"abba\", \"dog cat cat dog\")==True", "assert wordPattern(\"aaaa\", \"dog dog dog dog\") == True", "assert wordPattern(\"xyz\", \"apple banana apple\") == False", "assert wordPattern(\"xyx\", \"apple banana apple\") == True", "assert wordPattern(\"abab\", \"dog cat dog cat\") == True", "assert wordPattern(\"aaaa\", \"dog dog dog cat\") == False", "assert wordPattern(\"aabb\", \"dog dog cat cat\") == True", "assert wordPattern(\"abc\", \"dog\") == False  # Not enough words", "assert wordPattern(\"\", \"dog cat\") == False  # Empty pattern", "assert wordPattern(\"a\", \"dog cat dog cat\") == False  # Not enough pattern characters", "assert wordPattern(\"ab\", \"\") == False  # Empty string", "assert wordPattern(\"abb\", \"dog dog dog\") == False  # Same word for different pattern characters", "assert wordPattern(\"abba\", \"dog cat cat\") == False  # Not enough words for the pattern", "assert wordPattern(\"abba\", \"dog cat cat dog fish\") == False  # Extra words beyond the pattern length"]}], "category": "Pattern", "prompt_tokens": 1178, "total_tokens": 1714, "completion_tokens": 536, "completion": "Pattern Matching: Given a pattern and a string, find if the string follows the same pattern.\n\n###Code: \n\ndef patternMatching(pattern: str, s: str) -> bool:\n    n = len(s)\n    cnt_a = sum(1 for c in pattern if c == 'a')\n    cnt_b = len(pattern) - cnt_a\n    if cnt_a == 0 and cnt_b == 0:\n        return n == 0\n    if cnt_a == 0 or cnt_b == 0:\n        if n % max(cnt_a, cnt_b) != 0:\n            return False\n        length = n // max(cnt_a, cnt_b)\n        return s == s[:length] * max(cnt_a, cnt_b)\n    for len_a in range(n // cnt_a + 1):\n        rest = n - cnt_a * len_a\n        if (cnt_b == 0 and rest == 0) or (cnt_b != 0 and rest % cnt_b == 0):\n            len_b = 0 if cnt_b == 0 else rest // cnt_b\n            pos, valid = 0, True\n            a, b = None, None\n            for ch in pattern:\n                if ch == 'a':\n                    sub = s[pos:pos + len_a]\n                    if a is None:\n                        a = sub\n                    elif a != sub:\n                        valid = False\n                        break\n                    pos += len_a\n                else:\n                    sub = s[pos:pos + len_b]\n                    if b is None:\n                        b = sub\n                    elif b != sub:\n                        valid = False\n                        break\n                    pos += len_b\n            if valid and a != b:\n                return True\n    return False\n\n###Testcases: \n\nassert patternMatching(\"abab\", \"redblueredblue\") == True\nassert patternMatching(\"aaaa\", \"asdasdasdasd\") == True\nassert patternMatching(\"aabb\", \"xyzabcxyzabc\") == True\nassert patternMatching(\"ab\", \"aa\") == False\nassert patternMatching(\"aaaa\", \"catcatcatcat\") == True\nassert patternMatching(\"ab\", \"xyzxyzxyzxyz\") == True\nassert patternMatching(\"a\", \"xyz\") == True\nassert patternMatching(\"abba\", \"dogcatcatdog\") == True\nassert patternMatching(\"abab\", \"xyx\") == True\nassert patternMatching(\"abba\", \"dogcatcatfish\") == False\nassert patternMatching(\"aaaa\", \"asdasdasdasd\") == True\n\n[/Example 3]", "temperature": 0.84}, {"few_shots": [{"author": "Hafeez", "UUID": "124bfeca-24d0-411d-b4ad-26009b79436b", "question": "Word Pattern II: Given a pattern and a string s, return true if s matches the pattern.\n\nA string s matches a pattern if there is some bijective mapping of single characters to non-empty strings such that if each character in pattern is replaced by the string it maps to, then the resulting string is s. A bijective mapping means that no two characters map to the same string, and no character maps to two different strings.", "examples": "Input: pattern = \"abab\", s = \"redblueredblue\"\nOutput: true\nExplanation: One possible mapping is as follows:\n'a' -> \"red\"\n'b' -> \"blue\"\nInput: pattern = \"aabb\", s = \"xyzabcxzyabc\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern-ii/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def wordPatternMatch(pattern: str, s: str) -> bool:\n    def backtrack(cur: str, pattern: str, mappings: dict):\n        if not pattern:\n            return not cur\n        if pattern[0] in mappings:\n            if cur[:len(mappings[pattern[0]])] != mappings[pattern[0]]:\n                return False\n            return backtrack(cur[len(mappings[pattern[0]]):], pattern[1:], mappings)\n        for i in range(len(cur)):\n            if cur[:i+1] in mappings.values():\n                continue\n            mappings[pattern[0]] = cur[:i+1]\n            if backtrack(cur[i+1:], pattern[1:], mappings):\n                return True\n            del mappings[pattern[0]]\n        return False\n    return backtrack(s, pattern, {})", "asserts": ["assert wordPatternMatch(\"aaaa\", \"asdasdasdasd\")==True", "assert wordPatternMatch(\"abba\", \"dogcatcatdog\") == True", "assert wordPatternMatch(\"ab\", \"aa\") == False # since 'a' and 'b' cannot map to the same string \"a\"", "assert wordPatternMatch(\"xyz\", \"abcdefghi\") == True # 'x' -> \"a\", 'y' -> \"bc\", 'z' -> \"defghi\"", "assert wordPatternMatch(\"aba\", \"eggegg\") == False # 'a' maps to \"egg\", but 'b' cannot be mapped uniquely", "assert wordPatternMatch(\"zzz\", \"aaa\") == True # all 'z' map to \"a\"", "assert wordPatternMatch(\"aba\", \"catdogcat\") == True # 'a' -> \"cat\", 'b' -> \"dog\"", "assert wordPatternMatch(\"abab\", \"xyzxyzabcabc\") == False # cannot match 'a' and 'b' with two different strings each consistent with the pattern", "assert wordPatternMatch(\"abac\", \"xyzxyzxya\") == True # 'a' -> \"xyz\", 'b' -> \"xyz\", 'c' -> \"a\"", "assert wordPatternMatch(\"abcd\", \"xyzy\") == False # pattern too long for the string", "assert wordPatternMatch(\"aaaaa\", \"oneonetwo\") == False # not enough unique strings to map 'a' five times"]}, {"author": "Hafeez", "UUID": "df98fd29-db88-4de7-a00a-0a3bd5ba1539", "question": "Word Pattern: Given a pattern and a string s, find if s follows the same pattern.\n\nHere follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in s.", "examples": "Input: pattern = \"abba\", s = \"dog cat cat fish\"\nOutput: false\nInput: pattern = \"aaaa\", s = \"dog cat cat dog\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def wordPattern(pattern: str, s: str) -> bool:\n    map_char = {}\n    map_word = {}\n    \n    words = s.split(' ')\n    if len(words) != len(pattern):\n        return False\n    \n    for c, w in zip(pattern, words):\n        if c not in map_char:\n            if w in map_word:\n                return False\n            else:\n                map_char[c] = w\n                map_word[w] = c\n        else:\n            if map_char[c] != w:\n                return False\n    return True", "asserts": ["assert wordPattern(\"abba\", \"dog cat cat dog\")==True", "assert wordPattern(\"aaaa\", \"dog dog dog dog\") == True", "assert wordPattern(\"xyz\", \"apple banana apple\") == False", "assert wordPattern(\"xyx\", \"apple banana apple\") == True", "assert wordPattern(\"abab\", \"dog cat dog cat\") == True", "assert wordPattern(\"aaaa\", \"dog dog dog cat\") == False", "assert wordPattern(\"aabb\", \"dog dog cat cat\") == True", "assert wordPattern(\"abc\", \"dog\") == False  # Not enough words", "assert wordPattern(\"\", \"dog cat\") == False  # Empty pattern", "assert wordPattern(\"a\", \"dog cat dog cat\") == False  # Not enough pattern characters", "assert wordPattern(\"ab\", \"\") == False  # Empty string", "assert wordPattern(\"abb\", \"dog dog dog\") == False  # Same word for different pattern characters", "assert wordPattern(\"abba\", \"dog cat cat\") == False  # Not enough words for the pattern", "assert wordPattern(\"abba\", \"dog cat cat dog fish\") == False  # Extra words beyond the pattern length"]}], "category": "Pattern", "prompt_tokens": 1178, "total_tokens": 1608, "completion_tokens": 430, "completion": "Word Pattern III: Given a pattern and a string s, find if s follows the same pattern. Additionally, return the mapping of characters to words.\n\n###Code: \n\ndef wordPattern(pattern: str, s: str) -> (bool, dict):\n    words = s.split(' ')\n    if len(pattern) != len(words):\n        return False, {}\n    \n    char_to_word = {}\n    word_to_char = {}\n    for char, word in zip(pattern, words):\n        if char not in char_to_word:\n            if word in word_to_char:\n                return False, {}\n            else:\n                char_to_word[char] = word\n                word_to_char[word] = char\n        else:\n            if char_to_word[char] != word:\n                return False, {}\n    \n    return True, char_to_word\n\n###Testcases: \n\npattern1, s1 = \"abba\", \"dog cat cat dog\"\nassert wordPattern(pattern1, s1) == (True, {'a': 'dog', 'b': 'cat'})\npattern2, s2 = \"aaaa\", \"dog dog dog dog\"\nassert wordPattern(pattern2, s2) == (True, {'a': 'dog'})\npattern3, s3 = \"xyz\", \"apple banana apple\"\nassert wordPattern(pattern3, s3) == (False, {})\npattern4, s4 = \"xyx\", \"apple banana apple\"\nassert wordPattern(pattern4, s4) == (True, {'x': 'apple', 'y': 'banana'})\npattern5, s5 = \"abab\", \"dog cat dog cat\"\nassert wordPattern(pattern5, s5) == (True, {'a': 'dog', 'b': 'cat'})\npattern6, s6 = \"aaaa\", \"dog dog dog cat\"\nassert wordPattern(pattern6, s6) == (False, {})\npattern7, s7 = \"aabb\", \"dog dog cat cat\"\nassert wordPattern(pattern7, s7) == (True, {'a': 'dog', 'b': 'cat'})\n\n[/Example 3]", "temperature": 0.601}, {"few_shots": [{"author": "Hafeez", "UUID": "124bfeca-24d0-411d-b4ad-26009b79436b", "question": "Word Pattern II: Given a pattern and a string s, return true if s matches the pattern.\n\nA string s matches a pattern if there is some bijective mapping of single characters to non-empty strings such that if each character in pattern is replaced by the string it maps to, then the resulting string is s. A bijective mapping means that no two characters map to the same string, and no character maps to two different strings.", "examples": "Input: pattern = \"abab\", s = \"redblueredblue\"\nOutput: true\nExplanation: One possible mapping is as follows:\n'a' -> \"red\"\n'b' -> \"blue\"\nInput: pattern = \"aabb\", s = \"xyzabcxzyabc\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern-ii/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def wordPatternMatch(pattern: str, s: str) -> bool:\n    def backtrack(cur: str, pattern: str, mappings: dict):\n        if not pattern:\n            return not cur\n        if pattern[0] in mappings:\n            if cur[:len(mappings[pattern[0]])] != mappings[pattern[0]]:\n                return False\n            return backtrack(cur[len(mappings[pattern[0]]):], pattern[1:], mappings)\n        for i in range(len(cur)):\n            if cur[:i+1] in mappings.values():\n                continue\n            mappings[pattern[0]] = cur[:i+1]\n            if backtrack(cur[i+1:], pattern[1:], mappings):\n                return True\n            del mappings[pattern[0]]\n        return False\n    return backtrack(s, pattern, {})", "asserts": ["assert wordPatternMatch(\"aaaa\", \"asdasdasdasd\")==True", "assert wordPatternMatch(\"abba\", \"dogcatcatdog\") == True", "assert wordPatternMatch(\"ab\", \"aa\") == False # since 'a' and 'b' cannot map to the same string \"a\"", "assert wordPatternMatch(\"xyz\", \"abcdefghi\") == True # 'x' -> \"a\", 'y' -> \"bc\", 'z' -> \"defghi\"", "assert wordPatternMatch(\"aba\", \"eggegg\") == False # 'a' maps to \"egg\", but 'b' cannot be mapped uniquely", "assert wordPatternMatch(\"zzz\", \"aaa\") == True # all 'z' map to \"a\"", "assert wordPatternMatch(\"aba\", \"catdogcat\") == True # 'a' -> \"cat\", 'b' -> \"dog\"", "assert wordPatternMatch(\"abab\", \"xyzxyzabcabc\") == False # cannot match 'a' and 'b' with two different strings each consistent with the pattern", "assert wordPatternMatch(\"abac\", \"xyzxyzxya\") == True # 'a' -> \"xyz\", 'b' -> \"xyz\", 'c' -> \"a\"", "assert wordPatternMatch(\"abcd\", \"xyzy\") == False # pattern too long for the string", "assert wordPatternMatch(\"aaaaa\", \"oneonetwo\") == False # not enough unique strings to map 'a' five times"]}, {"author": "Hafeez", "UUID": "df98fd29-db88-4de7-a00a-0a3bd5ba1539", "question": "Word Pattern: Given a pattern and a string s, find if s follows the same pattern.\n\nHere follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in s.", "examples": "Input: pattern = \"abba\", s = \"dog cat cat fish\"\nOutput: false\nInput: pattern = \"aaaa\", s = \"dog cat cat dog\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def wordPattern(pattern: str, s: str) -> bool:\n    map_char = {}\n    map_word = {}\n    \n    words = s.split(' ')\n    if len(words) != len(pattern):\n        return False\n    \n    for c, w in zip(pattern, words):\n        if c not in map_char:\n            if w in map_word:\n                return False\n            else:\n                map_char[c] = w\n                map_word[w] = c\n        else:\n            if map_char[c] != w:\n                return False\n    return True", "asserts": ["assert wordPattern(\"abba\", \"dog cat cat dog\")==True", "assert wordPattern(\"aaaa\", \"dog dog dog dog\") == True", "assert wordPattern(\"xyz\", \"apple banana apple\") == False", "assert wordPattern(\"xyx\", \"apple banana apple\") == True", "assert wordPattern(\"abab\", \"dog cat dog cat\") == True", "assert wordPattern(\"aaaa\", \"dog dog dog cat\") == False", "assert wordPattern(\"aabb\", \"dog dog cat cat\") == True", "assert wordPattern(\"abc\", \"dog\") == False  # Not enough words", "assert wordPattern(\"\", \"dog cat\") == False  # Empty pattern", "assert wordPattern(\"a\", \"dog cat dog cat\") == False  # Not enough pattern characters", "assert wordPattern(\"ab\", \"\") == False  # Empty string", "assert wordPattern(\"abb\", \"dog dog dog\") == False  # Same word for different pattern characters", "assert wordPattern(\"abba\", \"dog cat cat\") == False  # Not enough words for the pattern", "assert wordPattern(\"abba\", \"dog cat cat dog fish\") == False  # Extra words beyond the pattern length"]}], "category": "Pattern", "prompt_tokens": 1178, "total_tokens": 1564, "completion_tokens": 386, "completion": "Find All Anagrams in a String: Given a string s and a non-empty string p, find all the start indices of p's anagrams in s.\n\nStrings consists of lowercase English letters only.\n\n###Code: \n\n```python\ndef findAnagrams(s: str, p: str):\n    result = []\n    if len(s) < len(p):\n        return result\n    \n    p_count = [0] * 26\n    s_count = [0] * 26\n    \n    for i in range(len(p)):\n        p_count[ord(p[i]) - ord('a')] += 1\n        s_count[ord(s[i]) - ord('a')] += 1\n        \n    if p_count == s_count:\n        result.append(0)\n        \n    for i in range(len(p), len(s)):\n        s_count[ord(s[i]) - ord('a')] += 1\n        s_count[ord(s[i - len(p)]) - ord('a')] -= 1\n        if p_count == s_count:\n            result.append(i - len(p) + 1)\n            \n    return result\n```\n\n###Testcases: \n\n```python\nassert findAnagrams(\"cbaebabacd\", \"abc\") == [0, 6]\nassert findAnagrams(\"abab\", \"ab\") == [0, 1, 2]\nassert findAnagrams(\"aaaaa\", \"aa\") == [0, 1, 2, 3]\nassert findAnagrams(\"abcdef\", \"xyz\") == []\nassert findAnagrams(\"aaaaaaaaaa\", \"a\") == [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nassert findAnagrams(\"ab\", \"abc\") == []\nassert findAnagrams(\"\", \"a\") == []\n```\n\n[/Example 3]", "temperature": 0.676}, {"few_shots": [{"author": "Hafeez", "UUID": "124bfeca-24d0-411d-b4ad-26009b79436b", "question": "Word Pattern II: Given a pattern and a string s, return true if s matches the pattern.\n\nA string s matches a pattern if there is some bijective mapping of single characters to non-empty strings such that if each character in pattern is replaced by the string it maps to, then the resulting string is s. A bijective mapping means that no two characters map to the same string, and no character maps to two different strings.", "examples": "Input: pattern = \"abab\", s = \"redblueredblue\"\nOutput: true\nExplanation: One possible mapping is as follows:\n'a' -> \"red\"\n'b' -> \"blue\"\nInput: pattern = \"aabb\", s = \"xyzabcxzyabc\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern-ii/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def wordPatternMatch(pattern: str, s: str) -> bool:\n    def backtrack(cur: str, pattern: str, mappings: dict):\n        if not pattern:\n            return not cur\n        if pattern[0] in mappings:\n            if cur[:len(mappings[pattern[0]])] != mappings[pattern[0]]:\n                return False\n            return backtrack(cur[len(mappings[pattern[0]]):], pattern[1:], mappings)\n        for i in range(len(cur)):\n            if cur[:i+1] in mappings.values():\n                continue\n            mappings[pattern[0]] = cur[:i+1]\n            if backtrack(cur[i+1:], pattern[1:], mappings):\n                return True\n            del mappings[pattern[0]]\n        return False\n    return backtrack(s, pattern, {})", "asserts": ["assert wordPatternMatch(\"aaaa\", \"asdasdasdasd\")==True", "assert wordPatternMatch(\"abba\", \"dogcatcatdog\") == True", "assert wordPatternMatch(\"ab\", \"aa\") == False # since 'a' and 'b' cannot map to the same string \"a\"", "assert wordPatternMatch(\"xyz\", \"abcdefghi\") == True # 'x' -> \"a\", 'y' -> \"bc\", 'z' -> \"defghi\"", "assert wordPatternMatch(\"aba\", \"eggegg\") == False # 'a' maps to \"egg\", but 'b' cannot be mapped uniquely", "assert wordPatternMatch(\"zzz\", \"aaa\") == True # all 'z' map to \"a\"", "assert wordPatternMatch(\"aba\", \"catdogcat\") == True # 'a' -> \"cat\", 'b' -> \"dog\"", "assert wordPatternMatch(\"abab\", \"xyzxyzabcabc\") == False # cannot match 'a' and 'b' with two different strings each consistent with the pattern", "assert wordPatternMatch(\"abac\", \"xyzxyzxya\") == True # 'a' -> \"xyz\", 'b' -> \"xyz\", 'c' -> \"a\"", "assert wordPatternMatch(\"abcd\", \"xyzy\") == False # pattern too long for the string", "assert wordPatternMatch(\"aaaaa\", \"oneonetwo\") == False # not enough unique strings to map 'a' five times"]}, {"author": "Hafeez", "UUID": "df98fd29-db88-4de7-a00a-0a3bd5ba1539", "question": "Word Pattern: Given a pattern and a string s, find if s follows the same pattern.\n\nHere follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in s.", "examples": "Input: pattern = \"abba\", s = \"dog cat cat fish\"\nOutput: false\nInput: pattern = \"aaaa\", s = \"dog cat cat dog\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def wordPattern(pattern: str, s: str) -> bool:\n    map_char = {}\n    map_word = {}\n    \n    words = s.split(' ')\n    if len(words) != len(pattern):\n        return False\n    \n    for c, w in zip(pattern, words):\n        if c not in map_char:\n            if w in map_word:\n                return False\n            else:\n                map_char[c] = w\n                map_word[w] = c\n        else:\n            if map_char[c] != w:\n                return False\n    return True", "asserts": ["assert wordPattern(\"abba\", \"dog cat cat dog\")==True", "assert wordPattern(\"aaaa\", \"dog dog dog dog\") == True", "assert wordPattern(\"xyz\", \"apple banana apple\") == False", "assert wordPattern(\"xyx\", \"apple banana apple\") == True", "assert wordPattern(\"abab\", \"dog cat dog cat\") == True", "assert wordPattern(\"aaaa\", \"dog dog dog cat\") == False", "assert wordPattern(\"aabb\", \"dog dog cat cat\") == True", "assert wordPattern(\"abc\", \"dog\") == False  # Not enough words", "assert wordPattern(\"\", \"dog cat\") == False  # Empty pattern", "assert wordPattern(\"a\", \"dog cat dog cat\") == False  # Not enough pattern characters", "assert wordPattern(\"ab\", \"\") == False  # Empty string", "assert wordPattern(\"abb\", \"dog dog dog\") == False  # Same word for different pattern characters", "assert wordPattern(\"abba\", \"dog cat cat\") == False  # Not enough words for the pattern", "assert wordPattern(\"abba\", \"dog cat cat dog fish\") == False  # Extra words beyond the pattern length"]}], "category": "Pattern", "prompt_tokens": 1178, "total_tokens": 1649, "completion_tokens": 471, "completion": "Word Pattern III: Given a pattern and a string s, find all possible bijections between the pattern characters and the words in s.\n\n###Code:\n\ndef wordPatternIII(pattern: str, s: str):\n    def backtrack(pattern, s, pattern_map, word_map):\n        if not pattern and not s:\n            return [pattern_map]\n        if not pattern or not s:\n            return []\n        \n        res = []\n        char = pattern[0]\n        if char in pattern_map:\n            prefix = pattern_map[char]\n            if s.startswith(prefix):\n                res += backtrack(pattern[1:], s[len(prefix):], pattern_map, word_map)\n        else:\n            for i in range(1, len(s) + 1):\n                prefix = s[:i]\n                if prefix not in word_map:\n                    pattern_map[char] = prefix\n                    word_map.add(prefix)\n                    res += backtrack(pattern[1:], s[i:], pattern_map, word_map)\n                    del pattern_map[char]\n                    word_map.remove(prefix)\n        return res\n    \n    return backtrack(pattern, s, {}, set())\n\n###Testcases:\n\nassert wordPatternIII(\"abba\", \"redbluebluered\") == [{'a': 'red', 'b': 'blue'}]\nassert wordPatternIII(\"aaaa\", \"dogdogdogdog\") == [{'a': 'dog'}]\nassert wordPatternIII(\"ab\", \"aa\") == []\nassert wordPatternIII(\"xyz\", \"abc\") == [{'x': 'a', 'y': 'b', 'z': 'c'}]\nassert wordPatternIII(\"aba\", \"eggegg\") == [{'a': 'egg', 'b': 'g'}]\nassert wordPatternIII(\"zzz\", \"aaa\") == [{'z': 'a'}]\nassert wordPatternIII(\"aba\", \"catdogcat\") == [{'a': 'cat', 'b': 'dog'}]\nassert wordPatternIII(\"abab\", \"xyzxyzabcabc\") == []\nassert wordPatternIII(\"abac\", \"xyzxyzxya\") == [{'a': 'xyz', 'b': 'xyz', 'c': 'xy'}]\nassert wordPatternIII(\"abcd\", \"xyzy\") == []\nassert wordPatternIII(\"aaaaa\", \"oneonetwo\") == []\n\n[/Example 3]", "temperature": 0.796}, {"few_shots": [{"author": "Hafeez", "UUID": "124bfeca-24d0-411d-b4ad-26009b79436b", "question": "Word Pattern II: Given a pattern and a string s, return true if s matches the pattern.\n\nA string s matches a pattern if there is some bijective mapping of single characters to non-empty strings such that if each character in pattern is replaced by the string it maps to, then the resulting string is s. A bijective mapping means that no two characters map to the same string, and no character maps to two different strings.", "examples": "Input: pattern = \"abab\", s = \"redblueredblue\"\nOutput: true\nExplanation: One possible mapping is as follows:\n'a' -> \"red\"\n'b' -> \"blue\"\nInput: pattern = \"aabb\", s = \"xyzabcxzyabc\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern-ii/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def wordPatternMatch(pattern: str, s: str) -> bool:\n    def backtrack(cur: str, pattern: str, mappings: dict):\n        if not pattern:\n            return not cur\n        if pattern[0] in mappings:\n            if cur[:len(mappings[pattern[0]])] != mappings[pattern[0]]:\n                return False\n            return backtrack(cur[len(mappings[pattern[0]]):], pattern[1:], mappings)\n        for i in range(len(cur)):\n            if cur[:i+1] in mappings.values():\n                continue\n            mappings[pattern[0]] = cur[:i+1]\n            if backtrack(cur[i+1:], pattern[1:], mappings):\n                return True\n            del mappings[pattern[0]]\n        return False\n    return backtrack(s, pattern, {})", "asserts": ["assert wordPatternMatch(\"aaaa\", \"asdasdasdasd\")==True", "assert wordPatternMatch(\"abba\", \"dogcatcatdog\") == True", "assert wordPatternMatch(\"ab\", \"aa\") == False # since 'a' and 'b' cannot map to the same string \"a\"", "assert wordPatternMatch(\"xyz\", \"abcdefghi\") == True # 'x' -> \"a\", 'y' -> \"bc\", 'z' -> \"defghi\"", "assert wordPatternMatch(\"aba\", \"eggegg\") == False # 'a' maps to \"egg\", but 'b' cannot be mapped uniquely", "assert wordPatternMatch(\"zzz\", \"aaa\") == True # all 'z' map to \"a\"", "assert wordPatternMatch(\"aba\", \"catdogcat\") == True # 'a' -> \"cat\", 'b' -> \"dog\"", "assert wordPatternMatch(\"abab\", \"xyzxyzabcabc\") == False # cannot match 'a' and 'b' with two different strings each consistent with the pattern", "assert wordPatternMatch(\"abac\", \"xyzxyzxya\") == True # 'a' -> \"xyz\", 'b' -> \"xyz\", 'c' -> \"a\"", "assert wordPatternMatch(\"abcd\", \"xyzy\") == False # pattern too long for the string", "assert wordPatternMatch(\"aaaaa\", \"oneonetwo\") == False # not enough unique strings to map 'a' five times"]}, {"author": "Hafeez", "UUID": "df98fd29-db88-4de7-a00a-0a3bd5ba1539", "question": "Word Pattern: Given a pattern and a string s, find if s follows the same pattern.\n\nHere follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in s.", "examples": "Input: pattern = \"abba\", s = \"dog cat cat fish\"\nOutput: false\nInput: pattern = \"aaaa\", s = \"dog cat cat dog\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def wordPattern(pattern: str, s: str) -> bool:\n    map_char = {}\n    map_word = {}\n    \n    words = s.split(' ')\n    if len(words) != len(pattern):\n        return False\n    \n    for c, w in zip(pattern, words):\n        if c not in map_char:\n            if w in map_word:\n                return False\n            else:\n                map_char[c] = w\n                map_word[w] = c\n        else:\n            if map_char[c] != w:\n                return False\n    return True", "asserts": ["assert wordPattern(\"abba\", \"dog cat cat dog\")==True", "assert wordPattern(\"aaaa\", \"dog dog dog dog\") == True", "assert wordPattern(\"xyz\", \"apple banana apple\") == False", "assert wordPattern(\"xyx\", \"apple banana apple\") == True", "assert wordPattern(\"abab\", \"dog cat dog cat\") == True", "assert wordPattern(\"aaaa\", \"dog dog dog cat\") == False", "assert wordPattern(\"aabb\", \"dog dog cat cat\") == True", "assert wordPattern(\"abc\", \"dog\") == False  # Not enough words", "assert wordPattern(\"\", \"dog cat\") == False  # Empty pattern", "assert wordPattern(\"a\", \"dog cat dog cat\") == False  # Not enough pattern characters", "assert wordPattern(\"ab\", \"\") == False  # Empty string", "assert wordPattern(\"abb\", \"dog dog dog\") == False  # Same word for different pattern characters", "assert wordPattern(\"abba\", \"dog cat cat\") == False  # Not enough words for the pattern", "assert wordPattern(\"abba\", \"dog cat cat dog fish\") == False  # Extra words beyond the pattern length"]}], "category": "Pattern", "prompt_tokens": 1178, "total_tokens": 1894, "completion_tokens": 716, "completion": "Word Pattern III: Given a pattern and a string s, return true if s matches the pattern. In this case, the pattern can contain both single and multiple characters. A multiple character is a character that can be mapped to one or more strings.\n\n###Code: \n\n```python\ndef wordPatternMatch(pattern: str, s: str) -> bool:\n    def backtrack(pattern, s, pattern_to_word, word_to_pattern):\n        if not pattern and not s:\n            return True\n        if not pattern or not s:\n            return False\n        char = pattern[0]\n        if char in pattern_to_word:\n            word = pattern_to_word[char]\n            if s.startswith(word):\n                return backtrack(pattern[1:], s[len(word):], pattern_to_word, word_to_pattern)\n            else:\n                return False\n        else:\n            for i in range(1, len(s)+1):\n                word = s[:i]\n                if word in word_to_pattern:\n                    continue\n                pattern_to_word[char] = word\n                word_to_pattern[word] = char\n                if backtrack(pattern[1:], s[i:], pattern_to_word, word_to_pattern):\n                    return True\n                del pattern_to_word[char]\n                del word_to_pattern[word]\n            return False\n    \n    return backtrack(pattern, s, {}, {})\n\n```\n\n###Testcases: \n\n```python\nassert wordPatternMatch(\"abab\", \"redblueredblue\") == True\nassert wordPatternMatch(\"aaaa\", \"asdasdasdasd\") == True\nassert wordPatternMatch(\"aabb\", \"xyzabcxzyabc\") == False\nassert wordPatternMatch(\"ab\", \"aa\") == False\nassert wordPatternMatch(\"ab\", \"xyzabcxzyabc\") == True\nassert wordPatternMatch(\"abab\", \"xyzxyzabcabc\") == True\nassert wordPatternMatch(\"aba\", \"xyzxyzxya\") == True\nassert wordPatternMatch(\"abac\", \"xyzxyzxya\") == False\nassert wordPatternMatch(\"abba\", \"dogcatcatdog\") == True\nassert wordPatternMatch(\"abba\", \"dogcatcatfish\") == False\nassert wordPatternMatch(\"aaaa\", \"oneonetwo\") == False\nassert wordPatternMatch(\"ab\", \"\") == False\nassert wordPatternMatch(\"\", \"xyz\") == False\nassert wordPatternMatch(\"abc\", \"dog\") == False\nassert wordPatternMatch(\"abab\", \"redblueredblue\") == True\nassert wordPatternMatch(\"abab\", \"redblueredblue\") == True\nassert wordPatternMatch(\"aabb\", \"xyzabcxzyabc\") == False\nassert wordPatternMatch(\"ab\", \"aa\") == False\nassert wordPatternMatch(\"ab\", \"xyzabcxzyabc\") == True\nassert wordPatternMatch(\"abab\", \"xyzxyzabcabc\") == True\nassert wordPatternMatch(\"aba\", \"xyzxyzxya\") == True\nassert wordPatternMatch(\"abac\", \"xyzxyzxya\") == False\nassert wordPatternMatch(\"abba\", \"dogcatcatdog\") == True\nassert wordPatternMatch(\"abba\", \"dogcatcatfish\") == False\nassert wordPatternMatch(\"aaaa\", \"oneonetwo\") == False\nassert wordPatternMatch(\"ab\", \"\") == False\nassert wordPatternMatch(\"\", \"xyz\") == False\nassert wordPatternMatch(\"abc\", \"dog\") == False\n```\n\n", "temperature": 0.609}, {"few_shots": [{"author": "Hafeez", "UUID": "124bfeca-24d0-411d-b4ad-26009b79436b", "question": "Word Pattern II: Given a pattern and a string s, return true if s matches the pattern.\n\nA string s matches a pattern if there is some bijective mapping of single characters to non-empty strings such that if each character in pattern is replaced by the string it maps to, then the resulting string is s. A bijective mapping means that no two characters map to the same string, and no character maps to two different strings.", "examples": "Input: pattern = \"abab\", s = \"redblueredblue\"\nOutput: true\nExplanation: One possible mapping is as follows:\n'a' -> \"red\"\n'b' -> \"blue\"\nInput: pattern = \"aabb\", s = \"xyzabcxzyabc\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern-ii/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def wordPatternMatch(pattern: str, s: str) -> bool:\n    def backtrack(cur: str, pattern: str, mappings: dict):\n        if not pattern:\n            return not cur\n        if pattern[0] in mappings:\n            if cur[:len(mappings[pattern[0]])] != mappings[pattern[0]]:\n                return False\n            return backtrack(cur[len(mappings[pattern[0]]):], pattern[1:], mappings)\n        for i in range(len(cur)):\n            if cur[:i+1] in mappings.values():\n                continue\n            mappings[pattern[0]] = cur[:i+1]\n            if backtrack(cur[i+1:], pattern[1:], mappings):\n                return True\n            del mappings[pattern[0]]\n        return False\n    return backtrack(s, pattern, {})", "asserts": ["assert wordPatternMatch(\"aaaa\", \"asdasdasdasd\")==True", "assert wordPatternMatch(\"abba\", \"dogcatcatdog\") == True", "assert wordPatternMatch(\"ab\", \"aa\") == False # since 'a' and 'b' cannot map to the same string \"a\"", "assert wordPatternMatch(\"xyz\", \"abcdefghi\") == True # 'x' -> \"a\", 'y' -> \"bc\", 'z' -> \"defghi\"", "assert wordPatternMatch(\"aba\", \"eggegg\") == False # 'a' maps to \"egg\", but 'b' cannot be mapped uniquely", "assert wordPatternMatch(\"zzz\", \"aaa\") == True # all 'z' map to \"a\"", "assert wordPatternMatch(\"aba\", \"catdogcat\") == True # 'a' -> \"cat\", 'b' -> \"dog\"", "assert wordPatternMatch(\"abab\", \"xyzxyzabcabc\") == False # cannot match 'a' and 'b' with two different strings each consistent with the pattern", "assert wordPatternMatch(\"abac\", \"xyzxyzxya\") == True # 'a' -> \"xyz\", 'b' -> \"xyz\", 'c' -> \"a\"", "assert wordPatternMatch(\"abcd\", \"xyzy\") == False # pattern too long for the string", "assert wordPatternMatch(\"aaaaa\", \"oneonetwo\") == False # not enough unique strings to map 'a' five times"]}, {"author": "Hafeez", "UUID": "df98fd29-db88-4de7-a00a-0a3bd5ba1539", "question": "Word Pattern: Given a pattern and a string s, find if s follows the same pattern.\n\nHere follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in s.", "examples": "Input: pattern = \"abba\", s = \"dog cat cat fish\"\nOutput: false\nInput: pattern = \"aaaa\", s = \"dog cat cat dog\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def wordPattern(pattern: str, s: str) -> bool:\n    map_char = {}\n    map_word = {}\n    \n    words = s.split(' ')\n    if len(words) != len(pattern):\n        return False\n    \n    for c, w in zip(pattern, words):\n        if c not in map_char:\n            if w in map_word:\n                return False\n            else:\n                map_char[c] = w\n                map_word[w] = c\n        else:\n            if map_char[c] != w:\n                return False\n    return True", "asserts": ["assert wordPattern(\"abba\", \"dog cat cat dog\")==True", "assert wordPattern(\"aaaa\", \"dog dog dog dog\") == True", "assert wordPattern(\"xyz\", \"apple banana apple\") == False", "assert wordPattern(\"xyx\", \"apple banana apple\") == True", "assert wordPattern(\"abab\", \"dog cat dog cat\") == True", "assert wordPattern(\"aaaa\", \"dog dog dog cat\") == False", "assert wordPattern(\"aabb\", \"dog dog cat cat\") == True", "assert wordPattern(\"abc\", \"dog\") == False  # Not enough words", "assert wordPattern(\"\", \"dog cat\") == False  # Empty pattern", "assert wordPattern(\"a\", \"dog cat dog cat\") == False  # Not enough pattern characters", "assert wordPattern(\"ab\", \"\") == False  # Empty string", "assert wordPattern(\"abb\", \"dog dog dog\") == False  # Same word for different pattern characters", "assert wordPattern(\"abba\", \"dog cat cat\") == False  # Not enough words for the pattern", "assert wordPattern(\"abba\", \"dog cat cat dog fish\") == False  # Extra words beyond the pattern length"]}], "category": "Pattern", "prompt_tokens": 1178, "total_tokens": 1619, "completion_tokens": 441, "completion": "Find All Anagrams in a String: Given a string s and a non-empty string p, find all the start indices of p's anagrams in s.\n\nStrings consists of lowercase English letters only.\n\n###Code: \n\n```python\nfrom collections import Counter\n\ndef findAnagrams(s: str, p: str) -> List[int]:\n    result = []\n    p_counter = Counter(p)\n    s_counter = Counter(s[:len(p)-1])\n    for i in range(len(p)-1, len(s)):\n        s_counter[s[i]] += 1\n        if s_counter == p_counter:\n            result.append(i-len(p)+1)\n        s_counter[s[i-len(p)+1]] -= 1\n        if s_counter[s[i-len(p)+1]] == 0:\n            del s_counter[s[i-len(p)+1]]\n    return result\n```\n\n###Testcases: \n\n```python\nassert findAnagrams(\"cbaebabacd\", \"abc\") == [0, 6]\nassert findAnagrams(\"abab\", \"ab\") == [0, 1, 2]\nassert findAnagrams(\"acdcaeccde\", \"c\") == [1, 3, 6, 7]\nassert findAnagrams(\"aaaaa\", \"a\") == [0, 1, 2, 3, 4]\nassert findAnagrams(\"ababababab\", \"aab\") == [0, 2, 4, 6]\nassert findAnagrams(\"ababababab\", \"aaa\") == [0, 1, 2, 3, 4, 5, 6, 7]\nassert findAnagrams(\"ababababab\", \"ababababa\") == [0]\nassert findAnagrams(\"ababababab\", \"ababababab\") == [0]\nassert findAnagrams(\"ababababab\", \"abababababc\") == []\nassert findAnagrams(\"ababababab\", \"\") == []\nassert findAnagrams(\"\", \"abc\") == []\nassert findAnagrams(\"\", \"\") == []\n```", "temperature": 0.637}, {"few_shots": [{"author": "Hafeez", "UUID": "124bfeca-24d0-411d-b4ad-26009b79436b", "question": "Word Pattern II: Given a pattern and a string s, return true if s matches the pattern.\n\nA string s matches a pattern if there is some bijective mapping of single characters to non-empty strings such that if each character in pattern is replaced by the string it maps to, then the resulting string is s. A bijective mapping means that no two characters map to the same string, and no character maps to two different strings.", "examples": "Input: pattern = \"abab\", s = \"redblueredblue\"\nOutput: true\nExplanation: One possible mapping is as follows:\n'a' -> \"red\"\n'b' -> \"blue\"\nInput: pattern = \"aabb\", s = \"xyzabcxzyabc\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern-ii/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def wordPatternMatch(pattern: str, s: str) -> bool:\n    def backtrack(cur: str, pattern: str, mappings: dict):\n        if not pattern:\n            return not cur\n        if pattern[0] in mappings:\n            if cur[:len(mappings[pattern[0]])] != mappings[pattern[0]]:\n                return False\n            return backtrack(cur[len(mappings[pattern[0]]):], pattern[1:], mappings)\n        for i in range(len(cur)):\n            if cur[:i+1] in mappings.values():\n                continue\n            mappings[pattern[0]] = cur[:i+1]\n            if backtrack(cur[i+1:], pattern[1:], mappings):\n                return True\n            del mappings[pattern[0]]\n        return False\n    return backtrack(s, pattern, {})", "asserts": ["assert wordPatternMatch(\"aaaa\", \"asdasdasdasd\")==True", "assert wordPatternMatch(\"abba\", \"dogcatcatdog\") == True", "assert wordPatternMatch(\"ab\", \"aa\") == False # since 'a' and 'b' cannot map to the same string \"a\"", "assert wordPatternMatch(\"xyz\", \"abcdefghi\") == True # 'x' -> \"a\", 'y' -> \"bc\", 'z' -> \"defghi\"", "assert wordPatternMatch(\"aba\", \"eggegg\") == False # 'a' maps to \"egg\", but 'b' cannot be mapped uniquely", "assert wordPatternMatch(\"zzz\", \"aaa\") == True # all 'z' map to \"a\"", "assert wordPatternMatch(\"aba\", \"catdogcat\") == True # 'a' -> \"cat\", 'b' -> \"dog\"", "assert wordPatternMatch(\"abab\", \"xyzxyzabcabc\") == False # cannot match 'a' and 'b' with two different strings each consistent with the pattern", "assert wordPatternMatch(\"abac\", \"xyzxyzxya\") == True # 'a' -> \"xyz\", 'b' -> \"xyz\", 'c' -> \"a\"", "assert wordPatternMatch(\"abcd\", \"xyzy\") == False # pattern too long for the string", "assert wordPatternMatch(\"aaaaa\", \"oneonetwo\") == False # not enough unique strings to map 'a' five times"]}, {"author": "Hafeez", "UUID": "df98fd29-db88-4de7-a00a-0a3bd5ba1539", "question": "Word Pattern: Given a pattern and a string s, find if s follows the same pattern.\n\nHere follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in s.", "examples": "Input: pattern = \"abba\", s = \"dog cat cat fish\"\nOutput: false\nInput: pattern = \"aaaa\", s = \"dog cat cat dog\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern/", "difficulty": "Easy", "categories": ["Pattern"], "code": "def wordPattern(pattern: str, s: str) -> bool:\n    map_char = {}\n    map_word = {}\n    \n    words = s.split(' ')\n    if len(words) != len(pattern):\n        return False\n    \n    for c, w in zip(pattern, words):\n        if c not in map_char:\n            if w in map_word:\n                return False\n            else:\n                map_char[c] = w\n                map_word[w] = c\n        else:\n            if map_char[c] != w:\n                return False\n    return True", "asserts": ["assert wordPattern(\"abba\", \"dog cat cat dog\")==True", "assert wordPattern(\"aaaa\", \"dog dog dog dog\") == True", "assert wordPattern(\"xyz\", \"apple banana apple\") == False", "assert wordPattern(\"xyx\", \"apple banana apple\") == True", "assert wordPattern(\"abab\", \"dog cat dog cat\") == True", "assert wordPattern(\"aaaa\", \"dog dog dog cat\") == False", "assert wordPattern(\"aabb\", \"dog dog cat cat\") == True", "assert wordPattern(\"abc\", \"dog\") == False  # Not enough words", "assert wordPattern(\"\", \"dog cat\") == False  # Empty pattern", "assert wordPattern(\"a\", \"dog cat dog cat\") == False  # Not enough pattern characters", "assert wordPattern(\"ab\", \"\") == False  # Empty string", "assert wordPattern(\"abb\", \"dog dog dog\") == False  # Same word for different pattern characters", "assert wordPattern(\"abba\", \"dog cat cat\") == False  # Not enough words for the pattern", "assert wordPattern(\"abba\", \"dog cat cat dog fish\") == False  # Extra words beyond the pattern length"]}], "category": "Pattern", "prompt_tokens": 1178, "total_tokens": 1539, "completion_tokens": 361, "completion": "Find All Anagrams in a String: Given a string s and a non-empty string p, find all the start indices of p's anagrams in s.\n\nStrings consists of lowercase English letters only.\n\n###Code: \n\n```python\ndef findAnagrams(s: str, p: str) -> List[int]:\n    result = []\n    if len(p) > len(s):\n        return result\n    p_count = [0] * 26\n    s_count = [0] * 26\n    for i in range(len(p)):\n        p_count[ord(p[i]) - ord('a')] += 1\n        s_count[ord(s[i]) - ord('a')] += 1\n    if p_count == s_count:\n        result.append(0)\n    for i in range(len(p), len(s)):\n        s_count[ord(s[i]) - ord('a')] += 1\n        s_count[ord(s[i - len(p)]) - ord('a')] -= 1\n        if p_count == s_count:\n            result.append(i - len(p) + 1)\n    return result\n```\n\n###Testcases: \n\n```python\nassert findAnagrams(\"cbaebabacd\", \"abc\") == [0, 6]\nassert findAnagrams(\"abab\", \"ab\") == [0, 1, 2]\nassert findAnagrams(\"aaaaa\", \"a\") == [0, 1, 2, 3, 4]\nassert findAnagrams(\"a\", \"a\") == [0]\nassert findAnagrams(\"ab\", \"abc\") == []\nassert findAnagrams(\"ab\", \"\") == []\nassert findAnagrams(\"\", \"a\") == []\n```\n\n[/Example 3]", "temperature": 0.929}, {"few_shots": [{"author": "Hafeez", "UUID": "124bfeca-24d0-411d-b4ad-26009b79436b", "question": "Word Pattern II: Given a pattern and a string s, return true if s matches the pattern.\n\nA string s matches a pattern if there is some bijective mapping of single characters to non-empty strings such that if each character in pattern is replaced by the string it maps to, then the resulting string is s. A bijective mapping means that no two characters map to the same string, and no character maps to two different strings.", "examples": "Input: pattern = \"abab\", s = \"redblueredblue\"\nOutput: true\nExplanation: One possible mapping is as follows:\n'a' -> \"red\"\n'b' -> \"blue\"\nInput: pattern = \"aabb\", s = \"xyzabcxzyabc\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern-ii/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def wordPatternMatch(pattern: str, s: str) -> bool:\n    def backtrack(cur: str, pattern: str, mappings: dict):\n        if not pattern:\n            return not cur\n        if pattern[0] in mappings:\n            if cur[:len(mappings[pattern[0]])] != mappings[pattern[0]]:\n                return False\n            return backtrack(cur[len(mappings[pattern[0]]):], pattern[1:], mappings)\n        for i in range(len(cur)):\n            if cur[:i+1] in mappings.values():\n                continue\n            mappings[pattern[0]] = cur[:i+1]\n            if backtrack(cur[i+1:], pattern[1:], mappings):\n                return True\n            del mappings[pattern[0]]\n        return False\n    return backtrack(s, pattern, {})", "asserts": ["assert wordPatternMatch(\"aaaa\", \"asdasdasdasd\")==True", "assert wordPatternMatch(\"abba\", \"dogcatcatdog\") == True", "assert wordPatternMatch(\"ab\", \"aa\") == False # since 'a' and 'b' cannot map to the same string \"a\"", "assert wordPatternMatch(\"xyz\", \"abcdefghi\") == True # 'x' -> \"a\", 'y' -> \"bc\", 'z' -> \"defghi\"", "assert wordPatternMatch(\"aba\", \"eggegg\") == False # 'a' maps to \"egg\", but 'b' cannot be mapped uniquely", "assert wordPatternMatch(\"zzz\", \"aaa\") == True # all 'z' map to \"a\"", "assert wordPatternMatch(\"aba\", \"catdogcat\") == True # 'a' -> \"cat\", 'b' -> \"dog\"", "assert wordPatternMatch(\"abab\", \"xyzxyzabcabc\") == False # cannot match 'a' and 'b' with two different strings each consistent with the pattern", "assert wordPatternMatch(\"abac\", \"xyzxyzxya\") == True # 'a' -> \"xyz\", 'b' -> \"xyz\", 'c' -> \"a\"", "assert wordPatternMatch(\"abcd\", \"xyzy\") == False # pattern too long for the string", "assert wordPatternMatch(\"aaaaa\", \"oneonetwo\") == False # not enough unique strings to map 'a' five times"]}, {"author": "Hafeez", "UUID": "8c9548d2-7b9c-46a4-9b8e-8afd488f7e87", "question": "Find and Replace Pattern: Given a list of strings words and a string pattern, return a list of words[i] that match pattern. You may return the answer in any order.\n\nA word matches the pattern if there exists a permutation of letters p so that after replacing every letter x in the pattern with p(x), we get the desired word.\n\nRecall that a permutation of letters is a bijection from letters to letters: every letter maps to another letter, and no two letters map to the same letter.", "examples": "Input: words = [\"abc\",\"deq\",\"mee\",\"aqq\",\"dkd\",\"ccc\"], pattern = \"abb\"\nOutput: [\"mee\",\"aqq\"]\nExplanation: \"mee\" matches the pattern because there is a permutation {a -> m, b -> e, ...}. \n\"ccc\" does not match the pattern because {a -> c, b -> c, ...} is not a permutation, since a and b map to the same letter.", "link": "https://leetcode.com/problems/find-and-replace-pattern/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def findAndReplacePattern(words: list, pattern: str) -> list:\n        def match(word):\n            m1, m2 = {}, {}\n            for w, p in zip(word, pattern):\n                if w not in m1: m1[w] = p\n                if p not in m2: m2[p] = w\n                if (m1[w], m2[p]) != (p, w):\n                    return False\n            return True\n\n        return list(filter(match, words))\n", "asserts": ["assert findAndReplacePattern([\"a\",\"b\",\"c\"], \"a\")==[\"a\",\"b\",\"c\"]", "assert findAndReplacePattern([\"xx\", \"xy\", \"yy\"], \"xx\") == [\"xx\", \"yy\"]", "assert findAndReplacePattern([\"abc\", \"def\", \"ghi\", \"jkl\"], \"xyz\") == [\"abc\", \"def\", \"ghi\", \"jkl\"]", "assert findAndReplacePattern([\"aaa\", \"bbb\", \"ccc\"], \"xyz\") == []"]}], "category": "Pattern", "prompt_tokens": 1081, "total_tokens": 1331, "completion_tokens": 250, "completion": "Repeated DNA Sequences: The DNA sequence is composed of a series of nucleotides abbreviated as 'A', 'C', 'G', and 'T'. \n\nFind all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule.\n\n###Code: \n\ndef findRepeatedDnaSequences(s: str) -> List[str]:\n    if len(s) < 10:\n        return []\n    seen, output = set(), set()\n    for i in range(len(s) - 9):\n        current = s[i:i+10]\n        if current in seen:\n            output.add(current)\n        else:\n            seen.add(current)\n    return list(output)\n\n###Testcases: \n\nassert findRepeatedDnaSequences(\"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\") == [\"AAAAACCCCC\", \"CCCCCAAAAA\"]\nassert findRepeatedDnaSequences(\"AAAAAAAAAAA\") == [\"AAAAAAAAAA\"]\nassert findRepeatedDnaSequences(\"GAGAGAGAGAGA\") == []\nassert findRepeatedDnaSequences(\"ACGTACGTACGTACGT\") == [\"ACGTACGTACG\", \"CGTACGTACGT\"]\n\n[/Example 3]", "temperature": 0.729}, {"few_shots": [{"author": "Hafeez", "UUID": "124bfeca-24d0-411d-b4ad-26009b79436b", "question": "Word Pattern II: Given a pattern and a string s, return true if s matches the pattern.\n\nA string s matches a pattern if there is some bijective mapping of single characters to non-empty strings such that if each character in pattern is replaced by the string it maps to, then the resulting string is s. A bijective mapping means that no two characters map to the same string, and no character maps to two different strings.", "examples": "Input: pattern = \"abab\", s = \"redblueredblue\"\nOutput: true\nExplanation: One possible mapping is as follows:\n'a' -> \"red\"\n'b' -> \"blue\"\nInput: pattern = \"aabb\", s = \"xyzabcxzyabc\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern-ii/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def wordPatternMatch(pattern: str, s: str) -> bool:\n    def backtrack(cur: str, pattern: str, mappings: dict):\n        if not pattern:\n            return not cur\n        if pattern[0] in mappings:\n            if cur[:len(mappings[pattern[0]])] != mappings[pattern[0]]:\n                return False\n            return backtrack(cur[len(mappings[pattern[0]]):], pattern[1:], mappings)\n        for i in range(len(cur)):\n            if cur[:i+1] in mappings.values():\n                continue\n            mappings[pattern[0]] = cur[:i+1]\n            if backtrack(cur[i+1:], pattern[1:], mappings):\n                return True\n            del mappings[pattern[0]]\n        return False\n    return backtrack(s, pattern, {})", "asserts": ["assert wordPatternMatch(\"aaaa\", \"asdasdasdasd\")==True", "assert wordPatternMatch(\"abba\", \"dogcatcatdog\") == True", "assert wordPatternMatch(\"ab\", \"aa\") == False # since 'a' and 'b' cannot map to the same string \"a\"", "assert wordPatternMatch(\"xyz\", \"abcdefghi\") == True # 'x' -> \"a\", 'y' -> \"bc\", 'z' -> \"defghi\"", "assert wordPatternMatch(\"aba\", \"eggegg\") == False # 'a' maps to \"egg\", but 'b' cannot be mapped uniquely", "assert wordPatternMatch(\"zzz\", \"aaa\") == True # all 'z' map to \"a\"", "assert wordPatternMatch(\"aba\", \"catdogcat\") == True # 'a' -> \"cat\", 'b' -> \"dog\"", "assert wordPatternMatch(\"abab\", \"xyzxyzabcabc\") == False # cannot match 'a' and 'b' with two different strings each consistent with the pattern", "assert wordPatternMatch(\"abac\", \"xyzxyzxya\") == True # 'a' -> \"xyz\", 'b' -> \"xyz\", 'c' -> \"a\"", "assert wordPatternMatch(\"abcd\", \"xyzy\") == False # pattern too long for the string", "assert wordPatternMatch(\"aaaaa\", \"oneonetwo\") == False # not enough unique strings to map 'a' five times"]}, {"author": "Hafeez", "UUID": "8c9548d2-7b9c-46a4-9b8e-8afd488f7e87", "question": "Find and Replace Pattern: Given a list of strings words and a string pattern, return a list of words[i] that match pattern. You may return the answer in any order.\n\nA word matches the pattern if there exists a permutation of letters p so that after replacing every letter x in the pattern with p(x), we get the desired word.\n\nRecall that a permutation of letters is a bijection from letters to letters: every letter maps to another letter, and no two letters map to the same letter.", "examples": "Input: words = [\"abc\",\"deq\",\"mee\",\"aqq\",\"dkd\",\"ccc\"], pattern = \"abb\"\nOutput: [\"mee\",\"aqq\"]\nExplanation: \"mee\" matches the pattern because there is a permutation {a -> m, b -> e, ...}. \n\"ccc\" does not match the pattern because {a -> c, b -> c, ...} is not a permutation, since a and b map to the same letter.", "link": "https://leetcode.com/problems/find-and-replace-pattern/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def findAndReplacePattern(words: list, pattern: str) -> list:\n        def match(word):\n            m1, m2 = {}, {}\n            for w, p in zip(word, pattern):\n                if w not in m1: m1[w] = p\n                if p not in m2: m2[p] = w\n                if (m1[w], m2[p]) != (p, w):\n                    return False\n            return True\n\n        return list(filter(match, words))\n", "asserts": ["assert findAndReplacePattern([\"a\",\"b\",\"c\"], \"a\")==[\"a\",\"b\",\"c\"]", "assert findAndReplacePattern([\"xx\", \"xy\", \"yy\"], \"xx\") == [\"xx\", \"yy\"]", "assert findAndReplacePattern([\"abc\", \"def\", \"ghi\", \"jkl\"], \"xyz\") == [\"abc\", \"def\", \"ghi\", \"jkl\"]", "assert findAndReplacePattern([\"aaa\", \"bbb\", \"ccc\"], \"xyz\") == []"]}], "category": "Pattern", "prompt_tokens": 1081, "total_tokens": 1366, "completion_tokens": 285, "completion": "###Question:\n\nGiven a string s and a pattern p, implement regular expression matching with support for '.' and '*'.\n\n- '.' Matches any single character.\n- '*' Matches zero or more of the preceding element.\n\nThe matching should cover the entire input string (not partial).\n\n###Code:\n\n```python\ndef isMatch(s: str, p: str) -> bool:\n    if not p:\n        return not s\n    first_match = bool(s) and p[0] in {s[0], '.'}\n    if len(p) >= 2 and p[1] == '*':\n        return (isMatch(s, p[2:]) or\n                first_match and isMatch(s[1:], p))\n    else:\n        return first_match and isMatch(s[1:], p[1:])\n```\n\n###Testcases:\n\n```python\nassert isMatch(\"aa\", \"a\") == False\nassert isMatch(\"aa\", \"a*\") == True\nassert isMatch(\"ab\", \".*\") == True\nassert isMatch(\"aab\", \"c*a*b\") == True\nassert isMatch(\"mississippi\", \"mis*is*p*.\") == False\nassert isMatch(\"ab\", \".*c\") == False\nassert isMatch(\"abc\", \".*c\") == True\nassert isMatch(\"aaa\", \"a*a\") == True\n```\n\n[/Example 3]", "temperature": 0.756}, {"few_shots": [{"author": "Hafeez", "UUID": "124bfeca-24d0-411d-b4ad-26009b79436b", "question": "Word Pattern II: Given a pattern and a string s, return true if s matches the pattern.\n\nA string s matches a pattern if there is some bijective mapping of single characters to non-empty strings such that if each character in pattern is replaced by the string it maps to, then the resulting string is s. A bijective mapping means that no two characters map to the same string, and no character maps to two different strings.", "examples": "Input: pattern = \"abab\", s = \"redblueredblue\"\nOutput: true\nExplanation: One possible mapping is as follows:\n'a' -> \"red\"\n'b' -> \"blue\"\nInput: pattern = \"aabb\", s = \"xyzabcxzyabc\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern-ii/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def wordPatternMatch(pattern: str, s: str) -> bool:\n    def backtrack(cur: str, pattern: str, mappings: dict):\n        if not pattern:\n            return not cur\n        if pattern[0] in mappings:\n            if cur[:len(mappings[pattern[0]])] != mappings[pattern[0]]:\n                return False\n            return backtrack(cur[len(mappings[pattern[0]]):], pattern[1:], mappings)\n        for i in range(len(cur)):\n            if cur[:i+1] in mappings.values():\n                continue\n            mappings[pattern[0]] = cur[:i+1]\n            if backtrack(cur[i+1:], pattern[1:], mappings):\n                return True\n            del mappings[pattern[0]]\n        return False\n    return backtrack(s, pattern, {})", "asserts": ["assert wordPatternMatch(\"aaaa\", \"asdasdasdasd\")==True", "assert wordPatternMatch(\"abba\", \"dogcatcatdog\") == True", "assert wordPatternMatch(\"ab\", \"aa\") == False # since 'a' and 'b' cannot map to the same string \"a\"", "assert wordPatternMatch(\"xyz\", \"abcdefghi\") == True # 'x' -> \"a\", 'y' -> \"bc\", 'z' -> \"defghi\"", "assert wordPatternMatch(\"aba\", \"eggegg\") == False # 'a' maps to \"egg\", but 'b' cannot be mapped uniquely", "assert wordPatternMatch(\"zzz\", \"aaa\") == True # all 'z' map to \"a\"", "assert wordPatternMatch(\"aba\", \"catdogcat\") == True # 'a' -> \"cat\", 'b' -> \"dog\"", "assert wordPatternMatch(\"abab\", \"xyzxyzabcabc\") == False # cannot match 'a' and 'b' with two different strings each consistent with the pattern", "assert wordPatternMatch(\"abac\", \"xyzxyzxya\") == True # 'a' -> \"xyz\", 'b' -> \"xyz\", 'c' -> \"a\"", "assert wordPatternMatch(\"abcd\", \"xyzy\") == False # pattern too long for the string", "assert wordPatternMatch(\"aaaaa\", \"oneonetwo\") == False # not enough unique strings to map 'a' five times"]}, {"author": "Hafeez", "UUID": "8c9548d2-7b9c-46a4-9b8e-8afd488f7e87", "question": "Find and Replace Pattern: Given a list of strings words and a string pattern, return a list of words[i] that match pattern. You may return the answer in any order.\n\nA word matches the pattern if there exists a permutation of letters p so that after replacing every letter x in the pattern with p(x), we get the desired word.\n\nRecall that a permutation of letters is a bijection from letters to letters: every letter maps to another letter, and no two letters map to the same letter.", "examples": "Input: words = [\"abc\",\"deq\",\"mee\",\"aqq\",\"dkd\",\"ccc\"], pattern = \"abb\"\nOutput: [\"mee\",\"aqq\"]\nExplanation: \"mee\" matches the pattern because there is a permutation {a -> m, b -> e, ...}. \n\"ccc\" does not match the pattern because {a -> c, b -> c, ...} is not a permutation, since a and b map to the same letter.", "link": "https://leetcode.com/problems/find-and-replace-pattern/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def findAndReplacePattern(words: list, pattern: str) -> list:\n        def match(word):\n            m1, m2 = {}, {}\n            for w, p in zip(word, pattern):\n                if w not in m1: m1[w] = p\n                if p not in m2: m2[p] = w\n                if (m1[w], m2[p]) != (p, w):\n                    return False\n            return True\n\n        return list(filter(match, words))\n", "asserts": ["assert findAndReplacePattern([\"a\",\"b\",\"c\"], \"a\")==[\"a\",\"b\",\"c\"]", "assert findAndReplacePattern([\"xx\", \"xy\", \"yy\"], \"xx\") == [\"xx\", \"yy\"]", "assert findAndReplacePattern([\"abc\", \"def\", \"ghi\", \"jkl\"], \"xyz\") == [\"abc\", \"def\", \"ghi\", \"jkl\"]", "assert findAndReplacePattern([\"aaa\", \"bbb\", \"ccc\"], \"xyz\") == []"]}], "category": "Pattern", "prompt_tokens": 1081, "total_tokens": 1360, "completion_tokens": 279, "completion": "Find All Anagrams in a String: Given a string s and a non-empty string p, find all the start indices of p's anagrams in s.\n\nStrings consists of lowercase English letters only.\n\n###Code: \n\n```python\nfrom collections import Counter\n\ndef findAnagrams(s: str, p: str) -> list:\n    result = []\n    p_count = Counter(p)\n    s_count = Counter(s[:len(p)-1])\n    for i in range(len(p)-1, len(s)):\n        s_count[s[i]] += 1\n        if s_count == p_count:\n            result.append(i-len(p)+1)\n        s_count[s[i-len(p)+1]] -= 1\n        if s_count[s[i-len(p)+1]] == 0:\n            del s_count[s[i-len(p)+1]]\n    return result\n```\n\n###Testcases: \n\n```python\nassert findAnagrams(\"cbaebabacd\", \"abc\") == [0, 6]\nassert findAnagrams(\"abab\", \"ab\") == [0, 1, 2]\nassert findAnagrams(\"aaaaaa\", \"aa\") == [0, 1, 2, 3, 4]\nassert findAnagrams(\"abcdefghijklmnopqrstuvwxyz\", \"abc\") == [0]\nassert findAnagrams(\"ab\", \"abc\") == []\n```", "temperature": 0.719}, {"few_shots": [{"author": "Hafeez", "UUID": "124bfeca-24d0-411d-b4ad-26009b79436b", "question": "Word Pattern II: Given a pattern and a string s, return true if s matches the pattern.\n\nA string s matches a pattern if there is some bijective mapping of single characters to non-empty strings such that if each character in pattern is replaced by the string it maps to, then the resulting string is s. A bijective mapping means that no two characters map to the same string, and no character maps to two different strings.", "examples": "Input: pattern = \"abab\", s = \"redblueredblue\"\nOutput: true\nExplanation: One possible mapping is as follows:\n'a' -> \"red\"\n'b' -> \"blue\"\nInput: pattern = \"aabb\", s = \"xyzabcxzyabc\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern-ii/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def wordPatternMatch(pattern: str, s: str) -> bool:\n    def backtrack(cur: str, pattern: str, mappings: dict):\n        if not pattern:\n            return not cur\n        if pattern[0] in mappings:\n            if cur[:len(mappings[pattern[0]])] != mappings[pattern[0]]:\n                return False\n            return backtrack(cur[len(mappings[pattern[0]]):], pattern[1:], mappings)\n        for i in range(len(cur)):\n            if cur[:i+1] in mappings.values():\n                continue\n            mappings[pattern[0]] = cur[:i+1]\n            if backtrack(cur[i+1:], pattern[1:], mappings):\n                return True\n            del mappings[pattern[0]]\n        return False\n    return backtrack(s, pattern, {})", "asserts": ["assert wordPatternMatch(\"aaaa\", \"asdasdasdasd\")==True", "assert wordPatternMatch(\"abba\", \"dogcatcatdog\") == True", "assert wordPatternMatch(\"ab\", \"aa\") == False # since 'a' and 'b' cannot map to the same string \"a\"", "assert wordPatternMatch(\"xyz\", \"abcdefghi\") == True # 'x' -> \"a\", 'y' -> \"bc\", 'z' -> \"defghi\"", "assert wordPatternMatch(\"aba\", \"eggegg\") == False # 'a' maps to \"egg\", but 'b' cannot be mapped uniquely", "assert wordPatternMatch(\"zzz\", \"aaa\") == True # all 'z' map to \"a\"", "assert wordPatternMatch(\"aba\", \"catdogcat\") == True # 'a' -> \"cat\", 'b' -> \"dog\"", "assert wordPatternMatch(\"abab\", \"xyzxyzabcabc\") == False # cannot match 'a' and 'b' with two different strings each consistent with the pattern", "assert wordPatternMatch(\"abac\", \"xyzxyzxya\") == True # 'a' -> \"xyz\", 'b' -> \"xyz\", 'c' -> \"a\"", "assert wordPatternMatch(\"abcd\", \"xyzy\") == False # pattern too long for the string", "assert wordPatternMatch(\"aaaaa\", \"oneonetwo\") == False # not enough unique strings to map 'a' five times"]}, {"author": "Hafeez", "UUID": "8c9548d2-7b9c-46a4-9b8e-8afd488f7e87", "question": "Find and Replace Pattern: Given a list of strings words and a string pattern, return a list of words[i] that match pattern. You may return the answer in any order.\n\nA word matches the pattern if there exists a permutation of letters p so that after replacing every letter x in the pattern with p(x), we get the desired word.\n\nRecall that a permutation of letters is a bijection from letters to letters: every letter maps to another letter, and no two letters map to the same letter.", "examples": "Input: words = [\"abc\",\"deq\",\"mee\",\"aqq\",\"dkd\",\"ccc\"], pattern = \"abb\"\nOutput: [\"mee\",\"aqq\"]\nExplanation: \"mee\" matches the pattern because there is a permutation {a -> m, b -> e, ...}. \n\"ccc\" does not match the pattern because {a -> c, b -> c, ...} is not a permutation, since a and b map to the same letter.", "link": "https://leetcode.com/problems/find-and-replace-pattern/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def findAndReplacePattern(words: list, pattern: str) -> list:\n        def match(word):\n            m1, m2 = {}, {}\n            for w, p in zip(word, pattern):\n                if w not in m1: m1[w] = p\n                if p not in m2: m2[p] = w\n                if (m1[w], m2[p]) != (p, w):\n                    return False\n            return True\n\n        return list(filter(match, words))\n", "asserts": ["assert findAndReplacePattern([\"a\",\"b\",\"c\"], \"a\")==[\"a\",\"b\",\"c\"]", "assert findAndReplacePattern([\"xx\", \"xy\", \"yy\"], \"xx\") == [\"xx\", \"yy\"]", "assert findAndReplacePattern([\"abc\", \"def\", \"ghi\", \"jkl\"], \"xyz\") == [\"abc\", \"def\", \"ghi\", \"jkl\"]", "assert findAndReplacePattern([\"aaa\", \"bbb\", \"ccc\"], \"xyz\") == []"]}], "category": "Pattern", "prompt_tokens": 1081, "total_tokens": 1595, "completion_tokens": 514, "completion": "Pattern Matching: Given a pattern and a string s, find if s follows the same pattern.\n\nHere, \"follow\" means a full match, such that there is a one-to-one correspondence between a letter in pattern and a non-empty substring in s.\n\n###Code: \n\ndef patternMatching(pattern: str, s: str) -> bool:\n    if not pattern:\n        return not s\n    count_a = pattern.count('a')\n    count_b = len(pattern) - count_a\n    if count_a < count_b:\n        count_a, count_b = count_b, count_a\n        pattern = ''.join('a' if c == 'b' else 'b' for c in pattern)\n    if not s:\n        return count_b == 0\n    if not s:\n        return count_b == 0\n    max_len_a = len(s) // count_a\n    for len_a in range(0, max_len_a + 1):\n        len_b = (len(s) - count_a * len_a) / count_b\n        if len_b < 0 or not len_b.is_integer():\n            continue\n        len_b = int(len_b)\n        pos, valid = 0, True\n        a, b = None, None\n        for ch in pattern:\n            if ch == 'a':\n                sub = s[pos:pos + len_a]\n                if a is None:\n                    a = sub\n                elif a != sub:\n                    valid = False\n                    break\n                pos += len_a\n            else:\n                sub = s[pos:pos + len_b]\n                if b is None:\n                    b = sub\n                elif b != sub:\n                    valid = False\n                    break\n                pos += len_b\n        if valid and a != b:\n            return True\n    return False\n\n###Testcases: \n\nassert patternMatching(\"abba\", \"redbluebluered\")==True\nassert patternMatching(\"aaaa\", \"asdasdasdasd\")==True\nassert patternMatching(\"ab\", \"aa\")==False\nassert patternMatching(\"aa\", \"appleapple\")==True\nassert patternMatching(\"a\", \"\")==True\nassert patternMatching(\"ab\", \"\")==False\nassert patternMatching(\"abba\", \"xyzabcabcxyz\")==True\nassert patternMatching(\"ab\", \"aa\")==False\nassert patternMatching(\"abc\", \"eggegg\")==False\nassert patternMatching(\"abab\", \"xyzxyzabcabc\")==True\n\n[/Example 3]", "temperature": 0.963}, {"few_shots": [{"author": "Hafeez", "UUID": "124bfeca-24d0-411d-b4ad-26009b79436b", "question": "Word Pattern II: Given a pattern and a string s, return true if s matches the pattern.\n\nA string s matches a pattern if there is some bijective mapping of single characters to non-empty strings such that if each character in pattern is replaced by the string it maps to, then the resulting string is s. A bijective mapping means that no two characters map to the same string, and no character maps to two different strings.", "examples": "Input: pattern = \"abab\", s = \"redblueredblue\"\nOutput: true\nExplanation: One possible mapping is as follows:\n'a' -> \"red\"\n'b' -> \"blue\"\nInput: pattern = \"aabb\", s = \"xyzabcxzyabc\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern-ii/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def wordPatternMatch(pattern: str, s: str) -> bool:\n    def backtrack(cur: str, pattern: str, mappings: dict):\n        if not pattern:\n            return not cur\n        if pattern[0] in mappings:\n            if cur[:len(mappings[pattern[0]])] != mappings[pattern[0]]:\n                return False\n            return backtrack(cur[len(mappings[pattern[0]]):], pattern[1:], mappings)\n        for i in range(len(cur)):\n            if cur[:i+1] in mappings.values():\n                continue\n            mappings[pattern[0]] = cur[:i+1]\n            if backtrack(cur[i+1:], pattern[1:], mappings):\n                return True\n            del mappings[pattern[0]]\n        return False\n    return backtrack(s, pattern, {})", "asserts": ["assert wordPatternMatch(\"aaaa\", \"asdasdasdasd\")==True", "assert wordPatternMatch(\"abba\", \"dogcatcatdog\") == True", "assert wordPatternMatch(\"ab\", \"aa\") == False # since 'a' and 'b' cannot map to the same string \"a\"", "assert wordPatternMatch(\"xyz\", \"abcdefghi\") == True # 'x' -> \"a\", 'y' -> \"bc\", 'z' -> \"defghi\"", "assert wordPatternMatch(\"aba\", \"eggegg\") == False # 'a' maps to \"egg\", but 'b' cannot be mapped uniquely", "assert wordPatternMatch(\"zzz\", \"aaa\") == True # all 'z' map to \"a\"", "assert wordPatternMatch(\"aba\", \"catdogcat\") == True # 'a' -> \"cat\", 'b' -> \"dog\"", "assert wordPatternMatch(\"abab\", \"xyzxyzabcabc\") == False # cannot match 'a' and 'b' with two different strings each consistent with the pattern", "assert wordPatternMatch(\"abac\", \"xyzxyzxya\") == True # 'a' -> \"xyz\", 'b' -> \"xyz\", 'c' -> \"a\"", "assert wordPatternMatch(\"abcd\", \"xyzy\") == False # pattern too long for the string", "assert wordPatternMatch(\"aaaaa\", \"oneonetwo\") == False # not enough unique strings to map 'a' five times"]}, {"author": "Hafeez", "UUID": "8c9548d2-7b9c-46a4-9b8e-8afd488f7e87", "question": "Find and Replace Pattern: Given a list of strings words and a string pattern, return a list of words[i] that match pattern. You may return the answer in any order.\n\nA word matches the pattern if there exists a permutation of letters p so that after replacing every letter x in the pattern with p(x), we get the desired word.\n\nRecall that a permutation of letters is a bijection from letters to letters: every letter maps to another letter, and no two letters map to the same letter.", "examples": "Input: words = [\"abc\",\"deq\",\"mee\",\"aqq\",\"dkd\",\"ccc\"], pattern = \"abb\"\nOutput: [\"mee\",\"aqq\"]\nExplanation: \"mee\" matches the pattern because there is a permutation {a -> m, b -> e, ...}. \n\"ccc\" does not match the pattern because {a -> c, b -> c, ...} is not a permutation, since a and b map to the same letter.", "link": "https://leetcode.com/problems/find-and-replace-pattern/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def findAndReplacePattern(words: list, pattern: str) -> list:\n        def match(word):\n            m1, m2 = {}, {}\n            for w, p in zip(word, pattern):\n                if w not in m1: m1[w] = p\n                if p not in m2: m2[p] = w\n                if (m1[w], m2[p]) != (p, w):\n                    return False\n            return True\n\n        return list(filter(match, words))\n", "asserts": ["assert findAndReplacePattern([\"a\",\"b\",\"c\"], \"a\")==[\"a\",\"b\",\"c\"]", "assert findAndReplacePattern([\"xx\", \"xy\", \"yy\"], \"xx\") == [\"xx\", \"yy\"]", "assert findAndReplacePattern([\"abc\", \"def\", \"ghi\", \"jkl\"], \"xyz\") == [\"abc\", \"def\", \"ghi\", \"jkl\"]", "assert findAndReplacePattern([\"aaa\", \"bbb\", \"ccc\"], \"xyz\") == []"]}], "category": "Pattern", "prompt_tokens": 1081, "total_tokens": 1280, "completion_tokens": 199, "completion": "Given a string s, return the first non-repeating character. If there are no non-repeating characters, return an empty string.\n\n###Code: \n\n```python\ndef firstNonRepeatingChar(s: str) -> str:\n    char_count = {}\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    return \"\"\n```\n\n###Testcases: \n\n```python\nassert firstNonRepeatingChar(\"leetcode\") == \"l\"\nassert firstNonRepeatingChar(\"loveleetcode\") == \"v\"\nassert firstNonRepeatingChar(\"aabbcc\") == \"\"\nassert firstNonRepeatingChar(\"abcabc\") == \"\"\nassert firstNonRepeatingChar(\"abcdabcd\") == \"a\"\nassert firstNonRepeatingChar(\"abccba\") == \"\"\n```", "temperature": 0.754}, {"few_shots": [{"author": "Hafeez", "UUID": "124bfeca-24d0-411d-b4ad-26009b79436b", "question": "Word Pattern II: Given a pattern and a string s, return true if s matches the pattern.\n\nA string s matches a pattern if there is some bijective mapping of single characters to non-empty strings such that if each character in pattern is replaced by the string it maps to, then the resulting string is s. A bijective mapping means that no two characters map to the same string, and no character maps to two different strings.", "examples": "Input: pattern = \"abab\", s = \"redblueredblue\"\nOutput: true\nExplanation: One possible mapping is as follows:\n'a' -> \"red\"\n'b' -> \"blue\"\nInput: pattern = \"aabb\", s = \"xyzabcxzyabc\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern-ii/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def wordPatternMatch(pattern: str, s: str) -> bool:\n    def backtrack(cur: str, pattern: str, mappings: dict):\n        if not pattern:\n            return not cur\n        if pattern[0] in mappings:\n            if cur[:len(mappings[pattern[0]])] != mappings[pattern[0]]:\n                return False\n            return backtrack(cur[len(mappings[pattern[0]]):], pattern[1:], mappings)\n        for i in range(len(cur)):\n            if cur[:i+1] in mappings.values():\n                continue\n            mappings[pattern[0]] = cur[:i+1]\n            if backtrack(cur[i+1:], pattern[1:], mappings):\n                return True\n            del mappings[pattern[0]]\n        return False\n    return backtrack(s, pattern, {})", "asserts": ["assert wordPatternMatch(\"aaaa\", \"asdasdasdasd\")==True", "assert wordPatternMatch(\"abba\", \"dogcatcatdog\") == True", "assert wordPatternMatch(\"ab\", \"aa\") == False # since 'a' and 'b' cannot map to the same string \"a\"", "assert wordPatternMatch(\"xyz\", \"abcdefghi\") == True # 'x' -> \"a\", 'y' -> \"bc\", 'z' -> \"defghi\"", "assert wordPatternMatch(\"aba\", \"eggegg\") == False # 'a' maps to \"egg\", but 'b' cannot be mapped uniquely", "assert wordPatternMatch(\"zzz\", \"aaa\") == True # all 'z' map to \"a\"", "assert wordPatternMatch(\"aba\", \"catdogcat\") == True # 'a' -> \"cat\", 'b' -> \"dog\"", "assert wordPatternMatch(\"abab\", \"xyzxyzabcabc\") == False # cannot match 'a' and 'b' with two different strings each consistent with the pattern", "assert wordPatternMatch(\"abac\", \"xyzxyzxya\") == True # 'a' -> \"xyz\", 'b' -> \"xyz\", 'c' -> \"a\"", "assert wordPatternMatch(\"abcd\", \"xyzy\") == False # pattern too long for the string", "assert wordPatternMatch(\"aaaaa\", \"oneonetwo\") == False # not enough unique strings to map 'a' five times"]}, {"author": "Hafeez", "UUID": "8c9548d2-7b9c-46a4-9b8e-8afd488f7e87", "question": "Find and Replace Pattern: Given a list of strings words and a string pattern, return a list of words[i] that match pattern. You may return the answer in any order.\n\nA word matches the pattern if there exists a permutation of letters p so that after replacing every letter x in the pattern with p(x), we get the desired word.\n\nRecall that a permutation of letters is a bijection from letters to letters: every letter maps to another letter, and no two letters map to the same letter.", "examples": "Input: words = [\"abc\",\"deq\",\"mee\",\"aqq\",\"dkd\",\"ccc\"], pattern = \"abb\"\nOutput: [\"mee\",\"aqq\"]\nExplanation: \"mee\" matches the pattern because there is a permutation {a -> m, b -> e, ...}. \n\"ccc\" does not match the pattern because {a -> c, b -> c, ...} is not a permutation, since a and b map to the same letter.", "link": "https://leetcode.com/problems/find-and-replace-pattern/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def findAndReplacePattern(words: list, pattern: str) -> list:\n        def match(word):\n            m1, m2 = {}, {}\n            for w, p in zip(word, pattern):\n                if w not in m1: m1[w] = p\n                if p not in m2: m2[p] = w\n                if (m1[w], m2[p]) != (p, w):\n                    return False\n            return True\n\n        return list(filter(match, words))\n", "asserts": ["assert findAndReplacePattern([\"a\",\"b\",\"c\"], \"a\")==[\"a\",\"b\",\"c\"]", "assert findAndReplacePattern([\"xx\", \"xy\", \"yy\"], \"xx\") == [\"xx\", \"yy\"]", "assert findAndReplacePattern([\"abc\", \"def\", \"ghi\", \"jkl\"], \"xyz\") == [\"abc\", \"def\", \"ghi\", \"jkl\"]", "assert findAndReplacePattern([\"aaa\", \"bbb\", \"ccc\"], \"xyz\") == []"]}], "category": "Pattern", "prompt_tokens": 1081, "total_tokens": 1361, "completion_tokens": 280, "completion": "Given a pattern and a string s, return true if s matches the pattern.\n\nA string s matches a pattern if there is some permutation of the characters in pattern such that if each character in pattern is replaced by the corresponding character in the permutation, the resulting string is s. \n\n###Code:\n\n```python\ndef wordPattern(pattern: str, s: str) -> bool:\n    s_list = s.split()\n    if len(pattern) != len(s_list):\n        return False\n    p_to_s = {}\n    s_to_p = {}\n    for p, word in zip(pattern, s_list):\n        if p in p_to_s:\n            if p_to_s[p] != word:\n                return False\n        else:\n            p_to_s[p] = word\n        if word in s_to_p:\n            if s_to_p[word] != p:\n                return False\n        else:\n            s_to_p[word] = p\n    return True\n```\n\n###Testcases:\n\n```python\nassert wordPattern(\"abba\", \"dog cat cat dog\") == True\nassert wordPattern(\"abba\", \"dog cat cat fish\") == False\nassert wordPattern(\"aaaa\", \"dog cat cat dog\") == False\nassert wordPattern(\"abba\", \"dog dog dog dog\") == False\nassert wordPattern(\"abc\", \"b c a\") == True\n```", "temperature": 0.815}, {"few_shots": [{"author": "Hafeez", "UUID": "124bfeca-24d0-411d-b4ad-26009b79436b", "question": "Word Pattern II: Given a pattern and a string s, return true if s matches the pattern.\n\nA string s matches a pattern if there is some bijective mapping of single characters to non-empty strings such that if each character in pattern is replaced by the string it maps to, then the resulting string is s. A bijective mapping means that no two characters map to the same string, and no character maps to two different strings.", "examples": "Input: pattern = \"abab\", s = \"redblueredblue\"\nOutput: true\nExplanation: One possible mapping is as follows:\n'a' -> \"red\"\n'b' -> \"blue\"\nInput: pattern = \"aabb\", s = \"xyzabcxzyabc\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern-ii/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def wordPatternMatch(pattern: str, s: str) -> bool:\n    def backtrack(cur: str, pattern: str, mappings: dict):\n        if not pattern:\n            return not cur\n        if pattern[0] in mappings:\n            if cur[:len(mappings[pattern[0]])] != mappings[pattern[0]]:\n                return False\n            return backtrack(cur[len(mappings[pattern[0]]):], pattern[1:], mappings)\n        for i in range(len(cur)):\n            if cur[:i+1] in mappings.values():\n                continue\n            mappings[pattern[0]] = cur[:i+1]\n            if backtrack(cur[i+1:], pattern[1:], mappings):\n                return True\n            del mappings[pattern[0]]\n        return False\n    return backtrack(s, pattern, {})", "asserts": ["assert wordPatternMatch(\"aaaa\", \"asdasdasdasd\")==True", "assert wordPatternMatch(\"abba\", \"dogcatcatdog\") == True", "assert wordPatternMatch(\"ab\", \"aa\") == False # since 'a' and 'b' cannot map to the same string \"a\"", "assert wordPatternMatch(\"xyz\", \"abcdefghi\") == True # 'x' -> \"a\", 'y' -> \"bc\", 'z' -> \"defghi\"", "assert wordPatternMatch(\"aba\", \"eggegg\") == False # 'a' maps to \"egg\", but 'b' cannot be mapped uniquely", "assert wordPatternMatch(\"zzz\", \"aaa\") == True # all 'z' map to \"a\"", "assert wordPatternMatch(\"aba\", \"catdogcat\") == True # 'a' -> \"cat\", 'b' -> \"dog\"", "assert wordPatternMatch(\"abab\", \"xyzxyzabcabc\") == False # cannot match 'a' and 'b' with two different strings each consistent with the pattern", "assert wordPatternMatch(\"abac\", \"xyzxyzxya\") == True # 'a' -> \"xyz\", 'b' -> \"xyz\", 'c' -> \"a\"", "assert wordPatternMatch(\"abcd\", \"xyzy\") == False # pattern too long for the string", "assert wordPatternMatch(\"aaaaa\", \"oneonetwo\") == False # not enough unique strings to map 'a' five times"]}, {"author": "Hafeez", "UUID": "8c9548d2-7b9c-46a4-9b8e-8afd488f7e87", "question": "Find and Replace Pattern: Given a list of strings words and a string pattern, return a list of words[i] that match pattern. You may return the answer in any order.\n\nA word matches the pattern if there exists a permutation of letters p so that after replacing every letter x in the pattern with p(x), we get the desired word.\n\nRecall that a permutation of letters is a bijection from letters to letters: every letter maps to another letter, and no two letters map to the same letter.", "examples": "Input: words = [\"abc\",\"deq\",\"mee\",\"aqq\",\"dkd\",\"ccc\"], pattern = \"abb\"\nOutput: [\"mee\",\"aqq\"]\nExplanation: \"mee\" matches the pattern because there is a permutation {a -> m, b -> e, ...}. \n\"ccc\" does not match the pattern because {a -> c, b -> c, ...} is not a permutation, since a and b map to the same letter.", "link": "https://leetcode.com/problems/find-and-replace-pattern/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def findAndReplacePattern(words: list, pattern: str) -> list:\n        def match(word):\n            m1, m2 = {}, {}\n            for w, p in zip(word, pattern):\n                if w not in m1: m1[w] = p\n                if p not in m2: m2[p] = w\n                if (m1[w], m2[p]) != (p, w):\n                    return False\n            return True\n\n        return list(filter(match, words))\n", "asserts": ["assert findAndReplacePattern([\"a\",\"b\",\"c\"], \"a\")==[\"a\",\"b\",\"c\"]", "assert findAndReplacePattern([\"xx\", \"xy\", \"yy\"], \"xx\") == [\"xx\", \"yy\"]", "assert findAndReplacePattern([\"abc\", \"def\", \"ghi\", \"jkl\"], \"xyz\") == [\"abc\", \"def\", \"ghi\", \"jkl\"]", "assert findAndReplacePattern([\"aaa\", \"bbb\", \"ccc\"], \"xyz\") == []"]}], "category": "Pattern", "prompt_tokens": 1081, "total_tokens": 1393, "completion_tokens": 312, "completion": "Pattern Matching: Given a pattern and a string s, determine if s follows the same pattern.\n\nA string s follows the same pattern if a one-to-one mapping exists between the characters in pattern and the words in s.\n\n###Code: \n\ndef wordPattern(pattern: str, s: str) -> bool:\n    words = s.split()\n    if len(pattern) != len(words):\n        return False\n    mapping = {}\n    reverse_mapping = {}\n    for char, word in zip(pattern, words):\n        if char not in mapping:\n            if word in reverse_mapping:\n                return False\n            mapping[char] = word\n            reverse_mapping[word] = char\n        else:\n            if mapping[char] != word:\n                return False\n    return True\n\n###Testcases: \n\nassert wordPattern(\"abba\", \"dog cat cat dog\") == True\nassert wordPattern(\"abba\", \"dog cat cat fish\") == False\nassert wordPattern(\"aaaa\", \"dog cat cat dog\") == False\nassert wordPattern(\"abba\", \"dog dog dog dog\") == False\nassert wordPattern(\"abc\", \"b c a\") == True\nassert wordPattern(\"aaa\", \"aa aa aa aa\") == False\nassert wordPattern(\"ab\", \"aa\") == False\nassert wordPattern(\"aab\", \"beef beef pork\") == False\nassert wordPattern(\"xyz\", \"apple banana orange\") == True\nassert wordPattern(\"abab\", \"red blue red blue\") == True\n\n[/Example 3]", "temperature": 0.888}, {"few_shots": [{"author": "Hafeez", "UUID": "124bfeca-24d0-411d-b4ad-26009b79436b", "question": "Word Pattern II: Given a pattern and a string s, return true if s matches the pattern.\n\nA string s matches a pattern if there is some bijective mapping of single characters to non-empty strings such that if each character in pattern is replaced by the string it maps to, then the resulting string is s. A bijective mapping means that no two characters map to the same string, and no character maps to two different strings.", "examples": "Input: pattern = \"abab\", s = \"redblueredblue\"\nOutput: true\nExplanation: One possible mapping is as follows:\n'a' -> \"red\"\n'b' -> \"blue\"\nInput: pattern = \"aabb\", s = \"xyzabcxzyabc\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern-ii/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def wordPatternMatch(pattern: str, s: str) -> bool:\n    def backtrack(cur: str, pattern: str, mappings: dict):\n        if not pattern:\n            return not cur\n        if pattern[0] in mappings:\n            if cur[:len(mappings[pattern[0]])] != mappings[pattern[0]]:\n                return False\n            return backtrack(cur[len(mappings[pattern[0]]):], pattern[1:], mappings)\n        for i in range(len(cur)):\n            if cur[:i+1] in mappings.values():\n                continue\n            mappings[pattern[0]] = cur[:i+1]\n            if backtrack(cur[i+1:], pattern[1:], mappings):\n                return True\n            del mappings[pattern[0]]\n        return False\n    return backtrack(s, pattern, {})", "asserts": ["assert wordPatternMatch(\"aaaa\", \"asdasdasdasd\")==True", "assert wordPatternMatch(\"abba\", \"dogcatcatdog\") == True", "assert wordPatternMatch(\"ab\", \"aa\") == False # since 'a' and 'b' cannot map to the same string \"a\"", "assert wordPatternMatch(\"xyz\", \"abcdefghi\") == True # 'x' -> \"a\", 'y' -> \"bc\", 'z' -> \"defghi\"", "assert wordPatternMatch(\"aba\", \"eggegg\") == False # 'a' maps to \"egg\", but 'b' cannot be mapped uniquely", "assert wordPatternMatch(\"zzz\", \"aaa\") == True # all 'z' map to \"a\"", "assert wordPatternMatch(\"aba\", \"catdogcat\") == True # 'a' -> \"cat\", 'b' -> \"dog\"", "assert wordPatternMatch(\"abab\", \"xyzxyzabcabc\") == False # cannot match 'a' and 'b' with two different strings each consistent with the pattern", "assert wordPatternMatch(\"abac\", \"xyzxyzxya\") == True # 'a' -> \"xyz\", 'b' -> \"xyz\", 'c' -> \"a\"", "assert wordPatternMatch(\"abcd\", \"xyzy\") == False # pattern too long for the string", "assert wordPatternMatch(\"aaaaa\", \"oneonetwo\") == False # not enough unique strings to map 'a' five times"]}, {"author": "Hafeez", "UUID": "8c9548d2-7b9c-46a4-9b8e-8afd488f7e87", "question": "Find and Replace Pattern: Given a list of strings words and a string pattern, return a list of words[i] that match pattern. You may return the answer in any order.\n\nA word matches the pattern if there exists a permutation of letters p so that after replacing every letter x in the pattern with p(x), we get the desired word.\n\nRecall that a permutation of letters is a bijection from letters to letters: every letter maps to another letter, and no two letters map to the same letter.", "examples": "Input: words = [\"abc\",\"deq\",\"mee\",\"aqq\",\"dkd\",\"ccc\"], pattern = \"abb\"\nOutput: [\"mee\",\"aqq\"]\nExplanation: \"mee\" matches the pattern because there is a permutation {a -> m, b -> e, ...}. \n\"ccc\" does not match the pattern because {a -> c, b -> c, ...} is not a permutation, since a and b map to the same letter.", "link": "https://leetcode.com/problems/find-and-replace-pattern/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def findAndReplacePattern(words: list, pattern: str) -> list:\n        def match(word):\n            m1, m2 = {}, {}\n            for w, p in zip(word, pattern):\n                if w not in m1: m1[w] = p\n                if p not in m2: m2[p] = w\n                if (m1[w], m2[p]) != (p, w):\n                    return False\n            return True\n\n        return list(filter(match, words))\n", "asserts": ["assert findAndReplacePattern([\"a\",\"b\",\"c\"], \"a\")==[\"a\",\"b\",\"c\"]", "assert findAndReplacePattern([\"xx\", \"xy\", \"yy\"], \"xx\") == [\"xx\", \"yy\"]", "assert findAndReplacePattern([\"abc\", \"def\", \"ghi\", \"jkl\"], \"xyz\") == [\"abc\", \"def\", \"ghi\", \"jkl\"]", "assert findAndReplacePattern([\"aaa\", \"bbb\", \"ccc\"], \"xyz\") == []"]}], "category": "Pattern", "prompt_tokens": 1081, "total_tokens": 1435, "completion_tokens": 354, "completion": "Find All Anagrams in a String: Given a string s and a non-empty string p, find all the start indices of p's anagrams in s.\n\nStrings consists of lowercase English letters only.\n\n###Code: \n\n```python\ndef findAnagrams(s: str, p: str) -> List[int]:\n        result = []\n        pCounter = collections.Counter(p)\n        sCounter = collections.Counter(s[:len(p)-1])\n        for i in range(len(p)-1,len(s)):\n            sCounter[s[i]] += 1   # include a new char in the window\n            if sCounter == pCounter:    # This step is O(1), since there are at most 26 English letters \n                result.append(i-len(p)+1)   # append the starting index\n            sCounter[s[i-len(p)+1]] -= 1   # decrease the count of oldest char in the window\n            if sCounter[s[i-len(p)+1]] == 0:\n                del sCounter[s[i-len(p)+1]]   # remove the count if it is 0\n        return result\n```\n\n###Testcases: \n\n```python\nassert findAnagrams(\"cbaebabacd\", \"abc\") == [0, 6]\nassert findAnagrams(\"abab\", \"ab\") == [0, 1, 2]\nassert findAnagrams(\"acdcaeccde\", \"c\") == [0, 3, 7, 8]\nassert findAnagrams(\"aaaaaaaaaa\", \"aa\") == [0, 1, 2, 3, 4, 5, 6, 7]\nassert findAnagrams(\"ab\", \"abc\") == []\n```", "temperature": 0.74}, {"few_shots": [{"author": "Hafeez", "UUID": "124bfeca-24d0-411d-b4ad-26009b79436b", "question": "Word Pattern II: Given a pattern and a string s, return true if s matches the pattern.\n\nA string s matches a pattern if there is some bijective mapping of single characters to non-empty strings such that if each character in pattern is replaced by the string it maps to, then the resulting string is s. A bijective mapping means that no two characters map to the same string, and no character maps to two different strings.", "examples": "Input: pattern = \"abab\", s = \"redblueredblue\"\nOutput: true\nExplanation: One possible mapping is as follows:\n'a' -> \"red\"\n'b' -> \"blue\"\nInput: pattern = \"aabb\", s = \"xyzabcxzyabc\"\nOutput: false", "link": "https://leetcode.com/problems/word-pattern-ii/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def wordPatternMatch(pattern: str, s: str) -> bool:\n    def backtrack(cur: str, pattern: str, mappings: dict):\n        if not pattern:\n            return not cur\n        if pattern[0] in mappings:\n            if cur[:len(mappings[pattern[0]])] != mappings[pattern[0]]:\n                return False\n            return backtrack(cur[len(mappings[pattern[0]]):], pattern[1:], mappings)\n        for i in range(len(cur)):\n            if cur[:i+1] in mappings.values():\n                continue\n            mappings[pattern[0]] = cur[:i+1]\n            if backtrack(cur[i+1:], pattern[1:], mappings):\n                return True\n            del mappings[pattern[0]]\n        return False\n    return backtrack(s, pattern, {})", "asserts": ["assert wordPatternMatch(\"aaaa\", \"asdasdasdasd\")==True", "assert wordPatternMatch(\"abba\", \"dogcatcatdog\") == True", "assert wordPatternMatch(\"ab\", \"aa\") == False # since 'a' and 'b' cannot map to the same string \"a\"", "assert wordPatternMatch(\"xyz\", \"abcdefghi\") == True # 'x' -> \"a\", 'y' -> \"bc\", 'z' -> \"defghi\"", "assert wordPatternMatch(\"aba\", \"eggegg\") == False # 'a' maps to \"egg\", but 'b' cannot be mapped uniquely", "assert wordPatternMatch(\"zzz\", \"aaa\") == True # all 'z' map to \"a\"", "assert wordPatternMatch(\"aba\", \"catdogcat\") == True # 'a' -> \"cat\", 'b' -> \"dog\"", "assert wordPatternMatch(\"abab\", \"xyzxyzabcabc\") == False # cannot match 'a' and 'b' with two different strings each consistent with the pattern", "assert wordPatternMatch(\"abac\", \"xyzxyzxya\") == True # 'a' -> \"xyz\", 'b' -> \"xyz\", 'c' -> \"a\"", "assert wordPatternMatch(\"abcd\", \"xyzy\") == False # pattern too long for the string", "assert wordPatternMatch(\"aaaaa\", \"oneonetwo\") == False # not enough unique strings to map 'a' five times"]}, {"author": "Hafeez", "UUID": "8c9548d2-7b9c-46a4-9b8e-8afd488f7e87", "question": "Find and Replace Pattern: Given a list of strings words and a string pattern, return a list of words[i] that match pattern. You may return the answer in any order.\n\nA word matches the pattern if there exists a permutation of letters p so that after replacing every letter x in the pattern with p(x), we get the desired word.\n\nRecall that a permutation of letters is a bijection from letters to letters: every letter maps to another letter, and no two letters map to the same letter.", "examples": "Input: words = [\"abc\",\"deq\",\"mee\",\"aqq\",\"dkd\",\"ccc\"], pattern = \"abb\"\nOutput: [\"mee\",\"aqq\"]\nExplanation: \"mee\" matches the pattern because there is a permutation {a -> m, b -> e, ...}. \n\"ccc\" does not match the pattern because {a -> c, b -> c, ...} is not a permutation, since a and b map to the same letter.", "link": "https://leetcode.com/problems/find-and-replace-pattern/description/", "difficulty": "Medium", "categories": ["Pattern"], "code": "def findAndReplacePattern(words: list, pattern: str) -> list:\n        def match(word):\n            m1, m2 = {}, {}\n            for w, p in zip(word, pattern):\n                if w not in m1: m1[w] = p\n                if p not in m2: m2[p] = w\n                if (m1[w], m2[p]) != (p, w):\n                    return False\n            return True\n\n        return list(filter(match, words))\n", "asserts": ["assert findAndReplacePattern([\"a\",\"b\",\"c\"], \"a\")==[\"a\",\"b\",\"c\"]", "assert findAndReplacePattern([\"xx\", \"xy\", \"yy\"], \"xx\") == [\"xx\", \"yy\"]", "assert findAndReplacePattern([\"abc\", \"def\", \"ghi\", \"jkl\"], \"xyz\") == [\"abc\", \"def\", \"ghi\", \"jkl\"]", "assert findAndReplacePattern([\"aaa\", \"bbb\", \"ccc\"], \"xyz\") == []"]}], "category": "Pattern", "prompt_tokens": 1081, "total_tokens": 1349, "completion_tokens": 268, "completion": "Decode String: Given an encoded string, return its decoded string.\n\nThe encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is being repeated exactly k times. Note that k is guaranteed to be a positive integer.\n\nYou may assume that the input string is always valid; no extra white spaces, square brackets are well-formed, etc.\n\n###Code: \n\ndef decodeString(s: str) -> str:\n    stack = []\n    stack.append([\"\", 1])\n    num = \"\"\n    for ch in s:\n        if ch.isdigit():\n            num += ch\n        elif ch == \"[\":\n            stack.append([\"\", int(num)])\n            num = \"\"\n        elif ch == \"]\":\n            st, k = stack.pop()\n            stack[-1][0] += st * k\n        else:\n            stack[-1][0] += ch\n    return stack[0][0]\n\n\n###Testcases: \n\nassert decodeString(\"3[a]2[bc]\") == \"aaabcbc\"\nassert decodeString(\"3[a2[c]]\") == \"accaccacc\"\nassert decodeString(\"2[abc]3[cd]ef\") == \"abcabccdcdcdef\"\nassert decodeString(\"abc3[cd]xyz\") == \"abccdcdcdxyz\"\n\n[/Example 3]", "temperature": 0.716}]