[{"few_shots": [{"author": "Calvin", "UUID": "ac641352-08d5-4950-8993-6a143da92ecf", "question": "You are given a string s and an integer k. You can choose one of the first k letters of s and append it at the end of the string.\n\nReturn the lexicographically smallest string you could have after applying the mentioned step any number of moves.\n", "examples": "Input: s = \"cba\", k = 1\nOutput: \"acb\"\n\nInput: s = \"baaca\", k = 3\nOutput: \"aaabc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef orderlyQueue(s: str, k: int) -> str:\n    if k == 1:\n        n = len(s)\n        ss = s + s\n        lex_min_str = s\n        for i in range(n):\n            lex_min_str = min(lex_min_str, ss[i:i + n])\n        return lex_min_str\n    \n    return \"\".join(sorted(s))\n", "asserts": ["assert orderlyQueue(\"abcd\", 1) == \"abcd\"", "assert orderlyQueue(\"hello\", 2) == \"ehllo\"", "assert orderlyQueue(\"programming\", 1) == \"ammingprogr\"", "assert orderlyQueue(\"rotator\", 1) == \"atorrot\"", "assert orderlyQueue(\"zxyabc\", 5) == \"abcxyz\"", "assert orderlyQueue(\"xy\", 2) == \"xy\""]}, {"author": "Calvin", "UUID": "80e34b28-16a8-46ac-8b6a-ee28beb1e8d4", "question": "Write a function that reverses a string. The input string is given as an array of characters s.\n\nYou must do this by modifying the input array in-place with O(1) extra memory.", "examples": "Input: [\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput: [\"o\",\"l\",\"l\",\"e\",\"h\"]\n\nInput: [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\nOutput: [\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def reverse_string(s: list) -> list:\n  l = 0\n  r = len(s) - 1\n  while l < r:\n    tmp = s[l]\n    s[l] = s[r]\n    s[r] = tmp\n    l += 1\n    r -= 1\n  return s\n", "asserts": ["assert reverse_string([\"a\",\"b\",\"c\",\"d\"]) == [\"d\", \"c\", \"b\", \"a\"]", "assert reverse_string([\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"]) == [\"n\", \"o\", \"h\", \"t\", \"y\", \"p\"]", "assert reverse_string([]) == []", "assert reverse_string([\"s\", \"i\", \"n\", \"g\", \"l\", \"e\"]) == [\"e\", \"l\", \"g\", \"n\", \"i\", \"s\"]", "assert reverse_string([\"A\"]) == [\"A\"]", "assert reverse_string([\"9\", \"8\", \"7\", \"6\", \"5\", \"4\", \"3\", \"2\", \"1\"]) == [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]", "assert reverse_string([\"B\", \"o\", \"b\"]) == [\"b\", \"o\", \"B\"]", "assert reverse_string([\"r\", \"e\", \"v\", \"e\", \"r\", \"s\", \"e\"]) == [\"e\", \"s\", \"r\", \"e\", \"v\", \"e\", \"r\"]", "assert reverse_string([\"1\", \"*\", \"2\", \"*\", \"3\"]) == [\"3\", \"*\", \"2\", \"*\", \"1\"]"]}], "category": "String", "prompt_tokens": 814, "total_tokens": 1116, "completion_tokens": 302, "completion": "Write a function to find the longest common prefix string amongst an array of strings.\n\nIf there is no common prefix, return an empty string \"\".\n\n###Code:\n\n```python\ndef longest_common_prefix(strs: list) -> str:\n    if not strs:\n        return \"\"\n    \n    min_length = min(len(s) for s in strs)\n    result = \"\"\n    \n    for i in range(min_length):\n        current_char = strs[0][i]\n        if all(s[i] == current_char for s in strs):\n            result += current_char\n        else:\n            break\n            \n    return result\n```\n\n###Testcases:\n\n```python\nassert longest_common_prefix([\"flower\", \"flow\", \"flight\"]) == \"fl\"\nassert longest_common_prefix([\"dog\", \"racecar\", \"car\"]) == \"\"\nassert longest_common_prefix([\"interspecies\", \"interstellar\", \"interstate\"]) == \"inters\"\nassert longest_common_prefix([\"throne\", \"throne\"]) == \"throne\"\nassert longest_common_prefix([\"prefix\", \"preposition\", \"precise\"]) == \"pre\"\nassert longest_common_prefix([\"\", \"\"]) == \"\"\nassert longest_common_prefix([\"a\"]) == \"a\"\nassert longest_common_prefix([\"ab\", \"a\"]) == \"a\"\nassert longest_common_prefix([\"classroom\", \"classy\", \"clasp\"]) == \"clas\"\nassert longest_common_prefix([\"blueberry\", \"blue\", \"blush\"]) == \"blu\"\n```\n\n[/Example 3]", "temperature": 0.799}, {"few_shots": [{"author": "Calvin", "UUID": "ac641352-08d5-4950-8993-6a143da92ecf", "question": "You are given a string s and an integer k. You can choose one of the first k letters of s and append it at the end of the string.\n\nReturn the lexicographically smallest string you could have after applying the mentioned step any number of moves.\n", "examples": "Input: s = \"cba\", k = 1\nOutput: \"acb\"\n\nInput: s = \"baaca\", k = 3\nOutput: \"aaabc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef orderlyQueue(s: str, k: int) -> str:\n    if k == 1:\n        n = len(s)\n        ss = s + s\n        lex_min_str = s\n        for i in range(n):\n            lex_min_str = min(lex_min_str, ss[i:i + n])\n        return lex_min_str\n    \n    return \"\".join(sorted(s))\n", "asserts": ["assert orderlyQueue(\"abcd\", 1) == \"abcd\"", "assert orderlyQueue(\"hello\", 2) == \"ehllo\"", "assert orderlyQueue(\"programming\", 1) == \"ammingprogr\"", "assert orderlyQueue(\"rotator\", 1) == \"atorrot\"", "assert orderlyQueue(\"zxyabc\", 5) == \"abcxyz\"", "assert orderlyQueue(\"xy\", 2) == \"xy\""]}, {"author": "Calvin", "UUID": "80e34b28-16a8-46ac-8b6a-ee28beb1e8d4", "question": "Write a function that reverses a string. The input string is given as an array of characters s.\n\nYou must do this by modifying the input array in-place with O(1) extra memory.", "examples": "Input: [\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput: [\"o\",\"l\",\"l\",\"e\",\"h\"]\n\nInput: [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\nOutput: [\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def reverse_string(s: list) -> list:\n  l = 0\n  r = len(s) - 1\n  while l < r:\n    tmp = s[l]\n    s[l] = s[r]\n    s[r] = tmp\n    l += 1\n    r -= 1\n  return s\n", "asserts": ["assert reverse_string([\"a\",\"b\",\"c\",\"d\"]) == [\"d\", \"c\", \"b\", \"a\"]", "assert reverse_string([\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"]) == [\"n\", \"o\", \"h\", \"t\", \"y\", \"p\"]", "assert reverse_string([]) == []", "assert reverse_string([\"s\", \"i\", \"n\", \"g\", \"l\", \"e\"]) == [\"e\", \"l\", \"g\", \"n\", \"i\", \"s\"]", "assert reverse_string([\"A\"]) == [\"A\"]", "assert reverse_string([\"9\", \"8\", \"7\", \"6\", \"5\", \"4\", \"3\", \"2\", \"1\"]) == [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]", "assert reverse_string([\"B\", \"o\", \"b\"]) == [\"b\", \"o\", \"B\"]", "assert reverse_string([\"r\", \"e\", \"v\", \"e\", \"r\", \"s\", \"e\"]) == [\"e\", \"s\", \"r\", \"e\", \"v\", \"e\", \"r\"]", "assert reverse_string([\"1\", \"*\", \"2\", \"*\", \"3\"]) == [\"3\", \"*\", \"2\", \"*\", \"1\"]"]}], "category": "String", "prompt_tokens": 814, "total_tokens": 1057, "completion_tokens": 243, "completion": "Write a function to check if two given strings are anagrams of each other. An anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.\n\n###Code: \n\ndef are_anagrams(str1: str, str2: str) -> bool:\n    return sorted(str1) == sorted(str2)\n\n###Testcases: \n\nassert are_anagrams(\"listen\", \"silent\") == True\nassert are_anagrams(\"triangle\", \"integral\") == True\nassert are_anagrams(\"hello\", \"billion\") == False\nassert are_anagrams(\"dormitory\", \"dirty room\") == False  # Spaces are not considered\nassert are_anagrams(\"\", \"\") == True\nassert are_anagrams(\"aabbcc\", \"abcabc\") == True\nassert are_anagrams(\"anagram\", \"nagaram\") == True\nassert are_anagrams(\"rat\", \"car\") == False\nassert are_anagrams(\"public relations\", \"crap built on lies\") == False  # Spaces and case sensitivity are not considered\nassert are_anagrams(\"night\", \"thing\") == True\n\n[/Example 3]", "temperature": 0.763}, {"few_shots": [{"author": "Calvin", "UUID": "ac641352-08d5-4950-8993-6a143da92ecf", "question": "You are given a string s and an integer k. You can choose one of the first k letters of s and append it at the end of the string.\n\nReturn the lexicographically smallest string you could have after applying the mentioned step any number of moves.\n", "examples": "Input: s = \"cba\", k = 1\nOutput: \"acb\"\n\nInput: s = \"baaca\", k = 3\nOutput: \"aaabc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef orderlyQueue(s: str, k: int) -> str:\n    if k == 1:\n        n = len(s)\n        ss = s + s\n        lex_min_str = s\n        for i in range(n):\n            lex_min_str = min(lex_min_str, ss[i:i + n])\n        return lex_min_str\n    \n    return \"\".join(sorted(s))\n", "asserts": ["assert orderlyQueue(\"abcd\", 1) == \"abcd\"", "assert orderlyQueue(\"hello\", 2) == \"ehllo\"", "assert orderlyQueue(\"programming\", 1) == \"ammingprogr\"", "assert orderlyQueue(\"rotator\", 1) == \"atorrot\"", "assert orderlyQueue(\"zxyabc\", 5) == \"abcxyz\"", "assert orderlyQueue(\"xy\", 2) == \"xy\""]}, {"author": "Calvin", "UUID": "80e34b28-16a8-46ac-8b6a-ee28beb1e8d4", "question": "Write a function that reverses a string. The input string is given as an array of characters s.\n\nYou must do this by modifying the input array in-place with O(1) extra memory.", "examples": "Input: [\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput: [\"o\",\"l\",\"l\",\"e\",\"h\"]\n\nInput: [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\nOutput: [\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def reverse_string(s: list) -> list:\n  l = 0\n  r = len(s) - 1\n  while l < r:\n    tmp = s[l]\n    s[l] = s[r]\n    s[r] = tmp\n    l += 1\n    r -= 1\n  return s\n", "asserts": ["assert reverse_string([\"a\",\"b\",\"c\",\"d\"]) == [\"d\", \"c\", \"b\", \"a\"]", "assert reverse_string([\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"]) == [\"n\", \"o\", \"h\", \"t\", \"y\", \"p\"]", "assert reverse_string([]) == []", "assert reverse_string([\"s\", \"i\", \"n\", \"g\", \"l\", \"e\"]) == [\"e\", \"l\", \"g\", \"n\", \"i\", \"s\"]", "assert reverse_string([\"A\"]) == [\"A\"]", "assert reverse_string([\"9\", \"8\", \"7\", \"6\", \"5\", \"4\", \"3\", \"2\", \"1\"]) == [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]", "assert reverse_string([\"B\", \"o\", \"b\"]) == [\"b\", \"o\", \"B\"]", "assert reverse_string([\"r\", \"e\", \"v\", \"e\", \"r\", \"s\", \"e\"]) == [\"e\", \"s\", \"r\", \"e\", \"v\", \"e\", \"r\"]", "assert reverse_string([\"1\", \"*\", \"2\", \"*\", \"3\"]) == [\"3\", \"*\", \"2\", \"*\", \"1\"]"]}], "category": "String", "prompt_tokens": 814, "total_tokens": 1064, "completion_tokens": 250, "completion": "Given a string s, find the first non-repeating character in it and return its index. If it does not exist, return -1.\n\n###Code:\n\ndef first_uniq_char(s: str) -> int:\n    frequency = {}\n    \n    # Count the frequency of each character\n    for char in s:\n        frequency[char] = frequency.get(char, 0) + 1\n    \n    # Find first non-repeating character\n    for index, char in enumerate(s):\n        if frequency[char] == 1:\n            return index\n    \n    return -1\n\n\n###Testcases:\n\nassert first_uniq_char(\"leetcode\") == 0\nassert first_uniq_char(\"loveleetcode\") == 2\nassert first_uniq_char(\"aabb\") == -1\nassert first_uniq_char(\"algorithm\") == 0\nassert first_uniq_char(\"abcabcabc\") == -1\nassert first_uniq_char(\"nikola\") == 0\nassert first_uniq_char(\"tesla\") == 0\nassert first_uniq_char(\"hello\") == 0\nassert first_uniq_char(\"xxyz\") == 3\nassert first_uniq_char(\"\") == -1\n\n[/Example 3]", "temperature": 0.862}, {"few_shots": [{"author": "Calvin", "UUID": "ac641352-08d5-4950-8993-6a143da92ecf", "question": "You are given a string s and an integer k. You can choose one of the first k letters of s and append it at the end of the string.\n\nReturn the lexicographically smallest string you could have after applying the mentioned step any number of moves.\n", "examples": "Input: s = \"cba\", k = 1\nOutput: \"acb\"\n\nInput: s = \"baaca\", k = 3\nOutput: \"aaabc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef orderlyQueue(s: str, k: int) -> str:\n    if k == 1:\n        n = len(s)\n        ss = s + s\n        lex_min_str = s\n        for i in range(n):\n            lex_min_str = min(lex_min_str, ss[i:i + n])\n        return lex_min_str\n    \n    return \"\".join(sorted(s))\n", "asserts": ["assert orderlyQueue(\"abcd\", 1) == \"abcd\"", "assert orderlyQueue(\"hello\", 2) == \"ehllo\"", "assert orderlyQueue(\"programming\", 1) == \"ammingprogr\"", "assert orderlyQueue(\"rotator\", 1) == \"atorrot\"", "assert orderlyQueue(\"zxyabc\", 5) == \"abcxyz\"", "assert orderlyQueue(\"xy\", 2) == \"xy\""]}, {"author": "Calvin", "UUID": "80e34b28-16a8-46ac-8b6a-ee28beb1e8d4", "question": "Write a function that reverses a string. The input string is given as an array of characters s.\n\nYou must do this by modifying the input array in-place with O(1) extra memory.", "examples": "Input: [\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput: [\"o\",\"l\",\"l\",\"e\",\"h\"]\n\nInput: [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\nOutput: [\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def reverse_string(s: list) -> list:\n  l = 0\n  r = len(s) - 1\n  while l < r:\n    tmp = s[l]\n    s[l] = s[r]\n    s[r] = tmp\n    l += 1\n    r -= 1\n  return s\n", "asserts": ["assert reverse_string([\"a\",\"b\",\"c\",\"d\"]) == [\"d\", \"c\", \"b\", \"a\"]", "assert reverse_string([\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"]) == [\"n\", \"o\", \"h\", \"t\", \"y\", \"p\"]", "assert reverse_string([]) == []", "assert reverse_string([\"s\", \"i\", \"n\", \"g\", \"l\", \"e\"]) == [\"e\", \"l\", \"g\", \"n\", \"i\", \"s\"]", "assert reverse_string([\"A\"]) == [\"A\"]", "assert reverse_string([\"9\", \"8\", \"7\", \"6\", \"5\", \"4\", \"3\", \"2\", \"1\"]) == [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]", "assert reverse_string([\"B\", \"o\", \"b\"]) == [\"b\", \"o\", \"B\"]", "assert reverse_string([\"r\", \"e\", \"v\", \"e\", \"r\", \"s\", \"e\"]) == [\"e\", \"s\", \"r\", \"e\", \"v\", \"e\", \"r\"]", "assert reverse_string([\"1\", \"*\", \"2\", \"*\", \"3\"]) == [\"3\", \"*\", \"2\", \"*\", \"1\"]"]}], "category": "String", "prompt_tokens": 814, "total_tokens": 1176, "completion_tokens": 362, "completion": "Given a string containing only lowercase English letters and the '?' character, convert all the '?' characters into lowercase English letters such that the resulting string does not contain any consecutive repeating characters. You can assume that it is always possible to replace '?' with a letter to meet the requirement.\n\n###Code: \n\ndef modify_string(s: str) -> str:\n    s = list(s)\n    for i in range(len(s)):\n        if s[i] == '?':\n            for c in \"abcdefghijklmnopqrstuvwxyz\":\n                if (i == 0 or s[i-1] != c) and (i == len(s)-1 or s[i+1] != c):\n                    s[i] = c\n                    break\n    return \"\".join(s)\n\n\n###Testcases: \n\nassert modify_string(\"ub?\") == \"uba\"  # Sample Output\nassert modify_string(\"?zs\") == \"azs\"  # Sample Output\nassert modify_string(\"a?a\") == \"aba\"  # Sample Output\nassert modify_string(\"??yw?ipkj?\") == \"abywaipkja\"  # Sample Output\nassert modify_string(\"?\") == \"a\"  # Single ? can be replaced with any letter\nassert modify_string(\"????\") == \"abab\" or modify_string(\"????\") == \"baba\"  # Multiple solutions possible\nassert modify_string(\"ab?ac?\") == \"abzacw\"  # Sample Output\nassert modify_string(\"j?qg??b\") == \"jaqgacb\"  # Sample Output\nassert modify_string(\"?ab??bac\") == \"cabacbac\"  # Sample Output\nassert modify_string(\"??abc???de?f?\") == \"ababcabadeafg\"  # Sample Output\n\n[/Example 3]", "temperature": 0.657}, {"few_shots": [{"author": "Calvin", "UUID": "ac641352-08d5-4950-8993-6a143da92ecf", "question": "You are given a string s and an integer k. You can choose one of the first k letters of s and append it at the end of the string.\n\nReturn the lexicographically smallest string you could have after applying the mentioned step any number of moves.\n", "examples": "Input: s = \"cba\", k = 1\nOutput: \"acb\"\n\nInput: s = \"baaca\", k = 3\nOutput: \"aaabc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef orderlyQueue(s: str, k: int) -> str:\n    if k == 1:\n        n = len(s)\n        ss = s + s\n        lex_min_str = s\n        for i in range(n):\n            lex_min_str = min(lex_min_str, ss[i:i + n])\n        return lex_min_str\n    \n    return \"\".join(sorted(s))\n", "asserts": ["assert orderlyQueue(\"abcd\", 1) == \"abcd\"", "assert orderlyQueue(\"hello\", 2) == \"ehllo\"", "assert orderlyQueue(\"programming\", 1) == \"ammingprogr\"", "assert orderlyQueue(\"rotator\", 1) == \"atorrot\"", "assert orderlyQueue(\"zxyabc\", 5) == \"abcxyz\"", "assert orderlyQueue(\"xy\", 2) == \"xy\""]}, {"author": "Calvin", "UUID": "80e34b28-16a8-46ac-8b6a-ee28beb1e8d4", "question": "Write a function that reverses a string. The input string is given as an array of characters s.\n\nYou must do this by modifying the input array in-place with O(1) extra memory.", "examples": "Input: [\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput: [\"o\",\"l\",\"l\",\"e\",\"h\"]\n\nInput: [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\nOutput: [\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def reverse_string(s: list) -> list:\n  l = 0\n  r = len(s) - 1\n  while l < r:\n    tmp = s[l]\n    s[l] = s[r]\n    s[r] = tmp\n    l += 1\n    r -= 1\n  return s\n", "asserts": ["assert reverse_string([\"a\",\"b\",\"c\",\"d\"]) == [\"d\", \"c\", \"b\", \"a\"]", "assert reverse_string([\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"]) == [\"n\", \"o\", \"h\", \"t\", \"y\", \"p\"]", "assert reverse_string([]) == []", "assert reverse_string([\"s\", \"i\", \"n\", \"g\", \"l\", \"e\"]) == [\"e\", \"l\", \"g\", \"n\", \"i\", \"s\"]", "assert reverse_string([\"A\"]) == [\"A\"]", "assert reverse_string([\"9\", \"8\", \"7\", \"6\", \"5\", \"4\", \"3\", \"2\", \"1\"]) == [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]", "assert reverse_string([\"B\", \"o\", \"b\"]) == [\"b\", \"o\", \"B\"]", "assert reverse_string([\"r\", \"e\", \"v\", \"e\", \"r\", \"s\", \"e\"]) == [\"e\", \"s\", \"r\", \"e\", \"v\", \"e\", \"r\"]", "assert reverse_string([\"1\", \"*\", \"2\", \"*\", \"3\"]) == [\"3\", \"*\", \"2\", \"*\", \"1\"]"]}], "category": "String", "prompt_tokens": 814, "total_tokens": 1222, "completion_tokens": 408, "completion": "Write a function that takes a string, and returns the longest palindromic substring in it. \nIf there are multiple longest palindromic substrings, return the first one encountered.\n\n###Code: \n\ndef longest_palindromic_substring(s: str) -> str:\n    def expand_from_center(left: int, right: int) -> str:\n        while left >= 0 and right < len(s) and s[left] == s[right]:\n            left -= 1\n            right += 1\n        return s[left + 1:right]\n    \n    longest_palindrome = \"\"\n    \n    for i in range(len(s)):\n        # Odd length palindromes\n        palindrome1 = expand_from_center(i, i)\n        # Even length palindromes\n        palindrome2 = expand_from_center(i, i + 1)\n        \n        # Update longest_palindrome if necessary\n        if len(palindrome1) > len(longest_palindrome):\n            longest_palindrome = palindrome1\n        if len(palindrome2) > len(longest_palindrome):\n            longest_palindrome = palindrome2\n    \n    return longest_palindrome\n\n\n###Testcases: \n\nassert longest_palindromic_substring(\"cbbd\") == \"bb\"\nassert longest_palindromic_substring(\"babad\") == \"bab\"\nassert longest_palindromic_substring(\"a\") == \"a\"\nassert longest_palindromic_substring(\"ac\") == \"a\"\nassert longest_palindromic_substring(\"racecar\") == \"racecar\"\nassert longest_palindromic_substring(\"forgeeksskeegfor\") == \"geeksskeeg\"\nassert longest_palindromic_substring(\"bananas\") == \"anana\"\nassert longest_palindromic_substring(\"abacab\") == \"bacab\"\nassert longest_palindromic_substring(\"tattarrattat\") == \"tattarrattat\"\n\n[/Example 3]", "temperature": 0.873}, {"few_shots": [{"author": "Calvin", "UUID": "ac641352-08d5-4950-8993-6a143da92ecf", "question": "You are given a string s and an integer k. You can choose one of the first k letters of s and append it at the end of the string.\n\nReturn the lexicographically smallest string you could have after applying the mentioned step any number of moves.\n", "examples": "Input: s = \"cba\", k = 1\nOutput: \"acb\"\n\nInput: s = \"baaca\", k = 3\nOutput: \"aaabc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef orderlyQueue(s: str, k: int) -> str:\n    if k == 1:\n        n = len(s)\n        ss = s + s\n        lex_min_str = s\n        for i in range(n):\n            lex_min_str = min(lex_min_str, ss[i:i + n])\n        return lex_min_str\n    \n    return \"\".join(sorted(s))\n", "asserts": ["assert orderlyQueue(\"abcd\", 1) == \"abcd\"", "assert orderlyQueue(\"hello\", 2) == \"ehllo\"", "assert orderlyQueue(\"programming\", 1) == \"ammingprogr\"", "assert orderlyQueue(\"rotator\", 1) == \"atorrot\"", "assert orderlyQueue(\"zxyabc\", 5) == \"abcxyz\"", "assert orderlyQueue(\"xy\", 2) == \"xy\""]}, {"author": "Calvin", "UUID": "80e34b28-16a8-46ac-8b6a-ee28beb1e8d4", "question": "Write a function that reverses a string. The input string is given as an array of characters s.\n\nYou must do this by modifying the input array in-place with O(1) extra memory.", "examples": "Input: [\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput: [\"o\",\"l\",\"l\",\"e\",\"h\"]\n\nInput: [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\nOutput: [\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def reverse_string(s: list) -> list:\n  l = 0\n  r = len(s) - 1\n  while l < r:\n    tmp = s[l]\n    s[l] = s[r]\n    s[r] = tmp\n    l += 1\n    r -= 1\n  return s\n", "asserts": ["assert reverse_string([\"a\",\"b\",\"c\",\"d\"]) == [\"d\", \"c\", \"b\", \"a\"]", "assert reverse_string([\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"]) == [\"n\", \"o\", \"h\", \"t\", \"y\", \"p\"]", "assert reverse_string([]) == []", "assert reverse_string([\"s\", \"i\", \"n\", \"g\", \"l\", \"e\"]) == [\"e\", \"l\", \"g\", \"n\", \"i\", \"s\"]", "assert reverse_string([\"A\"]) == [\"A\"]", "assert reverse_string([\"9\", \"8\", \"7\", \"6\", \"5\", \"4\", \"3\", \"2\", \"1\"]) == [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]", "assert reverse_string([\"B\", \"o\", \"b\"]) == [\"b\", \"o\", \"B\"]", "assert reverse_string([\"r\", \"e\", \"v\", \"e\", \"r\", \"s\", \"e\"]) == [\"e\", \"s\", \"r\", \"e\", \"v\", \"e\", \"r\"]", "assert reverse_string([\"1\", \"*\", \"2\", \"*\", \"3\"]) == [\"3\", \"*\", \"2\", \"*\", \"1\"]"]}], "category": "String", "prompt_tokens": 814, "total_tokens": 1080, "completion_tokens": 266, "completion": "Given a string s, find the length of the longest substring without repeating characters.\n\n###Code: \n\n```python\ndef length_of_longest_substring(s: str) -> int:\n    start = maxLength = 0\n    usedChar = {}\n\n    for i in range(len(s)):\n        if s[i] in usedChar and start <= usedChar[s[i]]:\n            start = usedChar[s[i]] + 1\n        else:\n            maxLength = max(maxLength, i - start + 1)\n\n        usedChar[s[i]] = i\n\n    return maxLength\n```\n\n###Testcases: \n\n```python\nassert length_of_longest_substring(\"abcabcbb\") == 3\nassert length_of_longest_substring(\"bbbbb\") == 1\nassert length_of_longest_substring(\"pwwkew\") == 3\nassert length_of_longest_substring(\"\") == 0\nassert length_of_longest_substring(\" \") == 1\nassert length_of_longest_substring(\"au\") == 2\nassert length_of_longest_substring(\"dvdf\") == 3\nassert length_of_longest_substring(\"anviaj\") == 5\nassert length_of_longest_substring(\"abba\") == 2\n```\n\n[/Example 3]", "temperature": 0.728}, {"few_shots": [{"author": "Calvin", "UUID": "ac641352-08d5-4950-8993-6a143da92ecf", "question": "You are given a string s and an integer k. You can choose one of the first k letters of s and append it at the end of the string.\n\nReturn the lexicographically smallest string you could have after applying the mentioned step any number of moves.\n", "examples": "Input: s = \"cba\", k = 1\nOutput: \"acb\"\n\nInput: s = \"baaca\", k = 3\nOutput: \"aaabc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef orderlyQueue(s: str, k: int) -> str:\n    if k == 1:\n        n = len(s)\n        ss = s + s\n        lex_min_str = s\n        for i in range(n):\n            lex_min_str = min(lex_min_str, ss[i:i + n])\n        return lex_min_str\n    \n    return \"\".join(sorted(s))\n", "asserts": ["assert orderlyQueue(\"abcd\", 1) == \"abcd\"", "assert orderlyQueue(\"hello\", 2) == \"ehllo\"", "assert orderlyQueue(\"programming\", 1) == \"ammingprogr\"", "assert orderlyQueue(\"rotator\", 1) == \"atorrot\"", "assert orderlyQueue(\"zxyabc\", 5) == \"abcxyz\"", "assert orderlyQueue(\"xy\", 2) == \"xy\""]}, {"author": "Calvin", "UUID": "80e34b28-16a8-46ac-8b6a-ee28beb1e8d4", "question": "Write a function that reverses a string. The input string is given as an array of characters s.\n\nYou must do this by modifying the input array in-place with O(1) extra memory.", "examples": "Input: [\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput: [\"o\",\"l\",\"l\",\"e\",\"h\"]\n\nInput: [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\nOutput: [\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def reverse_string(s: list) -> list:\n  l = 0\n  r = len(s) - 1\n  while l < r:\n    tmp = s[l]\n    s[l] = s[r]\n    s[r] = tmp\n    l += 1\n    r -= 1\n  return s\n", "asserts": ["assert reverse_string([\"a\",\"b\",\"c\",\"d\"]) == [\"d\", \"c\", \"b\", \"a\"]", "assert reverse_string([\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"]) == [\"n\", \"o\", \"h\", \"t\", \"y\", \"p\"]", "assert reverse_string([]) == []", "assert reverse_string([\"s\", \"i\", \"n\", \"g\", \"l\", \"e\"]) == [\"e\", \"l\", \"g\", \"n\", \"i\", \"s\"]", "assert reverse_string([\"A\"]) == [\"A\"]", "assert reverse_string([\"9\", \"8\", \"7\", \"6\", \"5\", \"4\", \"3\", \"2\", \"1\"]) == [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]", "assert reverse_string([\"B\", \"o\", \"b\"]) == [\"b\", \"o\", \"B\"]", "assert reverse_string([\"r\", \"e\", \"v\", \"e\", \"r\", \"s\", \"e\"]) == [\"e\", \"s\", \"r\", \"e\", \"v\", \"e\", \"r\"]", "assert reverse_string([\"1\", \"*\", \"2\", \"*\", \"3\"]) == [\"3\", \"*\", \"2\", \"*\", \"1\"]"]}], "category": "String", "prompt_tokens": 814, "total_tokens": 1201, "completion_tokens": 387, "completion": "Given a string containing only three types of characters: '(', ')' and '*', write a function to check whether this string is valid. The function considers the string valid if:\n\n1. Any left parenthesis '(' must have a corresponding right parenthesis ')'.\n2. Any right parenthesis ')' must have a corresponding left parenthesis '('.\n3. Left parenthesis '(' must go before the corresponding right parenthesis ')'.\n4. '*' could be treated as a single right parenthesis ')' or a single left parenthesis '(' or an empty string \"\".\n5. An empty string is also considered valid.\n\nA valid string could be balanced in multiple ways, the '*' characters could be interpreted in various ways, but as long as one or more interpretations result in a valid string, the overall string is considered valid.\n\n###Code: \n\ndef check_valid_string(s: str) -> bool:\n    left_balance = right_balance = 0\n    for c in s:\n        if c == '(' or c == '*':\n            left_balance += 1\n        else:\n            left_balance -= 1\n        \n        if c == ')' or c == '*':\n            right_balance -= 1\n        else:\n            right_balance += 1\n        \n        if left_balance < 0:\n            return False\n        if right_balance < 0:\n            right_balance = 0\n    \n    return right_balance == 0\n\n\n###Testcases: \n\nassert check_valid_string(\"()\") == True\nassert check_valid_string(\"(*)\") == True\nassert check_valid_string(\"(*))\") == True\nassert check_valid_string(\"(((******))\") == True\nassert check_valid_string(\"(()\") == False\nassert check_valid_string(\")*(\") == False\nassert check_valid_string(\"(*)))\") == False\nassert check_valid_string(\")(\") == False\nassert check_valid_string(\"*())\") == True\nassert check_valid_string(\"((*)\") == True\n\n[/Example 3]", "temperature": 0.943}, {"few_shots": [{"author": "Calvin", "UUID": "ac641352-08d5-4950-8993-6a143da92ecf", "question": "You are given a string s and an integer k. You can choose one of the first k letters of s and append it at the end of the string.\n\nReturn the lexicographically smallest string you could have after applying the mentioned step any number of moves.\n", "examples": "Input: s = \"cba\", k = 1\nOutput: \"acb\"\n\nInput: s = \"baaca\", k = 3\nOutput: \"aaabc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef orderlyQueue(s: str, k: int) -> str:\n    if k == 1:\n        n = len(s)\n        ss = s + s\n        lex_min_str = s\n        for i in range(n):\n            lex_min_str = min(lex_min_str, ss[i:i + n])\n        return lex_min_str\n    \n    return \"\".join(sorted(s))\n", "asserts": ["assert orderlyQueue(\"abcd\", 1) == \"abcd\"", "assert orderlyQueue(\"hello\", 2) == \"ehllo\"", "assert orderlyQueue(\"programming\", 1) == \"ammingprogr\"", "assert orderlyQueue(\"rotator\", 1) == \"atorrot\"", "assert orderlyQueue(\"zxyabc\", 5) == \"abcxyz\"", "assert orderlyQueue(\"xy\", 2) == \"xy\""]}, {"author": "Calvin", "UUID": "80e34b28-16a8-46ac-8b6a-ee28beb1e8d4", "question": "Write a function that reverses a string. The input string is given as an array of characters s.\n\nYou must do this by modifying the input array in-place with O(1) extra memory.", "examples": "Input: [\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput: [\"o\",\"l\",\"l\",\"e\",\"h\"]\n\nInput: [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\nOutput: [\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def reverse_string(s: list) -> list:\n  l = 0\n  r = len(s) - 1\n  while l < r:\n    tmp = s[l]\n    s[l] = s[r]\n    s[r] = tmp\n    l += 1\n    r -= 1\n  return s\n", "asserts": ["assert reverse_string([\"a\",\"b\",\"c\",\"d\"]) == [\"d\", \"c\", \"b\", \"a\"]", "assert reverse_string([\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"]) == [\"n\", \"o\", \"h\", \"t\", \"y\", \"p\"]", "assert reverse_string([]) == []", "assert reverse_string([\"s\", \"i\", \"n\", \"g\", \"l\", \"e\"]) == [\"e\", \"l\", \"g\", \"n\", \"i\", \"s\"]", "assert reverse_string([\"A\"]) == [\"A\"]", "assert reverse_string([\"9\", \"8\", \"7\", \"6\", \"5\", \"4\", \"3\", \"2\", \"1\"]) == [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]", "assert reverse_string([\"B\", \"o\", \"b\"]) == [\"b\", \"o\", \"B\"]", "assert reverse_string([\"r\", \"e\", \"v\", \"e\", \"r\", \"s\", \"e\"]) == [\"e\", \"s\", \"r\", \"e\", \"v\", \"e\", \"r\"]", "assert reverse_string([\"1\", \"*\", \"2\", \"*\", \"3\"]) == [\"3\", \"*\", \"2\", \"*\", \"1\"]"]}], "category": "String", "prompt_tokens": 814, "total_tokens": 1199, "completion_tokens": 385, "completion": "Given a string s, return the longest palindromic substring in s.\n\n###Code:\n\ndef longest_palindrome(s: str) -> str:\n    if len(s) == 0:\n        return \"\"\n    \n    start = 0\n    end = 0\n    \n    for i in range(len(s)):\n        len1 = expand_around_center(s, i, i)\n        len2 = expand_around_center(s, i, i + 1)\n        max_len = max(len1, len2)\n        if max_len > end - start:\n            start = i - (max_len - 1) // 2\n            end = i + max_len // 2\n    \n    return s[start:end + 1]\n\ndef expand_around_center(s, left, right):\n    while left >= 0 and right < len(s) and s[left] == s[right]:\n        left -= 1\n        right += 1\n    return right - left - 1\n\n###Testcases:\n\nassert longest_palindrome(\"babad\") == \"bab\" or longest_palindrome(\"babad\") == \"aba\"\nassert longest_palindrome(\"cbbd\") == \"bb\"\nassert longest_palindrome(\"a\") == \"a\"\nassert longest_palindrome(\"ac\") == \"a\" or longest_palindrome(\"ac\") == \"c\"\nassert longest_palindrome(\"racecar\") == \"racecar\"\nassert longest_palindrome(\"forgeeksskeegfor\") == \"geeksskeeg\"\nassert longest_palindrome(\"madamimadam\") == \"madamimadam\"\nassert longest_palindrome(\"xabax\") == \"xabax\"\nassert longest_palindrome(\"abacdfgdcaba\") == \"aba\"\nassert longest_palindrome(\"abacdfgdcabba\") == \"abba\"\nassert longest_palindrome(\"\") == \"\"\n\n[/Example 3]", "temperature": 0.79}, {"few_shots": [{"author": "Calvin", "UUID": "ac641352-08d5-4950-8993-6a143da92ecf", "question": "You are given a string s and an integer k. You can choose one of the first k letters of s and append it at the end of the string.\n\nReturn the lexicographically smallest string you could have after applying the mentioned step any number of moves.\n", "examples": "Input: s = \"cba\", k = 1\nOutput: \"acb\"\n\nInput: s = \"baaca\", k = 3\nOutput: \"aaabc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef orderlyQueue(s: str, k: int) -> str:\n    if k == 1:\n        n = len(s)\n        ss = s + s\n        lex_min_str = s\n        for i in range(n):\n            lex_min_str = min(lex_min_str, ss[i:i + n])\n        return lex_min_str\n    \n    return \"\".join(sorted(s))\n", "asserts": ["assert orderlyQueue(\"abcd\", 1) == \"abcd\"", "assert orderlyQueue(\"hello\", 2) == \"ehllo\"", "assert orderlyQueue(\"programming\", 1) == \"ammingprogr\"", "assert orderlyQueue(\"rotator\", 1) == \"atorrot\"", "assert orderlyQueue(\"zxyabc\", 5) == \"abcxyz\"", "assert orderlyQueue(\"xy\", 2) == \"xy\""]}, {"author": "Calvin", "UUID": "80e34b28-16a8-46ac-8b6a-ee28beb1e8d4", "question": "Write a function that reverses a string. The input string is given as an array of characters s.\n\nYou must do this by modifying the input array in-place with O(1) extra memory.", "examples": "Input: [\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput: [\"o\",\"l\",\"l\",\"e\",\"h\"]\n\nInput: [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\nOutput: [\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def reverse_string(s: list) -> list:\n  l = 0\n  r = len(s) - 1\n  while l < r:\n    tmp = s[l]\n    s[l] = s[r]\n    s[r] = tmp\n    l += 1\n    r -= 1\n  return s\n", "asserts": ["assert reverse_string([\"a\",\"b\",\"c\",\"d\"]) == [\"d\", \"c\", \"b\", \"a\"]", "assert reverse_string([\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"]) == [\"n\", \"o\", \"h\", \"t\", \"y\", \"p\"]", "assert reverse_string([]) == []", "assert reverse_string([\"s\", \"i\", \"n\", \"g\", \"l\", \"e\"]) == [\"e\", \"l\", \"g\", \"n\", \"i\", \"s\"]", "assert reverse_string([\"A\"]) == [\"A\"]", "assert reverse_string([\"9\", \"8\", \"7\", \"6\", \"5\", \"4\", \"3\", \"2\", \"1\"]) == [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]", "assert reverse_string([\"B\", \"o\", \"b\"]) == [\"b\", \"o\", \"B\"]", "assert reverse_string([\"r\", \"e\", \"v\", \"e\", \"r\", \"s\", \"e\"]) == [\"e\", \"s\", \"r\", \"e\", \"v\", \"e\", \"r\"]", "assert reverse_string([\"1\", \"*\", \"2\", \"*\", \"3\"]) == [\"3\", \"*\", \"2\", \"*\", \"1\"]"]}], "category": "String", "prompt_tokens": 814, "total_tokens": 1102, "completion_tokens": 288, "completion": "Given a string s and an integer array indices of the same length. The string s will be shuffled such that the character at the ith position moves to indices[i] in the shuffled string.\n\nReturn the shuffled string.\n\n###Code: \n\ndef restore_string(s: str, indices: list[int]) -> str:\n    shuffled_string = [''] * len(s)\n    for i, char in enumerate(s):\n        shuffled_string[indices[i]] = char\n    return ''.join(shuffled_string)\n\n\n###Testcases: \n\nassert restore_string(\"codeleet\", [4,5,6,7,0,2,1,3]) == \"leetcode\"\nassert restore_string(\"abc\", [0,1,2]) == \"abc\"\nassert restore_string(\"aiohn\", [3,1,4,2,0]) == \"nihao\"\nassert restore_string(\"aaiougrt\", [4,0,2,6,7,3,1,5]) == \"arigatou\"\nassert restore_string(\"art\", [1,0,2]) == \"rat\"\nassert restore_string(\"nraeyanlh\", [1,4,7,0,3,6,2,8,5]) == \"hanyarlen\"\nassert restore_string(\"12345\", [4,3,2,1,0]) == \"54321\"\n\n[/Example 3]", "temperature": 0.733}, {"few_shots": [{"author": "Calvin", "UUID": "ac641352-08d5-4950-8993-6a143da92ecf", "question": "You are given a string s and an integer k. You can choose one of the first k letters of s and append it at the end of the string.\n\nReturn the lexicographically smallest string you could have after applying the mentioned step any number of moves.\n", "examples": "Input: s = \"cba\", k = 1\nOutput: \"acb\"\n\nInput: s = \"baaca\", k = 3\nOutput: \"aaabc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef orderlyQueue(s: str, k: int) -> str:\n    if k == 1:\n        n = len(s)\n        ss = s + s\n        lex_min_str = s\n        for i in range(n):\n            lex_min_str = min(lex_min_str, ss[i:i + n])\n        return lex_min_str\n    \n    return \"\".join(sorted(s))\n", "asserts": ["assert orderlyQueue(\"abcd\", 1) == \"abcd\"", "assert orderlyQueue(\"hello\", 2) == \"ehllo\"", "assert orderlyQueue(\"programming\", 1) == \"ammingprogr\"", "assert orderlyQueue(\"rotator\", 1) == \"atorrot\"", "assert orderlyQueue(\"zxyabc\", 5) == \"abcxyz\"", "assert orderlyQueue(\"xy\", 2) == \"xy\""]}, {"author": "Calvin", "UUID": "d0ce7430-cfcd-4c69-b161-b3b2a186422c", "question": "Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.\n\nIn other words, return true if one of s1's permutations is the substring of s2.", "examples": "Input: s1 = \"ab\", s2 = \"eidbaooo\"\nOutput: True\n\nInput: s1 = \"ab\", s2 = \"eidboaoo\"\nOutput: False", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef permutation_in_string(s1: str, s2: str) -> bool:\n  window = len(s1)\n  if window > len(s2):\n    return False\n  freq1 = [0]*26\n  freq2 = [0]*26\n  for i in range(window):\n    freq1[ord(s1[i])-ord('a')] += 1\n    freq2[ord(s2[i])-ord('a')] += 1\n\n  matches = 0\n  for i in range(26):\n    if freq1[i] == freq2[i]:\n      matches += 1\n  \n  for l in range(len(s2) - window):\n    if matches == 26:\n      return True\n\n    added = ord(s2[l + window]) - ord('a')\n    freq2[added] += 1\n    if freq1[added] == freq2[added]:\n      matches += 1\n    elif freq1[added] + 1 == freq2[added]:\n      matches -= 1\n\n    removed = ord(s2[l]) - ord('a')\n    freq2[removed] -= 1\n    if freq1[removed] == freq2[removed]:\n      matches += 1\n    elif freq1[removed] == freq2[removed] + 1:\n      matches -= 1\n    \n  return matches == 26\n", "asserts": ["assert permutation_in_string(\"hello\", \"ooollehhhhh\") == True", "assert permutation_in_string(\"abc\", \"ccccbbbbaaaa\") == False", "assert permutation_in_string(\"xyz\", \"zxyopqrstuv\") == True", "assert permutation_in_string(\"xyz\", \"xzygxzyzxyzk\") == True", "assert permutation_in_string(\"a\", \"a\") == True", "assert permutation_in_string(\"adc\", \"dcda\") == True", "assert permutation_in_string(\"pq\", \"qpqqp\") == True", "assert permutation_in_string(\"kitten\", \"sittingkite\") == False", "assert permutation_in_string(\"pq\", \"pqpqr\") == True", "assert permutation_in_string(\"aba\", \"aabaabaa\") == True", "assert permutation_in_string(\"\", \"\") == True  # Edge case: both strings are empty", "assert permutation_in_string(\"longerstring\", \"short\") == False  # s1 is longer than s2", "assert permutation_in_string(\"a\", \"b\") == False  # Single character, no match", "assert permutation_in_string(\"aab\", \"baa\") == True  # s1 is a permutation of s2", "assert permutation_in_string(\"ab\", \"a\") == False  # s2 is shorter than s1", "assert permutation_in_string(\"ba\", \"eidbaooo\") == True  # Same characters as Example 1 but different permutation", "assert permutation_in_string(\"eid\", \"eidbaooo\") == True  # s1 is a prefix of s2", "assert permutation_in_string(\"ooo\", \"eidbaooo\") == True  # s1 is a suffix of s2", "assert permutation_in_string(\"db\", \"eidbaooo\") == True  # s1 is a permutation within s2", "assert permutation_in_string(\"eidoo\", \"eidbaooo\") == False  # s1 is longer than any permutation within s2"]}], "category": "String", "prompt_tokens": 1159, "total_tokens": 1650, "completion_tokens": 491, "completion": "Given a string, write a function to check if it is a permutation of a palindrome. A palindrome is a word or phrase that is the same forwards and backwards. A permutation is a rearrangement of letters. The palindrome does not need to be limited to just dictionary words.\n\n###Code: \n\ndef can_form_palindrome(s: str) -> bool:\n    char_counts = {}\n    for char in s:\n        char_counts[char] = char_counts.get(char, 0) + 1\n\n    odd_count = 0\n    for count in char_counts.values():\n        if count % 2 != 0:\n            odd_count += 1\n            if odd_count > 1:\n                return False\n    return True\n\n###Testcases: \n\nassert can_form_palindrome(\"code\") == False\nassert can_form_palindrome(\"aab\") == True\nassert can_form_palindrome(\"carerac\") == True\nassert can_form_palindrome(\"aabb\") == True\nassert can_form_palindrome(\"aabbh\") == False\nassert can_form_palindrome(\"aabbhh\") == True\nassert can_form_palindrome(\"a\") == True\nassert can_form_palindrome(\"\") == True  # Edge case: empty string\nassert can_form_palindrome(\"abcadcb\") == True # The permutation \"abcba\" is a palindrome\nassert can_form_palindrome(\"racecar\") == True # The string itself is a palindrome\nassert can_form_palindrome(\"tactcoa\") == True # The permutation \"taco cat\" is a palindrome\nassert can_form_palindrome(\"atcocta\") == True # The string itself is a permutation of a palindrome\nassert can_form_palindrome(\"rraacce\") == True # The permutation \"racecar\" is a palindrome\nassert can_form_palindrome(\"abababc\") == False # More than one character has an odd count\nassert can_form_palindrome(\"abbcabb\") == True # The permutation \"babcab\" is a palindrome\nassert can_form_palindrome(\"xyzzyx\") == True # The permutation \"xzyzyx\" is a palindrome\nassert can_form_palindrome(\"xyzyx\") == True # The string itself is a palindrome\nassert can_form_palindrome(\"xyzya\") == False # \"a\" has an odd count, and there's already a middle character\n\n[/Example 3]", "temperature": 0.653}, {"few_shots": [{"author": "Calvin", "UUID": "ac641352-08d5-4950-8993-6a143da92ecf", "question": "You are given a string s and an integer k. You can choose one of the first k letters of s and append it at the end of the string.\n\nReturn the lexicographically smallest string you could have after applying the mentioned step any number of moves.\n", "examples": "Input: s = \"cba\", k = 1\nOutput: \"acb\"\n\nInput: s = \"baaca\", k = 3\nOutput: \"aaabc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef orderlyQueue(s: str, k: int) -> str:\n    if k == 1:\n        n = len(s)\n        ss = s + s\n        lex_min_str = s\n        for i in range(n):\n            lex_min_str = min(lex_min_str, ss[i:i + n])\n        return lex_min_str\n    \n    return \"\".join(sorted(s))\n", "asserts": ["assert orderlyQueue(\"abcd\", 1) == \"abcd\"", "assert orderlyQueue(\"hello\", 2) == \"ehllo\"", "assert orderlyQueue(\"programming\", 1) == \"ammingprogr\"", "assert orderlyQueue(\"rotator\", 1) == \"atorrot\"", "assert orderlyQueue(\"zxyabc\", 5) == \"abcxyz\"", "assert orderlyQueue(\"xy\", 2) == \"xy\""]}, {"author": "Calvin", "UUID": "d0ce7430-cfcd-4c69-b161-b3b2a186422c", "question": "Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.\n\nIn other words, return true if one of s1's permutations is the substring of s2.", "examples": "Input: s1 = \"ab\", s2 = \"eidbaooo\"\nOutput: True\n\nInput: s1 = \"ab\", s2 = \"eidboaoo\"\nOutput: False", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef permutation_in_string(s1: str, s2: str) -> bool:\n  window = len(s1)\n  if window > len(s2):\n    return False\n  freq1 = [0]*26\n  freq2 = [0]*26\n  for i in range(window):\n    freq1[ord(s1[i])-ord('a')] += 1\n    freq2[ord(s2[i])-ord('a')] += 1\n\n  matches = 0\n  for i in range(26):\n    if freq1[i] == freq2[i]:\n      matches += 1\n  \n  for l in range(len(s2) - window):\n    if matches == 26:\n      return True\n\n    added = ord(s2[l + window]) - ord('a')\n    freq2[added] += 1\n    if freq1[added] == freq2[added]:\n      matches += 1\n    elif freq1[added] + 1 == freq2[added]:\n      matches -= 1\n\n    removed = ord(s2[l]) - ord('a')\n    freq2[removed] -= 1\n    if freq1[removed] == freq2[removed]:\n      matches += 1\n    elif freq1[removed] == freq2[removed] + 1:\n      matches -= 1\n    \n  return matches == 26\n", "asserts": ["assert permutation_in_string(\"hello\", \"ooollehhhhh\") == True", "assert permutation_in_string(\"abc\", \"ccccbbbbaaaa\") == False", "assert permutation_in_string(\"xyz\", \"zxyopqrstuv\") == True", "assert permutation_in_string(\"xyz\", \"xzygxzyzxyzk\") == True", "assert permutation_in_string(\"a\", \"a\") == True", "assert permutation_in_string(\"adc\", \"dcda\") == True", "assert permutation_in_string(\"pq\", \"qpqqp\") == True", "assert permutation_in_string(\"kitten\", \"sittingkite\") == False", "assert permutation_in_string(\"pq\", \"pqpqr\") == True", "assert permutation_in_string(\"aba\", \"aabaabaa\") == True", "assert permutation_in_string(\"\", \"\") == True  # Edge case: both strings are empty", "assert permutation_in_string(\"longerstring\", \"short\") == False  # s1 is longer than s2", "assert permutation_in_string(\"a\", \"b\") == False  # Single character, no match", "assert permutation_in_string(\"aab\", \"baa\") == True  # s1 is a permutation of s2", "assert permutation_in_string(\"ab\", \"a\") == False  # s2 is shorter than s1", "assert permutation_in_string(\"ba\", \"eidbaooo\") == True  # Same characters as Example 1 but different permutation", "assert permutation_in_string(\"eid\", \"eidbaooo\") == True  # s1 is a prefix of s2", "assert permutation_in_string(\"ooo\", \"eidbaooo\") == True  # s1 is a suffix of s2", "assert permutation_in_string(\"db\", \"eidbaooo\") == True  # s1 is a permutation within s2", "assert permutation_in_string(\"eidoo\", \"eidbaooo\") == False  # s1 is longer than any permutation within s2"]}], "category": "String", "prompt_tokens": 1159, "total_tokens": 1462, "completion_tokens": 303, "completion": "Create a function that takes a string and returns a new string with its first and last characters swapped, except when:\n\n- The length of the string is less than two, in which case, return the original string.\n- The string is empty, return an empty string.\n\n###Code: \n\n```python\ndef swap_end_chars(s: str) -> str:\n    if len(s) < 2:\n        return s\n    return s[-1] + s[1:-1] + s[0]\n```\n\n###Testcases: \n\n```python\nassert swap_end_chars(\"hello\") == \"oellh\"\nassert swap_end_chars(\"a\") == \"a\"\nassert swap_end_chars(\"ab\") == \"ba\"\nassert swap_end_chars(\"\") == \"\"\nassert swap_end_chars(\"it\") == \"ti\"\nassert swap_end_chars(\"sweep\") == \"pwees\"\nassert swap_end_chars(\"Python\") == \"nythoP\"\nassert swap_end_chars(\"12345\") == \"52341\"\nassert swap_end_chars(\"xy\") == \"yx\"\nassert swap_end_chars(\"coding\") == \"gondic\"\nassert swap_end_chars(\"x\") == \"x\"\nassert swap_end_chars(\"stronger\") == \"rtronges\"\nassert swap_end_chars(\"algorithm\") == \"mlgoritha\"\nassert swap_end_chars(\"example\") == \"exampel\"\nassert swap_end_chars(\"switch\") == \"hwtcis\"\n```\n\n[/Example 3]", "temperature": 0.657}, {"few_shots": [{"author": "Calvin", "UUID": "ac641352-08d5-4950-8993-6a143da92ecf", "question": "You are given a string s and an integer k. You can choose one of the first k letters of s and append it at the end of the string.\n\nReturn the lexicographically smallest string you could have after applying the mentioned step any number of moves.\n", "examples": "Input: s = \"cba\", k = 1\nOutput: \"acb\"\n\nInput: s = \"baaca\", k = 3\nOutput: \"aaabc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef orderlyQueue(s: str, k: int) -> str:\n    if k == 1:\n        n = len(s)\n        ss = s + s\n        lex_min_str = s\n        for i in range(n):\n            lex_min_str = min(lex_min_str, ss[i:i + n])\n        return lex_min_str\n    \n    return \"\".join(sorted(s))\n", "asserts": ["assert orderlyQueue(\"abcd\", 1) == \"abcd\"", "assert orderlyQueue(\"hello\", 2) == \"ehllo\"", "assert orderlyQueue(\"programming\", 1) == \"ammingprogr\"", "assert orderlyQueue(\"rotator\", 1) == \"atorrot\"", "assert orderlyQueue(\"zxyabc\", 5) == \"abcxyz\"", "assert orderlyQueue(\"xy\", 2) == \"xy\""]}, {"author": "Calvin", "UUID": "d0ce7430-cfcd-4c69-b161-b3b2a186422c", "question": "Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.\n\nIn other words, return true if one of s1's permutations is the substring of s2.", "examples": "Input: s1 = \"ab\", s2 = \"eidbaooo\"\nOutput: True\n\nInput: s1 = \"ab\", s2 = \"eidboaoo\"\nOutput: False", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef permutation_in_string(s1: str, s2: str) -> bool:\n  window = len(s1)\n  if window > len(s2):\n    return False\n  freq1 = [0]*26\n  freq2 = [0]*26\n  for i in range(window):\n    freq1[ord(s1[i])-ord('a')] += 1\n    freq2[ord(s2[i])-ord('a')] += 1\n\n  matches = 0\n  for i in range(26):\n    if freq1[i] == freq2[i]:\n      matches += 1\n  \n  for l in range(len(s2) - window):\n    if matches == 26:\n      return True\n\n    added = ord(s2[l + window]) - ord('a')\n    freq2[added] += 1\n    if freq1[added] == freq2[added]:\n      matches += 1\n    elif freq1[added] + 1 == freq2[added]:\n      matches -= 1\n\n    removed = ord(s2[l]) - ord('a')\n    freq2[removed] -= 1\n    if freq1[removed] == freq2[removed]:\n      matches += 1\n    elif freq1[removed] == freq2[removed] + 1:\n      matches -= 1\n    \n  return matches == 26\n", "asserts": ["assert permutation_in_string(\"hello\", \"ooollehhhhh\") == True", "assert permutation_in_string(\"abc\", \"ccccbbbbaaaa\") == False", "assert permutation_in_string(\"xyz\", \"zxyopqrstuv\") == True", "assert permutation_in_string(\"xyz\", \"xzygxzyzxyzk\") == True", "assert permutation_in_string(\"a\", \"a\") == True", "assert permutation_in_string(\"adc\", \"dcda\") == True", "assert permutation_in_string(\"pq\", \"qpqqp\") == True", "assert permutation_in_string(\"kitten\", \"sittingkite\") == False", "assert permutation_in_string(\"pq\", \"pqpqr\") == True", "assert permutation_in_string(\"aba\", \"aabaabaa\") == True", "assert permutation_in_string(\"\", \"\") == True  # Edge case: both strings are empty", "assert permutation_in_string(\"longerstring\", \"short\") == False  # s1 is longer than s2", "assert permutation_in_string(\"a\", \"b\") == False  # Single character, no match", "assert permutation_in_string(\"aab\", \"baa\") == True  # s1 is a permutation of s2", "assert permutation_in_string(\"ab\", \"a\") == False  # s2 is shorter than s1", "assert permutation_in_string(\"ba\", \"eidbaooo\") == True  # Same characters as Example 1 but different permutation", "assert permutation_in_string(\"eid\", \"eidbaooo\") == True  # s1 is a prefix of s2", "assert permutation_in_string(\"ooo\", \"eidbaooo\") == True  # s1 is a suffix of s2", "assert permutation_in_string(\"db\", \"eidbaooo\") == True  # s1 is a permutation within s2", "assert permutation_in_string(\"eidoo\", \"eidbaooo\") == False  # s1 is longer than any permutation within s2"]}], "category": "String", "prompt_tokens": 1159, "total_tokens": 1563, "completion_tokens": 404, "completion": "Write a function that takes a string s and returns the length of the longest substring without repeating characters.\n\n###Code: \n\n\ndef length_of_longest_substring(s: str) -> int:\n    char_index_map = {}\n    start = max_length = 0\n    \n    for index, char in enumerate(s):\n        if char in char_index_map and start <= char_index_map[char]:\n            start = char_index_map[char] + 1\n        else:\n            max_length = max(max_length, index - start + 1)\n        \n        char_index_map[char] = index\n\n    return max_length\n\n\n###Testcases: \n\nassert length_of_longest_substring(\"abcabcbb\") == 3\nassert length_of_longest_substring(\"bbbbb\") == 1\nassert length_of_longest_substring(\"pwwkew\") == 3\nassert length_of_longest_substring(\"\") == 0\nassert length_of_longest_substring(\" \") == 1\nassert length_of_longest_substring(\"au\") == 2\nassert length_of_longest_substring(\"dvdf\") == 3\nassert length_of_longest_substring(\"anviaj\") == 5\nassert length_of_longest_substring(\"abba\") == 2\nassert length_of_longest_substring(\"tmmzuxt\") == 5\nassert length_of_longest_substring(\"aabaab!bb\") == 3\nassert length_of_longest_substring(\"nfpdmpi\") == 5\nassert length_of_longest_substring(\"abcd\") == 4\nassert length_of_longest_substring(\"abba\") == 2\nassert length_of_longest_substring(\"aab\") == 2\nassert length_of_longest_substring(\"bziuwnklhqzrxnb\") == 11\nassert length_of_longest_substring(\"ghqwnfenmtpxbbnzox\") == 10\n\n[/Example 3]", "temperature": 0.834}, {"few_shots": [{"author": "Calvin", "UUID": "ac641352-08d5-4950-8993-6a143da92ecf", "question": "You are given a string s and an integer k. You can choose one of the first k letters of s and append it at the end of the string.\n\nReturn the lexicographically smallest string you could have after applying the mentioned step any number of moves.\n", "examples": "Input: s = \"cba\", k = 1\nOutput: \"acb\"\n\nInput: s = \"baaca\", k = 3\nOutput: \"aaabc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef orderlyQueue(s: str, k: int) -> str:\n    if k == 1:\n        n = len(s)\n        ss = s + s\n        lex_min_str = s\n        for i in range(n):\n            lex_min_str = min(lex_min_str, ss[i:i + n])\n        return lex_min_str\n    \n    return \"\".join(sorted(s))\n", "asserts": ["assert orderlyQueue(\"abcd\", 1) == \"abcd\"", "assert orderlyQueue(\"hello\", 2) == \"ehllo\"", "assert orderlyQueue(\"programming\", 1) == \"ammingprogr\"", "assert orderlyQueue(\"rotator\", 1) == \"atorrot\"", "assert orderlyQueue(\"zxyabc\", 5) == \"abcxyz\"", "assert orderlyQueue(\"xy\", 2) == \"xy\""]}, {"author": "Calvin", "UUID": "d0ce7430-cfcd-4c69-b161-b3b2a186422c", "question": "Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.\n\nIn other words, return true if one of s1's permutations is the substring of s2.", "examples": "Input: s1 = \"ab\", s2 = \"eidbaooo\"\nOutput: True\n\nInput: s1 = \"ab\", s2 = \"eidboaoo\"\nOutput: False", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef permutation_in_string(s1: str, s2: str) -> bool:\n  window = len(s1)\n  if window > len(s2):\n    return False\n  freq1 = [0]*26\n  freq2 = [0]*26\n  for i in range(window):\n    freq1[ord(s1[i])-ord('a')] += 1\n    freq2[ord(s2[i])-ord('a')] += 1\n\n  matches = 0\n  for i in range(26):\n    if freq1[i] == freq2[i]:\n      matches += 1\n  \n  for l in range(len(s2) - window):\n    if matches == 26:\n      return True\n\n    added = ord(s2[l + window]) - ord('a')\n    freq2[added] += 1\n    if freq1[added] == freq2[added]:\n      matches += 1\n    elif freq1[added] + 1 == freq2[added]:\n      matches -= 1\n\n    removed = ord(s2[l]) - ord('a')\n    freq2[removed] -= 1\n    if freq1[removed] == freq2[removed]:\n      matches += 1\n    elif freq1[removed] == freq2[removed] + 1:\n      matches -= 1\n    \n  return matches == 26\n", "asserts": ["assert permutation_in_string(\"hello\", \"ooollehhhhh\") == True", "assert permutation_in_string(\"abc\", \"ccccbbbbaaaa\") == False", "assert permutation_in_string(\"xyz\", \"zxyopqrstuv\") == True", "assert permutation_in_string(\"xyz\", \"xzygxzyzxyzk\") == True", "assert permutation_in_string(\"a\", \"a\") == True", "assert permutation_in_string(\"adc\", \"dcda\") == True", "assert permutation_in_string(\"pq\", \"qpqqp\") == True", "assert permutation_in_string(\"kitten\", \"sittingkite\") == False", "assert permutation_in_string(\"pq\", \"pqpqr\") == True", "assert permutation_in_string(\"aba\", \"aabaabaa\") == True", "assert permutation_in_string(\"\", \"\") == True  # Edge case: both strings are empty", "assert permutation_in_string(\"longerstring\", \"short\") == False  # s1 is longer than s2", "assert permutation_in_string(\"a\", \"b\") == False  # Single character, no match", "assert permutation_in_string(\"aab\", \"baa\") == True  # s1 is a permutation of s2", "assert permutation_in_string(\"ab\", \"a\") == False  # s2 is shorter than s1", "assert permutation_in_string(\"ba\", \"eidbaooo\") == True  # Same characters as Example 1 but different permutation", "assert permutation_in_string(\"eid\", \"eidbaooo\") == True  # s1 is a prefix of s2", "assert permutation_in_string(\"ooo\", \"eidbaooo\") == True  # s1 is a suffix of s2", "assert permutation_in_string(\"db\", \"eidbaooo\") == True  # s1 is a permutation within s2", "assert permutation_in_string(\"eidoo\", \"eidbaooo\") == False  # s1 is longer than any permutation within s2"]}], "category": "String", "prompt_tokens": 1159, "total_tokens": 1449, "completion_tokens": 290, "completion": "Given a string s, find the length of the longest substring without repeating characters.\n\n###Code: \n\n\ndef length_of_longest_substring(s: str) -> int:\n    start = maxLength = 0\n    usedChar = {}\n\n    for i in range(len(s)):\n        if s[i] in usedChar and start <= usedChar[s[i]]:\n            start = usedChar[s[i]] + 1\n        else:\n            maxLength = max(maxLength, i - start + 1)\n\n        usedChar[s[i]] = i\n\n    return maxLength\n\n\n###Testcases: \n\nassert length_of_longest_substring(\"abcabcbb\") == 3\nassert length_of_longest_substring(\"bbbbb\") == 1\nassert length_of_longest_substring(\"pwwkew\") == 3\nassert length_of_longest_substring(\"\") == 0\nassert length_of_longest_substring(\" \") == 1\nassert length_of_longest_substring(\"au\") == 2\nassert length_of_longest_substring(\"dvdf\") == 3\nassert length_of_longest_substring(\"anviaj\") == 5\nassert length_of_longest_substring(\"abba\") == 2\nassert length_of_longest_substring(\"tmmzuxt\") == 5\nassert length_of_longest_substring(\"nfpdmpi\") == 5\n\n[/Example 3]", "temperature": 0.792}, {"few_shots": [{"author": "Calvin", "UUID": "ac641352-08d5-4950-8993-6a143da92ecf", "question": "You are given a string s and an integer k. You can choose one of the first k letters of s and append it at the end of the string.\n\nReturn the lexicographically smallest string you could have after applying the mentioned step any number of moves.\n", "examples": "Input: s = \"cba\", k = 1\nOutput: \"acb\"\n\nInput: s = \"baaca\", k = 3\nOutput: \"aaabc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef orderlyQueue(s: str, k: int) -> str:\n    if k == 1:\n        n = len(s)\n        ss = s + s\n        lex_min_str = s\n        for i in range(n):\n            lex_min_str = min(lex_min_str, ss[i:i + n])\n        return lex_min_str\n    \n    return \"\".join(sorted(s))\n", "asserts": ["assert orderlyQueue(\"abcd\", 1) == \"abcd\"", "assert orderlyQueue(\"hello\", 2) == \"ehllo\"", "assert orderlyQueue(\"programming\", 1) == \"ammingprogr\"", "assert orderlyQueue(\"rotator\", 1) == \"atorrot\"", "assert orderlyQueue(\"zxyabc\", 5) == \"abcxyz\"", "assert orderlyQueue(\"xy\", 2) == \"xy\""]}, {"author": "Calvin", "UUID": "d0ce7430-cfcd-4c69-b161-b3b2a186422c", "question": "Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.\n\nIn other words, return true if one of s1's permutations is the substring of s2.", "examples": "Input: s1 = \"ab\", s2 = \"eidbaooo\"\nOutput: True\n\nInput: s1 = \"ab\", s2 = \"eidboaoo\"\nOutput: False", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef permutation_in_string(s1: str, s2: str) -> bool:\n  window = len(s1)\n  if window > len(s2):\n    return False\n  freq1 = [0]*26\n  freq2 = [0]*26\n  for i in range(window):\n    freq1[ord(s1[i])-ord('a')] += 1\n    freq2[ord(s2[i])-ord('a')] += 1\n\n  matches = 0\n  for i in range(26):\n    if freq1[i] == freq2[i]:\n      matches += 1\n  \n  for l in range(len(s2) - window):\n    if matches == 26:\n      return True\n\n    added = ord(s2[l + window]) - ord('a')\n    freq2[added] += 1\n    if freq1[added] == freq2[added]:\n      matches += 1\n    elif freq1[added] + 1 == freq2[added]:\n      matches -= 1\n\n    removed = ord(s2[l]) - ord('a')\n    freq2[removed] -= 1\n    if freq1[removed] == freq2[removed]:\n      matches += 1\n    elif freq1[removed] == freq2[removed] + 1:\n      matches -= 1\n    \n  return matches == 26\n", "asserts": ["assert permutation_in_string(\"hello\", \"ooollehhhhh\") == True", "assert permutation_in_string(\"abc\", \"ccccbbbbaaaa\") == False", "assert permutation_in_string(\"xyz\", \"zxyopqrstuv\") == True", "assert permutation_in_string(\"xyz\", \"xzygxzyzxyzk\") == True", "assert permutation_in_string(\"a\", \"a\") == True", "assert permutation_in_string(\"adc\", \"dcda\") == True", "assert permutation_in_string(\"pq\", \"qpqqp\") == True", "assert permutation_in_string(\"kitten\", \"sittingkite\") == False", "assert permutation_in_string(\"pq\", \"pqpqr\") == True", "assert permutation_in_string(\"aba\", \"aabaabaa\") == True", "assert permutation_in_string(\"\", \"\") == True  # Edge case: both strings are empty", "assert permutation_in_string(\"longerstring\", \"short\") == False  # s1 is longer than s2", "assert permutation_in_string(\"a\", \"b\") == False  # Single character, no match", "assert permutation_in_string(\"aab\", \"baa\") == True  # s1 is a permutation of s2", "assert permutation_in_string(\"ab\", \"a\") == False  # s2 is shorter than s1", "assert permutation_in_string(\"ba\", \"eidbaooo\") == True  # Same characters as Example 1 but different permutation", "assert permutation_in_string(\"eid\", \"eidbaooo\") == True  # s1 is a prefix of s2", "assert permutation_in_string(\"ooo\", \"eidbaooo\") == True  # s1 is a suffix of s2", "assert permutation_in_string(\"db\", \"eidbaooo\") == True  # s1 is a permutation within s2", "assert permutation_in_string(\"eidoo\", \"eidbaooo\") == False  # s1 is longer than any permutation within s2"]}], "category": "String", "prompt_tokens": 1159, "total_tokens": 1483, "completion_tokens": 324, "completion": "Given a string s, return the first non-repeating character in it and return its index. If it does not exist, return -1.\n\n###Code: \n\n```python\ndef firstUniqChar(s: str) -> int:\n    frequency = {}\n    for char in s:\n        frequency[char] = frequency.get(char, 0) + 1\n\n    for index, char in enumerate(s):\n        if frequency[char] == 1:\n            return index\n\n    return -1\n```\n\n###Testcases: \n\n```python\nassert firstUniqChar(\"leetcode\") == 0\nassert firstUniqChar(\"loveleetcode\") == 2\nassert firstUniqChar(\"aabb\") == -1\nassert firstUniqChar(\"z\") == 0\nassert firstUniqChar(\"aadadaad\") == -1\nassert firstUniqChar(\"aaabcccdeeef\") == 11\nassert firstUniqChar(\"abcabd\") == 4\nassert firstUniqChar(\"\") == -1  # Edge case: empty string\nassert firstUniqChar(\"llama\") == 1\nassert firstUniqChar(\"google\") == 4\nassert firstUniqChar(\"upup\") == -1\nassert firstUniqChar(\"character\") == 0\nassert firstUniqChar(\"repeat\") == 4\nassert firstUniqChar(\"single\") == 0  # Only one character is non-repeating\nassert firstUniqChar(\"obstacle\") == 5\n```\n\n[/Example 3]", "temperature": 0.894}, {"few_shots": [{"author": "Calvin", "UUID": "ac641352-08d5-4950-8993-6a143da92ecf", "question": "You are given a string s and an integer k. You can choose one of the first k letters of s and append it at the end of the string.\n\nReturn the lexicographically smallest string you could have after applying the mentioned step any number of moves.\n", "examples": "Input: s = \"cba\", k = 1\nOutput: \"acb\"\n\nInput: s = \"baaca\", k = 3\nOutput: \"aaabc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef orderlyQueue(s: str, k: int) -> str:\n    if k == 1:\n        n = len(s)\n        ss = s + s\n        lex_min_str = s\n        for i in range(n):\n            lex_min_str = min(lex_min_str, ss[i:i + n])\n        return lex_min_str\n    \n    return \"\".join(sorted(s))\n", "asserts": ["assert orderlyQueue(\"abcd\", 1) == \"abcd\"", "assert orderlyQueue(\"hello\", 2) == \"ehllo\"", "assert orderlyQueue(\"programming\", 1) == \"ammingprogr\"", "assert orderlyQueue(\"rotator\", 1) == \"atorrot\"", "assert orderlyQueue(\"zxyabc\", 5) == \"abcxyz\"", "assert orderlyQueue(\"xy\", 2) == \"xy\""]}, {"author": "Calvin", "UUID": "d0ce7430-cfcd-4c69-b161-b3b2a186422c", "question": "Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.\n\nIn other words, return true if one of s1's permutations is the substring of s2.", "examples": "Input: s1 = \"ab\", s2 = \"eidbaooo\"\nOutput: True\n\nInput: s1 = \"ab\", s2 = \"eidboaoo\"\nOutput: False", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef permutation_in_string(s1: str, s2: str) -> bool:\n  window = len(s1)\n  if window > len(s2):\n    return False\n  freq1 = [0]*26\n  freq2 = [0]*26\n  for i in range(window):\n    freq1[ord(s1[i])-ord('a')] += 1\n    freq2[ord(s2[i])-ord('a')] += 1\n\n  matches = 0\n  for i in range(26):\n    if freq1[i] == freq2[i]:\n      matches += 1\n  \n  for l in range(len(s2) - window):\n    if matches == 26:\n      return True\n\n    added = ord(s2[l + window]) - ord('a')\n    freq2[added] += 1\n    if freq1[added] == freq2[added]:\n      matches += 1\n    elif freq1[added] + 1 == freq2[added]:\n      matches -= 1\n\n    removed = ord(s2[l]) - ord('a')\n    freq2[removed] -= 1\n    if freq1[removed] == freq2[removed]:\n      matches += 1\n    elif freq1[removed] == freq2[removed] + 1:\n      matches -= 1\n    \n  return matches == 26\n", "asserts": ["assert permutation_in_string(\"hello\", \"ooollehhhhh\") == True", "assert permutation_in_string(\"abc\", \"ccccbbbbaaaa\") == False", "assert permutation_in_string(\"xyz\", \"zxyopqrstuv\") == True", "assert permutation_in_string(\"xyz\", \"xzygxzyzxyzk\") == True", "assert permutation_in_string(\"a\", \"a\") == True", "assert permutation_in_string(\"adc\", \"dcda\") == True", "assert permutation_in_string(\"pq\", \"qpqqp\") == True", "assert permutation_in_string(\"kitten\", \"sittingkite\") == False", "assert permutation_in_string(\"pq\", \"pqpqr\") == True", "assert permutation_in_string(\"aba\", \"aabaabaa\") == True", "assert permutation_in_string(\"\", \"\") == True  # Edge case: both strings are empty", "assert permutation_in_string(\"longerstring\", \"short\") == False  # s1 is longer than s2", "assert permutation_in_string(\"a\", \"b\") == False  # Single character, no match", "assert permutation_in_string(\"aab\", \"baa\") == True  # s1 is a permutation of s2", "assert permutation_in_string(\"ab\", \"a\") == False  # s2 is shorter than s1", "assert permutation_in_string(\"ba\", \"eidbaooo\") == True  # Same characters as Example 1 but different permutation", "assert permutation_in_string(\"eid\", \"eidbaooo\") == True  # s1 is a prefix of s2", "assert permutation_in_string(\"ooo\", \"eidbaooo\") == True  # s1 is a suffix of s2", "assert permutation_in_string(\"db\", \"eidbaooo\") == True  # s1 is a permutation within s2", "assert permutation_in_string(\"eidoo\", \"eidbaooo\") == False  # s1 is longer than any permutation within s2"]}], "category": "String", "prompt_tokens": 1159, "total_tokens": 1636, "completion_tokens": 477, "completion": "Given a string s, find out if the string is a palindrome or not. A string is a palindrome if it reads the same backward as forward. Ignore cases and any non-alphanumeric characters while checking for palindrome.\n\nReturn true if the string is a palindrome; otherwise, return false.\n\n###Code: \n\n```python\nimport re\n\ndef is_palindrome(s: str) -> bool:\n    # Remove non-alphanumeric characters and convert to lower case\n    clean_s = re.sub(r'[^a-zA-Z0-9]', '', s).lower()\n    # Compare the cleaned string with its reverse\n    return clean_s == clean_s[::-1]\n\n###Testcases: \n\nassert is_palindrome(\"A man, a plan, a canal: Panama\") == True\nassert is_palindrome(\"race a car\") == False\nassert is_palindrome(\" \") == True  # Edge case: empty string after cleaning\nassert is_palindrome(\"0P\") == False  # Case and non-alphanumeric characters\nassert is_palindrome(\"ab_a\") == True  # Underscores are not alphanumeric\nassert is_palindrome(\"1b1\") == True  # Numbers are alphanumeric\nassert is_palindrome(\"No lemon, no melon\") == True\nassert is_palindrome(\"Was it a car or a cat I saw?\") == True\nassert is_palindrome(\"No 'x' in Nixon\") == True\nassert is_palindrome(\"!@#$%^&*()_+\") == True  # Special characters only, empty after cleaning\nassert is_palindrome(\"Madam, in Eden, I'm Adam.\") == True\nassert is_palindrome(\"Never odd or even.\") == True\nassert is_palindrome(\"Do geese see God?\") == True\nassert is_palindrome(\"Able was I, ere I saw Elba.\") == True\nassert is_palindrome(\"Step on no pets.\") == True\nassert is_palindrome(\"Eva, can I see bees in a cave?\") == True\nassert is_palindrome(\"Mr. Owl ate my metal worm\") == True\nassert is_palindrome(\"A Santa at NASA\") == True\nassert is_palindrome(\"123454321\") == True  # Numeric palindrome\nassert is_palindrome(\"1a2\") == False\n```\n\n[/Example 3]", "temperature": 0.656}, {"few_shots": [{"author": "Calvin", "UUID": "ac641352-08d5-4950-8993-6a143da92ecf", "question": "You are given a string s and an integer k. You can choose one of the first k letters of s and append it at the end of the string.\n\nReturn the lexicographically smallest string you could have after applying the mentioned step any number of moves.\n", "examples": "Input: s = \"cba\", k = 1\nOutput: \"acb\"\n\nInput: s = \"baaca\", k = 3\nOutput: \"aaabc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef orderlyQueue(s: str, k: int) -> str:\n    if k == 1:\n        n = len(s)\n        ss = s + s\n        lex_min_str = s\n        for i in range(n):\n            lex_min_str = min(lex_min_str, ss[i:i + n])\n        return lex_min_str\n    \n    return \"\".join(sorted(s))\n", "asserts": ["assert orderlyQueue(\"abcd\", 1) == \"abcd\"", "assert orderlyQueue(\"hello\", 2) == \"ehllo\"", "assert orderlyQueue(\"programming\", 1) == \"ammingprogr\"", "assert orderlyQueue(\"rotator\", 1) == \"atorrot\"", "assert orderlyQueue(\"zxyabc\", 5) == \"abcxyz\"", "assert orderlyQueue(\"xy\", 2) == \"xy\""]}, {"author": "Calvin", "UUID": "d0ce7430-cfcd-4c69-b161-b3b2a186422c", "question": "Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.\n\nIn other words, return true if one of s1's permutations is the substring of s2.", "examples": "Input: s1 = \"ab\", s2 = \"eidbaooo\"\nOutput: True\n\nInput: s1 = \"ab\", s2 = \"eidboaoo\"\nOutput: False", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef permutation_in_string(s1: str, s2: str) -> bool:\n  window = len(s1)\n  if window > len(s2):\n    return False\n  freq1 = [0]*26\n  freq2 = [0]*26\n  for i in range(window):\n    freq1[ord(s1[i])-ord('a')] += 1\n    freq2[ord(s2[i])-ord('a')] += 1\n\n  matches = 0\n  for i in range(26):\n    if freq1[i] == freq2[i]:\n      matches += 1\n  \n  for l in range(len(s2) - window):\n    if matches == 26:\n      return True\n\n    added = ord(s2[l + window]) - ord('a')\n    freq2[added] += 1\n    if freq1[added] == freq2[added]:\n      matches += 1\n    elif freq1[added] + 1 == freq2[added]:\n      matches -= 1\n\n    removed = ord(s2[l]) - ord('a')\n    freq2[removed] -= 1\n    if freq1[removed] == freq2[removed]:\n      matches += 1\n    elif freq1[removed] == freq2[removed] + 1:\n      matches -= 1\n    \n  return matches == 26\n", "asserts": ["assert permutation_in_string(\"hello\", \"ooollehhhhh\") == True", "assert permutation_in_string(\"abc\", \"ccccbbbbaaaa\") == False", "assert permutation_in_string(\"xyz\", \"zxyopqrstuv\") == True", "assert permutation_in_string(\"xyz\", \"xzygxzyzxyzk\") == True", "assert permutation_in_string(\"a\", \"a\") == True", "assert permutation_in_string(\"adc\", \"dcda\") == True", "assert permutation_in_string(\"pq\", \"qpqqp\") == True", "assert permutation_in_string(\"kitten\", \"sittingkite\") == False", "assert permutation_in_string(\"pq\", \"pqpqr\") == True", "assert permutation_in_string(\"aba\", \"aabaabaa\") == True", "assert permutation_in_string(\"\", \"\") == True  # Edge case: both strings are empty", "assert permutation_in_string(\"longerstring\", \"short\") == False  # s1 is longer than s2", "assert permutation_in_string(\"a\", \"b\") == False  # Single character, no match", "assert permutation_in_string(\"aab\", \"baa\") == True  # s1 is a permutation of s2", "assert permutation_in_string(\"ab\", \"a\") == False  # s2 is shorter than s1", "assert permutation_in_string(\"ba\", \"eidbaooo\") == True  # Same characters as Example 1 but different permutation", "assert permutation_in_string(\"eid\", \"eidbaooo\") == True  # s1 is a prefix of s2", "assert permutation_in_string(\"ooo\", \"eidbaooo\") == True  # s1 is a suffix of s2", "assert permutation_in_string(\"db\", \"eidbaooo\") == True  # s1 is a permutation within s2", "assert permutation_in_string(\"eidoo\", \"eidbaooo\") == False  # s1 is longer than any permutation within s2"]}], "category": "String", "prompt_tokens": 1159, "total_tokens": 1679, "completion_tokens": 520, "completion": "Write a function `compressString` that takes a string as input and replaces consecutive repeating characters with the character followed by the count of repetitions. If the \"compressed\" string would not become smaller than the original string, your function should return the original string.\n\n###Code:\n\n```python\ndef compressString(s: str) -> str:\n    result = []\n    i = 0\n    while i < len(s):\n        char = s[i]\n        count = 1\n        while i + 1 < len(s) and s[i + 1] == char:\n            i += 1\n            count += 1\n        result.append(char + (str(count) if count > 1 else ''))\n        i += 1\n    compressed = ''.join(result)\n    return compressed if len(compressed) < len(s) else s\n```\n\n###Testcases:\n\n```python\nassert compressString(\"aabcccccaaa\") == \"a2bc5a3\"\nassert compressString(\"abcdef\") == \"abcdef\"\nassert compressString(\"aabbcc\") == \"aabbcc\"\nassert compressString(\"aaabbbcccddd\") == \"a3b3c3d3\"\nassert compressString(\"aaaaaaaaaa\") == \"a10\"\nassert compressString(\"abcaaabbb\") == \"abca3b3\"\nassert compressString(\"abcd\") == \"abcd\"\nassert compressString(\"a\") == \"a\"\nassert compressString(\"\") == \"\"  # Edge case: empty string\nassert compressString(\"aa\") == \"aa\"  # Edge case: string becomes equal in length when compressed\nassert compressString(\"aaa\") == \"a3\"  # String actually gets compressed\nassert compressString(\"aaAAaa\") == \"aaAAaa\"  # Case sensitive: uppercase and lowercase are considered different characters\nassert compressString(\"abbbcccdde\") == \"ab3c3d2e\"\nassert compressString(\"zzzzykkkdpppppppp\") == \"z4y1k3d1p9\"\nassert compressString(\"rrrrrTttttttt\") == \"r5T1t8\"\nassert compressString(\"hhhhhhhhhhhhhhh\") == \"h15\"\nassert compressString(\"qweeeeerty\") == \"qwe5rty\"\nassert compressString(\"aabbaabb\") == \"aabbaabb\"  # Should not compress to \"a2b2a2b2\" which is longer\n```\n\n[/Example 3]", "temperature": 0.744}, {"few_shots": [{"author": "Calvin", "UUID": "ac641352-08d5-4950-8993-6a143da92ecf", "question": "You are given a string s and an integer k. You can choose one of the first k letters of s and append it at the end of the string.\n\nReturn the lexicographically smallest string you could have after applying the mentioned step any number of moves.\n", "examples": "Input: s = \"cba\", k = 1\nOutput: \"acb\"\n\nInput: s = \"baaca\", k = 3\nOutput: \"aaabc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef orderlyQueue(s: str, k: int) -> str:\n    if k == 1:\n        n = len(s)\n        ss = s + s\n        lex_min_str = s\n        for i in range(n):\n            lex_min_str = min(lex_min_str, ss[i:i + n])\n        return lex_min_str\n    \n    return \"\".join(sorted(s))\n", "asserts": ["assert orderlyQueue(\"abcd\", 1) == \"abcd\"", "assert orderlyQueue(\"hello\", 2) == \"ehllo\"", "assert orderlyQueue(\"programming\", 1) == \"ammingprogr\"", "assert orderlyQueue(\"rotator\", 1) == \"atorrot\"", "assert orderlyQueue(\"zxyabc\", 5) == \"abcxyz\"", "assert orderlyQueue(\"xy\", 2) == \"xy\""]}, {"author": "Calvin", "UUID": "d0ce7430-cfcd-4c69-b161-b3b2a186422c", "question": "Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.\n\nIn other words, return true if one of s1's permutations is the substring of s2.", "examples": "Input: s1 = \"ab\", s2 = \"eidbaooo\"\nOutput: True\n\nInput: s1 = \"ab\", s2 = \"eidboaoo\"\nOutput: False", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef permutation_in_string(s1: str, s2: str) -> bool:\n  window = len(s1)\n  if window > len(s2):\n    return False\n  freq1 = [0]*26\n  freq2 = [0]*26\n  for i in range(window):\n    freq1[ord(s1[i])-ord('a')] += 1\n    freq2[ord(s2[i])-ord('a')] += 1\n\n  matches = 0\n  for i in range(26):\n    if freq1[i] == freq2[i]:\n      matches += 1\n  \n  for l in range(len(s2) - window):\n    if matches == 26:\n      return True\n\n    added = ord(s2[l + window]) - ord('a')\n    freq2[added] += 1\n    if freq1[added] == freq2[added]:\n      matches += 1\n    elif freq1[added] + 1 == freq2[added]:\n      matches -= 1\n\n    removed = ord(s2[l]) - ord('a')\n    freq2[removed] -= 1\n    if freq1[removed] == freq2[removed]:\n      matches += 1\n    elif freq1[removed] == freq2[removed] + 1:\n      matches -= 1\n    \n  return matches == 26\n", "asserts": ["assert permutation_in_string(\"hello\", \"ooollehhhhh\") == True", "assert permutation_in_string(\"abc\", \"ccccbbbbaaaa\") == False", "assert permutation_in_string(\"xyz\", \"zxyopqrstuv\") == True", "assert permutation_in_string(\"xyz\", \"xzygxzyzxyzk\") == True", "assert permutation_in_string(\"a\", \"a\") == True", "assert permutation_in_string(\"adc\", \"dcda\") == True", "assert permutation_in_string(\"pq\", \"qpqqp\") == True", "assert permutation_in_string(\"kitten\", \"sittingkite\") == False", "assert permutation_in_string(\"pq\", \"pqpqr\") == True", "assert permutation_in_string(\"aba\", \"aabaabaa\") == True", "assert permutation_in_string(\"\", \"\") == True  # Edge case: both strings are empty", "assert permutation_in_string(\"longerstring\", \"short\") == False  # s1 is longer than s2", "assert permutation_in_string(\"a\", \"b\") == False  # Single character, no match", "assert permutation_in_string(\"aab\", \"baa\") == True  # s1 is a permutation of s2", "assert permutation_in_string(\"ab\", \"a\") == False  # s2 is shorter than s1", "assert permutation_in_string(\"ba\", \"eidbaooo\") == True  # Same characters as Example 1 but different permutation", "assert permutation_in_string(\"eid\", \"eidbaooo\") == True  # s1 is a prefix of s2", "assert permutation_in_string(\"ooo\", \"eidbaooo\") == True  # s1 is a suffix of s2", "assert permutation_in_string(\"db\", \"eidbaooo\") == True  # s1 is a permutation within s2", "assert permutation_in_string(\"eidoo\", \"eidbaooo\") == False  # s1 is longer than any permutation within s2"]}], "category": "String", "prompt_tokens": 1159, "total_tokens": 1545, "completion_tokens": 386, "completion": "Given a string containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.\n\nAn input string is valid if:\n\n1. Open brackets must be closed by the same type of brackets.\n2. Open brackets must be closed in the correct order.\n\n###Code: \n\n\ndef isValid(s: str) -> bool:\n    stack = []\n    mapping = {\")\": \"(\", \"}\": \"{\", \"]\": \"[\"}\n    \n    for char in s:\n        if char in mapping:\n            top_element = stack.pop() if stack else '#'\n            if mapping[char] != top_element:\n                return False\n        else:\n            stack.append(char)\n    \n    return not stack\n\n\n###Testcases: \n\nassert isValid(\"()\") == True\nassert isValid(\"()[]{}\") == True\nassert isValid(\"{[]}\") == True\nassert isValid(\"(]\") == False\nassert isValid(\"([)]\") == False\nassert isValid(\"{[()]}\") == True\nassert isValid(\"\") == True  # Edge case: empty string\nassert isValid(\"]\") == False  # Unmatched closing bracket\nassert isValid(\"[\") == False  # Unmatched opening bracket\nassert isValid(\"({{{{}}}))\") == False  # Incorrect order\nassert isValid(\"(((((())))))\") == True  # Correctly nested\nassert isValid(\"()()()()\") == True  # Repeated patterns\nassert isValid(\"({[]})\") == True  # Mixed types\nassert isValid(\"({[)])\") == False  # Mixed types with incorrect order\nassert isValid(\"((()))()\") == True  # Correct order and type\nassert isValid(\"{{{{{{\") == False  # Only opening brackets\nassert isValid(\"}}}}}}\") == False  # Only closing brackets\nassert isValid(\"({)}\") == False  # Correct types but wrong order\n\n[/Example 3]", "temperature": 0.736}, {"few_shots": [{"author": "Calvin", "UUID": "ac641352-08d5-4950-8993-6a143da92ecf", "question": "You are given a string s and an integer k. You can choose one of the first k letters of s and append it at the end of the string.\n\nReturn the lexicographically smallest string you could have after applying the mentioned step any number of moves.\n", "examples": "Input: s = \"cba\", k = 1\nOutput: \"acb\"\n\nInput: s = \"baaca\", k = 3\nOutput: \"aaabc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef orderlyQueue(s: str, k: int) -> str:\n    if k == 1:\n        n = len(s)\n        ss = s + s\n        lex_min_str = s\n        for i in range(n):\n            lex_min_str = min(lex_min_str, ss[i:i + n])\n        return lex_min_str\n    \n    return \"\".join(sorted(s))\n", "asserts": ["assert orderlyQueue(\"abcd\", 1) == \"abcd\"", "assert orderlyQueue(\"hello\", 2) == \"ehllo\"", "assert orderlyQueue(\"programming\", 1) == \"ammingprogr\"", "assert orderlyQueue(\"rotator\", 1) == \"atorrot\"", "assert orderlyQueue(\"zxyabc\", 5) == \"abcxyz\"", "assert orderlyQueue(\"xy\", 2) == \"xy\""]}, {"author": "Calvin", "UUID": "d0ce7430-cfcd-4c69-b161-b3b2a186422c", "question": "Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.\n\nIn other words, return true if one of s1's permutations is the substring of s2.", "examples": "Input: s1 = \"ab\", s2 = \"eidbaooo\"\nOutput: True\n\nInput: s1 = \"ab\", s2 = \"eidboaoo\"\nOutput: False", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef permutation_in_string(s1: str, s2: str) -> bool:\n  window = len(s1)\n  if window > len(s2):\n    return False\n  freq1 = [0]*26\n  freq2 = [0]*26\n  for i in range(window):\n    freq1[ord(s1[i])-ord('a')] += 1\n    freq2[ord(s2[i])-ord('a')] += 1\n\n  matches = 0\n  for i in range(26):\n    if freq1[i] == freq2[i]:\n      matches += 1\n  \n  for l in range(len(s2) - window):\n    if matches == 26:\n      return True\n\n    added = ord(s2[l + window]) - ord('a')\n    freq2[added] += 1\n    if freq1[added] == freq2[added]:\n      matches += 1\n    elif freq1[added] + 1 == freq2[added]:\n      matches -= 1\n\n    removed = ord(s2[l]) - ord('a')\n    freq2[removed] -= 1\n    if freq1[removed] == freq2[removed]:\n      matches += 1\n    elif freq1[removed] == freq2[removed] + 1:\n      matches -= 1\n    \n  return matches == 26\n", "asserts": ["assert permutation_in_string(\"hello\", \"ooollehhhhh\") == True", "assert permutation_in_string(\"abc\", \"ccccbbbbaaaa\") == False", "assert permutation_in_string(\"xyz\", \"zxyopqrstuv\") == True", "assert permutation_in_string(\"xyz\", \"xzygxzyzxyzk\") == True", "assert permutation_in_string(\"a\", \"a\") == True", "assert permutation_in_string(\"adc\", \"dcda\") == True", "assert permutation_in_string(\"pq\", \"qpqqp\") == True", "assert permutation_in_string(\"kitten\", \"sittingkite\") == False", "assert permutation_in_string(\"pq\", \"pqpqr\") == True", "assert permutation_in_string(\"aba\", \"aabaabaa\") == True", "assert permutation_in_string(\"\", \"\") == True  # Edge case: both strings are empty", "assert permutation_in_string(\"longerstring\", \"short\") == False  # s1 is longer than s2", "assert permutation_in_string(\"a\", \"b\") == False  # Single character, no match", "assert permutation_in_string(\"aab\", \"baa\") == True  # s1 is a permutation of s2", "assert permutation_in_string(\"ab\", \"a\") == False  # s2 is shorter than s1", "assert permutation_in_string(\"ba\", \"eidbaooo\") == True  # Same characters as Example 1 but different permutation", "assert permutation_in_string(\"eid\", \"eidbaooo\") == True  # s1 is a prefix of s2", "assert permutation_in_string(\"ooo\", \"eidbaooo\") == True  # s1 is a suffix of s2", "assert permutation_in_string(\"db\", \"eidbaooo\") == True  # s1 is a permutation within s2", "assert permutation_in_string(\"eidoo\", \"eidbaooo\") == False  # s1 is longer than any permutation within s2"]}], "category": "String", "prompt_tokens": 1159, "total_tokens": 1599, "completion_tokens": 440, "completion": "Write a function to find the longest common prefix string amongst an array of strings.\n\nIf there is no common prefix, return an empty string \"\".\n\n###Code: \n\n```python\ndef longestCommonPrefix(strs: [str]) -> str:\n    if not strs:\n        return \"\"\n    min_len = min(len(s) for s in strs)\n    if min_len == 0:\n        return \"\"\n    \n    for i in range(min_len):\n        c = strs[0][i]\n        if any(s[i] != c for s in strs):\n            return strs[0][:i]\n    return strs[0][:min_len]\n```\n\n###Testcases: \n\n```python\nassert longestCommonPrefix([\"flower\",\"flow\",\"flight\"]) == \"fl\"\nassert longestCommonPrefix([\"dog\",\"racecar\",\"car\"]) == \"\"\nassert longestCommonPrefix([\"interspecies\",\"interstellar\",\"interstate\"]) == \"inters\"\nassert longestCommonPrefix([\"throne\",\"dungeon\"]) == \"\"\nassert longestCommonPrefix([\"throne\",\"throne\"]) == \"throne\"\nassert longestCommonPrefix([\"prefix\",\"prefixes\",\"pre\"]) == \"pre\"\nassert longestCommonPrefix([\"\",\"\"]) == \"\"\nassert longestCommonPrefix([\"a\"]) == \"a\"\nassert longestCommonPrefix([\"\",\"b\"]) == \"\"\nassert longestCommonPrefix([\"c\",\"c\"]) == \"c\"\nassert longestCommonPrefix([\"aaa\",\"aa\",\"aaa\"]) == \"aa\"\nassert longestCommonPrefix([\"abab\",\"aba\",\"\"]) == \"\"\nassert longestCommonPrefix([\"abc\",\"abcd\",\"ab\"]) == \"ab\"\nassert longestCommonPrefix([\"reflower\",\"flow\",\"flight\"]) == \"\"\nassert longestCommonPrefix([\"\"] * 5) == \"\"  # Edge case: all strings are empty\nassert longestCommonPrefix([\"a\"] * 5) == \"a\"  # Edge case: all strings are single character 'a'\nassert longestCommonPrefix([\"prefix\",\"pre\",\"pre\"]) == \"pre\"  # All strings have a common prefix\nassert longestCommonPrefix([\"longestprefix\",\"longest\",\"long\"]) == \"long\"  # Strings have decreasing lengths but common prefix\n```\n\n[/Example 3]", "temperature": 0.753}, {"few_shots": [{"author": "Calvin", "UUID": "ac641352-08d5-4950-8993-6a143da92ecf", "question": "You are given a string s and an integer k. You can choose one of the first k letters of s and append it at the end of the string.\n\nReturn the lexicographically smallest string you could have after applying the mentioned step any number of moves.\n", "examples": "Input: s = \"cba\", k = 1\nOutput: \"acb\"\n\nInput: s = \"baaca\", k = 3\nOutput: \"aaabc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef orderlyQueue(s: str, k: int) -> str:\n    if k == 1:\n        n = len(s)\n        ss = s + s\n        lex_min_str = s\n        for i in range(n):\n            lex_min_str = min(lex_min_str, ss[i:i + n])\n        return lex_min_str\n    \n    return \"\".join(sorted(s))\n", "asserts": ["assert orderlyQueue(\"abcd\", 1) == \"abcd\"", "assert orderlyQueue(\"hello\", 2) == \"ehllo\"", "assert orderlyQueue(\"programming\", 1) == \"ammingprogr\"", "assert orderlyQueue(\"rotator\", 1) == \"atorrot\"", "assert orderlyQueue(\"zxyabc\", 5) == \"abcxyz\"", "assert orderlyQueue(\"xy\", 2) == \"xy\""]}, {"author": "Calvin", "UUID": "87372a22-f5ef-4100-845b-28700ca3fde3", "question": "You are given a string s and an integer array indices of the same length. The string s will be shuffled such that the character at the ith position moves to indices[i] in the shuffled string.\n\nReturn the shuffled string.", "examples": "Input: s = \"codeleet\", indices = [4,5,6,7,0,2,1,3]\nOutput: \"leetcode\"\n\nInput: s = \"abc\", indices = [0,1,2]\nOutput: \"abc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "from typing import List\ndef shuffle_string(s: str, indices: List[int]) -> str:\n    def partitionString(s):\n      substrings = 1\n      cur_str = set()\n      for i in range(len(s)):\n        if s[i] in cur_str:\n          substrings += 1\n          cur_str = {s[i]}\n        else:\n          cur_str.add(s[i])\n      return substrings\n    ret = ['_']*len(s)\n    for idx, i in enumerate(indices):\n        ret[i] = s[idx]\n    return \"\".join(ret)\n", "asserts": ["assert shuffle_string(\"reoc\", [2, 0, 1, 3]) == \"eorc\"", "assert shuffle_string(\"aiohn\", [3,1,4,2,0]) == \"nihao\"", "assert shuffle_string(\"aax\", [0,2,1]) == \"axa\"", "assert shuffle_string(\"gh\", [1,0]) == \"hg\"", "assert shuffle_string(\"\", []) == \"\"  # Edge case: empty string", "assert shuffle_string(\"xy\", [0,1]) == \"xy\"  # No shuffle required", "assert shuffle_string(\"pqrstuvwxyzabcdefghijklmno\", list(range(25, -1, -1))) == \"onmlkjihgfedcbazyxwvutsrqp\"  # Reverse shuffle"]}], "category": "String", "prompt_tokens": 755, "total_tokens": 1051, "completion_tokens": 296, "completion": "You need to write a function that accepts a string and returns a new string with each character followed by the number of times it appears consecutively in the string. \n\n###Code:\n\ndef encode_consecutive_chars(s: str) -> str:\n    if not s:\n        return \"\"\n    \n    result = []\n    count = 1\n    for i in range(1, len(s)):\n        if s[i] == s[i-1]:\n            count += 1\n        else:\n            result.append(s[i-1] + str(count))\n            count = 1\n    result.append(s[-1] + str(count))\n    \n    return \"\".join(result)\n\n###Testcases:\n\nassert encode_consecutive_chars(\"aaabbcaaad\") == \"a3b2c1a3d1\"\nassert encode_consecutive_chars(\"hhhhhhhhhhh\") == \"h11\"\nassert encode_consecutive_chars(\"ab\") == \"a1b1\"\nassert encode_consecutive_chars(\"a\") == \"a1\"\nassert encode_consecutive_chars(\"\") == \"\"  # Edge case: empty string\nassert encode_consecutive_chars(\"aabba\") == \"a2b2a1\"\nassert encode_consecutive_chars(\"abcd\") == \"a1b1c1d1\"  # No consecutive characters\nassert encode_consecutive_chars(\"aaAAaa\") == \"a2A2a2\"  # Case-sensitive\n\n[/Example 3]", "temperature": 0.816}, {"few_shots": [{"author": "Calvin", "UUID": "ac641352-08d5-4950-8993-6a143da92ecf", "question": "You are given a string s and an integer k. You can choose one of the first k letters of s and append it at the end of the string.\n\nReturn the lexicographically smallest string you could have after applying the mentioned step any number of moves.\n", "examples": "Input: s = \"cba\", k = 1\nOutput: \"acb\"\n\nInput: s = \"baaca\", k = 3\nOutput: \"aaabc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef orderlyQueue(s: str, k: int) -> str:\n    if k == 1:\n        n = len(s)\n        ss = s + s\n        lex_min_str = s\n        for i in range(n):\n            lex_min_str = min(lex_min_str, ss[i:i + n])\n        return lex_min_str\n    \n    return \"\".join(sorted(s))\n", "asserts": ["assert orderlyQueue(\"abcd\", 1) == \"abcd\"", "assert orderlyQueue(\"hello\", 2) == \"ehllo\"", "assert orderlyQueue(\"programming\", 1) == \"ammingprogr\"", "assert orderlyQueue(\"rotator\", 1) == \"atorrot\"", "assert orderlyQueue(\"zxyabc\", 5) == \"abcxyz\"", "assert orderlyQueue(\"xy\", 2) == \"xy\""]}, {"author": "Calvin", "UUID": "87372a22-f5ef-4100-845b-28700ca3fde3", "question": "You are given a string s and an integer array indices of the same length. The string s will be shuffled such that the character at the ith position moves to indices[i] in the shuffled string.\n\nReturn the shuffled string.", "examples": "Input: s = \"codeleet\", indices = [4,5,6,7,0,2,1,3]\nOutput: \"leetcode\"\n\nInput: s = \"abc\", indices = [0,1,2]\nOutput: \"abc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "from typing import List\ndef shuffle_string(s: str, indices: List[int]) -> str:\n    def partitionString(s):\n      substrings = 1\n      cur_str = set()\n      for i in range(len(s)):\n        if s[i] in cur_str:\n          substrings += 1\n          cur_str = {s[i]}\n        else:\n          cur_str.add(s[i])\n      return substrings\n    ret = ['_']*len(s)\n    for idx, i in enumerate(indices):\n        ret[i] = s[idx]\n    return \"\".join(ret)\n", "asserts": ["assert shuffle_string(\"reoc\", [2, 0, 1, 3]) == \"eorc\"", "assert shuffle_string(\"aiohn\", [3,1,4,2,0]) == \"nihao\"", "assert shuffle_string(\"aax\", [0,2,1]) == \"axa\"", "assert shuffle_string(\"gh\", [1,0]) == \"hg\"", "assert shuffle_string(\"\", []) == \"\"  # Edge case: empty string", "assert shuffle_string(\"xy\", [0,1]) == \"xy\"  # No shuffle required", "assert shuffle_string(\"pqrstuvwxyzabcdefghijklmno\", list(range(25, -1, -1))) == \"onmlkjihgfedcbazyxwvutsrqp\"  # Reverse shuffle"]}], "category": "String", "prompt_tokens": 755, "total_tokens": 1016, "completion_tokens": 261, "completion": "Write a function that takes two strings `a` and `b` as arguments and returns a new string containing only the characters that are unique in each string. In other words, the function should return a string that contains all characters from `a` that are not in `b` and all characters from `b` that are not in `a`. The resulting string should not have any duplicate characters and should be sorted in lexicographic order.\n\n###Code: \n\ndef unique_string(a: str, b: str) -> str:\n    unique_chars = set(a) ^ set(b)  # Symmetric difference to find unique characters in each string\n    return ''.join(sorted(unique_chars))\n\n###Testcases: \n\nassert unique_string(\"abc\", \"bcd\") == \"ad\"\nassert unique_string(\"hello\", \"world\") == \"derw\"\nassert unique_string(\"python\", \"java\") == \"ahjnotvy\"\nassert unique_string(\"apple\", \"orange\") == \"eglpr\"\nassert unique_string(\"same\", \"same\") == \"\"  # No unique characters\nassert unique_string(\"\", \"\") == \"\"  # Edge case: both strings are empty\nassert unique_string(\"abcd\", \"efgh\") == \"abcdefgh\"  # No common characters\n\n[/Example 3]", "temperature": 0.835}, {"few_shots": [{"author": "Calvin", "UUID": "ac641352-08d5-4950-8993-6a143da92ecf", "question": "You are given a string s and an integer k. You can choose one of the first k letters of s and append it at the end of the string.\n\nReturn the lexicographically smallest string you could have after applying the mentioned step any number of moves.\n", "examples": "Input: s = \"cba\", k = 1\nOutput: \"acb\"\n\nInput: s = \"baaca\", k = 3\nOutput: \"aaabc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef orderlyQueue(s: str, k: int) -> str:\n    if k == 1:\n        n = len(s)\n        ss = s + s\n        lex_min_str = s\n        for i in range(n):\n            lex_min_str = min(lex_min_str, ss[i:i + n])\n        return lex_min_str\n    \n    return \"\".join(sorted(s))\n", "asserts": ["assert orderlyQueue(\"abcd\", 1) == \"abcd\"", "assert orderlyQueue(\"hello\", 2) == \"ehllo\"", "assert orderlyQueue(\"programming\", 1) == \"ammingprogr\"", "assert orderlyQueue(\"rotator\", 1) == \"atorrot\"", "assert orderlyQueue(\"zxyabc\", 5) == \"abcxyz\"", "assert orderlyQueue(\"xy\", 2) == \"xy\""]}, {"author": "Calvin", "UUID": "87372a22-f5ef-4100-845b-28700ca3fde3", "question": "You are given a string s and an integer array indices of the same length. The string s will be shuffled such that the character at the ith position moves to indices[i] in the shuffled string.\n\nReturn the shuffled string.", "examples": "Input: s = \"codeleet\", indices = [4,5,6,7,0,2,1,3]\nOutput: \"leetcode\"\n\nInput: s = \"abc\", indices = [0,1,2]\nOutput: \"abc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "from typing import List\ndef shuffle_string(s: str, indices: List[int]) -> str:\n    def partitionString(s):\n      substrings = 1\n      cur_str = set()\n      for i in range(len(s)):\n        if s[i] in cur_str:\n          substrings += 1\n          cur_str = {s[i]}\n        else:\n          cur_str.add(s[i])\n      return substrings\n    ret = ['_']*len(s)\n    for idx, i in enumerate(indices):\n        ret[i] = s[idx]\n    return \"\".join(ret)\n", "asserts": ["assert shuffle_string(\"reoc\", [2, 0, 1, 3]) == \"eorc\"", "assert shuffle_string(\"aiohn\", [3,1,4,2,0]) == \"nihao\"", "assert shuffle_string(\"aax\", [0,2,1]) == \"axa\"", "assert shuffle_string(\"gh\", [1,0]) == \"hg\"", "assert shuffle_string(\"\", []) == \"\"  # Edge case: empty string", "assert shuffle_string(\"xy\", [0,1]) == \"xy\"  # No shuffle required", "assert shuffle_string(\"pqrstuvwxyzabcdefghijklmno\", list(range(25, -1, -1))) == \"onmlkjihgfedcbazyxwvutsrqp\"  # Reverse shuffle"]}], "category": "String", "prompt_tokens": 755, "total_tokens": 1038, "completion_tokens": 283, "completion": "You have a string s and an integer n. Write a function to rotate the string to the right by n characters.\n\nIf n is greater than the length of the string, the rotation should work as if the string were repeated end to end as many times as needed to achieve the desired length.\n\nReturn the rotated string.\n\n###Code: \n\ndef rotate_string(s: str, n: int) -> str:\n    if not s:\n        return s\n    n = n % len(s)  # Handle the case where n is greater than the length of s\n    return s[-n:] + s[:-n]\n\n\n###Testcases: \n\nassert rotate_string(\"helloworld\", 2) == \"ldhellowor\"\nassert rotate_string(\"abcdef\", 1) == \"fabcde\"\nassert rotate_string(\"rotation\", 4) == \"tionrota\"\nassert rotate_string(\"abc\", 3) == \"abc\"  # Full rotation (no change)\nassert rotate_string(\"abc\", 6) == \"abc\"  # Full rotation twice (no change)\nassert rotate_string(\"\", 5) == \"\"  # Edge case: empty string\nassert rotate_string(\"xy\", 5) == \"yx\"  # Rotation longer than string length\nassert rotate_string(\"abcdefg\", 0) == \"abcdefg\"  # No rotation\n\n[/Example 3]", "temperature": 0.822}, {"few_shots": [{"author": "Calvin", "UUID": "ac641352-08d5-4950-8993-6a143da92ecf", "question": "You are given a string s and an integer k. You can choose one of the first k letters of s and append it at the end of the string.\n\nReturn the lexicographically smallest string you could have after applying the mentioned step any number of moves.\n", "examples": "Input: s = \"cba\", k = 1\nOutput: \"acb\"\n\nInput: s = \"baaca\", k = 3\nOutput: \"aaabc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef orderlyQueue(s: str, k: int) -> str:\n    if k == 1:\n        n = len(s)\n        ss = s + s\n        lex_min_str = s\n        for i in range(n):\n            lex_min_str = min(lex_min_str, ss[i:i + n])\n        return lex_min_str\n    \n    return \"\".join(sorted(s))\n", "asserts": ["assert orderlyQueue(\"abcd\", 1) == \"abcd\"", "assert orderlyQueue(\"hello\", 2) == \"ehllo\"", "assert orderlyQueue(\"programming\", 1) == \"ammingprogr\"", "assert orderlyQueue(\"rotator\", 1) == \"atorrot\"", "assert orderlyQueue(\"zxyabc\", 5) == \"abcxyz\"", "assert orderlyQueue(\"xy\", 2) == \"xy\""]}, {"author": "Calvin", "UUID": "87372a22-f5ef-4100-845b-28700ca3fde3", "question": "You are given a string s and an integer array indices of the same length. The string s will be shuffled such that the character at the ith position moves to indices[i] in the shuffled string.\n\nReturn the shuffled string.", "examples": "Input: s = \"codeleet\", indices = [4,5,6,7,0,2,1,3]\nOutput: \"leetcode\"\n\nInput: s = \"abc\", indices = [0,1,2]\nOutput: \"abc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "from typing import List\ndef shuffle_string(s: str, indices: List[int]) -> str:\n    def partitionString(s):\n      substrings = 1\n      cur_str = set()\n      for i in range(len(s)):\n        if s[i] in cur_str:\n          substrings += 1\n          cur_str = {s[i]}\n        else:\n          cur_str.add(s[i])\n      return substrings\n    ret = ['_']*len(s)\n    for idx, i in enumerate(indices):\n        ret[i] = s[idx]\n    return \"\".join(ret)\n", "asserts": ["assert shuffle_string(\"reoc\", [2, 0, 1, 3]) == \"eorc\"", "assert shuffle_string(\"aiohn\", [3,1,4,2,0]) == \"nihao\"", "assert shuffle_string(\"aax\", [0,2,1]) == \"axa\"", "assert shuffle_string(\"gh\", [1,0]) == \"hg\"", "assert shuffle_string(\"\", []) == \"\"  # Edge case: empty string", "assert shuffle_string(\"xy\", [0,1]) == \"xy\"  # No shuffle required", "assert shuffle_string(\"pqrstuvwxyzabcdefghijklmno\", list(range(25, -1, -1))) == \"onmlkjihgfedcbazyxwvutsrqp\"  # Reverse shuffle"]}], "category": "String", "prompt_tokens": 755, "total_tokens": 1085, "completion_tokens": 330, "completion": "You are tasked with implementing a function that compresses a string by using the counts of repeated characters. For example, the string \"aabcccccaaa\" would become \"a2b1c5a3\". If the \"compressed\" string would not become smaller than the original string, your function should return the original string.\n\n###Code:\n\ndef compress_string(s: str) -> str:\n    if not s:\n        return s\n    \n    compressed = []\n    count = 1\n    for i in range(1, len(s)):\n        if s[i] == s[i-1]:\n            count += 1\n        else:\n            compressed.append(s[i-1] + str(count))\n            count = 1\n    compressed.append(s[-1] + str(count))\n    \n    compressed_str = \"\".join(compressed)\n    return compressed_str if len(compressed_str) < len(s) else s\n\n###Testcases: \n\nassert compress_string(\"aabcccccaaa\") == \"a2b1c5a3\"\nassert compress_string(\"abcd\") == \"abcd\"  # Compression does not shorten the string\nassert compress_string(\"aaabbbccc\") == \"a3b3c3\"\nassert compress_string(\"a\") == \"a\"  # Single character\nassert compress_string(\"aa\") == \"a2\"\nassert compress_string(\"aaa\") == \"a3\"\nassert compress_string(\"\") == \"\"  # Empty string\nassert compress_string(\"wwwwaaadexxxxxxywww\") == \"w4a3d1e1x6y1w3\"\n\n[/Example 3]", "temperature": 0.676}, {"few_shots": [{"author": "Calvin", "UUID": "ac641352-08d5-4950-8993-6a143da92ecf", "question": "You are given a string s and an integer k. You can choose one of the first k letters of s and append it at the end of the string.\n\nReturn the lexicographically smallest string you could have after applying the mentioned step any number of moves.\n", "examples": "Input: s = \"cba\", k = 1\nOutput: \"acb\"\n\nInput: s = \"baaca\", k = 3\nOutput: \"aaabc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef orderlyQueue(s: str, k: int) -> str:\n    if k == 1:\n        n = len(s)\n        ss = s + s\n        lex_min_str = s\n        for i in range(n):\n            lex_min_str = min(lex_min_str, ss[i:i + n])\n        return lex_min_str\n    \n    return \"\".join(sorted(s))\n", "asserts": ["assert orderlyQueue(\"abcd\", 1) == \"abcd\"", "assert orderlyQueue(\"hello\", 2) == \"ehllo\"", "assert orderlyQueue(\"programming\", 1) == \"ammingprogr\"", "assert orderlyQueue(\"rotator\", 1) == \"atorrot\"", "assert orderlyQueue(\"zxyabc\", 5) == \"abcxyz\"", "assert orderlyQueue(\"xy\", 2) == \"xy\""]}, {"author": "Calvin", "UUID": "87372a22-f5ef-4100-845b-28700ca3fde3", "question": "You are given a string s and an integer array indices of the same length. The string s will be shuffled such that the character at the ith position moves to indices[i] in the shuffled string.\n\nReturn the shuffled string.", "examples": "Input: s = \"codeleet\", indices = [4,5,6,7,0,2,1,3]\nOutput: \"leetcode\"\n\nInput: s = \"abc\", indices = [0,1,2]\nOutput: \"abc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "from typing import List\ndef shuffle_string(s: str, indices: List[int]) -> str:\n    def partitionString(s):\n      substrings = 1\n      cur_str = set()\n      for i in range(len(s)):\n        if s[i] in cur_str:\n          substrings += 1\n          cur_str = {s[i]}\n        else:\n          cur_str.add(s[i])\n      return substrings\n    ret = ['_']*len(s)\n    for idx, i in enumerate(indices):\n        ret[i] = s[idx]\n    return \"\".join(ret)\n", "asserts": ["assert shuffle_string(\"reoc\", [2, 0, 1, 3]) == \"eorc\"", "assert shuffle_string(\"aiohn\", [3,1,4,2,0]) == \"nihao\"", "assert shuffle_string(\"aax\", [0,2,1]) == \"axa\"", "assert shuffle_string(\"gh\", [1,0]) == \"hg\"", "assert shuffle_string(\"\", []) == \"\"  # Edge case: empty string", "assert shuffle_string(\"xy\", [0,1]) == \"xy\"  # No shuffle required", "assert shuffle_string(\"pqrstuvwxyzabcdefghijklmno\", list(range(25, -1, -1))) == \"onmlkjihgfedcbazyxwvutsrqp\"  # Reverse shuffle"]}], "category": "String", "prompt_tokens": 755, "total_tokens": 1159, "completion_tokens": 404, "completion": "Given a string s and an integer k, return the length of the longest substring of s that contains at most k distinct characters.\n\n###Code:\n\n```python\ndef length_of_longest_substring_k_distinct(s: str, k: int) -> int:\n    if k == 0 or not s:\n        return 0\n\n    left = 0\n    right = 0\n    longest = 0\n    char_count = {}\n\n    while right < len(s):\n        char = s[right]\n        char_count[char] = char_count.get(char, 0) + 1\n\n        while len(char_count) > k:\n            char_count[s[left]] -= 1\n            if char_count[s[left]] == 0:\n                del char_count[s[left]]\n            left += 1\n        \n        longest = max(longest, right - left + 1)\n        right += 1\n\n    return longest\n```\n\n###Testcases:\n\n```python\nassert length_of_longest_substring_k_distinct(\"eceba\", 2) == 3\nassert length_of_longest_substring_k_distinct(\"aa\", 1) == 2\nassert length_of_longest_substring_k_distinct(\"\", 3) == 0  # Edge case: empty string\nassert length_of_longest_substring_k_distinct(\"abaccc\", 2) == 4\nassert length_of_longest_substring_k_distinct(\"abaccc\", 3) == 6\nassert length_of_longest_substring_k_distinct(\"aabbcc\", 1) == 2\nassert length_of_longest_substring_k_distinct(\"aabbcc\", 2) == 4\nassert length_of_longest_substring_k_distinct(\"aabbcc\", 3) == 6\nassert length_of_longest_substring_k_distinct(\"aaabbb\", 3) == 6\n```\n\n[/Example 3]", "temperature": 0.882}, {"few_shots": [{"author": "Calvin", "UUID": "ac641352-08d5-4950-8993-6a143da92ecf", "question": "You are given a string s and an integer k. You can choose one of the first k letters of s and append it at the end of the string.\n\nReturn the lexicographically smallest string you could have after applying the mentioned step any number of moves.\n", "examples": "Input: s = \"cba\", k = 1\nOutput: \"acb\"\n\nInput: s = \"baaca\", k = 3\nOutput: \"aaabc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef orderlyQueue(s: str, k: int) -> str:\n    if k == 1:\n        n = len(s)\n        ss = s + s\n        lex_min_str = s\n        for i in range(n):\n            lex_min_str = min(lex_min_str, ss[i:i + n])\n        return lex_min_str\n    \n    return \"\".join(sorted(s))\n", "asserts": ["assert orderlyQueue(\"abcd\", 1) == \"abcd\"", "assert orderlyQueue(\"hello\", 2) == \"ehllo\"", "assert orderlyQueue(\"programming\", 1) == \"ammingprogr\"", "assert orderlyQueue(\"rotator\", 1) == \"atorrot\"", "assert orderlyQueue(\"zxyabc\", 5) == \"abcxyz\"", "assert orderlyQueue(\"xy\", 2) == \"xy\""]}, {"author": "Calvin", "UUID": "87372a22-f5ef-4100-845b-28700ca3fde3", "question": "You are given a string s and an integer array indices of the same length. The string s will be shuffled such that the character at the ith position moves to indices[i] in the shuffled string.\n\nReturn the shuffled string.", "examples": "Input: s = \"codeleet\", indices = [4,5,6,7,0,2,1,3]\nOutput: \"leetcode\"\n\nInput: s = \"abc\", indices = [0,1,2]\nOutput: \"abc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "from typing import List\ndef shuffle_string(s: str, indices: List[int]) -> str:\n    def partitionString(s):\n      substrings = 1\n      cur_str = set()\n      for i in range(len(s)):\n        if s[i] in cur_str:\n          substrings += 1\n          cur_str = {s[i]}\n        else:\n          cur_str.add(s[i])\n      return substrings\n    ret = ['_']*len(s)\n    for idx, i in enumerate(indices):\n        ret[i] = s[idx]\n    return \"\".join(ret)\n", "asserts": ["assert shuffle_string(\"reoc\", [2, 0, 1, 3]) == \"eorc\"", "assert shuffle_string(\"aiohn\", [3,1,4,2,0]) == \"nihao\"", "assert shuffle_string(\"aax\", [0,2,1]) == \"axa\"", "assert shuffle_string(\"gh\", [1,0]) == \"hg\"", "assert shuffle_string(\"\", []) == \"\"  # Edge case: empty string", "assert shuffle_string(\"xy\", [0,1]) == \"xy\"  # No shuffle required", "assert shuffle_string(\"pqrstuvwxyzabcdefghijklmno\", list(range(25, -1, -1))) == \"onmlkjihgfedcbazyxwvutsrqp\"  # Reverse shuffle"]}], "category": "String", "prompt_tokens": 755, "total_tokens": 1183, "completion_tokens": 428, "completion": "Given a string containing only three types of characters: '(', ')' and '*', write a function to check whether this string is valid. We define the validity of a string by these rules:\n\n1. Any left parenthesis '(' must have a corresponding right parenthesis ')'.\n2. Any right parenthesis ')' must have a corresponding left parenthesis '('.\n3. Left parenthesis '(' must go before the corresponding right parenthesis ')'.\n4. '*' could be treated as a single right parenthesis ')' or a single left parenthesis '(' or an empty string.\n5. An empty string is also valid.\n\nThe function should return true if the string is valid, and false otherwise.\n\n###Code: \n\ndef checkValidString(s: str) -> bool:\n    left_balance = right_balance = 0\n    n = len(s)\n    \n    for i in range(n):\n        # consider '*' as '('\n        if s[i] in \"(*\":\n            left_balance += 1\n        else:\n            left_balance -= 1\n        \n        # consider '*' as ')'\n        if s[n - i - 1] in \"*)\":\n            right_balance += 1\n        else:\n            right_balance -= 1\n        \n        # if at any point balance is negative, it means it's not valid\n        if left_balance < 0 or right_balance < 0:\n            return False\n            \n    return True\n\n###Testcases: \n\nassert checkValidString(\"()\") == True\nassert checkValidString(\"(*)\") == True\nassert checkValidString(\"(*))\") == True\nassert checkValidString(\")*(\") == False\nassert checkValidString(\"(((******))\") == True\nassert checkValidString(\"(*)\") == True\nassert checkValidString(\"(*))\") == True\nassert checkValidString(\"((*)\") == True\nassert checkValidString(\")(\") == False\nassert checkValidString(\"\") == True  # Edge case: empty string\nassert checkValidString(\"*\") == True  # Single character - valid\nassert checkValidString(\"(((********))\") == True  # Multiple asterisks\n\n[/Example 3]", "temperature": 0.695}, {"few_shots": [{"author": "Calvin", "UUID": "ac641352-08d5-4950-8993-6a143da92ecf", "question": "You are given a string s and an integer k. You can choose one of the first k letters of s and append it at the end of the string.\n\nReturn the lexicographically smallest string you could have after applying the mentioned step any number of moves.\n", "examples": "Input: s = \"cba\", k = 1\nOutput: \"acb\"\n\nInput: s = \"baaca\", k = 3\nOutput: \"aaabc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef orderlyQueue(s: str, k: int) -> str:\n    if k == 1:\n        n = len(s)\n        ss = s + s\n        lex_min_str = s\n        for i in range(n):\n            lex_min_str = min(lex_min_str, ss[i:i + n])\n        return lex_min_str\n    \n    return \"\".join(sorted(s))\n", "asserts": ["assert orderlyQueue(\"abcd\", 1) == \"abcd\"", "assert orderlyQueue(\"hello\", 2) == \"ehllo\"", "assert orderlyQueue(\"programming\", 1) == \"ammingprogr\"", "assert orderlyQueue(\"rotator\", 1) == \"atorrot\"", "assert orderlyQueue(\"zxyabc\", 5) == \"abcxyz\"", "assert orderlyQueue(\"xy\", 2) == \"xy\""]}, {"author": "Calvin", "UUID": "87372a22-f5ef-4100-845b-28700ca3fde3", "question": "You are given a string s and an integer array indices of the same length. The string s will be shuffled such that the character at the ith position moves to indices[i] in the shuffled string.\n\nReturn the shuffled string.", "examples": "Input: s = \"codeleet\", indices = [4,5,6,7,0,2,1,3]\nOutput: \"leetcode\"\n\nInput: s = \"abc\", indices = [0,1,2]\nOutput: \"abc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "from typing import List\ndef shuffle_string(s: str, indices: List[int]) -> str:\n    def partitionString(s):\n      substrings = 1\n      cur_str = set()\n      for i in range(len(s)):\n        if s[i] in cur_str:\n          substrings += 1\n          cur_str = {s[i]}\n        else:\n          cur_str.add(s[i])\n      return substrings\n    ret = ['_']*len(s)\n    for idx, i in enumerate(indices):\n        ret[i] = s[idx]\n    return \"\".join(ret)\n", "asserts": ["assert shuffle_string(\"reoc\", [2, 0, 1, 3]) == \"eorc\"", "assert shuffle_string(\"aiohn\", [3,1,4,2,0]) == \"nihao\"", "assert shuffle_string(\"aax\", [0,2,1]) == \"axa\"", "assert shuffle_string(\"gh\", [1,0]) == \"hg\"", "assert shuffle_string(\"\", []) == \"\"  # Edge case: empty string", "assert shuffle_string(\"xy\", [0,1]) == \"xy\"  # No shuffle required", "assert shuffle_string(\"pqrstuvwxyzabcdefghijklmno\", list(range(25, -1, -1))) == \"onmlkjihgfedcbazyxwvutsrqp\"  # Reverse shuffle"]}], "category": "String", "prompt_tokens": 755, "total_tokens": 1165, "completion_tokens": 410, "completion": "Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.\n\n###Code:\n\ndef longest_palindrome(s: str) -> str:\n    if len(s) == 0:\n        return \"\"\n    \n    start, end = 0, 0\n    for i in range(len(s)):\n        len1 = expand_around_center(s, i, i)\n        len2 = expand_around_center(s, i, i + 1)\n        max_len = max(len1, len2)\n        if max_len > (end - start):\n            start = i - (max_len - 1) // 2\n            end = i + max_len // 2\n    \n    return s[start:end + 1]\n\ndef expand_around_center(s, left, right):\n    L, R = left, right\n    while L >= 0 and R < len(s) and s[L] == s[R]:\n        L -= 1\n        R += 1\n    return R - L - 1\n\n###Testcases:\n\nassert longest_palindrome(\"babad\") == \"bab\" or longest_palindrome(\"babad\") == \"aba\"\nassert longest_palindrome(\"cbbd\") == \"bb\"\nassert longest_palindrome(\"a\") == \"a\"\nassert longest_palindrome(\"ac\") == \"a\" or longest_palindrome(\"ac\") == \"c\"\nassert longest_palindrome(\"racecar\") == \"racecar\"\nassert longest_palindrome(\"aaaa\") == \"aaaa\"\nassert longest_palindrome(\"abcba\") == \"abcba\"\nassert longest_palindrome(\"forgeeksskeegfor\") == \"geeksskeeg\"\nassert longest_palindrome(\"abacdfgdcaba\") == \"aba\"\nassert longest_palindrome(\"abacdfgdcabba\") == \"abba\"\nassert longest_palindrome(\"\") == \"\"  # Edge case: empty string\n\n[/Example 3]", "temperature": 0.662}, {"few_shots": [{"author": "Calvin", "UUID": "ac641352-08d5-4950-8993-6a143da92ecf", "question": "You are given a string s and an integer k. You can choose one of the first k letters of s and append it at the end of the string.\n\nReturn the lexicographically smallest string you could have after applying the mentioned step any number of moves.\n", "examples": "Input: s = \"cba\", k = 1\nOutput: \"acb\"\n\nInput: s = \"baaca\", k = 3\nOutput: \"aaabc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef orderlyQueue(s: str, k: int) -> str:\n    if k == 1:\n        n = len(s)\n        ss = s + s\n        lex_min_str = s\n        for i in range(n):\n            lex_min_str = min(lex_min_str, ss[i:i + n])\n        return lex_min_str\n    \n    return \"\".join(sorted(s))\n", "asserts": ["assert orderlyQueue(\"abcd\", 1) == \"abcd\"", "assert orderlyQueue(\"hello\", 2) == \"ehllo\"", "assert orderlyQueue(\"programming\", 1) == \"ammingprogr\"", "assert orderlyQueue(\"rotator\", 1) == \"atorrot\"", "assert orderlyQueue(\"zxyabc\", 5) == \"abcxyz\"", "assert orderlyQueue(\"xy\", 2) == \"xy\""]}, {"author": "Calvin", "UUID": "87372a22-f5ef-4100-845b-28700ca3fde3", "question": "You are given a string s and an integer array indices of the same length. The string s will be shuffled such that the character at the ith position moves to indices[i] in the shuffled string.\n\nReturn the shuffled string.", "examples": "Input: s = \"codeleet\", indices = [4,5,6,7,0,2,1,3]\nOutput: \"leetcode\"\n\nInput: s = \"abc\", indices = [0,1,2]\nOutput: \"abc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "from typing import List\ndef shuffle_string(s: str, indices: List[int]) -> str:\n    def partitionString(s):\n      substrings = 1\n      cur_str = set()\n      for i in range(len(s)):\n        if s[i] in cur_str:\n          substrings += 1\n          cur_str = {s[i]}\n        else:\n          cur_str.add(s[i])\n      return substrings\n    ret = ['_']*len(s)\n    for idx, i in enumerate(indices):\n        ret[i] = s[idx]\n    return \"\".join(ret)\n", "asserts": ["assert shuffle_string(\"reoc\", [2, 0, 1, 3]) == \"eorc\"", "assert shuffle_string(\"aiohn\", [3,1,4,2,0]) == \"nihao\"", "assert shuffle_string(\"aax\", [0,2,1]) == \"axa\"", "assert shuffle_string(\"gh\", [1,0]) == \"hg\"", "assert shuffle_string(\"\", []) == \"\"  # Edge case: empty string", "assert shuffle_string(\"xy\", [0,1]) == \"xy\"  # No shuffle required", "assert shuffle_string(\"pqrstuvwxyzabcdefghijklmno\", list(range(25, -1, -1))) == \"onmlkjihgfedcbazyxwvutsrqp\"  # Reverse shuffle"]}], "category": "String", "prompt_tokens": 755, "total_tokens": 1082, "completion_tokens": 327, "completion": "Given a string s, find the longest substring that contains at most two distinct characters. If there are multiple solutions, return the first occurring substring.\n\n###Code: \n\ndef length_of_longest_substring_two_distinct(s: str) -> str:\n    max_substr = \"\"\n    for i in range(len(s)):\n        distinct_chars = set()\n        current_substr = \"\"\n        for j in range(i, len(s)):\n            if s[j] not in distinct_chars:\n                distinct_chars.add(s[j])\n                if len(distinct_chars) > 2:\n                    break\n            current_substr += s[j]\n        if len(current_substr) > len(max_substr):\n            max_substr = current_substr\n    return max_substr\n\n###Testcases: \n\nassert length_of_longest_substring_two_distinct(\"eceba\") == \"ece\"\nassert length_of_longest_substring_two_distinct(\"aabccbb\") == \"bccbb\"\nassert length_of_longest_substring_two_distinct(\"abcabcabc\") == \"bca\"\nassert length_of_longest_substring_two_distinct(\"aaaccc\") == \"aaaccc\"\nassert length_of_longest_substring_two_distinct(\"abaccc\") == \"baccc\"\nassert length_of_longest_substring_two_distinct(\"a\") == \"a\"  # Edge case: single character\nassert length_of_longest_substring_two_distinct(\"ab\") == \"ab\"  # Edge case: just two distinct characters\nassert length_of_longest_substring_two_distinct(\"\") == \"\"  # Edge case: empty string\n\n[/Example 3]", "temperature": 0.842}, {"few_shots": [{"author": "Calvin", "UUID": "ac641352-08d5-4950-8993-6a143da92ecf", "question": "You are given a string s and an integer k. You can choose one of the first k letters of s and append it at the end of the string.\n\nReturn the lexicographically smallest string you could have after applying the mentioned step any number of moves.\n", "examples": "Input: s = \"cba\", k = 1\nOutput: \"acb\"\n\nInput: s = \"baaca\", k = 3\nOutput: \"aaabc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef orderlyQueue(s: str, k: int) -> str:\n    if k == 1:\n        n = len(s)\n        ss = s + s\n        lex_min_str = s\n        for i in range(n):\n            lex_min_str = min(lex_min_str, ss[i:i + n])\n        return lex_min_str\n    \n    return \"\".join(sorted(s))\n", "asserts": ["assert orderlyQueue(\"abcd\", 1) == \"abcd\"", "assert orderlyQueue(\"hello\", 2) == \"ehllo\"", "assert orderlyQueue(\"programming\", 1) == \"ammingprogr\"", "assert orderlyQueue(\"rotator\", 1) == \"atorrot\"", "assert orderlyQueue(\"zxyabc\", 5) == \"abcxyz\"", "assert orderlyQueue(\"xy\", 2) == \"xy\""]}, {"author": "Calvin", "UUID": "87372a22-f5ef-4100-845b-28700ca3fde3", "question": "You are given a string s and an integer array indices of the same length. The string s will be shuffled such that the character at the ith position moves to indices[i] in the shuffled string.\n\nReturn the shuffled string.", "examples": "Input: s = \"codeleet\", indices = [4,5,6,7,0,2,1,3]\nOutput: \"leetcode\"\n\nInput: s = \"abc\", indices = [0,1,2]\nOutput: \"abc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "from typing import List\ndef shuffle_string(s: str, indices: List[int]) -> str:\n    def partitionString(s):\n      substrings = 1\n      cur_str = set()\n      for i in range(len(s)):\n        if s[i] in cur_str:\n          substrings += 1\n          cur_str = {s[i]}\n        else:\n          cur_str.add(s[i])\n      return substrings\n    ret = ['_']*len(s)\n    for idx, i in enumerate(indices):\n        ret[i] = s[idx]\n    return \"\".join(ret)\n", "asserts": ["assert shuffle_string(\"reoc\", [2, 0, 1, 3]) == \"eorc\"", "assert shuffle_string(\"aiohn\", [3,1,4,2,0]) == \"nihao\"", "assert shuffle_string(\"aax\", [0,2,1]) == \"axa\"", "assert shuffle_string(\"gh\", [1,0]) == \"hg\"", "assert shuffle_string(\"\", []) == \"\"  # Edge case: empty string", "assert shuffle_string(\"xy\", [0,1]) == \"xy\"  # No shuffle required", "assert shuffle_string(\"pqrstuvwxyzabcdefghijklmno\", list(range(25, -1, -1))) == \"onmlkjihgfedcbazyxwvutsrqp\"  # Reverse shuffle"]}], "category": "String", "prompt_tokens": 755, "total_tokens": 1007, "completion_tokens": 252, "completion": "Given a string s consisting of lowercase English letters, return the first non-repeating character in it and its index. If it does not exist, return -1.\n\n###Code:\n\nfrom typing import Tuple\n\ndef first_uniq_char(s: str) -> Tuple[str, int]:\n    freq = {}\n    for char in s:\n        freq[char] = freq.get(char, 0) + 1\n        \n    for i, char in enumerate(s):\n        if freq[char] == 1:\n            return (char, i)\n    \n    return (-1, -1)\n\n###Testcases:\n\nassert first_uniq_char(\"leetcode\") == ('l', 0)\nassert first_uniq_char(\"loveleetcode\") == ('v', 2)\nassert first_uniq_char(\"aabb\") == (-1, -1)\nassert first_uniq_char(\"algorithm\") == ('a', 0)\nassert first_uniq_char(\"python\") == ('p', 0)\nassert first_uniq_char(\"aabcc\") == ('b', 2)\nassert first_uniq_char(\"xxxyyyzzz\") == (-1, -1)\nassert first_uniq_char(\"z\") == ('z', 0)\n\n[/Example 3]", "temperature": 0.761}, {"few_shots": [{"author": "Calvin", "UUID": "ac641352-08d5-4950-8993-6a143da92ecf", "question": "You are given a string s and an integer k. You can choose one of the first k letters of s and append it at the end of the string.\n\nReturn the lexicographically smallest string you could have after applying the mentioned step any number of moves.\n", "examples": "Input: s = \"cba\", k = 1\nOutput: \"acb\"\n\nInput: s = \"baaca\", k = 3\nOutput: \"aaabc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef orderlyQueue(s: str, k: int) -> str:\n    if k == 1:\n        n = len(s)\n        ss = s + s\n        lex_min_str = s\n        for i in range(n):\n            lex_min_str = min(lex_min_str, ss[i:i + n])\n        return lex_min_str\n    \n    return \"\".join(sorted(s))\n", "asserts": ["assert orderlyQueue(\"abcd\", 1) == \"abcd\"", "assert orderlyQueue(\"hello\", 2) == \"ehllo\"", "assert orderlyQueue(\"programming\", 1) == \"ammingprogr\"", "assert orderlyQueue(\"rotator\", 1) == \"atorrot\"", "assert orderlyQueue(\"zxyabc\", 5) == \"abcxyz\"", "assert orderlyQueue(\"xy\", 2) == \"xy\""]}, {"author": "Calvin", "UUID": "56b48f6d-0d81-478d-b838-4d47b62d3031", "question": "Given an integer n, return the number of strings of length n that consist only of vowels (a, e, i, o, u) and are lexicographically sorted.\n\nA string s is lexicographically sorted if for all valid i, s[i] is the same as or comes before s[i+1] in the alphabet.", "examples": "Input: 1\nOutput: 5\n\nInput: 2\nOutput: 15", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def helper(n, letter_idx):\n  letters = [\"a\",\"e\",\"i\",\"o\",\"u\"]\n  dynamic = {\n      'a1' : 5,\n      'e1' : 4,\n      'i1' : 3,\n      'o1' : 2,\n      'u1' : 1\n  }\n  ret = 0\n  key = letters[letter_idx] + str(n)\n  if key in dynamic.keys():\n    return dynamic[key]\n  else:\n    for i in range(letter_idx, len(letters)):\n      ret += helper(n-1, i)\n    dynamic[key] = ret\n  return ret\n  \n\ndef countVowelStrings(n: int) -> int:\n  return helper(n, 0)\n", "asserts": ["assert countVowelStrings(3) == 35", "assert countVowelStrings(4) == 70", "assert countVowelStrings(5) == 126", "assert countVowelStrings(6) == 210", "assert countVowelStrings(7) == 330", "assert countVowelStrings(10) == 1001", "assert countVowelStrings(15) == 3876"]}], "category": "String", "prompt_tokens": 745, "total_tokens": 1039, "completion_tokens": 294, "completion": "Given a string s, return the longest palindromic substring in s.\n\n###Code: \n\ndef longestPalindrome(s: str) -> str:\n    def expand_around_center(left: int, right: int) -> str:\n        while left >= 0 and right < len(s) and s[left] == s[right]:\n            left -= 1\n            right += 1\n        return s[left + 1:right]\n    \n    longest = \"\"\n    for i in range(len(s)):\n        # Odd length palindrome\n        odd_palindrome = expand_around_center(i, i)\n        if len(odd_palindrome) > len(longest):\n            longest = odd_palindrome\n        \n        # Even length palindrome\n        even_palindrome = expand_around_center(i, i + 1)\n        if len(even_palindrome) > len(longest):\n            longest = even_palindrome\n            \n    return longest\n\n###Testcases: \n\nassert longestPalindrome(\"babad\") == \"bab\" or longestPalindrome(\"babad\") == \"aba\"\nassert longestPalindrome(\"cbbd\") == \"bb\"\nassert longestPalindrome(\"a\") == \"a\"\nassert longestPalindrome(\"ac\") == \"a\" or longestPalindrome(\"ac\") == \"c\"\nassert longestPalindrome(\"abcda\") == \"a\"\nassert longestPalindrome(\"ccc\") == \"ccc\"\nassert longestPalindrome(\"eabcb\") == \"bcb\"\n\n[/Example 3]", "temperature": 0.748}, {"few_shots": [{"author": "Calvin", "UUID": "ac641352-08d5-4950-8993-6a143da92ecf", "question": "You are given a string s and an integer k. You can choose one of the first k letters of s and append it at the end of the string.\n\nReturn the lexicographically smallest string you could have after applying the mentioned step any number of moves.\n", "examples": "Input: s = \"cba\", k = 1\nOutput: \"acb\"\n\nInput: s = \"baaca\", k = 3\nOutput: \"aaabc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef orderlyQueue(s: str, k: int) -> str:\n    if k == 1:\n        n = len(s)\n        ss = s + s\n        lex_min_str = s\n        for i in range(n):\n            lex_min_str = min(lex_min_str, ss[i:i + n])\n        return lex_min_str\n    \n    return \"\".join(sorted(s))\n", "asserts": ["assert orderlyQueue(\"abcd\", 1) == \"abcd\"", "assert orderlyQueue(\"hello\", 2) == \"ehllo\"", "assert orderlyQueue(\"programming\", 1) == \"ammingprogr\"", "assert orderlyQueue(\"rotator\", 1) == \"atorrot\"", "assert orderlyQueue(\"zxyabc\", 5) == \"abcxyz\"", "assert orderlyQueue(\"xy\", 2) == \"xy\""]}, {"author": "Calvin", "UUID": "56b48f6d-0d81-478d-b838-4d47b62d3031", "question": "Given an integer n, return the number of strings of length n that consist only of vowels (a, e, i, o, u) and are lexicographically sorted.\n\nA string s is lexicographically sorted if for all valid i, s[i] is the same as or comes before s[i+1] in the alphabet.", "examples": "Input: 1\nOutput: 5\n\nInput: 2\nOutput: 15", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def helper(n, letter_idx):\n  letters = [\"a\",\"e\",\"i\",\"o\",\"u\"]\n  dynamic = {\n      'a1' : 5,\n      'e1' : 4,\n      'i1' : 3,\n      'o1' : 2,\n      'u1' : 1\n  }\n  ret = 0\n  key = letters[letter_idx] + str(n)\n  if key in dynamic.keys():\n    return dynamic[key]\n  else:\n    for i in range(letter_idx, len(letters)):\n      ret += helper(n-1, i)\n    dynamic[key] = ret\n  return ret\n  \n\ndef countVowelStrings(n: int) -> int:\n  return helper(n, 0)\n", "asserts": ["assert countVowelStrings(3) == 35", "assert countVowelStrings(4) == 70", "assert countVowelStrings(5) == 126", "assert countVowelStrings(6) == 210", "assert countVowelStrings(7) == 330", "assert countVowelStrings(10) == 1001", "assert countVowelStrings(15) == 3876"]}], "category": "String", "prompt_tokens": 745, "total_tokens": 1092, "completion_tokens": 347, "completion": "Given a string s, you need to find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.\n\n###Code: \n\ndef longestPalindrome(s: str) -> str:\n    if not s or len(s) < 1:\n        return \"\"\n    start, end = 0, 0\n    for i in range(len(s)):\n        len1 = expandAroundCenter(s, i, i)\n        len2 = expandAroundCenter(s, i, i + 1)\n        max_len = max(len1, len2)\n        if max_len > (end - start):\n            start = i - (max_len - 1) // 2\n            end = i + max_len // 2\n    return s[start:end + 1]\n\ndef expandAroundCenter(s, left, right):\n    L, R = left, right\n    while L >= 0 and R < len(s) and s[L] == s[R]:\n        L -= 1\n        R += 1\n    return R - L - 1\n\n###Testcases: \n\nassert longestPalindrome(\"babad\") == \"bab\" or longestPalindrome(\"babad\") == \"aba\"\nassert longestPalindrome(\"cbbd\") == \"bb\"\nassert longestPalindrome(\"a\") == \"a\"\nassert longestPalindrome(\"ac\") == \"a\" or longestPalindrome(\"ac\") == \"c\"\nassert longestPalindrome(\"abbcccbbbcaaccbababcbcabca\") == \"bbcccbb\"\nassert longestPalindrome(\"forgeeksskeegfor\") == \"geeksskeeg\"\nassert longestPalindrome(\"\") == \"\"\n\n[/Example 3]", "temperature": 0.766}, {"few_shots": [{"author": "Calvin", "UUID": "ac641352-08d5-4950-8993-6a143da92ecf", "question": "You are given a string s and an integer k. You can choose one of the first k letters of s and append it at the end of the string.\n\nReturn the lexicographically smallest string you could have after applying the mentioned step any number of moves.\n", "examples": "Input: s = \"cba\", k = 1\nOutput: \"acb\"\n\nInput: s = \"baaca\", k = 3\nOutput: \"aaabc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef orderlyQueue(s: str, k: int) -> str:\n    if k == 1:\n        n = len(s)\n        ss = s + s\n        lex_min_str = s\n        for i in range(n):\n            lex_min_str = min(lex_min_str, ss[i:i + n])\n        return lex_min_str\n    \n    return \"\".join(sorted(s))\n", "asserts": ["assert orderlyQueue(\"abcd\", 1) == \"abcd\"", "assert orderlyQueue(\"hello\", 2) == \"ehllo\"", "assert orderlyQueue(\"programming\", 1) == \"ammingprogr\"", "assert orderlyQueue(\"rotator\", 1) == \"atorrot\"", "assert orderlyQueue(\"zxyabc\", 5) == \"abcxyz\"", "assert orderlyQueue(\"xy\", 2) == \"xy\""]}, {"author": "Calvin", "UUID": "56b48f6d-0d81-478d-b838-4d47b62d3031", "question": "Given an integer n, return the number of strings of length n that consist only of vowels (a, e, i, o, u) and are lexicographically sorted.\n\nA string s is lexicographically sorted if for all valid i, s[i] is the same as or comes before s[i+1] in the alphabet.", "examples": "Input: 1\nOutput: 5\n\nInput: 2\nOutput: 15", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def helper(n, letter_idx):\n  letters = [\"a\",\"e\",\"i\",\"o\",\"u\"]\n  dynamic = {\n      'a1' : 5,\n      'e1' : 4,\n      'i1' : 3,\n      'o1' : 2,\n      'u1' : 1\n  }\n  ret = 0\n  key = letters[letter_idx] + str(n)\n  if key in dynamic.keys():\n    return dynamic[key]\n  else:\n    for i in range(letter_idx, len(letters)):\n      ret += helper(n-1, i)\n    dynamic[key] = ret\n  return ret\n  \n\ndef countVowelStrings(n: int) -> int:\n  return helper(n, 0)\n", "asserts": ["assert countVowelStrings(3) == 35", "assert countVowelStrings(4) == 70", "assert countVowelStrings(5) == 126", "assert countVowelStrings(6) == 210", "assert countVowelStrings(7) == 330", "assert countVowelStrings(10) == 1001", "assert countVowelStrings(15) == 3876"]}], "category": "String", "prompt_tokens": 745, "total_tokens": 1053, "completion_tokens": 308, "completion": "Write a function that takes a string and returns the longest palindromic substring in it.\n\nA palindrome is a word, phrase, number, or other sequence of characters which reads the same backward as forward.\n\n###Code: \n\ndef longestPalindrome(s: str) -> str:\n    def expandAroundCenter(left, right):\n        while left >= 0 and right < len(s) and s[left] == s[right]:\n            left -= 1\n            right += 1\n        return s[left + 1:right]\n    \n    if len(s) < 2 or s == s[::-1]:\n        return s\n    \n    max_palindrome = \"\"\n    for i in range(len(s) - 1):\n        palindrome_odd = expandAroundCenter(i, i)\n        palindrome_even = expandAroundCenter(i, i + 1)\n        \n        max_palindrome = max(palindrome_odd, palindrome_even, max_palindrome, key=len)\n    \n    return max_palindrome\n\n###Testcases: \n\nassert longestPalindrome(\"babad\") == \"bab\" or longestPalindrome(\"babad\") == \"aba\"\nassert longestPalindrome(\"cbbd\") == \"bb\"\nassert longestPalindrome(\"a\") == \"a\"\nassert longestPalindrome(\"ac\") == \"a\" or longestPalindrome(\"ac\") == \"c\"\nassert longestPalindrome(\"racecar\") == \"racecar\"\nassert longestPalindrome(\"noon\") == \"noon\"\nassert longestPalindrome(\"abcdefedcba\") == \"abcdefedcba\"\n\n[/Example 3]", "temperature": 0.65}, {"few_shots": [{"author": "Calvin", "UUID": "ac641352-08d5-4950-8993-6a143da92ecf", "question": "You are given a string s and an integer k. You can choose one of the first k letters of s and append it at the end of the string.\n\nReturn the lexicographically smallest string you could have after applying the mentioned step any number of moves.\n", "examples": "Input: s = \"cba\", k = 1\nOutput: \"acb\"\n\nInput: s = \"baaca\", k = 3\nOutput: \"aaabc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef orderlyQueue(s: str, k: int) -> str:\n    if k == 1:\n        n = len(s)\n        ss = s + s\n        lex_min_str = s\n        for i in range(n):\n            lex_min_str = min(lex_min_str, ss[i:i + n])\n        return lex_min_str\n    \n    return \"\".join(sorted(s))\n", "asserts": ["assert orderlyQueue(\"abcd\", 1) == \"abcd\"", "assert orderlyQueue(\"hello\", 2) == \"ehllo\"", "assert orderlyQueue(\"programming\", 1) == \"ammingprogr\"", "assert orderlyQueue(\"rotator\", 1) == \"atorrot\"", "assert orderlyQueue(\"zxyabc\", 5) == \"abcxyz\"", "assert orderlyQueue(\"xy\", 2) == \"xy\""]}, {"author": "Calvin", "UUID": "56b48f6d-0d81-478d-b838-4d47b62d3031", "question": "Given an integer n, return the number of strings of length n that consist only of vowels (a, e, i, o, u) and are lexicographically sorted.\n\nA string s is lexicographically sorted if for all valid i, s[i] is the same as or comes before s[i+1] in the alphabet.", "examples": "Input: 1\nOutput: 5\n\nInput: 2\nOutput: 15", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def helper(n, letter_idx):\n  letters = [\"a\",\"e\",\"i\",\"o\",\"u\"]\n  dynamic = {\n      'a1' : 5,\n      'e1' : 4,\n      'i1' : 3,\n      'o1' : 2,\n      'u1' : 1\n  }\n  ret = 0\n  key = letters[letter_idx] + str(n)\n  if key in dynamic.keys():\n    return dynamic[key]\n  else:\n    for i in range(letter_idx, len(letters)):\n      ret += helper(n-1, i)\n    dynamic[key] = ret\n  return ret\n  \n\ndef countVowelStrings(n: int) -> int:\n  return helper(n, 0)\n", "asserts": ["assert countVowelStrings(3) == 35", "assert countVowelStrings(4) == 70", "assert countVowelStrings(5) == 126", "assert countVowelStrings(6) == 210", "assert countVowelStrings(7) == 330", "assert countVowelStrings(10) == 1001", "assert countVowelStrings(15) == 3876"]}], "category": "String", "prompt_tokens": 745, "total_tokens": 983, "completion_tokens": 238, "completion": "Given a string s consisting of lowercase letters, check if it is possible to re-arrange the letters of s to get a palindrome. A palindrome is a word or phrase that reads the same backward as forward.\n\n###Code:\n\ndef canFormPalindrome(s: str) -> bool:\n    from collections import Counter\n    # Count the frequency of each character in the string\n    char_counter = Counter(s)\n    # Keep track of the number of characters with odd frequency\n    odd_count = sum(1 for count in char_counter.values() if count % 2 != 0)\n    # For a string to be rearranged into a palindrome, \n    # there should be at most one character with an odd frequency\n    return odd_count <= 1\n\n###Testcases:\n\nassert canFormPalindrome(\"a\") == True\nassert canFormPalindrome(\"ab\") == False\nassert canFormPalindrome(\"aab\") == True\nassert canFormPalindrome(\"carerac\") == True\nassert canFormPalindrome(\"racecar\") == True\nassert canFormPalindrome(\"bbaa\") == True\nassert canFormPalindrome(\"daily\") == False\n\n[/Example 3]", "temperature": 0.901}, {"few_shots": [{"author": "Calvin", "UUID": "ac641352-08d5-4950-8993-6a143da92ecf", "question": "You are given a string s and an integer k. You can choose one of the first k letters of s and append it at the end of the string.\n\nReturn the lexicographically smallest string you could have after applying the mentioned step any number of moves.\n", "examples": "Input: s = \"cba\", k = 1\nOutput: \"acb\"\n\nInput: s = \"baaca\", k = 3\nOutput: \"aaabc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef orderlyQueue(s: str, k: int) -> str:\n    if k == 1:\n        n = len(s)\n        ss = s + s\n        lex_min_str = s\n        for i in range(n):\n            lex_min_str = min(lex_min_str, ss[i:i + n])\n        return lex_min_str\n    \n    return \"\".join(sorted(s))\n", "asserts": ["assert orderlyQueue(\"abcd\", 1) == \"abcd\"", "assert orderlyQueue(\"hello\", 2) == \"ehllo\"", "assert orderlyQueue(\"programming\", 1) == \"ammingprogr\"", "assert orderlyQueue(\"rotator\", 1) == \"atorrot\"", "assert orderlyQueue(\"zxyabc\", 5) == \"abcxyz\"", "assert orderlyQueue(\"xy\", 2) == \"xy\""]}, {"author": "Calvin", "UUID": "56b48f6d-0d81-478d-b838-4d47b62d3031", "question": "Given an integer n, return the number of strings of length n that consist only of vowels (a, e, i, o, u) and are lexicographically sorted.\n\nA string s is lexicographically sorted if for all valid i, s[i] is the same as or comes before s[i+1] in the alphabet.", "examples": "Input: 1\nOutput: 5\n\nInput: 2\nOutput: 15", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def helper(n, letter_idx):\n  letters = [\"a\",\"e\",\"i\",\"o\",\"u\"]\n  dynamic = {\n      'a1' : 5,\n      'e1' : 4,\n      'i1' : 3,\n      'o1' : 2,\n      'u1' : 1\n  }\n  ret = 0\n  key = letters[letter_idx] + str(n)\n  if key in dynamic.keys():\n    return dynamic[key]\n  else:\n    for i in range(letter_idx, len(letters)):\n      ret += helper(n-1, i)\n    dynamic[key] = ret\n  return ret\n  \n\ndef countVowelStrings(n: int) -> int:\n  return helper(n, 0)\n", "asserts": ["assert countVowelStrings(3) == 35", "assert countVowelStrings(4) == 70", "assert countVowelStrings(5) == 126", "assert countVowelStrings(6) == 210", "assert countVowelStrings(7) == 330", "assert countVowelStrings(10) == 1001", "assert countVowelStrings(15) == 3876"]}], "category": "String", "prompt_tokens": 745, "total_tokens": 1029, "completion_tokens": 284, "completion": "Write a function that takes a string s and returns the longest palindromic substring in s.\n\n###Code: \n\ndef longestPalindrome(s: str) -> str:\n    def expandAroundCenter(left, right):\n        while left >= 0 and right < len(s) and s[left] == s[right]:\n            left -= 1\n            right += 1\n        return s[left+1:right]\n    \n    longest = \"\"\n    for i in range(len(s)):\n        # Odd length palindrome\n        odd_palindrome = expandAroundCenter(i, i)\n        if len(odd_palindrome) > len(longest):\n            longest = odd_palindrome\n        \n        # Even length palindrome\n        even_palindrome = expandAroundCenter(i, i+1)\n        if len(even_palindrome) > len(longest):\n            longest = even_palindrome\n            \n    return longest\n\n###Testcases: \n\nassert longestPalindrome(\"babad\") in [\"bab\", \"aba\"]\nassert longestPalindrome(\"cbbd\") == \"bb\"\nassert longestPalindrome(\"a\") == \"a\"\nassert longestPalindrome(\"ac\") in [\"a\", \"c\"]\nassert longestPalindrome(\"aa\") == \"aa\"\nassert longestPalindrome(\"tattarrattat\") == \"tattarrattat\"\nassert longestPalindrome(\"forgeeksskeegfor\") == \"geeksskeeg\"\n\n[/Example 3]", "temperature": 0.787}, {"few_shots": [{"author": "Calvin", "UUID": "ac641352-08d5-4950-8993-6a143da92ecf", "question": "You are given a string s and an integer k. You can choose one of the first k letters of s and append it at the end of the string.\n\nReturn the lexicographically smallest string you could have after applying the mentioned step any number of moves.\n", "examples": "Input: s = \"cba\", k = 1\nOutput: \"acb\"\n\nInput: s = \"baaca\", k = 3\nOutput: \"aaabc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef orderlyQueue(s: str, k: int) -> str:\n    if k == 1:\n        n = len(s)\n        ss = s + s\n        lex_min_str = s\n        for i in range(n):\n            lex_min_str = min(lex_min_str, ss[i:i + n])\n        return lex_min_str\n    \n    return \"\".join(sorted(s))\n", "asserts": ["assert orderlyQueue(\"abcd\", 1) == \"abcd\"", "assert orderlyQueue(\"hello\", 2) == \"ehllo\"", "assert orderlyQueue(\"programming\", 1) == \"ammingprogr\"", "assert orderlyQueue(\"rotator\", 1) == \"atorrot\"", "assert orderlyQueue(\"zxyabc\", 5) == \"abcxyz\"", "assert orderlyQueue(\"xy\", 2) == \"xy\""]}, {"author": "Calvin", "UUID": "56b48f6d-0d81-478d-b838-4d47b62d3031", "question": "Given an integer n, return the number of strings of length n that consist only of vowels (a, e, i, o, u) and are lexicographically sorted.\n\nA string s is lexicographically sorted if for all valid i, s[i] is the same as or comes before s[i+1] in the alphabet.", "examples": "Input: 1\nOutput: 5\n\nInput: 2\nOutput: 15", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def helper(n, letter_idx):\n  letters = [\"a\",\"e\",\"i\",\"o\",\"u\"]\n  dynamic = {\n      'a1' : 5,\n      'e1' : 4,\n      'i1' : 3,\n      'o1' : 2,\n      'u1' : 1\n  }\n  ret = 0\n  key = letters[letter_idx] + str(n)\n  if key in dynamic.keys():\n    return dynamic[key]\n  else:\n    for i in range(letter_idx, len(letters)):\n      ret += helper(n-1, i)\n    dynamic[key] = ret\n  return ret\n  \n\ndef countVowelStrings(n: int) -> int:\n  return helper(n, 0)\n", "asserts": ["assert countVowelStrings(3) == 35", "assert countVowelStrings(4) == 70", "assert countVowelStrings(5) == 126", "assert countVowelStrings(6) == 210", "assert countVowelStrings(7) == 330", "assert countVowelStrings(10) == 1001", "assert countVowelStrings(15) == 3876"]}], "category": "String", "prompt_tokens": 745, "total_tokens": 1155, "completion_tokens": 410, "completion": "Write a function that takes a string `s` and a non-empty string `p`, and returns all the start indices of `p`'s anagrams in `s`. You may return the answer in any order.\n\nAn Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.\n\n###Code: \n\ndef findAnagrams(s: str, p: str) -> list[int]:\n    from collections import Counter\n\n    def is_anagram(s_counter, p_counter):\n        for char in p_counter:\n            if p_counter[char] != s_counter.get(char, 0):\n                return False\n        return True\n\n    result = []\n    p_len = len(p)\n    p_counter = Counter(p)\n    s_counter = Counter(s[:p_len - 1])\n    \n    for i in range(p_len - 1, len(s)):\n        s_counter[s[i]] += 1  # include a new char in the window\n        if i >= p_len:\n            if s_counter[s[i - p_len]] == 1:\n                del s_counter[s[i - p_len]]  # remove the leftmost char from window\n            else:\n                s_counter[s[i - p_len]] -= 1\n        if is_anagram(s_counter, p_counter):\n            result.append(i - p_len + 1)\n    \n    return result\n\n###Testcases: \n\nassert findAnagrams(\"cbaebabacd\", \"abc\") == [0, 6]\nassert findAnagrams(\"abab\", \"ab\") == [0, 1, 2]\nassert findAnagrams(\"af\", \"be\") == []\nassert findAnagrams(\"acdcaeccde\", \"c\") == [1, 3, 6, 7]\nassert findAnagrams(\"bpaa\", \"aa\") == [2]\nassert findAnagrams(\"aaaaaaaaaa\", \"aaaaaaaaaaaaa\") == []\n\n[/Example 3]", "temperature": 0.675}, {"few_shots": [{"author": "Calvin", "UUID": "ac641352-08d5-4950-8993-6a143da92ecf", "question": "You are given a string s and an integer k. You can choose one of the first k letters of s and append it at the end of the string.\n\nReturn the lexicographically smallest string you could have after applying the mentioned step any number of moves.\n", "examples": "Input: s = \"cba\", k = 1\nOutput: \"acb\"\n\nInput: s = \"baaca\", k = 3\nOutput: \"aaabc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef orderlyQueue(s: str, k: int) -> str:\n    if k == 1:\n        n = len(s)\n        ss = s + s\n        lex_min_str = s\n        for i in range(n):\n            lex_min_str = min(lex_min_str, ss[i:i + n])\n        return lex_min_str\n    \n    return \"\".join(sorted(s))\n", "asserts": ["assert orderlyQueue(\"abcd\", 1) == \"abcd\"", "assert orderlyQueue(\"hello\", 2) == \"ehllo\"", "assert orderlyQueue(\"programming\", 1) == \"ammingprogr\"", "assert orderlyQueue(\"rotator\", 1) == \"atorrot\"", "assert orderlyQueue(\"zxyabc\", 5) == \"abcxyz\"", "assert orderlyQueue(\"xy\", 2) == \"xy\""]}, {"author": "Calvin", "UUID": "56b48f6d-0d81-478d-b838-4d47b62d3031", "question": "Given an integer n, return the number of strings of length n that consist only of vowels (a, e, i, o, u) and are lexicographically sorted.\n\nA string s is lexicographically sorted if for all valid i, s[i] is the same as or comes before s[i+1] in the alphabet.", "examples": "Input: 1\nOutput: 5\n\nInput: 2\nOutput: 15", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def helper(n, letter_idx):\n  letters = [\"a\",\"e\",\"i\",\"o\",\"u\"]\n  dynamic = {\n      'a1' : 5,\n      'e1' : 4,\n      'i1' : 3,\n      'o1' : 2,\n      'u1' : 1\n  }\n  ret = 0\n  key = letters[letter_idx] + str(n)\n  if key in dynamic.keys():\n    return dynamic[key]\n  else:\n    for i in range(letter_idx, len(letters)):\n      ret += helper(n-1, i)\n    dynamic[key] = ret\n  return ret\n  \n\ndef countVowelStrings(n: int) -> int:\n  return helper(n, 0)\n", "asserts": ["assert countVowelStrings(3) == 35", "assert countVowelStrings(4) == 70", "assert countVowelStrings(5) == 126", "assert countVowelStrings(6) == 210", "assert countVowelStrings(7) == 330", "assert countVowelStrings(10) == 1001", "assert countVowelStrings(15) == 3876"]}], "category": "String", "prompt_tokens": 745, "total_tokens": 1051, "completion_tokens": 306, "completion": "Implement a method `frequencySort(s)` that sorts the characters in a string `s` by the frequency of their occurrence. The sorting should be in descending order of frequency, and if two characters have the same frequency, they should be sorted in ascending order of their ASCII values.\n\n###Code:\n\n```python\nfrom collections import Counter\n\ndef frequencySort(s: str) -> str:\n    # Count the frequency of each character in the string\n    freq = Counter(s)\n    # Sort the characters by frequency and then by ASCII values\n    sorted_chars = sorted(freq, key=lambda x: (-freq[x], x))\n    # Build the result string\n    result = ''.join(char * freq[char] for char in sorted_chars)\n    return result\n\n###Testcases:\n\nassert frequencySort(\"tree\") == \"eert\"\nassert frequencySort(\"cccaaa\") == \"aaaccc\"\nassert frequencySort(\"Aabb\") == \"bbaA\"\nassert frequencySort(\"2a554442f544asfasssffffasss\") == \"sssssssffffff44444aaaa55522\"\nassert frequencySort(\"his s he a ha he  ha ae\") == \"        hhhhhieeeaaaesss\"\n```\n\nThis code counts the occurrences using `Counter` from `collections` module, then sorts the characters both by frequency (in descending order) and ASCII value (in ascending order), and finally constructs the resulting string by repeating characters according to their counted frequencies.\n\n[/Example 3]", "temperature": 0.822}, {"few_shots": [{"author": "Calvin", "UUID": "ac641352-08d5-4950-8993-6a143da92ecf", "question": "You are given a string s and an integer k. You can choose one of the first k letters of s and append it at the end of the string.\n\nReturn the lexicographically smallest string you could have after applying the mentioned step any number of moves.\n", "examples": "Input: s = \"cba\", k = 1\nOutput: \"acb\"\n\nInput: s = \"baaca\", k = 3\nOutput: \"aaabc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef orderlyQueue(s: str, k: int) -> str:\n    if k == 1:\n        n = len(s)\n        ss = s + s\n        lex_min_str = s\n        for i in range(n):\n            lex_min_str = min(lex_min_str, ss[i:i + n])\n        return lex_min_str\n    \n    return \"\".join(sorted(s))\n", "asserts": ["assert orderlyQueue(\"abcd\", 1) == \"abcd\"", "assert orderlyQueue(\"hello\", 2) == \"ehllo\"", "assert orderlyQueue(\"programming\", 1) == \"ammingprogr\"", "assert orderlyQueue(\"rotator\", 1) == \"atorrot\"", "assert orderlyQueue(\"zxyabc\", 5) == \"abcxyz\"", "assert orderlyQueue(\"xy\", 2) == \"xy\""]}, {"author": "Calvin", "UUID": "56b48f6d-0d81-478d-b838-4d47b62d3031", "question": "Given an integer n, return the number of strings of length n that consist only of vowels (a, e, i, o, u) and are lexicographically sorted.\n\nA string s is lexicographically sorted if for all valid i, s[i] is the same as or comes before s[i+1] in the alphabet.", "examples": "Input: 1\nOutput: 5\n\nInput: 2\nOutput: 15", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def helper(n, letter_idx):\n  letters = [\"a\",\"e\",\"i\",\"o\",\"u\"]\n  dynamic = {\n      'a1' : 5,\n      'e1' : 4,\n      'i1' : 3,\n      'o1' : 2,\n      'u1' : 1\n  }\n  ret = 0\n  key = letters[letter_idx] + str(n)\n  if key in dynamic.keys():\n    return dynamic[key]\n  else:\n    for i in range(letter_idx, len(letters)):\n      ret += helper(n-1, i)\n    dynamic[key] = ret\n  return ret\n  \n\ndef countVowelStrings(n: int) -> int:\n  return helper(n, 0)\n", "asserts": ["assert countVowelStrings(3) == 35", "assert countVowelStrings(4) == 70", "assert countVowelStrings(5) == 126", "assert countVowelStrings(6) == 210", "assert countVowelStrings(7) == 330", "assert countVowelStrings(10) == 1001", "assert countVowelStrings(15) == 3876"]}], "category": "String", "prompt_tokens": 745, "total_tokens": 964, "completion_tokens": 219, "completion": "Given a string s, find the length of the longest substring without repeating characters.\n\n###Code: \n\ndef lengthOfLongestSubstring(s: str) -> int:\n    char_index_map = {}\n    start = max_length = 0\n    \n    for end, char in enumerate(s):\n        if char in char_index_map and start <= char_index_map[char]:\n            start = char_index_map[char] + 1\n        \n        char_index_map[char] = end\n        max_length = max(max_length, end - start + 1)\n    \n    return max_length\n\n###Testcases: \n\nassert lengthOfLongestSubstring(\"abcabcbb\") == 3\nassert lengthOfLongestSubstring(\"bbbbb\") == 1\nassert lengthOfLongestSubstring(\"pwwkew\") == 3\nassert lengthOfLongestSubstring(\"\") == 0\nassert lengthOfLongestSubstring(\" \") == 1\nassert lengthOfLongestSubstring(\"au\") == 2\nassert lengthOfLongestSubstring(\"dvdf\") == 3\n\n[/Example 3]", "temperature": 0.844}, {"few_shots": [{"author": "Calvin", "UUID": "ac641352-08d5-4950-8993-6a143da92ecf", "question": "You are given a string s and an integer k. You can choose one of the first k letters of s and append it at the end of the string.\n\nReturn the lexicographically smallest string you could have after applying the mentioned step any number of moves.\n", "examples": "Input: s = \"cba\", k = 1\nOutput: \"acb\"\n\nInput: s = \"baaca\", k = 3\nOutput: \"aaabc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef orderlyQueue(s: str, k: int) -> str:\n    if k == 1:\n        n = len(s)\n        ss = s + s\n        lex_min_str = s\n        for i in range(n):\n            lex_min_str = min(lex_min_str, ss[i:i + n])\n        return lex_min_str\n    \n    return \"\".join(sorted(s))\n", "asserts": ["assert orderlyQueue(\"abcd\", 1) == \"abcd\"", "assert orderlyQueue(\"hello\", 2) == \"ehllo\"", "assert orderlyQueue(\"programming\", 1) == \"ammingprogr\"", "assert orderlyQueue(\"rotator\", 1) == \"atorrot\"", "assert orderlyQueue(\"zxyabc\", 5) == \"abcxyz\"", "assert orderlyQueue(\"xy\", 2) == \"xy\""]}, {"author": "Calvin", "UUID": "56b48f6d-0d81-478d-b838-4d47b62d3031", "question": "Given an integer n, return the number of strings of length n that consist only of vowels (a, e, i, o, u) and are lexicographically sorted.\n\nA string s is lexicographically sorted if for all valid i, s[i] is the same as or comes before s[i+1] in the alphabet.", "examples": "Input: 1\nOutput: 5\n\nInput: 2\nOutput: 15", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def helper(n, letter_idx):\n  letters = [\"a\",\"e\",\"i\",\"o\",\"u\"]\n  dynamic = {\n      'a1' : 5,\n      'e1' : 4,\n      'i1' : 3,\n      'o1' : 2,\n      'u1' : 1\n  }\n  ret = 0\n  key = letters[letter_idx] + str(n)\n  if key in dynamic.keys():\n    return dynamic[key]\n  else:\n    for i in range(letter_idx, len(letters)):\n      ret += helper(n-1, i)\n    dynamic[key] = ret\n  return ret\n  \n\ndef countVowelStrings(n: int) -> int:\n  return helper(n, 0)\n", "asserts": ["assert countVowelStrings(3) == 35", "assert countVowelStrings(4) == 70", "assert countVowelStrings(5) == 126", "assert countVowelStrings(6) == 210", "assert countVowelStrings(7) == 330", "assert countVowelStrings(10) == 1001", "assert countVowelStrings(15) == 3876"]}], "category": "String", "prompt_tokens": 745, "total_tokens": 990, "completion_tokens": 245, "completion": "Write a function that takes a string containing only lowercase letters and returns a string with the same letters arranged in descending order according to frequency. If two letters have the same frequency, then the letter which comes earlier in the alphabet should appear first.\n\n###Code:\n\ndef frequencySort(s: str) -> str:\n    from collections import Counter\n    count = Counter(s)\n    # Create a list of tuples sorted by frequency and then by the letter itself\n    sorted_items = sorted(count.items(), key=lambda x: (-x[1], x[0]))\n    # Form the final string\n    result = ''.join(letter * freq for letter, freq in sorted_items)\n    return result\n\n###Testcases:\n\nassert frequencySort(\"tree\") == \"eetr\"\nassert frequencySort(\"cccaaa\") == \"aaaccc\"\nassert frequencySort(\"Aabb\") == \"bbaA\"\nassert frequencySort(\"loveleetcode\") == \"eeeeloolvtcd\"\nassert frequencySort(\"testcase\") == \"eettsacs\"\nassert frequencySort(\"pointtopoint\") == \"ooiinnttpp\"\nassert frequencySort(\"frequency\") == \"eefqucrny\"\n\n[/Example 3]", "temperature": 0.941}, {"few_shots": [{"author": "Calvin", "UUID": "80e34b28-16a8-46ac-8b6a-ee28beb1e8d4", "question": "Write a function that reverses a string. The input string is given as an array of characters s.\n\nYou must do this by modifying the input array in-place with O(1) extra memory.", "examples": "Input: [\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput: [\"o\",\"l\",\"l\",\"e\",\"h\"]\n\nInput: [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\nOutput: [\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def reverse_string(s: list) -> list:\n  l = 0\n  r = len(s) - 1\n  while l < r:\n    tmp = s[l]\n    s[l] = s[r]\n    s[r] = tmp\n    l += 1\n    r -= 1\n  return s\n", "asserts": ["assert reverse_string([\"a\",\"b\",\"c\",\"d\"]) == [\"d\", \"c\", \"b\", \"a\"]", "assert reverse_string([\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"]) == [\"n\", \"o\", \"h\", \"t\", \"y\", \"p\"]", "assert reverse_string([]) == []", "assert reverse_string([\"s\", \"i\", \"n\", \"g\", \"l\", \"e\"]) == [\"e\", \"l\", \"g\", \"n\", \"i\", \"s\"]", "assert reverse_string([\"A\"]) == [\"A\"]", "assert reverse_string([\"9\", \"8\", \"7\", \"6\", \"5\", \"4\", \"3\", \"2\", \"1\"]) == [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]", "assert reverse_string([\"B\", \"o\", \"b\"]) == [\"b\", \"o\", \"B\"]", "assert reverse_string([\"r\", \"e\", \"v\", \"e\", \"r\", \"s\", \"e\"]) == [\"e\", \"s\", \"r\", \"e\", \"v\", \"e\", \"r\"]", "assert reverse_string([\"1\", \"*\", \"2\", \"*\", \"3\"]) == [\"3\", \"*\", \"2\", \"*\", \"1\"]"]}, {"author": "Calvin", "UUID": "ac641352-08d5-4950-8993-6a143da92ecf", "question": "You are given a string s and an integer k. You can choose one of the first k letters of s and append it at the end of the string.\n\nReturn the lexicographically smallest string you could have after applying the mentioned step any number of moves.\n", "examples": "Input: s = \"cba\", k = 1\nOutput: \"acb\"\n\nInput: s = \"baaca\", k = 3\nOutput: \"aaabc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef orderlyQueue(s: str, k: int) -> str:\n    if k == 1:\n        n = len(s)\n        ss = s + s\n        lex_min_str = s\n        for i in range(n):\n            lex_min_str = min(lex_min_str, ss[i:i + n])\n        return lex_min_str\n    \n    return \"\".join(sorted(s))\n", "asserts": ["assert orderlyQueue(\"abcd\", 1) == \"abcd\"", "assert orderlyQueue(\"hello\", 2) == \"ehllo\"", "assert orderlyQueue(\"programming\", 1) == \"ammingprogr\"", "assert orderlyQueue(\"rotator\", 1) == \"atorrot\"", "assert orderlyQueue(\"zxyabc\", 5) == \"abcxyz\"", "assert orderlyQueue(\"xy\", 2) == \"xy\""]}], "category": "String", "prompt_tokens": 814, "total_tokens": 1016, "completion_tokens": 202, "completion": "Write a function to check if a string contains just one unique character. The function should return `True` if all characters in the string are the same, and `False` otherwise. The input string will only contain lowercase English letters.\n\n###Code:\n\ndef is_unique_char_string(s: str) -> bool:\n    return len(set(s)) == 1 if s else False\n\n###Testcases:\n\nassert is_unique_char_string(\"aaaaaa\") == True\nassert is_unique_char_string(\"bbbb\") == True\nassert is_unique_char_string(\"ccccccccc\") == True\nassert is_unique_char_string(\"a\") == True\nassert is_unique_char_string(\"ab\") == False\nassert is_unique_char_string(\"aaab\") == False\nassert is_unique_char_string(\"\") == False\nassert is_unique_char_string(\"xyzxyz\") == False\nassert is_unique_char_string(\"pppppppp\") == True\nassert is_unique_char_string(\"101010\") == False\n\n[/Example 3]", "temperature": 0.705}, {"few_shots": [{"author": "Calvin", "UUID": "80e34b28-16a8-46ac-8b6a-ee28beb1e8d4", "question": "Write a function that reverses a string. The input string is given as an array of characters s.\n\nYou must do this by modifying the input array in-place with O(1) extra memory.", "examples": "Input: [\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput: [\"o\",\"l\",\"l\",\"e\",\"h\"]\n\nInput: [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\nOutput: [\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def reverse_string(s: list) -> list:\n  l = 0\n  r = len(s) - 1\n  while l < r:\n    tmp = s[l]\n    s[l] = s[r]\n    s[r] = tmp\n    l += 1\n    r -= 1\n  return s\n", "asserts": ["assert reverse_string([\"a\",\"b\",\"c\",\"d\"]) == [\"d\", \"c\", \"b\", \"a\"]", "assert reverse_string([\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"]) == [\"n\", \"o\", \"h\", \"t\", \"y\", \"p\"]", "assert reverse_string([]) == []", "assert reverse_string([\"s\", \"i\", \"n\", \"g\", \"l\", \"e\"]) == [\"e\", \"l\", \"g\", \"n\", \"i\", \"s\"]", "assert reverse_string([\"A\"]) == [\"A\"]", "assert reverse_string([\"9\", \"8\", \"7\", \"6\", \"5\", \"4\", \"3\", \"2\", \"1\"]) == [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]", "assert reverse_string([\"B\", \"o\", \"b\"]) == [\"b\", \"o\", \"B\"]", "assert reverse_string([\"r\", \"e\", \"v\", \"e\", \"r\", \"s\", \"e\"]) == [\"e\", \"s\", \"r\", \"e\", \"v\", \"e\", \"r\"]", "assert reverse_string([\"1\", \"*\", \"2\", \"*\", \"3\"]) == [\"3\", \"*\", \"2\", \"*\", \"1\"]"]}, {"author": "Calvin", "UUID": "ac641352-08d5-4950-8993-6a143da92ecf", "question": "You are given a string s and an integer k. You can choose one of the first k letters of s and append it at the end of the string.\n\nReturn the lexicographically smallest string you could have after applying the mentioned step any number of moves.\n", "examples": "Input: s = \"cba\", k = 1\nOutput: \"acb\"\n\nInput: s = \"baaca\", k = 3\nOutput: \"aaabc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef orderlyQueue(s: str, k: int) -> str:\n    if k == 1:\n        n = len(s)\n        ss = s + s\n        lex_min_str = s\n        for i in range(n):\n            lex_min_str = min(lex_min_str, ss[i:i + n])\n        return lex_min_str\n    \n    return \"\".join(sorted(s))\n", "asserts": ["assert orderlyQueue(\"abcd\", 1) == \"abcd\"", "assert orderlyQueue(\"hello\", 2) == \"ehllo\"", "assert orderlyQueue(\"programming\", 1) == \"ammingprogr\"", "assert orderlyQueue(\"rotator\", 1) == \"atorrot\"", "assert orderlyQueue(\"zxyabc\", 5) == \"abcxyz\"", "assert orderlyQueue(\"xy\", 2) == \"xy\""]}], "category": "String", "prompt_tokens": 814, "total_tokens": 1209, "completion_tokens": 395, "completion": "Given a string containing only three types of characters: '(', ')' and '*', write a function to check whether this string is valid. The function must return true if the string is valid, and false otherwise.\n\nA string is considered valid if all the following conditions are met:\n\n- Any left parenthesis '(' must have a corresponding right parenthesis ')'.\n- Any right parenthesis ')' must have a corresponding left parenthesis '('.\n- Left parenthesis '(' must go before the corresponding right parenthesis ')'.\n- '*' could be treated as a single right parenthesis ')' or a single left parenthesis '(' or an empty string.\n- An empty string is also considered valid.\n\n###Code:\n\n```python\ndef checkValidString(s: str) -> bool:\n    left_balance = right_balance = 0\n    n = len(s)\n    \n    for i in range(n):\n        # Consider '*' as '('\n        if s[i] in \"(*\":\n            left_balance += 1\n        else:\n            left_balance -= 1\n        \n        # Consider '*' as ')'\n        if s[n - i - 1] in \"*)\":\n            right_balance += 1\n        else:\n            right_balance -= 1\n        \n        # If we find more ')' than '(' in any direction, return False\n        if left_balance < 0 or right_balance < 0:\n            return False\n        \n    return True\n```\n\n###Testcases:\n\n```python\nassert checkValidString(\"()\") == True\nassert checkValidString(\"(*)\") == True\nassert checkValidString(\"(*))\") == True\nassert checkValidString(\"(*()\") == True\nassert checkValidString(\")()(\") == False\nassert checkValidString(\"(((**)\") == True\nassert checkValidString(\"\") == True\nassert checkValidString(\"((*)\") == True\nassert checkValidString(\"(*)))\") == False\nassert checkValidString(\")(\") == False\n```\n\n[/Example 3]", "temperature": 0.727}, {"few_shots": [{"author": "Calvin", "UUID": "80e34b28-16a8-46ac-8b6a-ee28beb1e8d4", "question": "Write a function that reverses a string. The input string is given as an array of characters s.\n\nYou must do this by modifying the input array in-place with O(1) extra memory.", "examples": "Input: [\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput: [\"o\",\"l\",\"l\",\"e\",\"h\"]\n\nInput: [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\nOutput: [\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def reverse_string(s: list) -> list:\n  l = 0\n  r = len(s) - 1\n  while l < r:\n    tmp = s[l]\n    s[l] = s[r]\n    s[r] = tmp\n    l += 1\n    r -= 1\n  return s\n", "asserts": ["assert reverse_string([\"a\",\"b\",\"c\",\"d\"]) == [\"d\", \"c\", \"b\", \"a\"]", "assert reverse_string([\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"]) == [\"n\", \"o\", \"h\", \"t\", \"y\", \"p\"]", "assert reverse_string([]) == []", "assert reverse_string([\"s\", \"i\", \"n\", \"g\", \"l\", \"e\"]) == [\"e\", \"l\", \"g\", \"n\", \"i\", \"s\"]", "assert reverse_string([\"A\"]) == [\"A\"]", "assert reverse_string([\"9\", \"8\", \"7\", \"6\", \"5\", \"4\", \"3\", \"2\", \"1\"]) == [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]", "assert reverse_string([\"B\", \"o\", \"b\"]) == [\"b\", \"o\", \"B\"]", "assert reverse_string([\"r\", \"e\", \"v\", \"e\", \"r\", \"s\", \"e\"]) == [\"e\", \"s\", \"r\", \"e\", \"v\", \"e\", \"r\"]", "assert reverse_string([\"1\", \"*\", \"2\", \"*\", \"3\"]) == [\"3\", \"*\", \"2\", \"*\", \"1\"]"]}, {"author": "Calvin", "UUID": "ac641352-08d5-4950-8993-6a143da92ecf", "question": "You are given a string s and an integer k. You can choose one of the first k letters of s and append it at the end of the string.\n\nReturn the lexicographically smallest string you could have after applying the mentioned step any number of moves.\n", "examples": "Input: s = \"cba\", k = 1\nOutput: \"acb\"\n\nInput: s = \"baaca\", k = 3\nOutput: \"aaabc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef orderlyQueue(s: str, k: int) -> str:\n    if k == 1:\n        n = len(s)\n        ss = s + s\n        lex_min_str = s\n        for i in range(n):\n            lex_min_str = min(lex_min_str, ss[i:i + n])\n        return lex_min_str\n    \n    return \"\".join(sorted(s))\n", "asserts": ["assert orderlyQueue(\"abcd\", 1) == \"abcd\"", "assert orderlyQueue(\"hello\", 2) == \"ehllo\"", "assert orderlyQueue(\"programming\", 1) == \"ammingprogr\"", "assert orderlyQueue(\"rotator\", 1) == \"atorrot\"", "assert orderlyQueue(\"zxyabc\", 5) == \"abcxyz\"", "assert orderlyQueue(\"xy\", 2) == \"xy\""]}], "category": "String", "prompt_tokens": 814, "total_tokens": 1069, "completion_tokens": 255, "completion": "Given a string s, find the length of the longest substring without repeating characters.\n\n###Code:\n\ndef length_of_longest_substring(s: str) -> int:\n    char_map = {}\n    left = 0\n    max_length = 0\n\n    for right in range(len(s)):\n        if s[right] in char_map:\n            left = max(left, char_map[s[right]] + 1)\n        char_map[s[right]] = right\n        max_length = max(max_length, right - left + 1)\n    \n    return max_length\n\n###Testcases:\n\nassert length_of_longest_substring(\"abcabcbb\") == 3\nassert length_of_longest_substring(\"bbbbb\") == 1\nassert length_of_longest_substring(\"pwwkew\") == 3\nassert length_of_longest_substring(\"\") == 0\nassert length_of_longest_substring(\" \") == 1\nassert length_of_longest_substring(\"au\") == 2\nassert length_of_longest_substring(\"dvdf\") == 3\nassert length_of_longest_substring(\"anviaj\") == 5\nassert length_of_longest_substring(\"abba\") == 2\n\n[/Example 3]", "temperature": 0.759}, {"few_shots": [{"author": "Calvin", "UUID": "80e34b28-16a8-46ac-8b6a-ee28beb1e8d4", "question": "Write a function that reverses a string. The input string is given as an array of characters s.\n\nYou must do this by modifying the input array in-place with O(1) extra memory.", "examples": "Input: [\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput: [\"o\",\"l\",\"l\",\"e\",\"h\"]\n\nInput: [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\nOutput: [\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def reverse_string(s: list) -> list:\n  l = 0\n  r = len(s) - 1\n  while l < r:\n    tmp = s[l]\n    s[l] = s[r]\n    s[r] = tmp\n    l += 1\n    r -= 1\n  return s\n", "asserts": ["assert reverse_string([\"a\",\"b\",\"c\",\"d\"]) == [\"d\", \"c\", \"b\", \"a\"]", "assert reverse_string([\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"]) == [\"n\", \"o\", \"h\", \"t\", \"y\", \"p\"]", "assert reverse_string([]) == []", "assert reverse_string([\"s\", \"i\", \"n\", \"g\", \"l\", \"e\"]) == [\"e\", \"l\", \"g\", \"n\", \"i\", \"s\"]", "assert reverse_string([\"A\"]) == [\"A\"]", "assert reverse_string([\"9\", \"8\", \"7\", \"6\", \"5\", \"4\", \"3\", \"2\", \"1\"]) == [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]", "assert reverse_string([\"B\", \"o\", \"b\"]) == [\"b\", \"o\", \"B\"]", "assert reverse_string([\"r\", \"e\", \"v\", \"e\", \"r\", \"s\", \"e\"]) == [\"e\", \"s\", \"r\", \"e\", \"v\", \"e\", \"r\"]", "assert reverse_string([\"1\", \"*\", \"2\", \"*\", \"3\"]) == [\"3\", \"*\", \"2\", \"*\", \"1\"]"]}, {"author": "Calvin", "UUID": "ac641352-08d5-4950-8993-6a143da92ecf", "question": "You are given a string s and an integer k. You can choose one of the first k letters of s and append it at the end of the string.\n\nReturn the lexicographically smallest string you could have after applying the mentioned step any number of moves.\n", "examples": "Input: s = \"cba\", k = 1\nOutput: \"acb\"\n\nInput: s = \"baaca\", k = 3\nOutput: \"aaabc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef orderlyQueue(s: str, k: int) -> str:\n    if k == 1:\n        n = len(s)\n        ss = s + s\n        lex_min_str = s\n        for i in range(n):\n            lex_min_str = min(lex_min_str, ss[i:i + n])\n        return lex_min_str\n    \n    return \"\".join(sorted(s))\n", "asserts": ["assert orderlyQueue(\"abcd\", 1) == \"abcd\"", "assert orderlyQueue(\"hello\", 2) == \"ehllo\"", "assert orderlyQueue(\"programming\", 1) == \"ammingprogr\"", "assert orderlyQueue(\"rotator\", 1) == \"atorrot\"", "assert orderlyQueue(\"zxyabc\", 5) == \"abcxyz\"", "assert orderlyQueue(\"xy\", 2) == \"xy\""]}], "category": "String", "prompt_tokens": 814, "total_tokens": 1065, "completion_tokens": 251, "completion": "Given a string s, find the first non-repeating character in it and return its index. If it does not exist, return -1.\n\n###Code: \n\ndef firstUniqChar(s: str) -> int:\n  frequency = {}\n  \n  for char in s:\n    if char in frequency:\n      frequency[char] += 1\n    else:\n      frequency[char] = 1\n\n  for index, char in enumerate(s):\n    if frequency[char] == 1:\n      return index\n\n  return -1\n\n###Testcases: \n\nassert firstUniqChar(\"leetcode\") == 0\nassert firstUniqChar(\"loveleetcode\") == 2\nassert firstUniqChar(\"aabb\") == -1\nassert firstUniqChar(\"algorithm\") == 0\nassert firstUniqChar(\"abcabcabd\") == 8\nassert firstUniqChar(\"aabccbd\") == 6\nassert firstUniqChar(\"aadb\") == 2\nassert firstUniqChar(\"z\") == 0\nassert firstUniqChar(\"dddccdbba\") == 8\nassert firstUniqChar(\"hopeforthebest\") == 0\n\n[/Example 3]", "temperature": 0.874}, {"few_shots": [{"author": "Calvin", "UUID": "80e34b28-16a8-46ac-8b6a-ee28beb1e8d4", "question": "Write a function that reverses a string. The input string is given as an array of characters s.\n\nYou must do this by modifying the input array in-place with O(1) extra memory.", "examples": "Input: [\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput: [\"o\",\"l\",\"l\",\"e\",\"h\"]\n\nInput: [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\nOutput: [\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def reverse_string(s: list) -> list:\n  l = 0\n  r = len(s) - 1\n  while l < r:\n    tmp = s[l]\n    s[l] = s[r]\n    s[r] = tmp\n    l += 1\n    r -= 1\n  return s\n", "asserts": ["assert reverse_string([\"a\",\"b\",\"c\",\"d\"]) == [\"d\", \"c\", \"b\", \"a\"]", "assert reverse_string([\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"]) == [\"n\", \"o\", \"h\", \"t\", \"y\", \"p\"]", "assert reverse_string([]) == []", "assert reverse_string([\"s\", \"i\", \"n\", \"g\", \"l\", \"e\"]) == [\"e\", \"l\", \"g\", \"n\", \"i\", \"s\"]", "assert reverse_string([\"A\"]) == [\"A\"]", "assert reverse_string([\"9\", \"8\", \"7\", \"6\", \"5\", \"4\", \"3\", \"2\", \"1\"]) == [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]", "assert reverse_string([\"B\", \"o\", \"b\"]) == [\"b\", \"o\", \"B\"]", "assert reverse_string([\"r\", \"e\", \"v\", \"e\", \"r\", \"s\", \"e\"]) == [\"e\", \"s\", \"r\", \"e\", \"v\", \"e\", \"r\"]", "assert reverse_string([\"1\", \"*\", \"2\", \"*\", \"3\"]) == [\"3\", \"*\", \"2\", \"*\", \"1\"]"]}, {"author": "Calvin", "UUID": "ac641352-08d5-4950-8993-6a143da92ecf", "question": "You are given a string s and an integer k. You can choose one of the first k letters of s and append it at the end of the string.\n\nReturn the lexicographically smallest string you could have after applying the mentioned step any number of moves.\n", "examples": "Input: s = \"cba\", k = 1\nOutput: \"acb\"\n\nInput: s = \"baaca\", k = 3\nOutput: \"aaabc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef orderlyQueue(s: str, k: int) -> str:\n    if k == 1:\n        n = len(s)\n        ss = s + s\n        lex_min_str = s\n        for i in range(n):\n            lex_min_str = min(lex_min_str, ss[i:i + n])\n        return lex_min_str\n    \n    return \"\".join(sorted(s))\n", "asserts": ["assert orderlyQueue(\"abcd\", 1) == \"abcd\"", "assert orderlyQueue(\"hello\", 2) == \"ehllo\"", "assert orderlyQueue(\"programming\", 1) == \"ammingprogr\"", "assert orderlyQueue(\"rotator\", 1) == \"atorrot\"", "assert orderlyQueue(\"zxyabc\", 5) == \"abcxyz\"", "assert orderlyQueue(\"xy\", 2) == \"xy\""]}], "category": "String", "prompt_tokens": 814, "total_tokens": 1054, "completion_tokens": 240, "completion": "Create a function that checks if a string is a palindrome. A palindrome is a word, number, phrase, or other sequence of characters that reads the same forward and backward (ignoring spaces, punctuation, and capitalization).\n\n###Code:\n\ndef is_palindrome(s: str) -> bool:\n    clean_s = ''.join(c for c in s.lower() if c.isalnum())\n    return clean_s == clean_s[::-1]\n\n###Testcases:\n\nassert is_palindrome(\"A man, a plan, a canal: Panama\") == True\nassert is_palindrome(\"race a car\") == False\nassert is_palindrome(\" \") == True\nassert is_palindrome(\"No lemon, no melon\") == True\nassert is_palindrome(\"Was it a car or a cat I saw?\") == True\nassert is_palindrome(\"Madam In Eden, I\u2019m Adam\") == True\nassert is_palindrome(\"Never odd or even.\") == True\nassert is_palindrome(\"12321\") == True\nassert is_palindrome(\"123421\") == False\nassert is_palindrome(\"Able was I, I saw Elba\") == True\n\n[/Example 3]", "temperature": 0.824}, {"few_shots": [{"author": "Calvin", "UUID": "80e34b28-16a8-46ac-8b6a-ee28beb1e8d4", "question": "Write a function that reverses a string. The input string is given as an array of characters s.\n\nYou must do this by modifying the input array in-place with O(1) extra memory.", "examples": "Input: [\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput: [\"o\",\"l\",\"l\",\"e\",\"h\"]\n\nInput: [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\nOutput: [\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def reverse_string(s: list) -> list:\n  l = 0\n  r = len(s) - 1\n  while l < r:\n    tmp = s[l]\n    s[l] = s[r]\n    s[r] = tmp\n    l += 1\n    r -= 1\n  return s\n", "asserts": ["assert reverse_string([\"a\",\"b\",\"c\",\"d\"]) == [\"d\", \"c\", \"b\", \"a\"]", "assert reverse_string([\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"]) == [\"n\", \"o\", \"h\", \"t\", \"y\", \"p\"]", "assert reverse_string([]) == []", "assert reverse_string([\"s\", \"i\", \"n\", \"g\", \"l\", \"e\"]) == [\"e\", \"l\", \"g\", \"n\", \"i\", \"s\"]", "assert reverse_string([\"A\"]) == [\"A\"]", "assert reverse_string([\"9\", \"8\", \"7\", \"6\", \"5\", \"4\", \"3\", \"2\", \"1\"]) == [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]", "assert reverse_string([\"B\", \"o\", \"b\"]) == [\"b\", \"o\", \"B\"]", "assert reverse_string([\"r\", \"e\", \"v\", \"e\", \"r\", \"s\", \"e\"]) == [\"e\", \"s\", \"r\", \"e\", \"v\", \"e\", \"r\"]", "assert reverse_string([\"1\", \"*\", \"2\", \"*\", \"3\"]) == [\"3\", \"*\", \"2\", \"*\", \"1\"]"]}, {"author": "Calvin", "UUID": "ac641352-08d5-4950-8993-6a143da92ecf", "question": "You are given a string s and an integer k. You can choose one of the first k letters of s and append it at the end of the string.\n\nReturn the lexicographically smallest string you could have after applying the mentioned step any number of moves.\n", "examples": "Input: s = \"cba\", k = 1\nOutput: \"acb\"\n\nInput: s = \"baaca\", k = 3\nOutput: \"aaabc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef orderlyQueue(s: str, k: int) -> str:\n    if k == 1:\n        n = len(s)\n        ss = s + s\n        lex_min_str = s\n        for i in range(n):\n            lex_min_str = min(lex_min_str, ss[i:i + n])\n        return lex_min_str\n    \n    return \"\".join(sorted(s))\n", "asserts": ["assert orderlyQueue(\"abcd\", 1) == \"abcd\"", "assert orderlyQueue(\"hello\", 2) == \"ehllo\"", "assert orderlyQueue(\"programming\", 1) == \"ammingprogr\"", "assert orderlyQueue(\"rotator\", 1) == \"atorrot\"", "assert orderlyQueue(\"zxyabc\", 5) == \"abcxyz\"", "assert orderlyQueue(\"xy\", 2) == \"xy\""]}], "category": "String", "prompt_tokens": 814, "total_tokens": 1067, "completion_tokens": 253, "completion": "Write a function to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string \"\".\n\n###Code: \n\ndef longest_common_prefix(strs: list) -> str:\n    if not strs:\n        return \"\"\n\n    shortest = min(strs, key=len)\n\n    for i, char in enumerate(shortest):\n        for other in strs:\n            if other[i] != char:\n                return shortest[:i]\n    \n    return shortest\n\n\n###Testcases: \n\nassert longest_common_prefix([\"flower\",\"flow\",\"flight\"]) == \"fl\"\nassert longest_common_prefix([\"dog\",\"racecar\",\"car\"]) == \"\"\nassert longest_common_prefix([\"interspecies\",\"interstellar\",\"interstate\"]) == \"inters\"\nassert longest_common_prefix([\"throne\",\"throne\"]) == \"throne\"\nassert longest_common_prefix([\"throne\"]) == \"throne\"\nassert longest_common_prefix([]) == \"\"\nassert longest_common_prefix([\"cheese\"]) == \"cheese\"\nassert longest_common_prefix([\"patch\",\"path\",\"pacifier\"]) == \"pa\"\nassert longest_common_prefix([\"sparrow\",\"spear\",\"speed\"]) == \"sp\"\nassert longest_common_prefix([\"butterfly\"]) == \"butterfly\"\n\n[/Example 3]", "temperature": 0.838}, {"few_shots": [{"author": "Calvin", "UUID": "80e34b28-16a8-46ac-8b6a-ee28beb1e8d4", "question": "Write a function that reverses a string. The input string is given as an array of characters s.\n\nYou must do this by modifying the input array in-place with O(1) extra memory.", "examples": "Input: [\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput: [\"o\",\"l\",\"l\",\"e\",\"h\"]\n\nInput: [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\nOutput: [\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def reverse_string(s: list) -> list:\n  l = 0\n  r = len(s) - 1\n  while l < r:\n    tmp = s[l]\n    s[l] = s[r]\n    s[r] = tmp\n    l += 1\n    r -= 1\n  return s\n", "asserts": ["assert reverse_string([\"a\",\"b\",\"c\",\"d\"]) == [\"d\", \"c\", \"b\", \"a\"]", "assert reverse_string([\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"]) == [\"n\", \"o\", \"h\", \"t\", \"y\", \"p\"]", "assert reverse_string([]) == []", "assert reverse_string([\"s\", \"i\", \"n\", \"g\", \"l\", \"e\"]) == [\"e\", \"l\", \"g\", \"n\", \"i\", \"s\"]", "assert reverse_string([\"A\"]) == [\"A\"]", "assert reverse_string([\"9\", \"8\", \"7\", \"6\", \"5\", \"4\", \"3\", \"2\", \"1\"]) == [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]", "assert reverse_string([\"B\", \"o\", \"b\"]) == [\"b\", \"o\", \"B\"]", "assert reverse_string([\"r\", \"e\", \"v\", \"e\", \"r\", \"s\", \"e\"]) == [\"e\", \"s\", \"r\", \"e\", \"v\", \"e\", \"r\"]", "assert reverse_string([\"1\", \"*\", \"2\", \"*\", \"3\"]) == [\"3\", \"*\", \"2\", \"*\", \"1\"]"]}, {"author": "Calvin", "UUID": "ac641352-08d5-4950-8993-6a143da92ecf", "question": "You are given a string s and an integer k. You can choose one of the first k letters of s and append it at the end of the string.\n\nReturn the lexicographically smallest string you could have after applying the mentioned step any number of moves.\n", "examples": "Input: s = \"cba\", k = 1\nOutput: \"acb\"\n\nInput: s = \"baaca\", k = 3\nOutput: \"aaabc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef orderlyQueue(s: str, k: int) -> str:\n    if k == 1:\n        n = len(s)\n        ss = s + s\n        lex_min_str = s\n        for i in range(n):\n            lex_min_str = min(lex_min_str, ss[i:i + n])\n        return lex_min_str\n    \n    return \"\".join(sorted(s))\n", "asserts": ["assert orderlyQueue(\"abcd\", 1) == \"abcd\"", "assert orderlyQueue(\"hello\", 2) == \"ehllo\"", "assert orderlyQueue(\"programming\", 1) == \"ammingprogr\"", "assert orderlyQueue(\"rotator\", 1) == \"atorrot\"", "assert orderlyQueue(\"zxyabc\", 5) == \"abcxyz\"", "assert orderlyQueue(\"xy\", 2) == \"xy\""]}], "category": "String", "prompt_tokens": 814, "total_tokens": 1135, "completion_tokens": 321, "completion": "Write a function that takes a string s and returns the longest palindrome that can be constructed by deleting some of the characters from s. If there are multiple longest palindromes of the same length, return the one that appears first in the input string.\n\n###Code:\n\ndef longest_palindrome(s: str) -> str:\n    def helper(left, right):\n        while left >= 0 and right < len(s) and s[left] == s[right]:\n            left -= 1\n            right += 1\n        return s[left + 1:right]\n\n    result = \"\"\n    for i in range(len(s)):\n        # Odd length palindrome\n        temp = helper(i, i)\n        if len(temp) > len(result):\n            result = temp\n        # Even length palindrome\n        temp = helper(i, i + 1)\n        if len(temp) > len(result):\n            result = temp\n    return result\n\n###Testcases:\n\nassert longest_palindrome(\"abaxyzzyxf\") == \"xyzzyx\"\nassert longest_palindrome(\"racecarannakayak\") == \"racecar\"\nassert longest_palindrome(\"abc\") == \"a\"\nassert longest_palindrome(\"a\") == \"a\"\nassert longest_palindrome(\"abccba\") == \"abccba\"\nassert longest_palindrome(\"abacdfgdcaba\") == \"aba\"\nassert longest_palindrome(\"abacdfgdcabba\") == \"abba\"\nassert longest_palindrome(\"abacdedcaba\") == \"abacdedcaba\"\n\n[/Example 3]", "temperature": 0.805}, {"few_shots": [{"author": "Calvin", "UUID": "80e34b28-16a8-46ac-8b6a-ee28beb1e8d4", "question": "Write a function that reverses a string. The input string is given as an array of characters s.\n\nYou must do this by modifying the input array in-place with O(1) extra memory.", "examples": "Input: [\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput: [\"o\",\"l\",\"l\",\"e\",\"h\"]\n\nInput: [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\nOutput: [\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def reverse_string(s: list) -> list:\n  l = 0\n  r = len(s) - 1\n  while l < r:\n    tmp = s[l]\n    s[l] = s[r]\n    s[r] = tmp\n    l += 1\n    r -= 1\n  return s\n", "asserts": ["assert reverse_string([\"a\",\"b\",\"c\",\"d\"]) == [\"d\", \"c\", \"b\", \"a\"]", "assert reverse_string([\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"]) == [\"n\", \"o\", \"h\", \"t\", \"y\", \"p\"]", "assert reverse_string([]) == []", "assert reverse_string([\"s\", \"i\", \"n\", \"g\", \"l\", \"e\"]) == [\"e\", \"l\", \"g\", \"n\", \"i\", \"s\"]", "assert reverse_string([\"A\"]) == [\"A\"]", "assert reverse_string([\"9\", \"8\", \"7\", \"6\", \"5\", \"4\", \"3\", \"2\", \"1\"]) == [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]", "assert reverse_string([\"B\", \"o\", \"b\"]) == [\"b\", \"o\", \"B\"]", "assert reverse_string([\"r\", \"e\", \"v\", \"e\", \"r\", \"s\", \"e\"]) == [\"e\", \"s\", \"r\", \"e\", \"v\", \"e\", \"r\"]", "assert reverse_string([\"1\", \"*\", \"2\", \"*\", \"3\"]) == [\"3\", \"*\", \"2\", \"*\", \"1\"]"]}, {"author": "Calvin", "UUID": "ac641352-08d5-4950-8993-6a143da92ecf", "question": "You are given a string s and an integer k. You can choose one of the first k letters of s and append it at the end of the string.\n\nReturn the lexicographically smallest string you could have after applying the mentioned step any number of moves.\n", "examples": "Input: s = \"cba\", k = 1\nOutput: \"acb\"\n\nInput: s = \"baaca\", k = 3\nOutput: \"aaabc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef orderlyQueue(s: str, k: int) -> str:\n    if k == 1:\n        n = len(s)\n        ss = s + s\n        lex_min_str = s\n        for i in range(n):\n            lex_min_str = min(lex_min_str, ss[i:i + n])\n        return lex_min_str\n    \n    return \"\".join(sorted(s))\n", "asserts": ["assert orderlyQueue(\"abcd\", 1) == \"abcd\"", "assert orderlyQueue(\"hello\", 2) == \"ehllo\"", "assert orderlyQueue(\"programming\", 1) == \"ammingprogr\"", "assert orderlyQueue(\"rotator\", 1) == \"atorrot\"", "assert orderlyQueue(\"zxyabc\", 5) == \"abcxyz\"", "assert orderlyQueue(\"xy\", 2) == \"xy\""]}], "category": "String", "prompt_tokens": 814, "total_tokens": 1100, "completion_tokens": 286, "completion": "Implement a function that transforms a sentence by reversing the characters of each word without reversing the word order itself.\n\n###Code: \n\ndef reverse_words_in_sentence(sentence: str) -> str:\n    words = sentence.split()\n    reversed_words = [word[::-1] for word in words]\n    reversed_sentence = ' '.join(reversed_words)\n    return reversed_sentence\n\n###Testcases: \n\nassert reverse_words_in_sentence(\"Let's take LeetCode contest\") == \"s'teL ekat edoCteeL tsetnoc\"\nassert reverse_words_in_sentence(\"God Ding\") == \"doG gniD\"\nassert reverse_words_in_sentence(\"Welcome to the jungle\") == \"emocleW ot eht elgnuj\"\nassert reverse_words_in_sentence(\"The quick brown fox jumps over the lazy dog\") == \"ehT kciuq nworb xof spmuj revo eht yzal god\"\nassert reverse_words_in_sentence(\"Keep calm and code on\") == \"peeK mlac dna edoc no\"\nassert reverse_words_in_sentence(\"Challenge everything\") == \"egnellahC gnihtyreve\"\nassert reverse_words_in_sentence(\" \") == \" \"\nassert reverse_words_in_sentence(\"a b c d\") == \"a b c d\"\nassert reverse_words_in_sentence(\"Double  spaces\") == \"elbuoD  secaps\"\n\n[/Example 3]", "temperature": 0.854}, {"few_shots": [{"author": "Calvin", "UUID": "80e34b28-16a8-46ac-8b6a-ee28beb1e8d4", "question": "Write a function that reverses a string. The input string is given as an array of characters s.\n\nYou must do this by modifying the input array in-place with O(1) extra memory.", "examples": "Input: [\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput: [\"o\",\"l\",\"l\",\"e\",\"h\"]\n\nInput: [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\nOutput: [\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def reverse_string(s: list) -> list:\n  l = 0\n  r = len(s) - 1\n  while l < r:\n    tmp = s[l]\n    s[l] = s[r]\n    s[r] = tmp\n    l += 1\n    r -= 1\n  return s\n", "asserts": ["assert reverse_string([\"a\",\"b\",\"c\",\"d\"]) == [\"d\", \"c\", \"b\", \"a\"]", "assert reverse_string([\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"]) == [\"n\", \"o\", \"h\", \"t\", \"y\", \"p\"]", "assert reverse_string([]) == []", "assert reverse_string([\"s\", \"i\", \"n\", \"g\", \"l\", \"e\"]) == [\"e\", \"l\", \"g\", \"n\", \"i\", \"s\"]", "assert reverse_string([\"A\"]) == [\"A\"]", "assert reverse_string([\"9\", \"8\", \"7\", \"6\", \"5\", \"4\", \"3\", \"2\", \"1\"]) == [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]", "assert reverse_string([\"B\", \"o\", \"b\"]) == [\"b\", \"o\", \"B\"]", "assert reverse_string([\"r\", \"e\", \"v\", \"e\", \"r\", \"s\", \"e\"]) == [\"e\", \"s\", \"r\", \"e\", \"v\", \"e\", \"r\"]", "assert reverse_string([\"1\", \"*\", \"2\", \"*\", \"3\"]) == [\"3\", \"*\", \"2\", \"*\", \"1\"]"]}, {"author": "Calvin", "UUID": "ac641352-08d5-4950-8993-6a143da92ecf", "question": "You are given a string s and an integer k. You can choose one of the first k letters of s and append it at the end of the string.\n\nReturn the lexicographically smallest string you could have after applying the mentioned step any number of moves.\n", "examples": "Input: s = \"cba\", k = 1\nOutput: \"acb\"\n\nInput: s = \"baaca\", k = 3\nOutput: \"aaabc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef orderlyQueue(s: str, k: int) -> str:\n    if k == 1:\n        n = len(s)\n        ss = s + s\n        lex_min_str = s\n        for i in range(n):\n            lex_min_str = min(lex_min_str, ss[i:i + n])\n        return lex_min_str\n    \n    return \"\".join(sorted(s))\n", "asserts": ["assert orderlyQueue(\"abcd\", 1) == \"abcd\"", "assert orderlyQueue(\"hello\", 2) == \"ehllo\"", "assert orderlyQueue(\"programming\", 1) == \"ammingprogr\"", "assert orderlyQueue(\"rotator\", 1) == \"atorrot\"", "assert orderlyQueue(\"zxyabc\", 5) == \"abcxyz\"", "assert orderlyQueue(\"xy\", 2) == \"xy\""]}], "category": "String", "prompt_tokens": 814, "total_tokens": 1042, "completion_tokens": 228, "completion": "Write a function to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string \"\".\n\n###Code:\n\ndef longest_common_prefix(strs: list) -> str:\n    if not strs:\n        return \"\"\n    shortest = min(strs, key=len)\n    for i, char in enumerate(shortest):\n        for other in strs:\n            if other[i] != char:\n                return shortest[:i]\n    return shortest\n\n###Testcases:\n\nassert longest_common_prefix([\"flower\",\"flow\",\"flight\"]) == \"fl\"\nassert longest_common_prefix([\"dog\",\"racecar\",\"car\"]) == \"\"\nassert longest_common_prefix([\"interspecies\",\"interstellar\",\"interstate\"]) == \"inters\"\nassert longest_common_prefix([]) == \"\"\nassert longest_common_prefix([\"\"]) == \"\"\nassert longest_common_prefix([\"a\"]) == \"a\"\nassert longest_common_prefix([\"reflower\",\"flow\",\"flight\"]) == \"\"\nassert longest_common_prefix([\"ant\",\"anthology\",\"antonym\"]) == \"ant\"\nassert longest_common_prefix([\"prefix\",\"preform\",\"preponderant\"]) == \"pre\"\n\n[/Example 3]", "temperature": 0.915}, {"few_shots": [{"author": "Calvin", "UUID": "80e34b28-16a8-46ac-8b6a-ee28beb1e8d4", "question": "Write a function that reverses a string. The input string is given as an array of characters s.\n\nYou must do this by modifying the input array in-place with O(1) extra memory.", "examples": "Input: [\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput: [\"o\",\"l\",\"l\",\"e\",\"h\"]\n\nInput: [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\nOutput: [\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def reverse_string(s: list) -> list:\n  l = 0\n  r = len(s) - 1\n  while l < r:\n    tmp = s[l]\n    s[l] = s[r]\n    s[r] = tmp\n    l += 1\n    r -= 1\n  return s\n", "asserts": ["assert reverse_string([\"a\",\"b\",\"c\",\"d\"]) == [\"d\", \"c\", \"b\", \"a\"]", "assert reverse_string([\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"]) == [\"n\", \"o\", \"h\", \"t\", \"y\", \"p\"]", "assert reverse_string([]) == []", "assert reverse_string([\"s\", \"i\", \"n\", \"g\", \"l\", \"e\"]) == [\"e\", \"l\", \"g\", \"n\", \"i\", \"s\"]", "assert reverse_string([\"A\"]) == [\"A\"]", "assert reverse_string([\"9\", \"8\", \"7\", \"6\", \"5\", \"4\", \"3\", \"2\", \"1\"]) == [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]", "assert reverse_string([\"B\", \"o\", \"b\"]) == [\"b\", \"o\", \"B\"]", "assert reverse_string([\"r\", \"e\", \"v\", \"e\", \"r\", \"s\", \"e\"]) == [\"e\", \"s\", \"r\", \"e\", \"v\", \"e\", \"r\"]", "assert reverse_string([\"1\", \"*\", \"2\", \"*\", \"3\"]) == [\"3\", \"*\", \"2\", \"*\", \"1\"]"]}, {"author": "Calvin", "UUID": "d0ce7430-cfcd-4c69-b161-b3b2a186422c", "question": "Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.\n\nIn other words, return true if one of s1's permutations is the substring of s2.", "examples": "Input: s1 = \"ab\", s2 = \"eidbaooo\"\nOutput: True\n\nInput: s1 = \"ab\", s2 = \"eidboaoo\"\nOutput: False", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef permutation_in_string(s1: str, s2: str) -> bool:\n  window = len(s1)\n  if window > len(s2):\n    return False\n  freq1 = [0]*26\n  freq2 = [0]*26\n  for i in range(window):\n    freq1[ord(s1[i])-ord('a')] += 1\n    freq2[ord(s2[i])-ord('a')] += 1\n\n  matches = 0\n  for i in range(26):\n    if freq1[i] == freq2[i]:\n      matches += 1\n  \n  for l in range(len(s2) - window):\n    if matches == 26:\n      return True\n\n    added = ord(s2[l + window]) - ord('a')\n    freq2[added] += 1\n    if freq1[added] == freq2[added]:\n      matches += 1\n    elif freq1[added] + 1 == freq2[added]:\n      matches -= 1\n\n    removed = ord(s2[l]) - ord('a')\n    freq2[removed] -= 1\n    if freq1[removed] == freq2[removed]:\n      matches += 1\n    elif freq1[removed] == freq2[removed] + 1:\n      matches -= 1\n    \n  return matches == 26\n", "asserts": ["assert permutation_in_string(\"hello\", \"ooollehhhhh\") == True", "assert permutation_in_string(\"abc\", \"ccccbbbbaaaa\") == False", "assert permutation_in_string(\"xyz\", \"zxyopqrstuv\") == True", "assert permutation_in_string(\"xyz\", \"xzygxzyzxyzk\") == True", "assert permutation_in_string(\"a\", \"a\") == True", "assert permutation_in_string(\"adc\", \"dcda\") == True", "assert permutation_in_string(\"pq\", \"qpqqp\") == True", "assert permutation_in_string(\"kitten\", \"sittingkite\") == False", "assert permutation_in_string(\"pq\", \"pqpqr\") == True", "assert permutation_in_string(\"aba\", \"aabaabaa\") == True", "assert permutation_in_string(\"\", \"\") == True  # Edge case: both strings are empty", "assert permutation_in_string(\"longerstring\", \"short\") == False  # s1 is longer than s2", "assert permutation_in_string(\"a\", \"b\") == False  # Single character, no match", "assert permutation_in_string(\"aab\", \"baa\") == True  # s1 is a permutation of s2", "assert permutation_in_string(\"ab\", \"a\") == False  # s2 is shorter than s1", "assert permutation_in_string(\"ba\", \"eidbaooo\") == True  # Same characters as Example 1 but different permutation", "assert permutation_in_string(\"eid\", \"eidbaooo\") == True  # s1 is a prefix of s2", "assert permutation_in_string(\"ooo\", \"eidbaooo\") == True  # s1 is a suffix of s2", "assert permutation_in_string(\"db\", \"eidbaooo\") == True  # s1 is a permutation within s2", "assert permutation_in_string(\"eidoo\", \"eidbaooo\") == False  # s1 is longer than any permutation within s2"]}], "category": "String", "prompt_tokens": 1324, "total_tokens": 1777, "completion_tokens": 453, "completion": "Given a string s consisting of uppercase English letters, return the length of the longest palindrome that can be built with those letters.\n\nLetters are case sensitive, meaning \"Aa\" is not considered a palindrome here.\n\n###Code: \n\n```python\ndef longest_palindrome(s: str) -> int:\n    letter_counts = {}\n    for char in s:\n        letter_counts[char] = letter_counts.get(char, 0) + 1\n    \n    length = 0\n    odd_found = False\n    for count in letter_counts.values():\n        if count % 2 == 0:\n            length += count\n        else:\n            length += count - 1\n            odd_found = True\n    \n    if odd_found:\n        length += 1\n    \n    return length\n```\n\n###Testcases: \n\n```python\nassert longest_palindrome(\"ABCCBA\") == 6\nassert longest_palindrome(\"AABBCC\") == 6\nassert longest_palindrome(\"AAABBB\") == 5\nassert longest_palindrome(\"A\") == 1\nassert longest_palindrome(\"ABC\") == 1\nassert longest_palindrome(\"ABCCCCDD\") == 7\nassert longest_palindrome(\"a\") == 1\nassert longest_palindrome(\"\") == 0\nassert longest_palindrome(\"Aa\") == 1\nassert longest_palindrome(\"ABABAB\") == 5\nassert longest_palindrome(\"NAMAN\") == 5\nassert longest_palindrome(\"QQQ\") == 3\nassert longest_palindrome(\"ZZZZCD\") == 5\nassert longest_palindrome(\"XYZABCDDCBA\") == 9\nassert longest_palindrome(\"XXYYZZZ\") == 7\nassert longest_palindrome(\"XXYYZZZXXX\") == 9\nassert longest_palindrome(\"ABABABABAB\") == 9\nassert longest_palindrome(\"ABACADAEAFAGAHAIAJA\") == 1\nassert longest_palindrome(\"ABACADAEAFAGAHAIABA\") == 17\nassert longest_palindrome(\"AAAAAAAAAA\") == 10\nassert longest_palindrome(\"ABCDEFGHIJKL\") == 1\n```\n\n[/Example 3]", "temperature": 0.662}, {"few_shots": [{"author": "Calvin", "UUID": "80e34b28-16a8-46ac-8b6a-ee28beb1e8d4", "question": "Write a function that reverses a string. The input string is given as an array of characters s.\n\nYou must do this by modifying the input array in-place with O(1) extra memory.", "examples": "Input: [\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput: [\"o\",\"l\",\"l\",\"e\",\"h\"]\n\nInput: [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\nOutput: [\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def reverse_string(s: list) -> list:\n  l = 0\n  r = len(s) - 1\n  while l < r:\n    tmp = s[l]\n    s[l] = s[r]\n    s[r] = tmp\n    l += 1\n    r -= 1\n  return s\n", "asserts": ["assert reverse_string([\"a\",\"b\",\"c\",\"d\"]) == [\"d\", \"c\", \"b\", \"a\"]", "assert reverse_string([\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"]) == [\"n\", \"o\", \"h\", \"t\", \"y\", \"p\"]", "assert reverse_string([]) == []", "assert reverse_string([\"s\", \"i\", \"n\", \"g\", \"l\", \"e\"]) == [\"e\", \"l\", \"g\", \"n\", \"i\", \"s\"]", "assert reverse_string([\"A\"]) == [\"A\"]", "assert reverse_string([\"9\", \"8\", \"7\", \"6\", \"5\", \"4\", \"3\", \"2\", \"1\"]) == [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]", "assert reverse_string([\"B\", \"o\", \"b\"]) == [\"b\", \"o\", \"B\"]", "assert reverse_string([\"r\", \"e\", \"v\", \"e\", \"r\", \"s\", \"e\"]) == [\"e\", \"s\", \"r\", \"e\", \"v\", \"e\", \"r\"]", "assert reverse_string([\"1\", \"*\", \"2\", \"*\", \"3\"]) == [\"3\", \"*\", \"2\", \"*\", \"1\"]"]}, {"author": "Calvin", "UUID": "d0ce7430-cfcd-4c69-b161-b3b2a186422c", "question": "Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.\n\nIn other words, return true if one of s1's permutations is the substring of s2.", "examples": "Input: s1 = \"ab\", s2 = \"eidbaooo\"\nOutput: True\n\nInput: s1 = \"ab\", s2 = \"eidboaoo\"\nOutput: False", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef permutation_in_string(s1: str, s2: str) -> bool:\n  window = len(s1)\n  if window > len(s2):\n    return False\n  freq1 = [0]*26\n  freq2 = [0]*26\n  for i in range(window):\n    freq1[ord(s1[i])-ord('a')] += 1\n    freq2[ord(s2[i])-ord('a')] += 1\n\n  matches = 0\n  for i in range(26):\n    if freq1[i] == freq2[i]:\n      matches += 1\n  \n  for l in range(len(s2) - window):\n    if matches == 26:\n      return True\n\n    added = ord(s2[l + window]) - ord('a')\n    freq2[added] += 1\n    if freq1[added] == freq2[added]:\n      matches += 1\n    elif freq1[added] + 1 == freq2[added]:\n      matches -= 1\n\n    removed = ord(s2[l]) - ord('a')\n    freq2[removed] -= 1\n    if freq1[removed] == freq2[removed]:\n      matches += 1\n    elif freq1[removed] == freq2[removed] + 1:\n      matches -= 1\n    \n  return matches == 26\n", "asserts": ["assert permutation_in_string(\"hello\", \"ooollehhhhh\") == True", "assert permutation_in_string(\"abc\", \"ccccbbbbaaaa\") == False", "assert permutation_in_string(\"xyz\", \"zxyopqrstuv\") == True", "assert permutation_in_string(\"xyz\", \"xzygxzyzxyzk\") == True", "assert permutation_in_string(\"a\", \"a\") == True", "assert permutation_in_string(\"adc\", \"dcda\") == True", "assert permutation_in_string(\"pq\", \"qpqqp\") == True", "assert permutation_in_string(\"kitten\", \"sittingkite\") == False", "assert permutation_in_string(\"pq\", \"pqpqr\") == True", "assert permutation_in_string(\"aba\", \"aabaabaa\") == True", "assert permutation_in_string(\"\", \"\") == True  # Edge case: both strings are empty", "assert permutation_in_string(\"longerstring\", \"short\") == False  # s1 is longer than s2", "assert permutation_in_string(\"a\", \"b\") == False  # Single character, no match", "assert permutation_in_string(\"aab\", \"baa\") == True  # s1 is a permutation of s2", "assert permutation_in_string(\"ab\", \"a\") == False  # s2 is shorter than s1", "assert permutation_in_string(\"ba\", \"eidbaooo\") == True  # Same characters as Example 1 but different permutation", "assert permutation_in_string(\"eid\", \"eidbaooo\") == True  # s1 is a prefix of s2", "assert permutation_in_string(\"ooo\", \"eidbaooo\") == True  # s1 is a suffix of s2", "assert permutation_in_string(\"db\", \"eidbaooo\") == True  # s1 is a permutation within s2", "assert permutation_in_string(\"eidoo\", \"eidbaooo\") == False  # s1 is longer than any permutation within s2"]}], "category": "String", "prompt_tokens": 1324, "total_tokens": 1658, "completion_tokens": 334, "completion": "Generate a function that checks whether a string is a valid palindrome. A string is a palindrome if it reads the same backward as forward. \n\nFor this function, consider only alphanumeric characters and ignore cases. The function should return a boolean indicating whether the input string is a palindrome or not.\n\n###Code: \n\ndef is_palindrome(s: str) -> bool:\n  cleaned = [c.lower() for c in s if c.isalnum()]\n  return cleaned == cleaned[::-1]\n\n###Testcases: \n\nassert is_palindrome(\"A man, a plan, a canal: Panama\") == True\nassert is_palindrome(\"race a car\") == False\nassert is_palindrome(\"\") == True  # Edge case: empty string\nassert is_palindrome(\" \") == True  # Edge case: string with only whitespaces\nassert is_palindrome(\"racecar\") == True\nassert is_palindrome(\"No lemon, no melon\") == True\nassert is_palindrome(\"Was it a car or a cat I saw?\") == True\nassert is_palindrome(\"A Santa at Nasa\") == True\nassert is_palindrome(\"Never odd or even\") == True\nassert is_palindrome(\"909\") == True\nassert is_palindrome(\"Not a palindrome\") == False\nassert is_palindrome(\"12321\") == True\nassert is_palindrome(\"123456\") == False\nassert is_palindrome(\"Madam\") == True\nassert is_palindrome(\"Step on no pets\") == True\nassert is_palindrome(\"Top spot\") == True\nassert is_palindrome(\"1a2\") == False\n\n[/Example 3]", "temperature": 0.919}, {"few_shots": [{"author": "Calvin", "UUID": "80e34b28-16a8-46ac-8b6a-ee28beb1e8d4", "question": "Write a function that reverses a string. The input string is given as an array of characters s.\n\nYou must do this by modifying the input array in-place with O(1) extra memory.", "examples": "Input: [\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput: [\"o\",\"l\",\"l\",\"e\",\"h\"]\n\nInput: [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\nOutput: [\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def reverse_string(s: list) -> list:\n  l = 0\n  r = len(s) - 1\n  while l < r:\n    tmp = s[l]\n    s[l] = s[r]\n    s[r] = tmp\n    l += 1\n    r -= 1\n  return s\n", "asserts": ["assert reverse_string([\"a\",\"b\",\"c\",\"d\"]) == [\"d\", \"c\", \"b\", \"a\"]", "assert reverse_string([\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"]) == [\"n\", \"o\", \"h\", \"t\", \"y\", \"p\"]", "assert reverse_string([]) == []", "assert reverse_string([\"s\", \"i\", \"n\", \"g\", \"l\", \"e\"]) == [\"e\", \"l\", \"g\", \"n\", \"i\", \"s\"]", "assert reverse_string([\"A\"]) == [\"A\"]", "assert reverse_string([\"9\", \"8\", \"7\", \"6\", \"5\", \"4\", \"3\", \"2\", \"1\"]) == [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]", "assert reverse_string([\"B\", \"o\", \"b\"]) == [\"b\", \"o\", \"B\"]", "assert reverse_string([\"r\", \"e\", \"v\", \"e\", \"r\", \"s\", \"e\"]) == [\"e\", \"s\", \"r\", \"e\", \"v\", \"e\", \"r\"]", "assert reverse_string([\"1\", \"*\", \"2\", \"*\", \"3\"]) == [\"3\", \"*\", \"2\", \"*\", \"1\"]"]}, {"author": "Calvin", "UUID": "d0ce7430-cfcd-4c69-b161-b3b2a186422c", "question": "Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.\n\nIn other words, return true if one of s1's permutations is the substring of s2.", "examples": "Input: s1 = \"ab\", s2 = \"eidbaooo\"\nOutput: True\n\nInput: s1 = \"ab\", s2 = \"eidboaoo\"\nOutput: False", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef permutation_in_string(s1: str, s2: str) -> bool:\n  window = len(s1)\n  if window > len(s2):\n    return False\n  freq1 = [0]*26\n  freq2 = [0]*26\n  for i in range(window):\n    freq1[ord(s1[i])-ord('a')] += 1\n    freq2[ord(s2[i])-ord('a')] += 1\n\n  matches = 0\n  for i in range(26):\n    if freq1[i] == freq2[i]:\n      matches += 1\n  \n  for l in range(len(s2) - window):\n    if matches == 26:\n      return True\n\n    added = ord(s2[l + window]) - ord('a')\n    freq2[added] += 1\n    if freq1[added] == freq2[added]:\n      matches += 1\n    elif freq1[added] + 1 == freq2[added]:\n      matches -= 1\n\n    removed = ord(s2[l]) - ord('a')\n    freq2[removed] -= 1\n    if freq1[removed] == freq2[removed]:\n      matches += 1\n    elif freq1[removed] == freq2[removed] + 1:\n      matches -= 1\n    \n  return matches == 26\n", "asserts": ["assert permutation_in_string(\"hello\", \"ooollehhhhh\") == True", "assert permutation_in_string(\"abc\", \"ccccbbbbaaaa\") == False", "assert permutation_in_string(\"xyz\", \"zxyopqrstuv\") == True", "assert permutation_in_string(\"xyz\", \"xzygxzyzxyzk\") == True", "assert permutation_in_string(\"a\", \"a\") == True", "assert permutation_in_string(\"adc\", \"dcda\") == True", "assert permutation_in_string(\"pq\", \"qpqqp\") == True", "assert permutation_in_string(\"kitten\", \"sittingkite\") == False", "assert permutation_in_string(\"pq\", \"pqpqr\") == True", "assert permutation_in_string(\"aba\", \"aabaabaa\") == True", "assert permutation_in_string(\"\", \"\") == True  # Edge case: both strings are empty", "assert permutation_in_string(\"longerstring\", \"short\") == False  # s1 is longer than s2", "assert permutation_in_string(\"a\", \"b\") == False  # Single character, no match", "assert permutation_in_string(\"aab\", \"baa\") == True  # s1 is a permutation of s2", "assert permutation_in_string(\"ab\", \"a\") == False  # s2 is shorter than s1", "assert permutation_in_string(\"ba\", \"eidbaooo\") == True  # Same characters as Example 1 but different permutation", "assert permutation_in_string(\"eid\", \"eidbaooo\") == True  # s1 is a prefix of s2", "assert permutation_in_string(\"ooo\", \"eidbaooo\") == True  # s1 is a suffix of s2", "assert permutation_in_string(\"db\", \"eidbaooo\") == True  # s1 is a permutation within s2", "assert permutation_in_string(\"eidoo\", \"eidbaooo\") == False  # s1 is longer than any permutation within s2"]}], "category": "String", "prompt_tokens": 1324, "total_tokens": 1732, "completion_tokens": 408, "completion": "Write a function to find the first non-repeating character in a given string and return its index. If it doesn't exist, return -1.\n\n###Code:\n\n```python\ndef first_uniq_char(s: str) -> int:\n    # Using a dictionary to store the frequency of each character\n    frequency = {}\n    for char in s:\n        frequency[char] = frequency.get(char, 0) + 1\n    # Iterate over the string to find the first unique character\n    for index, char in enumerate(s):\n        if frequency[char] == 1:\n            return index\n    return -1\n```\n\n###Testcases:\n\n```python\nassert first_uniq_char(\"leetcode\") == 0\nassert first_uniq_char(\"loveleetcode\") == 2\nassert first_uniq_char(\"aabb\") == -1\nassert first_uniq_char(\"algorithm\") == 0\nassert first_uniq_char(\"python\") == 0\nassert first_uniq_char(\"abracadabra\") == 4\nassert first_uniq_char(\"sos\") == 1\nassert first_uniq_char(\"level\") == -1\nassert first_uniq_char(\"l\") == 0\nassert first_uniq_char(\"\") == -1  # Edge case: Empty string\nassert first_uniq_char(\"repeat\") == 5\nassert first_uniq_char(\"swiss\") == 0\nassert first_uniq_char(\"barbados\") == 2\nassert first_uniq_char(\"civic\") == -1\nassert first_uniq_char(\"stress\") == 2\nassert first_uniq_char(\"z\") == 0\nassert first_uniq_char(\"aaabcccdeeef\") == 11\nassert first_uniq_char(\"abcabcabc\") == -1\nassert first_uniq_char(\"aabcc\") == 2\nassert first_uniq_char(\"aabbccddee\") == -1\n```\n\n[/Example 3]", "temperature": 0.738}, {"few_shots": [{"author": "Calvin", "UUID": "80e34b28-16a8-46ac-8b6a-ee28beb1e8d4", "question": "Write a function that reverses a string. The input string is given as an array of characters s.\n\nYou must do this by modifying the input array in-place with O(1) extra memory.", "examples": "Input: [\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput: [\"o\",\"l\",\"l\",\"e\",\"h\"]\n\nInput: [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\nOutput: [\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def reverse_string(s: list) -> list:\n  l = 0\n  r = len(s) - 1\n  while l < r:\n    tmp = s[l]\n    s[l] = s[r]\n    s[r] = tmp\n    l += 1\n    r -= 1\n  return s\n", "asserts": ["assert reverse_string([\"a\",\"b\",\"c\",\"d\"]) == [\"d\", \"c\", \"b\", \"a\"]", "assert reverse_string([\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"]) == [\"n\", \"o\", \"h\", \"t\", \"y\", \"p\"]", "assert reverse_string([]) == []", "assert reverse_string([\"s\", \"i\", \"n\", \"g\", \"l\", \"e\"]) == [\"e\", \"l\", \"g\", \"n\", \"i\", \"s\"]", "assert reverse_string([\"A\"]) == [\"A\"]", "assert reverse_string([\"9\", \"8\", \"7\", \"6\", \"5\", \"4\", \"3\", \"2\", \"1\"]) == [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]", "assert reverse_string([\"B\", \"o\", \"b\"]) == [\"b\", \"o\", \"B\"]", "assert reverse_string([\"r\", \"e\", \"v\", \"e\", \"r\", \"s\", \"e\"]) == [\"e\", \"s\", \"r\", \"e\", \"v\", \"e\", \"r\"]", "assert reverse_string([\"1\", \"*\", \"2\", \"*\", \"3\"]) == [\"3\", \"*\", \"2\", \"*\", \"1\"]"]}, {"author": "Calvin", "UUID": "d0ce7430-cfcd-4c69-b161-b3b2a186422c", "question": "Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.\n\nIn other words, return true if one of s1's permutations is the substring of s2.", "examples": "Input: s1 = \"ab\", s2 = \"eidbaooo\"\nOutput: True\n\nInput: s1 = \"ab\", s2 = \"eidboaoo\"\nOutput: False", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef permutation_in_string(s1: str, s2: str) -> bool:\n  window = len(s1)\n  if window > len(s2):\n    return False\n  freq1 = [0]*26\n  freq2 = [0]*26\n  for i in range(window):\n    freq1[ord(s1[i])-ord('a')] += 1\n    freq2[ord(s2[i])-ord('a')] += 1\n\n  matches = 0\n  for i in range(26):\n    if freq1[i] == freq2[i]:\n      matches += 1\n  \n  for l in range(len(s2) - window):\n    if matches == 26:\n      return True\n\n    added = ord(s2[l + window]) - ord('a')\n    freq2[added] += 1\n    if freq1[added] == freq2[added]:\n      matches += 1\n    elif freq1[added] + 1 == freq2[added]:\n      matches -= 1\n\n    removed = ord(s2[l]) - ord('a')\n    freq2[removed] -= 1\n    if freq1[removed] == freq2[removed]:\n      matches += 1\n    elif freq1[removed] == freq2[removed] + 1:\n      matches -= 1\n    \n  return matches == 26\n", "asserts": ["assert permutation_in_string(\"hello\", \"ooollehhhhh\") == True", "assert permutation_in_string(\"abc\", \"ccccbbbbaaaa\") == False", "assert permutation_in_string(\"xyz\", \"zxyopqrstuv\") == True", "assert permutation_in_string(\"xyz\", \"xzygxzyzxyzk\") == True", "assert permutation_in_string(\"a\", \"a\") == True", "assert permutation_in_string(\"adc\", \"dcda\") == True", "assert permutation_in_string(\"pq\", \"qpqqp\") == True", "assert permutation_in_string(\"kitten\", \"sittingkite\") == False", "assert permutation_in_string(\"pq\", \"pqpqr\") == True", "assert permutation_in_string(\"aba\", \"aabaabaa\") == True", "assert permutation_in_string(\"\", \"\") == True  # Edge case: both strings are empty", "assert permutation_in_string(\"longerstring\", \"short\") == False  # s1 is longer than s2", "assert permutation_in_string(\"a\", \"b\") == False  # Single character, no match", "assert permutation_in_string(\"aab\", \"baa\") == True  # s1 is a permutation of s2", "assert permutation_in_string(\"ab\", \"a\") == False  # s2 is shorter than s1", "assert permutation_in_string(\"ba\", \"eidbaooo\") == True  # Same characters as Example 1 but different permutation", "assert permutation_in_string(\"eid\", \"eidbaooo\") == True  # s1 is a prefix of s2", "assert permutation_in_string(\"ooo\", \"eidbaooo\") == True  # s1 is a suffix of s2", "assert permutation_in_string(\"db\", \"eidbaooo\") == True  # s1 is a permutation within s2", "assert permutation_in_string(\"eidoo\", \"eidbaooo\") == False  # s1 is longer than any permutation within s2"]}], "category": "String", "prompt_tokens": 1324, "total_tokens": 1669, "completion_tokens": 345, "completion": "Write a function to check if a string is a palindrome. A string is a palindrome if it reads the same backward as forward.\n\n###Code: \n\ndef is_palindrome(s: str) -> bool:\n  l, r = 0, len(s) - 1\n  while l < r:\n    if s[l] != s[r]:\n      return False\n    l += 1\n    r -= 1\n  return True\n\n###Testcases: \n\nassert is_palindrome(\"racecar\") == True\nassert is_palindrome(\"level\") == True\nassert is_palindrome(\"hello\") == False\nassert is_palindrome(\"deified\") == True\nassert is_palindrome(\"civic\") == True\nassert is_palindrome(\"radar\") == True\nassert is_palindrome(\"refer\") == True\nassert is_palindrome(\"A\") == True\nassert is_palindrome(\"1234321\") == True\nassert is_palindrome(\"123456\") == False\nassert is_palindrome(\"\") == True  # Edge case: empty string should be considered a palindrome\nassert is_palindrome(\"No lemon, no melon\") == False  # Including punctuation and spaces, it's not a palindrome\nassert is_palindrome(\"Was it a car or a cat I saw\") == False  # Including punctuation and spaces, it's not a palindrome\nassert is_palindrome(\"Madam, in Eden, I\u2019m Adam\") == False  # Including punctuation and spaces, it's not a palindrome\nassert is_palindrome(\"Able was I, I saw Elba\") == False  # Including punctuation and spaces, it's not a palindrome\n\n[/Example 3]", "temperature": 0.724}, {"few_shots": [{"author": "Calvin", "UUID": "80e34b28-16a8-46ac-8b6a-ee28beb1e8d4", "question": "Write a function that reverses a string. The input string is given as an array of characters s.\n\nYou must do this by modifying the input array in-place with O(1) extra memory.", "examples": "Input: [\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput: [\"o\",\"l\",\"l\",\"e\",\"h\"]\n\nInput: [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\nOutput: [\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def reverse_string(s: list) -> list:\n  l = 0\n  r = len(s) - 1\n  while l < r:\n    tmp = s[l]\n    s[l] = s[r]\n    s[r] = tmp\n    l += 1\n    r -= 1\n  return s\n", "asserts": ["assert reverse_string([\"a\",\"b\",\"c\",\"d\"]) == [\"d\", \"c\", \"b\", \"a\"]", "assert reverse_string([\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"]) == [\"n\", \"o\", \"h\", \"t\", \"y\", \"p\"]", "assert reverse_string([]) == []", "assert reverse_string([\"s\", \"i\", \"n\", \"g\", \"l\", \"e\"]) == [\"e\", \"l\", \"g\", \"n\", \"i\", \"s\"]", "assert reverse_string([\"A\"]) == [\"A\"]", "assert reverse_string([\"9\", \"8\", \"7\", \"6\", \"5\", \"4\", \"3\", \"2\", \"1\"]) == [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]", "assert reverse_string([\"B\", \"o\", \"b\"]) == [\"b\", \"o\", \"B\"]", "assert reverse_string([\"r\", \"e\", \"v\", \"e\", \"r\", \"s\", \"e\"]) == [\"e\", \"s\", \"r\", \"e\", \"v\", \"e\", \"r\"]", "assert reverse_string([\"1\", \"*\", \"2\", \"*\", \"3\"]) == [\"3\", \"*\", \"2\", \"*\", \"1\"]"]}, {"author": "Calvin", "UUID": "d0ce7430-cfcd-4c69-b161-b3b2a186422c", "question": "Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.\n\nIn other words, return true if one of s1's permutations is the substring of s2.", "examples": "Input: s1 = \"ab\", s2 = \"eidbaooo\"\nOutput: True\n\nInput: s1 = \"ab\", s2 = \"eidboaoo\"\nOutput: False", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef permutation_in_string(s1: str, s2: str) -> bool:\n  window = len(s1)\n  if window > len(s2):\n    return False\n  freq1 = [0]*26\n  freq2 = [0]*26\n  for i in range(window):\n    freq1[ord(s1[i])-ord('a')] += 1\n    freq2[ord(s2[i])-ord('a')] += 1\n\n  matches = 0\n  for i in range(26):\n    if freq1[i] == freq2[i]:\n      matches += 1\n  \n  for l in range(len(s2) - window):\n    if matches == 26:\n      return True\n\n    added = ord(s2[l + window]) - ord('a')\n    freq2[added] += 1\n    if freq1[added] == freq2[added]:\n      matches += 1\n    elif freq1[added] + 1 == freq2[added]:\n      matches -= 1\n\n    removed = ord(s2[l]) - ord('a')\n    freq2[removed] -= 1\n    if freq1[removed] == freq2[removed]:\n      matches += 1\n    elif freq1[removed] == freq2[removed] + 1:\n      matches -= 1\n    \n  return matches == 26\n", "asserts": ["assert permutation_in_string(\"hello\", \"ooollehhhhh\") == True", "assert permutation_in_string(\"abc\", \"ccccbbbbaaaa\") == False", "assert permutation_in_string(\"xyz\", \"zxyopqrstuv\") == True", "assert permutation_in_string(\"xyz\", \"xzygxzyzxyzk\") == True", "assert permutation_in_string(\"a\", \"a\") == True", "assert permutation_in_string(\"adc\", \"dcda\") == True", "assert permutation_in_string(\"pq\", \"qpqqp\") == True", "assert permutation_in_string(\"kitten\", \"sittingkite\") == False", "assert permutation_in_string(\"pq\", \"pqpqr\") == True", "assert permutation_in_string(\"aba\", \"aabaabaa\") == True", "assert permutation_in_string(\"\", \"\") == True  # Edge case: both strings are empty", "assert permutation_in_string(\"longerstring\", \"short\") == False  # s1 is longer than s2", "assert permutation_in_string(\"a\", \"b\") == False  # Single character, no match", "assert permutation_in_string(\"aab\", \"baa\") == True  # s1 is a permutation of s2", "assert permutation_in_string(\"ab\", \"a\") == False  # s2 is shorter than s1", "assert permutation_in_string(\"ba\", \"eidbaooo\") == True  # Same characters as Example 1 but different permutation", "assert permutation_in_string(\"eid\", \"eidbaooo\") == True  # s1 is a prefix of s2", "assert permutation_in_string(\"ooo\", \"eidbaooo\") == True  # s1 is a suffix of s2", "assert permutation_in_string(\"db\", \"eidbaooo\") == True  # s1 is a permutation within s2", "assert permutation_in_string(\"eidoo\", \"eidbaooo\") == False  # s1 is longer than any permutation within s2"]}], "category": "String", "prompt_tokens": 1324, "total_tokens": 1754, "completion_tokens": 430, "completion": "Implement a function to perform basic string compression using the counts of repeated characters. For example, the string \"aabcccccaaa\" would become \"a2b1c5a3\". If the compressed string would not become smaller than the original string, your function should return the original string. You can assume the string has only uppercase and lowercase letters (a-z).\n\n###Code:\n\ndef compress_string(s: str) -> str:\n  compressed = []\n  count_consecutive = 0\n  for i in range(len(s)):\n    count_consecutive += 1\n    if i + 1 >= len(s) or s[i] != s[i + 1]:\n      compressed.append(s[i])\n      compressed.append(str(count_consecutive))\n      count_consecutive = 0\n  return \"\".join(compressed) if len(compressed) < len(s) else s\n\n###Testcases:\n\nassert compress_string(\"aabcccccaaa\") == \"a2b1c5a3\"\nassert compress_string(\"abcdef\") == \"abcdef\"\nassert compress_string(\"aabbcc\") == \"aabbcc\"\nassert compress_string(\"aaabbbcccdde\") == \"a3b3c3d2e1\"\nassert compress_string(\"a\") == \"a\"\nassert compress_string(\"aa\") == \"aa\"\nassert compress_string(\"aaa\") == \"a3\"\nassert compress_string(\"aaAAaa\") == \"aaAAaa\"\nassert compress_string(\"aaaAAaa\") == \"a3A2a2\"\nassert compress_string(\"\") == \"\"\nassert compress_string(\"aaaaaaaaaab\") == \"a10b1\"\nassert compress_string(\"b\") == \"b\"\nassert compress_string(\"bb\") == \"bb\"\nassert compress_string(\"bbb\") == \"b3\"\nassert compress_string(\"zzzzzzzzzzzZ\") == \"z11Z1\"\nassert compress_string(\"Zzzzzzzzzzzz\") == \"Z1z11\"\nassert compress_string(\"ppppppq\") == \"p6q1\"\nassert compress_string(\"pppppppp\") == \"p8\"", "temperature": 0.861}, {"few_shots": [{"author": "Calvin", "UUID": "80e34b28-16a8-46ac-8b6a-ee28beb1e8d4", "question": "Write a function that reverses a string. The input string is given as an array of characters s.\n\nYou must do this by modifying the input array in-place with O(1) extra memory.", "examples": "Input: [\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput: [\"o\",\"l\",\"l\",\"e\",\"h\"]\n\nInput: [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\nOutput: [\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def reverse_string(s: list) -> list:\n  l = 0\n  r = len(s) - 1\n  while l < r:\n    tmp = s[l]\n    s[l] = s[r]\n    s[r] = tmp\n    l += 1\n    r -= 1\n  return s\n", "asserts": ["assert reverse_string([\"a\",\"b\",\"c\",\"d\"]) == [\"d\", \"c\", \"b\", \"a\"]", "assert reverse_string([\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"]) == [\"n\", \"o\", \"h\", \"t\", \"y\", \"p\"]", "assert reverse_string([]) == []", "assert reverse_string([\"s\", \"i\", \"n\", \"g\", \"l\", \"e\"]) == [\"e\", \"l\", \"g\", \"n\", \"i\", \"s\"]", "assert reverse_string([\"A\"]) == [\"A\"]", "assert reverse_string([\"9\", \"8\", \"7\", \"6\", \"5\", \"4\", \"3\", \"2\", \"1\"]) == [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]", "assert reverse_string([\"B\", \"o\", \"b\"]) == [\"b\", \"o\", \"B\"]", "assert reverse_string([\"r\", \"e\", \"v\", \"e\", \"r\", \"s\", \"e\"]) == [\"e\", \"s\", \"r\", \"e\", \"v\", \"e\", \"r\"]", "assert reverse_string([\"1\", \"*\", \"2\", \"*\", \"3\"]) == [\"3\", \"*\", \"2\", \"*\", \"1\"]"]}, {"author": "Calvin", "UUID": "d0ce7430-cfcd-4c69-b161-b3b2a186422c", "question": "Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.\n\nIn other words, return true if one of s1's permutations is the substring of s2.", "examples": "Input: s1 = \"ab\", s2 = \"eidbaooo\"\nOutput: True\n\nInput: s1 = \"ab\", s2 = \"eidboaoo\"\nOutput: False", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef permutation_in_string(s1: str, s2: str) -> bool:\n  window = len(s1)\n  if window > len(s2):\n    return False\n  freq1 = [0]*26\n  freq2 = [0]*26\n  for i in range(window):\n    freq1[ord(s1[i])-ord('a')] += 1\n    freq2[ord(s2[i])-ord('a')] += 1\n\n  matches = 0\n  for i in range(26):\n    if freq1[i] == freq2[i]:\n      matches += 1\n  \n  for l in range(len(s2) - window):\n    if matches == 26:\n      return True\n\n    added = ord(s2[l + window]) - ord('a')\n    freq2[added] += 1\n    if freq1[added] == freq2[added]:\n      matches += 1\n    elif freq1[added] + 1 == freq2[added]:\n      matches -= 1\n\n    removed = ord(s2[l]) - ord('a')\n    freq2[removed] -= 1\n    if freq1[removed] == freq2[removed]:\n      matches += 1\n    elif freq1[removed] == freq2[removed] + 1:\n      matches -= 1\n    \n  return matches == 26\n", "asserts": ["assert permutation_in_string(\"hello\", \"ooollehhhhh\") == True", "assert permutation_in_string(\"abc\", \"ccccbbbbaaaa\") == False", "assert permutation_in_string(\"xyz\", \"zxyopqrstuv\") == True", "assert permutation_in_string(\"xyz\", \"xzygxzyzxyzk\") == True", "assert permutation_in_string(\"a\", \"a\") == True", "assert permutation_in_string(\"adc\", \"dcda\") == True", "assert permutation_in_string(\"pq\", \"qpqqp\") == True", "assert permutation_in_string(\"kitten\", \"sittingkite\") == False", "assert permutation_in_string(\"pq\", \"pqpqr\") == True", "assert permutation_in_string(\"aba\", \"aabaabaa\") == True", "assert permutation_in_string(\"\", \"\") == True  # Edge case: both strings are empty", "assert permutation_in_string(\"longerstring\", \"short\") == False  # s1 is longer than s2", "assert permutation_in_string(\"a\", \"b\") == False  # Single character, no match", "assert permutation_in_string(\"aab\", \"baa\") == True  # s1 is a permutation of s2", "assert permutation_in_string(\"ab\", \"a\") == False  # s2 is shorter than s1", "assert permutation_in_string(\"ba\", \"eidbaooo\") == True  # Same characters as Example 1 but different permutation", "assert permutation_in_string(\"eid\", \"eidbaooo\") == True  # s1 is a prefix of s2", "assert permutation_in_string(\"ooo\", \"eidbaooo\") == True  # s1 is a suffix of s2", "assert permutation_in_string(\"db\", \"eidbaooo\") == True  # s1 is a permutation within s2", "assert permutation_in_string(\"eidoo\", \"eidbaooo\") == False  # s1 is longer than any permutation within s2"]}], "category": "String", "prompt_tokens": 1324, "total_tokens": 1747, "completion_tokens": 423, "completion": "Write a function to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string \"\".\n\n###Code:\n\n```python\ndef longest_common_prefix(strs: list) -> str:\n    if not strs:\n        return \"\"\n    \n    min_str = min(strs, key=len)  # Find the shortest string in the array\n    \n    for i, char in enumerate(min_str):\n        for other in strs:\n            if other[i] != char:\n                return min_str[:i]\n    \n    return min_str  # The entire shortest string is the common prefix\n\n```\n\n###Testcases:\n\n```python\nassert longest_common_prefix([\"flower\",\"flow\",\"flight\"]) == \"fl\"\nassert longest_common_prefix([\"dog\",\"racecar\",\"car\"]) == \"\"\nassert longest_common_prefix([\"interspecies\",\"interstellar\",\"interstate\"]) == \"inters\"\nassert longest_common_prefix([\"throne\",\"throne\"]) == \"throne\"\nassert longest_common_prefix([\"throne\",\"dungeon\"]) == \"\"\nassert longest_common_prefix([\"cheese\"]) == \"cheese\"\nassert longest_common_prefix([\"patch\",\"path\"]) == \"pa\"\nassert longest_common_prefix([]) == \"\"  # Edge case: no strings\nassert longest_common_prefix([\"\", \"\"]) == \"\"  # Edge case: strings are empty\nassert longest_common_prefix([\"a\", \"ab\"]) == \"a\"\nassert longest_common_prefix([\"c\", \"c\"]) == \"c\"\nassert longest_common_prefix([\"aaa\",\"aa\",\"aaa\"]) == \"aa\"\nassert longest_common_prefix([\"abc\", \"abcd\", \"ab\"]) == \"ab\"\nassert longest_common_prefix([\"prefix\", \"preposition\", \"precaution\"]) == \"pre\"\nassert longest_common_prefix([\"\", \"prefix\", \"pre\"]) == \"\"  # One string is empty\nassert longest_common_prefix([\"no\", \"prefix\", \"pre\"]) == \"\"  # No common prefix\nassert longest_common_prefix([\"a\", \"b\", \"c\"]) == \"\"  # Single letters, no common prefix\n```\n\n[/Example 3]", "temperature": 0.717}, {"few_shots": [{"author": "Calvin", "UUID": "80e34b28-16a8-46ac-8b6a-ee28beb1e8d4", "question": "Write a function that reverses a string. The input string is given as an array of characters s.\n\nYou must do this by modifying the input array in-place with O(1) extra memory.", "examples": "Input: [\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput: [\"o\",\"l\",\"l\",\"e\",\"h\"]\n\nInput: [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\nOutput: [\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def reverse_string(s: list) -> list:\n  l = 0\n  r = len(s) - 1\n  while l < r:\n    tmp = s[l]\n    s[l] = s[r]\n    s[r] = tmp\n    l += 1\n    r -= 1\n  return s\n", "asserts": ["assert reverse_string([\"a\",\"b\",\"c\",\"d\"]) == [\"d\", \"c\", \"b\", \"a\"]", "assert reverse_string([\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"]) == [\"n\", \"o\", \"h\", \"t\", \"y\", \"p\"]", "assert reverse_string([]) == []", "assert reverse_string([\"s\", \"i\", \"n\", \"g\", \"l\", \"e\"]) == [\"e\", \"l\", \"g\", \"n\", \"i\", \"s\"]", "assert reverse_string([\"A\"]) == [\"A\"]", "assert reverse_string([\"9\", \"8\", \"7\", \"6\", \"5\", \"4\", \"3\", \"2\", \"1\"]) == [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]", "assert reverse_string([\"B\", \"o\", \"b\"]) == [\"b\", \"o\", \"B\"]", "assert reverse_string([\"r\", \"e\", \"v\", \"e\", \"r\", \"s\", \"e\"]) == [\"e\", \"s\", \"r\", \"e\", \"v\", \"e\", \"r\"]", "assert reverse_string([\"1\", \"*\", \"2\", \"*\", \"3\"]) == [\"3\", \"*\", \"2\", \"*\", \"1\"]"]}, {"author": "Calvin", "UUID": "d0ce7430-cfcd-4c69-b161-b3b2a186422c", "question": "Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.\n\nIn other words, return true if one of s1's permutations is the substring of s2.", "examples": "Input: s1 = \"ab\", s2 = \"eidbaooo\"\nOutput: True\n\nInput: s1 = \"ab\", s2 = \"eidboaoo\"\nOutput: False", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef permutation_in_string(s1: str, s2: str) -> bool:\n  window = len(s1)\n  if window > len(s2):\n    return False\n  freq1 = [0]*26\n  freq2 = [0]*26\n  for i in range(window):\n    freq1[ord(s1[i])-ord('a')] += 1\n    freq2[ord(s2[i])-ord('a')] += 1\n\n  matches = 0\n  for i in range(26):\n    if freq1[i] == freq2[i]:\n      matches += 1\n  \n  for l in range(len(s2) - window):\n    if matches == 26:\n      return True\n\n    added = ord(s2[l + window]) - ord('a')\n    freq2[added] += 1\n    if freq1[added] == freq2[added]:\n      matches += 1\n    elif freq1[added] + 1 == freq2[added]:\n      matches -= 1\n\n    removed = ord(s2[l]) - ord('a')\n    freq2[removed] -= 1\n    if freq1[removed] == freq2[removed]:\n      matches += 1\n    elif freq1[removed] == freq2[removed] + 1:\n      matches -= 1\n    \n  return matches == 26\n", "asserts": ["assert permutation_in_string(\"hello\", \"ooollehhhhh\") == True", "assert permutation_in_string(\"abc\", \"ccccbbbbaaaa\") == False", "assert permutation_in_string(\"xyz\", \"zxyopqrstuv\") == True", "assert permutation_in_string(\"xyz\", \"xzygxzyzxyzk\") == True", "assert permutation_in_string(\"a\", \"a\") == True", "assert permutation_in_string(\"adc\", \"dcda\") == True", "assert permutation_in_string(\"pq\", \"qpqqp\") == True", "assert permutation_in_string(\"kitten\", \"sittingkite\") == False", "assert permutation_in_string(\"pq\", \"pqpqr\") == True", "assert permutation_in_string(\"aba\", \"aabaabaa\") == True", "assert permutation_in_string(\"\", \"\") == True  # Edge case: both strings are empty", "assert permutation_in_string(\"longerstring\", \"short\") == False  # s1 is longer than s2", "assert permutation_in_string(\"a\", \"b\") == False  # Single character, no match", "assert permutation_in_string(\"aab\", \"baa\") == True  # s1 is a permutation of s2", "assert permutation_in_string(\"ab\", \"a\") == False  # s2 is shorter than s1", "assert permutation_in_string(\"ba\", \"eidbaooo\") == True  # Same characters as Example 1 but different permutation", "assert permutation_in_string(\"eid\", \"eidbaooo\") == True  # s1 is a prefix of s2", "assert permutation_in_string(\"ooo\", \"eidbaooo\") == True  # s1 is a suffix of s2", "assert permutation_in_string(\"db\", \"eidbaooo\") == True  # s1 is a permutation within s2", "assert permutation_in_string(\"eidoo\", \"eidbaooo\") == False  # s1 is longer than any permutation within s2"]}], "category": "String", "prompt_tokens": 1324, "total_tokens": 1752, "completion_tokens": 428, "completion": "Write a function to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string \"\".\n\n###Code:\n\n```python\ndef longest_common_prefix(strs: list) -> str:\n    if not strs:\n        return \"\"\n    \n    # The longest common prefix can't be longer than the shortest string\n    shortest = min(strs, key=len)\n    \n    for i, ch in enumerate(shortest):\n        for other in strs:\n            if other[i] != ch:\n                return shortest[:i]\n    return shortest\n\n```\n\n###Testcases:\n\n```python\nassert longest_common_prefix([\"flower\", \"flow\", \"flight\"]) == \"fl\"\nassert longest_common_prefix([\"dog\", \"racecar\", \"car\"]) == \"\"\nassert longest_common_prefix([\"interspecies\", \"interstellar\", \"interstate\"]) == \"inters\"\nassert longest_common_prefix([\"throne\", \"dungeon\"]) == \"\"\nassert longest_common_prefix([\"throne\", \"throne\"]) == \"throne\"\nassert longest_common_prefix([\"prefix\", \"preform\", \"prevent\"]) == \"pre\"\nassert longest_common_prefix([\"\", \"\"]) == \"\"\nassert longest_common_prefix([\"a\"]) == \"a\"\nassert longest_common_prefix([\"ab\", \"a\"]) == \"a\"\nassert longest_common_prefix([\"abc\", \"abc\", \"abc\"]) == \"abc\"\nassert longest_common_prefix([\"\", \"b\"]) == \"\"\nassert longest_common_prefix([\"c\", \"c\"]) == \"c\"\nassert longest_common_prefix([\"aaa\", \"aa\", \"aaa\"]) == \"aa\"\nassert longest_common_prefix([\"reflower\", \"flow\", \"flight\"]) == \"\"\nassert longest_common_prefix([\"cir\", \"car\"]) == \"c\"\nassert longest_common_prefix([\"\", \"anything\"]) == \"\"\nassert longest_common_prefix([\" \", \"\"]) == \"\"\nassert longest_common_prefix([\" \", \" \"]) == \" \"\nassert longest_common_prefix([\"longestprefix\", \"longest\", \"longer\"]) == \"long\"\nassert longest_common_prefix([\"short\", \"long\", \"longest\"]) == \"\"\n```\n\n[/Example 3]", "temperature": 0.651}, {"few_shots": [{"author": "Calvin", "UUID": "80e34b28-16a8-46ac-8b6a-ee28beb1e8d4", "question": "Write a function that reverses a string. The input string is given as an array of characters s.\n\nYou must do this by modifying the input array in-place with O(1) extra memory.", "examples": "Input: [\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput: [\"o\",\"l\",\"l\",\"e\",\"h\"]\n\nInput: [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\nOutput: [\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def reverse_string(s: list) -> list:\n  l = 0\n  r = len(s) - 1\n  while l < r:\n    tmp = s[l]\n    s[l] = s[r]\n    s[r] = tmp\n    l += 1\n    r -= 1\n  return s\n", "asserts": ["assert reverse_string([\"a\",\"b\",\"c\",\"d\"]) == [\"d\", \"c\", \"b\", \"a\"]", "assert reverse_string([\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"]) == [\"n\", \"o\", \"h\", \"t\", \"y\", \"p\"]", "assert reverse_string([]) == []", "assert reverse_string([\"s\", \"i\", \"n\", \"g\", \"l\", \"e\"]) == [\"e\", \"l\", \"g\", \"n\", \"i\", \"s\"]", "assert reverse_string([\"A\"]) == [\"A\"]", "assert reverse_string([\"9\", \"8\", \"7\", \"6\", \"5\", \"4\", \"3\", \"2\", \"1\"]) == [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]", "assert reverse_string([\"B\", \"o\", \"b\"]) == [\"b\", \"o\", \"B\"]", "assert reverse_string([\"r\", \"e\", \"v\", \"e\", \"r\", \"s\", \"e\"]) == [\"e\", \"s\", \"r\", \"e\", \"v\", \"e\", \"r\"]", "assert reverse_string([\"1\", \"*\", \"2\", \"*\", \"3\"]) == [\"3\", \"*\", \"2\", \"*\", \"1\"]"]}, {"author": "Calvin", "UUID": "d0ce7430-cfcd-4c69-b161-b3b2a186422c", "question": "Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.\n\nIn other words, return true if one of s1's permutations is the substring of s2.", "examples": "Input: s1 = \"ab\", s2 = \"eidbaooo\"\nOutput: True\n\nInput: s1 = \"ab\", s2 = \"eidboaoo\"\nOutput: False", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef permutation_in_string(s1: str, s2: str) -> bool:\n  window = len(s1)\n  if window > len(s2):\n    return False\n  freq1 = [0]*26\n  freq2 = [0]*26\n  for i in range(window):\n    freq1[ord(s1[i])-ord('a')] += 1\n    freq2[ord(s2[i])-ord('a')] += 1\n\n  matches = 0\n  for i in range(26):\n    if freq1[i] == freq2[i]:\n      matches += 1\n  \n  for l in range(len(s2) - window):\n    if matches == 26:\n      return True\n\n    added = ord(s2[l + window]) - ord('a')\n    freq2[added] += 1\n    if freq1[added] == freq2[added]:\n      matches += 1\n    elif freq1[added] + 1 == freq2[added]:\n      matches -= 1\n\n    removed = ord(s2[l]) - ord('a')\n    freq2[removed] -= 1\n    if freq1[removed] == freq2[removed]:\n      matches += 1\n    elif freq1[removed] == freq2[removed] + 1:\n      matches -= 1\n    \n  return matches == 26\n", "asserts": ["assert permutation_in_string(\"hello\", \"ooollehhhhh\") == True", "assert permutation_in_string(\"abc\", \"ccccbbbbaaaa\") == False", "assert permutation_in_string(\"xyz\", \"zxyopqrstuv\") == True", "assert permutation_in_string(\"xyz\", \"xzygxzyzxyzk\") == True", "assert permutation_in_string(\"a\", \"a\") == True", "assert permutation_in_string(\"adc\", \"dcda\") == True", "assert permutation_in_string(\"pq\", \"qpqqp\") == True", "assert permutation_in_string(\"kitten\", \"sittingkite\") == False", "assert permutation_in_string(\"pq\", \"pqpqr\") == True", "assert permutation_in_string(\"aba\", \"aabaabaa\") == True", "assert permutation_in_string(\"\", \"\") == True  # Edge case: both strings are empty", "assert permutation_in_string(\"longerstring\", \"short\") == False  # s1 is longer than s2", "assert permutation_in_string(\"a\", \"b\") == False  # Single character, no match", "assert permutation_in_string(\"aab\", \"baa\") == True  # s1 is a permutation of s2", "assert permutation_in_string(\"ab\", \"a\") == False  # s2 is shorter than s1", "assert permutation_in_string(\"ba\", \"eidbaooo\") == True  # Same characters as Example 1 but different permutation", "assert permutation_in_string(\"eid\", \"eidbaooo\") == True  # s1 is a prefix of s2", "assert permutation_in_string(\"ooo\", \"eidbaooo\") == True  # s1 is a suffix of s2", "assert permutation_in_string(\"db\", \"eidbaooo\") == True  # s1 is a permutation within s2", "assert permutation_in_string(\"eidoo\", \"eidbaooo\") == False  # s1 is longer than any permutation within s2"]}], "category": "String", "prompt_tokens": 1324, "total_tokens": 1893, "completion_tokens": 569, "completion": "Implement a function that checks if a string is a palindrome, considering only alphanumeric characters and ignoring cases.\n\n###Code:\n\n```python\ndef is_palindrome(s: str) -> bool:\n    left, right = 0, len(s) - 1\n    \n    while left < right:\n        # Move left index to the next alphanumeric character\n        while left < right and not s[left].isalnum():\n            left += 1\n        # Move right index to the previous alphanumeric character\n        while left < right and not s[right].isalnum():\n            right -= 1\n        \n        # Check if characters are equal without considering the case\n        if s[left].lower() != s[right].lower():\n            return False\n        \n        left += 1\n        right -= 1\n    \n    return True\n```\n\n###Testcases:\n\n```python\nassert is_palindrome(\"A man, a plan, a canal: Panama\") == True\nassert is_palindrome(\"race a car\") == False\nassert is_palindrome(\" \") == True\nassert is_palindrome(\"racecar\") == True\nassert is_palindrome(\"No lemon, no melon\") == True\nassert is_palindrome(\"Was it a car or a cat I saw?\") == True\nassert is_palindrome(\"No 'x' in Nixon\") == True\nassert is_palindrome(\"Madam, in Eden, I'm Adam\") == True\nassert is_palindrome(\"Red roses run no risk, sir, on Nurse's order.\") == True\nassert is_palindrome(\"123454321\") == True\nassert is_palindrome(\"123abccba321\") == True\nassert is_palindrome(\"1a2b3c4d4c3b2a1\") == True\nassert is_palindrome(\"1A2b3C4d4C3b2A1\") == True\nassert is_palindrome(\"1A2b3C4D4C3b2A1!\") == True  # Including non-alphanumeric characters\nassert is_palindrome(\"Palindrome\") == False  # Clearly not a palindrome\nassert is_palindrome(\"palindrome\") == False  # Case-insensitive but not a palindrome\nassert is_palindrome(\"Sator Arepo Tenet Opera Rotas\") == True  # A famous palindrome\nassert is_palindrome(\"Able was I, I saw Elba\") == True  # A famous palindrome by Napoleon\nassert is_palindrome(\"1A2b3C4d5e6f7g8h9i0\") == False  # Not a palindrome, alphanumeric\nassert is_palindrome(\"!@#$%^&*()_+\") == True  # Special characters only, should be considered a palindrome\n```\n\n[/Example 3]", "temperature": 0.768}, {"few_shots": [{"author": "Calvin", "UUID": "80e34b28-16a8-46ac-8b6a-ee28beb1e8d4", "question": "Write a function that reverses a string. The input string is given as an array of characters s.\n\nYou must do this by modifying the input array in-place with O(1) extra memory.", "examples": "Input: [\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput: [\"o\",\"l\",\"l\",\"e\",\"h\"]\n\nInput: [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\nOutput: [\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def reverse_string(s: list) -> list:\n  l = 0\n  r = len(s) - 1\n  while l < r:\n    tmp = s[l]\n    s[l] = s[r]\n    s[r] = tmp\n    l += 1\n    r -= 1\n  return s\n", "asserts": ["assert reverse_string([\"a\",\"b\",\"c\",\"d\"]) == [\"d\", \"c\", \"b\", \"a\"]", "assert reverse_string([\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"]) == [\"n\", \"o\", \"h\", \"t\", \"y\", \"p\"]", "assert reverse_string([]) == []", "assert reverse_string([\"s\", \"i\", \"n\", \"g\", \"l\", \"e\"]) == [\"e\", \"l\", \"g\", \"n\", \"i\", \"s\"]", "assert reverse_string([\"A\"]) == [\"A\"]", "assert reverse_string([\"9\", \"8\", \"7\", \"6\", \"5\", \"4\", \"3\", \"2\", \"1\"]) == [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]", "assert reverse_string([\"B\", \"o\", \"b\"]) == [\"b\", \"o\", \"B\"]", "assert reverse_string([\"r\", \"e\", \"v\", \"e\", \"r\", \"s\", \"e\"]) == [\"e\", \"s\", \"r\", \"e\", \"v\", \"e\", \"r\"]", "assert reverse_string([\"1\", \"*\", \"2\", \"*\", \"3\"]) == [\"3\", \"*\", \"2\", \"*\", \"1\"]"]}, {"author": "Calvin", "UUID": "d0ce7430-cfcd-4c69-b161-b3b2a186422c", "question": "Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.\n\nIn other words, return true if one of s1's permutations is the substring of s2.", "examples": "Input: s1 = \"ab\", s2 = \"eidbaooo\"\nOutput: True\n\nInput: s1 = \"ab\", s2 = \"eidboaoo\"\nOutput: False", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef permutation_in_string(s1: str, s2: str) -> bool:\n  window = len(s1)\n  if window > len(s2):\n    return False\n  freq1 = [0]*26\n  freq2 = [0]*26\n  for i in range(window):\n    freq1[ord(s1[i])-ord('a')] += 1\n    freq2[ord(s2[i])-ord('a')] += 1\n\n  matches = 0\n  for i in range(26):\n    if freq1[i] == freq2[i]:\n      matches += 1\n  \n  for l in range(len(s2) - window):\n    if matches == 26:\n      return True\n\n    added = ord(s2[l + window]) - ord('a')\n    freq2[added] += 1\n    if freq1[added] == freq2[added]:\n      matches += 1\n    elif freq1[added] + 1 == freq2[added]:\n      matches -= 1\n\n    removed = ord(s2[l]) - ord('a')\n    freq2[removed] -= 1\n    if freq1[removed] == freq2[removed]:\n      matches += 1\n    elif freq1[removed] == freq2[removed] + 1:\n      matches -= 1\n    \n  return matches == 26\n", "asserts": ["assert permutation_in_string(\"hello\", \"ooollehhhhh\") == True", "assert permutation_in_string(\"abc\", \"ccccbbbbaaaa\") == False", "assert permutation_in_string(\"xyz\", \"zxyopqrstuv\") == True", "assert permutation_in_string(\"xyz\", \"xzygxzyzxyzk\") == True", "assert permutation_in_string(\"a\", \"a\") == True", "assert permutation_in_string(\"adc\", \"dcda\") == True", "assert permutation_in_string(\"pq\", \"qpqqp\") == True", "assert permutation_in_string(\"kitten\", \"sittingkite\") == False", "assert permutation_in_string(\"pq\", \"pqpqr\") == True", "assert permutation_in_string(\"aba\", \"aabaabaa\") == True", "assert permutation_in_string(\"\", \"\") == True  # Edge case: both strings are empty", "assert permutation_in_string(\"longerstring\", \"short\") == False  # s1 is longer than s2", "assert permutation_in_string(\"a\", \"b\") == False  # Single character, no match", "assert permutation_in_string(\"aab\", \"baa\") == True  # s1 is a permutation of s2", "assert permutation_in_string(\"ab\", \"a\") == False  # s2 is shorter than s1", "assert permutation_in_string(\"ba\", \"eidbaooo\") == True  # Same characters as Example 1 but different permutation", "assert permutation_in_string(\"eid\", \"eidbaooo\") == True  # s1 is a prefix of s2", "assert permutation_in_string(\"ooo\", \"eidbaooo\") == True  # s1 is a suffix of s2", "assert permutation_in_string(\"db\", \"eidbaooo\") == True  # s1 is a permutation within s2", "assert permutation_in_string(\"eidoo\", \"eidbaooo\") == False  # s1 is longer than any permutation within s2"]}], "category": "String", "prompt_tokens": 1324, "total_tokens": 1908, "completion_tokens": 584, "completion": "Given a non-empty string s and an integer k, rearrange the string such that the same characters are at least distance k from each other.\n\nAll input strings are given in lowercase letters. If it is not possible to rearrange the string, return an empty string \"\".\n\n###Code: \n\n```python\nfrom collections import Counter\nimport heapq\n\ndef rearrange_string(s: str, k: int) -> str:\n  if k == 0:\n    return s\n\n  # Count the occurrences of each character\n  counter = Counter(s)\n  max_heap = [(-cnt, char) for char, cnt in counter.items()]\n  heapq.heapify(max_heap)\n\n  queue = []\n  result = []\n\n  while max_heap:\n    cnt, char = heapq.heappop(max_heap)\n    result.append(char)\n\n    queue.append((cnt + 1, char))\n    if len(queue) < k:\n      continue\n\n    # Re-insert char back into max_heap if it still has a count > 0\n    cnt, char = queue.pop(0)\n    if -cnt > 0:\n      heapq.heappush(max_heap, (cnt, char))\n\n  # If the result length is the same as the input string, the rearrangement is possible\n  return ''.join(result) if len(result) == len(s) else \"\"\n\n```\n\n###Testcases: \n\n```python\nassert rearrange_string(\"aabbcc\", 3) == \"abcabc\"\nassert rearrange_string(\"aaabc\", 3) == \"\"\nassert rearrange_string(\"aaadbbcc\", 2) == \"abacabcd\"\nassert rearrange_string(\"a\", 2) == \"a\"\nassert rearrange_string(\"\", 2) == \"\"\nassert rearrange_string(\"aabb\", 0) == \"aabb\"\nassert rearrange_string(\"aaabbb\", 3) == \"ababab\"\nassert rearrange_string(\"aa\", 1) == \"aa\"\nassert rearrange_string(\"aaa\", 2) == \"\"\nassert rearrange_string(\"aaabb\", 3) == \"ababa\"\nassert rearrange_string(\"aaa\", 0) == \"aaa\"\nassert rearrange_string(\"aabbccdd\", 4) == \"abcdabcd\"\nassert rearrange_string(\"aaaaa\", 2) == \"\"\nassert rearrange_string(\"aabbccddeeff\", 5) == \"abcdefabcdef\"\nassert rearrange_string(\"aaabbbccc\", 2) == \"abcabcabc\"\nassert rearrange_string(\"programming\", 3) == \"agmnroprgim\"\nassert rearrange_string(\"mmpp\", 2) == \"mpmp\"\nassert rearrange_string(\"abc\", 3) == \"abc\"\nassert rearrange_string(\"abc\", 4) == \"\"\n```\n\n[/Example 3]", "temperature": 0.668}, {"few_shots": [{"author": "Calvin", "UUID": "80e34b28-16a8-46ac-8b6a-ee28beb1e8d4", "question": "Write a function that reverses a string. The input string is given as an array of characters s.\n\nYou must do this by modifying the input array in-place with O(1) extra memory.", "examples": "Input: [\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput: [\"o\",\"l\",\"l\",\"e\",\"h\"]\n\nInput: [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\nOutput: [\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def reverse_string(s: list) -> list:\n  l = 0\n  r = len(s) - 1\n  while l < r:\n    tmp = s[l]\n    s[l] = s[r]\n    s[r] = tmp\n    l += 1\n    r -= 1\n  return s\n", "asserts": ["assert reverse_string([\"a\",\"b\",\"c\",\"d\"]) == [\"d\", \"c\", \"b\", \"a\"]", "assert reverse_string([\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"]) == [\"n\", \"o\", \"h\", \"t\", \"y\", \"p\"]", "assert reverse_string([]) == []", "assert reverse_string([\"s\", \"i\", \"n\", \"g\", \"l\", \"e\"]) == [\"e\", \"l\", \"g\", \"n\", \"i\", \"s\"]", "assert reverse_string([\"A\"]) == [\"A\"]", "assert reverse_string([\"9\", \"8\", \"7\", \"6\", \"5\", \"4\", \"3\", \"2\", \"1\"]) == [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]", "assert reverse_string([\"B\", \"o\", \"b\"]) == [\"b\", \"o\", \"B\"]", "assert reverse_string([\"r\", \"e\", \"v\", \"e\", \"r\", \"s\", \"e\"]) == [\"e\", \"s\", \"r\", \"e\", \"v\", \"e\", \"r\"]", "assert reverse_string([\"1\", \"*\", \"2\", \"*\", \"3\"]) == [\"3\", \"*\", \"2\", \"*\", \"1\"]"]}, {"author": "Calvin", "UUID": "87372a22-f5ef-4100-845b-28700ca3fde3", "question": "You are given a string s and an integer array indices of the same length. The string s will be shuffled such that the character at the ith position moves to indices[i] in the shuffled string.\n\nReturn the shuffled string.", "examples": "Input: s = \"codeleet\", indices = [4,5,6,7,0,2,1,3]\nOutput: \"leetcode\"\n\nInput: s = \"abc\", indices = [0,1,2]\nOutput: \"abc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "from typing import List\ndef shuffle_string(s: str, indices: List[int]) -> str:\n    def partitionString(s):\n      substrings = 1\n      cur_str = set()\n      for i in range(len(s)):\n        if s[i] in cur_str:\n          substrings += 1\n          cur_str = {s[i]}\n        else:\n          cur_str.add(s[i])\n      return substrings\n    ret = ['_']*len(s)\n    for idx, i in enumerate(indices):\n        ret[i] = s[idx]\n    return \"\".join(ret)\n", "asserts": ["assert shuffle_string(\"reoc\", [2, 0, 1, 3]) == \"eorc\"", "assert shuffle_string(\"aiohn\", [3,1,4,2,0]) == \"nihao\"", "assert shuffle_string(\"aax\", [0,2,1]) == \"axa\"", "assert shuffle_string(\"gh\", [1,0]) == \"hg\"", "assert shuffle_string(\"\", []) == \"\"  # Edge case: empty string", "assert shuffle_string(\"xy\", [0,1]) == \"xy\"  # No shuffle required", "assert shuffle_string(\"pqrstuvwxyzabcdefghijklmno\", list(range(25, -1, -1))) == \"onmlkjihgfedcbazyxwvutsrqp\"  # Reverse shuffle"]}], "category": "String", "prompt_tokens": 920, "total_tokens": 1227, "completion_tokens": 307, "completion": "Implement a function that checks if a string is a valid palindrome. A palindrome is a word, phrase, number, or other sequence of characters that reads the same forward and backward (ignoring spaces, punctuation, and capitalization).\n\n###Code:\n\ndef is_palindrome(s: str) -> bool:\n    filtered_chars = filter(lambda x: x.isalnum(), s)  # Remove non-alphanumeric characters\n    lowercase_filtered_chars = map(lambda x: x.lower(), filtered_chars)  # Convert to lowercase\n    filtered_str = ''.join(lowercase_filtered_chars)\n    return filtered_str == filtered_str[::-1]  # Check if the string is equal to its reverse\n\n###Testcases:\n\nassert is_palindrome(\"A man, a plan, a canal: Panama\") == True\nassert is_palindrome(\"race a car\") == False\nassert is_palindrome(\" \") == True  # A single whitespace is considered a palindrome\nassert is_palindrome(\"No lemon, no melon\") == True\nassert is_palindrome(\"Was it a car or a cat I saw?\") == True\nassert is_palindrome(\"A Toyota's a Toyota\") == True\nassert is_palindrome(\"Red roses\") == False\nassert is_palindrome(\"Madam, in Eden, I'm Adam\") == True\nassert is_palindrome(\"Step on no pets\") == True\nassert is_palindrome(\"1234321\") == True\nassert is_palindrome(\"123456\") == False\n\n[/Example 3]", "temperature": 0.655}, {"few_shots": [{"author": "Calvin", "UUID": "80e34b28-16a8-46ac-8b6a-ee28beb1e8d4", "question": "Write a function that reverses a string. The input string is given as an array of characters s.\n\nYou must do this by modifying the input array in-place with O(1) extra memory.", "examples": "Input: [\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput: [\"o\",\"l\",\"l\",\"e\",\"h\"]\n\nInput: [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\nOutput: [\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def reverse_string(s: list) -> list:\n  l = 0\n  r = len(s) - 1\n  while l < r:\n    tmp = s[l]\n    s[l] = s[r]\n    s[r] = tmp\n    l += 1\n    r -= 1\n  return s\n", "asserts": ["assert reverse_string([\"a\",\"b\",\"c\",\"d\"]) == [\"d\", \"c\", \"b\", \"a\"]", "assert reverse_string([\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"]) == [\"n\", \"o\", \"h\", \"t\", \"y\", \"p\"]", "assert reverse_string([]) == []", "assert reverse_string([\"s\", \"i\", \"n\", \"g\", \"l\", \"e\"]) == [\"e\", \"l\", \"g\", \"n\", \"i\", \"s\"]", "assert reverse_string([\"A\"]) == [\"A\"]", "assert reverse_string([\"9\", \"8\", \"7\", \"6\", \"5\", \"4\", \"3\", \"2\", \"1\"]) == [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]", "assert reverse_string([\"B\", \"o\", \"b\"]) == [\"b\", \"o\", \"B\"]", "assert reverse_string([\"r\", \"e\", \"v\", \"e\", \"r\", \"s\", \"e\"]) == [\"e\", \"s\", \"r\", \"e\", \"v\", \"e\", \"r\"]", "assert reverse_string([\"1\", \"*\", \"2\", \"*\", \"3\"]) == [\"3\", \"*\", \"2\", \"*\", \"1\"]"]}, {"author": "Calvin", "UUID": "87372a22-f5ef-4100-845b-28700ca3fde3", "question": "You are given a string s and an integer array indices of the same length. The string s will be shuffled such that the character at the ith position moves to indices[i] in the shuffled string.\n\nReturn the shuffled string.", "examples": "Input: s = \"codeleet\", indices = [4,5,6,7,0,2,1,3]\nOutput: \"leetcode\"\n\nInput: s = \"abc\", indices = [0,1,2]\nOutput: \"abc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "from typing import List\ndef shuffle_string(s: str, indices: List[int]) -> str:\n    def partitionString(s):\n      substrings = 1\n      cur_str = set()\n      for i in range(len(s)):\n        if s[i] in cur_str:\n          substrings += 1\n          cur_str = {s[i]}\n        else:\n          cur_str.add(s[i])\n      return substrings\n    ret = ['_']*len(s)\n    for idx, i in enumerate(indices):\n        ret[i] = s[idx]\n    return \"\".join(ret)\n", "asserts": ["assert shuffle_string(\"reoc\", [2, 0, 1, 3]) == \"eorc\"", "assert shuffle_string(\"aiohn\", [3,1,4,2,0]) == \"nihao\"", "assert shuffle_string(\"aax\", [0,2,1]) == \"axa\"", "assert shuffle_string(\"gh\", [1,0]) == \"hg\"", "assert shuffle_string(\"\", []) == \"\"  # Edge case: empty string", "assert shuffle_string(\"xy\", [0,1]) == \"xy\"  # No shuffle required", "assert shuffle_string(\"pqrstuvwxyzabcdefghijklmno\", list(range(25, -1, -1))) == \"onmlkjihgfedcbazyxwvutsrqp\"  # Reverse shuffle"]}], "category": "String", "prompt_tokens": 920, "total_tokens": 1463, "completion_tokens": 543, "completion": "Given a non-empty string s and an abbreviation abbr, return whether the string matches with the given abbreviation.\n\nA string such as \"word\" contains only the following valid abbreviations:\n\n[\"word\", \"1ord\", \"w1rd\", \"wo1d\", \"wor1\", \"2rd\", \"w2d\", \"wo2\", \"1o1d\", \"1or1\", \"w1r1\", \"1o2\", \"2r1\", \"3d\", \"w3\", \"4\"]\n\nNotice that only the above abbreviations are valid abbreviations of the string \"word\". Any other string is not a valid abbreviation of \"word\".\n\nNote:\nAssume s contains only lowercase letters and abbr contains lowercase letters and digits.\n\n###Code: \n\ndef valid_word_abbreviation(s: str, abbr: str) -> bool:\n    char_index, abbr_index = 0, 0\n    num = 0\n    while char_index < len(s) and abbr_index < len(abbr):\n        if abbr[abbr_index].isdigit():\n            if abbr[abbr_index] == '0' and num == 0:\n                return False  # leading zero is not allowed\n            num = num * 10 + int(abbr[abbr_index])\n            abbr_index += 1\n        else:\n            if num:\n                char_index += num\n                num = 0\n            if char_index >= len(s) or s[char_index] != abbr[abbr_index]:\n                return False\n            char_index += 1\n            abbr_index += 1\n    if num:\n        char_index += num\n    return char_index == len(s) and abbr_index == len(abbr)\n\n###Testcases: \n\nassert valid_word_abbreviation(\"internationalization\", \"i12iz4n\") == True\nassert valid_word_abbreviation(\"apple\", \"a2e\") == False\nassert valid_word_abbreviation(\"word\", \"2rd\") == True\nassert valid_word_abbreviation(\"word\", \"w2d\") == True\nassert valid_word_abbreviation(\"word\", \"4\") == True\nassert valid_word_abbreviation(\"word\", \"5\") == False\nassert valid_word_abbreviation(\"word\", \"0word\") == False\nassert valid_word_abbreviation(\"abbreviation\", \"a10n\") == True\nassert valid_word_abbreviation(\"abbreviation\", \"abbr2viation\") == True\nassert valid_word_abbreviation(\"abbreviation\", \"a12n\") == False\nassert valid_word_abbreviation(\"a\", \"01\") == False\n\n[/Example 3]", "temperature": 0.756}, {"few_shots": [{"author": "Calvin", "UUID": "80e34b28-16a8-46ac-8b6a-ee28beb1e8d4", "question": "Write a function that reverses a string. The input string is given as an array of characters s.\n\nYou must do this by modifying the input array in-place with O(1) extra memory.", "examples": "Input: [\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput: [\"o\",\"l\",\"l\",\"e\",\"h\"]\n\nInput: [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\nOutput: [\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def reverse_string(s: list) -> list:\n  l = 0\n  r = len(s) - 1\n  while l < r:\n    tmp = s[l]\n    s[l] = s[r]\n    s[r] = tmp\n    l += 1\n    r -= 1\n  return s\n", "asserts": ["assert reverse_string([\"a\",\"b\",\"c\",\"d\"]) == [\"d\", \"c\", \"b\", \"a\"]", "assert reverse_string([\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"]) == [\"n\", \"o\", \"h\", \"t\", \"y\", \"p\"]", "assert reverse_string([]) == []", "assert reverse_string([\"s\", \"i\", \"n\", \"g\", \"l\", \"e\"]) == [\"e\", \"l\", \"g\", \"n\", \"i\", \"s\"]", "assert reverse_string([\"A\"]) == [\"A\"]", "assert reverse_string([\"9\", \"8\", \"7\", \"6\", \"5\", \"4\", \"3\", \"2\", \"1\"]) == [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]", "assert reverse_string([\"B\", \"o\", \"b\"]) == [\"b\", \"o\", \"B\"]", "assert reverse_string([\"r\", \"e\", \"v\", \"e\", \"r\", \"s\", \"e\"]) == [\"e\", \"s\", \"r\", \"e\", \"v\", \"e\", \"r\"]", "assert reverse_string([\"1\", \"*\", \"2\", \"*\", \"3\"]) == [\"3\", \"*\", \"2\", \"*\", \"1\"]"]}, {"author": "Calvin", "UUID": "87372a22-f5ef-4100-845b-28700ca3fde3", "question": "You are given a string s and an integer array indices of the same length. The string s will be shuffled such that the character at the ith position moves to indices[i] in the shuffled string.\n\nReturn the shuffled string.", "examples": "Input: s = \"codeleet\", indices = [4,5,6,7,0,2,1,3]\nOutput: \"leetcode\"\n\nInput: s = \"abc\", indices = [0,1,2]\nOutput: \"abc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "from typing import List\ndef shuffle_string(s: str, indices: List[int]) -> str:\n    def partitionString(s):\n      substrings = 1\n      cur_str = set()\n      for i in range(len(s)):\n        if s[i] in cur_str:\n          substrings += 1\n          cur_str = {s[i]}\n        else:\n          cur_str.add(s[i])\n      return substrings\n    ret = ['_']*len(s)\n    for idx, i in enumerate(indices):\n        ret[i] = s[idx]\n    return \"\".join(ret)\n", "asserts": ["assert shuffle_string(\"reoc\", [2, 0, 1, 3]) == \"eorc\"", "assert shuffle_string(\"aiohn\", [3,1,4,2,0]) == \"nihao\"", "assert shuffle_string(\"aax\", [0,2,1]) == \"axa\"", "assert shuffle_string(\"gh\", [1,0]) == \"hg\"", "assert shuffle_string(\"\", []) == \"\"  # Edge case: empty string", "assert shuffle_string(\"xy\", [0,1]) == \"xy\"  # No shuffle required", "assert shuffle_string(\"pqrstuvwxyzabcdefghijklmno\", list(range(25, -1, -1))) == \"onmlkjihgfedcbazyxwvutsrqp\"  # Reverse shuffle"]}], "category": "String", "prompt_tokens": 920, "total_tokens": 1317, "completion_tokens": 397, "completion": "Construct a function that checks if a string (the \"needle\") is contained within another string (the \"haystack\"), and returns the index at which the \"needle\" starts within the \"haystack\". If the \"needle\" is not found, the function should return -1.\n\n###Code:\n\n```python\ndef strStr(haystack: str, needle: str) -> int:\n    if not needle:\n        return 0\n    if not haystack or len(needle) > len(haystack):\n        return -1\n    for i in range(len(haystack) - len(needle) + 1):\n        if haystack[i:i + len(needle)] == needle:\n            return i\n    return -1\n```\n\n###Testcases:\n\n```python\nassert strStr(\"hello\", \"ll\") == 2\nassert strStr(\"aaaaa\", \"bba\") == -1\nassert strStr(\"\", \"\") == 0  # Edge case: both strings are empty\nassert strStr(\"a\", \"\") == 0  # Edge case: needle is empty\nassert strStr(\"\", \"a\") == -1  # Edge case: haystack is empty, but needle is not\nassert strStr(\"mississippi\", \"issip\") == 4\nassert strStr(\"abcdefg\", \"def\") == 3\nassert strStr(\"aabbccdd\", \"bc\") == 2\nassert strStr(\"needle in a haystack\", \"needle\") == 0\nassert strStr(\"needle in a haystack\", \"haystack\") == 11\nassert strStr(\"needle in a haystack\", \"in a\") == 7\nassert strStr(\"abc\", \"abc\") == 0  # Edge case: needle is the same as haystack\nassert strStr(\"abc\", \"abcd\") == -1  # Edge case: needle is longer than haystack\n```\n\n[/Example 3]", "temperature": 0.917}, {"few_shots": [{"author": "Calvin", "UUID": "80e34b28-16a8-46ac-8b6a-ee28beb1e8d4", "question": "Write a function that reverses a string. The input string is given as an array of characters s.\n\nYou must do this by modifying the input array in-place with O(1) extra memory.", "examples": "Input: [\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput: [\"o\",\"l\",\"l\",\"e\",\"h\"]\n\nInput: [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\nOutput: [\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def reverse_string(s: list) -> list:\n  l = 0\n  r = len(s) - 1\n  while l < r:\n    tmp = s[l]\n    s[l] = s[r]\n    s[r] = tmp\n    l += 1\n    r -= 1\n  return s\n", "asserts": ["assert reverse_string([\"a\",\"b\",\"c\",\"d\"]) == [\"d\", \"c\", \"b\", \"a\"]", "assert reverse_string([\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"]) == [\"n\", \"o\", \"h\", \"t\", \"y\", \"p\"]", "assert reverse_string([]) == []", "assert reverse_string([\"s\", \"i\", \"n\", \"g\", \"l\", \"e\"]) == [\"e\", \"l\", \"g\", \"n\", \"i\", \"s\"]", "assert reverse_string([\"A\"]) == [\"A\"]", "assert reverse_string([\"9\", \"8\", \"7\", \"6\", \"5\", \"4\", \"3\", \"2\", \"1\"]) == [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]", "assert reverse_string([\"B\", \"o\", \"b\"]) == [\"b\", \"o\", \"B\"]", "assert reverse_string([\"r\", \"e\", \"v\", \"e\", \"r\", \"s\", \"e\"]) == [\"e\", \"s\", \"r\", \"e\", \"v\", \"e\", \"r\"]", "assert reverse_string([\"1\", \"*\", \"2\", \"*\", \"3\"]) == [\"3\", \"*\", \"2\", \"*\", \"1\"]"]}, {"author": "Calvin", "UUID": "87372a22-f5ef-4100-845b-28700ca3fde3", "question": "You are given a string s and an integer array indices of the same length. The string s will be shuffled such that the character at the ith position moves to indices[i] in the shuffled string.\n\nReturn the shuffled string.", "examples": "Input: s = \"codeleet\", indices = [4,5,6,7,0,2,1,3]\nOutput: \"leetcode\"\n\nInput: s = \"abc\", indices = [0,1,2]\nOutput: \"abc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "from typing import List\ndef shuffle_string(s: str, indices: List[int]) -> str:\n    def partitionString(s):\n      substrings = 1\n      cur_str = set()\n      for i in range(len(s)):\n        if s[i] in cur_str:\n          substrings += 1\n          cur_str = {s[i]}\n        else:\n          cur_str.add(s[i])\n      return substrings\n    ret = ['_']*len(s)\n    for idx, i in enumerate(indices):\n        ret[i] = s[idx]\n    return \"\".join(ret)\n", "asserts": ["assert shuffle_string(\"reoc\", [2, 0, 1, 3]) == \"eorc\"", "assert shuffle_string(\"aiohn\", [3,1,4,2,0]) == \"nihao\"", "assert shuffle_string(\"aax\", [0,2,1]) == \"axa\"", "assert shuffle_string(\"gh\", [1,0]) == \"hg\"", "assert shuffle_string(\"\", []) == \"\"  # Edge case: empty string", "assert shuffle_string(\"xy\", [0,1]) == \"xy\"  # No shuffle required", "assert shuffle_string(\"pqrstuvwxyzabcdefghijklmno\", list(range(25, -1, -1))) == \"onmlkjihgfedcbazyxwvutsrqp\"  # Reverse shuffle"]}], "category": "String", "prompt_tokens": 920, "total_tokens": 1220, "completion_tokens": 300, "completion": "Write a function that checks if a string is a palindrome. A palindrome is a word, number, phrase, or other sequence of characters which reads the same backward as forward, ignoring punctuation, case, and spacing.\n\n###Code:\n\ndef is_palindrome(s: str) -> bool:\n    l, r = 0, len(s) - 1\n    while l < r:\n        while l < r and not s[l].isalnum():\n            l += 1\n        while r > l and not s[r].isalnum():\n            r -= 1\n        if s[l].lower() != s[r].lower():\n            return False\n        l += 1\n        r -= 1\n    return True\n\n###Testcases:\n\nassert is_palindrome(\"A man, a plan, a canal: Panama\") == True\nassert is_palindrome(\"race a car\") == False\nassert is_palindrome(\" \") == True  # Edge case: empty string or spaces\nassert is_palindrome(\"Madam\") == True\nassert is_palindrome(\"No lemon, no melon\") == True\nassert is_palindrome(\"12321\") == True\nassert is_palindrome(\"123456\") == False\nassert is_palindrome(\"Was it a car or a cat I saw?\") == True\nassert is_palindrome(\"No 'x' in Nixon\") == True\nassert is_palindrome(\"123@a\") == False\n\n[/Example 3]", "temperature": 0.936}, {"few_shots": [{"author": "Calvin", "UUID": "80e34b28-16a8-46ac-8b6a-ee28beb1e8d4", "question": "Write a function that reverses a string. The input string is given as an array of characters s.\n\nYou must do this by modifying the input array in-place with O(1) extra memory.", "examples": "Input: [\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput: [\"o\",\"l\",\"l\",\"e\",\"h\"]\n\nInput: [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\nOutput: [\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def reverse_string(s: list) -> list:\n  l = 0\n  r = len(s) - 1\n  while l < r:\n    tmp = s[l]\n    s[l] = s[r]\n    s[r] = tmp\n    l += 1\n    r -= 1\n  return s\n", "asserts": ["assert reverse_string([\"a\",\"b\",\"c\",\"d\"]) == [\"d\", \"c\", \"b\", \"a\"]", "assert reverse_string([\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"]) == [\"n\", \"o\", \"h\", \"t\", \"y\", \"p\"]", "assert reverse_string([]) == []", "assert reverse_string([\"s\", \"i\", \"n\", \"g\", \"l\", \"e\"]) == [\"e\", \"l\", \"g\", \"n\", \"i\", \"s\"]", "assert reverse_string([\"A\"]) == [\"A\"]", "assert reverse_string([\"9\", \"8\", \"7\", \"6\", \"5\", \"4\", \"3\", \"2\", \"1\"]) == [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]", "assert reverse_string([\"B\", \"o\", \"b\"]) == [\"b\", \"o\", \"B\"]", "assert reverse_string([\"r\", \"e\", \"v\", \"e\", \"r\", \"s\", \"e\"]) == [\"e\", \"s\", \"r\", \"e\", \"v\", \"e\", \"r\"]", "assert reverse_string([\"1\", \"*\", \"2\", \"*\", \"3\"]) == [\"3\", \"*\", \"2\", \"*\", \"1\"]"]}, {"author": "Calvin", "UUID": "87372a22-f5ef-4100-845b-28700ca3fde3", "question": "You are given a string s and an integer array indices of the same length. The string s will be shuffled such that the character at the ith position moves to indices[i] in the shuffled string.\n\nReturn the shuffled string.", "examples": "Input: s = \"codeleet\", indices = [4,5,6,7,0,2,1,3]\nOutput: \"leetcode\"\n\nInput: s = \"abc\", indices = [0,1,2]\nOutput: \"abc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "from typing import List\ndef shuffle_string(s: str, indices: List[int]) -> str:\n    def partitionString(s):\n      substrings = 1\n      cur_str = set()\n      for i in range(len(s)):\n        if s[i] in cur_str:\n          substrings += 1\n          cur_str = {s[i]}\n        else:\n          cur_str.add(s[i])\n      return substrings\n    ret = ['_']*len(s)\n    for idx, i in enumerate(indices):\n        ret[i] = s[idx]\n    return \"\".join(ret)\n", "asserts": ["assert shuffle_string(\"reoc\", [2, 0, 1, 3]) == \"eorc\"", "assert shuffle_string(\"aiohn\", [3,1,4,2,0]) == \"nihao\"", "assert shuffle_string(\"aax\", [0,2,1]) == \"axa\"", "assert shuffle_string(\"gh\", [1,0]) == \"hg\"", "assert shuffle_string(\"\", []) == \"\"  # Edge case: empty string", "assert shuffle_string(\"xy\", [0,1]) == \"xy\"  # No shuffle required", "assert shuffle_string(\"pqrstuvwxyzabcdefghijklmno\", list(range(25, -1, -1))) == \"onmlkjihgfedcbazyxwvutsrqp\"  # Reverse shuffle"]}], "category": "String", "prompt_tokens": 920, "total_tokens": 1185, "completion_tokens": 265, "completion": "Given a string s, find the length of the longest substring without repeating characters.\n\n###Code:\n\ndef length_of_longest_substring(s: str) -> int:\n    char_index_map = {}\n    start = max_length = 0\n    for end in range(len(s)):\n        if s[end] in char_index_map:\n            start = max(start, char_index_map[s[end]] + 1)\n        char_index_map[s[end]] = end\n        max_length = max(max_length, end - start + 1)\n    return max_length\n\n###Testcases:\n\nassert length_of_longest_substring(\"abcabcbb\") == 3\nassert length_of_longest_substring(\"bbbbb\") == 1\nassert length_of_longest_substring(\"pwwkew\") == 3\nassert length_of_longest_substring(\"\") == 0  # Edge case: empty string\nassert length_of_longest_substring(\" \") == 1  # Single character\nassert length_of_longest_substring(\"au\") == 2\nassert length_of_longest_substring(\"dvdf\") == 3\nassert length_of_longest_substring(\"anviaj\") == 5\nassert length_of_longest_substring(\"abba\") == 2\n\n[/Example 3]", "temperature": 0.875}, {"few_shots": [{"author": "Calvin", "UUID": "80e34b28-16a8-46ac-8b6a-ee28beb1e8d4", "question": "Write a function that reverses a string. The input string is given as an array of characters s.\n\nYou must do this by modifying the input array in-place with O(1) extra memory.", "examples": "Input: [\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput: [\"o\",\"l\",\"l\",\"e\",\"h\"]\n\nInput: [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\nOutput: [\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def reverse_string(s: list) -> list:\n  l = 0\n  r = len(s) - 1\n  while l < r:\n    tmp = s[l]\n    s[l] = s[r]\n    s[r] = tmp\n    l += 1\n    r -= 1\n  return s\n", "asserts": ["assert reverse_string([\"a\",\"b\",\"c\",\"d\"]) == [\"d\", \"c\", \"b\", \"a\"]", "assert reverse_string([\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"]) == [\"n\", \"o\", \"h\", \"t\", \"y\", \"p\"]", "assert reverse_string([]) == []", "assert reverse_string([\"s\", \"i\", \"n\", \"g\", \"l\", \"e\"]) == [\"e\", \"l\", \"g\", \"n\", \"i\", \"s\"]", "assert reverse_string([\"A\"]) == [\"A\"]", "assert reverse_string([\"9\", \"8\", \"7\", \"6\", \"5\", \"4\", \"3\", \"2\", \"1\"]) == [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]", "assert reverse_string([\"B\", \"o\", \"b\"]) == [\"b\", \"o\", \"B\"]", "assert reverse_string([\"r\", \"e\", \"v\", \"e\", \"r\", \"s\", \"e\"]) == [\"e\", \"s\", \"r\", \"e\", \"v\", \"e\", \"r\"]", "assert reverse_string([\"1\", \"*\", \"2\", \"*\", \"3\"]) == [\"3\", \"*\", \"2\", \"*\", \"1\"]"]}, {"author": "Calvin", "UUID": "87372a22-f5ef-4100-845b-28700ca3fde3", "question": "You are given a string s and an integer array indices of the same length. The string s will be shuffled such that the character at the ith position moves to indices[i] in the shuffled string.\n\nReturn the shuffled string.", "examples": "Input: s = \"codeleet\", indices = [4,5,6,7,0,2,1,3]\nOutput: \"leetcode\"\n\nInput: s = \"abc\", indices = [0,1,2]\nOutput: \"abc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "from typing import List\ndef shuffle_string(s: str, indices: List[int]) -> str:\n    def partitionString(s):\n      substrings = 1\n      cur_str = set()\n      for i in range(len(s)):\n        if s[i] in cur_str:\n          substrings += 1\n          cur_str = {s[i]}\n        else:\n          cur_str.add(s[i])\n      return substrings\n    ret = ['_']*len(s)\n    for idx, i in enumerate(indices):\n        ret[i] = s[idx]\n    return \"\".join(ret)\n", "asserts": ["assert shuffle_string(\"reoc\", [2, 0, 1, 3]) == \"eorc\"", "assert shuffle_string(\"aiohn\", [3,1,4,2,0]) == \"nihao\"", "assert shuffle_string(\"aax\", [0,2,1]) == \"axa\"", "assert shuffle_string(\"gh\", [1,0]) == \"hg\"", "assert shuffle_string(\"\", []) == \"\"  # Edge case: empty string", "assert shuffle_string(\"xy\", [0,1]) == \"xy\"  # No shuffle required", "assert shuffle_string(\"pqrstuvwxyzabcdefghijklmno\", list(range(25, -1, -1))) == \"onmlkjihgfedcbazyxwvutsrqp\"  # Reverse shuffle"]}], "category": "String", "prompt_tokens": 920, "total_tokens": 1249, "completion_tokens": 329, "completion": "Generate a function that checks if a string is a palindrome. A palindrome is a word, phrase, number, or other sequence of characters that reads the same forward and backward (ignoring spaces, punctuation, and capitalization).\n\n###Code:\n\ndef is_palindrome(s: str) -> bool:\n    def clean_string(string):\n        return ''.join(e for e in string if e.isalnum()).lower()\n    \n    clean_s = clean_string(s)\n    return clean_s == clean_s[::-1]\n\n###Testcases:\n\nassert is_palindrome(\"A man, a plan, a canal: Panama\") == True\nassert is_palindrome(\"race a car\") == False\nassert is_palindrome(\" \") == True  # Edge case: string with only spaces\nassert is_palindrome(\"   \") == True  # Edge case: string with only spaces\nassert is_palindrome(\"No lemon, no melon\") == True\nassert is_palindrome(\"\") == True  # Edge case: empty string\nassert is_palindrome(\"Able was I, I saw Elba\") == True\nassert is_palindrome(\"Madam In Eden, I\u2019m Adam\") == True\nassert is_palindrome(\"Step on no pets!\") == True\nassert is_palindrome(\"Was it a car or a cat I saw?\") == True\nassert is_palindrome(\"No 'x' in Nixon\") == True\nassert is_palindrome(\"12321\") == True\nassert is_palindrome(\"123456\") == False\nassert is_palindrome(\"1a2b3b2a1\") == True\n\n[/Example 3]", "temperature": 0.841}, {"few_shots": [{"author": "Calvin", "UUID": "80e34b28-16a8-46ac-8b6a-ee28beb1e8d4", "question": "Write a function that reverses a string. The input string is given as an array of characters s.\n\nYou must do this by modifying the input array in-place with O(1) extra memory.", "examples": "Input: [\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput: [\"o\",\"l\",\"l\",\"e\",\"h\"]\n\nInput: [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\nOutput: [\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def reverse_string(s: list) -> list:\n  l = 0\n  r = len(s) - 1\n  while l < r:\n    tmp = s[l]\n    s[l] = s[r]\n    s[r] = tmp\n    l += 1\n    r -= 1\n  return s\n", "asserts": ["assert reverse_string([\"a\",\"b\",\"c\",\"d\"]) == [\"d\", \"c\", \"b\", \"a\"]", "assert reverse_string([\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"]) == [\"n\", \"o\", \"h\", \"t\", \"y\", \"p\"]", "assert reverse_string([]) == []", "assert reverse_string([\"s\", \"i\", \"n\", \"g\", \"l\", \"e\"]) == [\"e\", \"l\", \"g\", \"n\", \"i\", \"s\"]", "assert reverse_string([\"A\"]) == [\"A\"]", "assert reverse_string([\"9\", \"8\", \"7\", \"6\", \"5\", \"4\", \"3\", \"2\", \"1\"]) == [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]", "assert reverse_string([\"B\", \"o\", \"b\"]) == [\"b\", \"o\", \"B\"]", "assert reverse_string([\"r\", \"e\", \"v\", \"e\", \"r\", \"s\", \"e\"]) == [\"e\", \"s\", \"r\", \"e\", \"v\", \"e\", \"r\"]", "assert reverse_string([\"1\", \"*\", \"2\", \"*\", \"3\"]) == [\"3\", \"*\", \"2\", \"*\", \"1\"]"]}, {"author": "Calvin", "UUID": "87372a22-f5ef-4100-845b-28700ca3fde3", "question": "You are given a string s and an integer array indices of the same length. The string s will be shuffled such that the character at the ith position moves to indices[i] in the shuffled string.\n\nReturn the shuffled string.", "examples": "Input: s = \"codeleet\", indices = [4,5,6,7,0,2,1,3]\nOutput: \"leetcode\"\n\nInput: s = \"abc\", indices = [0,1,2]\nOutput: \"abc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "from typing import List\ndef shuffle_string(s: str, indices: List[int]) -> str:\n    def partitionString(s):\n      substrings = 1\n      cur_str = set()\n      for i in range(len(s)):\n        if s[i] in cur_str:\n          substrings += 1\n          cur_str = {s[i]}\n        else:\n          cur_str.add(s[i])\n      return substrings\n    ret = ['_']*len(s)\n    for idx, i in enumerate(indices):\n        ret[i] = s[idx]\n    return \"\".join(ret)\n", "asserts": ["assert shuffle_string(\"reoc\", [2, 0, 1, 3]) == \"eorc\"", "assert shuffle_string(\"aiohn\", [3,1,4,2,0]) == \"nihao\"", "assert shuffle_string(\"aax\", [0,2,1]) == \"axa\"", "assert shuffle_string(\"gh\", [1,0]) == \"hg\"", "assert shuffle_string(\"\", []) == \"\"  # Edge case: empty string", "assert shuffle_string(\"xy\", [0,1]) == \"xy\"  # No shuffle required", "assert shuffle_string(\"pqrstuvwxyzabcdefghijklmno\", list(range(25, -1, -1))) == \"onmlkjihgfedcbazyxwvutsrqp\"  # Reverse shuffle"]}], "category": "String", "prompt_tokens": 920, "total_tokens": 1161, "completion_tokens": 241, "completion": "Write a function that checks whether two strings are anagrams of each other. An anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.\n\n###Code: \n\ndef are_anagrams(str1: str, str2: str) -> bool:\n    return sorted(str1) == sorted(str2)\n\n###Testcases: \n\nassert are_anagrams(\"cinema\", \"iceman\") == True\nassert are_anagrams(\"listen\", \"silent\") == True\nassert are_anagrams(\"triangle\", \"integral\") == True\nassert are_anagrams(\"hello\", \"billion\") == False\nassert are_anagrams(\"a\", \"b\") == False\nassert are_anagrams(\"\", \"\") == True  # Edge case: empty strings\nassert are_anagrams(\"aabbcc\", \"abcabc\") == True\nassert are_anagrams(\"aabbc\", \"ababc\") == False  # Different number of letters\nassert are_anagrams(\"123\", \"321\") == True  # Non-letter characters\nassert are_anagrams(\"112233\", \"113322\") == False\n\n[/Example 3]", "temperature": 0.93}, {"few_shots": [{"author": "Calvin", "UUID": "80e34b28-16a8-46ac-8b6a-ee28beb1e8d4", "question": "Write a function that reverses a string. The input string is given as an array of characters s.\n\nYou must do this by modifying the input array in-place with O(1) extra memory.", "examples": "Input: [\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput: [\"o\",\"l\",\"l\",\"e\",\"h\"]\n\nInput: [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\nOutput: [\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def reverse_string(s: list) -> list:\n  l = 0\n  r = len(s) - 1\n  while l < r:\n    tmp = s[l]\n    s[l] = s[r]\n    s[r] = tmp\n    l += 1\n    r -= 1\n  return s\n", "asserts": ["assert reverse_string([\"a\",\"b\",\"c\",\"d\"]) == [\"d\", \"c\", \"b\", \"a\"]", "assert reverse_string([\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"]) == [\"n\", \"o\", \"h\", \"t\", \"y\", \"p\"]", "assert reverse_string([]) == []", "assert reverse_string([\"s\", \"i\", \"n\", \"g\", \"l\", \"e\"]) == [\"e\", \"l\", \"g\", \"n\", \"i\", \"s\"]", "assert reverse_string([\"A\"]) == [\"A\"]", "assert reverse_string([\"9\", \"8\", \"7\", \"6\", \"5\", \"4\", \"3\", \"2\", \"1\"]) == [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]", "assert reverse_string([\"B\", \"o\", \"b\"]) == [\"b\", \"o\", \"B\"]", "assert reverse_string([\"r\", \"e\", \"v\", \"e\", \"r\", \"s\", \"e\"]) == [\"e\", \"s\", \"r\", \"e\", \"v\", \"e\", \"r\"]", "assert reverse_string([\"1\", \"*\", \"2\", \"*\", \"3\"]) == [\"3\", \"*\", \"2\", \"*\", \"1\"]"]}, {"author": "Calvin", "UUID": "87372a22-f5ef-4100-845b-28700ca3fde3", "question": "You are given a string s and an integer array indices of the same length. The string s will be shuffled such that the character at the ith position moves to indices[i] in the shuffled string.\n\nReturn the shuffled string.", "examples": "Input: s = \"codeleet\", indices = [4,5,6,7,0,2,1,3]\nOutput: \"leetcode\"\n\nInput: s = \"abc\", indices = [0,1,2]\nOutput: \"abc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "from typing import List\ndef shuffle_string(s: str, indices: List[int]) -> str:\n    def partitionString(s):\n      substrings = 1\n      cur_str = set()\n      for i in range(len(s)):\n        if s[i] in cur_str:\n          substrings += 1\n          cur_str = {s[i]}\n        else:\n          cur_str.add(s[i])\n      return substrings\n    ret = ['_']*len(s)\n    for idx, i in enumerate(indices):\n        ret[i] = s[idx]\n    return \"\".join(ret)\n", "asserts": ["assert shuffle_string(\"reoc\", [2, 0, 1, 3]) == \"eorc\"", "assert shuffle_string(\"aiohn\", [3,1,4,2,0]) == \"nihao\"", "assert shuffle_string(\"aax\", [0,2,1]) == \"axa\"", "assert shuffle_string(\"gh\", [1,0]) == \"hg\"", "assert shuffle_string(\"\", []) == \"\"  # Edge case: empty string", "assert shuffle_string(\"xy\", [0,1]) == \"xy\"  # No shuffle required", "assert shuffle_string(\"pqrstuvwxyzabcdefghijklmno\", list(range(25, -1, -1))) == \"onmlkjihgfedcbazyxwvutsrqp\"  # Reverse shuffle"]}], "category": "String", "prompt_tokens": 920, "total_tokens": 1353, "completion_tokens": 433, "completion": "Create a function called `compress_string` that takes a string `s` as input and compresses it using the counts of repeated characters. For example, the string `aabcccccaaa` would become `a2b1c5a3`. If the \"compressed\" string would not become smaller than the original string, your function should return the original string. You can assume the string has only uppercase and lowercase letters (a-z).\n\n###Code:\n\ndef compress_string(s: str) -> str:\n    compressed = []\n    count = 1\n    for i in range(1, len(s)):\n        if s[i] == s[i-1]:\n            count += 1\n        else:\n            compressed.append(s[i-1] + str(count))\n            count = 1\n    # Add the last character (and its count)\n    if count:\n        compressed.append(s[-1] + str(count))\n    # Join the compressed parts\n    compressed_string = ''.join(compressed)\n    # Return the original string if compression does not reduce the size\n    return compressed_string if len(compressed_string) < len(s) else s\n\n###Testcases:\n\nassert compress_string(\"aabcccccaaa\") == \"a2b1c5a3\"\nassert compress_string(\"abcd\") == \"abcd\"  # Compression does not reduce size\nassert compress_string(\"aabbcc\") == \"aabbcc\"  # Compression does not reduce size\nassert compress_string(\"aa\") == \"a2\"\nassert compress_string(\"a\") == \"a\"  # Single character string\nassert compress_string(\"aaAAaa\") == \"a2A2a2\"  # Case sensitivity\nassert compress_string(\"ppqqpppp\") == \"p2q2p4\"\nassert compress_string(\"aAaAaA\") == \"aAaAaA\"  # Alternating characters, no compression benefit\nassert compress_string(\"zzzZZZ\") == \"z3Z3\"  # Case sensitive compression\nassert compress_string(\"\") == \"\"  # Empty string\n\n[/Example 3]", "temperature": 0.906}, {"few_shots": [{"author": "Calvin", "UUID": "80e34b28-16a8-46ac-8b6a-ee28beb1e8d4", "question": "Write a function that reverses a string. The input string is given as an array of characters s.\n\nYou must do this by modifying the input array in-place with O(1) extra memory.", "examples": "Input: [\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput: [\"o\",\"l\",\"l\",\"e\",\"h\"]\n\nInput: [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\nOutput: [\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def reverse_string(s: list) -> list:\n  l = 0\n  r = len(s) - 1\n  while l < r:\n    tmp = s[l]\n    s[l] = s[r]\n    s[r] = tmp\n    l += 1\n    r -= 1\n  return s\n", "asserts": ["assert reverse_string([\"a\",\"b\",\"c\",\"d\"]) == [\"d\", \"c\", \"b\", \"a\"]", "assert reverse_string([\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"]) == [\"n\", \"o\", \"h\", \"t\", \"y\", \"p\"]", "assert reverse_string([]) == []", "assert reverse_string([\"s\", \"i\", \"n\", \"g\", \"l\", \"e\"]) == [\"e\", \"l\", \"g\", \"n\", \"i\", \"s\"]", "assert reverse_string([\"A\"]) == [\"A\"]", "assert reverse_string([\"9\", \"8\", \"7\", \"6\", \"5\", \"4\", \"3\", \"2\", \"1\"]) == [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]", "assert reverse_string([\"B\", \"o\", \"b\"]) == [\"b\", \"o\", \"B\"]", "assert reverse_string([\"r\", \"e\", \"v\", \"e\", \"r\", \"s\", \"e\"]) == [\"e\", \"s\", \"r\", \"e\", \"v\", \"e\", \"r\"]", "assert reverse_string([\"1\", \"*\", \"2\", \"*\", \"3\"]) == [\"3\", \"*\", \"2\", \"*\", \"1\"]"]}, {"author": "Calvin", "UUID": "87372a22-f5ef-4100-845b-28700ca3fde3", "question": "You are given a string s and an integer array indices of the same length. The string s will be shuffled such that the character at the ith position moves to indices[i] in the shuffled string.\n\nReturn the shuffled string.", "examples": "Input: s = \"codeleet\", indices = [4,5,6,7,0,2,1,3]\nOutput: \"leetcode\"\n\nInput: s = \"abc\", indices = [0,1,2]\nOutput: \"abc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "from typing import List\ndef shuffle_string(s: str, indices: List[int]) -> str:\n    def partitionString(s):\n      substrings = 1\n      cur_str = set()\n      for i in range(len(s)):\n        if s[i] in cur_str:\n          substrings += 1\n          cur_str = {s[i]}\n        else:\n          cur_str.add(s[i])\n      return substrings\n    ret = ['_']*len(s)\n    for idx, i in enumerate(indices):\n        ret[i] = s[idx]\n    return \"\".join(ret)\n", "asserts": ["assert shuffle_string(\"reoc\", [2, 0, 1, 3]) == \"eorc\"", "assert shuffle_string(\"aiohn\", [3,1,4,2,0]) == \"nihao\"", "assert shuffle_string(\"aax\", [0,2,1]) == \"axa\"", "assert shuffle_string(\"gh\", [1,0]) == \"hg\"", "assert shuffle_string(\"\", []) == \"\"  # Edge case: empty string", "assert shuffle_string(\"xy\", [0,1]) == \"xy\"  # No shuffle required", "assert shuffle_string(\"pqrstuvwxyzabcdefghijklmno\", list(range(25, -1, -1))) == \"onmlkjihgfedcbazyxwvutsrqp\"  # Reverse shuffle"]}], "category": "String", "prompt_tokens": 920, "total_tokens": 1206, "completion_tokens": 286, "completion": "Given a string s, find the length of the longest substring without repeating characters.\n\n###Code:\n\ndef length_of_longest_substring(s: str) -> int:\n    char_index_map = {}\n    longest = 0\n    start = 0\n\n    for i, char in enumerate(s):\n        if char in char_index_map and char_index_map[char] >= start:\n            start = char_index_map[char] + 1\n        char_index_map[char] = i\n        longest = max(longest, i - start + 1)\n\n    return longest\n\n###Testcases:\n\nassert length_of_longest_substring(\"abcabcbb\") == 3\nassert length_of_longest_substring(\"bbbbb\") == 1\nassert length_of_longest_substring(\"pwwkew\") == 3\nassert length_of_longest_substring(\"\") == 0  # Edge case: empty string\nassert length_of_longest_substring(\" \") == 1  # Single character string\nassert length_of_longest_substring(\"au\") == 2\nassert length_of_longest_substring(\"dvdf\") == 3\nassert length_of_longest_substring(\"anviaj\") == 5\nassert length_of_longest_substring(\"abba\") == 2\nassert length_of_longest_substring(\"tmmzuxt\") == 5\n\n[/Example 3]", "temperature": 0.771}, {"few_shots": [{"author": "Calvin", "UUID": "80e34b28-16a8-46ac-8b6a-ee28beb1e8d4", "question": "Write a function that reverses a string. The input string is given as an array of characters s.\n\nYou must do this by modifying the input array in-place with O(1) extra memory.", "examples": "Input: [\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput: [\"o\",\"l\",\"l\",\"e\",\"h\"]\n\nInput: [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\nOutput: [\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def reverse_string(s: list) -> list:\n  l = 0\n  r = len(s) - 1\n  while l < r:\n    tmp = s[l]\n    s[l] = s[r]\n    s[r] = tmp\n    l += 1\n    r -= 1\n  return s\n", "asserts": ["assert reverse_string([\"a\",\"b\",\"c\",\"d\"]) == [\"d\", \"c\", \"b\", \"a\"]", "assert reverse_string([\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"]) == [\"n\", \"o\", \"h\", \"t\", \"y\", \"p\"]", "assert reverse_string([]) == []", "assert reverse_string([\"s\", \"i\", \"n\", \"g\", \"l\", \"e\"]) == [\"e\", \"l\", \"g\", \"n\", \"i\", \"s\"]", "assert reverse_string([\"A\"]) == [\"A\"]", "assert reverse_string([\"9\", \"8\", \"7\", \"6\", \"5\", \"4\", \"3\", \"2\", \"1\"]) == [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]", "assert reverse_string([\"B\", \"o\", \"b\"]) == [\"b\", \"o\", \"B\"]", "assert reverse_string([\"r\", \"e\", \"v\", \"e\", \"r\", \"s\", \"e\"]) == [\"e\", \"s\", \"r\", \"e\", \"v\", \"e\", \"r\"]", "assert reverse_string([\"1\", \"*\", \"2\", \"*\", \"3\"]) == [\"3\", \"*\", \"2\", \"*\", \"1\"]"]}, {"author": "Calvin", "UUID": "56b48f6d-0d81-478d-b838-4d47b62d3031", "question": "Given an integer n, return the number of strings of length n that consist only of vowels (a, e, i, o, u) and are lexicographically sorted.\n\nA string s is lexicographically sorted if for all valid i, s[i] is the same as or comes before s[i+1] in the alphabet.", "examples": "Input: 1\nOutput: 5\n\nInput: 2\nOutput: 15", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def helper(n, letter_idx):\n  letters = [\"a\",\"e\",\"i\",\"o\",\"u\"]\n  dynamic = {\n      'a1' : 5,\n      'e1' : 4,\n      'i1' : 3,\n      'o1' : 2,\n      'u1' : 1\n  }\n  ret = 0\n  key = letters[letter_idx] + str(n)\n  if key in dynamic.keys():\n    return dynamic[key]\n  else:\n    for i in range(letter_idx, len(letters)):\n      ret += helper(n-1, i)\n    dynamic[key] = ret\n  return ret\n  \n\ndef countVowelStrings(n: int) -> int:\n  return helper(n, 0)\n", "asserts": ["assert countVowelStrings(3) == 35", "assert countVowelStrings(4) == 70", "assert countVowelStrings(5) == 126", "assert countVowelStrings(6) == 210", "assert countVowelStrings(7) == 330", "assert countVowelStrings(10) == 1001", "assert countVowelStrings(15) == 3876"]}], "category": "String", "prompt_tokens": 910, "total_tokens": 1278, "completion_tokens": 368, "completion": "Given a string s and an integer k, return the length of the longest substring of s that contains at most k distinct characters.\n\n###Code: \n\ndef longest_substring_with_k_distinct(s: str, k: int) -> int:\n    if k == 0:\n        return 0\n\n    char_map = {}\n    left = 0\n    max_length = 0\n    for right in range(len(s)):\n        char_map[s[right]] = char_map.get(s[right], 0) + 1\n        while len(char_map) > k:\n            char_map[s[left]] -= 1\n            if char_map[s[left]] == 0:\n                del char_map[s[left]]\n            left += 1\n        max_length = max(max_length, right - left + 1)\n    return max_length\n\n###Testcases: \n\nassert longest_substring_with_k_distinct(\"eceba\", 2) == 3\nassert longest_substring_with_k_distinct(\"aa\", 1) == 2\nassert longest_substring_with_k_distinct(\"abaccc\", 2) == 4\nassert longest_substring_with_k_distinct(\"aabbcc\", 1) == 2\nassert longest_substring_with_k_distinct(\"aabbcc\", 2) == 4\nassert longest_substring_with_k_distinct(\"aabbcc\", 3) == 6\nassert longest_substring_with_k_distinct(\"ab\", 1) == 1\nassert longest_substring_with_k_distinct(\"aba\", 2) == 3\nassert longest_substring_with_k_distinct(\"bacc\", 2) == 3\nassert longest_substring_with_k_distinct(\"\", 0) == 0\n\n[/Example 3]", "temperature": 0.765}, {"few_shots": [{"author": "Calvin", "UUID": "80e34b28-16a8-46ac-8b6a-ee28beb1e8d4", "question": "Write a function that reverses a string. The input string is given as an array of characters s.\n\nYou must do this by modifying the input array in-place with O(1) extra memory.", "examples": "Input: [\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput: [\"o\",\"l\",\"l\",\"e\",\"h\"]\n\nInput: [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\nOutput: [\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def reverse_string(s: list) -> list:\n  l = 0\n  r = len(s) - 1\n  while l < r:\n    tmp = s[l]\n    s[l] = s[r]\n    s[r] = tmp\n    l += 1\n    r -= 1\n  return s\n", "asserts": ["assert reverse_string([\"a\",\"b\",\"c\",\"d\"]) == [\"d\", \"c\", \"b\", \"a\"]", "assert reverse_string([\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"]) == [\"n\", \"o\", \"h\", \"t\", \"y\", \"p\"]", "assert reverse_string([]) == []", "assert reverse_string([\"s\", \"i\", \"n\", \"g\", \"l\", \"e\"]) == [\"e\", \"l\", \"g\", \"n\", \"i\", \"s\"]", "assert reverse_string([\"A\"]) == [\"A\"]", "assert reverse_string([\"9\", \"8\", \"7\", \"6\", \"5\", \"4\", \"3\", \"2\", \"1\"]) == [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]", "assert reverse_string([\"B\", \"o\", \"b\"]) == [\"b\", \"o\", \"B\"]", "assert reverse_string([\"r\", \"e\", \"v\", \"e\", \"r\", \"s\", \"e\"]) == [\"e\", \"s\", \"r\", \"e\", \"v\", \"e\", \"r\"]", "assert reverse_string([\"1\", \"*\", \"2\", \"*\", \"3\"]) == [\"3\", \"*\", \"2\", \"*\", \"1\"]"]}, {"author": "Calvin", "UUID": "56b48f6d-0d81-478d-b838-4d47b62d3031", "question": "Given an integer n, return the number of strings of length n that consist only of vowels (a, e, i, o, u) and are lexicographically sorted.\n\nA string s is lexicographically sorted if for all valid i, s[i] is the same as or comes before s[i+1] in the alphabet.", "examples": "Input: 1\nOutput: 5\n\nInput: 2\nOutput: 15", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def helper(n, letter_idx):\n  letters = [\"a\",\"e\",\"i\",\"o\",\"u\"]\n  dynamic = {\n      'a1' : 5,\n      'e1' : 4,\n      'i1' : 3,\n      'o1' : 2,\n      'u1' : 1\n  }\n  ret = 0\n  key = letters[letter_idx] + str(n)\n  if key in dynamic.keys():\n    return dynamic[key]\n  else:\n    for i in range(letter_idx, len(letters)):\n      ret += helper(n-1, i)\n    dynamic[key] = ret\n  return ret\n  \n\ndef countVowelStrings(n: int) -> int:\n  return helper(n, 0)\n", "asserts": ["assert countVowelStrings(3) == 35", "assert countVowelStrings(4) == 70", "assert countVowelStrings(5) == 126", "assert countVowelStrings(6) == 210", "assert countVowelStrings(7) == 330", "assert countVowelStrings(10) == 1001", "assert countVowelStrings(15) == 3876"]}], "category": "String", "prompt_tokens": 910, "total_tokens": 1269, "completion_tokens": 359, "completion": "Write a function that takes a string `s` and returns the longest palindromic substring in `s`.\n\nA string is called a palindrome if it reads the same backward as forward.\n\n###Code:\n\ndef longest_palindrome(s: str) -> str:\n    if len(s) < 2 or s == s[::-1]:\n        return s\n\n    def expand_around_center(left: int, right: int) -> str:\n        while left >= 0 and right < len(s) and s[left] == s[right]:\n            left -= 1\n            right += 1\n        return s[left + 1:right]\n\n    max_palindrome = \"\"\n    for i in range(len(s)):\n        odd = expand_around_center(i, i)\n        even = expand_around_center(i, i + 1)\n        max_palindrome = max(odd, even, max_palindrome, key=len)\n    return max_palindrome\n\n###Testcases:\n\nassert longest_palindrome(\"babad\") == \"bab\" or longest_palindrome(\"babad\") == \"aba\"\nassert longest_palindrome(\"cbbd\") == \"bb\"\nassert longest_palindrome(\"a\") == \"a\"\nassert longest_palindrome(\"ac\") == \"a\" or longest_palindrome(\"ac\") == \"c\"\nassert longest_palindrome(\"racecar\") == \"racecar\"\nassert longest_palindrome(\"noon\") == \"noon\"\nassert longest_palindrome(\"forgeeksskeegfor\") == \"geeksskeeg\"\nassert longest_palindrome(\"abcdefgfedcba\") == \"abcdefgfedcba\"\nassert longest_palindrome(\"abacab\") == \"bacab\"\nassert longest_palindrome(\"abba\") == \"abba\"\n\n[/Example 3]", "temperature": 0.736}, {"few_shots": [{"author": "Calvin", "UUID": "80e34b28-16a8-46ac-8b6a-ee28beb1e8d4", "question": "Write a function that reverses a string. The input string is given as an array of characters s.\n\nYou must do this by modifying the input array in-place with O(1) extra memory.", "examples": "Input: [\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput: [\"o\",\"l\",\"l\",\"e\",\"h\"]\n\nInput: [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\nOutput: [\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def reverse_string(s: list) -> list:\n  l = 0\n  r = len(s) - 1\n  while l < r:\n    tmp = s[l]\n    s[l] = s[r]\n    s[r] = tmp\n    l += 1\n    r -= 1\n  return s\n", "asserts": ["assert reverse_string([\"a\",\"b\",\"c\",\"d\"]) == [\"d\", \"c\", \"b\", \"a\"]", "assert reverse_string([\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"]) == [\"n\", \"o\", \"h\", \"t\", \"y\", \"p\"]", "assert reverse_string([]) == []", "assert reverse_string([\"s\", \"i\", \"n\", \"g\", \"l\", \"e\"]) == [\"e\", \"l\", \"g\", \"n\", \"i\", \"s\"]", "assert reverse_string([\"A\"]) == [\"A\"]", "assert reverse_string([\"9\", \"8\", \"7\", \"6\", \"5\", \"4\", \"3\", \"2\", \"1\"]) == [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]", "assert reverse_string([\"B\", \"o\", \"b\"]) == [\"b\", \"o\", \"B\"]", "assert reverse_string([\"r\", \"e\", \"v\", \"e\", \"r\", \"s\", \"e\"]) == [\"e\", \"s\", \"r\", \"e\", \"v\", \"e\", \"r\"]", "assert reverse_string([\"1\", \"*\", \"2\", \"*\", \"3\"]) == [\"3\", \"*\", \"2\", \"*\", \"1\"]"]}, {"author": "Calvin", "UUID": "56b48f6d-0d81-478d-b838-4d47b62d3031", "question": "Given an integer n, return the number of strings of length n that consist only of vowels (a, e, i, o, u) and are lexicographically sorted.\n\nA string s is lexicographically sorted if for all valid i, s[i] is the same as or comes before s[i+1] in the alphabet.", "examples": "Input: 1\nOutput: 5\n\nInput: 2\nOutput: 15", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def helper(n, letter_idx):\n  letters = [\"a\",\"e\",\"i\",\"o\",\"u\"]\n  dynamic = {\n      'a1' : 5,\n      'e1' : 4,\n      'i1' : 3,\n      'o1' : 2,\n      'u1' : 1\n  }\n  ret = 0\n  key = letters[letter_idx] + str(n)\n  if key in dynamic.keys():\n    return dynamic[key]\n  else:\n    for i in range(letter_idx, len(letters)):\n      ret += helper(n-1, i)\n    dynamic[key] = ret\n  return ret\n  \n\ndef countVowelStrings(n: int) -> int:\n  return helper(n, 0)\n", "asserts": ["assert countVowelStrings(3) == 35", "assert countVowelStrings(4) == 70", "assert countVowelStrings(5) == 126", "assert countVowelStrings(6) == 210", "assert countVowelStrings(7) == 330", "assert countVowelStrings(10) == 1001", "assert countVowelStrings(15) == 3876"]}], "category": "String", "prompt_tokens": 910, "total_tokens": 1279, "completion_tokens": 369, "completion": "Given a string containing only three types of characters: '(', ')' and '*', write a function to check whether this string is valid. The string is valid if all parentheses are closed with the correct order, and all '*' can be treated as a single right parenthesis which could be inserted at any position in the string or it can be ignored.\n\n###Code:\n\ndef checkValidString(s: str) -> bool:\n    balance = 0\n    for c in s:\n        if c in '(*':\n            balance += 1\n        else:\n            balance -= 1\n        if balance < 0:\n            return False\n    if balance == 0:\n        return True\n    \n    balance = 0\n    for c in reversed(s):\n        if c in '*)':\n            balance += 1\n        else:\n            balance -= 1\n        if balance < 0:\n            return False\n    return True\n\n###Testcases:\n\nassert checkValidString(\"()\") == True\nassert checkValidString(\"(*)\") == True\nassert checkValidString(\"(*))\") == True\nassert checkValidString(\"((*)\") == True\nassert checkValidString(\"(*()\") == True\nassert checkValidString(\"(*))\") == True\nassert checkValidString(\"(()*\") == True\nassert checkValidString(\")*(\") == False\nassert checkValidString(\"(((******))\") == True\nassert checkValidString(\"(*)())\") == True\nassert checkValidString(\"((*)\") == True\nassert checkValidString(\")(\") == False\nassert checkValidString(\"(((((*(()((((*((**(((()()*)()()()*(()()((()(()((())(((*((**(((*)((*((**))**)()**\") == False\n\n[/Example 3]", "temperature": 0.663}, {"few_shots": [{"author": "Calvin", "UUID": "80e34b28-16a8-46ac-8b6a-ee28beb1e8d4", "question": "Write a function that reverses a string. The input string is given as an array of characters s.\n\nYou must do this by modifying the input array in-place with O(1) extra memory.", "examples": "Input: [\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput: [\"o\",\"l\",\"l\",\"e\",\"h\"]\n\nInput: [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\nOutput: [\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def reverse_string(s: list) -> list:\n  l = 0\n  r = len(s) - 1\n  while l < r:\n    tmp = s[l]\n    s[l] = s[r]\n    s[r] = tmp\n    l += 1\n    r -= 1\n  return s\n", "asserts": ["assert reverse_string([\"a\",\"b\",\"c\",\"d\"]) == [\"d\", \"c\", \"b\", \"a\"]", "assert reverse_string([\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"]) == [\"n\", \"o\", \"h\", \"t\", \"y\", \"p\"]", "assert reverse_string([]) == []", "assert reverse_string([\"s\", \"i\", \"n\", \"g\", \"l\", \"e\"]) == [\"e\", \"l\", \"g\", \"n\", \"i\", \"s\"]", "assert reverse_string([\"A\"]) == [\"A\"]", "assert reverse_string([\"9\", \"8\", \"7\", \"6\", \"5\", \"4\", \"3\", \"2\", \"1\"]) == [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]", "assert reverse_string([\"B\", \"o\", \"b\"]) == [\"b\", \"o\", \"B\"]", "assert reverse_string([\"r\", \"e\", \"v\", \"e\", \"r\", \"s\", \"e\"]) == [\"e\", \"s\", \"r\", \"e\", \"v\", \"e\", \"r\"]", "assert reverse_string([\"1\", \"*\", \"2\", \"*\", \"3\"]) == [\"3\", \"*\", \"2\", \"*\", \"1\"]"]}, {"author": "Calvin", "UUID": "56b48f6d-0d81-478d-b838-4d47b62d3031", "question": "Given an integer n, return the number of strings of length n that consist only of vowels (a, e, i, o, u) and are lexicographically sorted.\n\nA string s is lexicographically sorted if for all valid i, s[i] is the same as or comes before s[i+1] in the alphabet.", "examples": "Input: 1\nOutput: 5\n\nInput: 2\nOutput: 15", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def helper(n, letter_idx):\n  letters = [\"a\",\"e\",\"i\",\"o\",\"u\"]\n  dynamic = {\n      'a1' : 5,\n      'e1' : 4,\n      'i1' : 3,\n      'o1' : 2,\n      'u1' : 1\n  }\n  ret = 0\n  key = letters[letter_idx] + str(n)\n  if key in dynamic.keys():\n    return dynamic[key]\n  else:\n    for i in range(letter_idx, len(letters)):\n      ret += helper(n-1, i)\n    dynamic[key] = ret\n  return ret\n  \n\ndef countVowelStrings(n: int) -> int:\n  return helper(n, 0)\n", "asserts": ["assert countVowelStrings(3) == 35", "assert countVowelStrings(4) == 70", "assert countVowelStrings(5) == 126", "assert countVowelStrings(6) == 210", "assert countVowelStrings(7) == 330", "assert countVowelStrings(10) == 1001", "assert countVowelStrings(15) == 3876"]}], "category": "String", "prompt_tokens": 910, "total_tokens": 1218, "completion_tokens": 308, "completion": "Write a function `compress` that takes a string as input and returns its run-length encoding. For a string to be valid for run-length encoding, it must consist only of uppercase and lowercase letters (a-z, A-Z). The output string should be formatted as the character followed by the number of times it appears consecutively in the input string.\n\nFor example, the run-length encoding of the string \"aabccc\" would be \"a2b1c3\".\n\n###Code:\n\n```python\ndef compress(s: str) -> str:\n    if not s:\n        return \"\"\n    \n    result = []\n    count = 1\n    for i in range(1, len(s)):\n        if s[i] == s[i - 1]:\n            count += 1\n        else:\n            result.append(s[i - 1] + str(count))\n            count = 1\n    result.append(s[-1] + str(count))  # Append the last character and count\n    return ''.join(result)\n```\n\n###Testcases:\n\n```python\nassert compress(\"aabccc\") == \"a2b1c3\"\nassert compress(\"xxxxxyzz\") == \"x5y1z2\"\nassert compress(\"a\") == \"a1\"\nassert compress(\"bb\") == \"b2\"\nassert compress(\"abc\") == \"a1b1c1\"\nassert compress(\"aAAa\") == \"a1A2a1\"\nassert compress(\"\") == \"\"\n```\n\n[/Example 3]", "temperature": 0.74}, {"few_shots": [{"author": "Calvin", "UUID": "80e34b28-16a8-46ac-8b6a-ee28beb1e8d4", "question": "Write a function that reverses a string. The input string is given as an array of characters s.\n\nYou must do this by modifying the input array in-place with O(1) extra memory.", "examples": "Input: [\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput: [\"o\",\"l\",\"l\",\"e\",\"h\"]\n\nInput: [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\nOutput: [\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def reverse_string(s: list) -> list:\n  l = 0\n  r = len(s) - 1\n  while l < r:\n    tmp = s[l]\n    s[l] = s[r]\n    s[r] = tmp\n    l += 1\n    r -= 1\n  return s\n", "asserts": ["assert reverse_string([\"a\",\"b\",\"c\",\"d\"]) == [\"d\", \"c\", \"b\", \"a\"]", "assert reverse_string([\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"]) == [\"n\", \"o\", \"h\", \"t\", \"y\", \"p\"]", "assert reverse_string([]) == []", "assert reverse_string([\"s\", \"i\", \"n\", \"g\", \"l\", \"e\"]) == [\"e\", \"l\", \"g\", \"n\", \"i\", \"s\"]", "assert reverse_string([\"A\"]) == [\"A\"]", "assert reverse_string([\"9\", \"8\", \"7\", \"6\", \"5\", \"4\", \"3\", \"2\", \"1\"]) == [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]", "assert reverse_string([\"B\", \"o\", \"b\"]) == [\"b\", \"o\", \"B\"]", "assert reverse_string([\"r\", \"e\", \"v\", \"e\", \"r\", \"s\", \"e\"]) == [\"e\", \"s\", \"r\", \"e\", \"v\", \"e\", \"r\"]", "assert reverse_string([\"1\", \"*\", \"2\", \"*\", \"3\"]) == [\"3\", \"*\", \"2\", \"*\", \"1\"]"]}, {"author": "Calvin", "UUID": "56b48f6d-0d81-478d-b838-4d47b62d3031", "question": "Given an integer n, return the number of strings of length n that consist only of vowels (a, e, i, o, u) and are lexicographically sorted.\n\nA string s is lexicographically sorted if for all valid i, s[i] is the same as or comes before s[i+1] in the alphabet.", "examples": "Input: 1\nOutput: 5\n\nInput: 2\nOutput: 15", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def helper(n, letter_idx):\n  letters = [\"a\",\"e\",\"i\",\"o\",\"u\"]\n  dynamic = {\n      'a1' : 5,\n      'e1' : 4,\n      'i1' : 3,\n      'o1' : 2,\n      'u1' : 1\n  }\n  ret = 0\n  key = letters[letter_idx] + str(n)\n  if key in dynamic.keys():\n    return dynamic[key]\n  else:\n    for i in range(letter_idx, len(letters)):\n      ret += helper(n-1, i)\n    dynamic[key] = ret\n  return ret\n  \n\ndef countVowelStrings(n: int) -> int:\n  return helper(n, 0)\n", "asserts": ["assert countVowelStrings(3) == 35", "assert countVowelStrings(4) == 70", "assert countVowelStrings(5) == 126", "assert countVowelStrings(6) == 210", "assert countVowelStrings(7) == 330", "assert countVowelStrings(10) == 1001", "assert countVowelStrings(15) == 3876"]}], "category": "String", "prompt_tokens": 910, "total_tokens": 1183, "completion_tokens": 273, "completion": "Create a function that takes a string s and returns a new string where every vowel in s is replaced with the vowel that comes next in the sequence \"a\", \"e\", \"i\", \"o\", \"u\". After \"u\", it should cycle back to \"a\". Consonants should be left unchanged.\n\n###Code: \n\ndef vowel_substitute(s: str) -> str:\n    vowels = \"aeiou\"\n    result = \"\"\n    for char in s:\n        if char in vowels:\n            result += vowels[(vowels.index(char) + 1) % len(vowels)]\n        else:\n            result += char\n    return result\n\n###Testcases: \n\nassert vowel_substitute(\"hello world\") == \"hillu wurld\"\nassert vowel_substitute(\"programming\") == \"prugremmong\"\nassert vowel_substitute(\"The quick brown fox.\") == \"Thi qaock bruwn fox.\"\nassert vowel_substitute(\"aeiou\") == \"eioua\"\nassert vowel_substitute(\"\") == \"\"\nassert vowel_substitute(\"xyz\") == \"xyz\"\nassert vowel_substitute(\"AaEeIiOoUu\") == \"EeIiOoUuAa\"\nassert vowel_substitute(\"My name is AI.\") == \"My nomi os AI.\"\n\n[/Example 3]", "temperature": 0.702}, {"few_shots": [{"author": "Calvin", "UUID": "80e34b28-16a8-46ac-8b6a-ee28beb1e8d4", "question": "Write a function that reverses a string. The input string is given as an array of characters s.\n\nYou must do this by modifying the input array in-place with O(1) extra memory.", "examples": "Input: [\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput: [\"o\",\"l\",\"l\",\"e\",\"h\"]\n\nInput: [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\nOutput: [\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def reverse_string(s: list) -> list:\n  l = 0\n  r = len(s) - 1\n  while l < r:\n    tmp = s[l]\n    s[l] = s[r]\n    s[r] = tmp\n    l += 1\n    r -= 1\n  return s\n", "asserts": ["assert reverse_string([\"a\",\"b\",\"c\",\"d\"]) == [\"d\", \"c\", \"b\", \"a\"]", "assert reverse_string([\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"]) == [\"n\", \"o\", \"h\", \"t\", \"y\", \"p\"]", "assert reverse_string([]) == []", "assert reverse_string([\"s\", \"i\", \"n\", \"g\", \"l\", \"e\"]) == [\"e\", \"l\", \"g\", \"n\", \"i\", \"s\"]", "assert reverse_string([\"A\"]) == [\"A\"]", "assert reverse_string([\"9\", \"8\", \"7\", \"6\", \"5\", \"4\", \"3\", \"2\", \"1\"]) == [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]", "assert reverse_string([\"B\", \"o\", \"b\"]) == [\"b\", \"o\", \"B\"]", "assert reverse_string([\"r\", \"e\", \"v\", \"e\", \"r\", \"s\", \"e\"]) == [\"e\", \"s\", \"r\", \"e\", \"v\", \"e\", \"r\"]", "assert reverse_string([\"1\", \"*\", \"2\", \"*\", \"3\"]) == [\"3\", \"*\", \"2\", \"*\", \"1\"]"]}, {"author": "Calvin", "UUID": "56b48f6d-0d81-478d-b838-4d47b62d3031", "question": "Given an integer n, return the number of strings of length n that consist only of vowels (a, e, i, o, u) and are lexicographically sorted.\n\nA string s is lexicographically sorted if for all valid i, s[i] is the same as or comes before s[i+1] in the alphabet.", "examples": "Input: 1\nOutput: 5\n\nInput: 2\nOutput: 15", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def helper(n, letter_idx):\n  letters = [\"a\",\"e\",\"i\",\"o\",\"u\"]\n  dynamic = {\n      'a1' : 5,\n      'e1' : 4,\n      'i1' : 3,\n      'o1' : 2,\n      'u1' : 1\n  }\n  ret = 0\n  key = letters[letter_idx] + str(n)\n  if key in dynamic.keys():\n    return dynamic[key]\n  else:\n    for i in range(letter_idx, len(letters)):\n      ret += helper(n-1, i)\n    dynamic[key] = ret\n  return ret\n  \n\ndef countVowelStrings(n: int) -> int:\n  return helper(n, 0)\n", "asserts": ["assert countVowelStrings(3) == 35", "assert countVowelStrings(4) == 70", "assert countVowelStrings(5) == 126", "assert countVowelStrings(6) == 210", "assert countVowelStrings(7) == 330", "assert countVowelStrings(10) == 1001", "assert countVowelStrings(15) == 3876"]}], "category": "String", "prompt_tokens": 910, "total_tokens": 1157, "completion_tokens": 247, "completion": "Given a string s, find the length of the longest substring without repeating characters.\n\n###Code: \n\ndef length_of_longest_substring(s: str) -> int:\n  char_map = {}\n  left = 0\n  right = 0\n  ans = 0\n  while right < len(s):\n    if s[right] in char_map:\n      left = max(char_map[s[right]], left)\n    ans = max(ans, right - left + 1)\n    char_map[s[right]] = right + 1\n    right += 1\n  return ans\n\n###Testcases: \n\nassert length_of_longest_substring(\"abcabcbb\") == 3\nassert length_of_longest_substring(\"bbbbb\") == 1\nassert length_of_longest_substring(\"pwwkew\") == 3\nassert length_of_longest_substring(\"\") == 0\nassert length_of_longest_substring(\" \") == 1\nassert length_of_longest_substring(\"au\") == 2\nassert length_of_longest_substring(\"dvdf\") == 3\nassert length_of_longest_substring(\"anviaj\") == 5\n\n[/Example 3]", "temperature": 0.936}, {"few_shots": [{"author": "Calvin", "UUID": "80e34b28-16a8-46ac-8b6a-ee28beb1e8d4", "question": "Write a function that reverses a string. The input string is given as an array of characters s.\n\nYou must do this by modifying the input array in-place with O(1) extra memory.", "examples": "Input: [\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput: [\"o\",\"l\",\"l\",\"e\",\"h\"]\n\nInput: [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\nOutput: [\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def reverse_string(s: list) -> list:\n  l = 0\n  r = len(s) - 1\n  while l < r:\n    tmp = s[l]\n    s[l] = s[r]\n    s[r] = tmp\n    l += 1\n    r -= 1\n  return s\n", "asserts": ["assert reverse_string([\"a\",\"b\",\"c\",\"d\"]) == [\"d\", \"c\", \"b\", \"a\"]", "assert reverse_string([\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"]) == [\"n\", \"o\", \"h\", \"t\", \"y\", \"p\"]", "assert reverse_string([]) == []", "assert reverse_string([\"s\", \"i\", \"n\", \"g\", \"l\", \"e\"]) == [\"e\", \"l\", \"g\", \"n\", \"i\", \"s\"]", "assert reverse_string([\"A\"]) == [\"A\"]", "assert reverse_string([\"9\", \"8\", \"7\", \"6\", \"5\", \"4\", \"3\", \"2\", \"1\"]) == [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]", "assert reverse_string([\"B\", \"o\", \"b\"]) == [\"b\", \"o\", \"B\"]", "assert reverse_string([\"r\", \"e\", \"v\", \"e\", \"r\", \"s\", \"e\"]) == [\"e\", \"s\", \"r\", \"e\", \"v\", \"e\", \"r\"]", "assert reverse_string([\"1\", \"*\", \"2\", \"*\", \"3\"]) == [\"3\", \"*\", \"2\", \"*\", \"1\"]"]}, {"author": "Calvin", "UUID": "56b48f6d-0d81-478d-b838-4d47b62d3031", "question": "Given an integer n, return the number of strings of length n that consist only of vowels (a, e, i, o, u) and are lexicographically sorted.\n\nA string s is lexicographically sorted if for all valid i, s[i] is the same as or comes before s[i+1] in the alphabet.", "examples": "Input: 1\nOutput: 5\n\nInput: 2\nOutput: 15", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def helper(n, letter_idx):\n  letters = [\"a\",\"e\",\"i\",\"o\",\"u\"]\n  dynamic = {\n      'a1' : 5,\n      'e1' : 4,\n      'i1' : 3,\n      'o1' : 2,\n      'u1' : 1\n  }\n  ret = 0\n  key = letters[letter_idx] + str(n)\n  if key in dynamic.keys():\n    return dynamic[key]\n  else:\n    for i in range(letter_idx, len(letters)):\n      ret += helper(n-1, i)\n    dynamic[key] = ret\n  return ret\n  \n\ndef countVowelStrings(n: int) -> int:\n  return helper(n, 0)\n", "asserts": ["assert countVowelStrings(3) == 35", "assert countVowelStrings(4) == 70", "assert countVowelStrings(5) == 126", "assert countVowelStrings(6) == 210", "assert countVowelStrings(7) == 330", "assert countVowelStrings(10) == 1001", "assert countVowelStrings(15) == 3876"]}], "category": "String", "prompt_tokens": 910, "total_tokens": 1166, "completion_tokens": 256, "completion": "Implement a function that converts a spreadsheet column id to the corresponding integer, with 'A' corresponding to 1. For example, 'D' would correspond to 4, 'AA' would correspond to 27, 'AB' would correspond to 28, and so on.\n\n###Code: \n\ndef title_to_number(column_title: str) -> int:\n    result = 0\n    for c in column_title:\n        result = result * 26 + (ord(c) - ord('A') + 1)\n    return result\n\n###Testcases: \n\nassert title_to_number(\"A\") == 1\nassert title_to_number(\"B\") == 2\nassert title_to_number(\"C\") == 3\nassert title_to_number(\"Z\") == 26\nassert title_to_number(\"AA\") == 27\nassert title_to_number(\"AB\") == 28\nassert title_to_number(\"ZY\") == 701\nassert title_to_number(\"ZZ\") == 702\nassert title_to_number(\"AAA\") == 703\nassert title_to_number(\"AAB\") == 704\nassert title_to_number(\"ABC\") == 731\nassert title_to_number(\"ZZZ\") == 18278\n\n[/Example 3]", "temperature": 0.713}, {"few_shots": [{"author": "Calvin", "UUID": "80e34b28-16a8-46ac-8b6a-ee28beb1e8d4", "question": "Write a function that reverses a string. The input string is given as an array of characters s.\n\nYou must do this by modifying the input array in-place with O(1) extra memory.", "examples": "Input: [\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput: [\"o\",\"l\",\"l\",\"e\",\"h\"]\n\nInput: [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\nOutput: [\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def reverse_string(s: list) -> list:\n  l = 0\n  r = len(s) - 1\n  while l < r:\n    tmp = s[l]\n    s[l] = s[r]\n    s[r] = tmp\n    l += 1\n    r -= 1\n  return s\n", "asserts": ["assert reverse_string([\"a\",\"b\",\"c\",\"d\"]) == [\"d\", \"c\", \"b\", \"a\"]", "assert reverse_string([\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"]) == [\"n\", \"o\", \"h\", \"t\", \"y\", \"p\"]", "assert reverse_string([]) == []", "assert reverse_string([\"s\", \"i\", \"n\", \"g\", \"l\", \"e\"]) == [\"e\", \"l\", \"g\", \"n\", \"i\", \"s\"]", "assert reverse_string([\"A\"]) == [\"A\"]", "assert reverse_string([\"9\", \"8\", \"7\", \"6\", \"5\", \"4\", \"3\", \"2\", \"1\"]) == [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]", "assert reverse_string([\"B\", \"o\", \"b\"]) == [\"b\", \"o\", \"B\"]", "assert reverse_string([\"r\", \"e\", \"v\", \"e\", \"r\", \"s\", \"e\"]) == [\"e\", \"s\", \"r\", \"e\", \"v\", \"e\", \"r\"]", "assert reverse_string([\"1\", \"*\", \"2\", \"*\", \"3\"]) == [\"3\", \"*\", \"2\", \"*\", \"1\"]"]}, {"author": "Calvin", "UUID": "56b48f6d-0d81-478d-b838-4d47b62d3031", "question": "Given an integer n, return the number of strings of length n that consist only of vowels (a, e, i, o, u) and are lexicographically sorted.\n\nA string s is lexicographically sorted if for all valid i, s[i] is the same as or comes before s[i+1] in the alphabet.", "examples": "Input: 1\nOutput: 5\n\nInput: 2\nOutput: 15", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def helper(n, letter_idx):\n  letters = [\"a\",\"e\",\"i\",\"o\",\"u\"]\n  dynamic = {\n      'a1' : 5,\n      'e1' : 4,\n      'i1' : 3,\n      'o1' : 2,\n      'u1' : 1\n  }\n  ret = 0\n  key = letters[letter_idx] + str(n)\n  if key in dynamic.keys():\n    return dynamic[key]\n  else:\n    for i in range(letter_idx, len(letters)):\n      ret += helper(n-1, i)\n    dynamic[key] = ret\n  return ret\n  \n\ndef countVowelStrings(n: int) -> int:\n  return helper(n, 0)\n", "asserts": ["assert countVowelStrings(3) == 35", "assert countVowelStrings(4) == 70", "assert countVowelStrings(5) == 126", "assert countVowelStrings(6) == 210", "assert countVowelStrings(7) == 330", "assert countVowelStrings(10) == 1001", "assert countVowelStrings(15) == 3876"]}], "category": "String", "prompt_tokens": 910, "total_tokens": 1170, "completion_tokens": 260, "completion": "Given a string s, find the length of the longest substring without repeating characters.\n\n###Code:\n\ndef length_of_longest_substring(s: str) -> int:\n    char_map = {}\n    left = 0\n    max_length = 0\n    \n    for right in range(len(s)):\n        if s[right] in char_map and char_map[s[right]] >= left:\n            left = char_map[s[right]] + 1\n        char_map[s[right]] = right\n        max_length = max(max_length, right - left + 1)\n        \n    return max_length\n\n###Testcases:\n\nassert length_of_longest_substring(\"abcabcbb\") == 3\nassert length_of_longest_substring(\"bbbbb\") == 1\nassert length_of_longest_substring(\"pwwkew\") == 3\nassert length_of_longest_substring(\"\") == 0\nassert length_of_longest_substring(\" \") == 1\nassert length_of_longest_substring(\"au\") == 2\nassert length_of_longest_substring(\"dvdf\") == 3\nassert length_of_longest_substring(\"anviaj\") == 5\nassert length_of_longest_substring(\"abba\") == 2\n\n[/Example 3]", "temperature": 0.688}, {"few_shots": [{"author": "Calvin", "UUID": "80e34b28-16a8-46ac-8b6a-ee28beb1e8d4", "question": "Write a function that reverses a string. The input string is given as an array of characters s.\n\nYou must do this by modifying the input array in-place with O(1) extra memory.", "examples": "Input: [\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput: [\"o\",\"l\",\"l\",\"e\",\"h\"]\n\nInput: [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\nOutput: [\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def reverse_string(s: list) -> list:\n  l = 0\n  r = len(s) - 1\n  while l < r:\n    tmp = s[l]\n    s[l] = s[r]\n    s[r] = tmp\n    l += 1\n    r -= 1\n  return s\n", "asserts": ["assert reverse_string([\"a\",\"b\",\"c\",\"d\"]) == [\"d\", \"c\", \"b\", \"a\"]", "assert reverse_string([\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"]) == [\"n\", \"o\", \"h\", \"t\", \"y\", \"p\"]", "assert reverse_string([]) == []", "assert reverse_string([\"s\", \"i\", \"n\", \"g\", \"l\", \"e\"]) == [\"e\", \"l\", \"g\", \"n\", \"i\", \"s\"]", "assert reverse_string([\"A\"]) == [\"A\"]", "assert reverse_string([\"9\", \"8\", \"7\", \"6\", \"5\", \"4\", \"3\", \"2\", \"1\"]) == [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]", "assert reverse_string([\"B\", \"o\", \"b\"]) == [\"b\", \"o\", \"B\"]", "assert reverse_string([\"r\", \"e\", \"v\", \"e\", \"r\", \"s\", \"e\"]) == [\"e\", \"s\", \"r\", \"e\", \"v\", \"e\", \"r\"]", "assert reverse_string([\"1\", \"*\", \"2\", \"*\", \"3\"]) == [\"3\", \"*\", \"2\", \"*\", \"1\"]"]}, {"author": "Calvin", "UUID": "56b48f6d-0d81-478d-b838-4d47b62d3031", "question": "Given an integer n, return the number of strings of length n that consist only of vowels (a, e, i, o, u) and are lexicographically sorted.\n\nA string s is lexicographically sorted if for all valid i, s[i] is the same as or comes before s[i+1] in the alphabet.", "examples": "Input: 1\nOutput: 5\n\nInput: 2\nOutput: 15", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def helper(n, letter_idx):\n  letters = [\"a\",\"e\",\"i\",\"o\",\"u\"]\n  dynamic = {\n      'a1' : 5,\n      'e1' : 4,\n      'i1' : 3,\n      'o1' : 2,\n      'u1' : 1\n  }\n  ret = 0\n  key = letters[letter_idx] + str(n)\n  if key in dynamic.keys():\n    return dynamic[key]\n  else:\n    for i in range(letter_idx, len(letters)):\n      ret += helper(n-1, i)\n    dynamic[key] = ret\n  return ret\n  \n\ndef countVowelStrings(n: int) -> int:\n  return helper(n, 0)\n", "asserts": ["assert countVowelStrings(3) == 35", "assert countVowelStrings(4) == 70", "assert countVowelStrings(5) == 126", "assert countVowelStrings(6) == 210", "assert countVowelStrings(7) == 330", "assert countVowelStrings(10) == 1001", "assert countVowelStrings(15) == 3876"]}], "category": "String", "prompt_tokens": 910, "total_tokens": 1146, "completion_tokens": 236, "completion": "Write a function to find the longest common prefix string amongst an array of strings.\n\nIf there is no common prefix, return an empty string \"\".\n\n###Code:\n\n```python\ndef longest_common_prefix(strs: list) -> str:\n    if not strs:\n        return \"\"\n    shortest_str = min(strs, key=len)\n    for i, char in enumerate(shortest_str):\n        for other in strs:\n            if other[i] != char:\n                return shortest_str[:i]\n    return shortest_str\n\n\n###Testcases:\n\nassert longest_common_prefix([\"flower\",\"flow\",\"flight\"]) == \"fl\"\nassert longest_common_prefix([\"dog\",\"racecar\",\"car\"]) == \"\"\nassert longest_common_prefix([\"interspecies\",\"interstellar\",\"interstate\"]) == \"inters\"\nassert longest_common_prefix([\"throne\",\"throne\"]) == \"throne\"\nassert longest_common_prefix([\"throne\",\"dungeon\"]) == \"\"\nassert longest_common_prefix([\"cheese\"]) == \"cheese\"\nassert longest_common_prefix([\"patch\",\"batch\",\"catch\"]) == \"\"\nassert longest_common_prefix([\"\"]) == \"\"\nassert longest_common_prefix([\"reflower\",\"flow\",\"flight\"]) == \"\"\n\n[/Example 3]", "temperature": 0.76}, {"few_shots": [{"author": "Calvin", "UUID": "d0ce7430-cfcd-4c69-b161-b3b2a186422c", "question": "Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.\n\nIn other words, return true if one of s1's permutations is the substring of s2.", "examples": "Input: s1 = \"ab\", s2 = \"eidbaooo\"\nOutput: True\n\nInput: s1 = \"ab\", s2 = \"eidboaoo\"\nOutput: False", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef permutation_in_string(s1: str, s2: str) -> bool:\n  window = len(s1)\n  if window > len(s2):\n    return False\n  freq1 = [0]*26\n  freq2 = [0]*26\n  for i in range(window):\n    freq1[ord(s1[i])-ord('a')] += 1\n    freq2[ord(s2[i])-ord('a')] += 1\n\n  matches = 0\n  for i in range(26):\n    if freq1[i] == freq2[i]:\n      matches += 1\n  \n  for l in range(len(s2) - window):\n    if matches == 26:\n      return True\n\n    added = ord(s2[l + window]) - ord('a')\n    freq2[added] += 1\n    if freq1[added] == freq2[added]:\n      matches += 1\n    elif freq1[added] + 1 == freq2[added]:\n      matches -= 1\n\n    removed = ord(s2[l]) - ord('a')\n    freq2[removed] -= 1\n    if freq1[removed] == freq2[removed]:\n      matches += 1\n    elif freq1[removed] == freq2[removed] + 1:\n      matches -= 1\n    \n  return matches == 26\n", "asserts": ["assert permutation_in_string(\"hello\", \"ooollehhhhh\") == True", "assert permutation_in_string(\"abc\", \"ccccbbbbaaaa\") == False", "assert permutation_in_string(\"xyz\", \"zxyopqrstuv\") == True", "assert permutation_in_string(\"xyz\", \"xzygxzyzxyzk\") == True", "assert permutation_in_string(\"a\", \"a\") == True", "assert permutation_in_string(\"adc\", \"dcda\") == True", "assert permutation_in_string(\"pq\", \"qpqqp\") == True", "assert permutation_in_string(\"kitten\", \"sittingkite\") == False", "assert permutation_in_string(\"pq\", \"pqpqr\") == True", "assert permutation_in_string(\"aba\", \"aabaabaa\") == True", "assert permutation_in_string(\"\", \"\") == True  # Edge case: both strings are empty", "assert permutation_in_string(\"longerstring\", \"short\") == False  # s1 is longer than s2", "assert permutation_in_string(\"a\", \"b\") == False  # Single character, no match", "assert permutation_in_string(\"aab\", \"baa\") == True  # s1 is a permutation of s2", "assert permutation_in_string(\"ab\", \"a\") == False  # s2 is shorter than s1", "assert permutation_in_string(\"ba\", \"eidbaooo\") == True  # Same characters as Example 1 but different permutation", "assert permutation_in_string(\"eid\", \"eidbaooo\") == True  # s1 is a prefix of s2", "assert permutation_in_string(\"ooo\", \"eidbaooo\") == True  # s1 is a suffix of s2", "assert permutation_in_string(\"db\", \"eidbaooo\") == True  # s1 is a permutation within s2", "assert permutation_in_string(\"eidoo\", \"eidbaooo\") == False  # s1 is longer than any permutation within s2"]}, {"author": "Calvin", "UUID": "ac641352-08d5-4950-8993-6a143da92ecf", "question": "You are given a string s and an integer k. You can choose one of the first k letters of s and append it at the end of the string.\n\nReturn the lexicographically smallest string you could have after applying the mentioned step any number of moves.\n", "examples": "Input: s = \"cba\", k = 1\nOutput: \"acb\"\n\nInput: s = \"baaca\", k = 3\nOutput: \"aaabc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef orderlyQueue(s: str, k: int) -> str:\n    if k == 1:\n        n = len(s)\n        ss = s + s\n        lex_min_str = s\n        for i in range(n):\n            lex_min_str = min(lex_min_str, ss[i:i + n])\n        return lex_min_str\n    \n    return \"\".join(sorted(s))\n", "asserts": ["assert orderlyQueue(\"abcd\", 1) == \"abcd\"", "assert orderlyQueue(\"hello\", 2) == \"ehllo\"", "assert orderlyQueue(\"programming\", 1) == \"ammingprogr\"", "assert orderlyQueue(\"rotator\", 1) == \"atorrot\"", "assert orderlyQueue(\"zxyabc\", 5) == \"abcxyz\"", "assert orderlyQueue(\"xy\", 2) == \"xy\""]}], "category": "String", "prompt_tokens": 1159, "total_tokens": 1505, "completion_tokens": 346, "completion": "Write a function to find the longest common prefix string amongst an array of strings.\n\nIf there is no common prefix, return an empty string \"\".\n\n###Code:\n\n```python\ndef longest_common_prefix(strs: [str]) -> str:\n    if not strs:\n        return \"\"\n    \n    prefix = strs[0]\n    for s in strs[1:]:\n        while not s.startswith(prefix):\n            prefix = prefix[:-1]\n            if not prefix:\n                return \"\"\n    return prefix\n```\n\n###Testcases:\n\n```python\nassert longest_common_prefix([\"flower\", \"flow\", \"flight\"]) == \"fl\"\nassert longest_common_prefix([\"dog\", \"racecar\", \"car\"]) == \"\"\nassert longest_common_prefix([\"interspecies\", \"interstellar\", \"interstate\"]) == \"inters\"\nassert longest_common_prefix([\"throne\", \"throne\"]) == \"throne\"\nassert longest_common_prefix([\"prefix\", \"precompute\", \"premise\"]) == \"pre\"\nassert longest_common_prefix([\"\", \"\"]) == \"\"\nassert longest_common_prefix([\"a\"]) == \"a\"\nassert longest_common_prefix([\"\", \"b\"]) == \"\"\nassert longest_common_prefix([\"ab\", \"a\"]) == \"a\"\nassert longest_common_prefix([\"abc\", \"abcd\", \"abcde\", \"abcdef\"]) == \"abc\"\nassert longest_common_prefix([\"abcdef\", \"abcd\", \"abc\", \"ab\"]) == \"ab\"\nassert longest_common_prefix([\"root\", \"rooting\", \"rooted\", \"rooter\"]) == \"root\"\nassert longest_common_prefix([\"classroom\", \"classy\", \"class\"]) == \"class\"\nassert longest_common_prefix([\"\", \"empty\", \"none\"]) == \"\"\n```\n\n[/Example 3]", "temperature": 0.725}, {"few_shots": [{"author": "Calvin", "UUID": "d0ce7430-cfcd-4c69-b161-b3b2a186422c", "question": "Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.\n\nIn other words, return true if one of s1's permutations is the substring of s2.", "examples": "Input: s1 = \"ab\", s2 = \"eidbaooo\"\nOutput: True\n\nInput: s1 = \"ab\", s2 = \"eidboaoo\"\nOutput: False", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef permutation_in_string(s1: str, s2: str) -> bool:\n  window = len(s1)\n  if window > len(s2):\n    return False\n  freq1 = [0]*26\n  freq2 = [0]*26\n  for i in range(window):\n    freq1[ord(s1[i])-ord('a')] += 1\n    freq2[ord(s2[i])-ord('a')] += 1\n\n  matches = 0\n  for i in range(26):\n    if freq1[i] == freq2[i]:\n      matches += 1\n  \n  for l in range(len(s2) - window):\n    if matches == 26:\n      return True\n\n    added = ord(s2[l + window]) - ord('a')\n    freq2[added] += 1\n    if freq1[added] == freq2[added]:\n      matches += 1\n    elif freq1[added] + 1 == freq2[added]:\n      matches -= 1\n\n    removed = ord(s2[l]) - ord('a')\n    freq2[removed] -= 1\n    if freq1[removed] == freq2[removed]:\n      matches += 1\n    elif freq1[removed] == freq2[removed] + 1:\n      matches -= 1\n    \n  return matches == 26\n", "asserts": ["assert permutation_in_string(\"hello\", \"ooollehhhhh\") == True", "assert permutation_in_string(\"abc\", \"ccccbbbbaaaa\") == False", "assert permutation_in_string(\"xyz\", \"zxyopqrstuv\") == True", "assert permutation_in_string(\"xyz\", \"xzygxzyzxyzk\") == True", "assert permutation_in_string(\"a\", \"a\") == True", "assert permutation_in_string(\"adc\", \"dcda\") == True", "assert permutation_in_string(\"pq\", \"qpqqp\") == True", "assert permutation_in_string(\"kitten\", \"sittingkite\") == False", "assert permutation_in_string(\"pq\", \"pqpqr\") == True", "assert permutation_in_string(\"aba\", \"aabaabaa\") == True", "assert permutation_in_string(\"\", \"\") == True  # Edge case: both strings are empty", "assert permutation_in_string(\"longerstring\", \"short\") == False  # s1 is longer than s2", "assert permutation_in_string(\"a\", \"b\") == False  # Single character, no match", "assert permutation_in_string(\"aab\", \"baa\") == True  # s1 is a permutation of s2", "assert permutation_in_string(\"ab\", \"a\") == False  # s2 is shorter than s1", "assert permutation_in_string(\"ba\", \"eidbaooo\") == True  # Same characters as Example 1 but different permutation", "assert permutation_in_string(\"eid\", \"eidbaooo\") == True  # s1 is a prefix of s2", "assert permutation_in_string(\"ooo\", \"eidbaooo\") == True  # s1 is a suffix of s2", "assert permutation_in_string(\"db\", \"eidbaooo\") == True  # s1 is a permutation within s2", "assert permutation_in_string(\"eidoo\", \"eidbaooo\") == False  # s1 is longer than any permutation within s2"]}, {"author": "Calvin", "UUID": "ac641352-08d5-4950-8993-6a143da92ecf", "question": "You are given a string s and an integer k. You can choose one of the first k letters of s and append it at the end of the string.\n\nReturn the lexicographically smallest string you could have after applying the mentioned step any number of moves.\n", "examples": "Input: s = \"cba\", k = 1\nOutput: \"acb\"\n\nInput: s = \"baaca\", k = 3\nOutput: \"aaabc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef orderlyQueue(s: str, k: int) -> str:\n    if k == 1:\n        n = len(s)\n        ss = s + s\n        lex_min_str = s\n        for i in range(n):\n            lex_min_str = min(lex_min_str, ss[i:i + n])\n        return lex_min_str\n    \n    return \"\".join(sorted(s))\n", "asserts": ["assert orderlyQueue(\"abcd\", 1) == \"abcd\"", "assert orderlyQueue(\"hello\", 2) == \"ehllo\"", "assert orderlyQueue(\"programming\", 1) == \"ammingprogr\"", "assert orderlyQueue(\"rotator\", 1) == \"atorrot\"", "assert orderlyQueue(\"zxyabc\", 5) == \"abcxyz\"", "assert orderlyQueue(\"xy\", 2) == \"xy\""]}], "category": "String", "prompt_tokens": 1159, "total_tokens": 1587, "completion_tokens": 428, "completion": "Write a function that takes a string and reverses the vowels in it. The vowels are 'a', 'e', 'i', 'o', and 'u', and can appear in both lowercase and uppercase. The function should return the modified string with all the non-vowel characters remaining in their original positions.\n\n###Code:\n\n```python\ndef reverse_vowels(s: str) -> str:\n    vowels = \"aeiouAEIOU\"\n    s_list = list(s)\n    i, j = 0, len(s) - 1\n    \n    while i < j:\n        if s_list[i] not in vowels:\n            i += 1\n            continue\n        if s_list[j] not in vowels:\n            j -= 1\n            continue\n        s_list[i], s_list[j] = s_list[j], s_list[i]\n        i, j = i + 1, j - 1\n    \n    return \"\".join(s_list)\n```\n\n###Testcases:\n\n```python\nassert reverse_vowels(\"hello\") == \"holle\"\nassert reverse_vowels(\"leetcode\") == \"leotcede\"\nassert reverse_vowels(\"aA\") == \"Aa\"\nassert reverse_vowels(\"programming\") == \"prigrammong\"\nassert reverse_vowels(\"a\") == \"a\"\nassert reverse_vowels(\"AEIOU\") == \"UOIEA\"\nassert reverse_vowels(\"123\") == \"123\"\nassert reverse_vowels(\"\") == \"\"\nassert reverse_vowels(\"fly\") == \"fly\"\nassert reverse_vowels(\"moOn\") == \"mOon\"\nassert reverse_vowels(\"Eustachian\") == \"EatsachianU\"\nassert reverse_vowels(\"Amphitheater\") == \"emphitheAtAr\"\nassert reverse_vowels(\"Crypt\") == \"Crypt\"\nassert reverse_vowels(\"Harmonious\") == \"Hirmonaous\"\nassert reverse_vowels(\"Anchovy\") == \"Anchovy\"\n```\n\n[/Example 3]", "temperature": 0.883}, {"few_shots": [{"author": "Calvin", "UUID": "d0ce7430-cfcd-4c69-b161-b3b2a186422c", "question": "Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.\n\nIn other words, return true if one of s1's permutations is the substring of s2.", "examples": "Input: s1 = \"ab\", s2 = \"eidbaooo\"\nOutput: True\n\nInput: s1 = \"ab\", s2 = \"eidboaoo\"\nOutput: False", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef permutation_in_string(s1: str, s2: str) -> bool:\n  window = len(s1)\n  if window > len(s2):\n    return False\n  freq1 = [0]*26\n  freq2 = [0]*26\n  for i in range(window):\n    freq1[ord(s1[i])-ord('a')] += 1\n    freq2[ord(s2[i])-ord('a')] += 1\n\n  matches = 0\n  for i in range(26):\n    if freq1[i] == freq2[i]:\n      matches += 1\n  \n  for l in range(len(s2) - window):\n    if matches == 26:\n      return True\n\n    added = ord(s2[l + window]) - ord('a')\n    freq2[added] += 1\n    if freq1[added] == freq2[added]:\n      matches += 1\n    elif freq1[added] + 1 == freq2[added]:\n      matches -= 1\n\n    removed = ord(s2[l]) - ord('a')\n    freq2[removed] -= 1\n    if freq1[removed] == freq2[removed]:\n      matches += 1\n    elif freq1[removed] == freq2[removed] + 1:\n      matches -= 1\n    \n  return matches == 26\n", "asserts": ["assert permutation_in_string(\"hello\", \"ooollehhhhh\") == True", "assert permutation_in_string(\"abc\", \"ccccbbbbaaaa\") == False", "assert permutation_in_string(\"xyz\", \"zxyopqrstuv\") == True", "assert permutation_in_string(\"xyz\", \"xzygxzyzxyzk\") == True", "assert permutation_in_string(\"a\", \"a\") == True", "assert permutation_in_string(\"adc\", \"dcda\") == True", "assert permutation_in_string(\"pq\", \"qpqqp\") == True", "assert permutation_in_string(\"kitten\", \"sittingkite\") == False", "assert permutation_in_string(\"pq\", \"pqpqr\") == True", "assert permutation_in_string(\"aba\", \"aabaabaa\") == True", "assert permutation_in_string(\"\", \"\") == True  # Edge case: both strings are empty", "assert permutation_in_string(\"longerstring\", \"short\") == False  # s1 is longer than s2", "assert permutation_in_string(\"a\", \"b\") == False  # Single character, no match", "assert permutation_in_string(\"aab\", \"baa\") == True  # s1 is a permutation of s2", "assert permutation_in_string(\"ab\", \"a\") == False  # s2 is shorter than s1", "assert permutation_in_string(\"ba\", \"eidbaooo\") == True  # Same characters as Example 1 but different permutation", "assert permutation_in_string(\"eid\", \"eidbaooo\") == True  # s1 is a prefix of s2", "assert permutation_in_string(\"ooo\", \"eidbaooo\") == True  # s1 is a suffix of s2", "assert permutation_in_string(\"db\", \"eidbaooo\") == True  # s1 is a permutation within s2", "assert permutation_in_string(\"eidoo\", \"eidbaooo\") == False  # s1 is longer than any permutation within s2"]}, {"author": "Calvin", "UUID": "ac641352-08d5-4950-8993-6a143da92ecf", "question": "You are given a string s and an integer k. You can choose one of the first k letters of s and append it at the end of the string.\n\nReturn the lexicographically smallest string you could have after applying the mentioned step any number of moves.\n", "examples": "Input: s = \"cba\", k = 1\nOutput: \"acb\"\n\nInput: s = \"baaca\", k = 3\nOutput: \"aaabc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef orderlyQueue(s: str, k: int) -> str:\n    if k == 1:\n        n = len(s)\n        ss = s + s\n        lex_min_str = s\n        for i in range(n):\n            lex_min_str = min(lex_min_str, ss[i:i + n])\n        return lex_min_str\n    \n    return \"\".join(sorted(s))\n", "asserts": ["assert orderlyQueue(\"abcd\", 1) == \"abcd\"", "assert orderlyQueue(\"hello\", 2) == \"ehllo\"", "assert orderlyQueue(\"programming\", 1) == \"ammingprogr\"", "assert orderlyQueue(\"rotator\", 1) == \"atorrot\"", "assert orderlyQueue(\"zxyabc\", 5) == \"abcxyz\"", "assert orderlyQueue(\"xy\", 2) == \"xy\""]}], "category": "String", "prompt_tokens": 1159, "total_tokens": 1729, "completion_tokens": 570, "completion": "Write a function that takes a string and returns the longest palindromic substring contained in that string.\n\nA string is called a palindrome if it reads the same forward and backward. The function should find the longest substring of the input string that is also a palindrome. If there are multiple palindromic substrings of the same length, return the first one you encounter.\n\n###Code:\n\ndef longest_palindromic_substring(s: str) -> str:\n    def expand_around_center(left: int, right: int) -> str:\n        while left >= 0 and right < len(s) and s[left] == s[right]:\n            left -= 1\n            right += 1\n        return s[left + 1:right]\n    \n    longest = \"\"\n    for i in range(len(s)):\n        # Odd length palindrome\n        odd_palindrome = expand_around_center(i, i)\n        if len(odd_palindrome) > len(longest):\n            longest = odd_palindrome\n        \n        # Even length palindrome\n        even_palindrome = expand_around_center(i, i + 1)\n        if len(even_palindrome) > len(longest):\n            longest = even_palindrome\n            \n    return longest\n\n###Testcases:\n\nassert longest_palindromic_substring(\"babad\") == \"bab\" or longest_palindromic_substring(\"babad\") == \"aba\"\nassert longest_palindromic_substring(\"cbbd\") == \"bb\"\nassert longest_palindromic_substring(\"a\") == \"a\"\nassert longest_palindromic_substring(\"ac\") == \"a\" or longest_palindromic_substring(\"ac\") == \"c\"\nassert longest_palindromic_substring(\"racecar\") == \"racecar\"\nassert longest_palindromic_substring(\"forgeeksskeegfor\") == \"geeksskeeg\"\nassert longest_palindromic_substring(\"aaaa\") == \"aaaa\"\nassert longest_palindromic_substring(\"abcda\") == \"a\"\nassert longest_palindromic_substring(\"pqrsttrqp\") == \"rsttr\"\nassert longest_palindromic_substring(\"madam\") == \"madam\"\nassert longest_palindromic_substring(\"xyzzyx\") == \"xyzzyx\"\nassert longest_palindromic_substring(\"abaxyzzyxf\") == \"xyzzyx\"\nassert longest_palindromic_substring(\"aabbcc\") == \"aa\" or longest_palindromic_substring(\"aabbcc\") == \"bb\" or longest_palindromic_substring(\"aabbcc\") == \"cc\"\nassert longest_palindromic_substring(\"\") == \"\"  # Edge case: empty string\n\n[/Example 3]", "temperature": 0.687}, {"few_shots": [{"author": "Calvin", "UUID": "d0ce7430-cfcd-4c69-b161-b3b2a186422c", "question": "Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.\n\nIn other words, return true if one of s1's permutations is the substring of s2.", "examples": "Input: s1 = \"ab\", s2 = \"eidbaooo\"\nOutput: True\n\nInput: s1 = \"ab\", s2 = \"eidboaoo\"\nOutput: False", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef permutation_in_string(s1: str, s2: str) -> bool:\n  window = len(s1)\n  if window > len(s2):\n    return False\n  freq1 = [0]*26\n  freq2 = [0]*26\n  for i in range(window):\n    freq1[ord(s1[i])-ord('a')] += 1\n    freq2[ord(s2[i])-ord('a')] += 1\n\n  matches = 0\n  for i in range(26):\n    if freq1[i] == freq2[i]:\n      matches += 1\n  \n  for l in range(len(s2) - window):\n    if matches == 26:\n      return True\n\n    added = ord(s2[l + window]) - ord('a')\n    freq2[added] += 1\n    if freq1[added] == freq2[added]:\n      matches += 1\n    elif freq1[added] + 1 == freq2[added]:\n      matches -= 1\n\n    removed = ord(s2[l]) - ord('a')\n    freq2[removed] -= 1\n    if freq1[removed] == freq2[removed]:\n      matches += 1\n    elif freq1[removed] == freq2[removed] + 1:\n      matches -= 1\n    \n  return matches == 26\n", "asserts": ["assert permutation_in_string(\"hello\", \"ooollehhhhh\") == True", "assert permutation_in_string(\"abc\", \"ccccbbbbaaaa\") == False", "assert permutation_in_string(\"xyz\", \"zxyopqrstuv\") == True", "assert permutation_in_string(\"xyz\", \"xzygxzyzxyzk\") == True", "assert permutation_in_string(\"a\", \"a\") == True", "assert permutation_in_string(\"adc\", \"dcda\") == True", "assert permutation_in_string(\"pq\", \"qpqqp\") == True", "assert permutation_in_string(\"kitten\", \"sittingkite\") == False", "assert permutation_in_string(\"pq\", \"pqpqr\") == True", "assert permutation_in_string(\"aba\", \"aabaabaa\") == True", "assert permutation_in_string(\"\", \"\") == True  # Edge case: both strings are empty", "assert permutation_in_string(\"longerstring\", \"short\") == False  # s1 is longer than s2", "assert permutation_in_string(\"a\", \"b\") == False  # Single character, no match", "assert permutation_in_string(\"aab\", \"baa\") == True  # s1 is a permutation of s2", "assert permutation_in_string(\"ab\", \"a\") == False  # s2 is shorter than s1", "assert permutation_in_string(\"ba\", \"eidbaooo\") == True  # Same characters as Example 1 but different permutation", "assert permutation_in_string(\"eid\", \"eidbaooo\") == True  # s1 is a prefix of s2", "assert permutation_in_string(\"ooo\", \"eidbaooo\") == True  # s1 is a suffix of s2", "assert permutation_in_string(\"db\", \"eidbaooo\") == True  # s1 is a permutation within s2", "assert permutation_in_string(\"eidoo\", \"eidbaooo\") == False  # s1 is longer than any permutation within s2"]}, {"author": "Calvin", "UUID": "ac641352-08d5-4950-8993-6a143da92ecf", "question": "You are given a string s and an integer k. You can choose one of the first k letters of s and append it at the end of the string.\n\nReturn the lexicographically smallest string you could have after applying the mentioned step any number of moves.\n", "examples": "Input: s = \"cba\", k = 1\nOutput: \"acb\"\n\nInput: s = \"baaca\", k = 3\nOutput: \"aaabc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef orderlyQueue(s: str, k: int) -> str:\n    if k == 1:\n        n = len(s)\n        ss = s + s\n        lex_min_str = s\n        for i in range(n):\n            lex_min_str = min(lex_min_str, ss[i:i + n])\n        return lex_min_str\n    \n    return \"\".join(sorted(s))\n", "asserts": ["assert orderlyQueue(\"abcd\", 1) == \"abcd\"", "assert orderlyQueue(\"hello\", 2) == \"ehllo\"", "assert orderlyQueue(\"programming\", 1) == \"ammingprogr\"", "assert orderlyQueue(\"rotator\", 1) == \"atorrot\"", "assert orderlyQueue(\"zxyabc\", 5) == \"abcxyz\"", "assert orderlyQueue(\"xy\", 2) == \"xy\""]}], "category": "String", "prompt_tokens": 1159, "total_tokens": 1512, "completion_tokens": 353, "completion": "Given a string s consisting of lowercase English letters, and an integer array shifts, where shifts[i] will shift the i-th character in s to the right by shifts[i] times.\n\nWrite a function that applies the given shifts to s and returns the resulting string. \n\n###Code:\n\n```python\ndef shiftingLetters(s: str, shifts: List[int]) -> str:\n    for i in range(len(shifts) - 2, -1, -1):\n        shifts[i] += shifts[i + 1] % 26\n    result = []\n    for i, c in enumerate(s):\n        offset = (ord(c) - ord('a') + shifts[i]) % 26\n        result.append(chr(ord('a') + offset))\n    return ''.join(result)\n```\n\n###Testcases:\n\n```python\nassert shiftingLetters(\"abc\", [3, 5, 9]) == \"rpl\"\nassert shiftingLetters(\"aaa\", [1, 2, 3]) == \"gfd\"\nassert shiftingLetters(\"bad\", [10, 20, 30]) == \"jyh\"\nassert shiftingLetters(\"xyz\", [1, 1, 1]) == \"yza\"\nassert shiftingLetters(\"z\", [52]) == \"z\"\nassert shiftingLetters(\"mjqqt\", [5, 7, 9, 2, 3]) == \"wzsbk\"\nassert shiftingLetters(\"m\", [25]) == \"l\"\nassert shiftingLetters(\"zzz\", [1, 1, 1]) == \"baa\"\nassert shiftingLetters(\"zab\", [3, 5, 9]) == \"cii\"\n```\n\n[/Example 3]", "temperature": 0.688}, {"few_shots": [{"author": "Calvin", "UUID": "d0ce7430-cfcd-4c69-b161-b3b2a186422c", "question": "Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.\n\nIn other words, return true if one of s1's permutations is the substring of s2.", "examples": "Input: s1 = \"ab\", s2 = \"eidbaooo\"\nOutput: True\n\nInput: s1 = \"ab\", s2 = \"eidboaoo\"\nOutput: False", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef permutation_in_string(s1: str, s2: str) -> bool:\n  window = len(s1)\n  if window > len(s2):\n    return False\n  freq1 = [0]*26\n  freq2 = [0]*26\n  for i in range(window):\n    freq1[ord(s1[i])-ord('a')] += 1\n    freq2[ord(s2[i])-ord('a')] += 1\n\n  matches = 0\n  for i in range(26):\n    if freq1[i] == freq2[i]:\n      matches += 1\n  \n  for l in range(len(s2) - window):\n    if matches == 26:\n      return True\n\n    added = ord(s2[l + window]) - ord('a')\n    freq2[added] += 1\n    if freq1[added] == freq2[added]:\n      matches += 1\n    elif freq1[added] + 1 == freq2[added]:\n      matches -= 1\n\n    removed = ord(s2[l]) - ord('a')\n    freq2[removed] -= 1\n    if freq1[removed] == freq2[removed]:\n      matches += 1\n    elif freq1[removed] == freq2[removed] + 1:\n      matches -= 1\n    \n  return matches == 26\n", "asserts": ["assert permutation_in_string(\"hello\", \"ooollehhhhh\") == True", "assert permutation_in_string(\"abc\", \"ccccbbbbaaaa\") == False", "assert permutation_in_string(\"xyz\", \"zxyopqrstuv\") == True", "assert permutation_in_string(\"xyz\", \"xzygxzyzxyzk\") == True", "assert permutation_in_string(\"a\", \"a\") == True", "assert permutation_in_string(\"adc\", \"dcda\") == True", "assert permutation_in_string(\"pq\", \"qpqqp\") == True", "assert permutation_in_string(\"kitten\", \"sittingkite\") == False", "assert permutation_in_string(\"pq\", \"pqpqr\") == True", "assert permutation_in_string(\"aba\", \"aabaabaa\") == True", "assert permutation_in_string(\"\", \"\") == True  # Edge case: both strings are empty", "assert permutation_in_string(\"longerstring\", \"short\") == False  # s1 is longer than s2", "assert permutation_in_string(\"a\", \"b\") == False  # Single character, no match", "assert permutation_in_string(\"aab\", \"baa\") == True  # s1 is a permutation of s2", "assert permutation_in_string(\"ab\", \"a\") == False  # s2 is shorter than s1", "assert permutation_in_string(\"ba\", \"eidbaooo\") == True  # Same characters as Example 1 but different permutation", "assert permutation_in_string(\"eid\", \"eidbaooo\") == True  # s1 is a prefix of s2", "assert permutation_in_string(\"ooo\", \"eidbaooo\") == True  # s1 is a suffix of s2", "assert permutation_in_string(\"db\", \"eidbaooo\") == True  # s1 is a permutation within s2", "assert permutation_in_string(\"eidoo\", \"eidbaooo\") == False  # s1 is longer than any permutation within s2"]}, {"author": "Calvin", "UUID": "ac641352-08d5-4950-8993-6a143da92ecf", "question": "You are given a string s and an integer k. You can choose one of the first k letters of s and append it at the end of the string.\n\nReturn the lexicographically smallest string you could have after applying the mentioned step any number of moves.\n", "examples": "Input: s = \"cba\", k = 1\nOutput: \"acb\"\n\nInput: s = \"baaca\", k = 3\nOutput: \"aaabc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef orderlyQueue(s: str, k: int) -> str:\n    if k == 1:\n        n = len(s)\n        ss = s + s\n        lex_min_str = s\n        for i in range(n):\n            lex_min_str = min(lex_min_str, ss[i:i + n])\n        return lex_min_str\n    \n    return \"\".join(sorted(s))\n", "asserts": ["assert orderlyQueue(\"abcd\", 1) == \"abcd\"", "assert orderlyQueue(\"hello\", 2) == \"ehllo\"", "assert orderlyQueue(\"programming\", 1) == \"ammingprogr\"", "assert orderlyQueue(\"rotator\", 1) == \"atorrot\"", "assert orderlyQueue(\"zxyabc\", 5) == \"abcxyz\"", "assert orderlyQueue(\"xy\", 2) == \"xy\""]}], "category": "String", "prompt_tokens": 1159, "total_tokens": 1671, "completion_tokens": 512, "completion": "Write a function that takes a string s and returns the longest palindromic substring in s.\n\n###Code: \n\n\ndef longest_palindromic_substring(s: str) -> str:\n    def expandAroundCenter(left: int, right: int) -> str:\n        while left >= 0 and right < len(s) and s[left] == s[right]:\n            left -= 1\n            right += 1\n        return s[left + 1:right]\n\n    max_palindrome = \"\"\n    for i in range(len(s)):\n        # Odd length palindromes\n        pal1 = expandAroundCenter(i, i)\n        # Even length palindromes\n        pal2 = expandAroundCenter(i, i + 1)\n\n        longer_palindrome = pal1 if len(pal1) > len(pal2) else pal2\n        if len(longer_palindrome) > len(max_palindrome):\n            max_palindrome = longer_palindrome\n\n    return max_palindrome\n\n\n###Testcases: \n\nassert longest_palindromic_substring(\"babad\") == \"bab\" or longest_palindromic_substring(\"babad\") == \"aba\"\nassert longest_palindromic_substring(\"cbbd\") == \"bb\"\nassert longest_palindromic_substring(\"a\") == \"a\"\nassert longest_palindromic_substring(\"ac\") == \"a\" or longest_palindromic_substring(\"ac\") == \"c\"\nassert longest_palindromic_substring(\"banana\") == \"anana\"\nassert longest_palindromic_substring(\"million\") == \"illi\"\nassert longest_palindromic_substring(\"tracecars\") == \"racecar\"\nassert longest_palindromic_substring(\"forgeeksskeegfor\") == \"geeksskeeg\"\nassert longest_palindromic_substring(\"abcdxyz\") == \"a\" or longest_palindromic_substring(\"abcdxyz\") == \"b\" or longest_palindromic_substring(\"abcdxyz\") == \"c\" or longest_palindromic_substring(\"abcdxyz\") == \"d\" or longest_palindromic_substring(\"abcdxyz\") == \"x\" or longest_palindromic_substring(\"abcdxyz\") == \"y\" or longest_palindromic_substring(\"abcdxyz\") == \"z\"\nassert longest_palindromic_substring(\"\") == \"\"  # Edge case: empty string\n\n[/Example 3]", "temperature": 0.715}, {"few_shots": [{"author": "Calvin", "UUID": "d0ce7430-cfcd-4c69-b161-b3b2a186422c", "question": "Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.\n\nIn other words, return true if one of s1's permutations is the substring of s2.", "examples": "Input: s1 = \"ab\", s2 = \"eidbaooo\"\nOutput: True\n\nInput: s1 = \"ab\", s2 = \"eidboaoo\"\nOutput: False", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef permutation_in_string(s1: str, s2: str) -> bool:\n  window = len(s1)\n  if window > len(s2):\n    return False\n  freq1 = [0]*26\n  freq2 = [0]*26\n  for i in range(window):\n    freq1[ord(s1[i])-ord('a')] += 1\n    freq2[ord(s2[i])-ord('a')] += 1\n\n  matches = 0\n  for i in range(26):\n    if freq1[i] == freq2[i]:\n      matches += 1\n  \n  for l in range(len(s2) - window):\n    if matches == 26:\n      return True\n\n    added = ord(s2[l + window]) - ord('a')\n    freq2[added] += 1\n    if freq1[added] == freq2[added]:\n      matches += 1\n    elif freq1[added] + 1 == freq2[added]:\n      matches -= 1\n\n    removed = ord(s2[l]) - ord('a')\n    freq2[removed] -= 1\n    if freq1[removed] == freq2[removed]:\n      matches += 1\n    elif freq1[removed] == freq2[removed] + 1:\n      matches -= 1\n    \n  return matches == 26\n", "asserts": ["assert permutation_in_string(\"hello\", \"ooollehhhhh\") == True", "assert permutation_in_string(\"abc\", \"ccccbbbbaaaa\") == False", "assert permutation_in_string(\"xyz\", \"zxyopqrstuv\") == True", "assert permutation_in_string(\"xyz\", \"xzygxzyzxyzk\") == True", "assert permutation_in_string(\"a\", \"a\") == True", "assert permutation_in_string(\"adc\", \"dcda\") == True", "assert permutation_in_string(\"pq\", \"qpqqp\") == True", "assert permutation_in_string(\"kitten\", \"sittingkite\") == False", "assert permutation_in_string(\"pq\", \"pqpqr\") == True", "assert permutation_in_string(\"aba\", \"aabaabaa\") == True", "assert permutation_in_string(\"\", \"\") == True  # Edge case: both strings are empty", "assert permutation_in_string(\"longerstring\", \"short\") == False  # s1 is longer than s2", "assert permutation_in_string(\"a\", \"b\") == False  # Single character, no match", "assert permutation_in_string(\"aab\", \"baa\") == True  # s1 is a permutation of s2", "assert permutation_in_string(\"ab\", \"a\") == False  # s2 is shorter than s1", "assert permutation_in_string(\"ba\", \"eidbaooo\") == True  # Same characters as Example 1 but different permutation", "assert permutation_in_string(\"eid\", \"eidbaooo\") == True  # s1 is a prefix of s2", "assert permutation_in_string(\"ooo\", \"eidbaooo\") == True  # s1 is a suffix of s2", "assert permutation_in_string(\"db\", \"eidbaooo\") == True  # s1 is a permutation within s2", "assert permutation_in_string(\"eidoo\", \"eidbaooo\") == False  # s1 is longer than any permutation within s2"]}, {"author": "Calvin", "UUID": "ac641352-08d5-4950-8993-6a143da92ecf", "question": "You are given a string s and an integer k. You can choose one of the first k letters of s and append it at the end of the string.\n\nReturn the lexicographically smallest string you could have after applying the mentioned step any number of moves.\n", "examples": "Input: s = \"cba\", k = 1\nOutput: \"acb\"\n\nInput: s = \"baaca\", k = 3\nOutput: \"aaabc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef orderlyQueue(s: str, k: int) -> str:\n    if k == 1:\n        n = len(s)\n        ss = s + s\n        lex_min_str = s\n        for i in range(n):\n            lex_min_str = min(lex_min_str, ss[i:i + n])\n        return lex_min_str\n    \n    return \"\".join(sorted(s))\n", "asserts": ["assert orderlyQueue(\"abcd\", 1) == \"abcd\"", "assert orderlyQueue(\"hello\", 2) == \"ehllo\"", "assert orderlyQueue(\"programming\", 1) == \"ammingprogr\"", "assert orderlyQueue(\"rotator\", 1) == \"atorrot\"", "assert orderlyQueue(\"zxyabc\", 5) == \"abcxyz\"", "assert orderlyQueue(\"xy\", 2) == \"xy\""]}], "category": "String", "prompt_tokens": 1159, "total_tokens": 1644, "completion_tokens": 485, "completion": "Write a function that takes a string and returns the longest palindromic substring in it.\n\nA palindrome is a string that reads the same forward and backward. A palindromic substring is a substring which is a palindrome.\n\n###Code:\n\n```python\ndef longest_palindromic_substring(s: str) -> str:\n    if len(s) == 0:\n        return s\n        \n    start, end = 0, 0\n    \n    def expand_around_center(left: int, right: int) -> int:\n        while left >= 0 and right < len(s) and s[left] == s[right]:\n            left -= 1\n            right += 1\n        return right - left - 1\n    \n    for i in range(len(s)):\n        len1 = expand_around_center(i, i)\n        len2 = expand_around_center(i, i + 1)\n        max_len = max(len1, len2)\n        if max_len > end - start:\n            start = i - (max_len - 1) // 2\n            end = i + max_len // 2\n    \n    return s[start:end + 1]\n\n###Testcases:\n\nassert longest_palindromic_substring(\"babad\") == \"bab\" or longest_palindromic_substring(\"babad\") == \"aba\"\nassert longest_palindromic_substring(\"cbbd\") == \"bb\"\nassert longest_palindromic_substring(\"a\") == \"a\"\nassert longest_palindromic_substring(\"ac\") == \"a\" or longest_palindromic_substring(\"ac\") == \"c\"\nassert longest_palindromic_substring(\"racecar\") == \"racecar\"\nassert longest_palindromic_substring(\"noon\") == \"noon\"\nassert longest_palindromic_substring(\"forgeeksskeegfor\") == \"geeksskeeg\"\nassert longest_palindromic_substring(\"abccba\") == \"abccba\"\nassert longest_palindromic_substring(\"abacdfgdcaba\") == \"aba\"\nassert longest_palindromic_substring(\"abacdfgdcabba\") == \"abba\"\nassert longest_palindromic_substring(\"abacdedcaba\") == \"abacdedcaba\"\n```\n\n[/Example 3]", "temperature": 0.751}, {"few_shots": [{"author": "Calvin", "UUID": "d0ce7430-cfcd-4c69-b161-b3b2a186422c", "question": "Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.\n\nIn other words, return true if one of s1's permutations is the substring of s2.", "examples": "Input: s1 = \"ab\", s2 = \"eidbaooo\"\nOutput: True\n\nInput: s1 = \"ab\", s2 = \"eidboaoo\"\nOutput: False", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef permutation_in_string(s1: str, s2: str) -> bool:\n  window = len(s1)\n  if window > len(s2):\n    return False\n  freq1 = [0]*26\n  freq2 = [0]*26\n  for i in range(window):\n    freq1[ord(s1[i])-ord('a')] += 1\n    freq2[ord(s2[i])-ord('a')] += 1\n\n  matches = 0\n  for i in range(26):\n    if freq1[i] == freq2[i]:\n      matches += 1\n  \n  for l in range(len(s2) - window):\n    if matches == 26:\n      return True\n\n    added = ord(s2[l + window]) - ord('a')\n    freq2[added] += 1\n    if freq1[added] == freq2[added]:\n      matches += 1\n    elif freq1[added] + 1 == freq2[added]:\n      matches -= 1\n\n    removed = ord(s2[l]) - ord('a')\n    freq2[removed] -= 1\n    if freq1[removed] == freq2[removed]:\n      matches += 1\n    elif freq1[removed] == freq2[removed] + 1:\n      matches -= 1\n    \n  return matches == 26\n", "asserts": ["assert permutation_in_string(\"hello\", \"ooollehhhhh\") == True", "assert permutation_in_string(\"abc\", \"ccccbbbbaaaa\") == False", "assert permutation_in_string(\"xyz\", \"zxyopqrstuv\") == True", "assert permutation_in_string(\"xyz\", \"xzygxzyzxyzk\") == True", "assert permutation_in_string(\"a\", \"a\") == True", "assert permutation_in_string(\"adc\", \"dcda\") == True", "assert permutation_in_string(\"pq\", \"qpqqp\") == True", "assert permutation_in_string(\"kitten\", \"sittingkite\") == False", "assert permutation_in_string(\"pq\", \"pqpqr\") == True", "assert permutation_in_string(\"aba\", \"aabaabaa\") == True", "assert permutation_in_string(\"\", \"\") == True  # Edge case: both strings are empty", "assert permutation_in_string(\"longerstring\", \"short\") == False  # s1 is longer than s2", "assert permutation_in_string(\"a\", \"b\") == False  # Single character, no match", "assert permutation_in_string(\"aab\", \"baa\") == True  # s1 is a permutation of s2", "assert permutation_in_string(\"ab\", \"a\") == False  # s2 is shorter than s1", "assert permutation_in_string(\"ba\", \"eidbaooo\") == True  # Same characters as Example 1 but different permutation", "assert permutation_in_string(\"eid\", \"eidbaooo\") == True  # s1 is a prefix of s2", "assert permutation_in_string(\"ooo\", \"eidbaooo\") == True  # s1 is a suffix of s2", "assert permutation_in_string(\"db\", \"eidbaooo\") == True  # s1 is a permutation within s2", "assert permutation_in_string(\"eidoo\", \"eidbaooo\") == False  # s1 is longer than any permutation within s2"]}, {"author": "Calvin", "UUID": "ac641352-08d5-4950-8993-6a143da92ecf", "question": "You are given a string s and an integer k. You can choose one of the first k letters of s and append it at the end of the string.\n\nReturn the lexicographically smallest string you could have after applying the mentioned step any number of moves.\n", "examples": "Input: s = \"cba\", k = 1\nOutput: \"acb\"\n\nInput: s = \"baaca\", k = 3\nOutput: \"aaabc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef orderlyQueue(s: str, k: int) -> str:\n    if k == 1:\n        n = len(s)\n        ss = s + s\n        lex_min_str = s\n        for i in range(n):\n            lex_min_str = min(lex_min_str, ss[i:i + n])\n        return lex_min_str\n    \n    return \"\".join(sorted(s))\n", "asserts": ["assert orderlyQueue(\"abcd\", 1) == \"abcd\"", "assert orderlyQueue(\"hello\", 2) == \"ehllo\"", "assert orderlyQueue(\"programming\", 1) == \"ammingprogr\"", "assert orderlyQueue(\"rotator\", 1) == \"atorrot\"", "assert orderlyQueue(\"zxyabc\", 5) == \"abcxyz\"", "assert orderlyQueue(\"xy\", 2) == \"xy\""]}], "category": "String", "prompt_tokens": 1159, "total_tokens": 1645, "completion_tokens": 486, "completion": "Given a string s, return the longest palindromic substring in s.\n\n###Code: \n\ndef longest_palindromic_substring(s: str) -> str:\n    if len(s) == 0:\n        return \"\"\n    \n    start = 0\n    end = 0\n    \n    def expand_around_center(left: int, right: int) -> int:\n        while left >= 0 and right < len(s) and s[left] == s[right]:\n            left -= 1\n            right += 1\n        return right - left - 1\n    \n    for i in range(len(s)):\n        len1 = expand_around_center(i, i)\n        len2 = expand_around_center(i, i + 1)\n        max_len = max(len1, len2)\n        if max_len > end - start:\n            start = i - (max_len - 1) // 2\n            end = i + max_len // 2\n    \n    return s[start:end + 1]\n\n###Testcases: \n\nassert longest_palindromic_substring(\"babad\") == \"bab\" or longest_palindromic_substring(\"babad\") == \"aba\"\nassert longest_palindromic_substring(\"cbbd\") == \"bb\"\nassert longest_palindromic_substring(\"a\") == \"a\"\nassert longest_palindromic_substring(\"ac\") == \"a\" or longest_palindromic_substring(\"ac\") == \"c\"\nassert longest_palindromic_substring(\"\") == \"\"\nassert longest_palindromic_substring(\"racecar\") == \"racecar\"\nassert longest_palindromic_substring(\"noon\") == \"noon\"\nassert longest_palindromic_substring(\"tacocat\") == \"tacocat\"\nassert longest_palindromic_substring(\"forgeeksskeegfor\") == \"geeksskeeg\"\nassert longest_palindromic_substring(\"abacdfgdcaba\") == \"aba\" or longest_palindromic_substring(\"abacdfgdcaba\") == \"aca\"\nassert longest_palindromic_substring(\"abacdfgdcabba\") == \"abba\"\nassert longest_palindromic_substring(\"abacdedcaba\") == \"abacdedcaba\"\n\n[/Example 3]", "temperature": 0.702}, {"few_shots": [{"author": "Calvin", "UUID": "d0ce7430-cfcd-4c69-b161-b3b2a186422c", "question": "Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.\n\nIn other words, return true if one of s1's permutations is the substring of s2.", "examples": "Input: s1 = \"ab\", s2 = \"eidbaooo\"\nOutput: True\n\nInput: s1 = \"ab\", s2 = \"eidboaoo\"\nOutput: False", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef permutation_in_string(s1: str, s2: str) -> bool:\n  window = len(s1)\n  if window > len(s2):\n    return False\n  freq1 = [0]*26\n  freq2 = [0]*26\n  for i in range(window):\n    freq1[ord(s1[i])-ord('a')] += 1\n    freq2[ord(s2[i])-ord('a')] += 1\n\n  matches = 0\n  for i in range(26):\n    if freq1[i] == freq2[i]:\n      matches += 1\n  \n  for l in range(len(s2) - window):\n    if matches == 26:\n      return True\n\n    added = ord(s2[l + window]) - ord('a')\n    freq2[added] += 1\n    if freq1[added] == freq2[added]:\n      matches += 1\n    elif freq1[added] + 1 == freq2[added]:\n      matches -= 1\n\n    removed = ord(s2[l]) - ord('a')\n    freq2[removed] -= 1\n    if freq1[removed] == freq2[removed]:\n      matches += 1\n    elif freq1[removed] == freq2[removed] + 1:\n      matches -= 1\n    \n  return matches == 26\n", "asserts": ["assert permutation_in_string(\"hello\", \"ooollehhhhh\") == True", "assert permutation_in_string(\"abc\", \"ccccbbbbaaaa\") == False", "assert permutation_in_string(\"xyz\", \"zxyopqrstuv\") == True", "assert permutation_in_string(\"xyz\", \"xzygxzyzxyzk\") == True", "assert permutation_in_string(\"a\", \"a\") == True", "assert permutation_in_string(\"adc\", \"dcda\") == True", "assert permutation_in_string(\"pq\", \"qpqqp\") == True", "assert permutation_in_string(\"kitten\", \"sittingkite\") == False", "assert permutation_in_string(\"pq\", \"pqpqr\") == True", "assert permutation_in_string(\"aba\", \"aabaabaa\") == True", "assert permutation_in_string(\"\", \"\") == True  # Edge case: both strings are empty", "assert permutation_in_string(\"longerstring\", \"short\") == False  # s1 is longer than s2", "assert permutation_in_string(\"a\", \"b\") == False  # Single character, no match", "assert permutation_in_string(\"aab\", \"baa\") == True  # s1 is a permutation of s2", "assert permutation_in_string(\"ab\", \"a\") == False  # s2 is shorter than s1", "assert permutation_in_string(\"ba\", \"eidbaooo\") == True  # Same characters as Example 1 but different permutation", "assert permutation_in_string(\"eid\", \"eidbaooo\") == True  # s1 is a prefix of s2", "assert permutation_in_string(\"ooo\", \"eidbaooo\") == True  # s1 is a suffix of s2", "assert permutation_in_string(\"db\", \"eidbaooo\") == True  # s1 is a permutation within s2", "assert permutation_in_string(\"eidoo\", \"eidbaooo\") == False  # s1 is longer than any permutation within s2"]}, {"author": "Calvin", "UUID": "ac641352-08d5-4950-8993-6a143da92ecf", "question": "You are given a string s and an integer k. You can choose one of the first k letters of s and append it at the end of the string.\n\nReturn the lexicographically smallest string you could have after applying the mentioned step any number of moves.\n", "examples": "Input: s = \"cba\", k = 1\nOutput: \"acb\"\n\nInput: s = \"baaca\", k = 3\nOutput: \"aaabc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef orderlyQueue(s: str, k: int) -> str:\n    if k == 1:\n        n = len(s)\n        ss = s + s\n        lex_min_str = s\n        for i in range(n):\n            lex_min_str = min(lex_min_str, ss[i:i + n])\n        return lex_min_str\n    \n    return \"\".join(sorted(s))\n", "asserts": ["assert orderlyQueue(\"abcd\", 1) == \"abcd\"", "assert orderlyQueue(\"hello\", 2) == \"ehllo\"", "assert orderlyQueue(\"programming\", 1) == \"ammingprogr\"", "assert orderlyQueue(\"rotator\", 1) == \"atorrot\"", "assert orderlyQueue(\"zxyabc\", 5) == \"abcxyz\"", "assert orderlyQueue(\"xy\", 2) == \"xy\""]}], "category": "String", "prompt_tokens": 1159, "total_tokens": 1473, "completion_tokens": 314, "completion": "Write a function that takes in a non-empty string and that returns a boolean representing whether the string is a palindrome. A palindrome is defined as a string that's written the same forward and backward. Note that single-character strings are palindromes.\n\n###Code:\n\ndef is_palindrome(s: str) -> bool:\n    left = 0\n    right = len(s) - 1\n\n    while left < right:\n        if s[left] != s[right]:\n            return False\n        left += 1\n        right -= 1\n\n    return True\n\n###Testcases:\n\nassert is_palindrome(\"racecar\") == True\nassert is_palindrome(\"level\") == True\nassert is_palindrome(\"noon\") == True\nassert is_palindrome(\"python\") == False\nassert is_palindrome(\"a\") == True\nassert is_palindrome(\"rotor\") == True\nassert is_palindrome(\"neveroddoreven\") == True\nassert is_palindrome(\"deified\") == True\nassert is_palindrome(\"civic\") == True\nassert is_palindrome(\"radar\") == True\nassert is_palindrome(\"refer\") == True\nassert is_palindrome(\"palindrome\") == False\nassert is_palindrome(\"No lemon, no melon\") == False\nassert is_palindrome(\"Was it a car or a cat I saw?\") == False  # Punctuation and spaces are considered\nassert is_palindrome(\"\") == True  # Edge case: empty string is considered a palindrome\n\n[/Example 3]", "temperature": 0.857}, {"few_shots": [{"author": "Calvin", "UUID": "d0ce7430-cfcd-4c69-b161-b3b2a186422c", "question": "Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.\n\nIn other words, return true if one of s1's permutations is the substring of s2.", "examples": "Input: s1 = \"ab\", s2 = \"eidbaooo\"\nOutput: True\n\nInput: s1 = \"ab\", s2 = \"eidboaoo\"\nOutput: False", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef permutation_in_string(s1: str, s2: str) -> bool:\n  window = len(s1)\n  if window > len(s2):\n    return False\n  freq1 = [0]*26\n  freq2 = [0]*26\n  for i in range(window):\n    freq1[ord(s1[i])-ord('a')] += 1\n    freq2[ord(s2[i])-ord('a')] += 1\n\n  matches = 0\n  for i in range(26):\n    if freq1[i] == freq2[i]:\n      matches += 1\n  \n  for l in range(len(s2) - window):\n    if matches == 26:\n      return True\n\n    added = ord(s2[l + window]) - ord('a')\n    freq2[added] += 1\n    if freq1[added] == freq2[added]:\n      matches += 1\n    elif freq1[added] + 1 == freq2[added]:\n      matches -= 1\n\n    removed = ord(s2[l]) - ord('a')\n    freq2[removed] -= 1\n    if freq1[removed] == freq2[removed]:\n      matches += 1\n    elif freq1[removed] == freq2[removed] + 1:\n      matches -= 1\n    \n  return matches == 26\n", "asserts": ["assert permutation_in_string(\"hello\", \"ooollehhhhh\") == True", "assert permutation_in_string(\"abc\", \"ccccbbbbaaaa\") == False", "assert permutation_in_string(\"xyz\", \"zxyopqrstuv\") == True", "assert permutation_in_string(\"xyz\", \"xzygxzyzxyzk\") == True", "assert permutation_in_string(\"a\", \"a\") == True", "assert permutation_in_string(\"adc\", \"dcda\") == True", "assert permutation_in_string(\"pq\", \"qpqqp\") == True", "assert permutation_in_string(\"kitten\", \"sittingkite\") == False", "assert permutation_in_string(\"pq\", \"pqpqr\") == True", "assert permutation_in_string(\"aba\", \"aabaabaa\") == True", "assert permutation_in_string(\"\", \"\") == True  # Edge case: both strings are empty", "assert permutation_in_string(\"longerstring\", \"short\") == False  # s1 is longer than s2", "assert permutation_in_string(\"a\", \"b\") == False  # Single character, no match", "assert permutation_in_string(\"aab\", \"baa\") == True  # s1 is a permutation of s2", "assert permutation_in_string(\"ab\", \"a\") == False  # s2 is shorter than s1", "assert permutation_in_string(\"ba\", \"eidbaooo\") == True  # Same characters as Example 1 but different permutation", "assert permutation_in_string(\"eid\", \"eidbaooo\") == True  # s1 is a prefix of s2", "assert permutation_in_string(\"ooo\", \"eidbaooo\") == True  # s1 is a suffix of s2", "assert permutation_in_string(\"db\", \"eidbaooo\") == True  # s1 is a permutation within s2", "assert permutation_in_string(\"eidoo\", \"eidbaooo\") == False  # s1 is longer than any permutation within s2"]}, {"author": "Calvin", "UUID": "ac641352-08d5-4950-8993-6a143da92ecf", "question": "You are given a string s and an integer k. You can choose one of the first k letters of s and append it at the end of the string.\n\nReturn the lexicographically smallest string you could have after applying the mentioned step any number of moves.\n", "examples": "Input: s = \"cba\", k = 1\nOutput: \"acb\"\n\nInput: s = \"baaca\", k = 3\nOutput: \"aaabc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef orderlyQueue(s: str, k: int) -> str:\n    if k == 1:\n        n = len(s)\n        ss = s + s\n        lex_min_str = s\n        for i in range(n):\n            lex_min_str = min(lex_min_str, ss[i:i + n])\n        return lex_min_str\n    \n    return \"\".join(sorted(s))\n", "asserts": ["assert orderlyQueue(\"abcd\", 1) == \"abcd\"", "assert orderlyQueue(\"hello\", 2) == \"ehllo\"", "assert orderlyQueue(\"programming\", 1) == \"ammingprogr\"", "assert orderlyQueue(\"rotator\", 1) == \"atorrot\"", "assert orderlyQueue(\"zxyabc\", 5) == \"abcxyz\"", "assert orderlyQueue(\"xy\", 2) == \"xy\""]}], "category": "String", "prompt_tokens": 1159, "total_tokens": 1482, "completion_tokens": 323, "completion": "Write a function to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string \"\".\n\n###Code: \n\n```python\ndef longest_common_prefix(strs: List[str]) -> str:\n    if not strs:\n        return \"\"\n\n    shortest = min(strs, key=len)\n    \n    for i, char in enumerate(shortest):\n        for other in strs:\n            if other[i] != char:\n                return shortest[:i]\n                \n    return shortest\n\n\n###Testcases: \n\nassert longest_common_prefix([\"flower\",\"flow\",\"flight\"]) == \"fl\"\nassert longest_common_prefix([\"dog\",\"racecar\",\"car\"]) == \"\"\nassert longest_common_prefix([\"interspecies\",\"interstellar\",\"interstate\"]) == \"inters\"\nassert longest_common_prefix([\"throne\",\"throne\"]) == \"throne\"\nassert longest_common_prefix([\"throne\",\"dungeon\"]) == \"\"\nassert longest_common_prefix([\"\",\"\"]) == \"\"\nassert longest_common_prefix([\"a\"]) == \"a\"\nassert longest_common_prefix([\"cir\",\"car\"]) == \"c\"\nassert longest_common_prefix([\"abab\",\"aba\",\"\"]) == \"\"\nassert longest_common_prefix([\"reflower\",\"flow\",\"flight\"]) == \"\"\nassert longest_common_prefix([]) == \"\"  # Edge case: empty list\nassert longest_common_prefix([\"a\",\"a\",\"b\"]) == \"\"\nassert longest_common_prefix([\"c\",\"c\"]) == \"c\"\nassert longest_common_prefix([\"aaa\",\"aa\",\"aaa\"]) == \"aa\"\nassert longest_common_prefix([\"aaaa\",\"aaa\",\"aa\"]) == \"aa\"\n```\n\n[/Example 3]", "temperature": 0.721}, {"few_shots": [{"author": "Calvin", "UUID": "d0ce7430-cfcd-4c69-b161-b3b2a186422c", "question": "Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.\n\nIn other words, return true if one of s1's permutations is the substring of s2.", "examples": "Input: s1 = \"ab\", s2 = \"eidbaooo\"\nOutput: True\n\nInput: s1 = \"ab\", s2 = \"eidboaoo\"\nOutput: False", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef permutation_in_string(s1: str, s2: str) -> bool:\n  window = len(s1)\n  if window > len(s2):\n    return False\n  freq1 = [0]*26\n  freq2 = [0]*26\n  for i in range(window):\n    freq1[ord(s1[i])-ord('a')] += 1\n    freq2[ord(s2[i])-ord('a')] += 1\n\n  matches = 0\n  for i in range(26):\n    if freq1[i] == freq2[i]:\n      matches += 1\n  \n  for l in range(len(s2) - window):\n    if matches == 26:\n      return True\n\n    added = ord(s2[l + window]) - ord('a')\n    freq2[added] += 1\n    if freq1[added] == freq2[added]:\n      matches += 1\n    elif freq1[added] + 1 == freq2[added]:\n      matches -= 1\n\n    removed = ord(s2[l]) - ord('a')\n    freq2[removed] -= 1\n    if freq1[removed] == freq2[removed]:\n      matches += 1\n    elif freq1[removed] == freq2[removed] + 1:\n      matches -= 1\n    \n  return matches == 26\n", "asserts": ["assert permutation_in_string(\"hello\", \"ooollehhhhh\") == True", "assert permutation_in_string(\"abc\", \"ccccbbbbaaaa\") == False", "assert permutation_in_string(\"xyz\", \"zxyopqrstuv\") == True", "assert permutation_in_string(\"xyz\", \"xzygxzyzxyzk\") == True", "assert permutation_in_string(\"a\", \"a\") == True", "assert permutation_in_string(\"adc\", \"dcda\") == True", "assert permutation_in_string(\"pq\", \"qpqqp\") == True", "assert permutation_in_string(\"kitten\", \"sittingkite\") == False", "assert permutation_in_string(\"pq\", \"pqpqr\") == True", "assert permutation_in_string(\"aba\", \"aabaabaa\") == True", "assert permutation_in_string(\"\", \"\") == True  # Edge case: both strings are empty", "assert permutation_in_string(\"longerstring\", \"short\") == False  # s1 is longer than s2", "assert permutation_in_string(\"a\", \"b\") == False  # Single character, no match", "assert permutation_in_string(\"aab\", \"baa\") == True  # s1 is a permutation of s2", "assert permutation_in_string(\"ab\", \"a\") == False  # s2 is shorter than s1", "assert permutation_in_string(\"ba\", \"eidbaooo\") == True  # Same characters as Example 1 but different permutation", "assert permutation_in_string(\"eid\", \"eidbaooo\") == True  # s1 is a prefix of s2", "assert permutation_in_string(\"ooo\", \"eidbaooo\") == True  # s1 is a suffix of s2", "assert permutation_in_string(\"db\", \"eidbaooo\") == True  # s1 is a permutation within s2", "assert permutation_in_string(\"eidoo\", \"eidbaooo\") == False  # s1 is longer than any permutation within s2"]}, {"author": "Calvin", "UUID": "80e34b28-16a8-46ac-8b6a-ee28beb1e8d4", "question": "Write a function that reverses a string. The input string is given as an array of characters s.\n\nYou must do this by modifying the input array in-place with O(1) extra memory.", "examples": "Input: [\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput: [\"o\",\"l\",\"l\",\"e\",\"h\"]\n\nInput: [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\nOutput: [\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def reverse_string(s: list) -> list:\n  l = 0\n  r = len(s) - 1\n  while l < r:\n    tmp = s[l]\n    s[l] = s[r]\n    s[r] = tmp\n    l += 1\n    r -= 1\n  return s\n", "asserts": ["assert reverse_string([\"a\",\"b\",\"c\",\"d\"]) == [\"d\", \"c\", \"b\", \"a\"]", "assert reverse_string([\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"]) == [\"n\", \"o\", \"h\", \"t\", \"y\", \"p\"]", "assert reverse_string([]) == []", "assert reverse_string([\"s\", \"i\", \"n\", \"g\", \"l\", \"e\"]) == [\"e\", \"l\", \"g\", \"n\", \"i\", \"s\"]", "assert reverse_string([\"A\"]) == [\"A\"]", "assert reverse_string([\"9\", \"8\", \"7\", \"6\", \"5\", \"4\", \"3\", \"2\", \"1\"]) == [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]", "assert reverse_string([\"B\", \"o\", \"b\"]) == [\"b\", \"o\", \"B\"]", "assert reverse_string([\"r\", \"e\", \"v\", \"e\", \"r\", \"s\", \"e\"]) == [\"e\", \"s\", \"r\", \"e\", \"v\", \"e\", \"r\"]", "assert reverse_string([\"1\", \"*\", \"2\", \"*\", \"3\"]) == [\"3\", \"*\", \"2\", \"*\", \"1\"]"]}], "category": "String", "prompt_tokens": 1324, "total_tokens": 1793, "completion_tokens": 469, "completion": "Given a non-empty string s and an integer k, rearrange the string such that the same characters are at least distance k from each other.\n\nAll input strings are given in lowercase letters. If it is not possible to rearrange the string, return an empty string \"\".\n\n###Code: \n\nfrom collections import Counter\nimport heapq\n\ndef rearrange_string(s: str, k: int) -> str:\n    if k == 0:\n        return s\n\n    result = []\n    counter = Counter(s)\n    max_heap = [(-val, key) for key, val in counter.items()]\n    heapq.heapify(max_heap)\n    queue = []\n\n    while max_heap:\n        count, char = heapq.heappop(max_heap)\n        result.append(char)\n        \n        queue.append((count + 1, char))\n        if len(queue) < k:\n            continue\n\n        count, char = queue.pop(0)\n        if -count > 0:\n            heapq.heappush(max_heap, (count, char))\n\n    result = ''.join(result)\n    return result if len(result) == len(s) else \"\"\n\n###Testcases: \n\nassert rearrange_string(\"aabbcc\", 3) == \"abcabc\" or rearrange_string(\"aabbcc\", 3) == \"acbacb\"\nassert rearrange_string(\"aaabc\", 3) == \"\"\nassert rearrange_string(\"aaadbbcc\", 2) == \"abacabcd\" or rearrange_string(\"aaadbbcc\", 2) == \"abcabcad\"\nassert rearrange_string(\"a\", 2) == \"a\"\nassert rearrange_string(\"aa\", 0) == \"aa\"\nassert rearrange_string(\"aabb\", 0) == \"aabb\" or rearrange_string(\"aabb\", 0) == \"bbaa\"\nassert rearrange_string(\"aa\", 1) == \"aa\"\nassert rearrange_string(\"aaaaa\", 2) == \"\"\nassert rearrange_string(\"programming\", 3) != \"\"  # Can be any valid rearrangement\nassert rearrange_string(\"vvvlo\", 2) == \"vovlv\" or rearrange_string(\"vvvlo\", 2) == \"vlvov\"\n\n[/Example 3]", "temperature": 0.71}, {"few_shots": [{"author": "Calvin", "UUID": "d0ce7430-cfcd-4c69-b161-b3b2a186422c", "question": "Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.\n\nIn other words, return true if one of s1's permutations is the substring of s2.", "examples": "Input: s1 = \"ab\", s2 = \"eidbaooo\"\nOutput: True\n\nInput: s1 = \"ab\", s2 = \"eidboaoo\"\nOutput: False", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef permutation_in_string(s1: str, s2: str) -> bool:\n  window = len(s1)\n  if window > len(s2):\n    return False\n  freq1 = [0]*26\n  freq2 = [0]*26\n  for i in range(window):\n    freq1[ord(s1[i])-ord('a')] += 1\n    freq2[ord(s2[i])-ord('a')] += 1\n\n  matches = 0\n  for i in range(26):\n    if freq1[i] == freq2[i]:\n      matches += 1\n  \n  for l in range(len(s2) - window):\n    if matches == 26:\n      return True\n\n    added = ord(s2[l + window]) - ord('a')\n    freq2[added] += 1\n    if freq1[added] == freq2[added]:\n      matches += 1\n    elif freq1[added] + 1 == freq2[added]:\n      matches -= 1\n\n    removed = ord(s2[l]) - ord('a')\n    freq2[removed] -= 1\n    if freq1[removed] == freq2[removed]:\n      matches += 1\n    elif freq1[removed] == freq2[removed] + 1:\n      matches -= 1\n    \n  return matches == 26\n", "asserts": ["assert permutation_in_string(\"hello\", \"ooollehhhhh\") == True", "assert permutation_in_string(\"abc\", \"ccccbbbbaaaa\") == False", "assert permutation_in_string(\"xyz\", \"zxyopqrstuv\") == True", "assert permutation_in_string(\"xyz\", \"xzygxzyzxyzk\") == True", "assert permutation_in_string(\"a\", \"a\") == True", "assert permutation_in_string(\"adc\", \"dcda\") == True", "assert permutation_in_string(\"pq\", \"qpqqp\") == True", "assert permutation_in_string(\"kitten\", \"sittingkite\") == False", "assert permutation_in_string(\"pq\", \"pqpqr\") == True", "assert permutation_in_string(\"aba\", \"aabaabaa\") == True", "assert permutation_in_string(\"\", \"\") == True  # Edge case: both strings are empty", "assert permutation_in_string(\"longerstring\", \"short\") == False  # s1 is longer than s2", "assert permutation_in_string(\"a\", \"b\") == False  # Single character, no match", "assert permutation_in_string(\"aab\", \"baa\") == True  # s1 is a permutation of s2", "assert permutation_in_string(\"ab\", \"a\") == False  # s2 is shorter than s1", "assert permutation_in_string(\"ba\", \"eidbaooo\") == True  # Same characters as Example 1 but different permutation", "assert permutation_in_string(\"eid\", \"eidbaooo\") == True  # s1 is a prefix of s2", "assert permutation_in_string(\"ooo\", \"eidbaooo\") == True  # s1 is a suffix of s2", "assert permutation_in_string(\"db\", \"eidbaooo\") == True  # s1 is a permutation within s2", "assert permutation_in_string(\"eidoo\", \"eidbaooo\") == False  # s1 is longer than any permutation within s2"]}, {"author": "Calvin", "UUID": "80e34b28-16a8-46ac-8b6a-ee28beb1e8d4", "question": "Write a function that reverses a string. The input string is given as an array of characters s.\n\nYou must do this by modifying the input array in-place with O(1) extra memory.", "examples": "Input: [\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput: [\"o\",\"l\",\"l\",\"e\",\"h\"]\n\nInput: [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\nOutput: [\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def reverse_string(s: list) -> list:\n  l = 0\n  r = len(s) - 1\n  while l < r:\n    tmp = s[l]\n    s[l] = s[r]\n    s[r] = tmp\n    l += 1\n    r -= 1\n  return s\n", "asserts": ["assert reverse_string([\"a\",\"b\",\"c\",\"d\"]) == [\"d\", \"c\", \"b\", \"a\"]", "assert reverse_string([\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"]) == [\"n\", \"o\", \"h\", \"t\", \"y\", \"p\"]", "assert reverse_string([]) == []", "assert reverse_string([\"s\", \"i\", \"n\", \"g\", \"l\", \"e\"]) == [\"e\", \"l\", \"g\", \"n\", \"i\", \"s\"]", "assert reverse_string([\"A\"]) == [\"A\"]", "assert reverse_string([\"9\", \"8\", \"7\", \"6\", \"5\", \"4\", \"3\", \"2\", \"1\"]) == [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]", "assert reverse_string([\"B\", \"o\", \"b\"]) == [\"b\", \"o\", \"B\"]", "assert reverse_string([\"r\", \"e\", \"v\", \"e\", \"r\", \"s\", \"e\"]) == [\"e\", \"s\", \"r\", \"e\", \"v\", \"e\", \"r\"]", "assert reverse_string([\"1\", \"*\", \"2\", \"*\", \"3\"]) == [\"3\", \"*\", \"2\", \"*\", \"1\"]"]}], "category": "String", "prompt_tokens": 1324, "total_tokens": 1856, "completion_tokens": 532, "completion": "Given a non-empty string s and an integer k, rearrange the string such that the same characters are at least distance k from each other.\n\nAll input strings are given in lowercase letters. If it is not possible to rearrange the string, return an empty string \"\".\n\n###Code: \n\nfrom collections import Counter\nimport heapq\n\ndef rearrange_string(s: str, k: int) -> str:\n  if k == 0:\n    return s\n  frequency = Counter(s)\n  max_heap = [(-cnt, char) for char, cnt in frequency.items()]\n  heapq.heapify(max_heap)\n  queue = []\n  result = []\n\n  while max_heap:\n    cnt, char = heapq.heappop(max_heap)\n    result.append(char)\n    queue.append((cnt + 1, char))\n\n    if len(queue) < k:\n      continue\n\n    cnt, char = queue.pop(0)\n    if -cnt > 0:\n      heapq.heappush(max_heap, (cnt, char))\n\n  return ''.join(result) if len(result) == len(s) else \"\"\n\n\n###Testcases: \n\nassert rearrange_string(\"aabbcc\", 3) == \"abcabc\" or rearrange_string(\"aabbcc\", 3) == \"acbacb\"\nassert rearrange_string(\"aaabc\", 3) == \"\"\nassert rearrange_string(\"aaadbbcc\", 2) == \"abacabcd\" or rearrange_string(\"aaadbbcc\", 2) == \"ababacdc\"\nassert rearrange_string(\"aaaaa\", 2) == \"\"\nassert rearrange_string(\"a\", 2) == \"a\"\nassert rearrange_string(\"aa\", 0) == \"aa\"\nassert rearrange_string(\"aabb\", 0) == \"aabb\"\nassert rearrange_string(\"aabb\", 2) == \"abab\" or rearrange_string(\"aabb\", 2) == \"baba\"\nassert rearrange_string(\"aa\", 2) == \"\"\nassert rearrange_string(\"aaabc\", 2) == \"abaca\"\nassert rearrange_string(\"programming\", 3) != \"\"  # Actual output depends on how many characters can be placed to satisfy the condition\nassert rearrange_string(\"vvvlo\", 2) == \"vovlv\" or rearrange_string(\"vvvlo\", 2) == \"vlvov\"\nassert rearrange_string(\"example\", 4) != \"\"  # Actual output depends on how many characters can be placed to satisfy the condition\n\n[/Example 3]", "temperature": 0.755}, {"few_shots": [{"author": "Calvin", "UUID": "d0ce7430-cfcd-4c69-b161-b3b2a186422c", "question": "Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.\n\nIn other words, return true if one of s1's permutations is the substring of s2.", "examples": "Input: s1 = \"ab\", s2 = \"eidbaooo\"\nOutput: True\n\nInput: s1 = \"ab\", s2 = \"eidboaoo\"\nOutput: False", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef permutation_in_string(s1: str, s2: str) -> bool:\n  window = len(s1)\n  if window > len(s2):\n    return False\n  freq1 = [0]*26\n  freq2 = [0]*26\n  for i in range(window):\n    freq1[ord(s1[i])-ord('a')] += 1\n    freq2[ord(s2[i])-ord('a')] += 1\n\n  matches = 0\n  for i in range(26):\n    if freq1[i] == freq2[i]:\n      matches += 1\n  \n  for l in range(len(s2) - window):\n    if matches == 26:\n      return True\n\n    added = ord(s2[l + window]) - ord('a')\n    freq2[added] += 1\n    if freq1[added] == freq2[added]:\n      matches += 1\n    elif freq1[added] + 1 == freq2[added]:\n      matches -= 1\n\n    removed = ord(s2[l]) - ord('a')\n    freq2[removed] -= 1\n    if freq1[removed] == freq2[removed]:\n      matches += 1\n    elif freq1[removed] == freq2[removed] + 1:\n      matches -= 1\n    \n  return matches == 26\n", "asserts": ["assert permutation_in_string(\"hello\", \"ooollehhhhh\") == True", "assert permutation_in_string(\"abc\", \"ccccbbbbaaaa\") == False", "assert permutation_in_string(\"xyz\", \"zxyopqrstuv\") == True", "assert permutation_in_string(\"xyz\", \"xzygxzyzxyzk\") == True", "assert permutation_in_string(\"a\", \"a\") == True", "assert permutation_in_string(\"adc\", \"dcda\") == True", "assert permutation_in_string(\"pq\", \"qpqqp\") == True", "assert permutation_in_string(\"kitten\", \"sittingkite\") == False", "assert permutation_in_string(\"pq\", \"pqpqr\") == True", "assert permutation_in_string(\"aba\", \"aabaabaa\") == True", "assert permutation_in_string(\"\", \"\") == True  # Edge case: both strings are empty", "assert permutation_in_string(\"longerstring\", \"short\") == False  # s1 is longer than s2", "assert permutation_in_string(\"a\", \"b\") == False  # Single character, no match", "assert permutation_in_string(\"aab\", \"baa\") == True  # s1 is a permutation of s2", "assert permutation_in_string(\"ab\", \"a\") == False  # s2 is shorter than s1", "assert permutation_in_string(\"ba\", \"eidbaooo\") == True  # Same characters as Example 1 but different permutation", "assert permutation_in_string(\"eid\", \"eidbaooo\") == True  # s1 is a prefix of s2", "assert permutation_in_string(\"ooo\", \"eidbaooo\") == True  # s1 is a suffix of s2", "assert permutation_in_string(\"db\", \"eidbaooo\") == True  # s1 is a permutation within s2", "assert permutation_in_string(\"eidoo\", \"eidbaooo\") == False  # s1 is longer than any permutation within s2"]}, {"author": "Calvin", "UUID": "80e34b28-16a8-46ac-8b6a-ee28beb1e8d4", "question": "Write a function that reverses a string. The input string is given as an array of characters s.\n\nYou must do this by modifying the input array in-place with O(1) extra memory.", "examples": "Input: [\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput: [\"o\",\"l\",\"l\",\"e\",\"h\"]\n\nInput: [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\nOutput: [\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def reverse_string(s: list) -> list:\n  l = 0\n  r = len(s) - 1\n  while l < r:\n    tmp = s[l]\n    s[l] = s[r]\n    s[r] = tmp\n    l += 1\n    r -= 1\n  return s\n", "asserts": ["assert reverse_string([\"a\",\"b\",\"c\",\"d\"]) == [\"d\", \"c\", \"b\", \"a\"]", "assert reverse_string([\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"]) == [\"n\", \"o\", \"h\", \"t\", \"y\", \"p\"]", "assert reverse_string([]) == []", "assert reverse_string([\"s\", \"i\", \"n\", \"g\", \"l\", \"e\"]) == [\"e\", \"l\", \"g\", \"n\", \"i\", \"s\"]", "assert reverse_string([\"A\"]) == [\"A\"]", "assert reverse_string([\"9\", \"8\", \"7\", \"6\", \"5\", \"4\", \"3\", \"2\", \"1\"]) == [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]", "assert reverse_string([\"B\", \"o\", \"b\"]) == [\"b\", \"o\", \"B\"]", "assert reverse_string([\"r\", \"e\", \"v\", \"e\", \"r\", \"s\", \"e\"]) == [\"e\", \"s\", \"r\", \"e\", \"v\", \"e\", \"r\"]", "assert reverse_string([\"1\", \"*\", \"2\", \"*\", \"3\"]) == [\"3\", \"*\", \"2\", \"*\", \"1\"]"]}], "category": "String", "prompt_tokens": 1324, "total_tokens": 1726, "completion_tokens": 402, "completion": "Given a string phrase, return a new string that consists of the original string with all adjacent spaces replaced by a single space. If there are spaces at the beginning or end of the original string, they should be removed in the returned string.\n\n###Code: \n\ndef remove_redundant_spaces(phrase: str) -> str:\n  return ' '.join(phrase.split())\n\n###Testcases: \n\nassert remove_redundant_spaces(\"  This   is  an example  \") == \"This is an example\"\nassert remove_redundant_spaces(\"NoExtraSpace\") == \"NoExtraSpace\"\nassert remove_redundant_spaces(\"   Leading and trailing spaces    \") == \"Leading and trailing spaces\"\nassert remove_redundant_spaces(\"  Only    spaces   here    \") == \"Only spaces here\"\nassert remove_redundant_spaces(\"     \") == \"\"\nassert remove_redundant_spaces(\"a b  c   d    e\") == \"a b c d e\"\nassert remove_redundant_spaces(\"SingleWord\") == \"SingleWord\"\nassert remove_redundant_spaces(\" Multiple     Words \") == \"Multiple Words\"\nassert remove_redundant_spaces(\"\") == \"\"  # Edge case: empty string\nassert remove_redundant_spaces(\" A   B C    D E   \") == \"A B C D E\"\nassert remove_redundant_spaces(\"Spaces  at  the ends   \") == \"Spaces at the ends\"\nassert remove_redundant_spaces(\"  a\") == \"a\"  # Only a leading space\nassert remove_redundant_spaces(\"b  \") == \"b\"  # Only a trailing space\nassert remove_redundant_spaces(\"  c  \") == \"c\"  # Both leading and trailing spaces\nassert remove_redundant_spaces(\"   Many    spaces   in between words  \") == \"Many spaces in between words\"\n\n[/Example 3]", "temperature": 0.86}, {"few_shots": [{"author": "Calvin", "UUID": "d0ce7430-cfcd-4c69-b161-b3b2a186422c", "question": "Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.\n\nIn other words, return true if one of s1's permutations is the substring of s2.", "examples": "Input: s1 = \"ab\", s2 = \"eidbaooo\"\nOutput: True\n\nInput: s1 = \"ab\", s2 = \"eidboaoo\"\nOutput: False", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef permutation_in_string(s1: str, s2: str) -> bool:\n  window = len(s1)\n  if window > len(s2):\n    return False\n  freq1 = [0]*26\n  freq2 = [0]*26\n  for i in range(window):\n    freq1[ord(s1[i])-ord('a')] += 1\n    freq2[ord(s2[i])-ord('a')] += 1\n\n  matches = 0\n  for i in range(26):\n    if freq1[i] == freq2[i]:\n      matches += 1\n  \n  for l in range(len(s2) - window):\n    if matches == 26:\n      return True\n\n    added = ord(s2[l + window]) - ord('a')\n    freq2[added] += 1\n    if freq1[added] == freq2[added]:\n      matches += 1\n    elif freq1[added] + 1 == freq2[added]:\n      matches -= 1\n\n    removed = ord(s2[l]) - ord('a')\n    freq2[removed] -= 1\n    if freq1[removed] == freq2[removed]:\n      matches += 1\n    elif freq1[removed] == freq2[removed] + 1:\n      matches -= 1\n    \n  return matches == 26\n", "asserts": ["assert permutation_in_string(\"hello\", \"ooollehhhhh\") == True", "assert permutation_in_string(\"abc\", \"ccccbbbbaaaa\") == False", "assert permutation_in_string(\"xyz\", \"zxyopqrstuv\") == True", "assert permutation_in_string(\"xyz\", \"xzygxzyzxyzk\") == True", "assert permutation_in_string(\"a\", \"a\") == True", "assert permutation_in_string(\"adc\", \"dcda\") == True", "assert permutation_in_string(\"pq\", \"qpqqp\") == True", "assert permutation_in_string(\"kitten\", \"sittingkite\") == False", "assert permutation_in_string(\"pq\", \"pqpqr\") == True", "assert permutation_in_string(\"aba\", \"aabaabaa\") == True", "assert permutation_in_string(\"\", \"\") == True  # Edge case: both strings are empty", "assert permutation_in_string(\"longerstring\", \"short\") == False  # s1 is longer than s2", "assert permutation_in_string(\"a\", \"b\") == False  # Single character, no match", "assert permutation_in_string(\"aab\", \"baa\") == True  # s1 is a permutation of s2", "assert permutation_in_string(\"ab\", \"a\") == False  # s2 is shorter than s1", "assert permutation_in_string(\"ba\", \"eidbaooo\") == True  # Same characters as Example 1 but different permutation", "assert permutation_in_string(\"eid\", \"eidbaooo\") == True  # s1 is a prefix of s2", "assert permutation_in_string(\"ooo\", \"eidbaooo\") == True  # s1 is a suffix of s2", "assert permutation_in_string(\"db\", \"eidbaooo\") == True  # s1 is a permutation within s2", "assert permutation_in_string(\"eidoo\", \"eidbaooo\") == False  # s1 is longer than any permutation within s2"]}, {"author": "Calvin", "UUID": "80e34b28-16a8-46ac-8b6a-ee28beb1e8d4", "question": "Write a function that reverses a string. The input string is given as an array of characters s.\n\nYou must do this by modifying the input array in-place with O(1) extra memory.", "examples": "Input: [\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput: [\"o\",\"l\",\"l\",\"e\",\"h\"]\n\nInput: [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\nOutput: [\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def reverse_string(s: list) -> list:\n  l = 0\n  r = len(s) - 1\n  while l < r:\n    tmp = s[l]\n    s[l] = s[r]\n    s[r] = tmp\n    l += 1\n    r -= 1\n  return s\n", "asserts": ["assert reverse_string([\"a\",\"b\",\"c\",\"d\"]) == [\"d\", \"c\", \"b\", \"a\"]", "assert reverse_string([\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"]) == [\"n\", \"o\", \"h\", \"t\", \"y\", \"p\"]", "assert reverse_string([]) == []", "assert reverse_string([\"s\", \"i\", \"n\", \"g\", \"l\", \"e\"]) == [\"e\", \"l\", \"g\", \"n\", \"i\", \"s\"]", "assert reverse_string([\"A\"]) == [\"A\"]", "assert reverse_string([\"9\", \"8\", \"7\", \"6\", \"5\", \"4\", \"3\", \"2\", \"1\"]) == [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]", "assert reverse_string([\"B\", \"o\", \"b\"]) == [\"b\", \"o\", \"B\"]", "assert reverse_string([\"r\", \"e\", \"v\", \"e\", \"r\", \"s\", \"e\"]) == [\"e\", \"s\", \"r\", \"e\", \"v\", \"e\", \"r\"]", "assert reverse_string([\"1\", \"*\", \"2\", \"*\", \"3\"]) == [\"3\", \"*\", \"2\", \"*\", \"1\"]"]}], "category": "String", "prompt_tokens": 1324, "total_tokens": 1644, "completion_tokens": 320, "completion": "Write a function that takes a string and returns the first non-repeating character in it. If there is no non-repeating character, return an empty string.\n\n###Code:\n\ndef first_non_repeating_character(s: str) -> str:\n    frequency = {}\n    for char in s:\n        frequency[char] = frequency.get(char, 0) + 1\n    for char in s:\n        if frequency[char] == 1:\n            return char\n    return \"\"\n\n###Testcases:\n\nassert first_non_repeating_character(\"leetcode\") == \"l\"\nassert first_non_repeating_character(\"loveleetcode\") == \"v\"\nassert first_non_repeating_character(\"aabbcc\") == \"\"\nassert first_non_repeating_character(\"aabcc\") == \"b\"\nassert first_non_repeating_character(\"a\") == \"a\"\nassert first_non_repeating_character(\"xyzzyx\") == \"\"\nassert first_non_repeating_character(\"algorithms\") == \"l\"\nassert first_non_repeating_character(\"abcabcdd\") == \"d\"\nassert first_non_repeating_character(\"aabbccddee\") == \"\"\nassert first_non_repeating_character(\"z\") == \"z\"\nassert first_non_repeating_character(\"zzzcccbbbttt\") == \"\"\nassert first_non_repeating_character(\"alphabet\") == \"a\"\nassert first_non_repeating_character(\"racecars\") == \"e\"\nassert first_non_repeating_character(\"abracadabra\") == \"c\"\nassert first_non_repeating_character(\"sTreSS\") == \"T\"  # Case-sensitive\n\n[/Example 3]", "temperature": 0.832}, {"few_shots": [{"author": "Calvin", "UUID": "d0ce7430-cfcd-4c69-b161-b3b2a186422c", "question": "Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.\n\nIn other words, return true if one of s1's permutations is the substring of s2.", "examples": "Input: s1 = \"ab\", s2 = \"eidbaooo\"\nOutput: True\n\nInput: s1 = \"ab\", s2 = \"eidboaoo\"\nOutput: False", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef permutation_in_string(s1: str, s2: str) -> bool:\n  window = len(s1)\n  if window > len(s2):\n    return False\n  freq1 = [0]*26\n  freq2 = [0]*26\n  for i in range(window):\n    freq1[ord(s1[i])-ord('a')] += 1\n    freq2[ord(s2[i])-ord('a')] += 1\n\n  matches = 0\n  for i in range(26):\n    if freq1[i] == freq2[i]:\n      matches += 1\n  \n  for l in range(len(s2) - window):\n    if matches == 26:\n      return True\n\n    added = ord(s2[l + window]) - ord('a')\n    freq2[added] += 1\n    if freq1[added] == freq2[added]:\n      matches += 1\n    elif freq1[added] + 1 == freq2[added]:\n      matches -= 1\n\n    removed = ord(s2[l]) - ord('a')\n    freq2[removed] -= 1\n    if freq1[removed] == freq2[removed]:\n      matches += 1\n    elif freq1[removed] == freq2[removed] + 1:\n      matches -= 1\n    \n  return matches == 26\n", "asserts": ["assert permutation_in_string(\"hello\", \"ooollehhhhh\") == True", "assert permutation_in_string(\"abc\", \"ccccbbbbaaaa\") == False", "assert permutation_in_string(\"xyz\", \"zxyopqrstuv\") == True", "assert permutation_in_string(\"xyz\", \"xzygxzyzxyzk\") == True", "assert permutation_in_string(\"a\", \"a\") == True", "assert permutation_in_string(\"adc\", \"dcda\") == True", "assert permutation_in_string(\"pq\", \"qpqqp\") == True", "assert permutation_in_string(\"kitten\", \"sittingkite\") == False", "assert permutation_in_string(\"pq\", \"pqpqr\") == True", "assert permutation_in_string(\"aba\", \"aabaabaa\") == True", "assert permutation_in_string(\"\", \"\") == True  # Edge case: both strings are empty", "assert permutation_in_string(\"longerstring\", \"short\") == False  # s1 is longer than s2", "assert permutation_in_string(\"a\", \"b\") == False  # Single character, no match", "assert permutation_in_string(\"aab\", \"baa\") == True  # s1 is a permutation of s2", "assert permutation_in_string(\"ab\", \"a\") == False  # s2 is shorter than s1", "assert permutation_in_string(\"ba\", \"eidbaooo\") == True  # Same characters as Example 1 but different permutation", "assert permutation_in_string(\"eid\", \"eidbaooo\") == True  # s1 is a prefix of s2", "assert permutation_in_string(\"ooo\", \"eidbaooo\") == True  # s1 is a suffix of s2", "assert permutation_in_string(\"db\", \"eidbaooo\") == True  # s1 is a permutation within s2", "assert permutation_in_string(\"eidoo\", \"eidbaooo\") == False  # s1 is longer than any permutation within s2"]}, {"author": "Calvin", "UUID": "80e34b28-16a8-46ac-8b6a-ee28beb1e8d4", "question": "Write a function that reverses a string. The input string is given as an array of characters s.\n\nYou must do this by modifying the input array in-place with O(1) extra memory.", "examples": "Input: [\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput: [\"o\",\"l\",\"l\",\"e\",\"h\"]\n\nInput: [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\nOutput: [\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def reverse_string(s: list) -> list:\n  l = 0\n  r = len(s) - 1\n  while l < r:\n    tmp = s[l]\n    s[l] = s[r]\n    s[r] = tmp\n    l += 1\n    r -= 1\n  return s\n", "asserts": ["assert reverse_string([\"a\",\"b\",\"c\",\"d\"]) == [\"d\", \"c\", \"b\", \"a\"]", "assert reverse_string([\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"]) == [\"n\", \"o\", \"h\", \"t\", \"y\", \"p\"]", "assert reverse_string([]) == []", "assert reverse_string([\"s\", \"i\", \"n\", \"g\", \"l\", \"e\"]) == [\"e\", \"l\", \"g\", \"n\", \"i\", \"s\"]", "assert reverse_string([\"A\"]) == [\"A\"]", "assert reverse_string([\"9\", \"8\", \"7\", \"6\", \"5\", \"4\", \"3\", \"2\", \"1\"]) == [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]", "assert reverse_string([\"B\", \"o\", \"b\"]) == [\"b\", \"o\", \"B\"]", "assert reverse_string([\"r\", \"e\", \"v\", \"e\", \"r\", \"s\", \"e\"]) == [\"e\", \"s\", \"r\", \"e\", \"v\", \"e\", \"r\"]", "assert reverse_string([\"1\", \"*\", \"2\", \"*\", \"3\"]) == [\"3\", \"*\", \"2\", \"*\", \"1\"]"]}], "category": "String", "prompt_tokens": 1324, "total_tokens": 1763, "completion_tokens": 439, "completion": "Implement a function `compress_string` which takes in a string `s` and returns its run-length encoding. For the string \"aabccc\" the run length encoding should return \"a2b1c3\".\n\n###Code:\n\n```python\ndef compress_string(s: str) -> str:\n    if not s:\n        return \"\"\n    \n    compressed = []\n    count = 1\n    for i in range(1, len(s)):\n        if s[i] == s[i - 1]:\n            count += 1\n        else:\n            compressed.append(s[i - 1] + str(count))\n            count = 1\n    compressed.append(s[-1] + str(count))  # Append last run\n    return \"\".join(compressed)\n\n###Testcases:\n\nassert compress_string(\"aabccc\") == \"a2b1c3\"\nassert compress_string(\"a\") == \"a1\"\nassert compress_string(\"bb\") == \"b2\"\nassert compress_string(\"abc\") == \"a1b1c1\"\nassert compress_string(\"aaabbaacccc\") == \"a3b2a1c4\"\nassert compress_string(\"\") == \"\"\nassert compress_string(\"xxxxxxxxxxyyyyyyyzzz\") == \"x10y7z3\"\nassert compress_string(\"aabcccccaaa\") == \"a2b1c5a3\"\nassert compress_string(\"wwwwaaadexxxxxx\") == \"w4a3d1e1x6\"\nassert compress_string(\"AAB\") == \"A2B1\"\nassert compress_string(\"122333\") == \"12s333\"\nassert compress_string(\"aabcc\") == \"a2b1c2\"\nassert compress_string(\"aabbcc\") == \"a2b2c2\"\nassert compress_string(\"aaabbccccc\") == \"a3b2c5\"\nassert compress_string(\"a\") == \"a1\"\nassert compress_string(\" \") == \" 1\"\nassert compress_string(\"!!!!!\") == \"!5\"\nassert compress_string(\"aAa\") == \"a1A1a1\"  # Case sensitive\n\n[/Example 3]", "temperature": 0.839}, {"few_shots": [{"author": "Calvin", "UUID": "d0ce7430-cfcd-4c69-b161-b3b2a186422c", "question": "Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.\n\nIn other words, return true if one of s1's permutations is the substring of s2.", "examples": "Input: s1 = \"ab\", s2 = \"eidbaooo\"\nOutput: True\n\nInput: s1 = \"ab\", s2 = \"eidboaoo\"\nOutput: False", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef permutation_in_string(s1: str, s2: str) -> bool:\n  window = len(s1)\n  if window > len(s2):\n    return False\n  freq1 = [0]*26\n  freq2 = [0]*26\n  for i in range(window):\n    freq1[ord(s1[i])-ord('a')] += 1\n    freq2[ord(s2[i])-ord('a')] += 1\n\n  matches = 0\n  for i in range(26):\n    if freq1[i] == freq2[i]:\n      matches += 1\n  \n  for l in range(len(s2) - window):\n    if matches == 26:\n      return True\n\n    added = ord(s2[l + window]) - ord('a')\n    freq2[added] += 1\n    if freq1[added] == freq2[added]:\n      matches += 1\n    elif freq1[added] + 1 == freq2[added]:\n      matches -= 1\n\n    removed = ord(s2[l]) - ord('a')\n    freq2[removed] -= 1\n    if freq1[removed] == freq2[removed]:\n      matches += 1\n    elif freq1[removed] == freq2[removed] + 1:\n      matches -= 1\n    \n  return matches == 26\n", "asserts": ["assert permutation_in_string(\"hello\", \"ooollehhhhh\") == True", "assert permutation_in_string(\"abc\", \"ccccbbbbaaaa\") == False", "assert permutation_in_string(\"xyz\", \"zxyopqrstuv\") == True", "assert permutation_in_string(\"xyz\", \"xzygxzyzxyzk\") == True", "assert permutation_in_string(\"a\", \"a\") == True", "assert permutation_in_string(\"adc\", \"dcda\") == True", "assert permutation_in_string(\"pq\", \"qpqqp\") == True", "assert permutation_in_string(\"kitten\", \"sittingkite\") == False", "assert permutation_in_string(\"pq\", \"pqpqr\") == True", "assert permutation_in_string(\"aba\", \"aabaabaa\") == True", "assert permutation_in_string(\"\", \"\") == True  # Edge case: both strings are empty", "assert permutation_in_string(\"longerstring\", \"short\") == False  # s1 is longer than s2", "assert permutation_in_string(\"a\", \"b\") == False  # Single character, no match", "assert permutation_in_string(\"aab\", \"baa\") == True  # s1 is a permutation of s2", "assert permutation_in_string(\"ab\", \"a\") == False  # s2 is shorter than s1", "assert permutation_in_string(\"ba\", \"eidbaooo\") == True  # Same characters as Example 1 but different permutation", "assert permutation_in_string(\"eid\", \"eidbaooo\") == True  # s1 is a prefix of s2", "assert permutation_in_string(\"ooo\", \"eidbaooo\") == True  # s1 is a suffix of s2", "assert permutation_in_string(\"db\", \"eidbaooo\") == True  # s1 is a permutation within s2", "assert permutation_in_string(\"eidoo\", \"eidbaooo\") == False  # s1 is longer than any permutation within s2"]}, {"author": "Calvin", "UUID": "80e34b28-16a8-46ac-8b6a-ee28beb1e8d4", "question": "Write a function that reverses a string. The input string is given as an array of characters s.\n\nYou must do this by modifying the input array in-place with O(1) extra memory.", "examples": "Input: [\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput: [\"o\",\"l\",\"l\",\"e\",\"h\"]\n\nInput: [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\nOutput: [\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def reverse_string(s: list) -> list:\n  l = 0\n  r = len(s) - 1\n  while l < r:\n    tmp = s[l]\n    s[l] = s[r]\n    s[r] = tmp\n    l += 1\n    r -= 1\n  return s\n", "asserts": ["assert reverse_string([\"a\",\"b\",\"c\",\"d\"]) == [\"d\", \"c\", \"b\", \"a\"]", "assert reverse_string([\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"]) == [\"n\", \"o\", \"h\", \"t\", \"y\", \"p\"]", "assert reverse_string([]) == []", "assert reverse_string([\"s\", \"i\", \"n\", \"g\", \"l\", \"e\"]) == [\"e\", \"l\", \"g\", \"n\", \"i\", \"s\"]", "assert reverse_string([\"A\"]) == [\"A\"]", "assert reverse_string([\"9\", \"8\", \"7\", \"6\", \"5\", \"4\", \"3\", \"2\", \"1\"]) == [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]", "assert reverse_string([\"B\", \"o\", \"b\"]) == [\"b\", \"o\", \"B\"]", "assert reverse_string([\"r\", \"e\", \"v\", \"e\", \"r\", \"s\", \"e\"]) == [\"e\", \"s\", \"r\", \"e\", \"v\", \"e\", \"r\"]", "assert reverse_string([\"1\", \"*\", \"2\", \"*\", \"3\"]) == [\"3\", \"*\", \"2\", \"*\", \"1\"]"]}], "category": "String", "prompt_tokens": 1324, "total_tokens": 1807, "completion_tokens": 483, "completion": "Create a function that checks if a string is a palindrome. A palindrome is a word, phrase, number, or other sequence of characters which reads the same backward as forward, ignoring spaces, punctuation, and capitalization.\n\n###Code:\n\ndef is_palindrome(s: str) -> bool:\n  left, right = 0, len(s) - 1\n  while left < right:\n    # Skip non-alphanumeric characters\n    while left < right and not s[left].isalnum():\n      left += 1\n    while left < right and not s[right].isalnum():\n      right -= 1\n    \n    # Check if the characters are equal (case-insensitive)\n    if s[left].lower() != s[right].lower():\n      return False\n    \n    left, right = left + 1, right - 1\n  \n  return True\n\n###Testcases: \n\nassert is_palindrome(\"A man, a plan, a canal: Panama\") == True\nassert is_palindrome(\"race a car\") == False\nassert is_palindrome(\" \") == True  # Edge case: Empty string or string with only spaces\nassert is_palindrome(\"No lemon, no melon\") == True\nassert is_palindrome(\"Was it a car or a cat I saw?\") == True\nassert is_palindrome(\"No 'x' in Nixon\") == True\nassert is_palindrome(\"Madam, in Eden, I'm Adam\") == True\nassert is_palindrome(\"Step on no pets\") == True\nassert is_palindrome(\"123454321\") == True\nassert is_palindrome(\"12345\") == False\nassert is_palindrome(\"1a2\") == False\nassert is_palindrome(\"1a2a1\") == True\nassert is_palindrome(\"Able was I ere I saw Elba\") == True\nassert is_palindrome(\"Never odd or even\") == True\nassert is_palindrome(\"Do geese see God?\") == True\nassert is_palindrome(\"Mr. Owl ate my metal worm\") == True\nassert is_palindrome(\"Red roses run no risk, sir, on Nurse\u2019s order\") == True\nassert is_palindrome(\"Eva, can I see bees in a cave?\") == True\nassert is_palindrome(\"\") == True  # Edge case: Empty string\n\n[/Example 3]", "temperature": 0.722}, {"few_shots": [{"author": "Calvin", "UUID": "d0ce7430-cfcd-4c69-b161-b3b2a186422c", "question": "Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.\n\nIn other words, return true if one of s1's permutations is the substring of s2.", "examples": "Input: s1 = \"ab\", s2 = \"eidbaooo\"\nOutput: True\n\nInput: s1 = \"ab\", s2 = \"eidboaoo\"\nOutput: False", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef permutation_in_string(s1: str, s2: str) -> bool:\n  window = len(s1)\n  if window > len(s2):\n    return False\n  freq1 = [0]*26\n  freq2 = [0]*26\n  for i in range(window):\n    freq1[ord(s1[i])-ord('a')] += 1\n    freq2[ord(s2[i])-ord('a')] += 1\n\n  matches = 0\n  for i in range(26):\n    if freq1[i] == freq2[i]:\n      matches += 1\n  \n  for l in range(len(s2) - window):\n    if matches == 26:\n      return True\n\n    added = ord(s2[l + window]) - ord('a')\n    freq2[added] += 1\n    if freq1[added] == freq2[added]:\n      matches += 1\n    elif freq1[added] + 1 == freq2[added]:\n      matches -= 1\n\n    removed = ord(s2[l]) - ord('a')\n    freq2[removed] -= 1\n    if freq1[removed] == freq2[removed]:\n      matches += 1\n    elif freq1[removed] == freq2[removed] + 1:\n      matches -= 1\n    \n  return matches == 26\n", "asserts": ["assert permutation_in_string(\"hello\", \"ooollehhhhh\") == True", "assert permutation_in_string(\"abc\", \"ccccbbbbaaaa\") == False", "assert permutation_in_string(\"xyz\", \"zxyopqrstuv\") == True", "assert permutation_in_string(\"xyz\", \"xzygxzyzxyzk\") == True", "assert permutation_in_string(\"a\", \"a\") == True", "assert permutation_in_string(\"adc\", \"dcda\") == True", "assert permutation_in_string(\"pq\", \"qpqqp\") == True", "assert permutation_in_string(\"kitten\", \"sittingkite\") == False", "assert permutation_in_string(\"pq\", \"pqpqr\") == True", "assert permutation_in_string(\"aba\", \"aabaabaa\") == True", "assert permutation_in_string(\"\", \"\") == True  # Edge case: both strings are empty", "assert permutation_in_string(\"longerstring\", \"short\") == False  # s1 is longer than s2", "assert permutation_in_string(\"a\", \"b\") == False  # Single character, no match", "assert permutation_in_string(\"aab\", \"baa\") == True  # s1 is a permutation of s2", "assert permutation_in_string(\"ab\", \"a\") == False  # s2 is shorter than s1", "assert permutation_in_string(\"ba\", \"eidbaooo\") == True  # Same characters as Example 1 but different permutation", "assert permutation_in_string(\"eid\", \"eidbaooo\") == True  # s1 is a prefix of s2", "assert permutation_in_string(\"ooo\", \"eidbaooo\") == True  # s1 is a suffix of s2", "assert permutation_in_string(\"db\", \"eidbaooo\") == True  # s1 is a permutation within s2", "assert permutation_in_string(\"eidoo\", \"eidbaooo\") == False  # s1 is longer than any permutation within s2"]}, {"author": "Calvin", "UUID": "80e34b28-16a8-46ac-8b6a-ee28beb1e8d4", "question": "Write a function that reverses a string. The input string is given as an array of characters s.\n\nYou must do this by modifying the input array in-place with O(1) extra memory.", "examples": "Input: [\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput: [\"o\",\"l\",\"l\",\"e\",\"h\"]\n\nInput: [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\nOutput: [\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def reverse_string(s: list) -> list:\n  l = 0\n  r = len(s) - 1\n  while l < r:\n    tmp = s[l]\n    s[l] = s[r]\n    s[r] = tmp\n    l += 1\n    r -= 1\n  return s\n", "asserts": ["assert reverse_string([\"a\",\"b\",\"c\",\"d\"]) == [\"d\", \"c\", \"b\", \"a\"]", "assert reverse_string([\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"]) == [\"n\", \"o\", \"h\", \"t\", \"y\", \"p\"]", "assert reverse_string([]) == []", "assert reverse_string([\"s\", \"i\", \"n\", \"g\", \"l\", \"e\"]) == [\"e\", \"l\", \"g\", \"n\", \"i\", \"s\"]", "assert reverse_string([\"A\"]) == [\"A\"]", "assert reverse_string([\"9\", \"8\", \"7\", \"6\", \"5\", \"4\", \"3\", \"2\", \"1\"]) == [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]", "assert reverse_string([\"B\", \"o\", \"b\"]) == [\"b\", \"o\", \"B\"]", "assert reverse_string([\"r\", \"e\", \"v\", \"e\", \"r\", \"s\", \"e\"]) == [\"e\", \"s\", \"r\", \"e\", \"v\", \"e\", \"r\"]", "assert reverse_string([\"1\", \"*\", \"2\", \"*\", \"3\"]) == [\"3\", \"*\", \"2\", \"*\", \"1\"]"]}], "category": "String", "prompt_tokens": 1324, "total_tokens": 1774, "completion_tokens": 450, "completion": "Create a function that determines if a string can be formed by characters from a list of word fragments. Each fragment can only be used once, but it may not be necessary to use all of them.\n\n###Code: \n\ndef can_form_string_from_fragments(target: str, fragments: list) -> bool:\n    def can_form(index, current):\n        if index == len(target):\n            return current == target\n        \n        for i, fragment in enumerate(fragments):\n            if fragment and current + fragment == target[:len(current) + len(fragment)]:\n                # Use the fragment and move on\n                fragments[i] = ''  # Mark this fragment as used\n                if can_form(index + len(fragment), current + fragment):\n                    return True\n                fragments[i] = fragment  # Restore for backtracking\n                \n        return False\n        \n    return can_form(0, '')\n\n###Testcases: \n\nassert can_form_string_from_fragments(\"submarine\", [\"sub\", \"ma\", \"rine\", \"b\"]) == True\nassert can_form_string_from_fragments(\"hello\", [\"hel\", \"lo\", \"o\", \"he\"]) == True\nassert can_form_string_from_fragments(\"python\", [\"pyt\", \"hy\", \"on\"]) == False\nassert can_form_string_from_fragments(\"concatenate\", [\"con\", \"cat\", \"enate\", \"con\"]) == True\nassert can_form_string_from_fragments(\"balloon\", [\"ba\", \"loon\", \"bal\", \"on\"]) == True\nassert can_form_string_from_fragments(\"football\", [\"foot\", \"b\", \"all\"]) == True\nassert can_form_string_from_fragments(\"impossible\", [\"im\", \"possible\", \"pos\", \"sible\", \"impo\"]) == False\nassert can_form_string_from_fragments(\"algorithm\", []) == False\nassert can_form_string_from_fragments(\"performance\", [\"per\", \"mance\", \"for\", \"per\"]) == True\nassert can_form_string_from_fragments(\"\", [\"empty\", \"nope\"]) == True  # Edge case: empty target\nassert can_form_string_from_fragments(\"a\", [\"a\"]) == True  # Single character\n\n[/Example 3]", "temperature": 0.919}, {"few_shots": [{"author": "Calvin", "UUID": "d0ce7430-cfcd-4c69-b161-b3b2a186422c", "question": "Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.\n\nIn other words, return true if one of s1's permutations is the substring of s2.", "examples": "Input: s1 = \"ab\", s2 = \"eidbaooo\"\nOutput: True\n\nInput: s1 = \"ab\", s2 = \"eidboaoo\"\nOutput: False", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef permutation_in_string(s1: str, s2: str) -> bool:\n  window = len(s1)\n  if window > len(s2):\n    return False\n  freq1 = [0]*26\n  freq2 = [0]*26\n  for i in range(window):\n    freq1[ord(s1[i])-ord('a')] += 1\n    freq2[ord(s2[i])-ord('a')] += 1\n\n  matches = 0\n  for i in range(26):\n    if freq1[i] == freq2[i]:\n      matches += 1\n  \n  for l in range(len(s2) - window):\n    if matches == 26:\n      return True\n\n    added = ord(s2[l + window]) - ord('a')\n    freq2[added] += 1\n    if freq1[added] == freq2[added]:\n      matches += 1\n    elif freq1[added] + 1 == freq2[added]:\n      matches -= 1\n\n    removed = ord(s2[l]) - ord('a')\n    freq2[removed] -= 1\n    if freq1[removed] == freq2[removed]:\n      matches += 1\n    elif freq1[removed] == freq2[removed] + 1:\n      matches -= 1\n    \n  return matches == 26\n", "asserts": ["assert permutation_in_string(\"hello\", \"ooollehhhhh\") == True", "assert permutation_in_string(\"abc\", \"ccccbbbbaaaa\") == False", "assert permutation_in_string(\"xyz\", \"zxyopqrstuv\") == True", "assert permutation_in_string(\"xyz\", \"xzygxzyzxyzk\") == True", "assert permutation_in_string(\"a\", \"a\") == True", "assert permutation_in_string(\"adc\", \"dcda\") == True", "assert permutation_in_string(\"pq\", \"qpqqp\") == True", "assert permutation_in_string(\"kitten\", \"sittingkite\") == False", "assert permutation_in_string(\"pq\", \"pqpqr\") == True", "assert permutation_in_string(\"aba\", \"aabaabaa\") == True", "assert permutation_in_string(\"\", \"\") == True  # Edge case: both strings are empty", "assert permutation_in_string(\"longerstring\", \"short\") == False  # s1 is longer than s2", "assert permutation_in_string(\"a\", \"b\") == False  # Single character, no match", "assert permutation_in_string(\"aab\", \"baa\") == True  # s1 is a permutation of s2", "assert permutation_in_string(\"ab\", \"a\") == False  # s2 is shorter than s1", "assert permutation_in_string(\"ba\", \"eidbaooo\") == True  # Same characters as Example 1 but different permutation", "assert permutation_in_string(\"eid\", \"eidbaooo\") == True  # s1 is a prefix of s2", "assert permutation_in_string(\"ooo\", \"eidbaooo\") == True  # s1 is a suffix of s2", "assert permutation_in_string(\"db\", \"eidbaooo\") == True  # s1 is a permutation within s2", "assert permutation_in_string(\"eidoo\", \"eidbaooo\") == False  # s1 is longer than any permutation within s2"]}, {"author": "Calvin", "UUID": "80e34b28-16a8-46ac-8b6a-ee28beb1e8d4", "question": "Write a function that reverses a string. The input string is given as an array of characters s.\n\nYou must do this by modifying the input array in-place with O(1) extra memory.", "examples": "Input: [\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput: [\"o\",\"l\",\"l\",\"e\",\"h\"]\n\nInput: [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\nOutput: [\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def reverse_string(s: list) -> list:\n  l = 0\n  r = len(s) - 1\n  while l < r:\n    tmp = s[l]\n    s[l] = s[r]\n    s[r] = tmp\n    l += 1\n    r -= 1\n  return s\n", "asserts": ["assert reverse_string([\"a\",\"b\",\"c\",\"d\"]) == [\"d\", \"c\", \"b\", \"a\"]", "assert reverse_string([\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"]) == [\"n\", \"o\", \"h\", \"t\", \"y\", \"p\"]", "assert reverse_string([]) == []", "assert reverse_string([\"s\", \"i\", \"n\", \"g\", \"l\", \"e\"]) == [\"e\", \"l\", \"g\", \"n\", \"i\", \"s\"]", "assert reverse_string([\"A\"]) == [\"A\"]", "assert reverse_string([\"9\", \"8\", \"7\", \"6\", \"5\", \"4\", \"3\", \"2\", \"1\"]) == [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]", "assert reverse_string([\"B\", \"o\", \"b\"]) == [\"b\", \"o\", \"B\"]", "assert reverse_string([\"r\", \"e\", \"v\", \"e\", \"r\", \"s\", \"e\"]) == [\"e\", \"s\", \"r\", \"e\", \"v\", \"e\", \"r\"]", "assert reverse_string([\"1\", \"*\", \"2\", \"*\", \"3\"]) == [\"3\", \"*\", \"2\", \"*\", \"1\"]"]}], "category": "String", "prompt_tokens": 1324, "total_tokens": 1872, "completion_tokens": 548, "completion": "Given a string s and a set of characters c, find the shortest substring of s which contains all the characters in c at least once. If there isn't one, return an empty string.\n\n###Code: \n\ndef find_substring(s: str, c: set) -> str:\n    if not c or not s:\n        return \"\"\n    \n    required = {char: 1 for char in c}\n    formed = {char: 0 for char in c}\n    formed_count = 0\n    \n    left = 0\n    min_length = float('inf')\n    min_substring = \"\"\n    \n    for right, char in enumerate(s):\n        if char in formed:\n            formed[char] += 1\n            if formed[char] == required[char]:\n                formed_count += 1\n        \n        while left <= right and formed_count == len(c):\n            if right - left + 1 < min_length:\n                min_length = right - left + 1\n                min_substring = s[left:right + 1]\n            \n            if s[left] in formed:\n                formed[s[left]] -= 1\n                if formed[s[left]] < required[s[left]]:\n                    formed_count -= 1\n            \n            left += 1\n    \n    return min_substring\n\n\n###Testcases: \n\nassert find_substring(\"ADOBECODEBANC\", {\"A\", \"B\", \"C\"}) == \"BANC\"\nassert find_substring(\"this is a test string\", {\"t\", \"i\"}) == \"is is a t\"\nassert find_substring(\"geeksforgeeks\", {\"g\", \"k\", \"e\"}) == \"geeks\"\nassert find_substring(\"figehaeci\", {\"a\", \"e\", \"i\"}) == \"aeci\"\nassert find_substring(\"\", {\"a\", \"b\"}) == \"\"\nassert find_substring(\"abcdef\", {\"z\"}) == \"\"\nassert find_substring(\"a\", {\"a\"}) == \"a\"\nassert find_substring(\"bba\", {\"a\", \"b\"}) == \"ba\"\nassert find_substring(\"bcaacbc\", {\"a\", \"b\", \"c\"}) == \"cba\"\nassert find_substring(\"aaffhkksemckelloe\", {\"f\", \"e\", \"k\", \"h\"}) == \"affhkkse\"\nassert find_substring(\"xyz\", {\"x\", \"y\", \"z\"}) == \"xyz\"\nassert find_substring(\"xyyzyzyx\", {\"x\", \"y\", \"z\"}) == \"zyx\"\nassert find_substring(\"aaaabbbbcccc\", {\"a\", \"b\", \"c\"}) == \"abc\"\n\n[/Example 3]", "temperature": 0.924}, {"few_shots": [{"author": "Calvin", "UUID": "d0ce7430-cfcd-4c69-b161-b3b2a186422c", "question": "Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.\n\nIn other words, return true if one of s1's permutations is the substring of s2.", "examples": "Input: s1 = \"ab\", s2 = \"eidbaooo\"\nOutput: True\n\nInput: s1 = \"ab\", s2 = \"eidboaoo\"\nOutput: False", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef permutation_in_string(s1: str, s2: str) -> bool:\n  window = len(s1)\n  if window > len(s2):\n    return False\n  freq1 = [0]*26\n  freq2 = [0]*26\n  for i in range(window):\n    freq1[ord(s1[i])-ord('a')] += 1\n    freq2[ord(s2[i])-ord('a')] += 1\n\n  matches = 0\n  for i in range(26):\n    if freq1[i] == freq2[i]:\n      matches += 1\n  \n  for l in range(len(s2) - window):\n    if matches == 26:\n      return True\n\n    added = ord(s2[l + window]) - ord('a')\n    freq2[added] += 1\n    if freq1[added] == freq2[added]:\n      matches += 1\n    elif freq1[added] + 1 == freq2[added]:\n      matches -= 1\n\n    removed = ord(s2[l]) - ord('a')\n    freq2[removed] -= 1\n    if freq1[removed] == freq2[removed]:\n      matches += 1\n    elif freq1[removed] == freq2[removed] + 1:\n      matches -= 1\n    \n  return matches == 26\n", "asserts": ["assert permutation_in_string(\"hello\", \"ooollehhhhh\") == True", "assert permutation_in_string(\"abc\", \"ccccbbbbaaaa\") == False", "assert permutation_in_string(\"xyz\", \"zxyopqrstuv\") == True", "assert permutation_in_string(\"xyz\", \"xzygxzyzxyzk\") == True", "assert permutation_in_string(\"a\", \"a\") == True", "assert permutation_in_string(\"adc\", \"dcda\") == True", "assert permutation_in_string(\"pq\", \"qpqqp\") == True", "assert permutation_in_string(\"kitten\", \"sittingkite\") == False", "assert permutation_in_string(\"pq\", \"pqpqr\") == True", "assert permutation_in_string(\"aba\", \"aabaabaa\") == True", "assert permutation_in_string(\"\", \"\") == True  # Edge case: both strings are empty", "assert permutation_in_string(\"longerstring\", \"short\") == False  # s1 is longer than s2", "assert permutation_in_string(\"a\", \"b\") == False  # Single character, no match", "assert permutation_in_string(\"aab\", \"baa\") == True  # s1 is a permutation of s2", "assert permutation_in_string(\"ab\", \"a\") == False  # s2 is shorter than s1", "assert permutation_in_string(\"ba\", \"eidbaooo\") == True  # Same characters as Example 1 but different permutation", "assert permutation_in_string(\"eid\", \"eidbaooo\") == True  # s1 is a prefix of s2", "assert permutation_in_string(\"ooo\", \"eidbaooo\") == True  # s1 is a suffix of s2", "assert permutation_in_string(\"db\", \"eidbaooo\") == True  # s1 is a permutation within s2", "assert permutation_in_string(\"eidoo\", \"eidbaooo\") == False  # s1 is longer than any permutation within s2"]}, {"author": "Calvin", "UUID": "80e34b28-16a8-46ac-8b6a-ee28beb1e8d4", "question": "Write a function that reverses a string. The input string is given as an array of characters s.\n\nYou must do this by modifying the input array in-place with O(1) extra memory.", "examples": "Input: [\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput: [\"o\",\"l\",\"l\",\"e\",\"h\"]\n\nInput: [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\nOutput: [\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def reverse_string(s: list) -> list:\n  l = 0\n  r = len(s) - 1\n  while l < r:\n    tmp = s[l]\n    s[l] = s[r]\n    s[r] = tmp\n    l += 1\n    r -= 1\n  return s\n", "asserts": ["assert reverse_string([\"a\",\"b\",\"c\",\"d\"]) == [\"d\", \"c\", \"b\", \"a\"]", "assert reverse_string([\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"]) == [\"n\", \"o\", \"h\", \"t\", \"y\", \"p\"]", "assert reverse_string([]) == []", "assert reverse_string([\"s\", \"i\", \"n\", \"g\", \"l\", \"e\"]) == [\"e\", \"l\", \"g\", \"n\", \"i\", \"s\"]", "assert reverse_string([\"A\"]) == [\"A\"]", "assert reverse_string([\"9\", \"8\", \"7\", \"6\", \"5\", \"4\", \"3\", \"2\", \"1\"]) == [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]", "assert reverse_string([\"B\", \"o\", \"b\"]) == [\"b\", \"o\", \"B\"]", "assert reverse_string([\"r\", \"e\", \"v\", \"e\", \"r\", \"s\", \"e\"]) == [\"e\", \"s\", \"r\", \"e\", \"v\", \"e\", \"r\"]", "assert reverse_string([\"1\", \"*\", \"2\", \"*\", \"3\"]) == [\"3\", \"*\", \"2\", \"*\", \"1\"]"]}], "category": "String", "prompt_tokens": 1324, "total_tokens": 1634, "completion_tokens": 310, "completion": "Write a function to find the first non-repeating character in a given string and return its index. If it doesn't exist, return -1.\n\n###Code:\n\ndef first_uniq_char(s: str) -> int:\n  frequency = {}\n  for char in s:\n    frequency[char] = frequency.get(char, 0) + 1\n\n  for index, char in enumerate(s):\n    if frequency[char] == 1:\n      return index\n  \n  return -1\n\n\n###Testcases:\n\nassert first_uniq_char(\"leetcode\") == 0\nassert first_uniq_char(\"loveleetcode\") == 2\nassert first_uniq_char(\"aabb\") == -1\nassert first_uniq_char(\"algorithm\") == 0\nassert first_uniq_char(\"pythonprogramming\") == 1\nassert first_uniq_char(\"\") == -1  # Empty string\nassert first_uniq_char(\"z\") == 0  # Single character\nassert first_uniq_char(\"aabbc\") == 4\nassert first_uniq_char(\"aabbccddeeffg\") == 12\nassert first_uniq_char(\"abacb\") == 1\nassert first_uniq_char(\"xyzzyx\") == -1\nassert first_uniq_char(\"racecars\") == 7\nassert first_uniq_char(\"abacabad\") == 6\nassert first_uniq_char(\"thedailybyte\") == 1\nassert first_uniq_char(\"developer\") == 0\n\n[/Example 3]", "temperature": 0.69}, {"few_shots": [{"author": "Calvin", "UUID": "d0ce7430-cfcd-4c69-b161-b3b2a186422c", "question": "Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.\n\nIn other words, return true if one of s1's permutations is the substring of s2.", "examples": "Input: s1 = \"ab\", s2 = \"eidbaooo\"\nOutput: True\n\nInput: s1 = \"ab\", s2 = \"eidboaoo\"\nOutput: False", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef permutation_in_string(s1: str, s2: str) -> bool:\n  window = len(s1)\n  if window > len(s2):\n    return False\n  freq1 = [0]*26\n  freq2 = [0]*26\n  for i in range(window):\n    freq1[ord(s1[i])-ord('a')] += 1\n    freq2[ord(s2[i])-ord('a')] += 1\n\n  matches = 0\n  for i in range(26):\n    if freq1[i] == freq2[i]:\n      matches += 1\n  \n  for l in range(len(s2) - window):\n    if matches == 26:\n      return True\n\n    added = ord(s2[l + window]) - ord('a')\n    freq2[added] += 1\n    if freq1[added] == freq2[added]:\n      matches += 1\n    elif freq1[added] + 1 == freq2[added]:\n      matches -= 1\n\n    removed = ord(s2[l]) - ord('a')\n    freq2[removed] -= 1\n    if freq1[removed] == freq2[removed]:\n      matches += 1\n    elif freq1[removed] == freq2[removed] + 1:\n      matches -= 1\n    \n  return matches == 26\n", "asserts": ["assert permutation_in_string(\"hello\", \"ooollehhhhh\") == True", "assert permutation_in_string(\"abc\", \"ccccbbbbaaaa\") == False", "assert permutation_in_string(\"xyz\", \"zxyopqrstuv\") == True", "assert permutation_in_string(\"xyz\", \"xzygxzyzxyzk\") == True", "assert permutation_in_string(\"a\", \"a\") == True", "assert permutation_in_string(\"adc\", \"dcda\") == True", "assert permutation_in_string(\"pq\", \"qpqqp\") == True", "assert permutation_in_string(\"kitten\", \"sittingkite\") == False", "assert permutation_in_string(\"pq\", \"pqpqr\") == True", "assert permutation_in_string(\"aba\", \"aabaabaa\") == True", "assert permutation_in_string(\"\", \"\") == True  # Edge case: both strings are empty", "assert permutation_in_string(\"longerstring\", \"short\") == False  # s1 is longer than s2", "assert permutation_in_string(\"a\", \"b\") == False  # Single character, no match", "assert permutation_in_string(\"aab\", \"baa\") == True  # s1 is a permutation of s2", "assert permutation_in_string(\"ab\", \"a\") == False  # s2 is shorter than s1", "assert permutation_in_string(\"ba\", \"eidbaooo\") == True  # Same characters as Example 1 but different permutation", "assert permutation_in_string(\"eid\", \"eidbaooo\") == True  # s1 is a prefix of s2", "assert permutation_in_string(\"ooo\", \"eidbaooo\") == True  # s1 is a suffix of s2", "assert permutation_in_string(\"db\", \"eidbaooo\") == True  # s1 is a permutation within s2", "assert permutation_in_string(\"eidoo\", \"eidbaooo\") == False  # s1 is longer than any permutation within s2"]}, {"author": "Calvin", "UUID": "87372a22-f5ef-4100-845b-28700ca3fde3", "question": "You are given a string s and an integer array indices of the same length. The string s will be shuffled such that the character at the ith position moves to indices[i] in the shuffled string.\n\nReturn the shuffled string.", "examples": "Input: s = \"codeleet\", indices = [4,5,6,7,0,2,1,3]\nOutput: \"leetcode\"\n\nInput: s = \"abc\", indices = [0,1,2]\nOutput: \"abc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "from typing import List\ndef shuffle_string(s: str, indices: List[int]) -> str:\n    def partitionString(s):\n      substrings = 1\n      cur_str = set()\n      for i in range(len(s)):\n        if s[i] in cur_str:\n          substrings += 1\n          cur_str = {s[i]}\n        else:\n          cur_str.add(s[i])\n      return substrings\n    ret = ['_']*len(s)\n    for idx, i in enumerate(indices):\n        ret[i] = s[idx]\n    return \"\".join(ret)\n", "asserts": ["assert shuffle_string(\"reoc\", [2, 0, 1, 3]) == \"eorc\"", "assert shuffle_string(\"aiohn\", [3,1,4,2,0]) == \"nihao\"", "assert shuffle_string(\"aax\", [0,2,1]) == \"axa\"", "assert shuffle_string(\"gh\", [1,0]) == \"hg\"", "assert shuffle_string(\"\", []) == \"\"  # Edge case: empty string", "assert shuffle_string(\"xy\", [0,1]) == \"xy\"  # No shuffle required", "assert shuffle_string(\"pqrstuvwxyzabcdefghijklmno\", list(range(25, -1, -1))) == \"onmlkjihgfedcbazyxwvutsrqp\"  # Reverse shuffle"]}], "category": "String", "prompt_tokens": 1265, "total_tokens": 1620, "completion_tokens": 355, "completion": "Write a function called 'count_vowels' that takes a string as its parameter and returns the number of vowels contained in the string. The vowels are 'a', 'e', 'i', 'o', and 'u', and can be both lower and upper case.\n\n###Code:\n\ndef count_vowels(s: str) -> int:\n    vowels = \"aeiouAEIOU\"\n    return sum(1 for char in s if char in vowels)\n\n###Testcases:\n\nassert count_vowels(\"hello world\") == 3\nassert count_vowels(\"AEIOU\") == 5\nassert count_vowels(\"abcdefghijklmnopqrstuvwxyz\") == 5\nassert count_vowels(\"The quick brown fox jumps over the lazy dog\") == 11\nassert count_vowels(\"Python Programming\") == 4\nassert count_vowels(\"\") == 0  # Edge case: empty string\nassert count_vowels(\"bcdfghjklmnpqrstvwxyz\") == 0  # No vowels\nassert count_vowels(\"HELLO\") == 2\nassert count_vowels(\"aEiOu\") == 5  # Mixed case\nassert count_vowels(\"12345\") == 0  # Numbers, no vowels\nassert count_vowels(\"A man a plan a canal Panama\") == 11\nassert count_vowels(\"Fly to the moon\") == 4\nassert count_vowels(\"SymPy is a Python library for symbolic mathematics\") == 15\nassert count_vowels(\"Live long and prosper\") == 5\nassert count_vowels(\"May the Force be with you\") == 7\n\n[/Example 3]", "temperature": 0.667}, {"few_shots": [{"author": "Calvin", "UUID": "d0ce7430-cfcd-4c69-b161-b3b2a186422c", "question": "Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.\n\nIn other words, return true if one of s1's permutations is the substring of s2.", "examples": "Input: s1 = \"ab\", s2 = \"eidbaooo\"\nOutput: True\n\nInput: s1 = \"ab\", s2 = \"eidboaoo\"\nOutput: False", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef permutation_in_string(s1: str, s2: str) -> bool:\n  window = len(s1)\n  if window > len(s2):\n    return False\n  freq1 = [0]*26\n  freq2 = [0]*26\n  for i in range(window):\n    freq1[ord(s1[i])-ord('a')] += 1\n    freq2[ord(s2[i])-ord('a')] += 1\n\n  matches = 0\n  for i in range(26):\n    if freq1[i] == freq2[i]:\n      matches += 1\n  \n  for l in range(len(s2) - window):\n    if matches == 26:\n      return True\n\n    added = ord(s2[l + window]) - ord('a')\n    freq2[added] += 1\n    if freq1[added] == freq2[added]:\n      matches += 1\n    elif freq1[added] + 1 == freq2[added]:\n      matches -= 1\n\n    removed = ord(s2[l]) - ord('a')\n    freq2[removed] -= 1\n    if freq1[removed] == freq2[removed]:\n      matches += 1\n    elif freq1[removed] == freq2[removed] + 1:\n      matches -= 1\n    \n  return matches == 26\n", "asserts": ["assert permutation_in_string(\"hello\", \"ooollehhhhh\") == True", "assert permutation_in_string(\"abc\", \"ccccbbbbaaaa\") == False", "assert permutation_in_string(\"xyz\", \"zxyopqrstuv\") == True", "assert permutation_in_string(\"xyz\", \"xzygxzyzxyzk\") == True", "assert permutation_in_string(\"a\", \"a\") == True", "assert permutation_in_string(\"adc\", \"dcda\") == True", "assert permutation_in_string(\"pq\", \"qpqqp\") == True", "assert permutation_in_string(\"kitten\", \"sittingkite\") == False", "assert permutation_in_string(\"pq\", \"pqpqr\") == True", "assert permutation_in_string(\"aba\", \"aabaabaa\") == True", "assert permutation_in_string(\"\", \"\") == True  # Edge case: both strings are empty", "assert permutation_in_string(\"longerstring\", \"short\") == False  # s1 is longer than s2", "assert permutation_in_string(\"a\", \"b\") == False  # Single character, no match", "assert permutation_in_string(\"aab\", \"baa\") == True  # s1 is a permutation of s2", "assert permutation_in_string(\"ab\", \"a\") == False  # s2 is shorter than s1", "assert permutation_in_string(\"ba\", \"eidbaooo\") == True  # Same characters as Example 1 but different permutation", "assert permutation_in_string(\"eid\", \"eidbaooo\") == True  # s1 is a prefix of s2", "assert permutation_in_string(\"ooo\", \"eidbaooo\") == True  # s1 is a suffix of s2", "assert permutation_in_string(\"db\", \"eidbaooo\") == True  # s1 is a permutation within s2", "assert permutation_in_string(\"eidoo\", \"eidbaooo\") == False  # s1 is longer than any permutation within s2"]}, {"author": "Calvin", "UUID": "87372a22-f5ef-4100-845b-28700ca3fde3", "question": "You are given a string s and an integer array indices of the same length. The string s will be shuffled such that the character at the ith position moves to indices[i] in the shuffled string.\n\nReturn the shuffled string.", "examples": "Input: s = \"codeleet\", indices = [4,5,6,7,0,2,1,3]\nOutput: \"leetcode\"\n\nInput: s = \"abc\", indices = [0,1,2]\nOutput: \"abc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "from typing import List\ndef shuffle_string(s: str, indices: List[int]) -> str:\n    def partitionString(s):\n      substrings = 1\n      cur_str = set()\n      for i in range(len(s)):\n        if s[i] in cur_str:\n          substrings += 1\n          cur_str = {s[i]}\n        else:\n          cur_str.add(s[i])\n      return substrings\n    ret = ['_']*len(s)\n    for idx, i in enumerate(indices):\n        ret[i] = s[idx]\n    return \"\".join(ret)\n", "asserts": ["assert shuffle_string(\"reoc\", [2, 0, 1, 3]) == \"eorc\"", "assert shuffle_string(\"aiohn\", [3,1,4,2,0]) == \"nihao\"", "assert shuffle_string(\"aax\", [0,2,1]) == \"axa\"", "assert shuffle_string(\"gh\", [1,0]) == \"hg\"", "assert shuffle_string(\"\", []) == \"\"  # Edge case: empty string", "assert shuffle_string(\"xy\", [0,1]) == \"xy\"  # No shuffle required", "assert shuffle_string(\"pqrstuvwxyzabcdefghijklmno\", list(range(25, -1, -1))) == \"onmlkjihgfedcbazyxwvutsrqp\"  # Reverse shuffle"]}], "category": "String", "prompt_tokens": 1265, "total_tokens": 1591, "completion_tokens": 326, "completion": "Write a function that takes a string s and returns the length of the longest substring without repeating characters.\n\n###Code: \n\ndef length_of_longest_substring(s: str) -> int:\n    start = maxLength = 0\n    usedChar = {}\n\n    for i in range(len(s)):\n        if s[i] in usedChar and start <= usedChar[s[i]]:\n            start = usedChar[s[i]] + 1\n        else:\n            maxLength = max(maxLength, i - start + 1)\n\n        usedChar[s[i]] = i\n\n    return maxLength\n\n###Testcases: \n\nassert length_of_longest_substring(\"abcabcbb\") == 3\nassert length_of_longest_substring(\"bbbbb\") == 1\nassert length_of_longest_substring(\"pwwkew\") == 3\nassert length_of_longest_substring(\"\") == 0  # Edge case: empty string\nassert length_of_longest_substring(\" \") == 1  # Single character\nassert length_of_longest_substring(\"dvdf\") == 3\nassert length_of_longest_substring(\"anviaj\") == 5\nassert length_of_longest_substring(\"abcdefg\") == 7  # All unique characters\nassert length_of_longest_substring(\"abba\") == 2\nassert length_of_longest_substring(\"tmmzuxt\") == 5\nassert length_of_longest_substring(\"longestsubstring\") == 8\nassert length_of_longest_substring(\"nonduplicate\") == 11\n\n[/Example 3]", "temperature": 0.792}, {"few_shots": [{"author": "Calvin", "UUID": "d0ce7430-cfcd-4c69-b161-b3b2a186422c", "question": "Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.\n\nIn other words, return true if one of s1's permutations is the substring of s2.", "examples": "Input: s1 = \"ab\", s2 = \"eidbaooo\"\nOutput: True\n\nInput: s1 = \"ab\", s2 = \"eidboaoo\"\nOutput: False", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef permutation_in_string(s1: str, s2: str) -> bool:\n  window = len(s1)\n  if window > len(s2):\n    return False\n  freq1 = [0]*26\n  freq2 = [0]*26\n  for i in range(window):\n    freq1[ord(s1[i])-ord('a')] += 1\n    freq2[ord(s2[i])-ord('a')] += 1\n\n  matches = 0\n  for i in range(26):\n    if freq1[i] == freq2[i]:\n      matches += 1\n  \n  for l in range(len(s2) - window):\n    if matches == 26:\n      return True\n\n    added = ord(s2[l + window]) - ord('a')\n    freq2[added] += 1\n    if freq1[added] == freq2[added]:\n      matches += 1\n    elif freq1[added] + 1 == freq2[added]:\n      matches -= 1\n\n    removed = ord(s2[l]) - ord('a')\n    freq2[removed] -= 1\n    if freq1[removed] == freq2[removed]:\n      matches += 1\n    elif freq1[removed] == freq2[removed] + 1:\n      matches -= 1\n    \n  return matches == 26\n", "asserts": ["assert permutation_in_string(\"hello\", \"ooollehhhhh\") == True", "assert permutation_in_string(\"abc\", \"ccccbbbbaaaa\") == False", "assert permutation_in_string(\"xyz\", \"zxyopqrstuv\") == True", "assert permutation_in_string(\"xyz\", \"xzygxzyzxyzk\") == True", "assert permutation_in_string(\"a\", \"a\") == True", "assert permutation_in_string(\"adc\", \"dcda\") == True", "assert permutation_in_string(\"pq\", \"qpqqp\") == True", "assert permutation_in_string(\"kitten\", \"sittingkite\") == False", "assert permutation_in_string(\"pq\", \"pqpqr\") == True", "assert permutation_in_string(\"aba\", \"aabaabaa\") == True", "assert permutation_in_string(\"\", \"\") == True  # Edge case: both strings are empty", "assert permutation_in_string(\"longerstring\", \"short\") == False  # s1 is longer than s2", "assert permutation_in_string(\"a\", \"b\") == False  # Single character, no match", "assert permutation_in_string(\"aab\", \"baa\") == True  # s1 is a permutation of s2", "assert permutation_in_string(\"ab\", \"a\") == False  # s2 is shorter than s1", "assert permutation_in_string(\"ba\", \"eidbaooo\") == True  # Same characters as Example 1 but different permutation", "assert permutation_in_string(\"eid\", \"eidbaooo\") == True  # s1 is a prefix of s2", "assert permutation_in_string(\"ooo\", \"eidbaooo\") == True  # s1 is a suffix of s2", "assert permutation_in_string(\"db\", \"eidbaooo\") == True  # s1 is a permutation within s2", "assert permutation_in_string(\"eidoo\", \"eidbaooo\") == False  # s1 is longer than any permutation within s2"]}, {"author": "Calvin", "UUID": "87372a22-f5ef-4100-845b-28700ca3fde3", "question": "You are given a string s and an integer array indices of the same length. The string s will be shuffled such that the character at the ith position moves to indices[i] in the shuffled string.\n\nReturn the shuffled string.", "examples": "Input: s = \"codeleet\", indices = [4,5,6,7,0,2,1,3]\nOutput: \"leetcode\"\n\nInput: s = \"abc\", indices = [0,1,2]\nOutput: \"abc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "from typing import List\ndef shuffle_string(s: str, indices: List[int]) -> str:\n    def partitionString(s):\n      substrings = 1\n      cur_str = set()\n      for i in range(len(s)):\n        if s[i] in cur_str:\n          substrings += 1\n          cur_str = {s[i]}\n        else:\n          cur_str.add(s[i])\n      return substrings\n    ret = ['_']*len(s)\n    for idx, i in enumerate(indices):\n        ret[i] = s[idx]\n    return \"\".join(ret)\n", "asserts": ["assert shuffle_string(\"reoc\", [2, 0, 1, 3]) == \"eorc\"", "assert shuffle_string(\"aiohn\", [3,1,4,2,0]) == \"nihao\"", "assert shuffle_string(\"aax\", [0,2,1]) == \"axa\"", "assert shuffle_string(\"gh\", [1,0]) == \"hg\"", "assert shuffle_string(\"\", []) == \"\"  # Edge case: empty string", "assert shuffle_string(\"xy\", [0,1]) == \"xy\"  # No shuffle required", "assert shuffle_string(\"pqrstuvwxyzabcdefghijklmno\", list(range(25, -1, -1))) == \"onmlkjihgfedcbazyxwvutsrqp\"  # Reverse shuffle"]}], "category": "String", "prompt_tokens": 1265, "total_tokens": 1633, "completion_tokens": 368, "completion": "Write a function to find the first non-repeating character in a given string and return its index. If it doesn't exist, return -1.\n\n###Code: \n\ndef first_uniq_char(s: str) -> int:\n    count = {}\n    for c in s:\n        count[c] = count.get(c, 0) + 1\n\n    for index, c in enumerate(s):\n        if count[c] == 1:\n            return index\n\n    return -1\n\n###Testcases: \n\nassert first_uniq_char(\"leetcode\") == 0\nassert first_uniq_char(\"loveleetcode\") == 2\nassert first_uniq_char(\"aabb\") == -1\nassert first_uniq_char(\"a\") == 0\nassert first_uniq_char(\"\") == -1  # Edge case: empty string\nassert first_uniq_char(\"aadadaad\") == -1  # No unique character\nassert first_uniq_char(\"singleton\") == 0  # All unique characters\nassert first_uniq_char(\"abracadabra\") == 4  # 'c' is the first non-repeating character\nassert first_uniq_char(\"stress\") == 2  # 't' is the first non-repeating character\nassert first_uniq_char(\"sTreSS\") == 1  # 'T' is the first non-repeating character (case-sensitive)\nassert first_uniq_char(\"barbecue\") == 1  # 'a' is the first non-repeating character\nassert first_uniq_char(\"alphabeta\") == 5  # 'b' is the first non-repeating character\nassert first_uniq_char(\"swiss\") == 2  # 'i' is the first non-repeating character\n\n[/Example 3]", "temperature": 0.944}, {"few_shots": [{"author": "Calvin", "UUID": "d0ce7430-cfcd-4c69-b161-b3b2a186422c", "question": "Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.\n\nIn other words, return true if one of s1's permutations is the substring of s2.", "examples": "Input: s1 = \"ab\", s2 = \"eidbaooo\"\nOutput: True\n\nInput: s1 = \"ab\", s2 = \"eidboaoo\"\nOutput: False", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef permutation_in_string(s1: str, s2: str) -> bool:\n  window = len(s1)\n  if window > len(s2):\n    return False\n  freq1 = [0]*26\n  freq2 = [0]*26\n  for i in range(window):\n    freq1[ord(s1[i])-ord('a')] += 1\n    freq2[ord(s2[i])-ord('a')] += 1\n\n  matches = 0\n  for i in range(26):\n    if freq1[i] == freq2[i]:\n      matches += 1\n  \n  for l in range(len(s2) - window):\n    if matches == 26:\n      return True\n\n    added = ord(s2[l + window]) - ord('a')\n    freq2[added] += 1\n    if freq1[added] == freq2[added]:\n      matches += 1\n    elif freq1[added] + 1 == freq2[added]:\n      matches -= 1\n\n    removed = ord(s2[l]) - ord('a')\n    freq2[removed] -= 1\n    if freq1[removed] == freq2[removed]:\n      matches += 1\n    elif freq1[removed] == freq2[removed] + 1:\n      matches -= 1\n    \n  return matches == 26\n", "asserts": ["assert permutation_in_string(\"hello\", \"ooollehhhhh\") == True", "assert permutation_in_string(\"abc\", \"ccccbbbbaaaa\") == False", "assert permutation_in_string(\"xyz\", \"zxyopqrstuv\") == True", "assert permutation_in_string(\"xyz\", \"xzygxzyzxyzk\") == True", "assert permutation_in_string(\"a\", \"a\") == True", "assert permutation_in_string(\"adc\", \"dcda\") == True", "assert permutation_in_string(\"pq\", \"qpqqp\") == True", "assert permutation_in_string(\"kitten\", \"sittingkite\") == False", "assert permutation_in_string(\"pq\", \"pqpqr\") == True", "assert permutation_in_string(\"aba\", \"aabaabaa\") == True", "assert permutation_in_string(\"\", \"\") == True  # Edge case: both strings are empty", "assert permutation_in_string(\"longerstring\", \"short\") == False  # s1 is longer than s2", "assert permutation_in_string(\"a\", \"b\") == False  # Single character, no match", "assert permutation_in_string(\"aab\", \"baa\") == True  # s1 is a permutation of s2", "assert permutation_in_string(\"ab\", \"a\") == False  # s2 is shorter than s1", "assert permutation_in_string(\"ba\", \"eidbaooo\") == True  # Same characters as Example 1 but different permutation", "assert permutation_in_string(\"eid\", \"eidbaooo\") == True  # s1 is a prefix of s2", "assert permutation_in_string(\"ooo\", \"eidbaooo\") == True  # s1 is a suffix of s2", "assert permutation_in_string(\"db\", \"eidbaooo\") == True  # s1 is a permutation within s2", "assert permutation_in_string(\"eidoo\", \"eidbaooo\") == False  # s1 is longer than any permutation within s2"]}, {"author": "Calvin", "UUID": "87372a22-f5ef-4100-845b-28700ca3fde3", "question": "You are given a string s and an integer array indices of the same length. The string s will be shuffled such that the character at the ith position moves to indices[i] in the shuffled string.\n\nReturn the shuffled string.", "examples": "Input: s = \"codeleet\", indices = [4,5,6,7,0,2,1,3]\nOutput: \"leetcode\"\n\nInput: s = \"abc\", indices = [0,1,2]\nOutput: \"abc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "from typing import List\ndef shuffle_string(s: str, indices: List[int]) -> str:\n    def partitionString(s):\n      substrings = 1\n      cur_str = set()\n      for i in range(len(s)):\n        if s[i] in cur_str:\n          substrings += 1\n          cur_str = {s[i]}\n        else:\n          cur_str.add(s[i])\n      return substrings\n    ret = ['_']*len(s)\n    for idx, i in enumerate(indices):\n        ret[i] = s[idx]\n    return \"\".join(ret)\n", "asserts": ["assert shuffle_string(\"reoc\", [2, 0, 1, 3]) == \"eorc\"", "assert shuffle_string(\"aiohn\", [3,1,4,2,0]) == \"nihao\"", "assert shuffle_string(\"aax\", [0,2,1]) == \"axa\"", "assert shuffle_string(\"gh\", [1,0]) == \"hg\"", "assert shuffle_string(\"\", []) == \"\"  # Edge case: empty string", "assert shuffle_string(\"xy\", [0,1]) == \"xy\"  # No shuffle required", "assert shuffle_string(\"pqrstuvwxyzabcdefghijklmno\", list(range(25, -1, -1))) == \"onmlkjihgfedcbazyxwvutsrqp\"  # Reverse shuffle"]}], "category": "String", "prompt_tokens": 1265, "total_tokens": 1684, "completion_tokens": 419, "completion": "Write a function to find the longest common prefix string amongst an array of strings.\n\nIf there is no common prefix, return an empty string \"\".\n\n###Code: \n\nfrom typing import List\n\ndef longest_common_prefix(strs: List[str]) -> str:\n    if not strs:\n        return \"\"\n    \n    shortest = min(strs, key=len)\n    for i, ch in enumerate(shortest):\n        for other in strs:\n            if other[i] != ch:\n                return shortest[:i]\n    return shortest\n\n###Testcases:\n\nassert longest_common_prefix([\"flower\",\"flow\",\"flight\"]) == \"fl\"\nassert longest_common_prefix([\"dog\",\"racecar\",\"car\"]) == \"\"\nassert longest_common_prefix([\"interspecies\",\"interstellar\",\"interstate\"]) == \"inters\"\nassert longest_common_prefix([\"throne\",\"throne\"]) == \"throne\"\nassert longest_common_prefix([\"throne\",\"dungeon\"]) == \"\"\nassert longest_common_prefix([\"cheese\"]) == \"cheese\"  # Edge case: single string\nassert longest_common_prefix([\"\", \"\"]) == \"\"  # Edge case: empty strings\nassert longest_common_prefix([\"a\", \"b\"]) == \"\"  # No common prefix\nassert longest_common_prefix([\"a\", \"a\"]) == \"a\"  # All strings are the same single character\nassert longest_common_prefix([\"\", \"b\"]) == \"\"  # One string is empty\nassert longest_common_prefix([\"abcdef\", \"abcde\", \"abcd\"]) == \"abcd\"  # All prefix are common\nassert longest_common_prefix([\"abcdefg\", \"abcdegh\", \"abcd\"]) == \"abcd\"  # Partial common prefix\nassert longest_common_prefix([\"\", \"abcde\", \"abcd\"]) == \"\"  # One string is empty, others have common prefix\nassert longest_common_prefix([\"abc\", \"abcde\", \"abcf\"]) == \"abc\"  # All strings have the same prefix\nassert longest_common_prefix([\"ab\", \"a\"]) == \"a\"  # One string is the prefix of the other\n\n[/Example 3]", "temperature": 0.731}, {"few_shots": [{"author": "Calvin", "UUID": "d0ce7430-cfcd-4c69-b161-b3b2a186422c", "question": "Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.\n\nIn other words, return true if one of s1's permutations is the substring of s2.", "examples": "Input: s1 = \"ab\", s2 = \"eidbaooo\"\nOutput: True\n\nInput: s1 = \"ab\", s2 = \"eidboaoo\"\nOutput: False", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef permutation_in_string(s1: str, s2: str) -> bool:\n  window = len(s1)\n  if window > len(s2):\n    return False\n  freq1 = [0]*26\n  freq2 = [0]*26\n  for i in range(window):\n    freq1[ord(s1[i])-ord('a')] += 1\n    freq2[ord(s2[i])-ord('a')] += 1\n\n  matches = 0\n  for i in range(26):\n    if freq1[i] == freq2[i]:\n      matches += 1\n  \n  for l in range(len(s2) - window):\n    if matches == 26:\n      return True\n\n    added = ord(s2[l + window]) - ord('a')\n    freq2[added] += 1\n    if freq1[added] == freq2[added]:\n      matches += 1\n    elif freq1[added] + 1 == freq2[added]:\n      matches -= 1\n\n    removed = ord(s2[l]) - ord('a')\n    freq2[removed] -= 1\n    if freq1[removed] == freq2[removed]:\n      matches += 1\n    elif freq1[removed] == freq2[removed] + 1:\n      matches -= 1\n    \n  return matches == 26\n", "asserts": ["assert permutation_in_string(\"hello\", \"ooollehhhhh\") == True", "assert permutation_in_string(\"abc\", \"ccccbbbbaaaa\") == False", "assert permutation_in_string(\"xyz\", \"zxyopqrstuv\") == True", "assert permutation_in_string(\"xyz\", \"xzygxzyzxyzk\") == True", "assert permutation_in_string(\"a\", \"a\") == True", "assert permutation_in_string(\"adc\", \"dcda\") == True", "assert permutation_in_string(\"pq\", \"qpqqp\") == True", "assert permutation_in_string(\"kitten\", \"sittingkite\") == False", "assert permutation_in_string(\"pq\", \"pqpqr\") == True", "assert permutation_in_string(\"aba\", \"aabaabaa\") == True", "assert permutation_in_string(\"\", \"\") == True  # Edge case: both strings are empty", "assert permutation_in_string(\"longerstring\", \"short\") == False  # s1 is longer than s2", "assert permutation_in_string(\"a\", \"b\") == False  # Single character, no match", "assert permutation_in_string(\"aab\", \"baa\") == True  # s1 is a permutation of s2", "assert permutation_in_string(\"ab\", \"a\") == False  # s2 is shorter than s1", "assert permutation_in_string(\"ba\", \"eidbaooo\") == True  # Same characters as Example 1 but different permutation", "assert permutation_in_string(\"eid\", \"eidbaooo\") == True  # s1 is a prefix of s2", "assert permutation_in_string(\"ooo\", \"eidbaooo\") == True  # s1 is a suffix of s2", "assert permutation_in_string(\"db\", \"eidbaooo\") == True  # s1 is a permutation within s2", "assert permutation_in_string(\"eidoo\", \"eidbaooo\") == False  # s1 is longer than any permutation within s2"]}, {"author": "Calvin", "UUID": "87372a22-f5ef-4100-845b-28700ca3fde3", "question": "You are given a string s and an integer array indices of the same length. The string s will be shuffled such that the character at the ith position moves to indices[i] in the shuffled string.\n\nReturn the shuffled string.", "examples": "Input: s = \"codeleet\", indices = [4,5,6,7,0,2,1,3]\nOutput: \"leetcode\"\n\nInput: s = \"abc\", indices = [0,1,2]\nOutput: \"abc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "from typing import List\ndef shuffle_string(s: str, indices: List[int]) -> str:\n    def partitionString(s):\n      substrings = 1\n      cur_str = set()\n      for i in range(len(s)):\n        if s[i] in cur_str:\n          substrings += 1\n          cur_str = {s[i]}\n        else:\n          cur_str.add(s[i])\n      return substrings\n    ret = ['_']*len(s)\n    for idx, i in enumerate(indices):\n        ret[i] = s[idx]\n    return \"\".join(ret)\n", "asserts": ["assert shuffle_string(\"reoc\", [2, 0, 1, 3]) == \"eorc\"", "assert shuffle_string(\"aiohn\", [3,1,4,2,0]) == \"nihao\"", "assert shuffle_string(\"aax\", [0,2,1]) == \"axa\"", "assert shuffle_string(\"gh\", [1,0]) == \"hg\"", "assert shuffle_string(\"\", []) == \"\"  # Edge case: empty string", "assert shuffle_string(\"xy\", [0,1]) == \"xy\"  # No shuffle required", "assert shuffle_string(\"pqrstuvwxyzabcdefghijklmno\", list(range(25, -1, -1))) == \"onmlkjihgfedcbazyxwvutsrqp\"  # Reverse shuffle"]}], "category": "String", "prompt_tokens": 1265, "total_tokens": 1662, "completion_tokens": 397, "completion": "Write a function to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string \"\".\n\n###Code:\n\n```python\nfrom typing import List\n\ndef longest_common_prefix(strs: List[str]) -> str:\n    if not strs:\n        return \"\"\n    \n    shortest = min(strs, key=len)\n    \n    for i, char in enumerate(shortest):\n        for other in strs:\n            if other[i] != char:\n                return shortest[:i]\n    \n    return shortest\n\n```\n\n###Testcases:\n\n```python\nassert longest_common_prefix([\"flower\", \"flow\", \"flight\"]) == \"fl\"\nassert longest_common_prefix([\"dog\", \"racecar\", \"car\"]) == \"\"\nassert longest_common_prefix([\"interspecies\", \"interstellar\", \"interstate\"]) == \"inters\"\nassert longest_common_prefix([\"throne\", \"throne\"]) == \"throne\"\nassert longest_common_prefix([\"prefix\", \"preposition\", \"prevalent\"]) == \"pre\"\nassert longest_common_prefix([\"\", \"\"]) == \"\"  # Edge case: Empty strings\nassert longest_common_prefix([\"a\"]) == \"a\"  # Single string\nassert longest_common_prefix([\"ab\", \"a\"]) == \"a\"  # One string is a prefix of the other\nassert longest_common_prefix([\"abc\", \"abc\", \"abc\"]) == \"abc\"  # All strings are identical\nassert longest_common_prefix([\"\", \"notempty\", \"alsonotempty\"]) == \"\"  # One of the strings is empty\nassert longest_common_prefix([\"short\", \"longer\", \"longest\"]) == \"\"  # No common prefix\nassert longest_common_prefix([\"prefix\", \"suffix\", \"affix\"]) == \"\"  # No common prefix but common suffix\nassert longest_common_prefix([\"123\", \"12345\", \"123456\"]) == \"123\"  # Numerical strings\n```\n\n[/Example 3]", "temperature": 0.81}, {"few_shots": [{"author": "Calvin", "UUID": "d0ce7430-cfcd-4c69-b161-b3b2a186422c", "question": "Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.\n\nIn other words, return true if one of s1's permutations is the substring of s2.", "examples": "Input: s1 = \"ab\", s2 = \"eidbaooo\"\nOutput: True\n\nInput: s1 = \"ab\", s2 = \"eidboaoo\"\nOutput: False", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef permutation_in_string(s1: str, s2: str) -> bool:\n  window = len(s1)\n  if window > len(s2):\n    return False\n  freq1 = [0]*26\n  freq2 = [0]*26\n  for i in range(window):\n    freq1[ord(s1[i])-ord('a')] += 1\n    freq2[ord(s2[i])-ord('a')] += 1\n\n  matches = 0\n  for i in range(26):\n    if freq1[i] == freq2[i]:\n      matches += 1\n  \n  for l in range(len(s2) - window):\n    if matches == 26:\n      return True\n\n    added = ord(s2[l + window]) - ord('a')\n    freq2[added] += 1\n    if freq1[added] == freq2[added]:\n      matches += 1\n    elif freq1[added] + 1 == freq2[added]:\n      matches -= 1\n\n    removed = ord(s2[l]) - ord('a')\n    freq2[removed] -= 1\n    if freq1[removed] == freq2[removed]:\n      matches += 1\n    elif freq1[removed] == freq2[removed] + 1:\n      matches -= 1\n    \n  return matches == 26\n", "asserts": ["assert permutation_in_string(\"hello\", \"ooollehhhhh\") == True", "assert permutation_in_string(\"abc\", \"ccccbbbbaaaa\") == False", "assert permutation_in_string(\"xyz\", \"zxyopqrstuv\") == True", "assert permutation_in_string(\"xyz\", \"xzygxzyzxyzk\") == True", "assert permutation_in_string(\"a\", \"a\") == True", "assert permutation_in_string(\"adc\", \"dcda\") == True", "assert permutation_in_string(\"pq\", \"qpqqp\") == True", "assert permutation_in_string(\"kitten\", \"sittingkite\") == False", "assert permutation_in_string(\"pq\", \"pqpqr\") == True", "assert permutation_in_string(\"aba\", \"aabaabaa\") == True", "assert permutation_in_string(\"\", \"\") == True  # Edge case: both strings are empty", "assert permutation_in_string(\"longerstring\", \"short\") == False  # s1 is longer than s2", "assert permutation_in_string(\"a\", \"b\") == False  # Single character, no match", "assert permutation_in_string(\"aab\", \"baa\") == True  # s1 is a permutation of s2", "assert permutation_in_string(\"ab\", \"a\") == False  # s2 is shorter than s1", "assert permutation_in_string(\"ba\", \"eidbaooo\") == True  # Same characters as Example 1 but different permutation", "assert permutation_in_string(\"eid\", \"eidbaooo\") == True  # s1 is a prefix of s2", "assert permutation_in_string(\"ooo\", \"eidbaooo\") == True  # s1 is a suffix of s2", "assert permutation_in_string(\"db\", \"eidbaooo\") == True  # s1 is a permutation within s2", "assert permutation_in_string(\"eidoo\", \"eidbaooo\") == False  # s1 is longer than any permutation within s2"]}, {"author": "Calvin", "UUID": "87372a22-f5ef-4100-845b-28700ca3fde3", "question": "You are given a string s and an integer array indices of the same length. The string s will be shuffled such that the character at the ith position moves to indices[i] in the shuffled string.\n\nReturn the shuffled string.", "examples": "Input: s = \"codeleet\", indices = [4,5,6,7,0,2,1,3]\nOutput: \"leetcode\"\n\nInput: s = \"abc\", indices = [0,1,2]\nOutput: \"abc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "from typing import List\ndef shuffle_string(s: str, indices: List[int]) -> str:\n    def partitionString(s):\n      substrings = 1\n      cur_str = set()\n      for i in range(len(s)):\n        if s[i] in cur_str:\n          substrings += 1\n          cur_str = {s[i]}\n        else:\n          cur_str.add(s[i])\n      return substrings\n    ret = ['_']*len(s)\n    for idx, i in enumerate(indices):\n        ret[i] = s[idx]\n    return \"\".join(ret)\n", "asserts": ["assert shuffle_string(\"reoc\", [2, 0, 1, 3]) == \"eorc\"", "assert shuffle_string(\"aiohn\", [3,1,4,2,0]) == \"nihao\"", "assert shuffle_string(\"aax\", [0,2,1]) == \"axa\"", "assert shuffle_string(\"gh\", [1,0]) == \"hg\"", "assert shuffle_string(\"\", []) == \"\"  # Edge case: empty string", "assert shuffle_string(\"xy\", [0,1]) == \"xy\"  # No shuffle required", "assert shuffle_string(\"pqrstuvwxyzabcdefghijklmno\", list(range(25, -1, -1))) == \"onmlkjihgfedcbazyxwvutsrqp\"  # Reverse shuffle"]}], "category": "String", "prompt_tokens": 1265, "total_tokens": 1603, "completion_tokens": 338, "completion": "Write a function that takes a string as input and returns the string with all vowels (both uppercase and lowercase) removed.\n\n###Code: \n\ndef remove_vowels(s: str) -> str:\n    vowels = frozenset(\"aeiouAEIOU\")\n    return ''.join(filter(lambda x: x not in vowels, s))\n\n###Testcases: \n\nassert remove_vowels(\"Hello World!\") == \"Hll Wrld!\"\nassert remove_vowels(\"AEIOUaeiou\") == \"\"\nassert remove_vowels(\"abcdefghijklmnopqrstuvwxyz\") == \"bcdfghjklmnpqrstvwxyz\"\nassert remove_vowels(\"I love Python!\") == \" lv Pythn!\"\nassert remove_vowels(\"\") == \"\"  # Edge case: empty string\nassert remove_vowels(\"BCDFG\") == \"BCDFG\"  # String with no vowels\nassert remove_vowels(\"aEIoU\") == \"\"  # String with only vowels of mixed case\nassert remove_vowels(\"Quick Brown Fox Jumps Over The Lazy Dog\") == \"Qck Brwn Fx Jmps vr Th Lzy Dg\"\nassert remove_vowels(\"AEIOU\") == \"\"  # Uppercase vowels only\nassert remove_vowels(\"Python Programming\") == \"Pythn Prgrmmng\"  # String with spaces and consonants\nassert remove_vowels(\"12345!\") == \"12345!\"  # Non-alphabetic characters should not be affected\nassert remove_vowels(\"fly\") == \"fly\"  # String with no vowels but 'y'\n\n[/Example 3]", "temperature": 0.919}, {"few_shots": [{"author": "Calvin", "UUID": "d0ce7430-cfcd-4c69-b161-b3b2a186422c", "question": "Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.\n\nIn other words, return true if one of s1's permutations is the substring of s2.", "examples": "Input: s1 = \"ab\", s2 = \"eidbaooo\"\nOutput: True\n\nInput: s1 = \"ab\", s2 = \"eidboaoo\"\nOutput: False", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef permutation_in_string(s1: str, s2: str) -> bool:\n  window = len(s1)\n  if window > len(s2):\n    return False\n  freq1 = [0]*26\n  freq2 = [0]*26\n  for i in range(window):\n    freq1[ord(s1[i])-ord('a')] += 1\n    freq2[ord(s2[i])-ord('a')] += 1\n\n  matches = 0\n  for i in range(26):\n    if freq1[i] == freq2[i]:\n      matches += 1\n  \n  for l in range(len(s2) - window):\n    if matches == 26:\n      return True\n\n    added = ord(s2[l + window]) - ord('a')\n    freq2[added] += 1\n    if freq1[added] == freq2[added]:\n      matches += 1\n    elif freq1[added] + 1 == freq2[added]:\n      matches -= 1\n\n    removed = ord(s2[l]) - ord('a')\n    freq2[removed] -= 1\n    if freq1[removed] == freq2[removed]:\n      matches += 1\n    elif freq1[removed] == freq2[removed] + 1:\n      matches -= 1\n    \n  return matches == 26\n", "asserts": ["assert permutation_in_string(\"hello\", \"ooollehhhhh\") == True", "assert permutation_in_string(\"abc\", \"ccccbbbbaaaa\") == False", "assert permutation_in_string(\"xyz\", \"zxyopqrstuv\") == True", "assert permutation_in_string(\"xyz\", \"xzygxzyzxyzk\") == True", "assert permutation_in_string(\"a\", \"a\") == True", "assert permutation_in_string(\"adc\", \"dcda\") == True", "assert permutation_in_string(\"pq\", \"qpqqp\") == True", "assert permutation_in_string(\"kitten\", \"sittingkite\") == False", "assert permutation_in_string(\"pq\", \"pqpqr\") == True", "assert permutation_in_string(\"aba\", \"aabaabaa\") == True", "assert permutation_in_string(\"\", \"\") == True  # Edge case: both strings are empty", "assert permutation_in_string(\"longerstring\", \"short\") == False  # s1 is longer than s2", "assert permutation_in_string(\"a\", \"b\") == False  # Single character, no match", "assert permutation_in_string(\"aab\", \"baa\") == True  # s1 is a permutation of s2", "assert permutation_in_string(\"ab\", \"a\") == False  # s2 is shorter than s1", "assert permutation_in_string(\"ba\", \"eidbaooo\") == True  # Same characters as Example 1 but different permutation", "assert permutation_in_string(\"eid\", \"eidbaooo\") == True  # s1 is a prefix of s2", "assert permutation_in_string(\"ooo\", \"eidbaooo\") == True  # s1 is a suffix of s2", "assert permutation_in_string(\"db\", \"eidbaooo\") == True  # s1 is a permutation within s2", "assert permutation_in_string(\"eidoo\", \"eidbaooo\") == False  # s1 is longer than any permutation within s2"]}, {"author": "Calvin", "UUID": "87372a22-f5ef-4100-845b-28700ca3fde3", "question": "You are given a string s and an integer array indices of the same length. The string s will be shuffled such that the character at the ith position moves to indices[i] in the shuffled string.\n\nReturn the shuffled string.", "examples": "Input: s = \"codeleet\", indices = [4,5,6,7,0,2,1,3]\nOutput: \"leetcode\"\n\nInput: s = \"abc\", indices = [0,1,2]\nOutput: \"abc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "from typing import List\ndef shuffle_string(s: str, indices: List[int]) -> str:\n    def partitionString(s):\n      substrings = 1\n      cur_str = set()\n      for i in range(len(s)):\n        if s[i] in cur_str:\n          substrings += 1\n          cur_str = {s[i]}\n        else:\n          cur_str.add(s[i])\n      return substrings\n    ret = ['_']*len(s)\n    for idx, i in enumerate(indices):\n        ret[i] = s[idx]\n    return \"\".join(ret)\n", "asserts": ["assert shuffle_string(\"reoc\", [2, 0, 1, 3]) == \"eorc\"", "assert shuffle_string(\"aiohn\", [3,1,4,2,0]) == \"nihao\"", "assert shuffle_string(\"aax\", [0,2,1]) == \"axa\"", "assert shuffle_string(\"gh\", [1,0]) == \"hg\"", "assert shuffle_string(\"\", []) == \"\"  # Edge case: empty string", "assert shuffle_string(\"xy\", [0,1]) == \"xy\"  # No shuffle required", "assert shuffle_string(\"pqrstuvwxyzabcdefghijklmno\", list(range(25, -1, -1))) == \"onmlkjihgfedcbazyxwvutsrqp\"  # Reverse shuffle"]}], "category": "String", "prompt_tokens": 1265, "total_tokens": 1667, "completion_tokens": 402, "completion": "Write a function to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string \"\".\n\n###Code: \n\nfrom typing import List\n\ndef longest_common_prefix(strs: List[str]) -> str:\n    if not strs:\n        return \"\"\n    \n    shortest = min(strs, key=len)\n    for i, char in enumerate(shortest):\n        for other in strs:\n            if other[i] != char:\n                return shortest[:i]\n    return shortest\n\n###Testcases: \n\nassert longest_common_prefix([\"flower\",\"flow\",\"flight\"]) == \"fl\"\nassert longest_common_prefix([\"dog\",\"racecar\",\"car\"]) == \"\"\nassert longest_common_prefix([\"interspecies\",\"interstellar\",\"interstate\"]) == \"inters\"\nassert longest_common_prefix([\"throne\",\"throne\"]) == \"throne\"\nassert longest_common_prefix([\"prefix\",\"prefix\"]) == \"prefix\"\nassert longest_common_prefix([\"\",\"\"]) == \"\"  # Edge case: All strings are empty\nassert longest_common_prefix([\"a\"]) == \"a\"  # Edge case: Single string in array\nassert longest_common_prefix([\"abc\", \"abc\", \"abc\"]) == \"abc\"  # All strings are the same\nassert longest_common_prefix([\"abcd\", \"abce\", \"abcf\"]) == \"abc\"  # Common prefix at the beginning\nassert longest_common_prefix([\"\", \"b\"]) == \"\"  # One of the strings is empty\nassert longest_common_prefix([\"a\", \"b\", \"c\"]) == \"\"  # No common prefix\nassert longest_common_prefix([\"ab\", \"a\"]) == \"a\"  # Entire string is a prefix\nassert longest_common_prefix([\"prefix\", \"suffix\", \"affix\"]) == \"\"  # No common prefix\nassert longest_common_prefix([\"longestcommonprefix\", \"longestcommontable\", \"longestcommonspace\"]) == \"longestcommon\"  # Long common prefix\n\n[/Example 3]", "temperature": 0.73}, {"few_shots": [{"author": "Calvin", "UUID": "d0ce7430-cfcd-4c69-b161-b3b2a186422c", "question": "Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.\n\nIn other words, return true if one of s1's permutations is the substring of s2.", "examples": "Input: s1 = \"ab\", s2 = \"eidbaooo\"\nOutput: True\n\nInput: s1 = \"ab\", s2 = \"eidboaoo\"\nOutput: False", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef permutation_in_string(s1: str, s2: str) -> bool:\n  window = len(s1)\n  if window > len(s2):\n    return False\n  freq1 = [0]*26\n  freq2 = [0]*26\n  for i in range(window):\n    freq1[ord(s1[i])-ord('a')] += 1\n    freq2[ord(s2[i])-ord('a')] += 1\n\n  matches = 0\n  for i in range(26):\n    if freq1[i] == freq2[i]:\n      matches += 1\n  \n  for l in range(len(s2) - window):\n    if matches == 26:\n      return True\n\n    added = ord(s2[l + window]) - ord('a')\n    freq2[added] += 1\n    if freq1[added] == freq2[added]:\n      matches += 1\n    elif freq1[added] + 1 == freq2[added]:\n      matches -= 1\n\n    removed = ord(s2[l]) - ord('a')\n    freq2[removed] -= 1\n    if freq1[removed] == freq2[removed]:\n      matches += 1\n    elif freq1[removed] == freq2[removed] + 1:\n      matches -= 1\n    \n  return matches == 26\n", "asserts": ["assert permutation_in_string(\"hello\", \"ooollehhhhh\") == True", "assert permutation_in_string(\"abc\", \"ccccbbbbaaaa\") == False", "assert permutation_in_string(\"xyz\", \"zxyopqrstuv\") == True", "assert permutation_in_string(\"xyz\", \"xzygxzyzxyzk\") == True", "assert permutation_in_string(\"a\", \"a\") == True", "assert permutation_in_string(\"adc\", \"dcda\") == True", "assert permutation_in_string(\"pq\", \"qpqqp\") == True", "assert permutation_in_string(\"kitten\", \"sittingkite\") == False", "assert permutation_in_string(\"pq\", \"pqpqr\") == True", "assert permutation_in_string(\"aba\", \"aabaabaa\") == True", "assert permutation_in_string(\"\", \"\") == True  # Edge case: both strings are empty", "assert permutation_in_string(\"longerstring\", \"short\") == False  # s1 is longer than s2", "assert permutation_in_string(\"a\", \"b\") == False  # Single character, no match", "assert permutation_in_string(\"aab\", \"baa\") == True  # s1 is a permutation of s2", "assert permutation_in_string(\"ab\", \"a\") == False  # s2 is shorter than s1", "assert permutation_in_string(\"ba\", \"eidbaooo\") == True  # Same characters as Example 1 but different permutation", "assert permutation_in_string(\"eid\", \"eidbaooo\") == True  # s1 is a prefix of s2", "assert permutation_in_string(\"ooo\", \"eidbaooo\") == True  # s1 is a suffix of s2", "assert permutation_in_string(\"db\", \"eidbaooo\") == True  # s1 is a permutation within s2", "assert permutation_in_string(\"eidoo\", \"eidbaooo\") == False  # s1 is longer than any permutation within s2"]}, {"author": "Calvin", "UUID": "87372a22-f5ef-4100-845b-28700ca3fde3", "question": "You are given a string s and an integer array indices of the same length. The string s will be shuffled such that the character at the ith position moves to indices[i] in the shuffled string.\n\nReturn the shuffled string.", "examples": "Input: s = \"codeleet\", indices = [4,5,6,7,0,2,1,3]\nOutput: \"leetcode\"\n\nInput: s = \"abc\", indices = [0,1,2]\nOutput: \"abc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "from typing import List\ndef shuffle_string(s: str, indices: List[int]) -> str:\n    def partitionString(s):\n      substrings = 1\n      cur_str = set()\n      for i in range(len(s)):\n        if s[i] in cur_str:\n          substrings += 1\n          cur_str = {s[i]}\n        else:\n          cur_str.add(s[i])\n      return substrings\n    ret = ['_']*len(s)\n    for idx, i in enumerate(indices):\n        ret[i] = s[idx]\n    return \"\".join(ret)\n", "asserts": ["assert shuffle_string(\"reoc\", [2, 0, 1, 3]) == \"eorc\"", "assert shuffle_string(\"aiohn\", [3,1,4,2,0]) == \"nihao\"", "assert shuffle_string(\"aax\", [0,2,1]) == \"axa\"", "assert shuffle_string(\"gh\", [1,0]) == \"hg\"", "assert shuffle_string(\"\", []) == \"\"  # Edge case: empty string", "assert shuffle_string(\"xy\", [0,1]) == \"xy\"  # No shuffle required", "assert shuffle_string(\"pqrstuvwxyzabcdefghijklmno\", list(range(25, -1, -1))) == \"onmlkjihgfedcbazyxwvutsrqp\"  # Reverse shuffle"]}], "category": "String", "prompt_tokens": 1265, "total_tokens": 1684, "completion_tokens": 419, "completion": "Write a function that takes a string s and returns the longest palindrome that can be constructed by rearranging the letters of s. If there are multiple solutions, return the lexicographically smallest one.\n\n###Code: \n\nfrom collections import Counter\n\ndef longest_palindrome(s: str) -> str:\n    count = Counter(s)\n    mid = \"\"\n    halves = []\n    for char in sorted(count):\n        pair_count = count[char] // 2 * 2\n        halves.append(char * (pair_count // 2))\n        count[char] -= pair_count\n        if count[char] and not mid:\n            mid = char\n    half = ''.join(halves)\n    return half + mid + half[::-1]\n\n###Testcases: \n\nassert longest_palindrome(\"aabbcc\") == \"abcba\"\nassert longest_palindrome(\"a\") == \"a\"\nassert longest_palindrome(\"aaabbbc\") == \"abcba\"\nassert longest_palindrome(\"gggaaaa\") == \"aga\"\nassert longest_palindrome(\"abc\") == \"a\"  # Only single letters can be used\nassert longest_palindrome(\"aaa\") == \"aaa\"  # Already a palindrome\nassert longest_palindrome(\"aaabb\") == \"ababa\"\nassert longest_palindrome(\"bbaa\") == \"abba\"\nassert longest_palindrome(\"bananas\") == \"anana\"\nassert longest_palindrome(\"\") == \"\"  # Edge case: empty string\nassert longest_palindrome(\"xyyxz\") == \"xyzyx\"  # Lexicographically smallest palindrome\nassert longest_palindrome(\"carerac\") == \"acerca\"  # Multiple palindromes possible, return lexicographically smallest\nassert longest_palindrome(\"noon\") == \"noon\"  # Even length palindrome\nassert longest_palindrome(\"civil\") == \"c\"  # No palindrome longer than 1 character possible\nassert longest_palindrome(\"ivicc\") == \"civic\"  # One of the palindromes that can be constructed\n\n[/Example 3]", "temperature": 0.807}, {"few_shots": [{"author": "Calvin", "UUID": "d0ce7430-cfcd-4c69-b161-b3b2a186422c", "question": "Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.\n\nIn other words, return true if one of s1's permutations is the substring of s2.", "examples": "Input: s1 = \"ab\", s2 = \"eidbaooo\"\nOutput: True\n\nInput: s1 = \"ab\", s2 = \"eidboaoo\"\nOutput: False", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef permutation_in_string(s1: str, s2: str) -> bool:\n  window = len(s1)\n  if window > len(s2):\n    return False\n  freq1 = [0]*26\n  freq2 = [0]*26\n  for i in range(window):\n    freq1[ord(s1[i])-ord('a')] += 1\n    freq2[ord(s2[i])-ord('a')] += 1\n\n  matches = 0\n  for i in range(26):\n    if freq1[i] == freq2[i]:\n      matches += 1\n  \n  for l in range(len(s2) - window):\n    if matches == 26:\n      return True\n\n    added = ord(s2[l + window]) - ord('a')\n    freq2[added] += 1\n    if freq1[added] == freq2[added]:\n      matches += 1\n    elif freq1[added] + 1 == freq2[added]:\n      matches -= 1\n\n    removed = ord(s2[l]) - ord('a')\n    freq2[removed] -= 1\n    if freq1[removed] == freq2[removed]:\n      matches += 1\n    elif freq1[removed] == freq2[removed] + 1:\n      matches -= 1\n    \n  return matches == 26\n", "asserts": ["assert permutation_in_string(\"hello\", \"ooollehhhhh\") == True", "assert permutation_in_string(\"abc\", \"ccccbbbbaaaa\") == False", "assert permutation_in_string(\"xyz\", \"zxyopqrstuv\") == True", "assert permutation_in_string(\"xyz\", \"xzygxzyzxyzk\") == True", "assert permutation_in_string(\"a\", \"a\") == True", "assert permutation_in_string(\"adc\", \"dcda\") == True", "assert permutation_in_string(\"pq\", \"qpqqp\") == True", "assert permutation_in_string(\"kitten\", \"sittingkite\") == False", "assert permutation_in_string(\"pq\", \"pqpqr\") == True", "assert permutation_in_string(\"aba\", \"aabaabaa\") == True", "assert permutation_in_string(\"\", \"\") == True  # Edge case: both strings are empty", "assert permutation_in_string(\"longerstring\", \"short\") == False  # s1 is longer than s2", "assert permutation_in_string(\"a\", \"b\") == False  # Single character, no match", "assert permutation_in_string(\"aab\", \"baa\") == True  # s1 is a permutation of s2", "assert permutation_in_string(\"ab\", \"a\") == False  # s2 is shorter than s1", "assert permutation_in_string(\"ba\", \"eidbaooo\") == True  # Same characters as Example 1 but different permutation", "assert permutation_in_string(\"eid\", \"eidbaooo\") == True  # s1 is a prefix of s2", "assert permutation_in_string(\"ooo\", \"eidbaooo\") == True  # s1 is a suffix of s2", "assert permutation_in_string(\"db\", \"eidbaooo\") == True  # s1 is a permutation within s2", "assert permutation_in_string(\"eidoo\", \"eidbaooo\") == False  # s1 is longer than any permutation within s2"]}, {"author": "Calvin", "UUID": "87372a22-f5ef-4100-845b-28700ca3fde3", "question": "You are given a string s and an integer array indices of the same length. The string s will be shuffled such that the character at the ith position moves to indices[i] in the shuffled string.\n\nReturn the shuffled string.", "examples": "Input: s = \"codeleet\", indices = [4,5,6,7,0,2,1,3]\nOutput: \"leetcode\"\n\nInput: s = \"abc\", indices = [0,1,2]\nOutput: \"abc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "from typing import List\ndef shuffle_string(s: str, indices: List[int]) -> str:\n    def partitionString(s):\n      substrings = 1\n      cur_str = set()\n      for i in range(len(s)):\n        if s[i] in cur_str:\n          substrings += 1\n          cur_str = {s[i]}\n        else:\n          cur_str.add(s[i])\n      return substrings\n    ret = ['_']*len(s)\n    for idx, i in enumerate(indices):\n        ret[i] = s[idx]\n    return \"\".join(ret)\n", "asserts": ["assert shuffle_string(\"reoc\", [2, 0, 1, 3]) == \"eorc\"", "assert shuffle_string(\"aiohn\", [3,1,4,2,0]) == \"nihao\"", "assert shuffle_string(\"aax\", [0,2,1]) == \"axa\"", "assert shuffle_string(\"gh\", [1,0]) == \"hg\"", "assert shuffle_string(\"\", []) == \"\"  # Edge case: empty string", "assert shuffle_string(\"xy\", [0,1]) == \"xy\"  # No shuffle required", "assert shuffle_string(\"pqrstuvwxyzabcdefghijklmno\", list(range(25, -1, -1))) == \"onmlkjihgfedcbazyxwvutsrqp\"  # Reverse shuffle"]}], "category": "String", "prompt_tokens": 1265, "total_tokens": 1621, "completion_tokens": 356, "completion": "Write a function to find the first non-repeating character in a given string and return its index. If it doesn't exist, return -1.\n\n###Code:\n\ndef first_uniq_char(s: str) -> int:\n    char_count = dict()\n    # Count the characters in the string\n    for ch in s:\n        char_count[ch] = char_count.get(ch, 0) + 1\n\n    # Find the index of the first unique character\n    for idx, ch in enumerate(s):\n        if char_count[ch] == 1:\n            return idx\n\n    return -1  # If no unique character found\n\n###Testcases:\n\nassert first_uniq_char(\"leetcode\") == 0\nassert first_uniq_char(\"loveleetcode\") == 2\nassert first_uniq_char(\"aabb\") == -1\nassert first_uniq_char(\"aabbc\") == 4\nassert first_uniq_char(\"z\") == 0\nassert first_uniq_char(\"aadadaad\") == -1\nassert first_uniq_char(\"aabbdbc\") == 6\nassert first_uniq_char(\"\") == -1  # Edge case: empty string\nassert first_uniq_char(\"zzz\") == -1  # No unique character\nassert first_uniq_char(\"abcabd\") == 4  # Multiple repeating characters\nassert first_uniq_char(\"aabbccddeeffg\") == 12  # Single non-repeating character at the end\nassert first_uniq_char(\"xxyz\") == 3  # Single non-repeating character\nassert first_uniq_char(\"dbcaabcd\") == 7  # Non-repeating character after a set of repeating characters\n\n[/Example 3]", "temperature": 0.855}, {"few_shots": [{"author": "Calvin", "UUID": "d0ce7430-cfcd-4c69-b161-b3b2a186422c", "question": "Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.\n\nIn other words, return true if one of s1's permutations is the substring of s2.", "examples": "Input: s1 = \"ab\", s2 = \"eidbaooo\"\nOutput: True\n\nInput: s1 = \"ab\", s2 = \"eidboaoo\"\nOutput: False", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef permutation_in_string(s1: str, s2: str) -> bool:\n  window = len(s1)\n  if window > len(s2):\n    return False\n  freq1 = [0]*26\n  freq2 = [0]*26\n  for i in range(window):\n    freq1[ord(s1[i])-ord('a')] += 1\n    freq2[ord(s2[i])-ord('a')] += 1\n\n  matches = 0\n  for i in range(26):\n    if freq1[i] == freq2[i]:\n      matches += 1\n  \n  for l in range(len(s2) - window):\n    if matches == 26:\n      return True\n\n    added = ord(s2[l + window]) - ord('a')\n    freq2[added] += 1\n    if freq1[added] == freq2[added]:\n      matches += 1\n    elif freq1[added] + 1 == freq2[added]:\n      matches -= 1\n\n    removed = ord(s2[l]) - ord('a')\n    freq2[removed] -= 1\n    if freq1[removed] == freq2[removed]:\n      matches += 1\n    elif freq1[removed] == freq2[removed] + 1:\n      matches -= 1\n    \n  return matches == 26\n", "asserts": ["assert permutation_in_string(\"hello\", \"ooollehhhhh\") == True", "assert permutation_in_string(\"abc\", \"ccccbbbbaaaa\") == False", "assert permutation_in_string(\"xyz\", \"zxyopqrstuv\") == True", "assert permutation_in_string(\"xyz\", \"xzygxzyzxyzk\") == True", "assert permutation_in_string(\"a\", \"a\") == True", "assert permutation_in_string(\"adc\", \"dcda\") == True", "assert permutation_in_string(\"pq\", \"qpqqp\") == True", "assert permutation_in_string(\"kitten\", \"sittingkite\") == False", "assert permutation_in_string(\"pq\", \"pqpqr\") == True", "assert permutation_in_string(\"aba\", \"aabaabaa\") == True", "assert permutation_in_string(\"\", \"\") == True  # Edge case: both strings are empty", "assert permutation_in_string(\"longerstring\", \"short\") == False  # s1 is longer than s2", "assert permutation_in_string(\"a\", \"b\") == False  # Single character, no match", "assert permutation_in_string(\"aab\", \"baa\") == True  # s1 is a permutation of s2", "assert permutation_in_string(\"ab\", \"a\") == False  # s2 is shorter than s1", "assert permutation_in_string(\"ba\", \"eidbaooo\") == True  # Same characters as Example 1 but different permutation", "assert permutation_in_string(\"eid\", \"eidbaooo\") == True  # s1 is a prefix of s2", "assert permutation_in_string(\"ooo\", \"eidbaooo\") == True  # s1 is a suffix of s2", "assert permutation_in_string(\"db\", \"eidbaooo\") == True  # s1 is a permutation within s2", "assert permutation_in_string(\"eidoo\", \"eidbaooo\") == False  # s1 is longer than any permutation within s2"]}, {"author": "Calvin", "UUID": "56b48f6d-0d81-478d-b838-4d47b62d3031", "question": "Given an integer n, return the number of strings of length n that consist only of vowels (a, e, i, o, u) and are lexicographically sorted.\n\nA string s is lexicographically sorted if for all valid i, s[i] is the same as or comes before s[i+1] in the alphabet.", "examples": "Input: 1\nOutput: 5\n\nInput: 2\nOutput: 15", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def helper(n, letter_idx):\n  letters = [\"a\",\"e\",\"i\",\"o\",\"u\"]\n  dynamic = {\n      'a1' : 5,\n      'e1' : 4,\n      'i1' : 3,\n      'o1' : 2,\n      'u1' : 1\n  }\n  ret = 0\n  key = letters[letter_idx] + str(n)\n  if key in dynamic.keys():\n    return dynamic[key]\n  else:\n    for i in range(letter_idx, len(letters)):\n      ret += helper(n-1, i)\n    dynamic[key] = ret\n  return ret\n  \n\ndef countVowelStrings(n: int) -> int:\n  return helper(n, 0)\n", "asserts": ["assert countVowelStrings(3) == 35", "assert countVowelStrings(4) == 70", "assert countVowelStrings(5) == 126", "assert countVowelStrings(6) == 210", "assert countVowelStrings(7) == 330", "assert countVowelStrings(10) == 1001", "assert countVowelStrings(15) == 3876"]}], "category": "String", "prompt_tokens": 1255, "total_tokens": 1529, "completion_tokens": 274, "completion": "Given a string s, find the length of the longest substring without repeating characters.\n\n###Code:\n\ndef length_of_longest_substring(s: str) -> int:\n    char_index = {}\n    start = 0\n    max_length = 0\n    \n    for i, char in enumerate(s):\n        if char in char_index and start <= char_index[char]:\n            start = char_index[char] + 1\n        else:\n            max_length = max(max_length, i - start + 1)\n\n        char_index[char] = i\n\n    return max_length\n\n###Testcases:\n\nassert length_of_longest_substring(\"abcabcbb\") == 3\nassert length_of_longest_substring(\"bbbbb\") == 1\nassert length_of_longest_substring(\"pwwkew\") == 3\nassert length_of_longest_substring(\"\") == 0\nassert length_of_longest_substring(\" \") == 1\nassert length_of_longest_substring(\"au\") == 2\nassert length_of_longest_substring(\"dvdf\") == 3\nassert length_of_longest_substring(\"anviaj\") == 5\nassert length_of_longest_substring(\"abba\") == 2\nassert length_of_longest_substring(\"tmmzuxt\") == 5\n\n[/Example 3]", "temperature": 0.92}, {"few_shots": [{"author": "Calvin", "UUID": "d0ce7430-cfcd-4c69-b161-b3b2a186422c", "question": "Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.\n\nIn other words, return true if one of s1's permutations is the substring of s2.", "examples": "Input: s1 = \"ab\", s2 = \"eidbaooo\"\nOutput: True\n\nInput: s1 = \"ab\", s2 = \"eidboaoo\"\nOutput: False", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef permutation_in_string(s1: str, s2: str) -> bool:\n  window = len(s1)\n  if window > len(s2):\n    return False\n  freq1 = [0]*26\n  freq2 = [0]*26\n  for i in range(window):\n    freq1[ord(s1[i])-ord('a')] += 1\n    freq2[ord(s2[i])-ord('a')] += 1\n\n  matches = 0\n  for i in range(26):\n    if freq1[i] == freq2[i]:\n      matches += 1\n  \n  for l in range(len(s2) - window):\n    if matches == 26:\n      return True\n\n    added = ord(s2[l + window]) - ord('a')\n    freq2[added] += 1\n    if freq1[added] == freq2[added]:\n      matches += 1\n    elif freq1[added] + 1 == freq2[added]:\n      matches -= 1\n\n    removed = ord(s2[l]) - ord('a')\n    freq2[removed] -= 1\n    if freq1[removed] == freq2[removed]:\n      matches += 1\n    elif freq1[removed] == freq2[removed] + 1:\n      matches -= 1\n    \n  return matches == 26\n", "asserts": ["assert permutation_in_string(\"hello\", \"ooollehhhhh\") == True", "assert permutation_in_string(\"abc\", \"ccccbbbbaaaa\") == False", "assert permutation_in_string(\"xyz\", \"zxyopqrstuv\") == True", "assert permutation_in_string(\"xyz\", \"xzygxzyzxyzk\") == True", "assert permutation_in_string(\"a\", \"a\") == True", "assert permutation_in_string(\"adc\", \"dcda\") == True", "assert permutation_in_string(\"pq\", \"qpqqp\") == True", "assert permutation_in_string(\"kitten\", \"sittingkite\") == False", "assert permutation_in_string(\"pq\", \"pqpqr\") == True", "assert permutation_in_string(\"aba\", \"aabaabaa\") == True", "assert permutation_in_string(\"\", \"\") == True  # Edge case: both strings are empty", "assert permutation_in_string(\"longerstring\", \"short\") == False  # s1 is longer than s2", "assert permutation_in_string(\"a\", \"b\") == False  # Single character, no match", "assert permutation_in_string(\"aab\", \"baa\") == True  # s1 is a permutation of s2", "assert permutation_in_string(\"ab\", \"a\") == False  # s2 is shorter than s1", "assert permutation_in_string(\"ba\", \"eidbaooo\") == True  # Same characters as Example 1 but different permutation", "assert permutation_in_string(\"eid\", \"eidbaooo\") == True  # s1 is a prefix of s2", "assert permutation_in_string(\"ooo\", \"eidbaooo\") == True  # s1 is a suffix of s2", "assert permutation_in_string(\"db\", \"eidbaooo\") == True  # s1 is a permutation within s2", "assert permutation_in_string(\"eidoo\", \"eidbaooo\") == False  # s1 is longer than any permutation within s2"]}, {"author": "Calvin", "UUID": "56b48f6d-0d81-478d-b838-4d47b62d3031", "question": "Given an integer n, return the number of strings of length n that consist only of vowels (a, e, i, o, u) and are lexicographically sorted.\n\nA string s is lexicographically sorted if for all valid i, s[i] is the same as or comes before s[i+1] in the alphabet.", "examples": "Input: 1\nOutput: 5\n\nInput: 2\nOutput: 15", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def helper(n, letter_idx):\n  letters = [\"a\",\"e\",\"i\",\"o\",\"u\"]\n  dynamic = {\n      'a1' : 5,\n      'e1' : 4,\n      'i1' : 3,\n      'o1' : 2,\n      'u1' : 1\n  }\n  ret = 0\n  key = letters[letter_idx] + str(n)\n  if key in dynamic.keys():\n    return dynamic[key]\n  else:\n    for i in range(letter_idx, len(letters)):\n      ret += helper(n-1, i)\n    dynamic[key] = ret\n  return ret\n  \n\ndef countVowelStrings(n: int) -> int:\n  return helper(n, 0)\n", "asserts": ["assert countVowelStrings(3) == 35", "assert countVowelStrings(4) == 70", "assert countVowelStrings(5) == 126", "assert countVowelStrings(6) == 210", "assert countVowelStrings(7) == 330", "assert countVowelStrings(10) == 1001", "assert countVowelStrings(15) == 3876"]}], "category": "String", "prompt_tokens": 1255, "total_tokens": 1564, "completion_tokens": 309, "completion": "Write a function to find the longest common prefix string amongst an array of strings.\n\nIf there is no common prefix, return an empty string \"\".\n\n###Code: \n\ndef longest_common_prefix(strs: [str]) -> str:\n    if not strs:\n        return \"\"\n\n    for i in range(len(strs[0])):\n        char = strs[0][i]\n        for string in strs[1:]:\n            if i == len(string) or string[i] != char:\n                return strs[0][:i]\n    \n    return strs[0]\n\n###Testcases: \n\nassert longest_common_prefix([\"flower\",\"flow\",\"flight\"]) == \"fl\"\nassert longest_common_prefix([\"dog\",\"racecar\",\"car\"]) == \"\"\nassert longest_common_prefix([\"interspecies\",\"interstellar\",\"interstate\"]) == \"inters\"\nassert longest_common_prefix([\"throne\",\"throne\"]) == \"throne\"\nassert longest_common_prefix([\"throne\",\"dungeon\"]) == \"\"\nassert longest_common_prefix([\"cheese\"]) == \"cheese\"\nassert longest_common_prefix([\"patch\",\"path\"]) == \"pa\"\nassert longest_common_prefix([\"\"] * 5) == \"\"\nassert longest_common_prefix([]) == \"\"\nassert longest_common_prefix([\"reflower\",\"flow\",\"flight\"]) == \"\"\nassert longest_common_prefix([\"a\"] * 200) == \"a\"\nassert longest_common_prefix([\"abab\",\"aba\",\"\"]) == \"\"\nassert longest_common_prefix([\"c\",\"c\"]) == \"c\"\nassert longest_common_prefix([\"aca\",\"cba\"]) == \"\"\n\n[/Example 3]", "temperature": 0.758}, {"few_shots": [{"author": "Calvin", "UUID": "d0ce7430-cfcd-4c69-b161-b3b2a186422c", "question": "Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.\n\nIn other words, return true if one of s1's permutations is the substring of s2.", "examples": "Input: s1 = \"ab\", s2 = \"eidbaooo\"\nOutput: True\n\nInput: s1 = \"ab\", s2 = \"eidboaoo\"\nOutput: False", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef permutation_in_string(s1: str, s2: str) -> bool:\n  window = len(s1)\n  if window > len(s2):\n    return False\n  freq1 = [0]*26\n  freq2 = [0]*26\n  for i in range(window):\n    freq1[ord(s1[i])-ord('a')] += 1\n    freq2[ord(s2[i])-ord('a')] += 1\n\n  matches = 0\n  for i in range(26):\n    if freq1[i] == freq2[i]:\n      matches += 1\n  \n  for l in range(len(s2) - window):\n    if matches == 26:\n      return True\n\n    added = ord(s2[l + window]) - ord('a')\n    freq2[added] += 1\n    if freq1[added] == freq2[added]:\n      matches += 1\n    elif freq1[added] + 1 == freq2[added]:\n      matches -= 1\n\n    removed = ord(s2[l]) - ord('a')\n    freq2[removed] -= 1\n    if freq1[removed] == freq2[removed]:\n      matches += 1\n    elif freq1[removed] == freq2[removed] + 1:\n      matches -= 1\n    \n  return matches == 26\n", "asserts": ["assert permutation_in_string(\"hello\", \"ooollehhhhh\") == True", "assert permutation_in_string(\"abc\", \"ccccbbbbaaaa\") == False", "assert permutation_in_string(\"xyz\", \"zxyopqrstuv\") == True", "assert permutation_in_string(\"xyz\", \"xzygxzyzxyzk\") == True", "assert permutation_in_string(\"a\", \"a\") == True", "assert permutation_in_string(\"adc\", \"dcda\") == True", "assert permutation_in_string(\"pq\", \"qpqqp\") == True", "assert permutation_in_string(\"kitten\", \"sittingkite\") == False", "assert permutation_in_string(\"pq\", \"pqpqr\") == True", "assert permutation_in_string(\"aba\", \"aabaabaa\") == True", "assert permutation_in_string(\"\", \"\") == True  # Edge case: both strings are empty", "assert permutation_in_string(\"longerstring\", \"short\") == False  # s1 is longer than s2", "assert permutation_in_string(\"a\", \"b\") == False  # Single character, no match", "assert permutation_in_string(\"aab\", \"baa\") == True  # s1 is a permutation of s2", "assert permutation_in_string(\"ab\", \"a\") == False  # s2 is shorter than s1", "assert permutation_in_string(\"ba\", \"eidbaooo\") == True  # Same characters as Example 1 but different permutation", "assert permutation_in_string(\"eid\", \"eidbaooo\") == True  # s1 is a prefix of s2", "assert permutation_in_string(\"ooo\", \"eidbaooo\") == True  # s1 is a suffix of s2", "assert permutation_in_string(\"db\", \"eidbaooo\") == True  # s1 is a permutation within s2", "assert permutation_in_string(\"eidoo\", \"eidbaooo\") == False  # s1 is longer than any permutation within s2"]}, {"author": "Calvin", "UUID": "56b48f6d-0d81-478d-b838-4d47b62d3031", "question": "Given an integer n, return the number of strings of length n that consist only of vowels (a, e, i, o, u) and are lexicographically sorted.\n\nA string s is lexicographically sorted if for all valid i, s[i] is the same as or comes before s[i+1] in the alphabet.", "examples": "Input: 1\nOutput: 5\n\nInput: 2\nOutput: 15", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def helper(n, letter_idx):\n  letters = [\"a\",\"e\",\"i\",\"o\",\"u\"]\n  dynamic = {\n      'a1' : 5,\n      'e1' : 4,\n      'i1' : 3,\n      'o1' : 2,\n      'u1' : 1\n  }\n  ret = 0\n  key = letters[letter_idx] + str(n)\n  if key in dynamic.keys():\n    return dynamic[key]\n  else:\n    for i in range(letter_idx, len(letters)):\n      ret += helper(n-1, i)\n    dynamic[key] = ret\n  return ret\n  \n\ndef countVowelStrings(n: int) -> int:\n  return helper(n, 0)\n", "asserts": ["assert countVowelStrings(3) == 35", "assert countVowelStrings(4) == 70", "assert countVowelStrings(5) == 126", "assert countVowelStrings(6) == 210", "assert countVowelStrings(7) == 330", "assert countVowelStrings(10) == 1001", "assert countVowelStrings(15) == 3876"]}], "category": "String", "prompt_tokens": 1255, "total_tokens": 1517, "completion_tokens": 262, "completion": "Write a function that takes a string `s` and returns the first non-repeating character in it and returns its index. If it does not exist, return -1.\n\n###Code:\n\ndef first_uniq_char(s: str) -> int:\n    char_count = {}\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n\n    for index, char in enumerate(s):\n        if char_count[char] == 1:\n            return index\n    return -1\n\n###Testcases:\n\nassert first_uniq_char(\"leetcode\") == 0\nassert first_uniq_char(\"loveleetcode\") == 2\nassert first_uniq_char(\"aabb\") == -1\nassert first_uniq_char(\"a\") == 0\nassert first_uniq_char(\"aadadaad\") == -1\nassert first_uniq_char(\"z\") == 0\nassert first_uniq_char(\"\") == -1  # Edge case: empty string\nassert first_uniq_char(\"aabccbad\") == 6\nassert first_uniq_char(\"abcabcabc\") == -1\nassert first_uniq_char(\"xyzxzyt\") == 6 \n\n[/Example 3]", "temperature": 0.936}, {"few_shots": [{"author": "Calvin", "UUID": "d0ce7430-cfcd-4c69-b161-b3b2a186422c", "question": "Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.\n\nIn other words, return true if one of s1's permutations is the substring of s2.", "examples": "Input: s1 = \"ab\", s2 = \"eidbaooo\"\nOutput: True\n\nInput: s1 = \"ab\", s2 = \"eidboaoo\"\nOutput: False", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef permutation_in_string(s1: str, s2: str) -> bool:\n  window = len(s1)\n  if window > len(s2):\n    return False\n  freq1 = [0]*26\n  freq2 = [0]*26\n  for i in range(window):\n    freq1[ord(s1[i])-ord('a')] += 1\n    freq2[ord(s2[i])-ord('a')] += 1\n\n  matches = 0\n  for i in range(26):\n    if freq1[i] == freq2[i]:\n      matches += 1\n  \n  for l in range(len(s2) - window):\n    if matches == 26:\n      return True\n\n    added = ord(s2[l + window]) - ord('a')\n    freq2[added] += 1\n    if freq1[added] == freq2[added]:\n      matches += 1\n    elif freq1[added] + 1 == freq2[added]:\n      matches -= 1\n\n    removed = ord(s2[l]) - ord('a')\n    freq2[removed] -= 1\n    if freq1[removed] == freq2[removed]:\n      matches += 1\n    elif freq1[removed] == freq2[removed] + 1:\n      matches -= 1\n    \n  return matches == 26\n", "asserts": ["assert permutation_in_string(\"hello\", \"ooollehhhhh\") == True", "assert permutation_in_string(\"abc\", \"ccccbbbbaaaa\") == False", "assert permutation_in_string(\"xyz\", \"zxyopqrstuv\") == True", "assert permutation_in_string(\"xyz\", \"xzygxzyzxyzk\") == True", "assert permutation_in_string(\"a\", \"a\") == True", "assert permutation_in_string(\"adc\", \"dcda\") == True", "assert permutation_in_string(\"pq\", \"qpqqp\") == True", "assert permutation_in_string(\"kitten\", \"sittingkite\") == False", "assert permutation_in_string(\"pq\", \"pqpqr\") == True", "assert permutation_in_string(\"aba\", \"aabaabaa\") == True", "assert permutation_in_string(\"\", \"\") == True  # Edge case: both strings are empty", "assert permutation_in_string(\"longerstring\", \"short\") == False  # s1 is longer than s2", "assert permutation_in_string(\"a\", \"b\") == False  # Single character, no match", "assert permutation_in_string(\"aab\", \"baa\") == True  # s1 is a permutation of s2", "assert permutation_in_string(\"ab\", \"a\") == False  # s2 is shorter than s1", "assert permutation_in_string(\"ba\", \"eidbaooo\") == True  # Same characters as Example 1 but different permutation", "assert permutation_in_string(\"eid\", \"eidbaooo\") == True  # s1 is a prefix of s2", "assert permutation_in_string(\"ooo\", \"eidbaooo\") == True  # s1 is a suffix of s2", "assert permutation_in_string(\"db\", \"eidbaooo\") == True  # s1 is a permutation within s2", "assert permutation_in_string(\"eidoo\", \"eidbaooo\") == False  # s1 is longer than any permutation within s2"]}, {"author": "Calvin", "UUID": "56b48f6d-0d81-478d-b838-4d47b62d3031", "question": "Given an integer n, return the number of strings of length n that consist only of vowels (a, e, i, o, u) and are lexicographically sorted.\n\nA string s is lexicographically sorted if for all valid i, s[i] is the same as or comes before s[i+1] in the alphabet.", "examples": "Input: 1\nOutput: 5\n\nInput: 2\nOutput: 15", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def helper(n, letter_idx):\n  letters = [\"a\",\"e\",\"i\",\"o\",\"u\"]\n  dynamic = {\n      'a1' : 5,\n      'e1' : 4,\n      'i1' : 3,\n      'o1' : 2,\n      'u1' : 1\n  }\n  ret = 0\n  key = letters[letter_idx] + str(n)\n  if key in dynamic.keys():\n    return dynamic[key]\n  else:\n    for i in range(letter_idx, len(letters)):\n      ret += helper(n-1, i)\n    dynamic[key] = ret\n  return ret\n  \n\ndef countVowelStrings(n: int) -> int:\n  return helper(n, 0)\n", "asserts": ["assert countVowelStrings(3) == 35", "assert countVowelStrings(4) == 70", "assert countVowelStrings(5) == 126", "assert countVowelStrings(6) == 210", "assert countVowelStrings(7) == 330", "assert countVowelStrings(10) == 1001", "assert countVowelStrings(15) == 3876"]}], "category": "String", "prompt_tokens": 1255, "total_tokens": 1644, "completion_tokens": 389, "completion": "Given a string s, find the length of the longest substring without repeating characters.\n\n###Code: \n\ndef length_of_longest_substring(s: str) -> int:\n    char_map = {}\n    left = 0\n    max_length = 0\n\n    for right in range(len(s)):\n        if s[right] in char_map:\n            left = max(left, char_map[s[right]] + 1)\n        \n        char_map[s[right]] = right\n        max_length = max(max_length, right - left + 1)\n\n    return max_length\n\n###Testcases: \n\nassert length_of_longest_substring(\"abcabcbb\") == 3  # The answer is \"abc\", with the length of 3.\nassert length_of_longest_substring(\"bbbbb\") == 1  # The answer is \"b\", with the length of 1.\nassert length_of_longest_substring(\"pwwkew\") == 3  # The answer is \"wke\", with the length of 3.\nassert length_of_longest_substring(\"\") == 0  # The answer is \"\", with the length of 0.\nassert length_of_longest_substring(\" \") == 1  # The answer is \" \", with the length of 1.\nassert length_of_longest_substring(\"dvdf\") == 3  # The answer is \"vdf\", with the length of 3.\nassert length_of_longest_substring(\"anviaj\") == 5  # The answer is \"nviaj\", with the length of 5.\nassert length_of_longest_substring(\"abba\") == 2  # The answer is \"ab\", with the length of 2.\nassert length_of_longest_substring(\"tmmzuxt\") == 5  # The answer is \"mzuxt\", with the length of 5.\n\n[/Example 3]", "temperature": 0.77}, {"few_shots": [{"author": "Calvin", "UUID": "d0ce7430-cfcd-4c69-b161-b3b2a186422c", "question": "Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.\n\nIn other words, return true if one of s1's permutations is the substring of s2.", "examples": "Input: s1 = \"ab\", s2 = \"eidbaooo\"\nOutput: True\n\nInput: s1 = \"ab\", s2 = \"eidboaoo\"\nOutput: False", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef permutation_in_string(s1: str, s2: str) -> bool:\n  window = len(s1)\n  if window > len(s2):\n    return False\n  freq1 = [0]*26\n  freq2 = [0]*26\n  for i in range(window):\n    freq1[ord(s1[i])-ord('a')] += 1\n    freq2[ord(s2[i])-ord('a')] += 1\n\n  matches = 0\n  for i in range(26):\n    if freq1[i] == freq2[i]:\n      matches += 1\n  \n  for l in range(len(s2) - window):\n    if matches == 26:\n      return True\n\n    added = ord(s2[l + window]) - ord('a')\n    freq2[added] += 1\n    if freq1[added] == freq2[added]:\n      matches += 1\n    elif freq1[added] + 1 == freq2[added]:\n      matches -= 1\n\n    removed = ord(s2[l]) - ord('a')\n    freq2[removed] -= 1\n    if freq1[removed] == freq2[removed]:\n      matches += 1\n    elif freq1[removed] == freq2[removed] + 1:\n      matches -= 1\n    \n  return matches == 26\n", "asserts": ["assert permutation_in_string(\"hello\", \"ooollehhhhh\") == True", "assert permutation_in_string(\"abc\", \"ccccbbbbaaaa\") == False", "assert permutation_in_string(\"xyz\", \"zxyopqrstuv\") == True", "assert permutation_in_string(\"xyz\", \"xzygxzyzxyzk\") == True", "assert permutation_in_string(\"a\", \"a\") == True", "assert permutation_in_string(\"adc\", \"dcda\") == True", "assert permutation_in_string(\"pq\", \"qpqqp\") == True", "assert permutation_in_string(\"kitten\", \"sittingkite\") == False", "assert permutation_in_string(\"pq\", \"pqpqr\") == True", "assert permutation_in_string(\"aba\", \"aabaabaa\") == True", "assert permutation_in_string(\"\", \"\") == True  # Edge case: both strings are empty", "assert permutation_in_string(\"longerstring\", \"short\") == False  # s1 is longer than s2", "assert permutation_in_string(\"a\", \"b\") == False  # Single character, no match", "assert permutation_in_string(\"aab\", \"baa\") == True  # s1 is a permutation of s2", "assert permutation_in_string(\"ab\", \"a\") == False  # s2 is shorter than s1", "assert permutation_in_string(\"ba\", \"eidbaooo\") == True  # Same characters as Example 1 but different permutation", "assert permutation_in_string(\"eid\", \"eidbaooo\") == True  # s1 is a prefix of s2", "assert permutation_in_string(\"ooo\", \"eidbaooo\") == True  # s1 is a suffix of s2", "assert permutation_in_string(\"db\", \"eidbaooo\") == True  # s1 is a permutation within s2", "assert permutation_in_string(\"eidoo\", \"eidbaooo\") == False  # s1 is longer than any permutation within s2"]}, {"author": "Calvin", "UUID": "56b48f6d-0d81-478d-b838-4d47b62d3031", "question": "Given an integer n, return the number of strings of length n that consist only of vowels (a, e, i, o, u) and are lexicographically sorted.\n\nA string s is lexicographically sorted if for all valid i, s[i] is the same as or comes before s[i+1] in the alphabet.", "examples": "Input: 1\nOutput: 5\n\nInput: 2\nOutput: 15", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def helper(n, letter_idx):\n  letters = [\"a\",\"e\",\"i\",\"o\",\"u\"]\n  dynamic = {\n      'a1' : 5,\n      'e1' : 4,\n      'i1' : 3,\n      'o1' : 2,\n      'u1' : 1\n  }\n  ret = 0\n  key = letters[letter_idx] + str(n)\n  if key in dynamic.keys():\n    return dynamic[key]\n  else:\n    for i in range(letter_idx, len(letters)):\n      ret += helper(n-1, i)\n    dynamic[key] = ret\n  return ret\n  \n\ndef countVowelStrings(n: int) -> int:\n  return helper(n, 0)\n", "asserts": ["assert countVowelStrings(3) == 35", "assert countVowelStrings(4) == 70", "assert countVowelStrings(5) == 126", "assert countVowelStrings(6) == 210", "assert countVowelStrings(7) == 330", "assert countVowelStrings(10) == 1001", "assert countVowelStrings(15) == 3876"]}], "category": "String", "prompt_tokens": 1255, "total_tokens": 1635, "completion_tokens": 380, "completion": "Given a string containing only lowercase English letters and the '?' character, convert all the '?' characters into lowercase letters such that the resulting string does not contain any consecutive repeating characters. You may assume it is always possible to convert the string.\n\n###Code: \n\ndef modify_string(s: str) -> str:\n    s = list(s)\n    for i in range(len(s)):\n        if s[i] == '?':\n            for c in 'abcdefghijklmnopqrstuvwxyz':\n                if (i == 0 or s[i-1] != c) and (i == len(s) - 1 or s[i+1] != c):\n                    s[i] = c\n                    break\n    return \"\".join(s)\n\n###Testcases:\n\nassert modify_string(\"?zs\") == \"azs\"\nassert modify_string(\"ubv?w\") == \"ubvaw\"\nassert modify_string(\"j?qg??b\") == \"jaqgacb\"\nassert modify_string(\"??yw?ipkj?\") == \"abywaipkja\"\nassert modify_string(\"a?a\") == \"aba\"\nassert modify_string(\"?a?\") == \"bab\"\nassert modify_string(\"??\") == \"ab\"\nassert modify_string(\"????????\") == \"abababab\"\nassert modify_string(\"a????a\") == \"ababaa\"\nassert modify_string(\"?a??a?\") == \"bababa\"\nassert modify_string(\"??a\") == \"aba\"\nassert modify_string(\"a?\") == \"ab\"\nassert modify_string(\"?\") == \"a\"  # Single '?' character\nassert modify_string(\"b?b?e\") == \"baba\"\nassert modify_string(\"????a\") == \"abaca\"\nassert modify_string(\"a???\") == \"abca\"\nassert modify_string(\"?a??ubv?w\") == \"babacubvaw\"\n\n[/Example 3]", "temperature": 0.903}, {"few_shots": [{"author": "Calvin", "UUID": "d0ce7430-cfcd-4c69-b161-b3b2a186422c", "question": "Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.\n\nIn other words, return true if one of s1's permutations is the substring of s2.", "examples": "Input: s1 = \"ab\", s2 = \"eidbaooo\"\nOutput: True\n\nInput: s1 = \"ab\", s2 = \"eidboaoo\"\nOutput: False", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef permutation_in_string(s1: str, s2: str) -> bool:\n  window = len(s1)\n  if window > len(s2):\n    return False\n  freq1 = [0]*26\n  freq2 = [0]*26\n  for i in range(window):\n    freq1[ord(s1[i])-ord('a')] += 1\n    freq2[ord(s2[i])-ord('a')] += 1\n\n  matches = 0\n  for i in range(26):\n    if freq1[i] == freq2[i]:\n      matches += 1\n  \n  for l in range(len(s2) - window):\n    if matches == 26:\n      return True\n\n    added = ord(s2[l + window]) - ord('a')\n    freq2[added] += 1\n    if freq1[added] == freq2[added]:\n      matches += 1\n    elif freq1[added] + 1 == freq2[added]:\n      matches -= 1\n\n    removed = ord(s2[l]) - ord('a')\n    freq2[removed] -= 1\n    if freq1[removed] == freq2[removed]:\n      matches += 1\n    elif freq1[removed] == freq2[removed] + 1:\n      matches -= 1\n    \n  return matches == 26\n", "asserts": ["assert permutation_in_string(\"hello\", \"ooollehhhhh\") == True", "assert permutation_in_string(\"abc\", \"ccccbbbbaaaa\") == False", "assert permutation_in_string(\"xyz\", \"zxyopqrstuv\") == True", "assert permutation_in_string(\"xyz\", \"xzygxzyzxyzk\") == True", "assert permutation_in_string(\"a\", \"a\") == True", "assert permutation_in_string(\"adc\", \"dcda\") == True", "assert permutation_in_string(\"pq\", \"qpqqp\") == True", "assert permutation_in_string(\"kitten\", \"sittingkite\") == False", "assert permutation_in_string(\"pq\", \"pqpqr\") == True", "assert permutation_in_string(\"aba\", \"aabaabaa\") == True", "assert permutation_in_string(\"\", \"\") == True  # Edge case: both strings are empty", "assert permutation_in_string(\"longerstring\", \"short\") == False  # s1 is longer than s2", "assert permutation_in_string(\"a\", \"b\") == False  # Single character, no match", "assert permutation_in_string(\"aab\", \"baa\") == True  # s1 is a permutation of s2", "assert permutation_in_string(\"ab\", \"a\") == False  # s2 is shorter than s1", "assert permutation_in_string(\"ba\", \"eidbaooo\") == True  # Same characters as Example 1 but different permutation", "assert permutation_in_string(\"eid\", \"eidbaooo\") == True  # s1 is a prefix of s2", "assert permutation_in_string(\"ooo\", \"eidbaooo\") == True  # s1 is a suffix of s2", "assert permutation_in_string(\"db\", \"eidbaooo\") == True  # s1 is a permutation within s2", "assert permutation_in_string(\"eidoo\", \"eidbaooo\") == False  # s1 is longer than any permutation within s2"]}, {"author": "Calvin", "UUID": "56b48f6d-0d81-478d-b838-4d47b62d3031", "question": "Given an integer n, return the number of strings of length n that consist only of vowels (a, e, i, o, u) and are lexicographically sorted.\n\nA string s is lexicographically sorted if for all valid i, s[i] is the same as or comes before s[i+1] in the alphabet.", "examples": "Input: 1\nOutput: 5\n\nInput: 2\nOutput: 15", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def helper(n, letter_idx):\n  letters = [\"a\",\"e\",\"i\",\"o\",\"u\"]\n  dynamic = {\n      'a1' : 5,\n      'e1' : 4,\n      'i1' : 3,\n      'o1' : 2,\n      'u1' : 1\n  }\n  ret = 0\n  key = letters[letter_idx] + str(n)\n  if key in dynamic.keys():\n    return dynamic[key]\n  else:\n    for i in range(letter_idx, len(letters)):\n      ret += helper(n-1, i)\n    dynamic[key] = ret\n  return ret\n  \n\ndef countVowelStrings(n: int) -> int:\n  return helper(n, 0)\n", "asserts": ["assert countVowelStrings(3) == 35", "assert countVowelStrings(4) == 70", "assert countVowelStrings(5) == 126", "assert countVowelStrings(6) == 210", "assert countVowelStrings(7) == 330", "assert countVowelStrings(10) == 1001", "assert countVowelStrings(15) == 3876"]}], "category": "String", "prompt_tokens": 1255, "total_tokens": 1849, "completion_tokens": 594, "completion": "Given a string s and an integer k, return the length of the longest substring of s that contains at most k distinct characters.\n\n###Code:\n\n\ndef longest_substring_k_distinct(s: str, k: int) -> int:\n    if k == 0 or not s:\n        return 0\n\n    start, max_length = 0, 0\n    char_frequency = {}\n\n    for end in range(len(s)):\n        right_char = s[end]\n        if right_char not in char_frequency:\n            char_frequency[right_char] = 0\n        char_frequency[right_char] += 1\n\n        while len(char_frequency) > k:\n            left_char = s[start]\n            char_frequency[left_char] -= 1\n            if char_frequency[left_char] == 0:\n                del char_frequency[left_char]\n            start += 1\n\n        max_length = max(max_length, end - start + 1)\n\n    return max_length\n\n###Testcases:\n\n\nassert longest_substring_k_distinct(\"araaci\", 2) == 4\nassert longest_substring_k_distinct(\"araaci\", 1) == 2\nassert longest_substring_k_distinct(\"cbbebi\", 3) == 5\nassert longest_substring_k_distinct(\"cbbebi\", 10) == 6\nassert longest_substring_k_distinct(\"aabacbebebe\", 3) == 7\nassert longest_substring_k_distinct(\"aaa\", 2) == 3\nassert longest_substring_k_distinct(\"\", 1) == 0  # Edge case: empty string\nassert longest_substring_k_distinct(\"a\", 0) == 0  # Edge case: k is 0\nassert longest_substring_k_distinct(\"abcde\", 0) == 0  # Edge case: k is 0\nassert longest_substring_k_distinct(\"abcadcacacaca\", 3) == 10\nassert longest_substring_k_distinct(\"abaccc\", 2) == 4\nassert longest_substring_k_distinct(\"aa\", 1) == 2\nassert longest_substring_k_distinct(\"ab\", 1) == 1\nassert longest_substring_k_distinct(\"eceba\", 2) == 3\nassert longest_substring_k_distinct(\"aaabbcc\", 2) == 5\nassert longest_substring_k_distinct(\"aaabbcc\", 3) == 7\nassert longest_substring_k_distinct(\"aabbcc\", 1) == 2\nassert longest_substring_k_distinct(\"aabbcc\", 4) == 6\nassert longest_substring_k_distinct(\"abacab\", 2) == 4\nassert longest_substring_k_distinct(\"bacc\", 2) == 3\n\n[/Example 3]", "temperature": 0.92}, {"few_shots": [{"author": "Calvin", "UUID": "d0ce7430-cfcd-4c69-b161-b3b2a186422c", "question": "Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.\n\nIn other words, return true if one of s1's permutations is the substring of s2.", "examples": "Input: s1 = \"ab\", s2 = \"eidbaooo\"\nOutput: True\n\nInput: s1 = \"ab\", s2 = \"eidboaoo\"\nOutput: False", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef permutation_in_string(s1: str, s2: str) -> bool:\n  window = len(s1)\n  if window > len(s2):\n    return False\n  freq1 = [0]*26\n  freq2 = [0]*26\n  for i in range(window):\n    freq1[ord(s1[i])-ord('a')] += 1\n    freq2[ord(s2[i])-ord('a')] += 1\n\n  matches = 0\n  for i in range(26):\n    if freq1[i] == freq2[i]:\n      matches += 1\n  \n  for l in range(len(s2) - window):\n    if matches == 26:\n      return True\n\n    added = ord(s2[l + window]) - ord('a')\n    freq2[added] += 1\n    if freq1[added] == freq2[added]:\n      matches += 1\n    elif freq1[added] + 1 == freq2[added]:\n      matches -= 1\n\n    removed = ord(s2[l]) - ord('a')\n    freq2[removed] -= 1\n    if freq1[removed] == freq2[removed]:\n      matches += 1\n    elif freq1[removed] == freq2[removed] + 1:\n      matches -= 1\n    \n  return matches == 26\n", "asserts": ["assert permutation_in_string(\"hello\", \"ooollehhhhh\") == True", "assert permutation_in_string(\"abc\", \"ccccbbbbaaaa\") == False", "assert permutation_in_string(\"xyz\", \"zxyopqrstuv\") == True", "assert permutation_in_string(\"xyz\", \"xzygxzyzxyzk\") == True", "assert permutation_in_string(\"a\", \"a\") == True", "assert permutation_in_string(\"adc\", \"dcda\") == True", "assert permutation_in_string(\"pq\", \"qpqqp\") == True", "assert permutation_in_string(\"kitten\", \"sittingkite\") == False", "assert permutation_in_string(\"pq\", \"pqpqr\") == True", "assert permutation_in_string(\"aba\", \"aabaabaa\") == True", "assert permutation_in_string(\"\", \"\") == True  # Edge case: both strings are empty", "assert permutation_in_string(\"longerstring\", \"short\") == False  # s1 is longer than s2", "assert permutation_in_string(\"a\", \"b\") == False  # Single character, no match", "assert permutation_in_string(\"aab\", \"baa\") == True  # s1 is a permutation of s2", "assert permutation_in_string(\"ab\", \"a\") == False  # s2 is shorter than s1", "assert permutation_in_string(\"ba\", \"eidbaooo\") == True  # Same characters as Example 1 but different permutation", "assert permutation_in_string(\"eid\", \"eidbaooo\") == True  # s1 is a prefix of s2", "assert permutation_in_string(\"ooo\", \"eidbaooo\") == True  # s1 is a suffix of s2", "assert permutation_in_string(\"db\", \"eidbaooo\") == True  # s1 is a permutation within s2", "assert permutation_in_string(\"eidoo\", \"eidbaooo\") == False  # s1 is longer than any permutation within s2"]}, {"author": "Calvin", "UUID": "56b48f6d-0d81-478d-b838-4d47b62d3031", "question": "Given an integer n, return the number of strings of length n that consist only of vowels (a, e, i, o, u) and are lexicographically sorted.\n\nA string s is lexicographically sorted if for all valid i, s[i] is the same as or comes before s[i+1] in the alphabet.", "examples": "Input: 1\nOutput: 5\n\nInput: 2\nOutput: 15", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def helper(n, letter_idx):\n  letters = [\"a\",\"e\",\"i\",\"o\",\"u\"]\n  dynamic = {\n      'a1' : 5,\n      'e1' : 4,\n      'i1' : 3,\n      'o1' : 2,\n      'u1' : 1\n  }\n  ret = 0\n  key = letters[letter_idx] + str(n)\n  if key in dynamic.keys():\n    return dynamic[key]\n  else:\n    for i in range(letter_idx, len(letters)):\n      ret += helper(n-1, i)\n    dynamic[key] = ret\n  return ret\n  \n\ndef countVowelStrings(n: int) -> int:\n  return helper(n, 0)\n", "asserts": ["assert countVowelStrings(3) == 35", "assert countVowelStrings(4) == 70", "assert countVowelStrings(5) == 126", "assert countVowelStrings(6) == 210", "assert countVowelStrings(7) == 330", "assert countVowelStrings(10) == 1001", "assert countVowelStrings(15) == 3876"]}], "category": "String", "prompt_tokens": 1255, "total_tokens": 1770, "completion_tokens": 515, "completion": "Given a string s, return the longest palindromic substring in s. A string is called a palindrome if it reads the same backward as forward.\n\n###Code:\n\ndef longest_palindromic_substring(s: str) -> str:\n    if not s or len(s) < 1:\n        return \"\"\n\n    start, end = 0, 0\n\n    def expand_around_center(left: int, right: int) -> str:\n        while left >= 0 and right < len(s) and s[left] == s[right]:\n            left -= 1\n            right += 1\n        return s[left + 1:right]  # right is non-inclusive\n\n    for i in range(len(s)):\n        len1 = expand_around_center(i, i)  # Assume odd length, try to extend Palindrome as possible\n        len2 = expand_around_center(i, i + 1)  # Assume even length.\n        longer_palindrome = len1 if len(len1) > len(len2) else len2\n        if len(longer_palindrome) > end - start:\n            start, end = i - ((len(longer_palindrome) - 1) // 2), i + (len(longer_palindrome) // 2)\n\n    return s[start:end+1]\n\n###Testcases:\n\nassert longest_palindromic_substring(\"babad\") == \"bab\" or longest_palindromic_substring(\"babad\") == \"aba\"\nassert longest_palindromic_substring(\"cbbd\") == \"bb\"\nassert longest_palindromic_substring(\"a\") == \"a\"\nassert longest_palindromic_substring(\"ac\") == \"a\" or longest_palindromic_substring(\"ac\") == \"c\"\nassert longest_palindromic_substring(\"racecar\") == \"racecar\"\nassert longest_palindromic_substring(\"banana\") == \"anana\"\nassert longest_palindromic_substring(\"forgeeksskeegfor\") == \"geeksskeeg\"\nassert longest_palindromic_substring(\"abacab\") == \"bacab\"\nassert longest_palindromic_substring(\"abacdfgdcaba\") == \"aba\"\nassert longest_palindromic_substring(\"abacdfgdcabba\") == \"abb\"\nassert longest_palindromic_substring(\"abacdedcaba\") == \"abacdedcaba\"\n\n[/Example 3]", "temperature": 0.874}, {"few_shots": [{"author": "Calvin", "UUID": "d0ce7430-cfcd-4c69-b161-b3b2a186422c", "question": "Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.\n\nIn other words, return true if one of s1's permutations is the substring of s2.", "examples": "Input: s1 = \"ab\", s2 = \"eidbaooo\"\nOutput: True\n\nInput: s1 = \"ab\", s2 = \"eidboaoo\"\nOutput: False", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef permutation_in_string(s1: str, s2: str) -> bool:\n  window = len(s1)\n  if window > len(s2):\n    return False\n  freq1 = [0]*26\n  freq2 = [0]*26\n  for i in range(window):\n    freq1[ord(s1[i])-ord('a')] += 1\n    freq2[ord(s2[i])-ord('a')] += 1\n\n  matches = 0\n  for i in range(26):\n    if freq1[i] == freq2[i]:\n      matches += 1\n  \n  for l in range(len(s2) - window):\n    if matches == 26:\n      return True\n\n    added = ord(s2[l + window]) - ord('a')\n    freq2[added] += 1\n    if freq1[added] == freq2[added]:\n      matches += 1\n    elif freq1[added] + 1 == freq2[added]:\n      matches -= 1\n\n    removed = ord(s2[l]) - ord('a')\n    freq2[removed] -= 1\n    if freq1[removed] == freq2[removed]:\n      matches += 1\n    elif freq1[removed] == freq2[removed] + 1:\n      matches -= 1\n    \n  return matches == 26\n", "asserts": ["assert permutation_in_string(\"hello\", \"ooollehhhhh\") == True", "assert permutation_in_string(\"abc\", \"ccccbbbbaaaa\") == False", "assert permutation_in_string(\"xyz\", \"zxyopqrstuv\") == True", "assert permutation_in_string(\"xyz\", \"xzygxzyzxyzk\") == True", "assert permutation_in_string(\"a\", \"a\") == True", "assert permutation_in_string(\"adc\", \"dcda\") == True", "assert permutation_in_string(\"pq\", \"qpqqp\") == True", "assert permutation_in_string(\"kitten\", \"sittingkite\") == False", "assert permutation_in_string(\"pq\", \"pqpqr\") == True", "assert permutation_in_string(\"aba\", \"aabaabaa\") == True", "assert permutation_in_string(\"\", \"\") == True  # Edge case: both strings are empty", "assert permutation_in_string(\"longerstring\", \"short\") == False  # s1 is longer than s2", "assert permutation_in_string(\"a\", \"b\") == False  # Single character, no match", "assert permutation_in_string(\"aab\", \"baa\") == True  # s1 is a permutation of s2", "assert permutation_in_string(\"ab\", \"a\") == False  # s2 is shorter than s1", "assert permutation_in_string(\"ba\", \"eidbaooo\") == True  # Same characters as Example 1 but different permutation", "assert permutation_in_string(\"eid\", \"eidbaooo\") == True  # s1 is a prefix of s2", "assert permutation_in_string(\"ooo\", \"eidbaooo\") == True  # s1 is a suffix of s2", "assert permutation_in_string(\"db\", \"eidbaooo\") == True  # s1 is a permutation within s2", "assert permutation_in_string(\"eidoo\", \"eidbaooo\") == False  # s1 is longer than any permutation within s2"]}, {"author": "Calvin", "UUID": "56b48f6d-0d81-478d-b838-4d47b62d3031", "question": "Given an integer n, return the number of strings of length n that consist only of vowels (a, e, i, o, u) and are lexicographically sorted.\n\nA string s is lexicographically sorted if for all valid i, s[i] is the same as or comes before s[i+1] in the alphabet.", "examples": "Input: 1\nOutput: 5\n\nInput: 2\nOutput: 15", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def helper(n, letter_idx):\n  letters = [\"a\",\"e\",\"i\",\"o\",\"u\"]\n  dynamic = {\n      'a1' : 5,\n      'e1' : 4,\n      'i1' : 3,\n      'o1' : 2,\n      'u1' : 1\n  }\n  ret = 0\n  key = letters[letter_idx] + str(n)\n  if key in dynamic.keys():\n    return dynamic[key]\n  else:\n    for i in range(letter_idx, len(letters)):\n      ret += helper(n-1, i)\n    dynamic[key] = ret\n  return ret\n  \n\ndef countVowelStrings(n: int) -> int:\n  return helper(n, 0)\n", "asserts": ["assert countVowelStrings(3) == 35", "assert countVowelStrings(4) == 70", "assert countVowelStrings(5) == 126", "assert countVowelStrings(6) == 210", "assert countVowelStrings(7) == 330", "assert countVowelStrings(10) == 1001", "assert countVowelStrings(15) == 3876"]}], "category": "String", "prompt_tokens": 1255, "total_tokens": 1826, "completion_tokens": 571, "completion": "Given a string s, find and return the longest palindromic substring in s.\n\nA palindromic string is a string that reads the same backward as forward.\n\n###Code:\n\ndef longest_palindromic_substring(s: str) -> str:\n    def expand_around_center(left: int, right: int) -> str:\n        while left >= 0 and right < len(s) and s[left] == s[right]:\n            left -= 1\n            right += 1\n        return s[left + 1:right]\n\n    longest = \"\"\n    for i in range(len(s)):\n        # Odd length palindrome\n        odd_palindrome = expand_around_center(i, i)\n        if len(odd_palindrome) > len(longest):\n            longest = odd_palindrome\n        \n        # Even length palindrome\n        even_palindrome = expand_around_center(i, i+1)\n        if len(even_palindrome) > len(longest):\n            longest = even_palindrome\n\n    return longest\n\n###Testcases:\n\nassert longest_palindromic_substring(\"babad\") == \"bab\" or longest_palindromic_substring(\"babad\") == \"aba\"\nassert longest_palindromic_substring(\"cbbd\") == \"bb\"\nassert longest_palindromic_substring(\"a\") == \"a\"\nassert longest_palindromic_substring(\"ac\") == \"a\" or longest_palindromic_substring(\"ac\") == \"c\"\nassert longest_palindromic_substring(\"racecar\") == \"racecar\"\nassert longest_palindromic_substring(\"noon\") == \"noon\"\nassert longest_palindromic_substring(\"abcba\") == \"abcba\"\nassert longest_palindromic_substring(\"abccba\") == \"abccba\"\nassert longest_palindromic_substring(\"\") == \"\"  # Edge case: empty string\nassert longest_palindromic_substring(\"tattarrattat\") == \"tattarrattat\"  # Longest palindromic word\nassert longest_palindromic_substring(\"abcdefghba\") == \"a\" or longest_palindromic_substring(\"abcdefghba\") == \"b\"  # No palindrome longer than 1\nassert longest_palindromic_substring(\"bananas\") == \"anana\"\nassert longest_palindromic_substring(\"abacdfgdcaba\") == \"aba\" or longest_palindromic_substring(\"abacdfgdcaba\") == \"aca\"\nassert longest_palindromic_substring(\"abacdfgdcabba\") == \"abba\"\nassert longest_palindromic_substring(\"abacdxydcabba\") == \"abba\"\n\n[/Example 3]", "temperature": 0.738}, {"few_shots": [{"author": "Calvin", "UUID": "d0ce7430-cfcd-4c69-b161-b3b2a186422c", "question": "Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.\n\nIn other words, return true if one of s1's permutations is the substring of s2.", "examples": "Input: s1 = \"ab\", s2 = \"eidbaooo\"\nOutput: True\n\nInput: s1 = \"ab\", s2 = \"eidboaoo\"\nOutput: False", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef permutation_in_string(s1: str, s2: str) -> bool:\n  window = len(s1)\n  if window > len(s2):\n    return False\n  freq1 = [0]*26\n  freq2 = [0]*26\n  for i in range(window):\n    freq1[ord(s1[i])-ord('a')] += 1\n    freq2[ord(s2[i])-ord('a')] += 1\n\n  matches = 0\n  for i in range(26):\n    if freq1[i] == freq2[i]:\n      matches += 1\n  \n  for l in range(len(s2) - window):\n    if matches == 26:\n      return True\n\n    added = ord(s2[l + window]) - ord('a')\n    freq2[added] += 1\n    if freq1[added] == freq2[added]:\n      matches += 1\n    elif freq1[added] + 1 == freq2[added]:\n      matches -= 1\n\n    removed = ord(s2[l]) - ord('a')\n    freq2[removed] -= 1\n    if freq1[removed] == freq2[removed]:\n      matches += 1\n    elif freq1[removed] == freq2[removed] + 1:\n      matches -= 1\n    \n  return matches == 26\n", "asserts": ["assert permutation_in_string(\"hello\", \"ooollehhhhh\") == True", "assert permutation_in_string(\"abc\", \"ccccbbbbaaaa\") == False", "assert permutation_in_string(\"xyz\", \"zxyopqrstuv\") == True", "assert permutation_in_string(\"xyz\", \"xzygxzyzxyzk\") == True", "assert permutation_in_string(\"a\", \"a\") == True", "assert permutation_in_string(\"adc\", \"dcda\") == True", "assert permutation_in_string(\"pq\", \"qpqqp\") == True", "assert permutation_in_string(\"kitten\", \"sittingkite\") == False", "assert permutation_in_string(\"pq\", \"pqpqr\") == True", "assert permutation_in_string(\"aba\", \"aabaabaa\") == True", "assert permutation_in_string(\"\", \"\") == True  # Edge case: both strings are empty", "assert permutation_in_string(\"longerstring\", \"short\") == False  # s1 is longer than s2", "assert permutation_in_string(\"a\", \"b\") == False  # Single character, no match", "assert permutation_in_string(\"aab\", \"baa\") == True  # s1 is a permutation of s2", "assert permutation_in_string(\"ab\", \"a\") == False  # s2 is shorter than s1", "assert permutation_in_string(\"ba\", \"eidbaooo\") == True  # Same characters as Example 1 but different permutation", "assert permutation_in_string(\"eid\", \"eidbaooo\") == True  # s1 is a prefix of s2", "assert permutation_in_string(\"ooo\", \"eidbaooo\") == True  # s1 is a suffix of s2", "assert permutation_in_string(\"db\", \"eidbaooo\") == True  # s1 is a permutation within s2", "assert permutation_in_string(\"eidoo\", \"eidbaooo\") == False  # s1 is longer than any permutation within s2"]}, {"author": "Calvin", "UUID": "56b48f6d-0d81-478d-b838-4d47b62d3031", "question": "Given an integer n, return the number of strings of length n that consist only of vowels (a, e, i, o, u) and are lexicographically sorted.\n\nA string s is lexicographically sorted if for all valid i, s[i] is the same as or comes before s[i+1] in the alphabet.", "examples": "Input: 1\nOutput: 5\n\nInput: 2\nOutput: 15", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def helper(n, letter_idx):\n  letters = [\"a\",\"e\",\"i\",\"o\",\"u\"]\n  dynamic = {\n      'a1' : 5,\n      'e1' : 4,\n      'i1' : 3,\n      'o1' : 2,\n      'u1' : 1\n  }\n  ret = 0\n  key = letters[letter_idx] + str(n)\n  if key in dynamic.keys():\n    return dynamic[key]\n  else:\n    for i in range(letter_idx, len(letters)):\n      ret += helper(n-1, i)\n    dynamic[key] = ret\n  return ret\n  \n\ndef countVowelStrings(n: int) -> int:\n  return helper(n, 0)\n", "asserts": ["assert countVowelStrings(3) == 35", "assert countVowelStrings(4) == 70", "assert countVowelStrings(5) == 126", "assert countVowelStrings(6) == 210", "assert countVowelStrings(7) == 330", "assert countVowelStrings(10) == 1001", "assert countVowelStrings(15) == 3876"]}], "category": "String", "prompt_tokens": 1255, "total_tokens": 1773, "completion_tokens": 518, "completion": "Write a function that takes a string s and an integer k and returns the length of the longest substring with at most k distinct characters.\n\nFor example, given the string \"eceba\" and k = 2, the answer is 3, as the longest substring with at most 2 distinct characters is \"ece\".\n\n###Code: \n\ndef length_of_longest_substring_k_distinct(s: str, k: int) -> int:\n    if k == 0 or not s:\n        return 0\n\n    char_map = {}\n    left = 0\n    max_length = 0\n\n    for right in range(len(s)):\n        char_map[s[right]] = char_map.get(s[right], 0) + 1\n        \n        while len(char_map) > k:\n            char_map[s[left]] -= 1\n            if char_map[s[left]] == 0:\n                del char_map[s[left]]\n            left += 1\n        \n        max_length = max(max_length, right - left + 1)\n    \n    return max_length\n\n###Testcases: \n\nassert length_of_longest_substring_k_distinct(\"eceba\", 2) == 3\nassert length_of_longest_substring_k_distinct(\"aa\", 1) == 2\nassert length_of_longest_substring_k_distinct(\"aabbcc\", 1) == 2\nassert length_of_longest_substring_k_distinct(\"aabbcc\", 2) == 4\nassert length_of_longest_substring_k_distinct(\"aabbcc\", 3) == 6\nassert length_of_longest_substring_k_distinct(\"abaccc\", 2) == 4\nassert length_of_longest_substring_k_distinct(\"abaccc\", 0) == 0  # Edge case: k is 0\nassert length_of_longest_substring_k_distinct(\"\", 2) == 0  # Edge case: s is empty\nassert length_of_longest_substring_k_distinct(\"aba\", 2) == 3\nassert length_of_longest_substring_k_distinct(\"bacc\", 2) == 3\nassert length_of_longest_substring_k_distinct(\"abaccc\", 1) == 3\nassert length_of_longest_substring_k_distinct(\"aaabbb\", 3) == 6\nassert length_of_longest_substring_k_distinct(\"abababab\", 2) == 8\n\n[/Example 3]", "temperature": 0.786}, {"few_shots": [{"author": "Calvin", "UUID": "87372a22-f5ef-4100-845b-28700ca3fde3", "question": "You are given a string s and an integer array indices of the same length. The string s will be shuffled such that the character at the ith position moves to indices[i] in the shuffled string.\n\nReturn the shuffled string.", "examples": "Input: s = \"codeleet\", indices = [4,5,6,7,0,2,1,3]\nOutput: \"leetcode\"\n\nInput: s = \"abc\", indices = [0,1,2]\nOutput: \"abc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "from typing import List\ndef shuffle_string(s: str, indices: List[int]) -> str:\n    def partitionString(s):\n      substrings = 1\n      cur_str = set()\n      for i in range(len(s)):\n        if s[i] in cur_str:\n          substrings += 1\n          cur_str = {s[i]}\n        else:\n          cur_str.add(s[i])\n      return substrings\n    ret = ['_']*len(s)\n    for idx, i in enumerate(indices):\n        ret[i] = s[idx]\n    return \"\".join(ret)\n", "asserts": ["assert shuffle_string(\"reoc\", [2, 0, 1, 3]) == \"eorc\"", "assert shuffle_string(\"aiohn\", [3,1,4,2,0]) == \"nihao\"", "assert shuffle_string(\"aax\", [0,2,1]) == \"axa\"", "assert shuffle_string(\"gh\", [1,0]) == \"hg\"", "assert shuffle_string(\"\", []) == \"\"  # Edge case: empty string", "assert shuffle_string(\"xy\", [0,1]) == \"xy\"  # No shuffle required", "assert shuffle_string(\"pqrstuvwxyzabcdefghijklmno\", list(range(25, -1, -1))) == \"onmlkjihgfedcbazyxwvutsrqp\"  # Reverse shuffle"]}, {"author": "Calvin", "UUID": "ac641352-08d5-4950-8993-6a143da92ecf", "question": "You are given a string s and an integer k. You can choose one of the first k letters of s and append it at the end of the string.\n\nReturn the lexicographically smallest string you could have after applying the mentioned step any number of moves.\n", "examples": "Input: s = \"cba\", k = 1\nOutput: \"acb\"\n\nInput: s = \"baaca\", k = 3\nOutput: \"aaabc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef orderlyQueue(s: str, k: int) -> str:\n    if k == 1:\n        n = len(s)\n        ss = s + s\n        lex_min_str = s\n        for i in range(n):\n            lex_min_str = min(lex_min_str, ss[i:i + n])\n        return lex_min_str\n    \n    return \"\".join(sorted(s))\n", "asserts": ["assert orderlyQueue(\"abcd\", 1) == \"abcd\"", "assert orderlyQueue(\"hello\", 2) == \"ehllo\"", "assert orderlyQueue(\"programming\", 1) == \"ammingprogr\"", "assert orderlyQueue(\"rotator\", 1) == \"atorrot\"", "assert orderlyQueue(\"zxyabc\", 5) == \"abcxyz\"", "assert orderlyQueue(\"xy\", 2) == \"xy\""]}], "category": "String", "prompt_tokens": 755, "total_tokens": 959, "completion_tokens": 204, "completion": "Write a function that takes in a string s containing only lowercase English letters and returns the first non-repeating character in it. If there is no such character, return '_'.\n\n###Code: \n\ndef first_unique_char(s: str) -> str:\n    frequency = {}\n    for char in s:\n        frequency[char] = frequency.get(char, 0) + 1\n        \n    for char in s:\n        if frequency[char] == 1:\n            return char\n            \n    return '_'\n\n###Testcases: \n\nassert first_unique_char(\"leetcode\") == 'l'\nassert first_unique_char(\"loveleetcode\") == 'v'\nassert first_unique_char(\"aabb\") == '_'\nassert first_unique_char(\"strength\") == 's'\nassert first_unique_char(\"abacabad\") == 'c'\nassert first_unique_char(\"abcabc\") == '_'\nassert first_unique_char(\"z\") == 'z'\nassert first_unique_char(\"\") == '_'  # Edge case: empty string\n\n[/Example 3]", "temperature": 0.655}, {"few_shots": [{"author": "Calvin", "UUID": "87372a22-f5ef-4100-845b-28700ca3fde3", "question": "You are given a string s and an integer array indices of the same length. The string s will be shuffled such that the character at the ith position moves to indices[i] in the shuffled string.\n\nReturn the shuffled string.", "examples": "Input: s = \"codeleet\", indices = [4,5,6,7,0,2,1,3]\nOutput: \"leetcode\"\n\nInput: s = \"abc\", indices = [0,1,2]\nOutput: \"abc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "from typing import List\ndef shuffle_string(s: str, indices: List[int]) -> str:\n    def partitionString(s):\n      substrings = 1\n      cur_str = set()\n      for i in range(len(s)):\n        if s[i] in cur_str:\n          substrings += 1\n          cur_str = {s[i]}\n        else:\n          cur_str.add(s[i])\n      return substrings\n    ret = ['_']*len(s)\n    for idx, i in enumerate(indices):\n        ret[i] = s[idx]\n    return \"\".join(ret)\n", "asserts": ["assert shuffle_string(\"reoc\", [2, 0, 1, 3]) == \"eorc\"", "assert shuffle_string(\"aiohn\", [3,1,4,2,0]) == \"nihao\"", "assert shuffle_string(\"aax\", [0,2,1]) == \"axa\"", "assert shuffle_string(\"gh\", [1,0]) == \"hg\"", "assert shuffle_string(\"\", []) == \"\"  # Edge case: empty string", "assert shuffle_string(\"xy\", [0,1]) == \"xy\"  # No shuffle required", "assert shuffle_string(\"pqrstuvwxyzabcdefghijklmno\", list(range(25, -1, -1))) == \"onmlkjihgfedcbazyxwvutsrqp\"  # Reverse shuffle"]}, {"author": "Calvin", "UUID": "ac641352-08d5-4950-8993-6a143da92ecf", "question": "You are given a string s and an integer k. You can choose one of the first k letters of s and append it at the end of the string.\n\nReturn the lexicographically smallest string you could have after applying the mentioned step any number of moves.\n", "examples": "Input: s = \"cba\", k = 1\nOutput: \"acb\"\n\nInput: s = \"baaca\", k = 3\nOutput: \"aaabc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef orderlyQueue(s: str, k: int) -> str:\n    if k == 1:\n        n = len(s)\n        ss = s + s\n        lex_min_str = s\n        for i in range(n):\n            lex_min_str = min(lex_min_str, ss[i:i + n])\n        return lex_min_str\n    \n    return \"\".join(sorted(s))\n", "asserts": ["assert orderlyQueue(\"abcd\", 1) == \"abcd\"", "assert orderlyQueue(\"hello\", 2) == \"ehllo\"", "assert orderlyQueue(\"programming\", 1) == \"ammingprogr\"", "assert orderlyQueue(\"rotator\", 1) == \"atorrot\"", "assert orderlyQueue(\"zxyabc\", 5) == \"abcxyz\"", "assert orderlyQueue(\"xy\", 2) == \"xy\""]}], "category": "String", "prompt_tokens": 755, "total_tokens": 1062, "completion_tokens": 307, "completion": "Design a function that takes a string input and reverses only the vowels present in it. The characters that are not vowels should remain in their original positions.\n\n###Code:\n\ndef reverse_vowels(s: str) -> str:\n    vowels = set('aeiouAEIOU')\n    s_list = list(s)\n    left, right = 0, len(s) - 1\n    while left < right:\n        if s_list[left] not in vowels:\n            left += 1\n        elif s_list[right] not in vowels:\n            right -= 1\n        else:\n            s_list[left], s_list[right] = s_list[right], s_list[left]\n            left += 1\n            right -= 1\n    return ''.join(s_list)\n\n###Testcases:\n\nassert reverse_vowels(\"hello\") == \"holle\"\nassert reverse_vowels(\"leetcode\") == \"leotcede\"\nassert reverse_vowels(\"aA\") == \"Aa\"\nassert reverse_vowels(\"computation\") == \"cemputatoin\"\nassert reverse_vowels(\" \") == \" \"  # Edge case: string with space\nassert reverse_vowels(\"bbbb\") == \"bbbb\"  # No vowels to reverse\nassert reverse_vowels(\"AEIOU\") == \"UOIEA\"  # All vowels in uppercase\nassert reverse_vowels(\"aeiou\") == \"uoiea\"  # All vowels in lowercase\n\n[/Example 3]", "temperature": 0.892}, {"few_shots": [{"author": "Calvin", "UUID": "87372a22-f5ef-4100-845b-28700ca3fde3", "question": "You are given a string s and an integer array indices of the same length. The string s will be shuffled such that the character at the ith position moves to indices[i] in the shuffled string.\n\nReturn the shuffled string.", "examples": "Input: s = \"codeleet\", indices = [4,5,6,7,0,2,1,3]\nOutput: \"leetcode\"\n\nInput: s = \"abc\", indices = [0,1,2]\nOutput: \"abc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "from typing import List\ndef shuffle_string(s: str, indices: List[int]) -> str:\n    def partitionString(s):\n      substrings = 1\n      cur_str = set()\n      for i in range(len(s)):\n        if s[i] in cur_str:\n          substrings += 1\n          cur_str = {s[i]}\n        else:\n          cur_str.add(s[i])\n      return substrings\n    ret = ['_']*len(s)\n    for idx, i in enumerate(indices):\n        ret[i] = s[idx]\n    return \"\".join(ret)\n", "asserts": ["assert shuffle_string(\"reoc\", [2, 0, 1, 3]) == \"eorc\"", "assert shuffle_string(\"aiohn\", [3,1,4,2,0]) == \"nihao\"", "assert shuffle_string(\"aax\", [0,2,1]) == \"axa\"", "assert shuffle_string(\"gh\", [1,0]) == \"hg\"", "assert shuffle_string(\"\", []) == \"\"  # Edge case: empty string", "assert shuffle_string(\"xy\", [0,1]) == \"xy\"  # No shuffle required", "assert shuffle_string(\"pqrstuvwxyzabcdefghijklmno\", list(range(25, -1, -1))) == \"onmlkjihgfedcbazyxwvutsrqp\"  # Reverse shuffle"]}, {"author": "Calvin", "UUID": "ac641352-08d5-4950-8993-6a143da92ecf", "question": "You are given a string s and an integer k. You can choose one of the first k letters of s and append it at the end of the string.\n\nReturn the lexicographically smallest string you could have after applying the mentioned step any number of moves.\n", "examples": "Input: s = \"cba\", k = 1\nOutput: \"acb\"\n\nInput: s = \"baaca\", k = 3\nOutput: \"aaabc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef orderlyQueue(s: str, k: int) -> str:\n    if k == 1:\n        n = len(s)\n        ss = s + s\n        lex_min_str = s\n        for i in range(n):\n            lex_min_str = min(lex_min_str, ss[i:i + n])\n        return lex_min_str\n    \n    return \"\".join(sorted(s))\n", "asserts": ["assert orderlyQueue(\"abcd\", 1) == \"abcd\"", "assert orderlyQueue(\"hello\", 2) == \"ehllo\"", "assert orderlyQueue(\"programming\", 1) == \"ammingprogr\"", "assert orderlyQueue(\"rotator\", 1) == \"atorrot\"", "assert orderlyQueue(\"zxyabc\", 5) == \"abcxyz\"", "assert orderlyQueue(\"xy\", 2) == \"xy\""]}], "category": "String", "prompt_tokens": 755, "total_tokens": 1108, "completion_tokens": 353, "completion": "Given a string containing only three types of characters: '(', ')' and '*', write a function to check whether this string is valid. The '*' character can be treated as a single right parenthesis ')', a single left parenthesis '(', or an empty string.\n\nA valid string is one that can be converted into a valid parentheses string by inserting one or zero characters in front of or after each asterisk. The function should return true if the string is valid, and false otherwise.\n\n###Code:\n\ndef checkValidString(s: str) -> bool:\n    left_balance = right_balance = 0\n    n = len(s)\n    \n    for i in range(n):\n        # Treat '*' as '(' or as empty string\n        if s[i] in \"(*\":\n            left_balance += 1\n        else:\n            left_balance -= 1\n        \n        # Treat '*' as ')' or as empty string from the right\n        if s[n - i - 1] in \")*\":\n            right_balance += 1\n        else:\n            right_balance -= 1\n        \n        if left_balance < 0 or right_balance < 0:\n            return False\n\n    return True\n\n###Testcases:\n\nassert checkValidString(\"()\") == True\nassert checkValidString(\"(*)\") == True\nassert checkValidString(\"(*))\") == True\nassert checkValidString(\")*(\") == False\nassert checkValidString(\"(((******))\") == True\nassert checkValidString(\"\") == True  # Empty string is considered valid\nassert checkValidString(\"(((*)\") == True\nassert checkValidString(\"*()(())*()(()()((()(()()*)(*(())((((((((()*)(()(*)\") == True\n\n[/Example 3]", "temperature": 0.748}, {"few_shots": [{"author": "Calvin", "UUID": "87372a22-f5ef-4100-845b-28700ca3fde3", "question": "You are given a string s and an integer array indices of the same length. The string s will be shuffled such that the character at the ith position moves to indices[i] in the shuffled string.\n\nReturn the shuffled string.", "examples": "Input: s = \"codeleet\", indices = [4,5,6,7,0,2,1,3]\nOutput: \"leetcode\"\n\nInput: s = \"abc\", indices = [0,1,2]\nOutput: \"abc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "from typing import List\ndef shuffle_string(s: str, indices: List[int]) -> str:\n    def partitionString(s):\n      substrings = 1\n      cur_str = set()\n      for i in range(len(s)):\n        if s[i] in cur_str:\n          substrings += 1\n          cur_str = {s[i]}\n        else:\n          cur_str.add(s[i])\n      return substrings\n    ret = ['_']*len(s)\n    for idx, i in enumerate(indices):\n        ret[i] = s[idx]\n    return \"\".join(ret)\n", "asserts": ["assert shuffle_string(\"reoc\", [2, 0, 1, 3]) == \"eorc\"", "assert shuffle_string(\"aiohn\", [3,1,4,2,0]) == \"nihao\"", "assert shuffle_string(\"aax\", [0,2,1]) == \"axa\"", "assert shuffle_string(\"gh\", [1,0]) == \"hg\"", "assert shuffle_string(\"\", []) == \"\"  # Edge case: empty string", "assert shuffle_string(\"xy\", [0,1]) == \"xy\"  # No shuffle required", "assert shuffle_string(\"pqrstuvwxyzabcdefghijklmno\", list(range(25, -1, -1))) == \"onmlkjihgfedcbazyxwvutsrqp\"  # Reverse shuffle"]}, {"author": "Calvin", "UUID": "ac641352-08d5-4950-8993-6a143da92ecf", "question": "You are given a string s and an integer k. You can choose one of the first k letters of s and append it at the end of the string.\n\nReturn the lexicographically smallest string you could have after applying the mentioned step any number of moves.\n", "examples": "Input: s = \"cba\", k = 1\nOutput: \"acb\"\n\nInput: s = \"baaca\", k = 3\nOutput: \"aaabc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef orderlyQueue(s: str, k: int) -> str:\n    if k == 1:\n        n = len(s)\n        ss = s + s\n        lex_min_str = s\n        for i in range(n):\n            lex_min_str = min(lex_min_str, ss[i:i + n])\n        return lex_min_str\n    \n    return \"\".join(sorted(s))\n", "asserts": ["assert orderlyQueue(\"abcd\", 1) == \"abcd\"", "assert orderlyQueue(\"hello\", 2) == \"ehllo\"", "assert orderlyQueue(\"programming\", 1) == \"ammingprogr\"", "assert orderlyQueue(\"rotator\", 1) == \"atorrot\"", "assert orderlyQueue(\"zxyabc\", 5) == \"abcxyz\"", "assert orderlyQueue(\"xy\", 2) == \"xy\""]}], "category": "String", "prompt_tokens": 755, "total_tokens": 1033, "completion_tokens": 278, "completion": "You are given a string s that consists of lower case English letters and brackets. \n\nReverse the strings in each pair of matching parentheses, starting from the innermost one.\n\nYour result should not contain any brackets.\n\n###Code: \n\ndef reverseParentheses(s: str) -> str:\n    stack = []\n    for char in s:\n        if char == ')':\n            temp = []\n            while stack and stack[-1] != '(':\n                temp.append(stack.pop())\n            stack.pop()  # Remove the '(' from stack\n            stack.extend(temp)\n        else:\n            stack.append(char)\n    return ''.join(stack)\n\n\n###Testcases: \n\nassert reverseParentheses(\"(abcd)\") == \"dcba\"\nassert reverseParentheses(\"(u(love)i)\") == \"iloveu\"\nassert reverseParentheses(\"(ed(et(oc))el)\") == \"leetcode\"\nassert reverseParentheses(\"a(bcdefghijkl(mno)p)q\") == \"apmnolkjihgfedcbq\"\nassert reverseParentheses(\"\") == \"\"  # Edge case: empty string\nassert reverseParentheses(\"abc(cba)ab(bac)c\") == \"abcabcabcabc\"\nassert reverseParentheses(\"The ((quick (brown) (fox) jumps over the lazy) dog)\") == \"The god quick nworb xof jumps over the lazy\"\n\n[/Example 3]", "temperature": 0.928}, {"few_shots": [{"author": "Calvin", "UUID": "87372a22-f5ef-4100-845b-28700ca3fde3", "question": "You are given a string s and an integer array indices of the same length. The string s will be shuffled such that the character at the ith position moves to indices[i] in the shuffled string.\n\nReturn the shuffled string.", "examples": "Input: s = \"codeleet\", indices = [4,5,6,7,0,2,1,3]\nOutput: \"leetcode\"\n\nInput: s = \"abc\", indices = [0,1,2]\nOutput: \"abc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "from typing import List\ndef shuffle_string(s: str, indices: List[int]) -> str:\n    def partitionString(s):\n      substrings = 1\n      cur_str = set()\n      for i in range(len(s)):\n        if s[i] in cur_str:\n          substrings += 1\n          cur_str = {s[i]}\n        else:\n          cur_str.add(s[i])\n      return substrings\n    ret = ['_']*len(s)\n    for idx, i in enumerate(indices):\n        ret[i] = s[idx]\n    return \"\".join(ret)\n", "asserts": ["assert shuffle_string(\"reoc\", [2, 0, 1, 3]) == \"eorc\"", "assert shuffle_string(\"aiohn\", [3,1,4,2,0]) == \"nihao\"", "assert shuffle_string(\"aax\", [0,2,1]) == \"axa\"", "assert shuffle_string(\"gh\", [1,0]) == \"hg\"", "assert shuffle_string(\"\", []) == \"\"  # Edge case: empty string", "assert shuffle_string(\"xy\", [0,1]) == \"xy\"  # No shuffle required", "assert shuffle_string(\"pqrstuvwxyzabcdefghijklmno\", list(range(25, -1, -1))) == \"onmlkjihgfedcbazyxwvutsrqp\"  # Reverse shuffle"]}, {"author": "Calvin", "UUID": "ac641352-08d5-4950-8993-6a143da92ecf", "question": "You are given a string s and an integer k. You can choose one of the first k letters of s and append it at the end of the string.\n\nReturn the lexicographically smallest string you could have after applying the mentioned step any number of moves.\n", "examples": "Input: s = \"cba\", k = 1\nOutput: \"acb\"\n\nInput: s = \"baaca\", k = 3\nOutput: \"aaabc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef orderlyQueue(s: str, k: int) -> str:\n    if k == 1:\n        n = len(s)\n        ss = s + s\n        lex_min_str = s\n        for i in range(n):\n            lex_min_str = min(lex_min_str, ss[i:i + n])\n        return lex_min_str\n    \n    return \"\".join(sorted(s))\n", "asserts": ["assert orderlyQueue(\"abcd\", 1) == \"abcd\"", "assert orderlyQueue(\"hello\", 2) == \"ehllo\"", "assert orderlyQueue(\"programming\", 1) == \"ammingprogr\"", "assert orderlyQueue(\"rotator\", 1) == \"atorrot\"", "assert orderlyQueue(\"zxyabc\", 5) == \"abcxyz\"", "assert orderlyQueue(\"xy\", 2) == \"xy\""]}], "category": "String", "prompt_tokens": 755, "total_tokens": 1033, "completion_tokens": 278, "completion": "Create a function that takes in a string s and returns a string where each character is replaced by its respective rank in the alphabet. \n\nA space \" \" should be replaced by \"0\". The rank should start from 1 for the letter 'a' and end at 26 for the letter 'z'. The function should ignore case, treating all characters as lowercase.\n\n###Code: \n\ndef alphabet_rank(s: str) -> str:\n    def char_to_rank(c):\n        if c.isalpha():\n            return str(ord(c.lower()) - ord('a') + 1)\n        elif c == ' ':\n            return '0'\n        else:\n            return c  # Non-alphabetic characters are unchanged\n\n    return ''.join(char_to_rank(c) for c in s)\n\n###Testcases: \n\nassert alphabet_rank(\"abc\") == \"123\"\nassert alphabet_rank(\"hello world\") == \"85121215 2315184\"\nassert alphabet_rank(\"Sphinx of black quartz, judge my vow.\") == \"192518516 1512 21311 17218121, 106215 13135 225152315.\"\nassert alphabet_rank(\"\") == \"\"  # Edge case: empty string\nassert alphabet_rank(\"a B z\") == \"1 2 26\"\nassert alphabet_rank(\"XYZ\") == \"242526\"\n\n[/Example 3]", "temperature": 0.884}, {"few_shots": [{"author": "Calvin", "UUID": "87372a22-f5ef-4100-845b-28700ca3fde3", "question": "You are given a string s and an integer array indices of the same length. The string s will be shuffled such that the character at the ith position moves to indices[i] in the shuffled string.\n\nReturn the shuffled string.", "examples": "Input: s = \"codeleet\", indices = [4,5,6,7,0,2,1,3]\nOutput: \"leetcode\"\n\nInput: s = \"abc\", indices = [0,1,2]\nOutput: \"abc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "from typing import List\ndef shuffle_string(s: str, indices: List[int]) -> str:\n    def partitionString(s):\n      substrings = 1\n      cur_str = set()\n      for i in range(len(s)):\n        if s[i] in cur_str:\n          substrings += 1\n          cur_str = {s[i]}\n        else:\n          cur_str.add(s[i])\n      return substrings\n    ret = ['_']*len(s)\n    for idx, i in enumerate(indices):\n        ret[i] = s[idx]\n    return \"\".join(ret)\n", "asserts": ["assert shuffle_string(\"reoc\", [2, 0, 1, 3]) == \"eorc\"", "assert shuffle_string(\"aiohn\", [3,1,4,2,0]) == \"nihao\"", "assert shuffle_string(\"aax\", [0,2,1]) == \"axa\"", "assert shuffle_string(\"gh\", [1,0]) == \"hg\"", "assert shuffle_string(\"\", []) == \"\"  # Edge case: empty string", "assert shuffle_string(\"xy\", [0,1]) == \"xy\"  # No shuffle required", "assert shuffle_string(\"pqrstuvwxyzabcdefghijklmno\", list(range(25, -1, -1))) == \"onmlkjihgfedcbazyxwvutsrqp\"  # Reverse shuffle"]}, {"author": "Calvin", "UUID": "ac641352-08d5-4950-8993-6a143da92ecf", "question": "You are given a string s and an integer k. You can choose one of the first k letters of s and append it at the end of the string.\n\nReturn the lexicographically smallest string you could have after applying the mentioned step any number of moves.\n", "examples": "Input: s = \"cba\", k = 1\nOutput: \"acb\"\n\nInput: s = \"baaca\", k = 3\nOutput: \"aaabc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef orderlyQueue(s: str, k: int) -> str:\n    if k == 1:\n        n = len(s)\n        ss = s + s\n        lex_min_str = s\n        for i in range(n):\n            lex_min_str = min(lex_min_str, ss[i:i + n])\n        return lex_min_str\n    \n    return \"\".join(sorted(s))\n", "asserts": ["assert orderlyQueue(\"abcd\", 1) == \"abcd\"", "assert orderlyQueue(\"hello\", 2) == \"ehllo\"", "assert orderlyQueue(\"programming\", 1) == \"ammingprogr\"", "assert orderlyQueue(\"rotator\", 1) == \"atorrot\"", "assert orderlyQueue(\"zxyabc\", 5) == \"abcxyz\"", "assert orderlyQueue(\"xy\", 2) == \"xy\""]}], "category": "String", "prompt_tokens": 755, "total_tokens": 972, "completion_tokens": 217, "completion": "You are given a string s representing a sentence, where each word is separated by a single space. You need to return a new string with all the vowels (both uppercase and lowercase) removed from the sentence.\n\n###Code:\n\ndef remove_vowels(s: str) -> str:\n    vowels = set(\"aeiouAEIOU\")\n    return ''.join(filter(lambda x: x not in vowels, s))\n\n###Testcases:\n\nassert remove_vowels(\"This is a test sentence\") == \"Ths s  tst sntnc\"\nassert remove_vowels(\"We need to remove all the vowels.\") == \"W nd t rmv ll th vwls.\"\nassert remove_vowels(\"AEIOUaeiou\") == \"\"\nassert remove_vowels(\"Why?\") == \"Why?\"\nassert remove_vowels(\"AEIOU ae iou\") == \"  \"\nassert remove_vowels(\"Hello World!\") == \"Hll Wrld!\"\nassert remove_vowels(\"\") == \"\"  # Edge case: empty string\n\n[/Example 3]", "temperature": 0.816}, {"few_shots": [{"author": "Calvin", "UUID": "87372a22-f5ef-4100-845b-28700ca3fde3", "question": "You are given a string s and an integer array indices of the same length. The string s will be shuffled such that the character at the ith position moves to indices[i] in the shuffled string.\n\nReturn the shuffled string.", "examples": "Input: s = \"codeleet\", indices = [4,5,6,7,0,2,1,3]\nOutput: \"leetcode\"\n\nInput: s = \"abc\", indices = [0,1,2]\nOutput: \"abc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "from typing import List\ndef shuffle_string(s: str, indices: List[int]) -> str:\n    def partitionString(s):\n      substrings = 1\n      cur_str = set()\n      for i in range(len(s)):\n        if s[i] in cur_str:\n          substrings += 1\n          cur_str = {s[i]}\n        else:\n          cur_str.add(s[i])\n      return substrings\n    ret = ['_']*len(s)\n    for idx, i in enumerate(indices):\n        ret[i] = s[idx]\n    return \"\".join(ret)\n", "asserts": ["assert shuffle_string(\"reoc\", [2, 0, 1, 3]) == \"eorc\"", "assert shuffle_string(\"aiohn\", [3,1,4,2,0]) == \"nihao\"", "assert shuffle_string(\"aax\", [0,2,1]) == \"axa\"", "assert shuffle_string(\"gh\", [1,0]) == \"hg\"", "assert shuffle_string(\"\", []) == \"\"  # Edge case: empty string", "assert shuffle_string(\"xy\", [0,1]) == \"xy\"  # No shuffle required", "assert shuffle_string(\"pqrstuvwxyzabcdefghijklmno\", list(range(25, -1, -1))) == \"onmlkjihgfedcbazyxwvutsrqp\"  # Reverse shuffle"]}, {"author": "Calvin", "UUID": "ac641352-08d5-4950-8993-6a143da92ecf", "question": "You are given a string s and an integer k. You can choose one of the first k letters of s and append it at the end of the string.\n\nReturn the lexicographically smallest string you could have after applying the mentioned step any number of moves.\n", "examples": "Input: s = \"cba\", k = 1\nOutput: \"acb\"\n\nInput: s = \"baaca\", k = 3\nOutput: \"aaabc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef orderlyQueue(s: str, k: int) -> str:\n    if k == 1:\n        n = len(s)\n        ss = s + s\n        lex_min_str = s\n        for i in range(n):\n            lex_min_str = min(lex_min_str, ss[i:i + n])\n        return lex_min_str\n    \n    return \"\".join(sorted(s))\n", "asserts": ["assert orderlyQueue(\"abcd\", 1) == \"abcd\"", "assert orderlyQueue(\"hello\", 2) == \"ehllo\"", "assert orderlyQueue(\"programming\", 1) == \"ammingprogr\"", "assert orderlyQueue(\"rotator\", 1) == \"atorrot\"", "assert orderlyQueue(\"zxyabc\", 5) == \"abcxyz\"", "assert orderlyQueue(\"xy\", 2) == \"xy\""]}], "category": "String", "prompt_tokens": 755, "total_tokens": 1054, "completion_tokens": 299, "completion": "Given a string s, reverse only all the vowels in the string and return it. The vowels are 'a', 'e', 'i', 'o', and 'u', and they can appear in both cases.\n\n###Code:\n\ndef reverseVowels(s: str) -> str:\n    vowels = set(\"aeiouAEIOU\")\n    s_list = list(s)\n    left, right = 0, len(s) - 1\n    \n    while left < right:\n        while left < right and s_list[left] not in vowels:\n            left += 1\n        while left < right and s_list[right] not in vowels:\n            right -= 1\n        \n        s_list[left], s_list[right] = s_list[right], s_list[left]\n        left, right = left + 1, right - 1\n    \n    return ''.join(s_list)\n\n###Testcases:\n\nassert reverseVowels(\"hello\") == \"holle\"\nassert reverseVowels(\"leetcode\") == \"leotcede\"\nassert reverseVowels(\"aA\") == \"Aa\"\nassert reverseVowels(\"programming\") == \"prigrammong\"\nassert reverseVowels(\" \") == \" \"  # Edge case: single space\nassert reverseVowels(\"\") == \"\"  # Edge case: empty string\nassert reverseVowels(\"bcdfg\") == \"bcdfg\"  # No vowels to reverse\n\n[/Example 3]", "temperature": 0.762}, {"few_shots": [{"author": "Calvin", "UUID": "87372a22-f5ef-4100-845b-28700ca3fde3", "question": "You are given a string s and an integer array indices of the same length. The string s will be shuffled such that the character at the ith position moves to indices[i] in the shuffled string.\n\nReturn the shuffled string.", "examples": "Input: s = \"codeleet\", indices = [4,5,6,7,0,2,1,3]\nOutput: \"leetcode\"\n\nInput: s = \"abc\", indices = [0,1,2]\nOutput: \"abc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "from typing import List\ndef shuffle_string(s: str, indices: List[int]) -> str:\n    def partitionString(s):\n      substrings = 1\n      cur_str = set()\n      for i in range(len(s)):\n        if s[i] in cur_str:\n          substrings += 1\n          cur_str = {s[i]}\n        else:\n          cur_str.add(s[i])\n      return substrings\n    ret = ['_']*len(s)\n    for idx, i in enumerate(indices):\n        ret[i] = s[idx]\n    return \"\".join(ret)\n", "asserts": ["assert shuffle_string(\"reoc\", [2, 0, 1, 3]) == \"eorc\"", "assert shuffle_string(\"aiohn\", [3,1,4,2,0]) == \"nihao\"", "assert shuffle_string(\"aax\", [0,2,1]) == \"axa\"", "assert shuffle_string(\"gh\", [1,0]) == \"hg\"", "assert shuffle_string(\"\", []) == \"\"  # Edge case: empty string", "assert shuffle_string(\"xy\", [0,1]) == \"xy\"  # No shuffle required", "assert shuffle_string(\"pqrstuvwxyzabcdefghijklmno\", list(range(25, -1, -1))) == \"onmlkjihgfedcbazyxwvutsrqp\"  # Reverse shuffle"]}, {"author": "Calvin", "UUID": "ac641352-08d5-4950-8993-6a143da92ecf", "question": "You are given a string s and an integer k. You can choose one of the first k letters of s and append it at the end of the string.\n\nReturn the lexicographically smallest string you could have after applying the mentioned step any number of moves.\n", "examples": "Input: s = \"cba\", k = 1\nOutput: \"acb\"\n\nInput: s = \"baaca\", k = 3\nOutput: \"aaabc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef orderlyQueue(s: str, k: int) -> str:\n    if k == 1:\n        n = len(s)\n        ss = s + s\n        lex_min_str = s\n        for i in range(n):\n            lex_min_str = min(lex_min_str, ss[i:i + n])\n        return lex_min_str\n    \n    return \"\".join(sorted(s))\n", "asserts": ["assert orderlyQueue(\"abcd\", 1) == \"abcd\"", "assert orderlyQueue(\"hello\", 2) == \"ehllo\"", "assert orderlyQueue(\"programming\", 1) == \"ammingprogr\"", "assert orderlyQueue(\"rotator\", 1) == \"atorrot\"", "assert orderlyQueue(\"zxyabc\", 5) == \"abcxyz\"", "assert orderlyQueue(\"xy\", 2) == \"xy\""]}], "category": "String", "prompt_tokens": 755, "total_tokens": 955, "completion_tokens": 200, "completion": "You are given a string s consisting of lowercase English letters. A duplicate removal consists of choosing two adjacent and equal letters and removing them.\n\nWe repeatedly make duplicate removals on s until we no longer can.\n\nReturn the final string after all such duplicate removals have been made. It is guaranteed that the answer is unique.\n\n###Code: \n\ndef removeDuplicates(s: str) -> str:\n    stack = []\n    for char in s:\n        if stack and char == stack[-1]:\n            stack.pop()\n        else:\n            stack.append(char)\n    return \"\".join(stack)\n\n###Testcases: \n\nassert removeDuplicates(\"abbaca\") == \"ca\"\nassert removeDuplicates(\"azxxzy\") == \"ay\"\nassert removeDuplicates(\"a\") == \"a\"\nassert removeDuplicates(\"abba\") == \"\"\nassert removeDuplicates(\"aaa\") == \"a\"\nassert removeDuplicates(\"abccba\") == \"\"\nassert removeDuplicates(\"abcddcba\") == \"aa\"\n\n[/Example 3]", "temperature": 0.885}, {"few_shots": [{"author": "Calvin", "UUID": "87372a22-f5ef-4100-845b-28700ca3fde3", "question": "You are given a string s and an integer array indices of the same length. The string s will be shuffled such that the character at the ith position moves to indices[i] in the shuffled string.\n\nReturn the shuffled string.", "examples": "Input: s = \"codeleet\", indices = [4,5,6,7,0,2,1,3]\nOutput: \"leetcode\"\n\nInput: s = \"abc\", indices = [0,1,2]\nOutput: \"abc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "from typing import List\ndef shuffle_string(s: str, indices: List[int]) -> str:\n    def partitionString(s):\n      substrings = 1\n      cur_str = set()\n      for i in range(len(s)):\n        if s[i] in cur_str:\n          substrings += 1\n          cur_str = {s[i]}\n        else:\n          cur_str.add(s[i])\n      return substrings\n    ret = ['_']*len(s)\n    for idx, i in enumerate(indices):\n        ret[i] = s[idx]\n    return \"\".join(ret)\n", "asserts": ["assert shuffle_string(\"reoc\", [2, 0, 1, 3]) == \"eorc\"", "assert shuffle_string(\"aiohn\", [3,1,4,2,0]) == \"nihao\"", "assert shuffle_string(\"aax\", [0,2,1]) == \"axa\"", "assert shuffle_string(\"gh\", [1,0]) == \"hg\"", "assert shuffle_string(\"\", []) == \"\"  # Edge case: empty string", "assert shuffle_string(\"xy\", [0,1]) == \"xy\"  # No shuffle required", "assert shuffle_string(\"pqrstuvwxyzabcdefghijklmno\", list(range(25, -1, -1))) == \"onmlkjihgfedcbazyxwvutsrqp\"  # Reverse shuffle"]}, {"author": "Calvin", "UUID": "ac641352-08d5-4950-8993-6a143da92ecf", "question": "You are given a string s and an integer k. You can choose one of the first k letters of s and append it at the end of the string.\n\nReturn the lexicographically smallest string you could have after applying the mentioned step any number of moves.\n", "examples": "Input: s = \"cba\", k = 1\nOutput: \"acb\"\n\nInput: s = \"baaca\", k = 3\nOutput: \"aaabc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef orderlyQueue(s: str, k: int) -> str:\n    if k == 1:\n        n = len(s)\n        ss = s + s\n        lex_min_str = s\n        for i in range(n):\n            lex_min_str = min(lex_min_str, ss[i:i + n])\n        return lex_min_str\n    \n    return \"\".join(sorted(s))\n", "asserts": ["assert orderlyQueue(\"abcd\", 1) == \"abcd\"", "assert orderlyQueue(\"hello\", 2) == \"ehllo\"", "assert orderlyQueue(\"programming\", 1) == \"ammingprogr\"", "assert orderlyQueue(\"rotator\", 1) == \"atorrot\"", "assert orderlyQueue(\"zxyabc\", 5) == \"abcxyz\"", "assert orderlyQueue(\"xy\", 2) == \"xy\""]}], "category": "String", "prompt_tokens": 755, "total_tokens": 1066, "completion_tokens": 311, "completion": "Given a non-empty string of lowercase letters and a non-negative integer representing a key, write a function that returns a new string obtained by shifting every letter in the input string by k positions in the alphabet, where k is the key. Letters should \"wrap\" around the alphabet; in other words, the letter `z` shifted by one returns `a`.\n\n###Code:\n\ndef caesar_cipher_encryptor(string: str, key: int) -> str:\n    new_letters = []\n    new_key = key % 26\n    for letter in string:\n        new_letter_code = ord(letter) + new_key\n        if new_letter_code <= 122:\n            new_letters.append(chr(new_letter_code))\n        else:\n            new_letters.append(chr(96 + new_letter_code % 122))\n    return \"\".join(new_letters)\n\n###Testcases:\n\nassert caesar_cipher_encryptor(\"xyz\", 2) == \"zab\"\nassert caesar_cipher_encryptor(\"abc\", 0) == \"abc\"  # No shift\nassert caesar_cipher_encryptor(\"abc\", 3) == \"def\"\nassert caesar_cipher_encryptor(\"z\", 1) == \"a\"\nassert caesar_cipher_encryptor(\"xyz\", 26) == \"xyz\"  # Full rotation\nassert caesar_cipher_encryptor(\"abc\", 52) == \"abc\"  # Double rotation\nassert caesar_cipher_encryptor(\"hello\", 57) == \"olssv\"  # Over rotation\n\n[/Example 3]", "temperature": 0.901}, {"few_shots": [{"author": "Calvin", "UUID": "87372a22-f5ef-4100-845b-28700ca3fde3", "question": "You are given a string s and an integer array indices of the same length. The string s will be shuffled such that the character at the ith position moves to indices[i] in the shuffled string.\n\nReturn the shuffled string.", "examples": "Input: s = \"codeleet\", indices = [4,5,6,7,0,2,1,3]\nOutput: \"leetcode\"\n\nInput: s = \"abc\", indices = [0,1,2]\nOutput: \"abc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "from typing import List\ndef shuffle_string(s: str, indices: List[int]) -> str:\n    def partitionString(s):\n      substrings = 1\n      cur_str = set()\n      for i in range(len(s)):\n        if s[i] in cur_str:\n          substrings += 1\n          cur_str = {s[i]}\n        else:\n          cur_str.add(s[i])\n      return substrings\n    ret = ['_']*len(s)\n    for idx, i in enumerate(indices):\n        ret[i] = s[idx]\n    return \"\".join(ret)\n", "asserts": ["assert shuffle_string(\"reoc\", [2, 0, 1, 3]) == \"eorc\"", "assert shuffle_string(\"aiohn\", [3,1,4,2,0]) == \"nihao\"", "assert shuffle_string(\"aax\", [0,2,1]) == \"axa\"", "assert shuffle_string(\"gh\", [1,0]) == \"hg\"", "assert shuffle_string(\"\", []) == \"\"  # Edge case: empty string", "assert shuffle_string(\"xy\", [0,1]) == \"xy\"  # No shuffle required", "assert shuffle_string(\"pqrstuvwxyzabcdefghijklmno\", list(range(25, -1, -1))) == \"onmlkjihgfedcbazyxwvutsrqp\"  # Reverse shuffle"]}, {"author": "Calvin", "UUID": "80e34b28-16a8-46ac-8b6a-ee28beb1e8d4", "question": "Write a function that reverses a string. The input string is given as an array of characters s.\n\nYou must do this by modifying the input array in-place with O(1) extra memory.", "examples": "Input: [\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput: [\"o\",\"l\",\"l\",\"e\",\"h\"]\n\nInput: [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\nOutput: [\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def reverse_string(s: list) -> list:\n  l = 0\n  r = len(s) - 1\n  while l < r:\n    tmp = s[l]\n    s[l] = s[r]\n    s[r] = tmp\n    l += 1\n    r -= 1\n  return s\n", "asserts": ["assert reverse_string([\"a\",\"b\",\"c\",\"d\"]) == [\"d\", \"c\", \"b\", \"a\"]", "assert reverse_string([\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"]) == [\"n\", \"o\", \"h\", \"t\", \"y\", \"p\"]", "assert reverse_string([]) == []", "assert reverse_string([\"s\", \"i\", \"n\", \"g\", \"l\", \"e\"]) == [\"e\", \"l\", \"g\", \"n\", \"i\", \"s\"]", "assert reverse_string([\"A\"]) == [\"A\"]", "assert reverse_string([\"9\", \"8\", \"7\", \"6\", \"5\", \"4\", \"3\", \"2\", \"1\"]) == [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]", "assert reverse_string([\"B\", \"o\", \"b\"]) == [\"b\", \"o\", \"B\"]", "assert reverse_string([\"r\", \"e\", \"v\", \"e\", \"r\", \"s\", \"e\"]) == [\"e\", \"s\", \"r\", \"e\", \"v\", \"e\", \"r\"]", "assert reverse_string([\"1\", \"*\", \"2\", \"*\", \"3\"]) == [\"3\", \"*\", \"2\", \"*\", \"1\"]"]}], "category": "String", "prompt_tokens": 920, "total_tokens": 1195, "completion_tokens": 275, "completion": "Create a function that checks if a string can be formed by rearranging the characters of another string. If it is possible, return true; otherwise, return false.\n\nYou may assume the input contains only lowercase alphabets.\n\n###Code: \n\ndef can_form_by_rearranging(original: str, target: str) -> bool:\n    from collections import Counter\n    return Counter(original) == Counter(target)\n\n###Testcases: \n\nassert can_form_by_rearranging(\"anagram\", \"nagaram\") == True\nassert can_form_by_rearranging(\"hello\", \"billion\") == False\nassert can_form_by_rearranging(\"aabbcc\", \"abcabc\") == True\nassert can_form_by_rearranging(\"rat\", \"car\") == False\nassert can_form_by_rearranging(\"\", \"\") == True  # Edge case: both strings are empty\nassert can_form_by_rearranging(\"xyz\", \"zyx\") == True\nassert can_form_by_rearranging(\"aaa\", \"aaaa\") == False  # Different number of characters\nassert can_form_by_rearranging(\"silent\", \"listen\") == True\nassert can_form_by_rearranging(\"triangle\", \"integral\") == True\nassert can_form_by_rearranging(\"elevenplus\", \"twelveplus\") == False\n\n[/Example 3]", "temperature": 0.839}, {"few_shots": [{"author": "Calvin", "UUID": "87372a22-f5ef-4100-845b-28700ca3fde3", "question": "You are given a string s and an integer array indices of the same length. The string s will be shuffled such that the character at the ith position moves to indices[i] in the shuffled string.\n\nReturn the shuffled string.", "examples": "Input: s = \"codeleet\", indices = [4,5,6,7,0,2,1,3]\nOutput: \"leetcode\"\n\nInput: s = \"abc\", indices = [0,1,2]\nOutput: \"abc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "from typing import List\ndef shuffle_string(s: str, indices: List[int]) -> str:\n    def partitionString(s):\n      substrings = 1\n      cur_str = set()\n      for i in range(len(s)):\n        if s[i] in cur_str:\n          substrings += 1\n          cur_str = {s[i]}\n        else:\n          cur_str.add(s[i])\n      return substrings\n    ret = ['_']*len(s)\n    for idx, i in enumerate(indices):\n        ret[i] = s[idx]\n    return \"\".join(ret)\n", "asserts": ["assert shuffle_string(\"reoc\", [2, 0, 1, 3]) == \"eorc\"", "assert shuffle_string(\"aiohn\", [3,1,4,2,0]) == \"nihao\"", "assert shuffle_string(\"aax\", [0,2,1]) == \"axa\"", "assert shuffle_string(\"gh\", [1,0]) == \"hg\"", "assert shuffle_string(\"\", []) == \"\"  # Edge case: empty string", "assert shuffle_string(\"xy\", [0,1]) == \"xy\"  # No shuffle required", "assert shuffle_string(\"pqrstuvwxyzabcdefghijklmno\", list(range(25, -1, -1))) == \"onmlkjihgfedcbazyxwvutsrqp\"  # Reverse shuffle"]}, {"author": "Calvin", "UUID": "80e34b28-16a8-46ac-8b6a-ee28beb1e8d4", "question": "Write a function that reverses a string. The input string is given as an array of characters s.\n\nYou must do this by modifying the input array in-place with O(1) extra memory.", "examples": "Input: [\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput: [\"o\",\"l\",\"l\",\"e\",\"h\"]\n\nInput: [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\nOutput: [\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def reverse_string(s: list) -> list:\n  l = 0\n  r = len(s) - 1\n  while l < r:\n    tmp = s[l]\n    s[l] = s[r]\n    s[r] = tmp\n    l += 1\n    r -= 1\n  return s\n", "asserts": ["assert reverse_string([\"a\",\"b\",\"c\",\"d\"]) == [\"d\", \"c\", \"b\", \"a\"]", "assert reverse_string([\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"]) == [\"n\", \"o\", \"h\", \"t\", \"y\", \"p\"]", "assert reverse_string([]) == []", "assert reverse_string([\"s\", \"i\", \"n\", \"g\", \"l\", \"e\"]) == [\"e\", \"l\", \"g\", \"n\", \"i\", \"s\"]", "assert reverse_string([\"A\"]) == [\"A\"]", "assert reverse_string([\"9\", \"8\", \"7\", \"6\", \"5\", \"4\", \"3\", \"2\", \"1\"]) == [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]", "assert reverse_string([\"B\", \"o\", \"b\"]) == [\"b\", \"o\", \"B\"]", "assert reverse_string([\"r\", \"e\", \"v\", \"e\", \"r\", \"s\", \"e\"]) == [\"e\", \"s\", \"r\", \"e\", \"v\", \"e\", \"r\"]", "assert reverse_string([\"1\", \"*\", \"2\", \"*\", \"3\"]) == [\"3\", \"*\", \"2\", \"*\", \"1\"]"]}], "category": "String", "prompt_tokens": 920, "total_tokens": 1178, "completion_tokens": 258, "completion": "Given a string containing just the characters '(' and ')', find the length of the longest valid (well-formed) parentheses substring.\n\n###Code:\n\ndef longest_valid_parentheses(s: str) -> int:\n    stack, result = [-1], 0\n    for i in range(len(s)):\n        if s[i] == '(':\n            stack.append(i)\n        else:\n            stack.pop()\n            if len(stack) == 0:\n                stack.append(i)\n            else:\n                result = max(result, i - stack[-1])\n    return result\n\n###Testcases:\n\nassert longest_valid_parentheses(\"(()\") == 2\nassert longest_valid_parentheses(\")()())\") == 4\nassert longest_valid_parentheses(\"\") == 0\nassert longest_valid_parentheses(\"()(()\") == 2\nassert longest_valid_parentheses(\"((()\") == 2\nassert longest_valid_parentheses(\"()()\") == 4\nassert longest_valid_parentheses(\"(()())\") == 6\nassert longest_valid_parentheses(\"(()\") == 2\nassert longest_valid_parentheses(\"()(()))))\") == 6\nassert longest_valid_parentheses(\")(\") == 0\n\n[/Example 3]", "temperature": 0.879}, {"few_shots": [{"author": "Calvin", "UUID": "87372a22-f5ef-4100-845b-28700ca3fde3", "question": "You are given a string s and an integer array indices of the same length. The string s will be shuffled such that the character at the ith position moves to indices[i] in the shuffled string.\n\nReturn the shuffled string.", "examples": "Input: s = \"codeleet\", indices = [4,5,6,7,0,2,1,3]\nOutput: \"leetcode\"\n\nInput: s = \"abc\", indices = [0,1,2]\nOutput: \"abc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "from typing import List\ndef shuffle_string(s: str, indices: List[int]) -> str:\n    def partitionString(s):\n      substrings = 1\n      cur_str = set()\n      for i in range(len(s)):\n        if s[i] in cur_str:\n          substrings += 1\n          cur_str = {s[i]}\n        else:\n          cur_str.add(s[i])\n      return substrings\n    ret = ['_']*len(s)\n    for idx, i in enumerate(indices):\n        ret[i] = s[idx]\n    return \"\".join(ret)\n", "asserts": ["assert shuffle_string(\"reoc\", [2, 0, 1, 3]) == \"eorc\"", "assert shuffle_string(\"aiohn\", [3,1,4,2,0]) == \"nihao\"", "assert shuffle_string(\"aax\", [0,2,1]) == \"axa\"", "assert shuffle_string(\"gh\", [1,0]) == \"hg\"", "assert shuffle_string(\"\", []) == \"\"  # Edge case: empty string", "assert shuffle_string(\"xy\", [0,1]) == \"xy\"  # No shuffle required", "assert shuffle_string(\"pqrstuvwxyzabcdefghijklmno\", list(range(25, -1, -1))) == \"onmlkjihgfedcbazyxwvutsrqp\"  # Reverse shuffle"]}, {"author": "Calvin", "UUID": "80e34b28-16a8-46ac-8b6a-ee28beb1e8d4", "question": "Write a function that reverses a string. The input string is given as an array of characters s.\n\nYou must do this by modifying the input array in-place with O(1) extra memory.", "examples": "Input: [\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput: [\"o\",\"l\",\"l\",\"e\",\"h\"]\n\nInput: [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\nOutput: [\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def reverse_string(s: list) -> list:\n  l = 0\n  r = len(s) - 1\n  while l < r:\n    tmp = s[l]\n    s[l] = s[r]\n    s[r] = tmp\n    l += 1\n    r -= 1\n  return s\n", "asserts": ["assert reverse_string([\"a\",\"b\",\"c\",\"d\"]) == [\"d\", \"c\", \"b\", \"a\"]", "assert reverse_string([\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"]) == [\"n\", \"o\", \"h\", \"t\", \"y\", \"p\"]", "assert reverse_string([]) == []", "assert reverse_string([\"s\", \"i\", \"n\", \"g\", \"l\", \"e\"]) == [\"e\", \"l\", \"g\", \"n\", \"i\", \"s\"]", "assert reverse_string([\"A\"]) == [\"A\"]", "assert reverse_string([\"9\", \"8\", \"7\", \"6\", \"5\", \"4\", \"3\", \"2\", \"1\"]) == [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]", "assert reverse_string([\"B\", \"o\", \"b\"]) == [\"b\", \"o\", \"B\"]", "assert reverse_string([\"r\", \"e\", \"v\", \"e\", \"r\", \"s\", \"e\"]) == [\"e\", \"s\", \"r\", \"e\", \"v\", \"e\", \"r\"]", "assert reverse_string([\"1\", \"*\", \"2\", \"*\", \"3\"]) == [\"3\", \"*\", \"2\", \"*\", \"1\"]"]}], "category": "String", "prompt_tokens": 920, "total_tokens": 1205, "completion_tokens": 285, "completion": "Write a Python function to check if a string is a palindrome. A string is a palindrome if it reads the same backward as forward. The function should be case insensitive and should ignore all non-alphanumeric characters.\n\n###Code: \n\ndef is_palindrome(s: str) -> bool:\n    filtered_chars = ''.join(filter(str.isalnum, s)).lower()\n    return filtered_chars == filtered_chars[::-1]\n\n###Testcases: \n\nassert is_palindrome(\"A man, a plan, a canal: Panama\") == True\nassert is_palindrome(\"race a car\") == False\nassert is_palindrome(\" \") == True  # Edge case: empty string considered palindrome\nassert is_palindrome(\"ab_a\") == True\nassert is_palindrome(\"0P\") == False  # Different characters when reversed\nassert is_palindrome(\"Never Odd or Even\") == True\nassert is_palindrome(\"madam\") == True\nassert is_palindrome(\"Do geese see God?\") == True\nassert is_palindrome(\"No lemon, no melon\") == True\nassert is_palindrome(\"Not a palindrome!\") == False\nassert is_palindrome(\"\") == True  # Edge case: empty string considered palindrome\nassert is_palindrome(\"123454321\") == True\nassert is_palindrome(\"1b1\") == True  # Ignore non-alphanumeric, case insensitive\n\n[/Example 3]", "temperature": 0.848}, {"few_shots": [{"author": "Calvin", "UUID": "87372a22-f5ef-4100-845b-28700ca3fde3", "question": "You are given a string s and an integer array indices of the same length. The string s will be shuffled such that the character at the ith position moves to indices[i] in the shuffled string.\n\nReturn the shuffled string.", "examples": "Input: s = \"codeleet\", indices = [4,5,6,7,0,2,1,3]\nOutput: \"leetcode\"\n\nInput: s = \"abc\", indices = [0,1,2]\nOutput: \"abc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "from typing import List\ndef shuffle_string(s: str, indices: List[int]) -> str:\n    def partitionString(s):\n      substrings = 1\n      cur_str = set()\n      for i in range(len(s)):\n        if s[i] in cur_str:\n          substrings += 1\n          cur_str = {s[i]}\n        else:\n          cur_str.add(s[i])\n      return substrings\n    ret = ['_']*len(s)\n    for idx, i in enumerate(indices):\n        ret[i] = s[idx]\n    return \"\".join(ret)\n", "asserts": ["assert shuffle_string(\"reoc\", [2, 0, 1, 3]) == \"eorc\"", "assert shuffle_string(\"aiohn\", [3,1,4,2,0]) == \"nihao\"", "assert shuffle_string(\"aax\", [0,2,1]) == \"axa\"", "assert shuffle_string(\"gh\", [1,0]) == \"hg\"", "assert shuffle_string(\"\", []) == \"\"  # Edge case: empty string", "assert shuffle_string(\"xy\", [0,1]) == \"xy\"  # No shuffle required", "assert shuffle_string(\"pqrstuvwxyzabcdefghijklmno\", list(range(25, -1, -1))) == \"onmlkjihgfedcbazyxwvutsrqp\"  # Reverse shuffle"]}, {"author": "Calvin", "UUID": "80e34b28-16a8-46ac-8b6a-ee28beb1e8d4", "question": "Write a function that reverses a string. The input string is given as an array of characters s.\n\nYou must do this by modifying the input array in-place with O(1) extra memory.", "examples": "Input: [\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput: [\"o\",\"l\",\"l\",\"e\",\"h\"]\n\nInput: [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\nOutput: [\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def reverse_string(s: list) -> list:\n  l = 0\n  r = len(s) - 1\n  while l < r:\n    tmp = s[l]\n    s[l] = s[r]\n    s[r] = tmp\n    l += 1\n    r -= 1\n  return s\n", "asserts": ["assert reverse_string([\"a\",\"b\",\"c\",\"d\"]) == [\"d\", \"c\", \"b\", \"a\"]", "assert reverse_string([\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"]) == [\"n\", \"o\", \"h\", \"t\", \"y\", \"p\"]", "assert reverse_string([]) == []", "assert reverse_string([\"s\", \"i\", \"n\", \"g\", \"l\", \"e\"]) == [\"e\", \"l\", \"g\", \"n\", \"i\", \"s\"]", "assert reverse_string([\"A\"]) == [\"A\"]", "assert reverse_string([\"9\", \"8\", \"7\", \"6\", \"5\", \"4\", \"3\", \"2\", \"1\"]) == [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]", "assert reverse_string([\"B\", \"o\", \"b\"]) == [\"b\", \"o\", \"B\"]", "assert reverse_string([\"r\", \"e\", \"v\", \"e\", \"r\", \"s\", \"e\"]) == [\"e\", \"s\", \"r\", \"e\", \"v\", \"e\", \"r\"]", "assert reverse_string([\"1\", \"*\", \"2\", \"*\", \"3\"]) == [\"3\", \"*\", \"2\", \"*\", \"1\"]"]}], "category": "String", "prompt_tokens": 920, "total_tokens": 1186, "completion_tokens": 266, "completion": "Write a function that checks if a given string is a valid palindrome, considering only alphanumeric characters and ignoring cases. Non-alphanumeric characters should be ignored.\n\nNote: For the purpose of this problem, an empty string is considered to be a valid palindrome.\n\n###Code:\n\ndef is_palindrome(s: str) -> bool:\n    filtered_chars = [c.lower() for c in s if c.isalnum()]\n    return filtered_chars == filtered_chars[::-1]\n\n###Testcases:\n\nassert is_palindrome(\"A man, a plan, a canal: Panama\") == True\nassert is_palindrome(\"race a car\") == False\nassert is_palindrome(\" \") == True  # considering an empty string as valid palindrome\nassert is_palindrome(\"0P\") == False\nassert is_palindrome(\"racecar\") == True\nassert is_palindrome(\"No lemon, no melon\") == True\nassert is_palindrome(\"Red roses\") == False\nassert is_palindrome(\"Was it a car or a cat I saw?\") == True\nassert is_palindrome(\"No 'x' in Nixon\") == True\nassert is_palindrome(\"Eva, can I see bees in a cave?\") == True\nassert is_palindrome(\"\") == True  # Edge case: empty string\n\n[/Example 3]", "temperature": 0.824}, {"few_shots": [{"author": "Calvin", "UUID": "87372a22-f5ef-4100-845b-28700ca3fde3", "question": "You are given a string s and an integer array indices of the same length. The string s will be shuffled such that the character at the ith position moves to indices[i] in the shuffled string.\n\nReturn the shuffled string.", "examples": "Input: s = \"codeleet\", indices = [4,5,6,7,0,2,1,3]\nOutput: \"leetcode\"\n\nInput: s = \"abc\", indices = [0,1,2]\nOutput: \"abc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "from typing import List\ndef shuffle_string(s: str, indices: List[int]) -> str:\n    def partitionString(s):\n      substrings = 1\n      cur_str = set()\n      for i in range(len(s)):\n        if s[i] in cur_str:\n          substrings += 1\n          cur_str = {s[i]}\n        else:\n          cur_str.add(s[i])\n      return substrings\n    ret = ['_']*len(s)\n    for idx, i in enumerate(indices):\n        ret[i] = s[idx]\n    return \"\".join(ret)\n", "asserts": ["assert shuffle_string(\"reoc\", [2, 0, 1, 3]) == \"eorc\"", "assert shuffle_string(\"aiohn\", [3,1,4,2,0]) == \"nihao\"", "assert shuffle_string(\"aax\", [0,2,1]) == \"axa\"", "assert shuffle_string(\"gh\", [1,0]) == \"hg\"", "assert shuffle_string(\"\", []) == \"\"  # Edge case: empty string", "assert shuffle_string(\"xy\", [0,1]) == \"xy\"  # No shuffle required", "assert shuffle_string(\"pqrstuvwxyzabcdefghijklmno\", list(range(25, -1, -1))) == \"onmlkjihgfedcbazyxwvutsrqp\"  # Reverse shuffle"]}, {"author": "Calvin", "UUID": "80e34b28-16a8-46ac-8b6a-ee28beb1e8d4", "question": "Write a function that reverses a string. The input string is given as an array of characters s.\n\nYou must do this by modifying the input array in-place with O(1) extra memory.", "examples": "Input: [\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput: [\"o\",\"l\",\"l\",\"e\",\"h\"]\n\nInput: [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\nOutput: [\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def reverse_string(s: list) -> list:\n  l = 0\n  r = len(s) - 1\n  while l < r:\n    tmp = s[l]\n    s[l] = s[r]\n    s[r] = tmp\n    l += 1\n    r -= 1\n  return s\n", "asserts": ["assert reverse_string([\"a\",\"b\",\"c\",\"d\"]) == [\"d\", \"c\", \"b\", \"a\"]", "assert reverse_string([\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"]) == [\"n\", \"o\", \"h\", \"t\", \"y\", \"p\"]", "assert reverse_string([]) == []", "assert reverse_string([\"s\", \"i\", \"n\", \"g\", \"l\", \"e\"]) == [\"e\", \"l\", \"g\", \"n\", \"i\", \"s\"]", "assert reverse_string([\"A\"]) == [\"A\"]", "assert reverse_string([\"9\", \"8\", \"7\", \"6\", \"5\", \"4\", \"3\", \"2\", \"1\"]) == [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]", "assert reverse_string([\"B\", \"o\", \"b\"]) == [\"b\", \"o\", \"B\"]", "assert reverse_string([\"r\", \"e\", \"v\", \"e\", \"r\", \"s\", \"e\"]) == [\"e\", \"s\", \"r\", \"e\", \"v\", \"e\", \"r\"]", "assert reverse_string([\"1\", \"*\", \"2\", \"*\", \"3\"]) == [\"3\", \"*\", \"2\", \"*\", \"1\"]"]}], "category": "String", "prompt_tokens": 920, "total_tokens": 1376, "completion_tokens": 456, "completion": "Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent when dialed on a telephone keypad. Return the combinations in any order.\n\nA mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.\n\n```\n2: abc\n3: def\n4: ghi\n5: jkl\n6: mno\n7: pqrs\n8: tuv\n9: wxyz\n```\n\n###Code:\n\n```python\nfrom typing import List\n\ndef letter_combinations(digits: str) -> List[str]:\n    if not digits:\n        return []\n\n    digit_to_char = {\n        '2': 'abc',\n        '3': 'def',\n        '4': 'ghi',\n        '5': 'jkl',\n        '6': 'mno',\n        '7': 'pqrs',\n        '8': 'tuv',\n        '9': 'wxyz'\n    }\n\n    def backtrack(index, path):\n        if index == len(digits):\n            combinations.append(''.join(path))\n            return\n        possible_letters = digit_to_char[digits[index]]\n        for letter in possible_letters:\n            path.append(letter)\n            backtrack(index + 1, path)\n            path.pop()\n\n    combinations = []\n    backtrack(0, [])\n    return combinations\n\n```\n\n###Testcases:\n\n```python\nassert set(letter_combinations(\"23\")) == set([\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"])\nassert set(letter_combinations(\"\")) == set([])\nassert set(letter_combinations(\"2\")) == set([\"a\",\"b\",\"c\"])\nassert set(letter_combinations(\"9\")) == set([\"w\",\"x\",\"y\",\"z\"])\nassert set(letter_combinations(\"78\")) == set([\"pt\", \"pu\", \"pv\", \"qt\", \"qu\", \"qv\", \"rt\", \"ru\", \"rv\", \"st\", \"su\", \"sv\"])\nassert set(letter_combinations(\"56\")) == set([\"jm\", \"jn\", \"jo\", \"km\", \"kn\", \"ko\", \"lm\", \"ln\", \"lo\"])\n```\n\n[/Example 3]", "temperature": 0.838}, {"few_shots": [{"author": "Calvin", "UUID": "87372a22-f5ef-4100-845b-28700ca3fde3", "question": "You are given a string s and an integer array indices of the same length. The string s will be shuffled such that the character at the ith position moves to indices[i] in the shuffled string.\n\nReturn the shuffled string.", "examples": "Input: s = \"codeleet\", indices = [4,5,6,7,0,2,1,3]\nOutput: \"leetcode\"\n\nInput: s = \"abc\", indices = [0,1,2]\nOutput: \"abc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "from typing import List\ndef shuffle_string(s: str, indices: List[int]) -> str:\n    def partitionString(s):\n      substrings = 1\n      cur_str = set()\n      for i in range(len(s)):\n        if s[i] in cur_str:\n          substrings += 1\n          cur_str = {s[i]}\n        else:\n          cur_str.add(s[i])\n      return substrings\n    ret = ['_']*len(s)\n    for idx, i in enumerate(indices):\n        ret[i] = s[idx]\n    return \"\".join(ret)\n", "asserts": ["assert shuffle_string(\"reoc\", [2, 0, 1, 3]) == \"eorc\"", "assert shuffle_string(\"aiohn\", [3,1,4,2,0]) == \"nihao\"", "assert shuffle_string(\"aax\", [0,2,1]) == \"axa\"", "assert shuffle_string(\"gh\", [1,0]) == \"hg\"", "assert shuffle_string(\"\", []) == \"\"  # Edge case: empty string", "assert shuffle_string(\"xy\", [0,1]) == \"xy\"  # No shuffle required", "assert shuffle_string(\"pqrstuvwxyzabcdefghijklmno\", list(range(25, -1, -1))) == \"onmlkjihgfedcbazyxwvutsrqp\"  # Reverse shuffle"]}, {"author": "Calvin", "UUID": "80e34b28-16a8-46ac-8b6a-ee28beb1e8d4", "question": "Write a function that reverses a string. The input string is given as an array of characters s.\n\nYou must do this by modifying the input array in-place with O(1) extra memory.", "examples": "Input: [\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput: [\"o\",\"l\",\"l\",\"e\",\"h\"]\n\nInput: [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\nOutput: [\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def reverse_string(s: list) -> list:\n  l = 0\n  r = len(s) - 1\n  while l < r:\n    tmp = s[l]\n    s[l] = s[r]\n    s[r] = tmp\n    l += 1\n    r -= 1\n  return s\n", "asserts": ["assert reverse_string([\"a\",\"b\",\"c\",\"d\"]) == [\"d\", \"c\", \"b\", \"a\"]", "assert reverse_string([\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"]) == [\"n\", \"o\", \"h\", \"t\", \"y\", \"p\"]", "assert reverse_string([]) == []", "assert reverse_string([\"s\", \"i\", \"n\", \"g\", \"l\", \"e\"]) == [\"e\", \"l\", \"g\", \"n\", \"i\", \"s\"]", "assert reverse_string([\"A\"]) == [\"A\"]", "assert reverse_string([\"9\", \"8\", \"7\", \"6\", \"5\", \"4\", \"3\", \"2\", \"1\"]) == [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]", "assert reverse_string([\"B\", \"o\", \"b\"]) == [\"b\", \"o\", \"B\"]", "assert reverse_string([\"r\", \"e\", \"v\", \"e\", \"r\", \"s\", \"e\"]) == [\"e\", \"s\", \"r\", \"e\", \"v\", \"e\", \"r\"]", "assert reverse_string([\"1\", \"*\", \"2\", \"*\", \"3\"]) == [\"3\", \"*\", \"2\", \"*\", \"1\"]"]}], "category": "String", "prompt_tokens": 920, "total_tokens": 1288, "completion_tokens": 368, "completion": "Given a string s, find the length of the longest substring without repeating characters.\n\n###Code:\n\ndef length_of_longest_substring(s: str) -> int:\n    char_map = {}\n    left = 0\n    max_length = 0\n    for right in range(len(s)):\n        if s[right] in char_map and char_map[s[right]] >= left:\n            left = char_map[s[right]] + 1\n        char_map[s[right]] = right\n        max_length = max(max_length, right - left + 1)\n    return max_length\n\n###Testcases:\n\nassert length_of_longest_substring(\"abcabcbb\") == 3  # The answer is \"abc\", with the length of 3.\nassert length_of_longest_substring(\"bbbbb\") == 1  # The answer is \"b\", with the length of 1.\nassert length_of_longest_substring(\"pwwkew\") == 3  # The answer is \"wke\", with the length of 3.\nassert length_of_longest_substring(\"\") == 0  # Edge case: empty string\nassert length_of_longest_substring(\" \") == 1  # Single character string\nassert length_of_longest_substring(\"au\") == 2  # All unique characters\nassert length_of_longest_substring(\"dvdf\") == 3  # The answer is \"vdf\", with the length of 3.\nassert length_of_longest_substring(\"anviaj\") == 5  # The answer is \"nviaj\", with the length of 5.\nassert length_of_longest_substring(\"abba\") == 2  # The answer is \"ab\" or \"ba\", with the length of 2.\n\n[/Example 3]", "temperature": 0.68}, {"few_shots": [{"author": "Calvin", "UUID": "87372a22-f5ef-4100-845b-28700ca3fde3", "question": "You are given a string s and an integer array indices of the same length. The string s will be shuffled such that the character at the ith position moves to indices[i] in the shuffled string.\n\nReturn the shuffled string.", "examples": "Input: s = \"codeleet\", indices = [4,5,6,7,0,2,1,3]\nOutput: \"leetcode\"\n\nInput: s = \"abc\", indices = [0,1,2]\nOutput: \"abc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "from typing import List\ndef shuffle_string(s: str, indices: List[int]) -> str:\n    def partitionString(s):\n      substrings = 1\n      cur_str = set()\n      for i in range(len(s)):\n        if s[i] in cur_str:\n          substrings += 1\n          cur_str = {s[i]}\n        else:\n          cur_str.add(s[i])\n      return substrings\n    ret = ['_']*len(s)\n    for idx, i in enumerate(indices):\n        ret[i] = s[idx]\n    return \"\".join(ret)\n", "asserts": ["assert shuffle_string(\"reoc\", [2, 0, 1, 3]) == \"eorc\"", "assert shuffle_string(\"aiohn\", [3,1,4,2,0]) == \"nihao\"", "assert shuffle_string(\"aax\", [0,2,1]) == \"axa\"", "assert shuffle_string(\"gh\", [1,0]) == \"hg\"", "assert shuffle_string(\"\", []) == \"\"  # Edge case: empty string", "assert shuffle_string(\"xy\", [0,1]) == \"xy\"  # No shuffle required", "assert shuffle_string(\"pqrstuvwxyzabcdefghijklmno\", list(range(25, -1, -1))) == \"onmlkjihgfedcbazyxwvutsrqp\"  # Reverse shuffle"]}, {"author": "Calvin", "UUID": "80e34b28-16a8-46ac-8b6a-ee28beb1e8d4", "question": "Write a function that reverses a string. The input string is given as an array of characters s.\n\nYou must do this by modifying the input array in-place with O(1) extra memory.", "examples": "Input: [\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput: [\"o\",\"l\",\"l\",\"e\",\"h\"]\n\nInput: [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\nOutput: [\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def reverse_string(s: list) -> list:\n  l = 0\n  r = len(s) - 1\n  while l < r:\n    tmp = s[l]\n    s[l] = s[r]\n    s[r] = tmp\n    l += 1\n    r -= 1\n  return s\n", "asserts": ["assert reverse_string([\"a\",\"b\",\"c\",\"d\"]) == [\"d\", \"c\", \"b\", \"a\"]", "assert reverse_string([\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"]) == [\"n\", \"o\", \"h\", \"t\", \"y\", \"p\"]", "assert reverse_string([]) == []", "assert reverse_string([\"s\", \"i\", \"n\", \"g\", \"l\", \"e\"]) == [\"e\", \"l\", \"g\", \"n\", \"i\", \"s\"]", "assert reverse_string([\"A\"]) == [\"A\"]", "assert reverse_string([\"9\", \"8\", \"7\", \"6\", \"5\", \"4\", \"3\", \"2\", \"1\"]) == [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]", "assert reverse_string([\"B\", \"o\", \"b\"]) == [\"b\", \"o\", \"B\"]", "assert reverse_string([\"r\", \"e\", \"v\", \"e\", \"r\", \"s\", \"e\"]) == [\"e\", \"s\", \"r\", \"e\", \"v\", \"e\", \"r\"]", "assert reverse_string([\"1\", \"*\", \"2\", \"*\", \"3\"]) == [\"3\", \"*\", \"2\", \"*\", \"1\"]"]}], "category": "String", "prompt_tokens": 920, "total_tokens": 1198, "completion_tokens": 278, "completion": "Given two strings s and goal, return true if and only if s can become goal after some number of shifts on s.\n\nA shift on s consists of moving the leftmost character of s to the rightmost position.\n\nFor example, if s = \"abcde\", then it will be \"bcdea\" after one shift.\n\n###Code: \n\ndef can_shift(s: str, goal: str) -> bool:\n    if len(s) != len(goal):\n        return False\n    return goal in s + s\n\n###Testcases: \n\nassert can_shift(\"abcde\", \"cdeab\") == True\nassert can_shift(\"abcde\", \"abced\") == False\nassert can_shift(\"aa\", \"a\") == False  # Different lengths\nassert can_shift(\"\", \"\") == True  # Both strings are empty\nassert can_shift(\"a\", \"a\") == True  # Both strings have length 1 and are equal\nassert can_shift(\"abcdefg\", \"efgabcd\") == True\nassert can_shift(\"xyz\", \"zxy\") == True\nassert can_shift(\"xyz\", \"yxz\") == False\nassert can_shift(\"abc\", \"bac\") == False\nassert can_shift(\"1abc2\", \"abc21\") == True\nassert can_shift(\"cool\", \"looc\") == True\n\n[/Example 3]", "temperature": 0.75}, {"few_shots": [{"author": "Calvin", "UUID": "87372a22-f5ef-4100-845b-28700ca3fde3", "question": "You are given a string s and an integer array indices of the same length. The string s will be shuffled such that the character at the ith position moves to indices[i] in the shuffled string.\n\nReturn the shuffled string.", "examples": "Input: s = \"codeleet\", indices = [4,5,6,7,0,2,1,3]\nOutput: \"leetcode\"\n\nInput: s = \"abc\", indices = [0,1,2]\nOutput: \"abc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "from typing import List\ndef shuffle_string(s: str, indices: List[int]) -> str:\n    def partitionString(s):\n      substrings = 1\n      cur_str = set()\n      for i in range(len(s)):\n        if s[i] in cur_str:\n          substrings += 1\n          cur_str = {s[i]}\n        else:\n          cur_str.add(s[i])\n      return substrings\n    ret = ['_']*len(s)\n    for idx, i in enumerate(indices):\n        ret[i] = s[idx]\n    return \"\".join(ret)\n", "asserts": ["assert shuffle_string(\"reoc\", [2, 0, 1, 3]) == \"eorc\"", "assert shuffle_string(\"aiohn\", [3,1,4,2,0]) == \"nihao\"", "assert shuffle_string(\"aax\", [0,2,1]) == \"axa\"", "assert shuffle_string(\"gh\", [1,0]) == \"hg\"", "assert shuffle_string(\"\", []) == \"\"  # Edge case: empty string", "assert shuffle_string(\"xy\", [0,1]) == \"xy\"  # No shuffle required", "assert shuffle_string(\"pqrstuvwxyzabcdefghijklmno\", list(range(25, -1, -1))) == \"onmlkjihgfedcbazyxwvutsrqp\"  # Reverse shuffle"]}, {"author": "Calvin", "UUID": "80e34b28-16a8-46ac-8b6a-ee28beb1e8d4", "question": "Write a function that reverses a string. The input string is given as an array of characters s.\n\nYou must do this by modifying the input array in-place with O(1) extra memory.", "examples": "Input: [\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput: [\"o\",\"l\",\"l\",\"e\",\"h\"]\n\nInput: [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\nOutput: [\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def reverse_string(s: list) -> list:\n  l = 0\n  r = len(s) - 1\n  while l < r:\n    tmp = s[l]\n    s[l] = s[r]\n    s[r] = tmp\n    l += 1\n    r -= 1\n  return s\n", "asserts": ["assert reverse_string([\"a\",\"b\",\"c\",\"d\"]) == [\"d\", \"c\", \"b\", \"a\"]", "assert reverse_string([\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"]) == [\"n\", \"o\", \"h\", \"t\", \"y\", \"p\"]", "assert reverse_string([]) == []", "assert reverse_string([\"s\", \"i\", \"n\", \"g\", \"l\", \"e\"]) == [\"e\", \"l\", \"g\", \"n\", \"i\", \"s\"]", "assert reverse_string([\"A\"]) == [\"A\"]", "assert reverse_string([\"9\", \"8\", \"7\", \"6\", \"5\", \"4\", \"3\", \"2\", \"1\"]) == [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]", "assert reverse_string([\"B\", \"o\", \"b\"]) == [\"b\", \"o\", \"B\"]", "assert reverse_string([\"r\", \"e\", \"v\", \"e\", \"r\", \"s\", \"e\"]) == [\"e\", \"s\", \"r\", \"e\", \"v\", \"e\", \"r\"]", "assert reverse_string([\"1\", \"*\", \"2\", \"*\", \"3\"]) == [\"3\", \"*\", \"2\", \"*\", \"1\"]"]}], "category": "String", "prompt_tokens": 920, "total_tokens": 1248, "completion_tokens": 328, "completion": "Given two strings s and goal, return true if and only if s can become goal after some number of shifts on s.\n\nA shift on s consists of moving the leftmost character of s to the rightmost position.\n\nFor example, if s = \"abcde\", then it will be \"bcdea\" after one shift.\n\n###Code:\n\n```python\ndef can_become_after_shift(s: str, goal: str) -> bool:\n    if len(s) != len(goal):\n        return False\n    if s == goal:\n        return True\n    for i in range(len(s)):\n        s = s[1:] + s[0]\n        if s == goal:\n            return True\n    return False\n```\n\n###Testcases:\n\n```python\nassert can_become_after_shift(\"abcde\", \"cdeab\") == True\nassert can_become_after_shift(\"abcde\", \"abced\") == False\nassert can_become_after_shift(\"xyz\", \"zyx\") == False\nassert can_become_after_shift(\"aaab\", \"baaa\") == True\nassert can_become_after_shift(\"\", \"\") == True  # Edge case: both strings are empty\nassert can_become_after_shift(\"a\", \"a\") == True  # Edge case: single-character strings\nassert can_become_after_shift(\"abc\", \"cab\") == True\nassert can_become_after_shift(\"clrwmpkwru\", \"wmpkwruclr\") == True\nassert can_become_after_shift(\"rotation\", \"tationro\") == True\n```\n\n[/Example 3]", "temperature": 0.778}, {"few_shots": [{"author": "Calvin", "UUID": "87372a22-f5ef-4100-845b-28700ca3fde3", "question": "You are given a string s and an integer array indices of the same length. The string s will be shuffled such that the character at the ith position moves to indices[i] in the shuffled string.\n\nReturn the shuffled string.", "examples": "Input: s = \"codeleet\", indices = [4,5,6,7,0,2,1,3]\nOutput: \"leetcode\"\n\nInput: s = \"abc\", indices = [0,1,2]\nOutput: \"abc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "from typing import List\ndef shuffle_string(s: str, indices: List[int]) -> str:\n    def partitionString(s):\n      substrings = 1\n      cur_str = set()\n      for i in range(len(s)):\n        if s[i] in cur_str:\n          substrings += 1\n          cur_str = {s[i]}\n        else:\n          cur_str.add(s[i])\n      return substrings\n    ret = ['_']*len(s)\n    for idx, i in enumerate(indices):\n        ret[i] = s[idx]\n    return \"\".join(ret)\n", "asserts": ["assert shuffle_string(\"reoc\", [2, 0, 1, 3]) == \"eorc\"", "assert shuffle_string(\"aiohn\", [3,1,4,2,0]) == \"nihao\"", "assert shuffle_string(\"aax\", [0,2,1]) == \"axa\"", "assert shuffle_string(\"gh\", [1,0]) == \"hg\"", "assert shuffle_string(\"\", []) == \"\"  # Edge case: empty string", "assert shuffle_string(\"xy\", [0,1]) == \"xy\"  # No shuffle required", "assert shuffle_string(\"pqrstuvwxyzabcdefghijklmno\", list(range(25, -1, -1))) == \"onmlkjihgfedcbazyxwvutsrqp\"  # Reverse shuffle"]}, {"author": "Calvin", "UUID": "80e34b28-16a8-46ac-8b6a-ee28beb1e8d4", "question": "Write a function that reverses a string. The input string is given as an array of characters s.\n\nYou must do this by modifying the input array in-place with O(1) extra memory.", "examples": "Input: [\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput: [\"o\",\"l\",\"l\",\"e\",\"h\"]\n\nInput: [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\nOutput: [\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def reverse_string(s: list) -> list:\n  l = 0\n  r = len(s) - 1\n  while l < r:\n    tmp = s[l]\n    s[l] = s[r]\n    s[r] = tmp\n    l += 1\n    r -= 1\n  return s\n", "asserts": ["assert reverse_string([\"a\",\"b\",\"c\",\"d\"]) == [\"d\", \"c\", \"b\", \"a\"]", "assert reverse_string([\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"]) == [\"n\", \"o\", \"h\", \"t\", \"y\", \"p\"]", "assert reverse_string([]) == []", "assert reverse_string([\"s\", \"i\", \"n\", \"g\", \"l\", \"e\"]) == [\"e\", \"l\", \"g\", \"n\", \"i\", \"s\"]", "assert reverse_string([\"A\"]) == [\"A\"]", "assert reverse_string([\"9\", \"8\", \"7\", \"6\", \"5\", \"4\", \"3\", \"2\", \"1\"]) == [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]", "assert reverse_string([\"B\", \"o\", \"b\"]) == [\"b\", \"o\", \"B\"]", "assert reverse_string([\"r\", \"e\", \"v\", \"e\", \"r\", \"s\", \"e\"]) == [\"e\", \"s\", \"r\", \"e\", \"v\", \"e\", \"r\"]", "assert reverse_string([\"1\", \"*\", \"2\", \"*\", \"3\"]) == [\"3\", \"*\", \"2\", \"*\", \"1\"]"]}], "category": "String", "prompt_tokens": 920, "total_tokens": 1170, "completion_tokens": 250, "completion": "Write a function that determines if a string contains all unique characters. Assume the string only contains lowercase English letters.\n\n###Code:\n\ndef is_unique(s: str) -> bool:\n    # A string cannot have all unique characters if its length exceeds 26 (the number of lowercase English letters)\n    if len(s) > 26:\n        return False\n        \n    char_set = set()\n    for char in s:\n        if char in char_set:\n            return False\n        char_set.add(char)\n    return True\n\n###Testcases:\n\nassert is_unique(\"abcdefg\") == True\nassert is_unique(\"hello\") == False  # 'l' is repeated\nassert is_unique(\"\") == True  # An empty string is considered to have all unique characters\nassert is_unique(\"uniqe\") == False  # 'u' is repeated\nassert is_unique(\"python\") == True\nassert is_unique(\"a\") == True\nassert is_unique(\"thequickbrownfxjmpsvlazydg\") == False  # Exceeds 26 characters, cannot be unique\nassert is_unique(\"algorithm\") == True\nassert is_unique(\"characters\") == False  # 'c' and 'a' are repeated\n\n[/Example 3]", "temperature": 0.792}, {"few_shots": [{"author": "Calvin", "UUID": "87372a22-f5ef-4100-845b-28700ca3fde3", "question": "You are given a string s and an integer array indices of the same length. The string s will be shuffled such that the character at the ith position moves to indices[i] in the shuffled string.\n\nReturn the shuffled string.", "examples": "Input: s = \"codeleet\", indices = [4,5,6,7,0,2,1,3]\nOutput: \"leetcode\"\n\nInput: s = \"abc\", indices = [0,1,2]\nOutput: \"abc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "from typing import List\ndef shuffle_string(s: str, indices: List[int]) -> str:\n    def partitionString(s):\n      substrings = 1\n      cur_str = set()\n      for i in range(len(s)):\n        if s[i] in cur_str:\n          substrings += 1\n          cur_str = {s[i]}\n        else:\n          cur_str.add(s[i])\n      return substrings\n    ret = ['_']*len(s)\n    for idx, i in enumerate(indices):\n        ret[i] = s[idx]\n    return \"\".join(ret)\n", "asserts": ["assert shuffle_string(\"reoc\", [2, 0, 1, 3]) == \"eorc\"", "assert shuffle_string(\"aiohn\", [3,1,4,2,0]) == \"nihao\"", "assert shuffle_string(\"aax\", [0,2,1]) == \"axa\"", "assert shuffle_string(\"gh\", [1,0]) == \"hg\"", "assert shuffle_string(\"\", []) == \"\"  # Edge case: empty string", "assert shuffle_string(\"xy\", [0,1]) == \"xy\"  # No shuffle required", "assert shuffle_string(\"pqrstuvwxyzabcdefghijklmno\", list(range(25, -1, -1))) == \"onmlkjihgfedcbazyxwvutsrqp\"  # Reverse shuffle"]}, {"author": "Calvin", "UUID": "d0ce7430-cfcd-4c69-b161-b3b2a186422c", "question": "Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.\n\nIn other words, return true if one of s1's permutations is the substring of s2.", "examples": "Input: s1 = \"ab\", s2 = \"eidbaooo\"\nOutput: True\n\nInput: s1 = \"ab\", s2 = \"eidboaoo\"\nOutput: False", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef permutation_in_string(s1: str, s2: str) -> bool:\n  window = len(s1)\n  if window > len(s2):\n    return False\n  freq1 = [0]*26\n  freq2 = [0]*26\n  for i in range(window):\n    freq1[ord(s1[i])-ord('a')] += 1\n    freq2[ord(s2[i])-ord('a')] += 1\n\n  matches = 0\n  for i in range(26):\n    if freq1[i] == freq2[i]:\n      matches += 1\n  \n  for l in range(len(s2) - window):\n    if matches == 26:\n      return True\n\n    added = ord(s2[l + window]) - ord('a')\n    freq2[added] += 1\n    if freq1[added] == freq2[added]:\n      matches += 1\n    elif freq1[added] + 1 == freq2[added]:\n      matches -= 1\n\n    removed = ord(s2[l]) - ord('a')\n    freq2[removed] -= 1\n    if freq1[removed] == freq2[removed]:\n      matches += 1\n    elif freq1[removed] == freq2[removed] + 1:\n      matches -= 1\n    \n  return matches == 26\n", "asserts": ["assert permutation_in_string(\"hello\", \"ooollehhhhh\") == True", "assert permutation_in_string(\"abc\", \"ccccbbbbaaaa\") == False", "assert permutation_in_string(\"xyz\", \"zxyopqrstuv\") == True", "assert permutation_in_string(\"xyz\", \"xzygxzyzxyzk\") == True", "assert permutation_in_string(\"a\", \"a\") == True", "assert permutation_in_string(\"adc\", \"dcda\") == True", "assert permutation_in_string(\"pq\", \"qpqqp\") == True", "assert permutation_in_string(\"kitten\", \"sittingkite\") == False", "assert permutation_in_string(\"pq\", \"pqpqr\") == True", "assert permutation_in_string(\"aba\", \"aabaabaa\") == True", "assert permutation_in_string(\"\", \"\") == True  # Edge case: both strings are empty", "assert permutation_in_string(\"longerstring\", \"short\") == False  # s1 is longer than s2", "assert permutation_in_string(\"a\", \"b\") == False  # Single character, no match", "assert permutation_in_string(\"aab\", \"baa\") == True  # s1 is a permutation of s2", "assert permutation_in_string(\"ab\", \"a\") == False  # s2 is shorter than s1", "assert permutation_in_string(\"ba\", \"eidbaooo\") == True  # Same characters as Example 1 but different permutation", "assert permutation_in_string(\"eid\", \"eidbaooo\") == True  # s1 is a prefix of s2", "assert permutation_in_string(\"ooo\", \"eidbaooo\") == True  # s1 is a suffix of s2", "assert permutation_in_string(\"db\", \"eidbaooo\") == True  # s1 is a permutation within s2", "assert permutation_in_string(\"eidoo\", \"eidbaooo\") == False  # s1 is longer than any permutation within s2"]}], "category": "String", "prompt_tokens": 1265, "total_tokens": 1822, "completion_tokens": 557, "completion": "Given a string s consisting only of characters 'a', 'b', and 'c', return the number of substrings containing at least one occurrence of all these characters exactly once.\n\n###Code:\n\n```python\ndef count_substrings_with_abc(s: str) -> int:\n    \"\"\"\n    Counts the number of substrings containing 'a', 'b', and 'c' exactly once.\n    \n    Parameters:\n    s (str): The input string consisting of characters 'a', 'b', and 'c' only.\n    \n    Returns:\n    int: The number of substrings that contain 'a', 'b', and 'c' exactly once.\n    \"\"\"\n    counts = { 'a': 0, 'b': 0, 'c': 0 }\n    left = 0\n    result = 0\n    \n    for right, char in enumerate(s):\n        if char in counts:\n            counts[char] += 1\n        \n        while all(counts.values()):\n            counts[s[left]] -= 1\n            left += 1\n        \n        if counts['a'] == 1 and counts['b'] == 1 and counts['c'] == 1:\n            result += left\n\n    return result\n```\n\n###Testcases:\n\n```python\nassert count_substrings_with_abc('abc') == 1\nassert count_substrings_with_abc('abbc') == 3\nassert count_substrings_with_abc('abccba') == 3\nassert count_substrings_with_abc('abcabc') == 10\nassert count_substrings_with_abc('aabbcc') == 0\nassert count_substrings_with_abc('abcabcabc') == 27\nassert count_substrings_with_abc('aaabbbccc') == 1\nassert count_substrings_with_abc('acbcbacabc') == 16\nassert count_substrings_with_abc('ccc') == 0  # No 'a' or 'b'\nassert count_substrings_with_abc('bbbaac') == 0  # No continuous substring containing 'abc'\nassert count_substrings_with_abc('aaabbbcccabc') == 18  # Mix of multiple substrings\nassert count_substrings_with_abc('') == 0  # Edge case: empty string\nassert count_substrings_with_abc('ab') == 0  # Edge case: string too short to contain 'abc'\nassert count_substrings_with_abc('abca') == 2  # Multiple occurrences of one character\nassert count_substrings_with_abc('abcabca') == 15  # Overlaps with multiple 'abc' sequences\n```\n\n[/Example 3]", "temperature": 0.932}, {"few_shots": [{"author": "Calvin", "UUID": "87372a22-f5ef-4100-845b-28700ca3fde3", "question": "You are given a string s and an integer array indices of the same length. The string s will be shuffled such that the character at the ith position moves to indices[i] in the shuffled string.\n\nReturn the shuffled string.", "examples": "Input: s = \"codeleet\", indices = [4,5,6,7,0,2,1,3]\nOutput: \"leetcode\"\n\nInput: s = \"abc\", indices = [0,1,2]\nOutput: \"abc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "from typing import List\ndef shuffle_string(s: str, indices: List[int]) -> str:\n    def partitionString(s):\n      substrings = 1\n      cur_str = set()\n      for i in range(len(s)):\n        if s[i] in cur_str:\n          substrings += 1\n          cur_str = {s[i]}\n        else:\n          cur_str.add(s[i])\n      return substrings\n    ret = ['_']*len(s)\n    for idx, i in enumerate(indices):\n        ret[i] = s[idx]\n    return \"\".join(ret)\n", "asserts": ["assert shuffle_string(\"reoc\", [2, 0, 1, 3]) == \"eorc\"", "assert shuffle_string(\"aiohn\", [3,1,4,2,0]) == \"nihao\"", "assert shuffle_string(\"aax\", [0,2,1]) == \"axa\"", "assert shuffle_string(\"gh\", [1,0]) == \"hg\"", "assert shuffle_string(\"\", []) == \"\"  # Edge case: empty string", "assert shuffle_string(\"xy\", [0,1]) == \"xy\"  # No shuffle required", "assert shuffle_string(\"pqrstuvwxyzabcdefghijklmno\", list(range(25, -1, -1))) == \"onmlkjihgfedcbazyxwvutsrqp\"  # Reverse shuffle"]}, {"author": "Calvin", "UUID": "d0ce7430-cfcd-4c69-b161-b3b2a186422c", "question": "Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.\n\nIn other words, return true if one of s1's permutations is the substring of s2.", "examples": "Input: s1 = \"ab\", s2 = \"eidbaooo\"\nOutput: True\n\nInput: s1 = \"ab\", s2 = \"eidboaoo\"\nOutput: False", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef permutation_in_string(s1: str, s2: str) -> bool:\n  window = len(s1)\n  if window > len(s2):\n    return False\n  freq1 = [0]*26\n  freq2 = [0]*26\n  for i in range(window):\n    freq1[ord(s1[i])-ord('a')] += 1\n    freq2[ord(s2[i])-ord('a')] += 1\n\n  matches = 0\n  for i in range(26):\n    if freq1[i] == freq2[i]:\n      matches += 1\n  \n  for l in range(len(s2) - window):\n    if matches == 26:\n      return True\n\n    added = ord(s2[l + window]) - ord('a')\n    freq2[added] += 1\n    if freq1[added] == freq2[added]:\n      matches += 1\n    elif freq1[added] + 1 == freq2[added]:\n      matches -= 1\n\n    removed = ord(s2[l]) - ord('a')\n    freq2[removed] -= 1\n    if freq1[removed] == freq2[removed]:\n      matches += 1\n    elif freq1[removed] == freq2[removed] + 1:\n      matches -= 1\n    \n  return matches == 26\n", "asserts": ["assert permutation_in_string(\"hello\", \"ooollehhhhh\") == True", "assert permutation_in_string(\"abc\", \"ccccbbbbaaaa\") == False", "assert permutation_in_string(\"xyz\", \"zxyopqrstuv\") == True", "assert permutation_in_string(\"xyz\", \"xzygxzyzxyzk\") == True", "assert permutation_in_string(\"a\", \"a\") == True", "assert permutation_in_string(\"adc\", \"dcda\") == True", "assert permutation_in_string(\"pq\", \"qpqqp\") == True", "assert permutation_in_string(\"kitten\", \"sittingkite\") == False", "assert permutation_in_string(\"pq\", \"pqpqr\") == True", "assert permutation_in_string(\"aba\", \"aabaabaa\") == True", "assert permutation_in_string(\"\", \"\") == True  # Edge case: both strings are empty", "assert permutation_in_string(\"longerstring\", \"short\") == False  # s1 is longer than s2", "assert permutation_in_string(\"a\", \"b\") == False  # Single character, no match", "assert permutation_in_string(\"aab\", \"baa\") == True  # s1 is a permutation of s2", "assert permutation_in_string(\"ab\", \"a\") == False  # s2 is shorter than s1", "assert permutation_in_string(\"ba\", \"eidbaooo\") == True  # Same characters as Example 1 but different permutation", "assert permutation_in_string(\"eid\", \"eidbaooo\") == True  # s1 is a prefix of s2", "assert permutation_in_string(\"ooo\", \"eidbaooo\") == True  # s1 is a suffix of s2", "assert permutation_in_string(\"db\", \"eidbaooo\") == True  # s1 is a permutation within s2", "assert permutation_in_string(\"eidoo\", \"eidbaooo\") == False  # s1 is longer than any permutation within s2"]}], "category": "String", "prompt_tokens": 1265, "total_tokens": 1887, "completion_tokens": 622, "completion": "Given a string s, write a function to check if it is a palindrome. A string is a palindrome when it reads the same backward as forward. The check should be case-insensitive and should ignore all non-alphanumeric characters.\n\n###Code:\n\ndef is_palindrome(s: str) -> bool:\n    def is_valid(c: str) -> bool:\n        return c.isalnum()\n    \n    def to_lower(c: str) -> str:\n        return c.lower()\n    \n    # Use two pointers to compare characters from the start and the end, moving toward the center\n    left, right = 0, len(s) - 1\n    \n    while left < right:\n        # skip non-alphanumeric characters\n        while left < right and not is_valid(s[left]):\n            left += 1\n        while right > left and not is_valid(s[right]):\n            right -= 1\n        \n        if to_lower(s[left]) != to_lower(s[right]):\n            return False\n        \n        left, right = left + 1, right - 1\n    \n    return True\n\n###Testcases:\n\nassert is_palindrome(\"A man, a plan, a canal: Panama\") == True\nassert is_palindrome(\"race a car\") == False\nassert is_palindrome(\" \") == True  # Empty string or string with only spaces should be considered a palindrome\nassert is_palindrome(\"No lemon, no melon\") == True\nassert is_palindrome(\"Was it a car or a cat I saw?\") == True\nassert is_palindrome(\"No 'x' in Nixon\") == True\nassert is_palindrome(\"Madam, in Eden, I'm Adam\") == True\nassert is_palindrome(\"Never odd or even.\") == True\nassert is_palindrome(\"Red roses run no risk, sir, on Nurse\u2019s order.\") == True\nassert is_palindrome(\"Eva, can I see bees in a cave?\") == True\nassert is_palindrome(\"No sir! Away! A papaya war is on.\") == True\nassert is_palindrome(\"1234321\") == True\nassert is_palindrome(\"12344321\") == True\nassert is_palindrome(\"1a2\") == False\nassert is_palindrome(\"Able was I ere I saw Elba\") == True\nassert is_palindrome(\"Straw? No, too stupid a fad, I put soot on warts.\") == True\nassert is_palindrome(\"Sit on a potato pan, Otis\") == True\nassert is_palindrome(\"123abccba321\") == True\nassert is_palindrome(\"1b1\") == True\nassert is_palindrome(\"1 b 1\") == True\nassert is_palindrome(\"1,b,1\") == True\nassert is_palindrome(\"racecar\") == True\nassert is_palindrome(\"step on no pets\") == True\nassert is_palindrome(\"put it up\") == True\nassert is_palindrome(\"Was it a rat I saw?\") == True\n\n[/Example 3]", "temperature": 0.858}, {"few_shots": [{"author": "Calvin", "UUID": "87372a22-f5ef-4100-845b-28700ca3fde3", "question": "You are given a string s and an integer array indices of the same length. The string s will be shuffled such that the character at the ith position moves to indices[i] in the shuffled string.\n\nReturn the shuffled string.", "examples": "Input: s = \"codeleet\", indices = [4,5,6,7,0,2,1,3]\nOutput: \"leetcode\"\n\nInput: s = \"abc\", indices = [0,1,2]\nOutput: \"abc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "from typing import List\ndef shuffle_string(s: str, indices: List[int]) -> str:\n    def partitionString(s):\n      substrings = 1\n      cur_str = set()\n      for i in range(len(s)):\n        if s[i] in cur_str:\n          substrings += 1\n          cur_str = {s[i]}\n        else:\n          cur_str.add(s[i])\n      return substrings\n    ret = ['_']*len(s)\n    for idx, i in enumerate(indices):\n        ret[i] = s[idx]\n    return \"\".join(ret)\n", "asserts": ["assert shuffle_string(\"reoc\", [2, 0, 1, 3]) == \"eorc\"", "assert shuffle_string(\"aiohn\", [3,1,4,2,0]) == \"nihao\"", "assert shuffle_string(\"aax\", [0,2,1]) == \"axa\"", "assert shuffle_string(\"gh\", [1,0]) == \"hg\"", "assert shuffle_string(\"\", []) == \"\"  # Edge case: empty string", "assert shuffle_string(\"xy\", [0,1]) == \"xy\"  # No shuffle required", "assert shuffle_string(\"pqrstuvwxyzabcdefghijklmno\", list(range(25, -1, -1))) == \"onmlkjihgfedcbazyxwvutsrqp\"  # Reverse shuffle"]}, {"author": "Calvin", "UUID": "d0ce7430-cfcd-4c69-b161-b3b2a186422c", "question": "Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.\n\nIn other words, return true if one of s1's permutations is the substring of s2.", "examples": "Input: s1 = \"ab\", s2 = \"eidbaooo\"\nOutput: True\n\nInput: s1 = \"ab\", s2 = \"eidboaoo\"\nOutput: False", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef permutation_in_string(s1: str, s2: str) -> bool:\n  window = len(s1)\n  if window > len(s2):\n    return False\n  freq1 = [0]*26\n  freq2 = [0]*26\n  for i in range(window):\n    freq1[ord(s1[i])-ord('a')] += 1\n    freq2[ord(s2[i])-ord('a')] += 1\n\n  matches = 0\n  for i in range(26):\n    if freq1[i] == freq2[i]:\n      matches += 1\n  \n  for l in range(len(s2) - window):\n    if matches == 26:\n      return True\n\n    added = ord(s2[l + window]) - ord('a')\n    freq2[added] += 1\n    if freq1[added] == freq2[added]:\n      matches += 1\n    elif freq1[added] + 1 == freq2[added]:\n      matches -= 1\n\n    removed = ord(s2[l]) - ord('a')\n    freq2[removed] -= 1\n    if freq1[removed] == freq2[removed]:\n      matches += 1\n    elif freq1[removed] == freq2[removed] + 1:\n      matches -= 1\n    \n  return matches == 26\n", "asserts": ["assert permutation_in_string(\"hello\", \"ooollehhhhh\") == True", "assert permutation_in_string(\"abc\", \"ccccbbbbaaaa\") == False", "assert permutation_in_string(\"xyz\", \"zxyopqrstuv\") == True", "assert permutation_in_string(\"xyz\", \"xzygxzyzxyzk\") == True", "assert permutation_in_string(\"a\", \"a\") == True", "assert permutation_in_string(\"adc\", \"dcda\") == True", "assert permutation_in_string(\"pq\", \"qpqqp\") == True", "assert permutation_in_string(\"kitten\", \"sittingkite\") == False", "assert permutation_in_string(\"pq\", \"pqpqr\") == True", "assert permutation_in_string(\"aba\", \"aabaabaa\") == True", "assert permutation_in_string(\"\", \"\") == True  # Edge case: both strings are empty", "assert permutation_in_string(\"longerstring\", \"short\") == False  # s1 is longer than s2", "assert permutation_in_string(\"a\", \"b\") == False  # Single character, no match", "assert permutation_in_string(\"aab\", \"baa\") == True  # s1 is a permutation of s2", "assert permutation_in_string(\"ab\", \"a\") == False  # s2 is shorter than s1", "assert permutation_in_string(\"ba\", \"eidbaooo\") == True  # Same characters as Example 1 but different permutation", "assert permutation_in_string(\"eid\", \"eidbaooo\") == True  # s1 is a prefix of s2", "assert permutation_in_string(\"ooo\", \"eidbaooo\") == True  # s1 is a suffix of s2", "assert permutation_in_string(\"db\", \"eidbaooo\") == True  # s1 is a permutation within s2", "assert permutation_in_string(\"eidoo\", \"eidbaooo\") == False  # s1 is longer than any permutation within s2"]}], "category": "String", "prompt_tokens": 1265, "total_tokens": 1916, "completion_tokens": 651, "completion": "Given a non-empty string s and an integer k, you are allowed to choose any character of the string and change it to any other uppercase English character. You can perform this operation at most k times.\n\nReturn the length of the longest substring containing the same letter you can get after performing the above operations.\n\n###Code: \n\ndef character_replacement(s: str, k: int) -> int:\n    count = {}\n    max_count = 0\n    max_length = 0\n    start = 0\n    \n    for end in range(len(s)):\n        count[s[end]] = count.get(s[end], 0) + 1\n        max_count = max(max_count, count[s[end]])\n        \n        while (end - start + 1) - max_count > k:\n            count[s[start]] -= 1\n            start += 1\n            \n        max_length = max(max_length, end - start + 1)\n        \n    return max_length\n\n###Testcases: \n\nassert character_replacement(\"ABAB\", 2) == 4\nassert character_replacement(\"AABABBA\", 1) == 4\nassert character_replacement(\"ABAA\", 0) == 2\nassert character_replacement(\"BAAA\", 0) == 3\nassert character_replacement(\"AAAB\", 1) == 4\nassert character_replacement(\"ABBB\", 2) == 4\nassert character_replacement(\"AAAA\", 2) == 4  # No need to replace any character\nassert character_replacement(\"ABCD\", 2) == 3  # Replace any two characters to form a substring of 3 identical letters\nassert character_replacement(\"ABCCDE\", 1) == 3  # Replace 'D' to 'C' to form \"ABCCCDE\"\nassert character_replacement(\"ABCDEFG\", 1) == 2  # Only one replacement allowed, so the longest substring is of length 2\nassert character_replacement(\"AABCD\", 1) == 3  # Replace 'C' to 'A' to form \"AAABD\"\nassert character_replacement(\"AABBCC\", 3) == 5  # Replace 'CC' to 'BB' to form \"AABBBB\"\nassert character_replacement(\"QQQQ\", 1) == 4  # All characters are the same, no need to replace\nassert character_replacement(\"XYZXYZ\", 2) == 3  # Replace any two characters to form a substring of 3 identical letters\nassert character_replacement(\"XXXYX\", 1) == 4  # Replace the last 'X' to 'Y' to form \"XXYYY\"\nassert character_replacement(\"A\", 5) == 1  # Single character string, no operation needed\nassert character_replacement(\"ABBA\", 1) == 3  # Replace one 'B' with 'A' to form \"AAAA\"\nassert character_replacement(\"ABACABA\", 1) == 3  # Replace 'C' with 'A' to form \"ABAAABA\"\n\n[/Example 3]", "temperature": 0.695}, {"few_shots": [{"author": "Calvin", "UUID": "87372a22-f5ef-4100-845b-28700ca3fde3", "question": "You are given a string s and an integer array indices of the same length. The string s will be shuffled such that the character at the ith position moves to indices[i] in the shuffled string.\n\nReturn the shuffled string.", "examples": "Input: s = \"codeleet\", indices = [4,5,6,7,0,2,1,3]\nOutput: \"leetcode\"\n\nInput: s = \"abc\", indices = [0,1,2]\nOutput: \"abc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "from typing import List\ndef shuffle_string(s: str, indices: List[int]) -> str:\n    def partitionString(s):\n      substrings = 1\n      cur_str = set()\n      for i in range(len(s)):\n        if s[i] in cur_str:\n          substrings += 1\n          cur_str = {s[i]}\n        else:\n          cur_str.add(s[i])\n      return substrings\n    ret = ['_']*len(s)\n    for idx, i in enumerate(indices):\n        ret[i] = s[idx]\n    return \"\".join(ret)\n", "asserts": ["assert shuffle_string(\"reoc\", [2, 0, 1, 3]) == \"eorc\"", "assert shuffle_string(\"aiohn\", [3,1,4,2,0]) == \"nihao\"", "assert shuffle_string(\"aax\", [0,2,1]) == \"axa\"", "assert shuffle_string(\"gh\", [1,0]) == \"hg\"", "assert shuffle_string(\"\", []) == \"\"  # Edge case: empty string", "assert shuffle_string(\"xy\", [0,1]) == \"xy\"  # No shuffle required", "assert shuffle_string(\"pqrstuvwxyzabcdefghijklmno\", list(range(25, -1, -1))) == \"onmlkjihgfedcbazyxwvutsrqp\"  # Reverse shuffle"]}, {"author": "Calvin", "UUID": "d0ce7430-cfcd-4c69-b161-b3b2a186422c", "question": "Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.\n\nIn other words, return true if one of s1's permutations is the substring of s2.", "examples": "Input: s1 = \"ab\", s2 = \"eidbaooo\"\nOutput: True\n\nInput: s1 = \"ab\", s2 = \"eidboaoo\"\nOutput: False", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef permutation_in_string(s1: str, s2: str) -> bool:\n  window = len(s1)\n  if window > len(s2):\n    return False\n  freq1 = [0]*26\n  freq2 = [0]*26\n  for i in range(window):\n    freq1[ord(s1[i])-ord('a')] += 1\n    freq2[ord(s2[i])-ord('a')] += 1\n\n  matches = 0\n  for i in range(26):\n    if freq1[i] == freq2[i]:\n      matches += 1\n  \n  for l in range(len(s2) - window):\n    if matches == 26:\n      return True\n\n    added = ord(s2[l + window]) - ord('a')\n    freq2[added] += 1\n    if freq1[added] == freq2[added]:\n      matches += 1\n    elif freq1[added] + 1 == freq2[added]:\n      matches -= 1\n\n    removed = ord(s2[l]) - ord('a')\n    freq2[removed] -= 1\n    if freq1[removed] == freq2[removed]:\n      matches += 1\n    elif freq1[removed] == freq2[removed] + 1:\n      matches -= 1\n    \n  return matches == 26\n", "asserts": ["assert permutation_in_string(\"hello\", \"ooollehhhhh\") == True", "assert permutation_in_string(\"abc\", \"ccccbbbbaaaa\") == False", "assert permutation_in_string(\"xyz\", \"zxyopqrstuv\") == True", "assert permutation_in_string(\"xyz\", \"xzygxzyzxyzk\") == True", "assert permutation_in_string(\"a\", \"a\") == True", "assert permutation_in_string(\"adc\", \"dcda\") == True", "assert permutation_in_string(\"pq\", \"qpqqp\") == True", "assert permutation_in_string(\"kitten\", \"sittingkite\") == False", "assert permutation_in_string(\"pq\", \"pqpqr\") == True", "assert permutation_in_string(\"aba\", \"aabaabaa\") == True", "assert permutation_in_string(\"\", \"\") == True  # Edge case: both strings are empty", "assert permutation_in_string(\"longerstring\", \"short\") == False  # s1 is longer than s2", "assert permutation_in_string(\"a\", \"b\") == False  # Single character, no match", "assert permutation_in_string(\"aab\", \"baa\") == True  # s1 is a permutation of s2", "assert permutation_in_string(\"ab\", \"a\") == False  # s2 is shorter than s1", "assert permutation_in_string(\"ba\", \"eidbaooo\") == True  # Same characters as Example 1 but different permutation", "assert permutation_in_string(\"eid\", \"eidbaooo\") == True  # s1 is a prefix of s2", "assert permutation_in_string(\"ooo\", \"eidbaooo\") == True  # s1 is a suffix of s2", "assert permutation_in_string(\"db\", \"eidbaooo\") == True  # s1 is a permutation within s2", "assert permutation_in_string(\"eidoo\", \"eidbaooo\") == False  # s1 is longer than any permutation within s2"]}], "category": "String", "prompt_tokens": 1265, "total_tokens": 1804, "completion_tokens": 539, "completion": "Given a string containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.\n\nAn input string is valid if:\n\n1. Open brackets must be closed by the same type of brackets.\n2. Open brackets must be closed in the correct order.\n\n###Code:\n\ndef is_valid_parentheses(s: str) -> bool:\n    stack = []\n    bracket_map = {')': '(', '}': '{', ']': '['}\n    for char in s:\n        if char in bracket_map.values():\n            stack.append(char)\n        elif char in bracket_map.keys():\n            if stack == [] or bracket_map[char] != stack.pop():\n                return False\n        else:\n            return False  # Invalid character\n    return stack == []\n\n###Testcases:\n\nassert is_valid_parentheses(\"()\") == True\nassert is_valid_parentheses(\"()[]{}\") == True\nassert is_valid_parentheses(\"(]\") == False\nassert is_valid_parentheses(\"([)]\") == False\nassert is_valid_parentheses(\"{[]}\") == True\nassert is_valid_parentheses(\"(({{[[]]}}))\") == True\nassert is_valid_parentheses(\"(){}[\") == False  # Missing closing bracket\nassert is_valid_parentheses(\"]\") == False  # Missing opening bracket\nassert is_valid_parentheses(\"{[]})\") == False  # Extra closing bracket\nassert is_valid_parentheses(\"({[)]}\") == False  # Incorrectly nested\nassert is_valid_parentheses(\"{[()]}\") == True  # Correctly nested\nassert is_valid_parentheses(\"\") == True  # Edge case: empty string\nassert is_valid_parentheses(\"([{}])\") == True  # Multiple types of brackets\nassert is_valid_parentheses(\"(((((())))))\") == True  # Many nested same type of brackets\nassert is_valid_parentheses(\"[][][](){}\") == True  # Many non-nested same type of brackets\nassert is_valid_parentheses(\"([)]{}\") == False  # Incorrect order\nassert is_valid_parentheses(\"{[(])}\") == False  # Incorrectly nested, correct types\nassert is_valid_parentheses(\"({[}])\") == False  # Incorrect types\nassert is_valid_parentheses(\"{\") == False  # Single unclosed bracket\nassert is_valid_parentheses(\"}\") == False  # Single unopened bracket\nassert is_valid_parentheses(\"({[{{}}]})\") == True  # Correctly nested complex pattern\n\n[/Example 3]", "temperature": 0.833}, {"few_shots": [{"author": "Calvin", "UUID": "87372a22-f5ef-4100-845b-28700ca3fde3", "question": "You are given a string s and an integer array indices of the same length. The string s will be shuffled such that the character at the ith position moves to indices[i] in the shuffled string.\n\nReturn the shuffled string.", "examples": "Input: s = \"codeleet\", indices = [4,5,6,7,0,2,1,3]\nOutput: \"leetcode\"\n\nInput: s = \"abc\", indices = [0,1,2]\nOutput: \"abc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "from typing import List\ndef shuffle_string(s: str, indices: List[int]) -> str:\n    def partitionString(s):\n      substrings = 1\n      cur_str = set()\n      for i in range(len(s)):\n        if s[i] in cur_str:\n          substrings += 1\n          cur_str = {s[i]}\n        else:\n          cur_str.add(s[i])\n      return substrings\n    ret = ['_']*len(s)\n    for idx, i in enumerate(indices):\n        ret[i] = s[idx]\n    return \"\".join(ret)\n", "asserts": ["assert shuffle_string(\"reoc\", [2, 0, 1, 3]) == \"eorc\"", "assert shuffle_string(\"aiohn\", [3,1,4,2,0]) == \"nihao\"", "assert shuffle_string(\"aax\", [0,2,1]) == \"axa\"", "assert shuffle_string(\"gh\", [1,0]) == \"hg\"", "assert shuffle_string(\"\", []) == \"\"  # Edge case: empty string", "assert shuffle_string(\"xy\", [0,1]) == \"xy\"  # No shuffle required", "assert shuffle_string(\"pqrstuvwxyzabcdefghijklmno\", list(range(25, -1, -1))) == \"onmlkjihgfedcbazyxwvutsrqp\"  # Reverse shuffle"]}, {"author": "Calvin", "UUID": "d0ce7430-cfcd-4c69-b161-b3b2a186422c", "question": "Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.\n\nIn other words, return true if one of s1's permutations is the substring of s2.", "examples": "Input: s1 = \"ab\", s2 = \"eidbaooo\"\nOutput: True\n\nInput: s1 = \"ab\", s2 = \"eidboaoo\"\nOutput: False", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef permutation_in_string(s1: str, s2: str) -> bool:\n  window = len(s1)\n  if window > len(s2):\n    return False\n  freq1 = [0]*26\n  freq2 = [0]*26\n  for i in range(window):\n    freq1[ord(s1[i])-ord('a')] += 1\n    freq2[ord(s2[i])-ord('a')] += 1\n\n  matches = 0\n  for i in range(26):\n    if freq1[i] == freq2[i]:\n      matches += 1\n  \n  for l in range(len(s2) - window):\n    if matches == 26:\n      return True\n\n    added = ord(s2[l + window]) - ord('a')\n    freq2[added] += 1\n    if freq1[added] == freq2[added]:\n      matches += 1\n    elif freq1[added] + 1 == freq2[added]:\n      matches -= 1\n\n    removed = ord(s2[l]) - ord('a')\n    freq2[removed] -= 1\n    if freq1[removed] == freq2[removed]:\n      matches += 1\n    elif freq1[removed] == freq2[removed] + 1:\n      matches -= 1\n    \n  return matches == 26\n", "asserts": ["assert permutation_in_string(\"hello\", \"ooollehhhhh\") == True", "assert permutation_in_string(\"abc\", \"ccccbbbbaaaa\") == False", "assert permutation_in_string(\"xyz\", \"zxyopqrstuv\") == True", "assert permutation_in_string(\"xyz\", \"xzygxzyzxyzk\") == True", "assert permutation_in_string(\"a\", \"a\") == True", "assert permutation_in_string(\"adc\", \"dcda\") == True", "assert permutation_in_string(\"pq\", \"qpqqp\") == True", "assert permutation_in_string(\"kitten\", \"sittingkite\") == False", "assert permutation_in_string(\"pq\", \"pqpqr\") == True", "assert permutation_in_string(\"aba\", \"aabaabaa\") == True", "assert permutation_in_string(\"\", \"\") == True  # Edge case: both strings are empty", "assert permutation_in_string(\"longerstring\", \"short\") == False  # s1 is longer than s2", "assert permutation_in_string(\"a\", \"b\") == False  # Single character, no match", "assert permutation_in_string(\"aab\", \"baa\") == True  # s1 is a permutation of s2", "assert permutation_in_string(\"ab\", \"a\") == False  # s2 is shorter than s1", "assert permutation_in_string(\"ba\", \"eidbaooo\") == True  # Same characters as Example 1 but different permutation", "assert permutation_in_string(\"eid\", \"eidbaooo\") == True  # s1 is a prefix of s2", "assert permutation_in_string(\"ooo\", \"eidbaooo\") == True  # s1 is a suffix of s2", "assert permutation_in_string(\"db\", \"eidbaooo\") == True  # s1 is a permutation within s2", "assert permutation_in_string(\"eidoo\", \"eidbaooo\") == False  # s1 is longer than any permutation within s2"]}], "category": "String", "prompt_tokens": 1265, "total_tokens": 1736, "completion_tokens": 471, "completion": "Write a function to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string \"\".\n\n###Code:\n\n\nfrom typing import List\n\ndef longest_common_prefix(strs: List[str]) -> str:\n    if not strs:\n        return \"\"\n    for i in range(len(strs[0])):\n        char = strs[0][i]\n        for string in strs[1:]:\n            if i == len(string) or string[i] != char:\n                return strs[0][:i]\n    return strs[0]\n\n###Test cases:\n\nassert longest_common_prefix([\"flower\", \"flow\", \"flight\"]) == \"fl\"\nassert longest_common_prefix([\"dog\", \"racecar\", \"car\"]) == \"\"\nassert longest_common_prefix([\"interspecies\", \"interstellar\", \"interstate\"]) == \"inters\"\nassert longest_common_prefix([\"throne\", \"throne\"]) == \"throne\"\nassert longest_common_prefix([\"throne\", \"dungeon\"]) == \"\"\nassert longest_common_prefix([\"\", \"\"]) == \"\"\nassert longest_common_prefix([\"a\"]) == \"a\"\nassert longest_common_prefix([\"\", \"b\"]) == \"\"\nassert longest_common_prefix([\"abc\", \"abcd\", \"ab\"]) == \"ab\"\nassert longest_common_prefix([\"prefix\", \"preach\"]) == \"pre\"\nassert longest_common_prefix([\"uncommon\", \"uncle\", \"untie\"]) == \"un\"\nassert longest_common_prefix([\"skate\", \"skateboarding\", \"skater\"]) == \"skate\"\nassert longest_common_prefix([\"refinish\", \"rethink\", \"reliable\"]) == \"re\"\nassert longest_common_prefix([\"\", \"notempty\", \"stillnotempty\"]) == \"\"\nassert longest_common_prefix([\"commonprefix\", \"commonsense\", \"commonwealth\"]) == \"common\"\nassert longest_common_prefix([\"nomatch\", \"nocommonality\"]) == \"no\"\nassert longest_common_prefix([\"longestpre\", \"longestprefix\", \"longest\"]) == \"longest\"\nassert longest_common_prefix([\"short\", \"longer\", \"shortest\"]) == \"short\"\nassert longest_common_prefix([\"classroom\", \"classy\", \"classicism\"]) == \"class\"\nassert longest_common_prefix([\"no\", \"common\", \"prefix\"]) == \"\"  # No common prefix\n\n[/Example 3]", "temperature": 0.892}, {"few_shots": [{"author": "Calvin", "UUID": "87372a22-f5ef-4100-845b-28700ca3fde3", "question": "You are given a string s and an integer array indices of the same length. The string s will be shuffled such that the character at the ith position moves to indices[i] in the shuffled string.\n\nReturn the shuffled string.", "examples": "Input: s = \"codeleet\", indices = [4,5,6,7,0,2,1,3]\nOutput: \"leetcode\"\n\nInput: s = \"abc\", indices = [0,1,2]\nOutput: \"abc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "from typing import List\ndef shuffle_string(s: str, indices: List[int]) -> str:\n    def partitionString(s):\n      substrings = 1\n      cur_str = set()\n      for i in range(len(s)):\n        if s[i] in cur_str:\n          substrings += 1\n          cur_str = {s[i]}\n        else:\n          cur_str.add(s[i])\n      return substrings\n    ret = ['_']*len(s)\n    for idx, i in enumerate(indices):\n        ret[i] = s[idx]\n    return \"\".join(ret)\n", "asserts": ["assert shuffle_string(\"reoc\", [2, 0, 1, 3]) == \"eorc\"", "assert shuffle_string(\"aiohn\", [3,1,4,2,0]) == \"nihao\"", "assert shuffle_string(\"aax\", [0,2,1]) == \"axa\"", "assert shuffle_string(\"gh\", [1,0]) == \"hg\"", "assert shuffle_string(\"\", []) == \"\"  # Edge case: empty string", "assert shuffle_string(\"xy\", [0,1]) == \"xy\"  # No shuffle required", "assert shuffle_string(\"pqrstuvwxyzabcdefghijklmno\", list(range(25, -1, -1))) == \"onmlkjihgfedcbazyxwvutsrqp\"  # Reverse shuffle"]}, {"author": "Calvin", "UUID": "d0ce7430-cfcd-4c69-b161-b3b2a186422c", "question": "Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.\n\nIn other words, return true if one of s1's permutations is the substring of s2.", "examples": "Input: s1 = \"ab\", s2 = \"eidbaooo\"\nOutput: True\n\nInput: s1 = \"ab\", s2 = \"eidboaoo\"\nOutput: False", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef permutation_in_string(s1: str, s2: str) -> bool:\n  window = len(s1)\n  if window > len(s2):\n    return False\n  freq1 = [0]*26\n  freq2 = [0]*26\n  for i in range(window):\n    freq1[ord(s1[i])-ord('a')] += 1\n    freq2[ord(s2[i])-ord('a')] += 1\n\n  matches = 0\n  for i in range(26):\n    if freq1[i] == freq2[i]:\n      matches += 1\n  \n  for l in range(len(s2) - window):\n    if matches == 26:\n      return True\n\n    added = ord(s2[l + window]) - ord('a')\n    freq2[added] += 1\n    if freq1[added] == freq2[added]:\n      matches += 1\n    elif freq1[added] + 1 == freq2[added]:\n      matches -= 1\n\n    removed = ord(s2[l]) - ord('a')\n    freq2[removed] -= 1\n    if freq1[removed] == freq2[removed]:\n      matches += 1\n    elif freq1[removed] == freq2[removed] + 1:\n      matches -= 1\n    \n  return matches == 26\n", "asserts": ["assert permutation_in_string(\"hello\", \"ooollehhhhh\") == True", "assert permutation_in_string(\"abc\", \"ccccbbbbaaaa\") == False", "assert permutation_in_string(\"xyz\", \"zxyopqrstuv\") == True", "assert permutation_in_string(\"xyz\", \"xzygxzyzxyzk\") == True", "assert permutation_in_string(\"a\", \"a\") == True", "assert permutation_in_string(\"adc\", \"dcda\") == True", "assert permutation_in_string(\"pq\", \"qpqqp\") == True", "assert permutation_in_string(\"kitten\", \"sittingkite\") == False", "assert permutation_in_string(\"pq\", \"pqpqr\") == True", "assert permutation_in_string(\"aba\", \"aabaabaa\") == True", "assert permutation_in_string(\"\", \"\") == True  # Edge case: both strings are empty", "assert permutation_in_string(\"longerstring\", \"short\") == False  # s1 is longer than s2", "assert permutation_in_string(\"a\", \"b\") == False  # Single character, no match", "assert permutation_in_string(\"aab\", \"baa\") == True  # s1 is a permutation of s2", "assert permutation_in_string(\"ab\", \"a\") == False  # s2 is shorter than s1", "assert permutation_in_string(\"ba\", \"eidbaooo\") == True  # Same characters as Example 1 but different permutation", "assert permutation_in_string(\"eid\", \"eidbaooo\") == True  # s1 is a prefix of s2", "assert permutation_in_string(\"ooo\", \"eidbaooo\") == True  # s1 is a suffix of s2", "assert permutation_in_string(\"db\", \"eidbaooo\") == True  # s1 is a permutation within s2", "assert permutation_in_string(\"eidoo\", \"eidbaooo\") == False  # s1 is longer than any permutation within s2"]}], "category": "String", "prompt_tokens": 1265, "total_tokens": 1675, "completion_tokens": 410, "completion": "Given a string s, write a function to check if it can form a palindrome by rearranging the letters.\n\nThe function should return true if the string can be rearranged to form a palindrome, and false otherwise.\n\n###Code:\n\ndef can_form_palindrome(s: str) -> bool:\n  letter_count = {}\n  for char in s:\n    letter_count[char] = letter_count.get(char, 0) + 1\n  odd_count = 0\n  for count in letter_count.values():\n    if count % 2 == 1:\n      odd_count += 1\n  return odd_count <= 1\n\n###Testcases:\n\nassert can_form_palindrome(\"carrace\") == True\nassert can_form_palindrome(\"aabbcc\") == True\nassert can_form_palindrome(\"a\") == True\nassert can_form_palindrome(\"code\") == False\nassert can_form_palindrome(\"\") == True  # Edge case: empty string\nassert can_form_palindrome(\"tactcoa\") == True\nassert can_form_palindrome(\"randomword\") == False\nassert can_form_palindrome(\"arceace\") == True\nassert can_form_palindrome(\"arceaceb\") == False\nassert can_form_palindrome(\"aabbhijkjihk\") == False\nassert can_form_palindrome(\"aabbccdd\") == True\nassert can_form_palindrome(\"abcabc\") == False\nassert can_form_palindrome(\"xyzzyx\") == True\nassert can_form_palindrome(\"xxyyzzwwu\") == False\nassert can_form_palindrome(\"madam\") == True\nassert can_form_palindrome(\"civic\") == True\nassert can_form_palindrome(\"ivicc\") == True\nassert can_form_palindrome(\"civil\") == False\nassert can_form_palindrome(\"livci\") == False\nassert can_form_palindrome(\"aaabbbb\") == True\nassert can_form_palindrome(\"aabbbccc\") == False\n\n[/Example 3]", "temperature": 0.934}, {"few_shots": [{"author": "Calvin", "UUID": "87372a22-f5ef-4100-845b-28700ca3fde3", "question": "You are given a string s and an integer array indices of the same length. The string s will be shuffled such that the character at the ith position moves to indices[i] in the shuffled string.\n\nReturn the shuffled string.", "examples": "Input: s = \"codeleet\", indices = [4,5,6,7,0,2,1,3]\nOutput: \"leetcode\"\n\nInput: s = \"abc\", indices = [0,1,2]\nOutput: \"abc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "from typing import List\ndef shuffle_string(s: str, indices: List[int]) -> str:\n    def partitionString(s):\n      substrings = 1\n      cur_str = set()\n      for i in range(len(s)):\n        if s[i] in cur_str:\n          substrings += 1\n          cur_str = {s[i]}\n        else:\n          cur_str.add(s[i])\n      return substrings\n    ret = ['_']*len(s)\n    for idx, i in enumerate(indices):\n        ret[i] = s[idx]\n    return \"\".join(ret)\n", "asserts": ["assert shuffle_string(\"reoc\", [2, 0, 1, 3]) == \"eorc\"", "assert shuffle_string(\"aiohn\", [3,1,4,2,0]) == \"nihao\"", "assert shuffle_string(\"aax\", [0,2,1]) == \"axa\"", "assert shuffle_string(\"gh\", [1,0]) == \"hg\"", "assert shuffle_string(\"\", []) == \"\"  # Edge case: empty string", "assert shuffle_string(\"xy\", [0,1]) == \"xy\"  # No shuffle required", "assert shuffle_string(\"pqrstuvwxyzabcdefghijklmno\", list(range(25, -1, -1))) == \"onmlkjihgfedcbazyxwvutsrqp\"  # Reverse shuffle"]}, {"author": "Calvin", "UUID": "d0ce7430-cfcd-4c69-b161-b3b2a186422c", "question": "Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.\n\nIn other words, return true if one of s1's permutations is the substring of s2.", "examples": "Input: s1 = \"ab\", s2 = \"eidbaooo\"\nOutput: True\n\nInput: s1 = \"ab\", s2 = \"eidboaoo\"\nOutput: False", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef permutation_in_string(s1: str, s2: str) -> bool:\n  window = len(s1)\n  if window > len(s2):\n    return False\n  freq1 = [0]*26\n  freq2 = [0]*26\n  for i in range(window):\n    freq1[ord(s1[i])-ord('a')] += 1\n    freq2[ord(s2[i])-ord('a')] += 1\n\n  matches = 0\n  for i in range(26):\n    if freq1[i] == freq2[i]:\n      matches += 1\n  \n  for l in range(len(s2) - window):\n    if matches == 26:\n      return True\n\n    added = ord(s2[l + window]) - ord('a')\n    freq2[added] += 1\n    if freq1[added] == freq2[added]:\n      matches += 1\n    elif freq1[added] + 1 == freq2[added]:\n      matches -= 1\n\n    removed = ord(s2[l]) - ord('a')\n    freq2[removed] -= 1\n    if freq1[removed] == freq2[removed]:\n      matches += 1\n    elif freq1[removed] == freq2[removed] + 1:\n      matches -= 1\n    \n  return matches == 26\n", "asserts": ["assert permutation_in_string(\"hello\", \"ooollehhhhh\") == True", "assert permutation_in_string(\"abc\", \"ccccbbbbaaaa\") == False", "assert permutation_in_string(\"xyz\", \"zxyopqrstuv\") == True", "assert permutation_in_string(\"xyz\", \"xzygxzyzxyzk\") == True", "assert permutation_in_string(\"a\", \"a\") == True", "assert permutation_in_string(\"adc\", \"dcda\") == True", "assert permutation_in_string(\"pq\", \"qpqqp\") == True", "assert permutation_in_string(\"kitten\", \"sittingkite\") == False", "assert permutation_in_string(\"pq\", \"pqpqr\") == True", "assert permutation_in_string(\"aba\", \"aabaabaa\") == True", "assert permutation_in_string(\"\", \"\") == True  # Edge case: both strings are empty", "assert permutation_in_string(\"longerstring\", \"short\") == False  # s1 is longer than s2", "assert permutation_in_string(\"a\", \"b\") == False  # Single character, no match", "assert permutation_in_string(\"aab\", \"baa\") == True  # s1 is a permutation of s2", "assert permutation_in_string(\"ab\", \"a\") == False  # s2 is shorter than s1", "assert permutation_in_string(\"ba\", \"eidbaooo\") == True  # Same characters as Example 1 but different permutation", "assert permutation_in_string(\"eid\", \"eidbaooo\") == True  # s1 is a prefix of s2", "assert permutation_in_string(\"ooo\", \"eidbaooo\") == True  # s1 is a suffix of s2", "assert permutation_in_string(\"db\", \"eidbaooo\") == True  # s1 is a permutation within s2", "assert permutation_in_string(\"eidoo\", \"eidbaooo\") == False  # s1 is longer than any permutation within s2"]}], "category": "String", "prompt_tokens": 1265, "total_tokens": 1698, "completion_tokens": 433, "completion": "Write a function that takes a non-empty string s and returns the longest palindromic substring in s.\n\n###Code:\n\n```python\ndef longest_palindrome(s: str) -> str:\n    def expand_around_center(left: int, right: int) -> str:\n        while left >= 0 and right < len(s) and s[left] == s[right]:\n            left -= 1\n            right += 1\n        return s[left + 1:right]\n    \n    longest = \"\"\n    for i in range(len(s)):\n        # Odd length palindrome\n        palindrome1 = expand_around_center(i, i)\n        # Even length palindrome\n        palindrome2 = expand_around_center(i, i + 1)\n        \n        # Check for the longest palindrome\n        if len(palindrome1) > len(longest):\n            longest = palindrome1\n        if len(palindrome2) > len(longest):\n            longest = palindrome2\n    \n    return longest\n\n###Testcases:\n\nassert longest_palindrome(\"babad\") == \"bab\" or longest_palindrome(\"babad\") == \"aba\"\nassert longest_palindrome(\"cbbd\") == \"bb\"\nassert longest_palindrome(\"a\") == \"a\"\nassert longest_palindrome(\"ac\") == \"a\" or longest_palindrome(\"ac\") == \"c\"\nassert longest_palindrome(\"racecar\") == \"racecar\"\nassert longest_palindrome(\"banana\") == \"anana\"\nassert longest_palindrome(\"million\") == \"illi\"\nassert longest_palindrome(\"tracecars\") == \"racecar\"\nassert longest_palindrome(\"abcd\") == \"a\" or longest_palindrome(\"abcd\") == \"b\" or longest_palindrome(\"abcd\") == \"c\" or longest_palindrome(\"abcd\") == \"d\"\nassert longest_palindrome(\"bb\") == \"bb\"\nassert longest_palindrome(\"anana\") == \"anana\"\nassert longest_palindrome(\"abccba\") == \"abccba\"\nassert longest_palindrome(\"forgeeksskeegfor\") == \"geeksskeeg\"\n```\n\n[/Example 3]", "temperature": 0.916}, {"few_shots": [{"author": "Calvin", "UUID": "87372a22-f5ef-4100-845b-28700ca3fde3", "question": "You are given a string s and an integer array indices of the same length. The string s will be shuffled such that the character at the ith position moves to indices[i] in the shuffled string.\n\nReturn the shuffled string.", "examples": "Input: s = \"codeleet\", indices = [4,5,6,7,0,2,1,3]\nOutput: \"leetcode\"\n\nInput: s = \"abc\", indices = [0,1,2]\nOutput: \"abc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "from typing import List\ndef shuffle_string(s: str, indices: List[int]) -> str:\n    def partitionString(s):\n      substrings = 1\n      cur_str = set()\n      for i in range(len(s)):\n        if s[i] in cur_str:\n          substrings += 1\n          cur_str = {s[i]}\n        else:\n          cur_str.add(s[i])\n      return substrings\n    ret = ['_']*len(s)\n    for idx, i in enumerate(indices):\n        ret[i] = s[idx]\n    return \"\".join(ret)\n", "asserts": ["assert shuffle_string(\"reoc\", [2, 0, 1, 3]) == \"eorc\"", "assert shuffle_string(\"aiohn\", [3,1,4,2,0]) == \"nihao\"", "assert shuffle_string(\"aax\", [0,2,1]) == \"axa\"", "assert shuffle_string(\"gh\", [1,0]) == \"hg\"", "assert shuffle_string(\"\", []) == \"\"  # Edge case: empty string", "assert shuffle_string(\"xy\", [0,1]) == \"xy\"  # No shuffle required", "assert shuffle_string(\"pqrstuvwxyzabcdefghijklmno\", list(range(25, -1, -1))) == \"onmlkjihgfedcbazyxwvutsrqp\"  # Reverse shuffle"]}, {"author": "Calvin", "UUID": "d0ce7430-cfcd-4c69-b161-b3b2a186422c", "question": "Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.\n\nIn other words, return true if one of s1's permutations is the substring of s2.", "examples": "Input: s1 = \"ab\", s2 = \"eidbaooo\"\nOutput: True\n\nInput: s1 = \"ab\", s2 = \"eidboaoo\"\nOutput: False", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef permutation_in_string(s1: str, s2: str) -> bool:\n  window = len(s1)\n  if window > len(s2):\n    return False\n  freq1 = [0]*26\n  freq2 = [0]*26\n  for i in range(window):\n    freq1[ord(s1[i])-ord('a')] += 1\n    freq2[ord(s2[i])-ord('a')] += 1\n\n  matches = 0\n  for i in range(26):\n    if freq1[i] == freq2[i]:\n      matches += 1\n  \n  for l in range(len(s2) - window):\n    if matches == 26:\n      return True\n\n    added = ord(s2[l + window]) - ord('a')\n    freq2[added] += 1\n    if freq1[added] == freq2[added]:\n      matches += 1\n    elif freq1[added] + 1 == freq2[added]:\n      matches -= 1\n\n    removed = ord(s2[l]) - ord('a')\n    freq2[removed] -= 1\n    if freq1[removed] == freq2[removed]:\n      matches += 1\n    elif freq1[removed] == freq2[removed] + 1:\n      matches -= 1\n    \n  return matches == 26\n", "asserts": ["assert permutation_in_string(\"hello\", \"ooollehhhhh\") == True", "assert permutation_in_string(\"abc\", \"ccccbbbbaaaa\") == False", "assert permutation_in_string(\"xyz\", \"zxyopqrstuv\") == True", "assert permutation_in_string(\"xyz\", \"xzygxzyzxyzk\") == True", "assert permutation_in_string(\"a\", \"a\") == True", "assert permutation_in_string(\"adc\", \"dcda\") == True", "assert permutation_in_string(\"pq\", \"qpqqp\") == True", "assert permutation_in_string(\"kitten\", \"sittingkite\") == False", "assert permutation_in_string(\"pq\", \"pqpqr\") == True", "assert permutation_in_string(\"aba\", \"aabaabaa\") == True", "assert permutation_in_string(\"\", \"\") == True  # Edge case: both strings are empty", "assert permutation_in_string(\"longerstring\", \"short\") == False  # s1 is longer than s2", "assert permutation_in_string(\"a\", \"b\") == False  # Single character, no match", "assert permutation_in_string(\"aab\", \"baa\") == True  # s1 is a permutation of s2", "assert permutation_in_string(\"ab\", \"a\") == False  # s2 is shorter than s1", "assert permutation_in_string(\"ba\", \"eidbaooo\") == True  # Same characters as Example 1 but different permutation", "assert permutation_in_string(\"eid\", \"eidbaooo\") == True  # s1 is a prefix of s2", "assert permutation_in_string(\"ooo\", \"eidbaooo\") == True  # s1 is a suffix of s2", "assert permutation_in_string(\"db\", \"eidbaooo\") == True  # s1 is a permutation within s2", "assert permutation_in_string(\"eidoo\", \"eidbaooo\") == False  # s1 is longer than any permutation within s2"]}], "category": "String", "prompt_tokens": 1265, "total_tokens": 1766, "completion_tokens": 501, "completion": "Given a string containing only three types of characters: '(', ')' and '*', write a function to check whether this string is valid. We define the validity of a string by these rules:\n\n1. Any left parenthesis '(' must have a corresponding right parenthesis ')'.\n2. Any right parenthesis ')' must have a corresponding left parenthesis '('.\n3. Left parenthesis '(' must go before the corresponding right parenthesis ')'.\n4. '*' could be treated as a single right parenthesis ')' or a single left parenthesis '(' or an empty string.\n5. An empty string is also valid.\n\nReturn true if the string is valid, otherwise return false.\n\n###Code: \n\ndef check_valid_string(s: str) -> bool:\n    balance_min = balance_max = 0\n    for char in s:\n        if char == '(':\n            balance_min += 1\n            balance_max += 1\n        elif char == ')':\n            balance_min = max(balance_min - 1, 0)\n            balance_max -= 1\n            if balance_max < 0:\n                return False\n        elif char == '*':\n            balance_min = max(balance_min - 1, 0)\n            balance_max += 1\n\n    return balance_min == 0\n\n###Testcases: \n\nassert check_valid_string(\"()\") == True\nassert check_valid_string(\"(*)\") == True\nassert check_valid_string(\"(*))\") == True\nassert check_valid_string(\"(*()\") == True\nassert check_valid_string(\")*()\") == False\nassert check_valid_string(\"(()\") == False\nassert check_valid_string(\"())\") == False\nassert check_valid_string(\"(*))*)\") == True\nassert check_valid_string(\"((*)\") == True\nassert check_valid_string(\"(*)*(**)\") == True\nassert check_valid_string(\"\") == True  # Edge case: empty string\nassert check_valid_string(\"(((((*)))**\") == True\nassert check_valid_string(\"(((((*)))\") == False\nassert check_valid_string(\"(())((())()()(*)(*()(())())())()()((()())((()))(*\") == False\nassert check_valid_string(\"*()(())*()(()()((()(()()*)(*(())((((((((()*)(()(*)\") == False\nassert check_valid_string(\"****\") == True  # All asterisks can be treated as empty\nassert check_valid_string(\"((((****))\") == True  # Asterisks balance uneven parentheses\n\n[/Example 3]", "temperature": 0.918}, {"few_shots": [{"author": "Calvin", "UUID": "87372a22-f5ef-4100-845b-28700ca3fde3", "question": "You are given a string s and an integer array indices of the same length. The string s will be shuffled such that the character at the ith position moves to indices[i] in the shuffled string.\n\nReturn the shuffled string.", "examples": "Input: s = \"codeleet\", indices = [4,5,6,7,0,2,1,3]\nOutput: \"leetcode\"\n\nInput: s = \"abc\", indices = [0,1,2]\nOutput: \"abc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "from typing import List\ndef shuffle_string(s: str, indices: List[int]) -> str:\n    def partitionString(s):\n      substrings = 1\n      cur_str = set()\n      for i in range(len(s)):\n        if s[i] in cur_str:\n          substrings += 1\n          cur_str = {s[i]}\n        else:\n          cur_str.add(s[i])\n      return substrings\n    ret = ['_']*len(s)\n    for idx, i in enumerate(indices):\n        ret[i] = s[idx]\n    return \"\".join(ret)\n", "asserts": ["assert shuffle_string(\"reoc\", [2, 0, 1, 3]) == \"eorc\"", "assert shuffle_string(\"aiohn\", [3,1,4,2,0]) == \"nihao\"", "assert shuffle_string(\"aax\", [0,2,1]) == \"axa\"", "assert shuffle_string(\"gh\", [1,0]) == \"hg\"", "assert shuffle_string(\"\", []) == \"\"  # Edge case: empty string", "assert shuffle_string(\"xy\", [0,1]) == \"xy\"  # No shuffle required", "assert shuffle_string(\"pqrstuvwxyzabcdefghijklmno\", list(range(25, -1, -1))) == \"onmlkjihgfedcbazyxwvutsrqp\"  # Reverse shuffle"]}, {"author": "Calvin", "UUID": "d0ce7430-cfcd-4c69-b161-b3b2a186422c", "question": "Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.\n\nIn other words, return true if one of s1's permutations is the substring of s2.", "examples": "Input: s1 = \"ab\", s2 = \"eidbaooo\"\nOutput: True\n\nInput: s1 = \"ab\", s2 = \"eidboaoo\"\nOutput: False", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef permutation_in_string(s1: str, s2: str) -> bool:\n  window = len(s1)\n  if window > len(s2):\n    return False\n  freq1 = [0]*26\n  freq2 = [0]*26\n  for i in range(window):\n    freq1[ord(s1[i])-ord('a')] += 1\n    freq2[ord(s2[i])-ord('a')] += 1\n\n  matches = 0\n  for i in range(26):\n    if freq1[i] == freq2[i]:\n      matches += 1\n  \n  for l in range(len(s2) - window):\n    if matches == 26:\n      return True\n\n    added = ord(s2[l + window]) - ord('a')\n    freq2[added] += 1\n    if freq1[added] == freq2[added]:\n      matches += 1\n    elif freq1[added] + 1 == freq2[added]:\n      matches -= 1\n\n    removed = ord(s2[l]) - ord('a')\n    freq2[removed] -= 1\n    if freq1[removed] == freq2[removed]:\n      matches += 1\n    elif freq1[removed] == freq2[removed] + 1:\n      matches -= 1\n    \n  return matches == 26\n", "asserts": ["assert permutation_in_string(\"hello\", \"ooollehhhhh\") == True", "assert permutation_in_string(\"abc\", \"ccccbbbbaaaa\") == False", "assert permutation_in_string(\"xyz\", \"zxyopqrstuv\") == True", "assert permutation_in_string(\"xyz\", \"xzygxzyzxyzk\") == True", "assert permutation_in_string(\"a\", \"a\") == True", "assert permutation_in_string(\"adc\", \"dcda\") == True", "assert permutation_in_string(\"pq\", \"qpqqp\") == True", "assert permutation_in_string(\"kitten\", \"sittingkite\") == False", "assert permutation_in_string(\"pq\", \"pqpqr\") == True", "assert permutation_in_string(\"aba\", \"aabaabaa\") == True", "assert permutation_in_string(\"\", \"\") == True  # Edge case: both strings are empty", "assert permutation_in_string(\"longerstring\", \"short\") == False  # s1 is longer than s2", "assert permutation_in_string(\"a\", \"b\") == False  # Single character, no match", "assert permutation_in_string(\"aab\", \"baa\") == True  # s1 is a permutation of s2", "assert permutation_in_string(\"ab\", \"a\") == False  # s2 is shorter than s1", "assert permutation_in_string(\"ba\", \"eidbaooo\") == True  # Same characters as Example 1 but different permutation", "assert permutation_in_string(\"eid\", \"eidbaooo\") == True  # s1 is a prefix of s2", "assert permutation_in_string(\"ooo\", \"eidbaooo\") == True  # s1 is a suffix of s2", "assert permutation_in_string(\"db\", \"eidbaooo\") == True  # s1 is a permutation within s2", "assert permutation_in_string(\"eidoo\", \"eidbaooo\") == False  # s1 is longer than any permutation within s2"]}], "category": "String", "prompt_tokens": 1265, "total_tokens": 1730, "completion_tokens": 465, "completion": "Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.\n\nAn input string is valid if:\n\n1. Open brackets must be closed by the same type of brackets.\n2. Open brackets must be closed in the correct order.\n\n###Code: \n\ndef is_valid_parentheses(s: str) -> bool:\n    stack = []\n    mapping = {')': '(', '}': '{', ']': '['}\n    for char in s:\n        if char in mapping:\n            top_element = stack.pop() if stack else '#'\n            if mapping[char] != top_element:\n                return False\n        else:\n            stack.append(char)\n    return not stack\n\n###Testcases: \n\nassert is_valid_parentheses(\"()\") == True\nassert is_valid_parentheses(\"()[]{}\") == True\nassert is_valid_parentheses(\"(]\") == False\nassert is_valid_parentheses(\"([)]\") == False\nassert is_valid_parentheses(\"{[]}\") == True\nassert is_valid_parentheses(\"{{{{}}}}\") == True\nassert is_valid_parentheses(\"(((())))\") == True\nassert is_valid_parentheses(\"({[({})]})\") == True\nassert is_valid_parentheses(\"\") == True  # Edge case: empty string\nassert is_valid_parentheses(\"{\") == False  # Single unmatched bracket\nassert is_valid_parentheses(\"}\") == False  # Single unmatched bracket\nassert is_valid_parentheses(\"{[}]\") == False  # Incorrectly nested\nassert is_valid_parentheses(\"{{)}\") == False  # Incorrectly nested\nassert is_valid_parentheses(\"{{([])}}\") == True  # Correctly nested complex example\nassert is_valid_parentheses(\"{{[(])}}\") == False  # Incorrectly nested complex example\nassert is_valid_parentheses(\"()()()()\") == True  # Repeated pattern\nassert is_valid_parentheses(\"(((({{{{[[[]]]}}}}))))\") == True  # Correct deep nesting\nassert is_valid_parentheses(\"(((({{{{[[[(]]]]}}}}))))\") == False  # Incorrect deep nesting\n\n[/Example 3]", "temperature": 0.894}, {"few_shots": [{"author": "Calvin", "UUID": "87372a22-f5ef-4100-845b-28700ca3fde3", "question": "You are given a string s and an integer array indices of the same length. The string s will be shuffled such that the character at the ith position moves to indices[i] in the shuffled string.\n\nReturn the shuffled string.", "examples": "Input: s = \"codeleet\", indices = [4,5,6,7,0,2,1,3]\nOutput: \"leetcode\"\n\nInput: s = \"abc\", indices = [0,1,2]\nOutput: \"abc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "from typing import List\ndef shuffle_string(s: str, indices: List[int]) -> str:\n    def partitionString(s):\n      substrings = 1\n      cur_str = set()\n      for i in range(len(s)):\n        if s[i] in cur_str:\n          substrings += 1\n          cur_str = {s[i]}\n        else:\n          cur_str.add(s[i])\n      return substrings\n    ret = ['_']*len(s)\n    for idx, i in enumerate(indices):\n        ret[i] = s[idx]\n    return \"\".join(ret)\n", "asserts": ["assert shuffle_string(\"reoc\", [2, 0, 1, 3]) == \"eorc\"", "assert shuffle_string(\"aiohn\", [3,1,4,2,0]) == \"nihao\"", "assert shuffle_string(\"aax\", [0,2,1]) == \"axa\"", "assert shuffle_string(\"gh\", [1,0]) == \"hg\"", "assert shuffle_string(\"\", []) == \"\"  # Edge case: empty string", "assert shuffle_string(\"xy\", [0,1]) == \"xy\"  # No shuffle required", "assert shuffle_string(\"pqrstuvwxyzabcdefghijklmno\", list(range(25, -1, -1))) == \"onmlkjihgfedcbazyxwvutsrqp\"  # Reverse shuffle"]}, {"author": "Calvin", "UUID": "56b48f6d-0d81-478d-b838-4d47b62d3031", "question": "Given an integer n, return the number of strings of length n that consist only of vowels (a, e, i, o, u) and are lexicographically sorted.\n\nA string s is lexicographically sorted if for all valid i, s[i] is the same as or comes before s[i+1] in the alphabet.", "examples": "Input: 1\nOutput: 5\n\nInput: 2\nOutput: 15", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def helper(n, letter_idx):\n  letters = [\"a\",\"e\",\"i\",\"o\",\"u\"]\n  dynamic = {\n      'a1' : 5,\n      'e1' : 4,\n      'i1' : 3,\n      'o1' : 2,\n      'u1' : 1\n  }\n  ret = 0\n  key = letters[letter_idx] + str(n)\n  if key in dynamic.keys():\n    return dynamic[key]\n  else:\n    for i in range(letter_idx, len(letters)):\n      ret += helper(n-1, i)\n    dynamic[key] = ret\n  return ret\n  \n\ndef countVowelStrings(n: int) -> int:\n  return helper(n, 0)\n", "asserts": ["assert countVowelStrings(3) == 35", "assert countVowelStrings(4) == 70", "assert countVowelStrings(5) == 126", "assert countVowelStrings(6) == 210", "assert countVowelStrings(7) == 330", "assert countVowelStrings(10) == 1001", "assert countVowelStrings(15) == 3876"]}], "category": "String", "prompt_tokens": 851, "total_tokens": 1232, "completion_tokens": 381, "completion": "Given a string s, you need to find the longest palindromic substring in s. You may assume that the maximum length of s is 1000, and there exists one unique longest palindromic substring.\n\n###Code: \n\ndef longest_palindromic_substring(s: str) -> str:\n    if len(s) == 0:\n        return \"\"\n    start, end = 0, 0\n    for i in range(len(s)):\n        len1 = expand_around_center(s, i, i)\n        len2 = expand_around_center(s, i, i + 1)\n        max_len = max(len1, len2)\n        if max_len > end - start:\n            start = i - (max_len - 1) // 2\n            end = i + max_len // 2\n    return s[start:end + 1]\n\ndef expand_around_center(s, left, right):\n    L, R = left, right\n    while L >= 0 and R < len(s) and s[L] == s[R]:\n        L -= 1\n        R += 1\n    return R - L - 1\n\n###Testcases: \n\nassert longest_palindromic_substring(\"babad\") == \"bab\"  # or \"aba\"\nassert longest_palindromic_substring(\"cbbd\") == \"bb\"\nassert longest_palindromic_substring(\"a\") == \"a\"\nassert longest_palindromic_substring(\"ac\") == \"a\"  # or \"c\"\nassert longest_palindromic_substring(\"racecar\") == \"racecar\"\nassert longest_palindromic_substring(\"amadam\") == \"madam\"\nassert longest_palindromic_substring(\"\") == \"\"  # Edge case: empty string\n\n[/Example 3]", "temperature": 0.769}, {"few_shots": [{"author": "Calvin", "UUID": "87372a22-f5ef-4100-845b-28700ca3fde3", "question": "You are given a string s and an integer array indices of the same length. The string s will be shuffled such that the character at the ith position moves to indices[i] in the shuffled string.\n\nReturn the shuffled string.", "examples": "Input: s = \"codeleet\", indices = [4,5,6,7,0,2,1,3]\nOutput: \"leetcode\"\n\nInput: s = \"abc\", indices = [0,1,2]\nOutput: \"abc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "from typing import List\ndef shuffle_string(s: str, indices: List[int]) -> str:\n    def partitionString(s):\n      substrings = 1\n      cur_str = set()\n      for i in range(len(s)):\n        if s[i] in cur_str:\n          substrings += 1\n          cur_str = {s[i]}\n        else:\n          cur_str.add(s[i])\n      return substrings\n    ret = ['_']*len(s)\n    for idx, i in enumerate(indices):\n        ret[i] = s[idx]\n    return \"\".join(ret)\n", "asserts": ["assert shuffle_string(\"reoc\", [2, 0, 1, 3]) == \"eorc\"", "assert shuffle_string(\"aiohn\", [3,1,4,2,0]) == \"nihao\"", "assert shuffle_string(\"aax\", [0,2,1]) == \"axa\"", "assert shuffle_string(\"gh\", [1,0]) == \"hg\"", "assert shuffle_string(\"\", []) == \"\"  # Edge case: empty string", "assert shuffle_string(\"xy\", [0,1]) == \"xy\"  # No shuffle required", "assert shuffle_string(\"pqrstuvwxyzabcdefghijklmno\", list(range(25, -1, -1))) == \"onmlkjihgfedcbazyxwvutsrqp\"  # Reverse shuffle"]}, {"author": "Calvin", "UUID": "56b48f6d-0d81-478d-b838-4d47b62d3031", "question": "Given an integer n, return the number of strings of length n that consist only of vowels (a, e, i, o, u) and are lexicographically sorted.\n\nA string s is lexicographically sorted if for all valid i, s[i] is the same as or comes before s[i+1] in the alphabet.", "examples": "Input: 1\nOutput: 5\n\nInput: 2\nOutput: 15", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def helper(n, letter_idx):\n  letters = [\"a\",\"e\",\"i\",\"o\",\"u\"]\n  dynamic = {\n      'a1' : 5,\n      'e1' : 4,\n      'i1' : 3,\n      'o1' : 2,\n      'u1' : 1\n  }\n  ret = 0\n  key = letters[letter_idx] + str(n)\n  if key in dynamic.keys():\n    return dynamic[key]\n  else:\n    for i in range(letter_idx, len(letters)):\n      ret += helper(n-1, i)\n    dynamic[key] = ret\n  return ret\n  \n\ndef countVowelStrings(n: int) -> int:\n  return helper(n, 0)\n", "asserts": ["assert countVowelStrings(3) == 35", "assert countVowelStrings(4) == 70", "assert countVowelStrings(5) == 126", "assert countVowelStrings(6) == 210", "assert countVowelStrings(7) == 330", "assert countVowelStrings(10) == 1001", "assert countVowelStrings(15) == 3876"]}], "category": "String", "prompt_tokens": 851, "total_tokens": 1211, "completion_tokens": 360, "completion": "Given a string s, find the length of the longest substring without repeating characters.\n\n###Code:\n\ndef length_of_longest_substring(s: str) -> int:\n    char_map = {}\n    left = 0\n    max_length = 0\n    \n    for right in range(len(s)):\n        if s[right] in char_map and char_map[s[right]] >= left:\n            left = char_map[s[right]] + 1\n        char_map[s[right]] = right\n        max_length = max(max_length, right - left + 1)\n    \n    return max_length\n\n###Testcases:\n\nassert length_of_longest_substring(\"abcabcbb\") == 3  # The answer is \"abc\", with the length of 3.\nassert length_of_longest_substring(\"bbbbb\") == 1  # The answer is \"b\", with the length of 1.\nassert length_of_longest_substring(\"pwwkew\") == 3  # The answer is \"wke\", with the length of 3.\nassert length_of_longest_substring(\"\") == 0  # The answer is \"\", with the length of 0.\nassert length_of_longest_substring(\" \") == 1  # The answer is \" \", with the length of 1.\nassert length_of_longest_substring(\"dvdf\") == 3  # The answer is \"vdf\", with the length of 3.\nassert length_of_longest_substring(\"abba\") == 2  # The answer is \"ab\", with the length of 2.\nassert length_of_longest_substring(\"nfpdmpi\") == 5  # The answer is \"fpdmi\", with the length of 5.\n\n[/Example 3]", "temperature": 0.769}, {"few_shots": [{"author": "Calvin", "UUID": "87372a22-f5ef-4100-845b-28700ca3fde3", "question": "You are given a string s and an integer array indices of the same length. The string s will be shuffled such that the character at the ith position moves to indices[i] in the shuffled string.\n\nReturn the shuffled string.", "examples": "Input: s = \"codeleet\", indices = [4,5,6,7,0,2,1,3]\nOutput: \"leetcode\"\n\nInput: s = \"abc\", indices = [0,1,2]\nOutput: \"abc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "from typing import List\ndef shuffle_string(s: str, indices: List[int]) -> str:\n    def partitionString(s):\n      substrings = 1\n      cur_str = set()\n      for i in range(len(s)):\n        if s[i] in cur_str:\n          substrings += 1\n          cur_str = {s[i]}\n        else:\n          cur_str.add(s[i])\n      return substrings\n    ret = ['_']*len(s)\n    for idx, i in enumerate(indices):\n        ret[i] = s[idx]\n    return \"\".join(ret)\n", "asserts": ["assert shuffle_string(\"reoc\", [2, 0, 1, 3]) == \"eorc\"", "assert shuffle_string(\"aiohn\", [3,1,4,2,0]) == \"nihao\"", "assert shuffle_string(\"aax\", [0,2,1]) == \"axa\"", "assert shuffle_string(\"gh\", [1,0]) == \"hg\"", "assert shuffle_string(\"\", []) == \"\"  # Edge case: empty string", "assert shuffle_string(\"xy\", [0,1]) == \"xy\"  # No shuffle required", "assert shuffle_string(\"pqrstuvwxyzabcdefghijklmno\", list(range(25, -1, -1))) == \"onmlkjihgfedcbazyxwvutsrqp\"  # Reverse shuffle"]}, {"author": "Calvin", "UUID": "56b48f6d-0d81-478d-b838-4d47b62d3031", "question": "Given an integer n, return the number of strings of length n that consist only of vowels (a, e, i, o, u) and are lexicographically sorted.\n\nA string s is lexicographically sorted if for all valid i, s[i] is the same as or comes before s[i+1] in the alphabet.", "examples": "Input: 1\nOutput: 5\n\nInput: 2\nOutput: 15", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def helper(n, letter_idx):\n  letters = [\"a\",\"e\",\"i\",\"o\",\"u\"]\n  dynamic = {\n      'a1' : 5,\n      'e1' : 4,\n      'i1' : 3,\n      'o1' : 2,\n      'u1' : 1\n  }\n  ret = 0\n  key = letters[letter_idx] + str(n)\n  if key in dynamic.keys():\n    return dynamic[key]\n  else:\n    for i in range(letter_idx, len(letters)):\n      ret += helper(n-1, i)\n    dynamic[key] = ret\n  return ret\n  \n\ndef countVowelStrings(n: int) -> int:\n  return helper(n, 0)\n", "asserts": ["assert countVowelStrings(3) == 35", "assert countVowelStrings(4) == 70", "assert countVowelStrings(5) == 126", "assert countVowelStrings(6) == 210", "assert countVowelStrings(7) == 330", "assert countVowelStrings(10) == 1001", "assert countVowelStrings(15) == 3876"]}], "category": "String", "prompt_tokens": 851, "total_tokens": 1109, "completion_tokens": 258, "completion": "Given two strings, base and remove, return a new string where all occurrences of the string remove have been removed from the base. If the string remove does not appear in base, return the base string unchanged. The matching should be case-sensitive.\n\n###Code: \n\ndef removeOccurrences(base: str, remove: str) -> str:\n    while remove in base:\n        base = base.replace(remove, \"\", 1)  # Remove only one occurrence at a time\n    return base\n\n###Testcases: \n\nassert removeOccurrences(\"daabcbaabcbc\", \"abc\") == \"dab\"\nassert removeOccurrences(\"axxyxx\", \"xx\") == \"ay\"\nassert removeOccurrences(\"abababab\", \"abab\") == \"ab\"\nassert removeOccurrences(\"teststring\", \"test\") == \"string\"\nassert removeOccurrences(\"hellohello\", \"hello\") == \"\"\nassert removeOccurrences(\"mississippi\", \"iss\") == \"mippi\"\nassert removeOccurrences(\"foobarbarfoo\", \"bar\") == \"foofoo\"\nassert removeOccurrences(\"abc\", \"def\") == \"abc\"  # 'remove' does not exist in 'base'\nassert removeOccurrences(\"aaa\", \"a\") == \"\"  # All characters are removed\n\n[/Example 3]", "temperature": 0.895}, {"few_shots": [{"author": "Calvin", "UUID": "87372a22-f5ef-4100-845b-28700ca3fde3", "question": "You are given a string s and an integer array indices of the same length. The string s will be shuffled such that the character at the ith position moves to indices[i] in the shuffled string.\n\nReturn the shuffled string.", "examples": "Input: s = \"codeleet\", indices = [4,5,6,7,0,2,1,3]\nOutput: \"leetcode\"\n\nInput: s = \"abc\", indices = [0,1,2]\nOutput: \"abc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "from typing import List\ndef shuffle_string(s: str, indices: List[int]) -> str:\n    def partitionString(s):\n      substrings = 1\n      cur_str = set()\n      for i in range(len(s)):\n        if s[i] in cur_str:\n          substrings += 1\n          cur_str = {s[i]}\n        else:\n          cur_str.add(s[i])\n      return substrings\n    ret = ['_']*len(s)\n    for idx, i in enumerate(indices):\n        ret[i] = s[idx]\n    return \"\".join(ret)\n", "asserts": ["assert shuffle_string(\"reoc\", [2, 0, 1, 3]) == \"eorc\"", "assert shuffle_string(\"aiohn\", [3,1,4,2,0]) == \"nihao\"", "assert shuffle_string(\"aax\", [0,2,1]) == \"axa\"", "assert shuffle_string(\"gh\", [1,0]) == \"hg\"", "assert shuffle_string(\"\", []) == \"\"  # Edge case: empty string", "assert shuffle_string(\"xy\", [0,1]) == \"xy\"  # No shuffle required", "assert shuffle_string(\"pqrstuvwxyzabcdefghijklmno\", list(range(25, -1, -1))) == \"onmlkjihgfedcbazyxwvutsrqp\"  # Reverse shuffle"]}, {"author": "Calvin", "UUID": "56b48f6d-0d81-478d-b838-4d47b62d3031", "question": "Given an integer n, return the number of strings of length n that consist only of vowels (a, e, i, o, u) and are lexicographically sorted.\n\nA string s is lexicographically sorted if for all valid i, s[i] is the same as or comes before s[i+1] in the alphabet.", "examples": "Input: 1\nOutput: 5\n\nInput: 2\nOutput: 15", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def helper(n, letter_idx):\n  letters = [\"a\",\"e\",\"i\",\"o\",\"u\"]\n  dynamic = {\n      'a1' : 5,\n      'e1' : 4,\n      'i1' : 3,\n      'o1' : 2,\n      'u1' : 1\n  }\n  ret = 0\n  key = letters[letter_idx] + str(n)\n  if key in dynamic.keys():\n    return dynamic[key]\n  else:\n    for i in range(letter_idx, len(letters)):\n      ret += helper(n-1, i)\n    dynamic[key] = ret\n  return ret\n  \n\ndef countVowelStrings(n: int) -> int:\n  return helper(n, 0)\n", "asserts": ["assert countVowelStrings(3) == 35", "assert countVowelStrings(4) == 70", "assert countVowelStrings(5) == 126", "assert countVowelStrings(6) == 210", "assert countVowelStrings(7) == 330", "assert countVowelStrings(10) == 1001", "assert countVowelStrings(15) == 3876"]}], "category": "String", "prompt_tokens": 851, "total_tokens": 1074, "completion_tokens": 223, "completion": "Write a function to check if a string contains all unique characters. Assume the string contains only ASCII characters.\n\n###Code: \n\ndef is_unique(s: str) -> bool:\n    if len(s) > 128:  # There are 128 different ASCII characters\n        return False\n    char_set = [False] * 128\n    for char in s:\n        val = ord(char)\n        if char_set[val]:\n            return False\n        char_set[val] = True\n    return True\n\n###Testcases: \n\nassert is_unique(\"abcdef\") == True\nassert is_unique(\"aabbcc\") == False\nassert is_unique(\"abcABC\") == True\nassert is_unique(\"1234567890\") == True\nassert is_unique(\"AaBbCc123!\") == True\nassert is_unique(\"!@#$%^&*()_+\") == True\nassert is_unique(\"The quick brown fox jumps over the lazy dog\") == False  # Contains every letter of the alphabet\nassert is_unique(\"\") == True  # Edge case: empty string\n\n[/Example 3]", "temperature": 0.669}, {"few_shots": [{"author": "Calvin", "UUID": "87372a22-f5ef-4100-845b-28700ca3fde3", "question": "You are given a string s and an integer array indices of the same length. The string s will be shuffled such that the character at the ith position moves to indices[i] in the shuffled string.\n\nReturn the shuffled string.", "examples": "Input: s = \"codeleet\", indices = [4,5,6,7,0,2,1,3]\nOutput: \"leetcode\"\n\nInput: s = \"abc\", indices = [0,1,2]\nOutput: \"abc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "from typing import List\ndef shuffle_string(s: str, indices: List[int]) -> str:\n    def partitionString(s):\n      substrings = 1\n      cur_str = set()\n      for i in range(len(s)):\n        if s[i] in cur_str:\n          substrings += 1\n          cur_str = {s[i]}\n        else:\n          cur_str.add(s[i])\n      return substrings\n    ret = ['_']*len(s)\n    for idx, i in enumerate(indices):\n        ret[i] = s[idx]\n    return \"\".join(ret)\n", "asserts": ["assert shuffle_string(\"reoc\", [2, 0, 1, 3]) == \"eorc\"", "assert shuffle_string(\"aiohn\", [3,1,4,2,0]) == \"nihao\"", "assert shuffle_string(\"aax\", [0,2,1]) == \"axa\"", "assert shuffle_string(\"gh\", [1,0]) == \"hg\"", "assert shuffle_string(\"\", []) == \"\"  # Edge case: empty string", "assert shuffle_string(\"xy\", [0,1]) == \"xy\"  # No shuffle required", "assert shuffle_string(\"pqrstuvwxyzabcdefghijklmno\", list(range(25, -1, -1))) == \"onmlkjihgfedcbazyxwvutsrqp\"  # Reverse shuffle"]}, {"author": "Calvin", "UUID": "56b48f6d-0d81-478d-b838-4d47b62d3031", "question": "Given an integer n, return the number of strings of length n that consist only of vowels (a, e, i, o, u) and are lexicographically sorted.\n\nA string s is lexicographically sorted if for all valid i, s[i] is the same as or comes before s[i+1] in the alphabet.", "examples": "Input: 1\nOutput: 5\n\nInput: 2\nOutput: 15", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def helper(n, letter_idx):\n  letters = [\"a\",\"e\",\"i\",\"o\",\"u\"]\n  dynamic = {\n      'a1' : 5,\n      'e1' : 4,\n      'i1' : 3,\n      'o1' : 2,\n      'u1' : 1\n  }\n  ret = 0\n  key = letters[letter_idx] + str(n)\n  if key in dynamic.keys():\n    return dynamic[key]\n  else:\n    for i in range(letter_idx, len(letters)):\n      ret += helper(n-1, i)\n    dynamic[key] = ret\n  return ret\n  \n\ndef countVowelStrings(n: int) -> int:\n  return helper(n, 0)\n", "asserts": ["assert countVowelStrings(3) == 35", "assert countVowelStrings(4) == 70", "assert countVowelStrings(5) == 126", "assert countVowelStrings(6) == 210", "assert countVowelStrings(7) == 330", "assert countVowelStrings(10) == 1001", "assert countVowelStrings(15) == 3876"]}], "category": "String", "prompt_tokens": 851, "total_tokens": 1078, "completion_tokens": 227, "completion": "Write a function to find the first non-repeating character in a given string and return its index. If it doesn't exist, return -1.\n\n###Code: \n\ndef first_uniq_char(s: str) -> int:\n    # Build a frequency map for all characters in the string\n    frequency = {}\n    for char in s:\n        frequency[char] = frequency.get(char, 0) + 1\n    \n    # Find the first character that only appears once\n    for index, char in enumerate(s):\n        if frequency[char] == 1:\n            return index\n    \n    return -1  # If no unique character found\n\n\n###Testcases: \n\nassert first_uniq_char(\"leetcode\") == 0\nassert first_uniq_char(\"loveleetcode\") == 2\nassert first_uniq_char(\"aabb\") == -1\nassert first_uniq_char(\"z\") == 0\nassert first_uniq_char(\"repeat\") == 5\nassert first_uniq_char(\"svelte\") == 0\nassert first_uniq_char(\"algorithm\") == 0\n\n[/Example 3]", "temperature": 0.922}, {"few_shots": [{"author": "Calvin", "UUID": "87372a22-f5ef-4100-845b-28700ca3fde3", "question": "You are given a string s and an integer array indices of the same length. The string s will be shuffled such that the character at the ith position moves to indices[i] in the shuffled string.\n\nReturn the shuffled string.", "examples": "Input: s = \"codeleet\", indices = [4,5,6,7,0,2,1,3]\nOutput: \"leetcode\"\n\nInput: s = \"abc\", indices = [0,1,2]\nOutput: \"abc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "from typing import List\ndef shuffle_string(s: str, indices: List[int]) -> str:\n    def partitionString(s):\n      substrings = 1\n      cur_str = set()\n      for i in range(len(s)):\n        if s[i] in cur_str:\n          substrings += 1\n          cur_str = {s[i]}\n        else:\n          cur_str.add(s[i])\n      return substrings\n    ret = ['_']*len(s)\n    for idx, i in enumerate(indices):\n        ret[i] = s[idx]\n    return \"\".join(ret)\n", "asserts": ["assert shuffle_string(\"reoc\", [2, 0, 1, 3]) == \"eorc\"", "assert shuffle_string(\"aiohn\", [3,1,4,2,0]) == \"nihao\"", "assert shuffle_string(\"aax\", [0,2,1]) == \"axa\"", "assert shuffle_string(\"gh\", [1,0]) == \"hg\"", "assert shuffle_string(\"\", []) == \"\"  # Edge case: empty string", "assert shuffle_string(\"xy\", [0,1]) == \"xy\"  # No shuffle required", "assert shuffle_string(\"pqrstuvwxyzabcdefghijklmno\", list(range(25, -1, -1))) == \"onmlkjihgfedcbazyxwvutsrqp\"  # Reverse shuffle"]}, {"author": "Calvin", "UUID": "56b48f6d-0d81-478d-b838-4d47b62d3031", "question": "Given an integer n, return the number of strings of length n that consist only of vowels (a, e, i, o, u) and are lexicographically sorted.\n\nA string s is lexicographically sorted if for all valid i, s[i] is the same as or comes before s[i+1] in the alphabet.", "examples": "Input: 1\nOutput: 5\n\nInput: 2\nOutput: 15", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def helper(n, letter_idx):\n  letters = [\"a\",\"e\",\"i\",\"o\",\"u\"]\n  dynamic = {\n      'a1' : 5,\n      'e1' : 4,\n      'i1' : 3,\n      'o1' : 2,\n      'u1' : 1\n  }\n  ret = 0\n  key = letters[letter_idx] + str(n)\n  if key in dynamic.keys():\n    return dynamic[key]\n  else:\n    for i in range(letter_idx, len(letters)):\n      ret += helper(n-1, i)\n    dynamic[key] = ret\n  return ret\n  \n\ndef countVowelStrings(n: int) -> int:\n  return helper(n, 0)\n", "asserts": ["assert countVowelStrings(3) == 35", "assert countVowelStrings(4) == 70", "assert countVowelStrings(5) == 126", "assert countVowelStrings(6) == 210", "assert countVowelStrings(7) == 330", "assert countVowelStrings(10) == 1001", "assert countVowelStrings(15) == 3876"]}], "category": "String", "prompt_tokens": 851, "total_tokens": 1107, "completion_tokens": 256, "completion": "Given a string text and another string brokenLetters, return the number of words in text that are not broken.\n\nA word is broken if it contains any letters that are in brokenLetters. If a word does not contain any of these characters, it is not broken.\n\nWords are separated by a single space character.\n\n###Code:\n\ndef canBeTypedWords(text: str, brokenLetters: str) -> int:\n    words = text.split()\n    broken_set = set(brokenLetters)\n    return sum(not set(word) & broken_set for word in words)\n\n###Testcases:\n\nassert canBeTypedWords(\"hello world\", \"ad\") == 1\nassert canBeTypedWords(\"leet code\", \"lt\") == 1\nassert canBeTypedWords(\"broken words here\", \"brkn\") == 0\nassert canBeTypedWords(\"hello there\", \"xyz\") == 2\nassert canBeTypedWords(\"coding\", \"\") == 1  # Edge case: No broken letters\nassert canBeTypedWords(\"\", \"abc\") == 0  # Edge case: Empty text\nassert canBeTypedWords(\"this is a test sentence\", \"aeiou\") == 0  # Edge case: All vowels broken\n\n[/Example 3]", "temperature": 0.928}, {"few_shots": [{"author": "Calvin", "UUID": "87372a22-f5ef-4100-845b-28700ca3fde3", "question": "You are given a string s and an integer array indices of the same length. The string s will be shuffled such that the character at the ith position moves to indices[i] in the shuffled string.\n\nReturn the shuffled string.", "examples": "Input: s = \"codeleet\", indices = [4,5,6,7,0,2,1,3]\nOutput: \"leetcode\"\n\nInput: s = \"abc\", indices = [0,1,2]\nOutput: \"abc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "from typing import List\ndef shuffle_string(s: str, indices: List[int]) -> str:\n    def partitionString(s):\n      substrings = 1\n      cur_str = set()\n      for i in range(len(s)):\n        if s[i] in cur_str:\n          substrings += 1\n          cur_str = {s[i]}\n        else:\n          cur_str.add(s[i])\n      return substrings\n    ret = ['_']*len(s)\n    for idx, i in enumerate(indices):\n        ret[i] = s[idx]\n    return \"\".join(ret)\n", "asserts": ["assert shuffle_string(\"reoc\", [2, 0, 1, 3]) == \"eorc\"", "assert shuffle_string(\"aiohn\", [3,1,4,2,0]) == \"nihao\"", "assert shuffle_string(\"aax\", [0,2,1]) == \"axa\"", "assert shuffle_string(\"gh\", [1,0]) == \"hg\"", "assert shuffle_string(\"\", []) == \"\"  # Edge case: empty string", "assert shuffle_string(\"xy\", [0,1]) == \"xy\"  # No shuffle required", "assert shuffle_string(\"pqrstuvwxyzabcdefghijklmno\", list(range(25, -1, -1))) == \"onmlkjihgfedcbazyxwvutsrqp\"  # Reverse shuffle"]}, {"author": "Calvin", "UUID": "56b48f6d-0d81-478d-b838-4d47b62d3031", "question": "Given an integer n, return the number of strings of length n that consist only of vowels (a, e, i, o, u) and are lexicographically sorted.\n\nA string s is lexicographically sorted if for all valid i, s[i] is the same as or comes before s[i+1] in the alphabet.", "examples": "Input: 1\nOutput: 5\n\nInput: 2\nOutput: 15", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def helper(n, letter_idx):\n  letters = [\"a\",\"e\",\"i\",\"o\",\"u\"]\n  dynamic = {\n      'a1' : 5,\n      'e1' : 4,\n      'i1' : 3,\n      'o1' : 2,\n      'u1' : 1\n  }\n  ret = 0\n  key = letters[letter_idx] + str(n)\n  if key in dynamic.keys():\n    return dynamic[key]\n  else:\n    for i in range(letter_idx, len(letters)):\n      ret += helper(n-1, i)\n    dynamic[key] = ret\n  return ret\n  \n\ndef countVowelStrings(n: int) -> int:\n  return helper(n, 0)\n", "asserts": ["assert countVowelStrings(3) == 35", "assert countVowelStrings(4) == 70", "assert countVowelStrings(5) == 126", "assert countVowelStrings(6) == 210", "assert countVowelStrings(7) == 330", "assert countVowelStrings(10) == 1001", "assert countVowelStrings(15) == 3876"]}], "category": "String", "prompt_tokens": 851, "total_tokens": 1150, "completion_tokens": 299, "completion": "Given a non-empty string s, you may delete at most one character. Judge whether you can make it a palindrome.\n\nA palindrome is a word that reads the same backward as forward.\n\n###Code:\n\n```python\ndef validPalindrome(s: str) -> bool:\n    def is_pali_range(i, j):\n        return all(s[k] == s[j-k+i] for k in range(i, j))\n\n    for i in range(len(s) // 2):\n        if s[i] != s[~i]:\n            j = len(s) - 1 - i\n            return is_pali_range(i+1, j) or is_pali_range(i, j-1)\n    return True\n```\n\n###Testcases:\n\n```python\nassert validPalindrome(\"aba\") == True\nassert validPalindrome(\"abca\") == True\nassert validPalindrome(\"abc\") == False\nassert validPalindrome(\"deeee\") == True\nassert validPalindrome(\"raceacar\") == True\nassert validPalindrome(\"ab\") == True\nassert validPalindrome(\"a\") == True\nassert validPalindrome(\"\") == True  # Edge case: empty string\nassert validPalindrome(\"radar\") == True  # Palindrome without deletion\nassert validPalindrome(\"baccab\") == True  # Palindrome with one deletion\nassert validPalindrome(\"abacdfgfdcaba\") == False  # Cannot be palindrome with just one deletion\n```\n\n[/Example 3]", "temperature": 0.812}, {"few_shots": [{"author": "Calvin", "UUID": "87372a22-f5ef-4100-845b-28700ca3fde3", "question": "You are given a string s and an integer array indices of the same length. The string s will be shuffled such that the character at the ith position moves to indices[i] in the shuffled string.\n\nReturn the shuffled string.", "examples": "Input: s = \"codeleet\", indices = [4,5,6,7,0,2,1,3]\nOutput: \"leetcode\"\n\nInput: s = \"abc\", indices = [0,1,2]\nOutput: \"abc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "from typing import List\ndef shuffle_string(s: str, indices: List[int]) -> str:\n    def partitionString(s):\n      substrings = 1\n      cur_str = set()\n      for i in range(len(s)):\n        if s[i] in cur_str:\n          substrings += 1\n          cur_str = {s[i]}\n        else:\n          cur_str.add(s[i])\n      return substrings\n    ret = ['_']*len(s)\n    for idx, i in enumerate(indices):\n        ret[i] = s[idx]\n    return \"\".join(ret)\n", "asserts": ["assert shuffle_string(\"reoc\", [2, 0, 1, 3]) == \"eorc\"", "assert shuffle_string(\"aiohn\", [3,1,4,2,0]) == \"nihao\"", "assert shuffle_string(\"aax\", [0,2,1]) == \"axa\"", "assert shuffle_string(\"gh\", [1,0]) == \"hg\"", "assert shuffle_string(\"\", []) == \"\"  # Edge case: empty string", "assert shuffle_string(\"xy\", [0,1]) == \"xy\"  # No shuffle required", "assert shuffle_string(\"pqrstuvwxyzabcdefghijklmno\", list(range(25, -1, -1))) == \"onmlkjihgfedcbazyxwvutsrqp\"  # Reverse shuffle"]}, {"author": "Calvin", "UUID": "56b48f6d-0d81-478d-b838-4d47b62d3031", "question": "Given an integer n, return the number of strings of length n that consist only of vowels (a, e, i, o, u) and are lexicographically sorted.\n\nA string s is lexicographically sorted if for all valid i, s[i] is the same as or comes before s[i+1] in the alphabet.", "examples": "Input: 1\nOutput: 5\n\nInput: 2\nOutput: 15", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def helper(n, letter_idx):\n  letters = [\"a\",\"e\",\"i\",\"o\",\"u\"]\n  dynamic = {\n      'a1' : 5,\n      'e1' : 4,\n      'i1' : 3,\n      'o1' : 2,\n      'u1' : 1\n  }\n  ret = 0\n  key = letters[letter_idx] + str(n)\n  if key in dynamic.keys():\n    return dynamic[key]\n  else:\n    for i in range(letter_idx, len(letters)):\n      ret += helper(n-1, i)\n    dynamic[key] = ret\n  return ret\n  \n\ndef countVowelStrings(n: int) -> int:\n  return helper(n, 0)\n", "asserts": ["assert countVowelStrings(3) == 35", "assert countVowelStrings(4) == 70", "assert countVowelStrings(5) == 126", "assert countVowelStrings(6) == 210", "assert countVowelStrings(7) == 330", "assert countVowelStrings(10) == 1001", "assert countVowelStrings(15) == 3876"]}], "category": "String", "prompt_tokens": 851, "total_tokens": 1266, "completion_tokens": 415, "completion": "Given a string s and an integer k, return the length of the longest substring of s that contains at most k distinct characters.\n\n###Code:\n\ndef length_of_longest_substring_k_distinct(s: str, k: int) -> int:\n    if k == 0:\n        return 0\n    \n    char_map = {}\n    left = 0\n    longest = 0\n    \n    for right in range(len(s)):\n        # Add the character at the right pointer to the map\n        char_map[s[right]] = char_map.get(s[right], 0) + 1\n        \n        # Shrink the window from the left if the distinct character count goes above k\n        while len(char_map) > k:\n            char_map[s[left]] -= 1\n            if char_map[s[left]] == 0:\n                del char_map[s[left]]\n            left += 1\n        \n        # Update the longest substring length\n        longest = max(longest, right - left + 1)\n    \n    return longest\n\n###Testcases:\n\nassert length_of_longest_substring_k_distinct(\"eceba\", 2) == 3\nassert length_of_longest_substring_k_distinct(\"aa\", 1) == 2\nassert length_of_longest_substring_k_distinct(\"a\", 2) == 1\nassert length_of_longest_substring_k_distinct(\"abaac\", 2) == 3\nassert length_of_longest_substring_k_distinct(\"abaccc\", 2) == 4\nassert length_of_longest_substring_k_distinct(\"aaaahhhh\", 1) == 5\nassert length_of_longest_substring_k_distinct(\"bcb\", 1) == 2\nassert length_of_longest_substring_k_distinct(\"\", 3) == 0  # Edge case: empty string\nassert length_of_longest_substring_k_distinct(\"abacab\", 3) == 6  # Whole string\n\n[/Example 3]", "temperature": 0.819}, {"few_shots": [{"author": "Calvin", "UUID": "87372a22-f5ef-4100-845b-28700ca3fde3", "question": "You are given a string s and an integer array indices of the same length. The string s will be shuffled such that the character at the ith position moves to indices[i] in the shuffled string.\n\nReturn the shuffled string.", "examples": "Input: s = \"codeleet\", indices = [4,5,6,7,0,2,1,3]\nOutput: \"leetcode\"\n\nInput: s = \"abc\", indices = [0,1,2]\nOutput: \"abc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "from typing import List\ndef shuffle_string(s: str, indices: List[int]) -> str:\n    def partitionString(s):\n      substrings = 1\n      cur_str = set()\n      for i in range(len(s)):\n        if s[i] in cur_str:\n          substrings += 1\n          cur_str = {s[i]}\n        else:\n          cur_str.add(s[i])\n      return substrings\n    ret = ['_']*len(s)\n    for idx, i in enumerate(indices):\n        ret[i] = s[idx]\n    return \"\".join(ret)\n", "asserts": ["assert shuffle_string(\"reoc\", [2, 0, 1, 3]) == \"eorc\"", "assert shuffle_string(\"aiohn\", [3,1,4,2,0]) == \"nihao\"", "assert shuffle_string(\"aax\", [0,2,1]) == \"axa\"", "assert shuffle_string(\"gh\", [1,0]) == \"hg\"", "assert shuffle_string(\"\", []) == \"\"  # Edge case: empty string", "assert shuffle_string(\"xy\", [0,1]) == \"xy\"  # No shuffle required", "assert shuffle_string(\"pqrstuvwxyzabcdefghijklmno\", list(range(25, -1, -1))) == \"onmlkjihgfedcbazyxwvutsrqp\"  # Reverse shuffle"]}, {"author": "Calvin", "UUID": "56b48f6d-0d81-478d-b838-4d47b62d3031", "question": "Given an integer n, return the number of strings of length n that consist only of vowels (a, e, i, o, u) and are lexicographically sorted.\n\nA string s is lexicographically sorted if for all valid i, s[i] is the same as or comes before s[i+1] in the alphabet.", "examples": "Input: 1\nOutput: 5\n\nInput: 2\nOutput: 15", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def helper(n, letter_idx):\n  letters = [\"a\",\"e\",\"i\",\"o\",\"u\"]\n  dynamic = {\n      'a1' : 5,\n      'e1' : 4,\n      'i1' : 3,\n      'o1' : 2,\n      'u1' : 1\n  }\n  ret = 0\n  key = letters[letter_idx] + str(n)\n  if key in dynamic.keys():\n    return dynamic[key]\n  else:\n    for i in range(letter_idx, len(letters)):\n      ret += helper(n-1, i)\n    dynamic[key] = ret\n  return ret\n  \n\ndef countVowelStrings(n: int) -> int:\n  return helper(n, 0)\n", "asserts": ["assert countVowelStrings(3) == 35", "assert countVowelStrings(4) == 70", "assert countVowelStrings(5) == 126", "assert countVowelStrings(6) == 210", "assert countVowelStrings(7) == 330", "assert countVowelStrings(10) == 1001", "assert countVowelStrings(15) == 3876"]}], "category": "String", "prompt_tokens": 851, "total_tokens": 1106, "completion_tokens": 255, "completion": "Write a function to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string \"\".\n\n###Code:\n\nfrom typing import List\n\ndef longestCommonPrefix(strs: List[str]) -> str:\n    if not strs:\n        return \"\"\n    \n    min_str = min(strs, key=len)\n    for i, ch in enumerate(min_str):\n        for s in strs:\n            if s[i] != ch:\n                return min_str[:i]\n    \n    return min_str\n\n###Testcases:\n\nassert longestCommonPrefix([\"flower\",\"flow\",\"flight\"]) == \"fl\"\nassert longestCommonPrefix([\"dog\",\"racecar\",\"car\"]) == \"\"\nassert longestCommonPrefix([\"interspecies\",\"interstellar\",\"interstate\"]) == \"inters\"\nassert longestCommonPrefix([\"throne\",\"throne\"]) == \"throne\"\nassert longestCommonPrefix([\"throne\",\"dungeon\"]) == \"\"\nassert longestCommonPrefix([]) == \"\"  # Edge case: empty list of strings\nassert longestCommonPrefix([\"a\"]) == \"a\"  # Edge case: single character\nassert longestCommonPrefix([\"ab\",\"a\"]) == \"a\"  # Edge case: one string is a prefix of another\n\n[/Example 3]", "temperature": 0.667}, {"few_shots": [{"author": "Calvin", "UUID": "56b48f6d-0d81-478d-b838-4d47b62d3031", "question": "Given an integer n, return the number of strings of length n that consist only of vowels (a, e, i, o, u) and are lexicographically sorted.\n\nA string s is lexicographically sorted if for all valid i, s[i] is the same as or comes before s[i+1] in the alphabet.", "examples": "Input: 1\nOutput: 5\n\nInput: 2\nOutput: 15", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def helper(n, letter_idx):\n  letters = [\"a\",\"e\",\"i\",\"o\",\"u\"]\n  dynamic = {\n      'a1' : 5,\n      'e1' : 4,\n      'i1' : 3,\n      'o1' : 2,\n      'u1' : 1\n  }\n  ret = 0\n  key = letters[letter_idx] + str(n)\n  if key in dynamic.keys():\n    return dynamic[key]\n  else:\n    for i in range(letter_idx, len(letters)):\n      ret += helper(n-1, i)\n    dynamic[key] = ret\n  return ret\n  \n\ndef countVowelStrings(n: int) -> int:\n  return helper(n, 0)\n", "asserts": ["assert countVowelStrings(3) == 35", "assert countVowelStrings(4) == 70", "assert countVowelStrings(5) == 126", "assert countVowelStrings(6) == 210", "assert countVowelStrings(7) == 330", "assert countVowelStrings(10) == 1001", "assert countVowelStrings(15) == 3876"]}, {"author": "Calvin", "UUID": "ac641352-08d5-4950-8993-6a143da92ecf", "question": "You are given a string s and an integer k. You can choose one of the first k letters of s and append it at the end of the string.\n\nReturn the lexicographically smallest string you could have after applying the mentioned step any number of moves.\n", "examples": "Input: s = \"cba\", k = 1\nOutput: \"acb\"\n\nInput: s = \"baaca\", k = 3\nOutput: \"aaabc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef orderlyQueue(s: str, k: int) -> str:\n    if k == 1:\n        n = len(s)\n        ss = s + s\n        lex_min_str = s\n        for i in range(n):\n            lex_min_str = min(lex_min_str, ss[i:i + n])\n        return lex_min_str\n    \n    return \"\".join(sorted(s))\n", "asserts": ["assert orderlyQueue(\"abcd\", 1) == \"abcd\"", "assert orderlyQueue(\"hello\", 2) == \"ehllo\"", "assert orderlyQueue(\"programming\", 1) == \"ammingprogr\"", "assert orderlyQueue(\"rotator\", 1) == \"atorrot\"", "assert orderlyQueue(\"zxyabc\", 5) == \"abcxyz\"", "assert orderlyQueue(\"xy\", 2) == \"xy\""]}], "category": "String", "prompt_tokens": 745, "total_tokens": 1014, "completion_tokens": 269, "completion": "Write a function that takes a string s and an integer k. The function should return a new string where each character in the new string is the letter that is k letters later in the alphabet than the corresponding character in the input string s. If the operation takes you past the end of the alphabet, start again at the letter 'a'. Assume all letters in s are lowercase, and k is a non-negative integer.\n\n###Code: \n\ndef caesarCipher(s: str, k: int) -> str:\n    result = []\n    for char in s:\n        if char.isalpha():\n            shifted = ord(char) + k % 26\n            if shifted > ord('z'):\n                shifted -= 26\n            result.append(chr(shifted))\n        else:\n            result.append(char)\n    return ''.join(result)\n\n###Testcases: \n\nassert caesarCipher(\"abcd\", 2) == \"cdef\"\nassert caesarCipher(\"xyz\", 3) == \"abc\"\nassert caesarCipher(\"hello\", 26) == \"hello\"\nassert caesarCipher(\"programming\", 5) == \"uwtlwfrrnsl\"\nassert caesarCipher(\"input\", 0) == \"input\"\nassert caesarCipher(\"zulu\", 1) == \"avmv\"\n\n[/Example 3]", "temperature": 0.812}, {"few_shots": [{"author": "Calvin", "UUID": "56b48f6d-0d81-478d-b838-4d47b62d3031", "question": "Given an integer n, return the number of strings of length n that consist only of vowels (a, e, i, o, u) and are lexicographically sorted.\n\nA string s is lexicographically sorted if for all valid i, s[i] is the same as or comes before s[i+1] in the alphabet.", "examples": "Input: 1\nOutput: 5\n\nInput: 2\nOutput: 15", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def helper(n, letter_idx):\n  letters = [\"a\",\"e\",\"i\",\"o\",\"u\"]\n  dynamic = {\n      'a1' : 5,\n      'e1' : 4,\n      'i1' : 3,\n      'o1' : 2,\n      'u1' : 1\n  }\n  ret = 0\n  key = letters[letter_idx] + str(n)\n  if key in dynamic.keys():\n    return dynamic[key]\n  else:\n    for i in range(letter_idx, len(letters)):\n      ret += helper(n-1, i)\n    dynamic[key] = ret\n  return ret\n  \n\ndef countVowelStrings(n: int) -> int:\n  return helper(n, 0)\n", "asserts": ["assert countVowelStrings(3) == 35", "assert countVowelStrings(4) == 70", "assert countVowelStrings(5) == 126", "assert countVowelStrings(6) == 210", "assert countVowelStrings(7) == 330", "assert countVowelStrings(10) == 1001", "assert countVowelStrings(15) == 3876"]}, {"author": "Calvin", "UUID": "ac641352-08d5-4950-8993-6a143da92ecf", "question": "You are given a string s and an integer k. You can choose one of the first k letters of s and append it at the end of the string.\n\nReturn the lexicographically smallest string you could have after applying the mentioned step any number of moves.\n", "examples": "Input: s = \"cba\", k = 1\nOutput: \"acb\"\n\nInput: s = \"baaca\", k = 3\nOutput: \"aaabc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef orderlyQueue(s: str, k: int) -> str:\n    if k == 1:\n        n = len(s)\n        ss = s + s\n        lex_min_str = s\n        for i in range(n):\n            lex_min_str = min(lex_min_str, ss[i:i + n])\n        return lex_min_str\n    \n    return \"\".join(sorted(s))\n", "asserts": ["assert orderlyQueue(\"abcd\", 1) == \"abcd\"", "assert orderlyQueue(\"hello\", 2) == \"ehllo\"", "assert orderlyQueue(\"programming\", 1) == \"ammingprogr\"", "assert orderlyQueue(\"rotator\", 1) == \"atorrot\"", "assert orderlyQueue(\"zxyabc\", 5) == \"abcxyz\"", "assert orderlyQueue(\"xy\", 2) == \"xy\""]}], "category": "String", "prompt_tokens": 745, "total_tokens": 1093, "completion_tokens": 348, "completion": "Given a string s and a non-empty string p, find all the start indices of p's anagrams in s. Strings s and p consist of lowercase English letters only.\n\nThe order of output does not matter.\n\n###Code: \n\nfrom collections import Counter\n\ndef findAnagrams(s: str, p: str):\n    p_counter = Counter(p)\n    s_counter = Counter(s[:len(p)-1])\n    start_indices = []\n\n    for i in range(len(p)-1, len(s)):\n        s_counter[s[i]] += 1   # include a new char in the window\n        if s_counter == p_counter:  # this step compares counts of all letters\n            start_indices.append(i-len(p)+1)  # append the starting index\n        s_counter[s[i-len(p)+1]] -= 1  # decrease the count of the oldest char in the window\n        if s_counter[s[i-len(p)+1]] == 0:\n            del s_counter[s[i-len(p)+1]]  # remove the count if it is zero to avoid unnecessary items\n\n    return start_indices\n\n###Testcases:\n\nassert findAnagrams(\"cbaebabacd\", \"abc\") == [0, 6]\nassert findAnagrams(\"abab\", \"ab\") == [0, 1, 2]\nassert findAnagrams(\"acdbacdacb\", \"abc\") == [3, 4, 7]\nassert findAnagrams(\"aa\", \"bb\") == []\nassert findAnagrams(\"a\" * 10000, \"a\" * 9999) == [0]\nassert findAnagrams(\"af\", \"be\") == []\n\n[/Example 3]", "temperature": 0.818}, {"few_shots": [{"author": "Calvin", "UUID": "56b48f6d-0d81-478d-b838-4d47b62d3031", "question": "Given an integer n, return the number of strings of length n that consist only of vowels (a, e, i, o, u) and are lexicographically sorted.\n\nA string s is lexicographically sorted if for all valid i, s[i] is the same as or comes before s[i+1] in the alphabet.", "examples": "Input: 1\nOutput: 5\n\nInput: 2\nOutput: 15", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def helper(n, letter_idx):\n  letters = [\"a\",\"e\",\"i\",\"o\",\"u\"]\n  dynamic = {\n      'a1' : 5,\n      'e1' : 4,\n      'i1' : 3,\n      'o1' : 2,\n      'u1' : 1\n  }\n  ret = 0\n  key = letters[letter_idx] + str(n)\n  if key in dynamic.keys():\n    return dynamic[key]\n  else:\n    for i in range(letter_idx, len(letters)):\n      ret += helper(n-1, i)\n    dynamic[key] = ret\n  return ret\n  \n\ndef countVowelStrings(n: int) -> int:\n  return helper(n, 0)\n", "asserts": ["assert countVowelStrings(3) == 35", "assert countVowelStrings(4) == 70", "assert countVowelStrings(5) == 126", "assert countVowelStrings(6) == 210", "assert countVowelStrings(7) == 330", "assert countVowelStrings(10) == 1001", "assert countVowelStrings(15) == 3876"]}, {"author": "Calvin", "UUID": "ac641352-08d5-4950-8993-6a143da92ecf", "question": "You are given a string s and an integer k. You can choose one of the first k letters of s and append it at the end of the string.\n\nReturn the lexicographically smallest string you could have after applying the mentioned step any number of moves.\n", "examples": "Input: s = \"cba\", k = 1\nOutput: \"acb\"\n\nInput: s = \"baaca\", k = 3\nOutput: \"aaabc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef orderlyQueue(s: str, k: int) -> str:\n    if k == 1:\n        n = len(s)\n        ss = s + s\n        lex_min_str = s\n        for i in range(n):\n            lex_min_str = min(lex_min_str, ss[i:i + n])\n        return lex_min_str\n    \n    return \"\".join(sorted(s))\n", "asserts": ["assert orderlyQueue(\"abcd\", 1) == \"abcd\"", "assert orderlyQueue(\"hello\", 2) == \"ehllo\"", "assert orderlyQueue(\"programming\", 1) == \"ammingprogr\"", "assert orderlyQueue(\"rotator\", 1) == \"atorrot\"", "assert orderlyQueue(\"zxyabc\", 5) == \"abcxyz\"", "assert orderlyQueue(\"xy\", 2) == \"xy\""]}], "category": "String", "prompt_tokens": 745, "total_tokens": 1036, "completion_tokens": 291, "completion": "Write a function that takes a string and reverses the vowels in it. Vowels are 'a', 'e', 'i', 'o', and 'u', and can be both lower case and upper case.\n\n###Code:\n\n```python\ndef reverseVowels(s: str) -> str:\n    vowels = set(\"aeiouAEIOU\")\n    s_list = list(s)  # Convert string to list to allow modifications\n    left, right = 0, len(s) - 1\n\n    while left < right:\n        if s_list[left] in vowels and s_list[right] in vowels:\n            s_list[left], s_list[right] = s_list[right], s_list[left]\n            left += 1\n            right -= 1\n        if s_list[left] not in vowels:\n            left += 1\n        if s_list[right] not in vowels:\n            right -= 1\n\n    return ''.join(s_list)\n\n###Testcases:\n\nassert reverseVowels(\"hello\") == \"holle\"\nassert reverseVowels(\"leetcode\") == \"leotcede\"\nassert reverseVowels(\"aA\") == \"Aa\"\nassert reverseVowels(\" \") == \" \"\nassert reverseVowels(\"computer\") == \"cemputor\"\nassert reverseVowels(\"The Daily Byte\") == \"The Daoly Byti\"\n```\n\n[/Example 3]", "temperature": 0.812}, {"few_shots": [{"author": "Calvin", "UUID": "56b48f6d-0d81-478d-b838-4d47b62d3031", "question": "Given an integer n, return the number of strings of length n that consist only of vowels (a, e, i, o, u) and are lexicographically sorted.\n\nA string s is lexicographically sorted if for all valid i, s[i] is the same as or comes before s[i+1] in the alphabet.", "examples": "Input: 1\nOutput: 5\n\nInput: 2\nOutput: 15", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def helper(n, letter_idx):\n  letters = [\"a\",\"e\",\"i\",\"o\",\"u\"]\n  dynamic = {\n      'a1' : 5,\n      'e1' : 4,\n      'i1' : 3,\n      'o1' : 2,\n      'u1' : 1\n  }\n  ret = 0\n  key = letters[letter_idx] + str(n)\n  if key in dynamic.keys():\n    return dynamic[key]\n  else:\n    for i in range(letter_idx, len(letters)):\n      ret += helper(n-1, i)\n    dynamic[key] = ret\n  return ret\n  \n\ndef countVowelStrings(n: int) -> int:\n  return helper(n, 0)\n", "asserts": ["assert countVowelStrings(3) == 35", "assert countVowelStrings(4) == 70", "assert countVowelStrings(5) == 126", "assert countVowelStrings(6) == 210", "assert countVowelStrings(7) == 330", "assert countVowelStrings(10) == 1001", "assert countVowelStrings(15) == 3876"]}, {"author": "Calvin", "UUID": "ac641352-08d5-4950-8993-6a143da92ecf", "question": "You are given a string s and an integer k. You can choose one of the first k letters of s and append it at the end of the string.\n\nReturn the lexicographically smallest string you could have after applying the mentioned step any number of moves.\n", "examples": "Input: s = \"cba\", k = 1\nOutput: \"acb\"\n\nInput: s = \"baaca\", k = 3\nOutput: \"aaabc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef orderlyQueue(s: str, k: int) -> str:\n    if k == 1:\n        n = len(s)\n        ss = s + s\n        lex_min_str = s\n        for i in range(n):\n            lex_min_str = min(lex_min_str, ss[i:i + n])\n        return lex_min_str\n    \n    return \"\".join(sorted(s))\n", "asserts": ["assert orderlyQueue(\"abcd\", 1) == \"abcd\"", "assert orderlyQueue(\"hello\", 2) == \"ehllo\"", "assert orderlyQueue(\"programming\", 1) == \"ammingprogr\"", "assert orderlyQueue(\"rotator\", 1) == \"atorrot\"", "assert orderlyQueue(\"zxyabc\", 5) == \"abcxyz\"", "assert orderlyQueue(\"xy\", 2) == \"xy\""]}], "category": "String", "prompt_tokens": 745, "total_tokens": 957, "completion_tokens": 212, "completion": "Write a function that takes a string `s` containing only lowercase English letters and returns the first non-repeating character in it. If there is no such character, return '_'.\n\n###Code:\n\n```python\ndef first_unique_char(s: str) -> str:\n    char_frequency = {}\n    for char in s:\n        if char in char_frequency:\n            char_frequency[char] += 1\n        else:\n            char_frequency[char] = 1\n    \n    for char in s:\n        if char_frequency[char] == 1:\n            return char\n    \n    return '_'\n```\n\n###Testcases:\n\n```python\nassert first_unique_char(\"leetcode\") == 'l'\nassert first_unique_char(\"loveleetcode\") == 'v'\nassert first_unique_char(\"aabb\") == '_'\nassert first_unique_char(\"algorithm\") == 'a'\nassert first_unique_char(\"challenge\") == 'c'\nassert first_unique_char(\"aabcc\") == 'b'\nassert first_unique_char(\"xxyz\") == 'y'\n```\n\n[/Example 3]", "temperature": 0.821}, {"few_shots": [{"author": "Calvin", "UUID": "56b48f6d-0d81-478d-b838-4d47b62d3031", "question": "Given an integer n, return the number of strings of length n that consist only of vowels (a, e, i, o, u) and are lexicographically sorted.\n\nA string s is lexicographically sorted if for all valid i, s[i] is the same as or comes before s[i+1] in the alphabet.", "examples": "Input: 1\nOutput: 5\n\nInput: 2\nOutput: 15", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def helper(n, letter_idx):\n  letters = [\"a\",\"e\",\"i\",\"o\",\"u\"]\n  dynamic = {\n      'a1' : 5,\n      'e1' : 4,\n      'i1' : 3,\n      'o1' : 2,\n      'u1' : 1\n  }\n  ret = 0\n  key = letters[letter_idx] + str(n)\n  if key in dynamic.keys():\n    return dynamic[key]\n  else:\n    for i in range(letter_idx, len(letters)):\n      ret += helper(n-1, i)\n    dynamic[key] = ret\n  return ret\n  \n\ndef countVowelStrings(n: int) -> int:\n  return helper(n, 0)\n", "asserts": ["assert countVowelStrings(3) == 35", "assert countVowelStrings(4) == 70", "assert countVowelStrings(5) == 126", "assert countVowelStrings(6) == 210", "assert countVowelStrings(7) == 330", "assert countVowelStrings(10) == 1001", "assert countVowelStrings(15) == 3876"]}, {"author": "Calvin", "UUID": "ac641352-08d5-4950-8993-6a143da92ecf", "question": "You are given a string s and an integer k. You can choose one of the first k letters of s and append it at the end of the string.\n\nReturn the lexicographically smallest string you could have after applying the mentioned step any number of moves.\n", "examples": "Input: s = \"cba\", k = 1\nOutput: \"acb\"\n\nInput: s = \"baaca\", k = 3\nOutput: \"aaabc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef orderlyQueue(s: str, k: int) -> str:\n    if k == 1:\n        n = len(s)\n        ss = s + s\n        lex_min_str = s\n        for i in range(n):\n            lex_min_str = min(lex_min_str, ss[i:i + n])\n        return lex_min_str\n    \n    return \"\".join(sorted(s))\n", "asserts": ["assert orderlyQueue(\"abcd\", 1) == \"abcd\"", "assert orderlyQueue(\"hello\", 2) == \"ehllo\"", "assert orderlyQueue(\"programming\", 1) == \"ammingprogr\"", "assert orderlyQueue(\"rotator\", 1) == \"atorrot\"", "assert orderlyQueue(\"zxyabc\", 5) == \"abcxyz\"", "assert orderlyQueue(\"xy\", 2) == \"xy\""]}], "category": "String", "prompt_tokens": 745, "total_tokens": 989, "completion_tokens": 244, "completion": "Given a string containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.\n\nAn input string is valid if:\n1. Open brackets must be closed by the same type of brackets.\n2. Open brackets must be closed in the correct order.\n3. Every close bracket has a corresponding open bracket of the same type.\n\n###Code:\n\ndef isValid(s: str) -> bool:\n    stack = []\n    bracket_map = {\")\": \"(\", \"}\": \"{\", \"]\": \"[\"}\n\n    for char in s:\n        if char in bracket_map.values():\n            stack.append(char)\n        elif char in bracket_map.keys():\n            if stack == [] or bracket_map[char] != stack.pop():\n                return False\n        else:\n            return False\n    return stack == []\n\n###Testcases:\n\nassert isValid(\"()\") == True\nassert isValid(\"()[]{}\") == True\nassert isValid(\"(]\") == False\nassert isValid(\"([)]\") == False\nassert isValid(\"{[]}\") == True\nassert isValid(\"]\") == False\nassert isValid(\"\") == True\nassert isValid(\"((({{{[[[]]]}}})))\") == True\n\n[/Example 3]", "temperature": 0.82}, {"few_shots": [{"author": "Calvin", "UUID": "56b48f6d-0d81-478d-b838-4d47b62d3031", "question": "Given an integer n, return the number of strings of length n that consist only of vowels (a, e, i, o, u) and are lexicographically sorted.\n\nA string s is lexicographically sorted if for all valid i, s[i] is the same as or comes before s[i+1] in the alphabet.", "examples": "Input: 1\nOutput: 5\n\nInput: 2\nOutput: 15", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def helper(n, letter_idx):\n  letters = [\"a\",\"e\",\"i\",\"o\",\"u\"]\n  dynamic = {\n      'a1' : 5,\n      'e1' : 4,\n      'i1' : 3,\n      'o1' : 2,\n      'u1' : 1\n  }\n  ret = 0\n  key = letters[letter_idx] + str(n)\n  if key in dynamic.keys():\n    return dynamic[key]\n  else:\n    for i in range(letter_idx, len(letters)):\n      ret += helper(n-1, i)\n    dynamic[key] = ret\n  return ret\n  \n\ndef countVowelStrings(n: int) -> int:\n  return helper(n, 0)\n", "asserts": ["assert countVowelStrings(3) == 35", "assert countVowelStrings(4) == 70", "assert countVowelStrings(5) == 126", "assert countVowelStrings(6) == 210", "assert countVowelStrings(7) == 330", "assert countVowelStrings(10) == 1001", "assert countVowelStrings(15) == 3876"]}, {"author": "Calvin", "UUID": "ac641352-08d5-4950-8993-6a143da92ecf", "question": "You are given a string s and an integer k. You can choose one of the first k letters of s and append it at the end of the string.\n\nReturn the lexicographically smallest string you could have after applying the mentioned step any number of moves.\n", "examples": "Input: s = \"cba\", k = 1\nOutput: \"acb\"\n\nInput: s = \"baaca\", k = 3\nOutput: \"aaabc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef orderlyQueue(s: str, k: int) -> str:\n    if k == 1:\n        n = len(s)\n        ss = s + s\n        lex_min_str = s\n        for i in range(n):\n            lex_min_str = min(lex_min_str, ss[i:i + n])\n        return lex_min_str\n    \n    return \"\".join(sorted(s))\n", "asserts": ["assert orderlyQueue(\"abcd\", 1) == \"abcd\"", "assert orderlyQueue(\"hello\", 2) == \"ehllo\"", "assert orderlyQueue(\"programming\", 1) == \"ammingprogr\"", "assert orderlyQueue(\"rotator\", 1) == \"atorrot\"", "assert orderlyQueue(\"zxyabc\", 5) == \"abcxyz\"", "assert orderlyQueue(\"xy\", 2) == \"xy\""]}], "category": "String", "prompt_tokens": 745, "total_tokens": 933, "completion_tokens": 188, "completion": "Given a string s consisting of lowercase English letters, return the first non-repeating character in it. If there is no such character, return an empty string.\n\n###Code:\n\n```python\ndef firstUniqChar(s: str) -> str:\n    frequency = {}\n    for char in s:\n        frequency[char] = frequency.get(char, 0) + 1\n    for char in s:\n        if frequency[char] == 1:\n            return char\n    return \"\"\n```\n\n###Testcases:\n\n```python\nassert firstUniqChar(\"leetcode\") == \"l\"\nassert firstUniqChar(\"loveleetcode\") == \"v\"\nassert firstUniqChar(\"aabb\") == \"\"\nassert firstUniqChar(\"aabbc\") == \"c\"\nassert firstUniqChar(\"z\") == \"z\"\nassert firstUniqChar(\"dddccdbba\") == \"\"\n```\n\n[/Example 3]", "temperature": 0.851}, {"few_shots": [{"author": "Calvin", "UUID": "56b48f6d-0d81-478d-b838-4d47b62d3031", "question": "Given an integer n, return the number of strings of length n that consist only of vowels (a, e, i, o, u) and are lexicographically sorted.\n\nA string s is lexicographically sorted if for all valid i, s[i] is the same as or comes before s[i+1] in the alphabet.", "examples": "Input: 1\nOutput: 5\n\nInput: 2\nOutput: 15", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def helper(n, letter_idx):\n  letters = [\"a\",\"e\",\"i\",\"o\",\"u\"]\n  dynamic = {\n      'a1' : 5,\n      'e1' : 4,\n      'i1' : 3,\n      'o1' : 2,\n      'u1' : 1\n  }\n  ret = 0\n  key = letters[letter_idx] + str(n)\n  if key in dynamic.keys():\n    return dynamic[key]\n  else:\n    for i in range(letter_idx, len(letters)):\n      ret += helper(n-1, i)\n    dynamic[key] = ret\n  return ret\n  \n\ndef countVowelStrings(n: int) -> int:\n  return helper(n, 0)\n", "asserts": ["assert countVowelStrings(3) == 35", "assert countVowelStrings(4) == 70", "assert countVowelStrings(5) == 126", "assert countVowelStrings(6) == 210", "assert countVowelStrings(7) == 330", "assert countVowelStrings(10) == 1001", "assert countVowelStrings(15) == 3876"]}, {"author": "Calvin", "UUID": "ac641352-08d5-4950-8993-6a143da92ecf", "question": "You are given a string s and an integer k. You can choose one of the first k letters of s and append it at the end of the string.\n\nReturn the lexicographically smallest string you could have after applying the mentioned step any number of moves.\n", "examples": "Input: s = \"cba\", k = 1\nOutput: \"acb\"\n\nInput: s = \"baaca\", k = 3\nOutput: \"aaabc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef orderlyQueue(s: str, k: int) -> str:\n    if k == 1:\n        n = len(s)\n        ss = s + s\n        lex_min_str = s\n        for i in range(n):\n            lex_min_str = min(lex_min_str, ss[i:i + n])\n        return lex_min_str\n    \n    return \"\".join(sorted(s))\n", "asserts": ["assert orderlyQueue(\"abcd\", 1) == \"abcd\"", "assert orderlyQueue(\"hello\", 2) == \"ehllo\"", "assert orderlyQueue(\"programming\", 1) == \"ammingprogr\"", "assert orderlyQueue(\"rotator\", 1) == \"atorrot\"", "assert orderlyQueue(\"zxyabc\", 5) == \"abcxyz\"", "assert orderlyQueue(\"xy\", 2) == \"xy\""]}], "category": "String", "prompt_tokens": 745, "total_tokens": 996, "completion_tokens": 251, "completion": "Create a function `rearrange_characters` which takes a string `s` and a string `target`. The function should return the maximum number of instances of `target` that can be formed by rearranging the characters from `s`. The characters in `s` can be used more than once, but each character in `s` can only be used one time per instance of `target`.\n\n###Code:\n\n```python\nfrom collections import Counter\n\ndef rearrange_characters(s: str, target: str) -> int:\n    count_s = Counter(s)\n    count_target = Counter(target)\n    return min(count_s[char] // count_target[char] for char in count_target)\n\n\n###Testcases:\n\nassert rearrange_characters(\"ilovecodingonleetcode\", \"code\") == 2\nassert rearrange_characters(\"abcba\", \"abc\") == 1\nassert rearrange_characters(\"aabbcc\", \"abc\") == 2\nassert rearrange_characters(\"abc\", \"abcd\") == 0\nassert rearrange_characters(\"aaaaaabbbbbcccccdddddeeeee\", \"abcde\") == 5\nassert rearrange_characters(\"xxyyzz\", \"xyz\") == 2\n```\n\n[/Example 3]", "temperature": 0.912}, {"few_shots": [{"author": "Calvin", "UUID": "56b48f6d-0d81-478d-b838-4d47b62d3031", "question": "Given an integer n, return the number of strings of length n that consist only of vowels (a, e, i, o, u) and are lexicographically sorted.\n\nA string s is lexicographically sorted if for all valid i, s[i] is the same as or comes before s[i+1] in the alphabet.", "examples": "Input: 1\nOutput: 5\n\nInput: 2\nOutput: 15", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def helper(n, letter_idx):\n  letters = [\"a\",\"e\",\"i\",\"o\",\"u\"]\n  dynamic = {\n      'a1' : 5,\n      'e1' : 4,\n      'i1' : 3,\n      'o1' : 2,\n      'u1' : 1\n  }\n  ret = 0\n  key = letters[letter_idx] + str(n)\n  if key in dynamic.keys():\n    return dynamic[key]\n  else:\n    for i in range(letter_idx, len(letters)):\n      ret += helper(n-1, i)\n    dynamic[key] = ret\n  return ret\n  \n\ndef countVowelStrings(n: int) -> int:\n  return helper(n, 0)\n", "asserts": ["assert countVowelStrings(3) == 35", "assert countVowelStrings(4) == 70", "assert countVowelStrings(5) == 126", "assert countVowelStrings(6) == 210", "assert countVowelStrings(7) == 330", "assert countVowelStrings(10) == 1001", "assert countVowelStrings(15) == 3876"]}, {"author": "Calvin", "UUID": "ac641352-08d5-4950-8993-6a143da92ecf", "question": "You are given a string s and an integer k. You can choose one of the first k letters of s and append it at the end of the string.\n\nReturn the lexicographically smallest string you could have after applying the mentioned step any number of moves.\n", "examples": "Input: s = \"cba\", k = 1\nOutput: \"acb\"\n\nInput: s = \"baaca\", k = 3\nOutput: \"aaabc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef orderlyQueue(s: str, k: int) -> str:\n    if k == 1:\n        n = len(s)\n        ss = s + s\n        lex_min_str = s\n        for i in range(n):\n            lex_min_str = min(lex_min_str, ss[i:i + n])\n        return lex_min_str\n    \n    return \"\".join(sorted(s))\n", "asserts": ["assert orderlyQueue(\"abcd\", 1) == \"abcd\"", "assert orderlyQueue(\"hello\", 2) == \"ehllo\"", "assert orderlyQueue(\"programming\", 1) == \"ammingprogr\"", "assert orderlyQueue(\"rotator\", 1) == \"atorrot\"", "assert orderlyQueue(\"zxyabc\", 5) == \"abcxyz\"", "assert orderlyQueue(\"xy\", 2) == \"xy\""]}], "category": "String", "prompt_tokens": 745, "total_tokens": 938, "completion_tokens": 193, "completion": "Given a string s, reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order.\n\n###Code: \n\ndef reverseWords(s: str) -> str:\n    return ' '.join(word[::-1] for word in s.split())\n\n###Testcases: \n\nassert reverseWords(\"Let's take LeetCode contest\") == \"s'teL ekat edoCteeL tsetnoc\"\nassert reverseWords(\"God Ding\") == \"doG gniD\"\nassert reverseWords(\"Hello World\") == \"olleH dlroW\"\nassert reverseWords(\"The quick brown fox jumps over the lazy dog\") == \"ehT kciuq nworb xof spmuj revo eht yzal god\"\nassert reverseWords(\"a b c d\") == \"a b c d\"\nassert reverseWords(\"double  spaces\") == \"elbuod  secaps\"\n\n[/Example 3]", "temperature": 0.658}, {"few_shots": [{"author": "Calvin", "UUID": "56b48f6d-0d81-478d-b838-4d47b62d3031", "question": "Given an integer n, return the number of strings of length n that consist only of vowels (a, e, i, o, u) and are lexicographically sorted.\n\nA string s is lexicographically sorted if for all valid i, s[i] is the same as or comes before s[i+1] in the alphabet.", "examples": "Input: 1\nOutput: 5\n\nInput: 2\nOutput: 15", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def helper(n, letter_idx):\n  letters = [\"a\",\"e\",\"i\",\"o\",\"u\"]\n  dynamic = {\n      'a1' : 5,\n      'e1' : 4,\n      'i1' : 3,\n      'o1' : 2,\n      'u1' : 1\n  }\n  ret = 0\n  key = letters[letter_idx] + str(n)\n  if key in dynamic.keys():\n    return dynamic[key]\n  else:\n    for i in range(letter_idx, len(letters)):\n      ret += helper(n-1, i)\n    dynamic[key] = ret\n  return ret\n  \n\ndef countVowelStrings(n: int) -> int:\n  return helper(n, 0)\n", "asserts": ["assert countVowelStrings(3) == 35", "assert countVowelStrings(4) == 70", "assert countVowelStrings(5) == 126", "assert countVowelStrings(6) == 210", "assert countVowelStrings(7) == 330", "assert countVowelStrings(10) == 1001", "assert countVowelStrings(15) == 3876"]}, {"author": "Calvin", "UUID": "ac641352-08d5-4950-8993-6a143da92ecf", "question": "You are given a string s and an integer k. You can choose one of the first k letters of s and append it at the end of the string.\n\nReturn the lexicographically smallest string you could have after applying the mentioned step any number of moves.\n", "examples": "Input: s = \"cba\", k = 1\nOutput: \"acb\"\n\nInput: s = \"baaca\", k = 3\nOutput: \"aaabc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef orderlyQueue(s: str, k: int) -> str:\n    if k == 1:\n        n = len(s)\n        ss = s + s\n        lex_min_str = s\n        for i in range(n):\n            lex_min_str = min(lex_min_str, ss[i:i + n])\n        return lex_min_str\n    \n    return \"\".join(sorted(s))\n", "asserts": ["assert orderlyQueue(\"abcd\", 1) == \"abcd\"", "assert orderlyQueue(\"hello\", 2) == \"ehllo\"", "assert orderlyQueue(\"programming\", 1) == \"ammingprogr\"", "assert orderlyQueue(\"rotator\", 1) == \"atorrot\"", "assert orderlyQueue(\"zxyabc\", 5) == \"abcxyz\"", "assert orderlyQueue(\"xy\", 2) == \"xy\""]}], "category": "String", "prompt_tokens": 745, "total_tokens": 965, "completion_tokens": 220, "completion": "Given a string s, find the length of the longest substring without repeating characters.\n\n###Code:\n\ndef lengthOfLongestSubstring(s: str) -> int:\n    char_map = {}\n    left = 0\n    max_length = 0\n    for right in range(len(s)):\n        if s[right] in char_map and char_map[s[right]] >= left:\n            left = char_map[s[right]] + 1\n        char_map[s[right]] = right\n        max_length = max(max_length, right - left + 1)\n\n    return max_length\n\n###Testcases:\n\nassert lengthOfLongestSubstring(\"abcabcbb\") == 3\nassert lengthOfLongestSubstring(\"bbbbb\") == 1\nassert lengthOfLongestSubstring(\"pwwkew\") == 3\nassert lengthOfLongestSubstring(\"\") == 0\nassert lengthOfLongestSubstring(\" \") == 1\nassert lengthOfLongestSubstring(\"au\") == 2\nassert lengthOfLongestSubstring(\"dvdf\") == 3\n\n[/Example 3]", "temperature": 0.665}, {"few_shots": [{"author": "Calvin", "UUID": "56b48f6d-0d81-478d-b838-4d47b62d3031", "question": "Given an integer n, return the number of strings of length n that consist only of vowels (a, e, i, o, u) and are lexicographically sorted.\n\nA string s is lexicographically sorted if for all valid i, s[i] is the same as or comes before s[i+1] in the alphabet.", "examples": "Input: 1\nOutput: 5\n\nInput: 2\nOutput: 15", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def helper(n, letter_idx):\n  letters = [\"a\",\"e\",\"i\",\"o\",\"u\"]\n  dynamic = {\n      'a1' : 5,\n      'e1' : 4,\n      'i1' : 3,\n      'o1' : 2,\n      'u1' : 1\n  }\n  ret = 0\n  key = letters[letter_idx] + str(n)\n  if key in dynamic.keys():\n    return dynamic[key]\n  else:\n    for i in range(letter_idx, len(letters)):\n      ret += helper(n-1, i)\n    dynamic[key] = ret\n  return ret\n  \n\ndef countVowelStrings(n: int) -> int:\n  return helper(n, 0)\n", "asserts": ["assert countVowelStrings(3) == 35", "assert countVowelStrings(4) == 70", "assert countVowelStrings(5) == 126", "assert countVowelStrings(6) == 210", "assert countVowelStrings(7) == 330", "assert countVowelStrings(10) == 1001", "assert countVowelStrings(15) == 3876"]}, {"author": "Calvin", "UUID": "80e34b28-16a8-46ac-8b6a-ee28beb1e8d4", "question": "Write a function that reverses a string. The input string is given as an array of characters s.\n\nYou must do this by modifying the input array in-place with O(1) extra memory.", "examples": "Input: [\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput: [\"o\",\"l\",\"l\",\"e\",\"h\"]\n\nInput: [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\nOutput: [\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def reverse_string(s: list) -> list:\n  l = 0\n  r = len(s) - 1\n  while l < r:\n    tmp = s[l]\n    s[l] = s[r]\n    s[r] = tmp\n    l += 1\n    r -= 1\n  return s\n", "asserts": ["assert reverse_string([\"a\",\"b\",\"c\",\"d\"]) == [\"d\", \"c\", \"b\", \"a\"]", "assert reverse_string([\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"]) == [\"n\", \"o\", \"h\", \"t\", \"y\", \"p\"]", "assert reverse_string([]) == []", "assert reverse_string([\"s\", \"i\", \"n\", \"g\", \"l\", \"e\"]) == [\"e\", \"l\", \"g\", \"n\", \"i\", \"s\"]", "assert reverse_string([\"A\"]) == [\"A\"]", "assert reverse_string([\"9\", \"8\", \"7\", \"6\", \"5\", \"4\", \"3\", \"2\", \"1\"]) == [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]", "assert reverse_string([\"B\", \"o\", \"b\"]) == [\"b\", \"o\", \"B\"]", "assert reverse_string([\"r\", \"e\", \"v\", \"e\", \"r\", \"s\", \"e\"]) == [\"e\", \"s\", \"r\", \"e\", \"v\", \"e\", \"r\"]", "assert reverse_string([\"1\", \"*\", \"2\", \"*\", \"3\"]) == [\"3\", \"*\", \"2\", \"*\", \"1\"]"]}], "category": "String", "prompt_tokens": 910, "total_tokens": 1257, "completion_tokens": 347, "completion": "Write a function that takes a string s and returns the longest palindromic substring in s. A string is called a palindrome if it reads the same backward as forward.\n\n###Code: \n\ndef longest_palindrome(s: str) -> str:\n  if len(s) < 2 or s == s[::-1]:\n    return s\n\n  def expand_around_center(left: int, right: int) -> str:\n    while left >= 0 and right < len(s) and s[left] == s[right]:\n      left -= 1\n      right += 1\n    return s[left+1:right]\n\n  max_palindrome = \"\"\n  for i in range(len(s) - 1):\n    palindrome_odd = expand_around_center(i, i)\n    palindrome_even = expand_around_center(i, i+1)\n    max_palindrome = max(palindrome_odd, palindrome_even, max_palindrome, key=len)\n\n  return max_palindrome\n\n\n###Testcases: \n\nassert longest_palindrome(\"babad\") == \"bab\" or longest_palindrome(\"babad\") == \"aba\"\nassert longest_palindrome(\"cbbd\") == \"bb\"\nassert longest_palindrome(\"a\") == \"a\"\nassert longest_palindrome(\"ac\") == \"a\" or longest_palindrome(\"ac\") == \"c\"\nassert longest_palindrome(\"racecar\") == \"racecar\"\nassert longest_palindrome(\"forgeeksskeegfor\") == \"geeksskeeg\"\nassert longest_palindrome(\"abacab\") == \"bacab\"\nassert longest_palindrome(\"abacdfgdcaba\") == \"aba\"\nassert longest_palindrome(\"\") == \"\"\n\n[/Example 3]", "temperature": 0.858}, {"few_shots": [{"author": "Calvin", "UUID": "56b48f6d-0d81-478d-b838-4d47b62d3031", "question": "Given an integer n, return the number of strings of length n that consist only of vowels (a, e, i, o, u) and are lexicographically sorted.\n\nA string s is lexicographically sorted if for all valid i, s[i] is the same as or comes before s[i+1] in the alphabet.", "examples": "Input: 1\nOutput: 5\n\nInput: 2\nOutput: 15", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def helper(n, letter_idx):\n  letters = [\"a\",\"e\",\"i\",\"o\",\"u\"]\n  dynamic = {\n      'a1' : 5,\n      'e1' : 4,\n      'i1' : 3,\n      'o1' : 2,\n      'u1' : 1\n  }\n  ret = 0\n  key = letters[letter_idx] + str(n)\n  if key in dynamic.keys():\n    return dynamic[key]\n  else:\n    for i in range(letter_idx, len(letters)):\n      ret += helper(n-1, i)\n    dynamic[key] = ret\n  return ret\n  \n\ndef countVowelStrings(n: int) -> int:\n  return helper(n, 0)\n", "asserts": ["assert countVowelStrings(3) == 35", "assert countVowelStrings(4) == 70", "assert countVowelStrings(5) == 126", "assert countVowelStrings(6) == 210", "assert countVowelStrings(7) == 330", "assert countVowelStrings(10) == 1001", "assert countVowelStrings(15) == 3876"]}, {"author": "Calvin", "UUID": "80e34b28-16a8-46ac-8b6a-ee28beb1e8d4", "question": "Write a function that reverses a string. The input string is given as an array of characters s.\n\nYou must do this by modifying the input array in-place with O(1) extra memory.", "examples": "Input: [\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput: [\"o\",\"l\",\"l\",\"e\",\"h\"]\n\nInput: [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\nOutput: [\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def reverse_string(s: list) -> list:\n  l = 0\n  r = len(s) - 1\n  while l < r:\n    tmp = s[l]\n    s[l] = s[r]\n    s[r] = tmp\n    l += 1\n    r -= 1\n  return s\n", "asserts": ["assert reverse_string([\"a\",\"b\",\"c\",\"d\"]) == [\"d\", \"c\", \"b\", \"a\"]", "assert reverse_string([\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"]) == [\"n\", \"o\", \"h\", \"t\", \"y\", \"p\"]", "assert reverse_string([]) == []", "assert reverse_string([\"s\", \"i\", \"n\", \"g\", \"l\", \"e\"]) == [\"e\", \"l\", \"g\", \"n\", \"i\", \"s\"]", "assert reverse_string([\"A\"]) == [\"A\"]", "assert reverse_string([\"9\", \"8\", \"7\", \"6\", \"5\", \"4\", \"3\", \"2\", \"1\"]) == [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]", "assert reverse_string([\"B\", \"o\", \"b\"]) == [\"b\", \"o\", \"B\"]", "assert reverse_string([\"r\", \"e\", \"v\", \"e\", \"r\", \"s\", \"e\"]) == [\"e\", \"s\", \"r\", \"e\", \"v\", \"e\", \"r\"]", "assert reverse_string([\"1\", \"*\", \"2\", \"*\", \"3\"]) == [\"3\", \"*\", \"2\", \"*\", \"1\"]"]}], "category": "String", "prompt_tokens": 910, "total_tokens": 1142, "completion_tokens": 232, "completion": "Given a string s, remove all its adjacent duplicate characters repeatedly until no adjacent duplicates are left. You need to do this in-place and return the final string after all such duplicate removals have been made.\n\nNote that the input string may contain lowercase and uppercase letters.\n\n###Code: \n\ndef remove_adjacent_duplicates(s: str) -> str:\n  stack = []\n  for char in s:\n    if stack and stack[-1] == char:\n      stack.pop()\n    else:\n      stack.append(char)\n  return ''.join(stack)\n\n\n###Testcases: \n\nassert remove_adjacent_duplicates(\"abbaca\") == \"ca\"\nassert remove_adjacent_duplicates(\"azxxzy\") == \"ay\"\nassert remove_adjacent_duplicates(\"a\") == \"a\"\nassert remove_adjacent_duplicates(\"aabccddd\") == \"abd\"\nassert remove_adjacent_duplicates(\"aaaaa\") == \"\"\nassert remove_adjacent_duplicates(\"abbbbcddde\") == \"acde\"\nassert remove_adjacent_duplicates(\"AABBA\") == \"A\"\nassert remove_adjacent_duplicates(\"vVVeEEnnuUu\") == \"nv\"\n\n[/Example 3]", "temperature": 0.86}, {"few_shots": [{"author": "Calvin", "UUID": "56b48f6d-0d81-478d-b838-4d47b62d3031", "question": "Given an integer n, return the number of strings of length n that consist only of vowels (a, e, i, o, u) and are lexicographically sorted.\n\nA string s is lexicographically sorted if for all valid i, s[i] is the same as or comes before s[i+1] in the alphabet.", "examples": "Input: 1\nOutput: 5\n\nInput: 2\nOutput: 15", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def helper(n, letter_idx):\n  letters = [\"a\",\"e\",\"i\",\"o\",\"u\"]\n  dynamic = {\n      'a1' : 5,\n      'e1' : 4,\n      'i1' : 3,\n      'o1' : 2,\n      'u1' : 1\n  }\n  ret = 0\n  key = letters[letter_idx] + str(n)\n  if key in dynamic.keys():\n    return dynamic[key]\n  else:\n    for i in range(letter_idx, len(letters)):\n      ret += helper(n-1, i)\n    dynamic[key] = ret\n  return ret\n  \n\ndef countVowelStrings(n: int) -> int:\n  return helper(n, 0)\n", "asserts": ["assert countVowelStrings(3) == 35", "assert countVowelStrings(4) == 70", "assert countVowelStrings(5) == 126", "assert countVowelStrings(6) == 210", "assert countVowelStrings(7) == 330", "assert countVowelStrings(10) == 1001", "assert countVowelStrings(15) == 3876"]}, {"author": "Calvin", "UUID": "80e34b28-16a8-46ac-8b6a-ee28beb1e8d4", "question": "Write a function that reverses a string. The input string is given as an array of characters s.\n\nYou must do this by modifying the input array in-place with O(1) extra memory.", "examples": "Input: [\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput: [\"o\",\"l\",\"l\",\"e\",\"h\"]\n\nInput: [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\nOutput: [\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def reverse_string(s: list) -> list:\n  l = 0\n  r = len(s) - 1\n  while l < r:\n    tmp = s[l]\n    s[l] = s[r]\n    s[r] = tmp\n    l += 1\n    r -= 1\n  return s\n", "asserts": ["assert reverse_string([\"a\",\"b\",\"c\",\"d\"]) == [\"d\", \"c\", \"b\", \"a\"]", "assert reverse_string([\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"]) == [\"n\", \"o\", \"h\", \"t\", \"y\", \"p\"]", "assert reverse_string([]) == []", "assert reverse_string([\"s\", \"i\", \"n\", \"g\", \"l\", \"e\"]) == [\"e\", \"l\", \"g\", \"n\", \"i\", \"s\"]", "assert reverse_string([\"A\"]) == [\"A\"]", "assert reverse_string([\"9\", \"8\", \"7\", \"6\", \"5\", \"4\", \"3\", \"2\", \"1\"]) == [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]", "assert reverse_string([\"B\", \"o\", \"b\"]) == [\"b\", \"o\", \"B\"]", "assert reverse_string([\"r\", \"e\", \"v\", \"e\", \"r\", \"s\", \"e\"]) == [\"e\", \"s\", \"r\", \"e\", \"v\", \"e\", \"r\"]", "assert reverse_string([\"1\", \"*\", \"2\", \"*\", \"3\"]) == [\"3\", \"*\", \"2\", \"*\", \"1\"]"]}], "category": "String", "prompt_tokens": 910, "total_tokens": 1304, "completion_tokens": 394, "completion": "Given a string s, find the longest palindromic substring in s. A string is a palindrome if it reads the same backward as forward.\n\n###Code:\n\ndef longest_palindrome(s: str) -> str:\n    def expand_around_center(left, right):\n        while left >= 0 and right < len(s) and s[left] == s[right]:\n            left -= 1\n            right += 1\n        return s[left + 1:right]\n\n    if len(s) == 0:\n        return \"\"\n\n    max_palindrome = s[0]\n    for i in range(len(s)):\n        # Odd length palindrome\n        palindrome1 = expand_around_center(i, i)\n        if len(palindrome1) > len(max_palindrome):\n            max_palindrome = palindrome1\n        \n        # Even length palindrome\n        palindrome2 = expand_around_center(i, i + 1)\n        if len(palindrome2) > len(max_palindrome):\n            max_palindrome = palindrome2\n\n    return max_palindrome\n\n\n###Testcases:\n\nassert longest_palindrome(\"babad\") == \"bab\" or longest_palindrome(\"babad\") == \"aba\"\nassert longest_palindrome(\"cbbd\") == \"bb\"\nassert longest_palindrome(\"a\") == \"a\"\nassert longest_palindrome(\"ac\") == \"a\" or longest_palindrome(\"ac\") == \"c\"\nassert longest_palindrome(\"racecar\") == \"racecar\"\nassert longest_palindrome(\"google\") == \"goog\"\nassert longest_palindrome(\"forgeeksskeegfor\") == \"geeksskeeg\"\nassert longest_palindrome(\"abacdfgdcaba\") == \"aba\" or longest_palindrome(\"abacdfgdcaba\") == \"cdc\"\nassert longest_palindrome(\"abaxabaxabb\") == \"baxabaxab\"\nassert longest_palindrome(\"\") == \"\"\n\n[/Example 3]", "temperature": 0.675}, {"few_shots": [{"author": "Calvin", "UUID": "56b48f6d-0d81-478d-b838-4d47b62d3031", "question": "Given an integer n, return the number of strings of length n that consist only of vowels (a, e, i, o, u) and are lexicographically sorted.\n\nA string s is lexicographically sorted if for all valid i, s[i] is the same as or comes before s[i+1] in the alphabet.", "examples": "Input: 1\nOutput: 5\n\nInput: 2\nOutput: 15", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def helper(n, letter_idx):\n  letters = [\"a\",\"e\",\"i\",\"o\",\"u\"]\n  dynamic = {\n      'a1' : 5,\n      'e1' : 4,\n      'i1' : 3,\n      'o1' : 2,\n      'u1' : 1\n  }\n  ret = 0\n  key = letters[letter_idx] + str(n)\n  if key in dynamic.keys():\n    return dynamic[key]\n  else:\n    for i in range(letter_idx, len(letters)):\n      ret += helper(n-1, i)\n    dynamic[key] = ret\n  return ret\n  \n\ndef countVowelStrings(n: int) -> int:\n  return helper(n, 0)\n", "asserts": ["assert countVowelStrings(3) == 35", "assert countVowelStrings(4) == 70", "assert countVowelStrings(5) == 126", "assert countVowelStrings(6) == 210", "assert countVowelStrings(7) == 330", "assert countVowelStrings(10) == 1001", "assert countVowelStrings(15) == 3876"]}, {"author": "Calvin", "UUID": "80e34b28-16a8-46ac-8b6a-ee28beb1e8d4", "question": "Write a function that reverses a string. The input string is given as an array of characters s.\n\nYou must do this by modifying the input array in-place with O(1) extra memory.", "examples": "Input: [\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput: [\"o\",\"l\",\"l\",\"e\",\"h\"]\n\nInput: [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\nOutput: [\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def reverse_string(s: list) -> list:\n  l = 0\n  r = len(s) - 1\n  while l < r:\n    tmp = s[l]\n    s[l] = s[r]\n    s[r] = tmp\n    l += 1\n    r -= 1\n  return s\n", "asserts": ["assert reverse_string([\"a\",\"b\",\"c\",\"d\"]) == [\"d\", \"c\", \"b\", \"a\"]", "assert reverse_string([\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"]) == [\"n\", \"o\", \"h\", \"t\", \"y\", \"p\"]", "assert reverse_string([]) == []", "assert reverse_string([\"s\", \"i\", \"n\", \"g\", \"l\", \"e\"]) == [\"e\", \"l\", \"g\", \"n\", \"i\", \"s\"]", "assert reverse_string([\"A\"]) == [\"A\"]", "assert reverse_string([\"9\", \"8\", \"7\", \"6\", \"5\", \"4\", \"3\", \"2\", \"1\"]) == [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]", "assert reverse_string([\"B\", \"o\", \"b\"]) == [\"b\", \"o\", \"B\"]", "assert reverse_string([\"r\", \"e\", \"v\", \"e\", \"r\", \"s\", \"e\"]) == [\"e\", \"s\", \"r\", \"e\", \"v\", \"e\", \"r\"]", "assert reverse_string([\"1\", \"*\", \"2\", \"*\", \"3\"]) == [\"3\", \"*\", \"2\", \"*\", \"1\"]"]}], "category": "String", "prompt_tokens": 910, "total_tokens": 1161, "completion_tokens": 251, "completion": "Given a string `words` consisting of space-separated words, return the word with the largest number of occurrences. If more than one word has the highest occurrence, return the one that appears first lexicographically.\n\n###Code: \n\n```python\nfrom collections import Counter\n\ndef most_common_word(words: str) -> str:\n    word_count = Counter(words.split())\n    max_count = max(word_count.values())\n    most_common_words = [word for word, count in word_count.items() if count == max_count]\n    return sorted(most_common_words)[0]\n\n###Testcases: \n\nassert most_common_word(\"hello world hello\") == \"hello\"\nassert most_common_word(\"the quick brown fox jumps over the lazy dog the the\") == \"the\"\nassert most_common_word(\"one two three two two\") == \"two\"\nassert most_common_word(\"alpha beta gamma beta alpha alpha\") == \"alpha\"\nassert most_common_word(\"no repetition here\") == \"here\"\nassert most_common_word(\"test test test test\") == \"test\"\nassert most_common_word(\"ties are broken lexicographically\") == \"are\"\nassert most_common_word(\"a a a b b b a\") == \"a\"\n```\n\n[/Example 3]", "temperature": 0.765}, {"few_shots": [{"author": "Calvin", "UUID": "56b48f6d-0d81-478d-b838-4d47b62d3031", "question": "Given an integer n, return the number of strings of length n that consist only of vowels (a, e, i, o, u) and are lexicographically sorted.\n\nA string s is lexicographically sorted if for all valid i, s[i] is the same as or comes before s[i+1] in the alphabet.", "examples": "Input: 1\nOutput: 5\n\nInput: 2\nOutput: 15", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def helper(n, letter_idx):\n  letters = [\"a\",\"e\",\"i\",\"o\",\"u\"]\n  dynamic = {\n      'a1' : 5,\n      'e1' : 4,\n      'i1' : 3,\n      'o1' : 2,\n      'u1' : 1\n  }\n  ret = 0\n  key = letters[letter_idx] + str(n)\n  if key in dynamic.keys():\n    return dynamic[key]\n  else:\n    for i in range(letter_idx, len(letters)):\n      ret += helper(n-1, i)\n    dynamic[key] = ret\n  return ret\n  \n\ndef countVowelStrings(n: int) -> int:\n  return helper(n, 0)\n", "asserts": ["assert countVowelStrings(3) == 35", "assert countVowelStrings(4) == 70", "assert countVowelStrings(5) == 126", "assert countVowelStrings(6) == 210", "assert countVowelStrings(7) == 330", "assert countVowelStrings(10) == 1001", "assert countVowelStrings(15) == 3876"]}, {"author": "Calvin", "UUID": "80e34b28-16a8-46ac-8b6a-ee28beb1e8d4", "question": "Write a function that reverses a string. The input string is given as an array of characters s.\n\nYou must do this by modifying the input array in-place with O(1) extra memory.", "examples": "Input: [\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput: [\"o\",\"l\",\"l\",\"e\",\"h\"]\n\nInput: [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\nOutput: [\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def reverse_string(s: list) -> list:\n  l = 0\n  r = len(s) - 1\n  while l < r:\n    tmp = s[l]\n    s[l] = s[r]\n    s[r] = tmp\n    l += 1\n    r -= 1\n  return s\n", "asserts": ["assert reverse_string([\"a\",\"b\",\"c\",\"d\"]) == [\"d\", \"c\", \"b\", \"a\"]", "assert reverse_string([\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"]) == [\"n\", \"o\", \"h\", \"t\", \"y\", \"p\"]", "assert reverse_string([]) == []", "assert reverse_string([\"s\", \"i\", \"n\", \"g\", \"l\", \"e\"]) == [\"e\", \"l\", \"g\", \"n\", \"i\", \"s\"]", "assert reverse_string([\"A\"]) == [\"A\"]", "assert reverse_string([\"9\", \"8\", \"7\", \"6\", \"5\", \"4\", \"3\", \"2\", \"1\"]) == [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]", "assert reverse_string([\"B\", \"o\", \"b\"]) == [\"b\", \"o\", \"B\"]", "assert reverse_string([\"r\", \"e\", \"v\", \"e\", \"r\", \"s\", \"e\"]) == [\"e\", \"s\", \"r\", \"e\", \"v\", \"e\", \"r\"]", "assert reverse_string([\"1\", \"*\", \"2\", \"*\", \"3\"]) == [\"3\", \"*\", \"2\", \"*\", \"1\"]"]}], "category": "String", "prompt_tokens": 910, "total_tokens": 1230, "completion_tokens": 320, "completion": "Write a function that checks if a string is a palindrome. A string is a palindrome if it reads the same backward as forward. \n\nThe function should be case-insensitive and should not consider spaces or punctuation.\n\n###Code: \n\ndef is_palindrome(s: str) -> bool:\n  alphanumeric_str = \"\".join(char.lower() for char in s if char.isalnum())\n  return alphanumeric_str == alphanumeric_str[::-1]\n\n\n###Testcases: \n\nassert is_palindrome(\"A man, a plan, a canal: Panama\") == True\nassert is_palindrome(\"race a car\") == False\nassert is_palindrome(\" \") == True\nassert is_palindrome(\"No lemon, no melon\") == True\nassert is_palindrome(\"Was it a car or a cat I saw?\") == True\nassert is_palindrome(\"A Toyota! Race fast, safe car! A Toyota!\") == True\nassert is_palindrome(\"No 'x' in Nixon\") == True\nassert is_palindrome(\"Madam, in Eden, I'm Adam.\") == True\nassert is_palindrome(\"Step on no pets\") == True\nassert is_palindrome(\"Eva, can I see bees in a cave?\") == True\nassert is_palindrome(\"Never odd or even.\") == True\nassert is_palindrome(\"Do geese see God?\") == True\nassert is_palindrome(\"Mr. Owl ate my metal worm\") == True\nassert is_palindrome(\"Go hang a salami, I'm a lasagna hog\") == True\n\n[/Example 3]", "temperature": 0.686}, {"few_shots": [{"author": "Calvin", "UUID": "56b48f6d-0d81-478d-b838-4d47b62d3031", "question": "Given an integer n, return the number of strings of length n that consist only of vowels (a, e, i, o, u) and are lexicographically sorted.\n\nA string s is lexicographically sorted if for all valid i, s[i] is the same as or comes before s[i+1] in the alphabet.", "examples": "Input: 1\nOutput: 5\n\nInput: 2\nOutput: 15", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def helper(n, letter_idx):\n  letters = [\"a\",\"e\",\"i\",\"o\",\"u\"]\n  dynamic = {\n      'a1' : 5,\n      'e1' : 4,\n      'i1' : 3,\n      'o1' : 2,\n      'u1' : 1\n  }\n  ret = 0\n  key = letters[letter_idx] + str(n)\n  if key in dynamic.keys():\n    return dynamic[key]\n  else:\n    for i in range(letter_idx, len(letters)):\n      ret += helper(n-1, i)\n    dynamic[key] = ret\n  return ret\n  \n\ndef countVowelStrings(n: int) -> int:\n  return helper(n, 0)\n", "asserts": ["assert countVowelStrings(3) == 35", "assert countVowelStrings(4) == 70", "assert countVowelStrings(5) == 126", "assert countVowelStrings(6) == 210", "assert countVowelStrings(7) == 330", "assert countVowelStrings(10) == 1001", "assert countVowelStrings(15) == 3876"]}, {"author": "Calvin", "UUID": "80e34b28-16a8-46ac-8b6a-ee28beb1e8d4", "question": "Write a function that reverses a string. The input string is given as an array of characters s.\n\nYou must do this by modifying the input array in-place with O(1) extra memory.", "examples": "Input: [\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput: [\"o\",\"l\",\"l\",\"e\",\"h\"]\n\nInput: [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\nOutput: [\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def reverse_string(s: list) -> list:\n  l = 0\n  r = len(s) - 1\n  while l < r:\n    tmp = s[l]\n    s[l] = s[r]\n    s[r] = tmp\n    l += 1\n    r -= 1\n  return s\n", "asserts": ["assert reverse_string([\"a\",\"b\",\"c\",\"d\"]) == [\"d\", \"c\", \"b\", \"a\"]", "assert reverse_string([\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"]) == [\"n\", \"o\", \"h\", \"t\", \"y\", \"p\"]", "assert reverse_string([]) == []", "assert reverse_string([\"s\", \"i\", \"n\", \"g\", \"l\", \"e\"]) == [\"e\", \"l\", \"g\", \"n\", \"i\", \"s\"]", "assert reverse_string([\"A\"]) == [\"A\"]", "assert reverse_string([\"9\", \"8\", \"7\", \"6\", \"5\", \"4\", \"3\", \"2\", \"1\"]) == [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]", "assert reverse_string([\"B\", \"o\", \"b\"]) == [\"b\", \"o\", \"B\"]", "assert reverse_string([\"r\", \"e\", \"v\", \"e\", \"r\", \"s\", \"e\"]) == [\"e\", \"s\", \"r\", \"e\", \"v\", \"e\", \"r\"]", "assert reverse_string([\"1\", \"*\", \"2\", \"*\", \"3\"]) == [\"3\", \"*\", \"2\", \"*\", \"1\"]"]}], "category": "String", "prompt_tokens": 910, "total_tokens": 1188, "completion_tokens": 278, "completion": "Write a function to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string \"\".\n\n###Code: \n\ndef longest_common_prefix(strs: list) -> str:\n    if not strs:\n        return \"\"\n    \n    min_len = min(len(s) for s in strs)\n    prefix = \"\"\n    \n    for i in range(min_len):\n        char_set = set(string[i] for string in strs)\n        if len(char_set) == 1:\n            prefix += strs[0][i]\n        else:\n            break\n            \n    return prefix\n\n\n###Testcases: \n\nassert longest_common_prefix([\"flower\", \"flow\", \"flight\"]) == \"fl\"\nassert longest_common_prefix([\"dog\", \"racecar\", \"car\"]) == \"\"\nassert longest_common_prefix([\"interspecies\", \"interstellar\", \"interstate\"]) == \"inters\"\nassert longest_common_prefix([\"throne\", \"throne\"]) == \"throne\"\nassert longest_common_prefix([\"throne\", \"dungeon\"]) == \"\"\nassert longest_common_prefix([\"cheese\"]) == \"cheese\"\nassert longest_common_prefix([\"patch\", \"path\"]) == \"pa\"\nassert longest_common_prefix([]) == \"\"\nassert longest_common_prefix([\"a\"]) == \"a\"\nassert longest_common_prefix([\"reflower\", \"flow\", \"flight\"]) == \"\"\n\n[/Example 3]", "temperature": 0.69}, {"few_shots": [{"author": "Calvin", "UUID": "56b48f6d-0d81-478d-b838-4d47b62d3031", "question": "Given an integer n, return the number of strings of length n that consist only of vowels (a, e, i, o, u) and are lexicographically sorted.\n\nA string s is lexicographically sorted if for all valid i, s[i] is the same as or comes before s[i+1] in the alphabet.", "examples": "Input: 1\nOutput: 5\n\nInput: 2\nOutput: 15", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def helper(n, letter_idx):\n  letters = [\"a\",\"e\",\"i\",\"o\",\"u\"]\n  dynamic = {\n      'a1' : 5,\n      'e1' : 4,\n      'i1' : 3,\n      'o1' : 2,\n      'u1' : 1\n  }\n  ret = 0\n  key = letters[letter_idx] + str(n)\n  if key in dynamic.keys():\n    return dynamic[key]\n  else:\n    for i in range(letter_idx, len(letters)):\n      ret += helper(n-1, i)\n    dynamic[key] = ret\n  return ret\n  \n\ndef countVowelStrings(n: int) -> int:\n  return helper(n, 0)\n", "asserts": ["assert countVowelStrings(3) == 35", "assert countVowelStrings(4) == 70", "assert countVowelStrings(5) == 126", "assert countVowelStrings(6) == 210", "assert countVowelStrings(7) == 330", "assert countVowelStrings(10) == 1001", "assert countVowelStrings(15) == 3876"]}, {"author": "Calvin", "UUID": "80e34b28-16a8-46ac-8b6a-ee28beb1e8d4", "question": "Write a function that reverses a string. The input string is given as an array of characters s.\n\nYou must do this by modifying the input array in-place with O(1) extra memory.", "examples": "Input: [\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput: [\"o\",\"l\",\"l\",\"e\",\"h\"]\n\nInput: [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\nOutput: [\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def reverse_string(s: list) -> list:\n  l = 0\n  r = len(s) - 1\n  while l < r:\n    tmp = s[l]\n    s[l] = s[r]\n    s[r] = tmp\n    l += 1\n    r -= 1\n  return s\n", "asserts": ["assert reverse_string([\"a\",\"b\",\"c\",\"d\"]) == [\"d\", \"c\", \"b\", \"a\"]", "assert reverse_string([\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"]) == [\"n\", \"o\", \"h\", \"t\", \"y\", \"p\"]", "assert reverse_string([]) == []", "assert reverse_string([\"s\", \"i\", \"n\", \"g\", \"l\", \"e\"]) == [\"e\", \"l\", \"g\", \"n\", \"i\", \"s\"]", "assert reverse_string([\"A\"]) == [\"A\"]", "assert reverse_string([\"9\", \"8\", \"7\", \"6\", \"5\", \"4\", \"3\", \"2\", \"1\"]) == [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]", "assert reverse_string([\"B\", \"o\", \"b\"]) == [\"b\", \"o\", \"B\"]", "assert reverse_string([\"r\", \"e\", \"v\", \"e\", \"r\", \"s\", \"e\"]) == [\"e\", \"s\", \"r\", \"e\", \"v\", \"e\", \"r\"]", "assert reverse_string([\"1\", \"*\", \"2\", \"*\", \"3\"]) == [\"3\", \"*\", \"2\", \"*\", \"1\"]"]}], "category": "String", "prompt_tokens": 910, "total_tokens": 1143, "completion_tokens": 233, "completion": "Write a function that takes a string s and returns true if s is a palindrome, or false otherwise.\n\nA string is a palindrome if it reads the same backward as forward. For this case, we will consider only alphanumeric characters and ignore case sensitivity.\n\n### Code:\n\n```python\ndef is_palindrome(s: str) -> bool:\n    s = ''.join(char.lower() for char in s if char.isalnum())\n    return s == s[::-1]\n\n```\n\n### Testcases:\n\n```python\nassert is_palindrome(\"A man, a plan, a canal: Panama\") == True\nassert is_palindrome(\"race a car\") == False\nassert is_palindrome(\" \") == True\nassert is_palindrome(\"No lemon, no melon\") == True\nassert is_palindrome(\"Was it a car or a cat I saw?\") == True\nassert is_palindrome(\"No 'x' in Nixon\") == True\nassert is_palindrome(\"1234321\") == True\nassert is_palindrome(\"12344321\") == True\nassert is_palindrome(\"not a palindrome\") == False\n```\n\n[/Example 3]", "temperature": 0.793}, {"few_shots": [{"author": "Calvin", "UUID": "56b48f6d-0d81-478d-b838-4d47b62d3031", "question": "Given an integer n, return the number of strings of length n that consist only of vowels (a, e, i, o, u) and are lexicographically sorted.\n\nA string s is lexicographically sorted if for all valid i, s[i] is the same as or comes before s[i+1] in the alphabet.", "examples": "Input: 1\nOutput: 5\n\nInput: 2\nOutput: 15", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def helper(n, letter_idx):\n  letters = [\"a\",\"e\",\"i\",\"o\",\"u\"]\n  dynamic = {\n      'a1' : 5,\n      'e1' : 4,\n      'i1' : 3,\n      'o1' : 2,\n      'u1' : 1\n  }\n  ret = 0\n  key = letters[letter_idx] + str(n)\n  if key in dynamic.keys():\n    return dynamic[key]\n  else:\n    for i in range(letter_idx, len(letters)):\n      ret += helper(n-1, i)\n    dynamic[key] = ret\n  return ret\n  \n\ndef countVowelStrings(n: int) -> int:\n  return helper(n, 0)\n", "asserts": ["assert countVowelStrings(3) == 35", "assert countVowelStrings(4) == 70", "assert countVowelStrings(5) == 126", "assert countVowelStrings(6) == 210", "assert countVowelStrings(7) == 330", "assert countVowelStrings(10) == 1001", "assert countVowelStrings(15) == 3876"]}, {"author": "Calvin", "UUID": "80e34b28-16a8-46ac-8b6a-ee28beb1e8d4", "question": "Write a function that reverses a string. The input string is given as an array of characters s.\n\nYou must do this by modifying the input array in-place with O(1) extra memory.", "examples": "Input: [\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput: [\"o\",\"l\",\"l\",\"e\",\"h\"]\n\nInput: [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\nOutput: [\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def reverse_string(s: list) -> list:\n  l = 0\n  r = len(s) - 1\n  while l < r:\n    tmp = s[l]\n    s[l] = s[r]\n    s[r] = tmp\n    l += 1\n    r -= 1\n  return s\n", "asserts": ["assert reverse_string([\"a\",\"b\",\"c\",\"d\"]) == [\"d\", \"c\", \"b\", \"a\"]", "assert reverse_string([\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"]) == [\"n\", \"o\", \"h\", \"t\", \"y\", \"p\"]", "assert reverse_string([]) == []", "assert reverse_string([\"s\", \"i\", \"n\", \"g\", \"l\", \"e\"]) == [\"e\", \"l\", \"g\", \"n\", \"i\", \"s\"]", "assert reverse_string([\"A\"]) == [\"A\"]", "assert reverse_string([\"9\", \"8\", \"7\", \"6\", \"5\", \"4\", \"3\", \"2\", \"1\"]) == [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]", "assert reverse_string([\"B\", \"o\", \"b\"]) == [\"b\", \"o\", \"B\"]", "assert reverse_string([\"r\", \"e\", \"v\", \"e\", \"r\", \"s\", \"e\"]) == [\"e\", \"s\", \"r\", \"e\", \"v\", \"e\", \"r\"]", "assert reverse_string([\"1\", \"*\", \"2\", \"*\", \"3\"]) == [\"3\", \"*\", \"2\", \"*\", \"1\"]"]}], "category": "String", "prompt_tokens": 910, "total_tokens": 1150, "completion_tokens": 240, "completion": "Write a function that takes in a string and returns a new string with the vowels removed.\n\n###Code:\n\ndef remove_vowels(s: str) -> str:\n    vowels = \"aeiouAEIOU\"\n    return ''.join([char for char in s if char not in vowels])\n\n###Testcases:\n\nassert remove_vowels(\"hello world\") == \"hll wrld\"\nassert remove_vowels(\"aEiOu\") == \"\"\nassert remove_vowels(\"AEIOUaeiou\") == \"\"\nassert remove_vowels(\"programming is fun\") == \"prgrmmng s fn\"\nassert remove_vowels(\"The quick brown fox\") == \"Th qck brwn fx\"\nassert remove_vowels(\"Python\") == \"Pythn\"\nassert remove_vowels(\"\") == \"\"\nassert remove_vowels(\"12345\") == \"12345\"\nassert remove_vowels(\"A man, a plan, a canal: Panama\") == \" mn,  pln,  cnl: Pnm\"\nassert remove_vowels(\"This website is awesome!\") == \"Ths wbst s wsm!\"\n\n[/Example 3]", "temperature": 0.835}, {"few_shots": [{"author": "Calvin", "UUID": "56b48f6d-0d81-478d-b838-4d47b62d3031", "question": "Given an integer n, return the number of strings of length n that consist only of vowels (a, e, i, o, u) and are lexicographically sorted.\n\nA string s is lexicographically sorted if for all valid i, s[i] is the same as or comes before s[i+1] in the alphabet.", "examples": "Input: 1\nOutput: 5\n\nInput: 2\nOutput: 15", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def helper(n, letter_idx):\n  letters = [\"a\",\"e\",\"i\",\"o\",\"u\"]\n  dynamic = {\n      'a1' : 5,\n      'e1' : 4,\n      'i1' : 3,\n      'o1' : 2,\n      'u1' : 1\n  }\n  ret = 0\n  key = letters[letter_idx] + str(n)\n  if key in dynamic.keys():\n    return dynamic[key]\n  else:\n    for i in range(letter_idx, len(letters)):\n      ret += helper(n-1, i)\n    dynamic[key] = ret\n  return ret\n  \n\ndef countVowelStrings(n: int) -> int:\n  return helper(n, 0)\n", "asserts": ["assert countVowelStrings(3) == 35", "assert countVowelStrings(4) == 70", "assert countVowelStrings(5) == 126", "assert countVowelStrings(6) == 210", "assert countVowelStrings(7) == 330", "assert countVowelStrings(10) == 1001", "assert countVowelStrings(15) == 3876"]}, {"author": "Calvin", "UUID": "80e34b28-16a8-46ac-8b6a-ee28beb1e8d4", "question": "Write a function that reverses a string. The input string is given as an array of characters s.\n\nYou must do this by modifying the input array in-place with O(1) extra memory.", "examples": "Input: [\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput: [\"o\",\"l\",\"l\",\"e\",\"h\"]\n\nInput: [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\nOutput: [\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def reverse_string(s: list) -> list:\n  l = 0\n  r = len(s) - 1\n  while l < r:\n    tmp = s[l]\n    s[l] = s[r]\n    s[r] = tmp\n    l += 1\n    r -= 1\n  return s\n", "asserts": ["assert reverse_string([\"a\",\"b\",\"c\",\"d\"]) == [\"d\", \"c\", \"b\", \"a\"]", "assert reverse_string([\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"]) == [\"n\", \"o\", \"h\", \"t\", \"y\", \"p\"]", "assert reverse_string([]) == []", "assert reverse_string([\"s\", \"i\", \"n\", \"g\", \"l\", \"e\"]) == [\"e\", \"l\", \"g\", \"n\", \"i\", \"s\"]", "assert reverse_string([\"A\"]) == [\"A\"]", "assert reverse_string([\"9\", \"8\", \"7\", \"6\", \"5\", \"4\", \"3\", \"2\", \"1\"]) == [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]", "assert reverse_string([\"B\", \"o\", \"b\"]) == [\"b\", \"o\", \"B\"]", "assert reverse_string([\"r\", \"e\", \"v\", \"e\", \"r\", \"s\", \"e\"]) == [\"e\", \"s\", \"r\", \"e\", \"v\", \"e\", \"r\"]", "assert reverse_string([\"1\", \"*\", \"2\", \"*\", \"3\"]) == [\"3\", \"*\", \"2\", \"*\", \"1\"]"]}], "category": "String", "prompt_tokens": 910, "total_tokens": 1144, "completion_tokens": 234, "completion": "Create a function that checks if a string is a palindrome. A palindrome is a word, phrase, number, or other sequences of characters which reads the same backward as forward, ignoring spaces, punctuation, and capitalization.\n\n###Code:\n\ndef is_palindrome(s: str) -> bool:\n    stripped = ''.join(c.lower() for c in s if c.isalnum())\n    return stripped == stripped[::-1]\n\n###Testcases:\n\nassert is_palindrome(\"A man, a plan, a canal, Panama\") == True\nassert is_palindrome(\"Was it a car or a cat I saw?\") == True\nassert is_palindrome(\"No 'x' in Nixon\") == True\nassert is_palindrome(\" \") == True\nassert is_palindrome(\"racecar\") == True\nassert is_palindrome(\"not a palindrome\") == False\nassert is_palindrome(\"Never Odd or Even\") == True\nassert is_palindrome(\"123454321\") == True\nassert is_palindrome(\"12345 5432\") == False\nassert is_palindrome(\"Sator Arepo tenet opera rotas\") == True\n\n[/Example 3]", "temperature": 0.909}, {"few_shots": [{"author": "Calvin", "UUID": "56b48f6d-0d81-478d-b838-4d47b62d3031", "question": "Given an integer n, return the number of strings of length n that consist only of vowels (a, e, i, o, u) and are lexicographically sorted.\n\nA string s is lexicographically sorted if for all valid i, s[i] is the same as or comes before s[i+1] in the alphabet.", "examples": "Input: 1\nOutput: 5\n\nInput: 2\nOutput: 15", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def helper(n, letter_idx):\n  letters = [\"a\",\"e\",\"i\",\"o\",\"u\"]\n  dynamic = {\n      'a1' : 5,\n      'e1' : 4,\n      'i1' : 3,\n      'o1' : 2,\n      'u1' : 1\n  }\n  ret = 0\n  key = letters[letter_idx] + str(n)\n  if key in dynamic.keys():\n    return dynamic[key]\n  else:\n    for i in range(letter_idx, len(letters)):\n      ret += helper(n-1, i)\n    dynamic[key] = ret\n  return ret\n  \n\ndef countVowelStrings(n: int) -> int:\n  return helper(n, 0)\n", "asserts": ["assert countVowelStrings(3) == 35", "assert countVowelStrings(4) == 70", "assert countVowelStrings(5) == 126", "assert countVowelStrings(6) == 210", "assert countVowelStrings(7) == 330", "assert countVowelStrings(10) == 1001", "assert countVowelStrings(15) == 3876"]}, {"author": "Calvin", "UUID": "d0ce7430-cfcd-4c69-b161-b3b2a186422c", "question": "Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.\n\nIn other words, return true if one of s1's permutations is the substring of s2.", "examples": "Input: s1 = \"ab\", s2 = \"eidbaooo\"\nOutput: True\n\nInput: s1 = \"ab\", s2 = \"eidboaoo\"\nOutput: False", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef permutation_in_string(s1: str, s2: str) -> bool:\n  window = len(s1)\n  if window > len(s2):\n    return False\n  freq1 = [0]*26\n  freq2 = [0]*26\n  for i in range(window):\n    freq1[ord(s1[i])-ord('a')] += 1\n    freq2[ord(s2[i])-ord('a')] += 1\n\n  matches = 0\n  for i in range(26):\n    if freq1[i] == freq2[i]:\n      matches += 1\n  \n  for l in range(len(s2) - window):\n    if matches == 26:\n      return True\n\n    added = ord(s2[l + window]) - ord('a')\n    freq2[added] += 1\n    if freq1[added] == freq2[added]:\n      matches += 1\n    elif freq1[added] + 1 == freq2[added]:\n      matches -= 1\n\n    removed = ord(s2[l]) - ord('a')\n    freq2[removed] -= 1\n    if freq1[removed] == freq2[removed]:\n      matches += 1\n    elif freq1[removed] == freq2[removed] + 1:\n      matches -= 1\n    \n  return matches == 26\n", "asserts": ["assert permutation_in_string(\"hello\", \"ooollehhhhh\") == True", "assert permutation_in_string(\"abc\", \"ccccbbbbaaaa\") == False", "assert permutation_in_string(\"xyz\", \"zxyopqrstuv\") == True", "assert permutation_in_string(\"xyz\", \"xzygxzyzxyzk\") == True", "assert permutation_in_string(\"a\", \"a\") == True", "assert permutation_in_string(\"adc\", \"dcda\") == True", "assert permutation_in_string(\"pq\", \"qpqqp\") == True", "assert permutation_in_string(\"kitten\", \"sittingkite\") == False", "assert permutation_in_string(\"pq\", \"pqpqr\") == True", "assert permutation_in_string(\"aba\", \"aabaabaa\") == True", "assert permutation_in_string(\"\", \"\") == True  # Edge case: both strings are empty", "assert permutation_in_string(\"longerstring\", \"short\") == False  # s1 is longer than s2", "assert permutation_in_string(\"a\", \"b\") == False  # Single character, no match", "assert permutation_in_string(\"aab\", \"baa\") == True  # s1 is a permutation of s2", "assert permutation_in_string(\"ab\", \"a\") == False  # s2 is shorter than s1", "assert permutation_in_string(\"ba\", \"eidbaooo\") == True  # Same characters as Example 1 but different permutation", "assert permutation_in_string(\"eid\", \"eidbaooo\") == True  # s1 is a prefix of s2", "assert permutation_in_string(\"ooo\", \"eidbaooo\") == True  # s1 is a suffix of s2", "assert permutation_in_string(\"db\", \"eidbaooo\") == True  # s1 is a permutation within s2", "assert permutation_in_string(\"eidoo\", \"eidbaooo\") == False  # s1 is longer than any permutation within s2"]}], "category": "String", "prompt_tokens": 1255, "total_tokens": 1586, "completion_tokens": 331, "completion": "Given a string s, find the length of the longest substring without repeating characters.\n\n###Code: \n\ndef longest_unique_substring(s: str) -> int:\n    char_index = {}\n    start = 0\n    max_len = 0\n    for i, char in enumerate(s):\n        if char in char_index and start <= char_index[char]:\n            start = char_index[char] + 1\n        else:\n            max_len = max(max_len, i - start + 1)\n        char_index[char] = i\n    return max_len\n\n###Testcases: \n\nassert longest_unique_substring(\"abcabcbb\") == 3\nassert longest_unique_substring(\"bbbbb\") == 1\nassert longest_unique_substring(\"pwwkew\") == 3\nassert longest_unique_substring(\"\") == 0\nassert longest_unique_substring(\" \") == 1\nassert longest_unique_substring(\"dvdf\") == 3\nassert longest_unique_substring(\"abba\") == 2\nassert longest_unique_substring(\"nfpdmpi\") == 5\nassert longest_unique_substring(\"aabaab!bb\") == 3\nassert longest_unique_substring(\"anviaj\") == 5\nassert longest_unique_substring(\"tmmzuxt\") == 5\nassert longest_unique_substring(\"wobgrovw\") == 6\nassert longest_unique_substring(\"au\") == 2\nassert longest_unique_substring(\"jbpnbwwd\") == 4\nassert longest_unique_substring(\"ckilbkd\") == 5\n\n[/Example 3]", "temperature": 0.938}, {"few_shots": [{"author": "Calvin", "UUID": "56b48f6d-0d81-478d-b838-4d47b62d3031", "question": "Given an integer n, return the number of strings of length n that consist only of vowels (a, e, i, o, u) and are lexicographically sorted.\n\nA string s is lexicographically sorted if for all valid i, s[i] is the same as or comes before s[i+1] in the alphabet.", "examples": "Input: 1\nOutput: 5\n\nInput: 2\nOutput: 15", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def helper(n, letter_idx):\n  letters = [\"a\",\"e\",\"i\",\"o\",\"u\"]\n  dynamic = {\n      'a1' : 5,\n      'e1' : 4,\n      'i1' : 3,\n      'o1' : 2,\n      'u1' : 1\n  }\n  ret = 0\n  key = letters[letter_idx] + str(n)\n  if key in dynamic.keys():\n    return dynamic[key]\n  else:\n    for i in range(letter_idx, len(letters)):\n      ret += helper(n-1, i)\n    dynamic[key] = ret\n  return ret\n  \n\ndef countVowelStrings(n: int) -> int:\n  return helper(n, 0)\n", "asserts": ["assert countVowelStrings(3) == 35", "assert countVowelStrings(4) == 70", "assert countVowelStrings(5) == 126", "assert countVowelStrings(6) == 210", "assert countVowelStrings(7) == 330", "assert countVowelStrings(10) == 1001", "assert countVowelStrings(15) == 3876"]}, {"author": "Calvin", "UUID": "d0ce7430-cfcd-4c69-b161-b3b2a186422c", "question": "Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.\n\nIn other words, return true if one of s1's permutations is the substring of s2.", "examples": "Input: s1 = \"ab\", s2 = \"eidbaooo\"\nOutput: True\n\nInput: s1 = \"ab\", s2 = \"eidboaoo\"\nOutput: False", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef permutation_in_string(s1: str, s2: str) -> bool:\n  window = len(s1)\n  if window > len(s2):\n    return False\n  freq1 = [0]*26\n  freq2 = [0]*26\n  for i in range(window):\n    freq1[ord(s1[i])-ord('a')] += 1\n    freq2[ord(s2[i])-ord('a')] += 1\n\n  matches = 0\n  for i in range(26):\n    if freq1[i] == freq2[i]:\n      matches += 1\n  \n  for l in range(len(s2) - window):\n    if matches == 26:\n      return True\n\n    added = ord(s2[l + window]) - ord('a')\n    freq2[added] += 1\n    if freq1[added] == freq2[added]:\n      matches += 1\n    elif freq1[added] + 1 == freq2[added]:\n      matches -= 1\n\n    removed = ord(s2[l]) - ord('a')\n    freq2[removed] -= 1\n    if freq1[removed] == freq2[removed]:\n      matches += 1\n    elif freq1[removed] == freq2[removed] + 1:\n      matches -= 1\n    \n  return matches == 26\n", "asserts": ["assert permutation_in_string(\"hello\", \"ooollehhhhh\") == True", "assert permutation_in_string(\"abc\", \"ccccbbbbaaaa\") == False", "assert permutation_in_string(\"xyz\", \"zxyopqrstuv\") == True", "assert permutation_in_string(\"xyz\", \"xzygxzyzxyzk\") == True", "assert permutation_in_string(\"a\", \"a\") == True", "assert permutation_in_string(\"adc\", \"dcda\") == True", "assert permutation_in_string(\"pq\", \"qpqqp\") == True", "assert permutation_in_string(\"kitten\", \"sittingkite\") == False", "assert permutation_in_string(\"pq\", \"pqpqr\") == True", "assert permutation_in_string(\"aba\", \"aabaabaa\") == True", "assert permutation_in_string(\"\", \"\") == True  # Edge case: both strings are empty", "assert permutation_in_string(\"longerstring\", \"short\") == False  # s1 is longer than s2", "assert permutation_in_string(\"a\", \"b\") == False  # Single character, no match", "assert permutation_in_string(\"aab\", \"baa\") == True  # s1 is a permutation of s2", "assert permutation_in_string(\"ab\", \"a\") == False  # s2 is shorter than s1", "assert permutation_in_string(\"ba\", \"eidbaooo\") == True  # Same characters as Example 1 but different permutation", "assert permutation_in_string(\"eid\", \"eidbaooo\") == True  # s1 is a prefix of s2", "assert permutation_in_string(\"ooo\", \"eidbaooo\") == True  # s1 is a suffix of s2", "assert permutation_in_string(\"db\", \"eidbaooo\") == True  # s1 is a permutation within s2", "assert permutation_in_string(\"eidoo\", \"eidbaooo\") == False  # s1 is longer than any permutation within s2"]}], "category": "String", "prompt_tokens": 1255, "total_tokens": 1714, "completion_tokens": 459, "completion": "Write a function to check whether two given strings are isomorphic.\n\nTwo strings are isomorphic if the characters in string s can be replaced to get string t. No two characters may map to the same character, but a character may map to itself.\n\n###Code: \n\ndef is_isomorphic(s: str, t: str) -> bool:\n  if len(s) != len(t):\n    return False\n  \n  mapping_s_t = {}\n  mapping_t_s = {}\n  \n  for i in range(len(s)):\n    char_s, char_t = s[i], t[i]\n    \n    if char_s not in mapping_s_t and char_t not in mapping_t_s:\n      mapping_s_t[char_s] = char_t\n      mapping_t_s[char_t] = char_s\n    elif mapping_s_t.get(char_s) != char_t or mapping_t_s.get(char_t) != char_s:\n      return False\n\n  return True\n\n###Testcases: \n\nassert is_isomorphic(\"egg\", \"add\") == True\nassert is_isomorphic(\"foo\", \"bar\") == False\nassert is_isomorphic(\"paper\", \"title\") == True\nassert is_isomorphic(\"ab\", \"aa\") == False\nassert is_isomorphic(\"aacc\", \"bbdd\") == True\nassert is_isomorphic(\"abc\", \"def\") == True\nassert is_isomorphic(\"aab\", \"xyz\") == False\nassert is_isomorphic(\"\", \"\") == True  # Edge case: both strings are empty\nassert is_isomorphic(\"13\", \"42\") == True  # Testing with numeric characters\nassert is_isomorphic(\"it\", \"at\") == True  # Only two characters, same structure\nassert is_isomorphic(\"aba\", \"baa\") == False  # 'a' maps to two different characters\nassert is_isomorphic(\"turtle\", \"tletur\") == False  # Same letters, different structure\nassert is_isomorphic(\"abab\", \"baba\") == True  # Repeating pattern\nassert is_isomorphic(\"abba\", \"abab\") == False  # Different repeating pattern\nassert is_isomorphic(\"abcabc\", \"xyzxyz\") == True  # Repeated pattern with more characters\n\n[/Example 3]", "temperature": 0.748}, {"few_shots": [{"author": "Calvin", "UUID": "56b48f6d-0d81-478d-b838-4d47b62d3031", "question": "Given an integer n, return the number of strings of length n that consist only of vowels (a, e, i, o, u) and are lexicographically sorted.\n\nA string s is lexicographically sorted if for all valid i, s[i] is the same as or comes before s[i+1] in the alphabet.", "examples": "Input: 1\nOutput: 5\n\nInput: 2\nOutput: 15", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def helper(n, letter_idx):\n  letters = [\"a\",\"e\",\"i\",\"o\",\"u\"]\n  dynamic = {\n      'a1' : 5,\n      'e1' : 4,\n      'i1' : 3,\n      'o1' : 2,\n      'u1' : 1\n  }\n  ret = 0\n  key = letters[letter_idx] + str(n)\n  if key in dynamic.keys():\n    return dynamic[key]\n  else:\n    for i in range(letter_idx, len(letters)):\n      ret += helper(n-1, i)\n    dynamic[key] = ret\n  return ret\n  \n\ndef countVowelStrings(n: int) -> int:\n  return helper(n, 0)\n", "asserts": ["assert countVowelStrings(3) == 35", "assert countVowelStrings(4) == 70", "assert countVowelStrings(5) == 126", "assert countVowelStrings(6) == 210", "assert countVowelStrings(7) == 330", "assert countVowelStrings(10) == 1001", "assert countVowelStrings(15) == 3876"]}, {"author": "Calvin", "UUID": "d0ce7430-cfcd-4c69-b161-b3b2a186422c", "question": "Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.\n\nIn other words, return true if one of s1's permutations is the substring of s2.", "examples": "Input: s1 = \"ab\", s2 = \"eidbaooo\"\nOutput: True\n\nInput: s1 = \"ab\", s2 = \"eidboaoo\"\nOutput: False", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef permutation_in_string(s1: str, s2: str) -> bool:\n  window = len(s1)\n  if window > len(s2):\n    return False\n  freq1 = [0]*26\n  freq2 = [0]*26\n  for i in range(window):\n    freq1[ord(s1[i])-ord('a')] += 1\n    freq2[ord(s2[i])-ord('a')] += 1\n\n  matches = 0\n  for i in range(26):\n    if freq1[i] == freq2[i]:\n      matches += 1\n  \n  for l in range(len(s2) - window):\n    if matches == 26:\n      return True\n\n    added = ord(s2[l + window]) - ord('a')\n    freq2[added] += 1\n    if freq1[added] == freq2[added]:\n      matches += 1\n    elif freq1[added] + 1 == freq2[added]:\n      matches -= 1\n\n    removed = ord(s2[l]) - ord('a')\n    freq2[removed] -= 1\n    if freq1[removed] == freq2[removed]:\n      matches += 1\n    elif freq1[removed] == freq2[removed] + 1:\n      matches -= 1\n    \n  return matches == 26\n", "asserts": ["assert permutation_in_string(\"hello\", \"ooollehhhhh\") == True", "assert permutation_in_string(\"abc\", \"ccccbbbbaaaa\") == False", "assert permutation_in_string(\"xyz\", \"zxyopqrstuv\") == True", "assert permutation_in_string(\"xyz\", \"xzygxzyzxyzk\") == True", "assert permutation_in_string(\"a\", \"a\") == True", "assert permutation_in_string(\"adc\", \"dcda\") == True", "assert permutation_in_string(\"pq\", \"qpqqp\") == True", "assert permutation_in_string(\"kitten\", \"sittingkite\") == False", "assert permutation_in_string(\"pq\", \"pqpqr\") == True", "assert permutation_in_string(\"aba\", \"aabaabaa\") == True", "assert permutation_in_string(\"\", \"\") == True  # Edge case: both strings are empty", "assert permutation_in_string(\"longerstring\", \"short\") == False  # s1 is longer than s2", "assert permutation_in_string(\"a\", \"b\") == False  # Single character, no match", "assert permutation_in_string(\"aab\", \"baa\") == True  # s1 is a permutation of s2", "assert permutation_in_string(\"ab\", \"a\") == False  # s2 is shorter than s1", "assert permutation_in_string(\"ba\", \"eidbaooo\") == True  # Same characters as Example 1 but different permutation", "assert permutation_in_string(\"eid\", \"eidbaooo\") == True  # s1 is a prefix of s2", "assert permutation_in_string(\"ooo\", \"eidbaooo\") == True  # s1 is a suffix of s2", "assert permutation_in_string(\"db\", \"eidbaooo\") == True  # s1 is a permutation within s2", "assert permutation_in_string(\"eidoo\", \"eidbaooo\") == False  # s1 is longer than any permutation within s2"]}], "category": "String", "prompt_tokens": 1255, "total_tokens": 1717, "completion_tokens": 462, "completion": "Given a string s, find the length of the longest substring without repeating characters.\n\n###Code:\n\ndef length_of_longest_substring(s: str) -> int:\n    char_index_map = {}\n    longest = 0\n    left = 0\n\n    for right in range(len(s)):\n        if s[right] in char_index_map and char_index_map[s[right]] >= left:\n            left = char_index_map[s[right]] + 1\n        char_index_map[s[right]] = right\n        longest = max(longest, right - left + 1)\n    return longest\n\n###Testcases: \n\nassert length_of_longest_substring(\"abcabcbb\") == 3\nassert length_of_longest_substring(\"bbbbb\") == 1\nassert length_of_longest_substring(\"pwwkew\") == 3\nassert length_of_longest_substring(\"\") == 0\nassert length_of_longest_substring(\" \") == 1\nassert length_of_longest_substring(\"au\") == 2\nassert length_of_longest_substring(\"dvdf\") == 3\nassert length_of_longest_substring(\"anviaj\") == 5\nassert length_of_longest_substring(\"abba\") == 2\nassert length_of_longest_substring(\"tmmzuxt\") == 5\nassert length_of_longest_substring(\"abcdefg\") == 7\nassert length_of_longest_substring(\"aab\") == 2\nassert length_of_longest_substring(\"aabaab!bb\") == 3\n\n# Unique test cases not in the original list.\nassert length_of_longest_substring(\"nrfzh\") == 5  # Entire string is a substring\nassert length_of_longest_substring(\"cdd\") == 2  # Repeating character in the middle\nassert length_of_longest_substring(\"asjrgapa\") == 6  # Repeating character at the end\nassert length_of_longest_substring(\"ohomm\") == 3  # Repeating characters at the start and end\nassert length_of_longest_substring(\"jbpnbwwd\") == 4  # Repeating characters with non-repeating ones in between\n\n[/Example 3]", "temperature": 0.844}, {"few_shots": [{"author": "Calvin", "UUID": "56b48f6d-0d81-478d-b838-4d47b62d3031", "question": "Given an integer n, return the number of strings of length n that consist only of vowels (a, e, i, o, u) and are lexicographically sorted.\n\nA string s is lexicographically sorted if for all valid i, s[i] is the same as or comes before s[i+1] in the alphabet.", "examples": "Input: 1\nOutput: 5\n\nInput: 2\nOutput: 15", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def helper(n, letter_idx):\n  letters = [\"a\",\"e\",\"i\",\"o\",\"u\"]\n  dynamic = {\n      'a1' : 5,\n      'e1' : 4,\n      'i1' : 3,\n      'o1' : 2,\n      'u1' : 1\n  }\n  ret = 0\n  key = letters[letter_idx] + str(n)\n  if key in dynamic.keys():\n    return dynamic[key]\n  else:\n    for i in range(letter_idx, len(letters)):\n      ret += helper(n-1, i)\n    dynamic[key] = ret\n  return ret\n  \n\ndef countVowelStrings(n: int) -> int:\n  return helper(n, 0)\n", "asserts": ["assert countVowelStrings(3) == 35", "assert countVowelStrings(4) == 70", "assert countVowelStrings(5) == 126", "assert countVowelStrings(6) == 210", "assert countVowelStrings(7) == 330", "assert countVowelStrings(10) == 1001", "assert countVowelStrings(15) == 3876"]}, {"author": "Calvin", "UUID": "d0ce7430-cfcd-4c69-b161-b3b2a186422c", "question": "Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.\n\nIn other words, return true if one of s1's permutations is the substring of s2.", "examples": "Input: s1 = \"ab\", s2 = \"eidbaooo\"\nOutput: True\n\nInput: s1 = \"ab\", s2 = \"eidboaoo\"\nOutput: False", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef permutation_in_string(s1: str, s2: str) -> bool:\n  window = len(s1)\n  if window > len(s2):\n    return False\n  freq1 = [0]*26\n  freq2 = [0]*26\n  for i in range(window):\n    freq1[ord(s1[i])-ord('a')] += 1\n    freq2[ord(s2[i])-ord('a')] += 1\n\n  matches = 0\n  for i in range(26):\n    if freq1[i] == freq2[i]:\n      matches += 1\n  \n  for l in range(len(s2) - window):\n    if matches == 26:\n      return True\n\n    added = ord(s2[l + window]) - ord('a')\n    freq2[added] += 1\n    if freq1[added] == freq2[added]:\n      matches += 1\n    elif freq1[added] + 1 == freq2[added]:\n      matches -= 1\n\n    removed = ord(s2[l]) - ord('a')\n    freq2[removed] -= 1\n    if freq1[removed] == freq2[removed]:\n      matches += 1\n    elif freq1[removed] == freq2[removed] + 1:\n      matches -= 1\n    \n  return matches == 26\n", "asserts": ["assert permutation_in_string(\"hello\", \"ooollehhhhh\") == True", "assert permutation_in_string(\"abc\", \"ccccbbbbaaaa\") == False", "assert permutation_in_string(\"xyz\", \"zxyopqrstuv\") == True", "assert permutation_in_string(\"xyz\", \"xzygxzyzxyzk\") == True", "assert permutation_in_string(\"a\", \"a\") == True", "assert permutation_in_string(\"adc\", \"dcda\") == True", "assert permutation_in_string(\"pq\", \"qpqqp\") == True", "assert permutation_in_string(\"kitten\", \"sittingkite\") == False", "assert permutation_in_string(\"pq\", \"pqpqr\") == True", "assert permutation_in_string(\"aba\", \"aabaabaa\") == True", "assert permutation_in_string(\"\", \"\") == True  # Edge case: both strings are empty", "assert permutation_in_string(\"longerstring\", \"short\") == False  # s1 is longer than s2", "assert permutation_in_string(\"a\", \"b\") == False  # Single character, no match", "assert permutation_in_string(\"aab\", \"baa\") == True  # s1 is a permutation of s2", "assert permutation_in_string(\"ab\", \"a\") == False  # s2 is shorter than s1", "assert permutation_in_string(\"ba\", \"eidbaooo\") == True  # Same characters as Example 1 but different permutation", "assert permutation_in_string(\"eid\", \"eidbaooo\") == True  # s1 is a prefix of s2", "assert permutation_in_string(\"ooo\", \"eidbaooo\") == True  # s1 is a suffix of s2", "assert permutation_in_string(\"db\", \"eidbaooo\") == True  # s1 is a permutation within s2", "assert permutation_in_string(\"eidoo\", \"eidbaooo\") == False  # s1 is longer than any permutation within s2"]}], "category": "String", "prompt_tokens": 1255, "total_tokens": 1666, "completion_tokens": 411, "completion": "Given a string s, find the length of the longest substring without repeating characters.\n\n###Code: \n\ndef length_of_longest_substring(s: str) -> int:\n    char_map = {}\n    left = 0\n    max_length = 0\n\n    for right in range(len(s)):\n        if s[right] in char_map:\n            left = max(left, char_map[s[right]] + 1)\n        char_map[s[right]] = right\n        max_length = max(max_length, right - left + 1)\n\n    return max_length\n\n###Testcases: \n\nassert length_of_longest_substring(\"abcabcbb\") == 3\nassert length_of_longest_substring(\"bbbbb\") == 1\nassert length_of_longest_substring(\"pwwkew\") == 3\nassert length_of_longest_substring(\"\") == 0\nassert length_of_longest_substring(\" \") == 1\nassert length_of_longest_substring(\"dvdf\") == 3\nassert length_of_longest_substring(\"anviaj\") == 5\nassert length_of_longest_substring(\"abcadef\") == 6\nassert length_of_longest_substring(\"tmmzuxt\") == 5\nassert length_of_longest_substring(\"aabaab!bb\") == 3\nassert length_of_longest_substring(\"ab!@#ba!@#\") == 6\nassert length_of_longest_substring(\"nfpdmpi\") == 5\nassert length_of_longest_substring(\"au\") == 2\nassert length_of_longest_substring(\"aab\") == 2\nassert length_of_longest_substring(\"abba\") == 2\nassert length_of_longest_substring(\"ohvhjdml\") == 6\nassert length_of_longest_substring(\"ckilbkd\") == 5\nassert length_of_longest_substring(\"bpfbhmipx\") == 7\n\n[/Example 3]", "temperature": 0.732}, {"few_shots": [{"author": "Calvin", "UUID": "56b48f6d-0d81-478d-b838-4d47b62d3031", "question": "Given an integer n, return the number of strings of length n that consist only of vowels (a, e, i, o, u) and are lexicographically sorted.\n\nA string s is lexicographically sorted if for all valid i, s[i] is the same as or comes before s[i+1] in the alphabet.", "examples": "Input: 1\nOutput: 5\n\nInput: 2\nOutput: 15", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def helper(n, letter_idx):\n  letters = [\"a\",\"e\",\"i\",\"o\",\"u\"]\n  dynamic = {\n      'a1' : 5,\n      'e1' : 4,\n      'i1' : 3,\n      'o1' : 2,\n      'u1' : 1\n  }\n  ret = 0\n  key = letters[letter_idx] + str(n)\n  if key in dynamic.keys():\n    return dynamic[key]\n  else:\n    for i in range(letter_idx, len(letters)):\n      ret += helper(n-1, i)\n    dynamic[key] = ret\n  return ret\n  \n\ndef countVowelStrings(n: int) -> int:\n  return helper(n, 0)\n", "asserts": ["assert countVowelStrings(3) == 35", "assert countVowelStrings(4) == 70", "assert countVowelStrings(5) == 126", "assert countVowelStrings(6) == 210", "assert countVowelStrings(7) == 330", "assert countVowelStrings(10) == 1001", "assert countVowelStrings(15) == 3876"]}, {"author": "Calvin", "UUID": "d0ce7430-cfcd-4c69-b161-b3b2a186422c", "question": "Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.\n\nIn other words, return true if one of s1's permutations is the substring of s2.", "examples": "Input: s1 = \"ab\", s2 = \"eidbaooo\"\nOutput: True\n\nInput: s1 = \"ab\", s2 = \"eidboaoo\"\nOutput: False", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef permutation_in_string(s1: str, s2: str) -> bool:\n  window = len(s1)\n  if window > len(s2):\n    return False\n  freq1 = [0]*26\n  freq2 = [0]*26\n  for i in range(window):\n    freq1[ord(s1[i])-ord('a')] += 1\n    freq2[ord(s2[i])-ord('a')] += 1\n\n  matches = 0\n  for i in range(26):\n    if freq1[i] == freq2[i]:\n      matches += 1\n  \n  for l in range(len(s2) - window):\n    if matches == 26:\n      return True\n\n    added = ord(s2[l + window]) - ord('a')\n    freq2[added] += 1\n    if freq1[added] == freq2[added]:\n      matches += 1\n    elif freq1[added] + 1 == freq2[added]:\n      matches -= 1\n\n    removed = ord(s2[l]) - ord('a')\n    freq2[removed] -= 1\n    if freq1[removed] == freq2[removed]:\n      matches += 1\n    elif freq1[removed] == freq2[removed] + 1:\n      matches -= 1\n    \n  return matches == 26\n", "asserts": ["assert permutation_in_string(\"hello\", \"ooollehhhhh\") == True", "assert permutation_in_string(\"abc\", \"ccccbbbbaaaa\") == False", "assert permutation_in_string(\"xyz\", \"zxyopqrstuv\") == True", "assert permutation_in_string(\"xyz\", \"xzygxzyzxyzk\") == True", "assert permutation_in_string(\"a\", \"a\") == True", "assert permutation_in_string(\"adc\", \"dcda\") == True", "assert permutation_in_string(\"pq\", \"qpqqp\") == True", "assert permutation_in_string(\"kitten\", \"sittingkite\") == False", "assert permutation_in_string(\"pq\", \"pqpqr\") == True", "assert permutation_in_string(\"aba\", \"aabaabaa\") == True", "assert permutation_in_string(\"\", \"\") == True  # Edge case: both strings are empty", "assert permutation_in_string(\"longerstring\", \"short\") == False  # s1 is longer than s2", "assert permutation_in_string(\"a\", \"b\") == False  # Single character, no match", "assert permutation_in_string(\"aab\", \"baa\") == True  # s1 is a permutation of s2", "assert permutation_in_string(\"ab\", \"a\") == False  # s2 is shorter than s1", "assert permutation_in_string(\"ba\", \"eidbaooo\") == True  # Same characters as Example 1 but different permutation", "assert permutation_in_string(\"eid\", \"eidbaooo\") == True  # s1 is a prefix of s2", "assert permutation_in_string(\"ooo\", \"eidbaooo\") == True  # s1 is a suffix of s2", "assert permutation_in_string(\"db\", \"eidbaooo\") == True  # s1 is a permutation within s2", "assert permutation_in_string(\"eidoo\", \"eidbaooo\") == False  # s1 is longer than any permutation within s2"]}], "category": "String", "prompt_tokens": 1255, "total_tokens": 1797, "completion_tokens": 542, "completion": "Given a non-empty string s and an integer k, rearrange the string such that the same characters are at least distance k from each other.\n\nIf it is not possible to rearrange the string, return an empty string \"\".\n\n###Code: \n\n```python\nfrom collections import Counter\nimport heapq\n\ndef rearrange_string(s: str, k: int) -> str:\n    if k == 0:\n        return s\n    \n    # Count frequency of each character and use max heap\n    frequency = Counter(s)\n    max_heap = [(-freq, char) for char, freq in frequency.items()]\n    heapq.heapify(max_heap)\n    \n    result = []\n    queue = []\n    \n    while max_heap:\n        freq, char = heapq.heappop(max_heap)\n        result.append(char)\n        \n        queue.append((freq + 1, char))  # Increment freq since it's a negative value\n        if len(queue) < k:\n            continue\n        \n        # Maintain the k distance window\n        ready_freq, ready_char = queue.pop(0)\n        if -ready_freq > 0:\n            heapq.heappush(max_heap, (ready_freq, ready_char))\n    \n    result_string = ''.join(result)\n    # Verify that result maintains k distance\n    for i in range(len(result_string) - k):\n        if result_string[i] == result_string[i + k]:\n            return \"\"\n    \n    return result_string\n```\n\n###Testcases: \n\n```python\nassert rearrange_string(\"aabbcc\", 3) == \"abcabc\" or rearrange_string(\"aabbcc\", 3) == \"bacbac\" or rearrange_string(\"aabbcc\", 3) == \"cabcab\"\nassert rearrange_string(\"aaabc\", 3) == \"\"\nassert rearrange_string(\"aaadbbcc\", 2) == \"abacabcd\" or rearrange_string(\"aaadbbcc\", 2) == \"bacabacd\"\nassert rearrange_string(\"a\", 2) == \"a\"\nassert rearrange_string(\"aa\", 0) == \"aa\"\nassert rearrange_string(\"aa\", 2) == \"\"\nassert rearrange_string(\"aaa\", 2) == \"\"\nassert rearrange_string(\"aaabc\", 2) == \"abaca\"\nassert rearrange_string(\"aabb\", 2) == \"abab\" or rearrange_string(\"aabb\", 2) == \"baba\"\nassert rearrange_string(\"aaabbbccc\", 3) == \"abcabcabc\"\nassert rearrange_string(\"programming\", 3) != \"\"\n```\n\n[/Example 3]", "temperature": 0.875}, {"few_shots": [{"author": "Calvin", "UUID": "56b48f6d-0d81-478d-b838-4d47b62d3031", "question": "Given an integer n, return the number of strings of length n that consist only of vowels (a, e, i, o, u) and are lexicographically sorted.\n\nA string s is lexicographically sorted if for all valid i, s[i] is the same as or comes before s[i+1] in the alphabet.", "examples": "Input: 1\nOutput: 5\n\nInput: 2\nOutput: 15", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def helper(n, letter_idx):\n  letters = [\"a\",\"e\",\"i\",\"o\",\"u\"]\n  dynamic = {\n      'a1' : 5,\n      'e1' : 4,\n      'i1' : 3,\n      'o1' : 2,\n      'u1' : 1\n  }\n  ret = 0\n  key = letters[letter_idx] + str(n)\n  if key in dynamic.keys():\n    return dynamic[key]\n  else:\n    for i in range(letter_idx, len(letters)):\n      ret += helper(n-1, i)\n    dynamic[key] = ret\n  return ret\n  \n\ndef countVowelStrings(n: int) -> int:\n  return helper(n, 0)\n", "asserts": ["assert countVowelStrings(3) == 35", "assert countVowelStrings(4) == 70", "assert countVowelStrings(5) == 126", "assert countVowelStrings(6) == 210", "assert countVowelStrings(7) == 330", "assert countVowelStrings(10) == 1001", "assert countVowelStrings(15) == 3876"]}, {"author": "Calvin", "UUID": "d0ce7430-cfcd-4c69-b161-b3b2a186422c", "question": "Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.\n\nIn other words, return true if one of s1's permutations is the substring of s2.", "examples": "Input: s1 = \"ab\", s2 = \"eidbaooo\"\nOutput: True\n\nInput: s1 = \"ab\", s2 = \"eidboaoo\"\nOutput: False", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef permutation_in_string(s1: str, s2: str) -> bool:\n  window = len(s1)\n  if window > len(s2):\n    return False\n  freq1 = [0]*26\n  freq2 = [0]*26\n  for i in range(window):\n    freq1[ord(s1[i])-ord('a')] += 1\n    freq2[ord(s2[i])-ord('a')] += 1\n\n  matches = 0\n  for i in range(26):\n    if freq1[i] == freq2[i]:\n      matches += 1\n  \n  for l in range(len(s2) - window):\n    if matches == 26:\n      return True\n\n    added = ord(s2[l + window]) - ord('a')\n    freq2[added] += 1\n    if freq1[added] == freq2[added]:\n      matches += 1\n    elif freq1[added] + 1 == freq2[added]:\n      matches -= 1\n\n    removed = ord(s2[l]) - ord('a')\n    freq2[removed] -= 1\n    if freq1[removed] == freq2[removed]:\n      matches += 1\n    elif freq1[removed] == freq2[removed] + 1:\n      matches -= 1\n    \n  return matches == 26\n", "asserts": ["assert permutation_in_string(\"hello\", \"ooollehhhhh\") == True", "assert permutation_in_string(\"abc\", \"ccccbbbbaaaa\") == False", "assert permutation_in_string(\"xyz\", \"zxyopqrstuv\") == True", "assert permutation_in_string(\"xyz\", \"xzygxzyzxyzk\") == True", "assert permutation_in_string(\"a\", \"a\") == True", "assert permutation_in_string(\"adc\", \"dcda\") == True", "assert permutation_in_string(\"pq\", \"qpqqp\") == True", "assert permutation_in_string(\"kitten\", \"sittingkite\") == False", "assert permutation_in_string(\"pq\", \"pqpqr\") == True", "assert permutation_in_string(\"aba\", \"aabaabaa\") == True", "assert permutation_in_string(\"\", \"\") == True  # Edge case: both strings are empty", "assert permutation_in_string(\"longerstring\", \"short\") == False  # s1 is longer than s2", "assert permutation_in_string(\"a\", \"b\") == False  # Single character, no match", "assert permutation_in_string(\"aab\", \"baa\") == True  # s1 is a permutation of s2", "assert permutation_in_string(\"ab\", \"a\") == False  # s2 is shorter than s1", "assert permutation_in_string(\"ba\", \"eidbaooo\") == True  # Same characters as Example 1 but different permutation", "assert permutation_in_string(\"eid\", \"eidbaooo\") == True  # s1 is a prefix of s2", "assert permutation_in_string(\"ooo\", \"eidbaooo\") == True  # s1 is a suffix of s2", "assert permutation_in_string(\"db\", \"eidbaooo\") == True  # s1 is a permutation within s2", "assert permutation_in_string(\"eidoo\", \"eidbaooo\") == False  # s1 is longer than any permutation within s2"]}], "category": "String", "prompt_tokens": 1255, "total_tokens": 1620, "completion_tokens": 365, "completion": "Write a function to find the longest common prefix string amongst an array of strings.\n\nIf there is no common prefix, return an empty string \"\".\n\n###Code:\n\n```python\ndef longest_common_prefix(strs):\n    if not strs:\n        return \"\"\n    \n    shortest = min(strs, key=len)\n    for i, ch in enumerate(shortest):\n        for other in strs:\n            if other[i] != ch:\n                return shortest[:i]\n    return shortest\n\n\n###Testcases:\n\nassert longest_common_prefix([\"flower\",\"flow\",\"flight\"]) == \"fl\"\nassert longest_common_prefix([\"dog\",\"racecar\",\"car\"]) == \"\"\nassert longest_common_prefix([\"interspecies\",\"interstellar\",\"interstate\"]) == \"inters\"\nassert longest_common_prefix([\"throne\",\"dungeon\"]) == \"\"\nassert longest_common_prefix([\"throne\",\"throne\"]) == \"throne\"\nassert longest_common_prefix([\"prefix\",\"preposition\",\"presume\"]) == \"pre\"\nassert longest_common_prefix([\"\"]) == \"\"\nassert longest_common_prefix([\"a\"]) == \"a\"\nassert longest_common_prefix([\"ab\", \"a\"]) == \"a\"\nassert longest_common_prefix([\"\", \"\"]) == \"\"\nassert longest_common_prefix([\"\", \"b\"]) == \"\"\nassert longest_common_prefix([\"abcde\", \"abfgh\", \"abqwe\"]) == \"ab\"\nassert longest_common_prefix([\"correspond\", \"correlation\", \"core\"]) == \"cor\"\nassert longest_common_prefix([\"mark\", \"market\", \"marking\"]) == \"mark\"\nassert longest_common_prefix([\"classroom\", \"classy\", \"class\"]) == \"class\"\nassert longest_common_prefix([\"\", \"notempty\", \"stillnotempty\"]) == \"\"\nassert longest_common_prefix([\"same\", \"same\", \"same\"]) == \"same\"\n```\n\n[/Example 3]", "temperature": 0.758}, {"few_shots": [{"author": "Calvin", "UUID": "56b48f6d-0d81-478d-b838-4d47b62d3031", "question": "Given an integer n, return the number of strings of length n that consist only of vowels (a, e, i, o, u) and are lexicographically sorted.\n\nA string s is lexicographically sorted if for all valid i, s[i] is the same as or comes before s[i+1] in the alphabet.", "examples": "Input: 1\nOutput: 5\n\nInput: 2\nOutput: 15", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def helper(n, letter_idx):\n  letters = [\"a\",\"e\",\"i\",\"o\",\"u\"]\n  dynamic = {\n      'a1' : 5,\n      'e1' : 4,\n      'i1' : 3,\n      'o1' : 2,\n      'u1' : 1\n  }\n  ret = 0\n  key = letters[letter_idx] + str(n)\n  if key in dynamic.keys():\n    return dynamic[key]\n  else:\n    for i in range(letter_idx, len(letters)):\n      ret += helper(n-1, i)\n    dynamic[key] = ret\n  return ret\n  \n\ndef countVowelStrings(n: int) -> int:\n  return helper(n, 0)\n", "asserts": ["assert countVowelStrings(3) == 35", "assert countVowelStrings(4) == 70", "assert countVowelStrings(5) == 126", "assert countVowelStrings(6) == 210", "assert countVowelStrings(7) == 330", "assert countVowelStrings(10) == 1001", "assert countVowelStrings(15) == 3876"]}, {"author": "Calvin", "UUID": "d0ce7430-cfcd-4c69-b161-b3b2a186422c", "question": "Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.\n\nIn other words, return true if one of s1's permutations is the substring of s2.", "examples": "Input: s1 = \"ab\", s2 = \"eidbaooo\"\nOutput: True\n\nInput: s1 = \"ab\", s2 = \"eidboaoo\"\nOutput: False", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef permutation_in_string(s1: str, s2: str) -> bool:\n  window = len(s1)\n  if window > len(s2):\n    return False\n  freq1 = [0]*26\n  freq2 = [0]*26\n  for i in range(window):\n    freq1[ord(s1[i])-ord('a')] += 1\n    freq2[ord(s2[i])-ord('a')] += 1\n\n  matches = 0\n  for i in range(26):\n    if freq1[i] == freq2[i]:\n      matches += 1\n  \n  for l in range(len(s2) - window):\n    if matches == 26:\n      return True\n\n    added = ord(s2[l + window]) - ord('a')\n    freq2[added] += 1\n    if freq1[added] == freq2[added]:\n      matches += 1\n    elif freq1[added] + 1 == freq2[added]:\n      matches -= 1\n\n    removed = ord(s2[l]) - ord('a')\n    freq2[removed] -= 1\n    if freq1[removed] == freq2[removed]:\n      matches += 1\n    elif freq1[removed] == freq2[removed] + 1:\n      matches -= 1\n    \n  return matches == 26\n", "asserts": ["assert permutation_in_string(\"hello\", \"ooollehhhhh\") == True", "assert permutation_in_string(\"abc\", \"ccccbbbbaaaa\") == False", "assert permutation_in_string(\"xyz\", \"zxyopqrstuv\") == True", "assert permutation_in_string(\"xyz\", \"xzygxzyzxyzk\") == True", "assert permutation_in_string(\"a\", \"a\") == True", "assert permutation_in_string(\"adc\", \"dcda\") == True", "assert permutation_in_string(\"pq\", \"qpqqp\") == True", "assert permutation_in_string(\"kitten\", \"sittingkite\") == False", "assert permutation_in_string(\"pq\", \"pqpqr\") == True", "assert permutation_in_string(\"aba\", \"aabaabaa\") == True", "assert permutation_in_string(\"\", \"\") == True  # Edge case: both strings are empty", "assert permutation_in_string(\"longerstring\", \"short\") == False  # s1 is longer than s2", "assert permutation_in_string(\"a\", \"b\") == False  # Single character, no match", "assert permutation_in_string(\"aab\", \"baa\") == True  # s1 is a permutation of s2", "assert permutation_in_string(\"ab\", \"a\") == False  # s2 is shorter than s1", "assert permutation_in_string(\"ba\", \"eidbaooo\") == True  # Same characters as Example 1 but different permutation", "assert permutation_in_string(\"eid\", \"eidbaooo\") == True  # s1 is a prefix of s2", "assert permutation_in_string(\"ooo\", \"eidbaooo\") == True  # s1 is a suffix of s2", "assert permutation_in_string(\"db\", \"eidbaooo\") == True  # s1 is a permutation within s2", "assert permutation_in_string(\"eidoo\", \"eidbaooo\") == False  # s1 is longer than any permutation within s2"]}], "category": "String", "prompt_tokens": 1255, "total_tokens": 1671, "completion_tokens": 416, "completion": "Given a string containing just the characters '(' and ')', find the length of the longest valid (well-formed) parentheses substring.\n\n###Code:\n\n```python\ndef longest_valid_parentheses(s: str) -> int:\n    max_len = 0\n    stack = [-1]\n    for i, char in enumerate(s):\n        if char == '(':\n            stack.append(i)\n        else:\n            stack.pop()\n            if stack:\n                max_len = max(max_len, i - stack[-1])\n            else:\n                stack.append(i)\n    return max_len\n```\n\n###Testcases:\n\n```python\nassert longest_valid_parentheses(\"(()\") == 2\nassert longest_valid_parentheses(\")()())\") == 4\nassert longest_valid_parentheses(\"\") == 0\nassert longest_valid_parentheses(\"(((((((()\") == 2\nassert longest_valid_parentheses(\"()(()\") == 2\nassert longest_valid_parentheses(\"()((()))\") == 8\nassert longest_valid_parentheses(\"(()(((()\") == 2\nassert longest_valid_parentheses(\"((()()(()))(\") == 10\nassert longest_valid_parentheses(\"((())())\") == 8\nassert longest_valid_parentheses(\"()\") == 2\nassert longest_valid_parentheses(\"(()())\") == 6\nassert longest_valid_parentheses(\"())\") == 2\nassert longest_valid_parentheses(\"()(())\") == 6\nassert longest_valid_parentheses(\"()(()())\") == 8\nassert longest_valid_parentheses(\"(((((())\") == 4\nassert longest_valid_parentheses(\")(\") == 0\nassert longest_valid_parentheses(\"(()()\") == 4\nassert longest_valid_parentheses(\"((()))\") == 6\nassert longest_valid_parentheses(\")(())(\") == 4\nassert longest_valid_parentheses(\"()()\") == 4\n```\n\n[/Example 3]", "temperature": 0.811}, {"few_shots": [{"author": "Calvin", "UUID": "56b48f6d-0d81-478d-b838-4d47b62d3031", "question": "Given an integer n, return the number of strings of length n that consist only of vowels (a, e, i, o, u) and are lexicographically sorted.\n\nA string s is lexicographically sorted if for all valid i, s[i] is the same as or comes before s[i+1] in the alphabet.", "examples": "Input: 1\nOutput: 5\n\nInput: 2\nOutput: 15", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def helper(n, letter_idx):\n  letters = [\"a\",\"e\",\"i\",\"o\",\"u\"]\n  dynamic = {\n      'a1' : 5,\n      'e1' : 4,\n      'i1' : 3,\n      'o1' : 2,\n      'u1' : 1\n  }\n  ret = 0\n  key = letters[letter_idx] + str(n)\n  if key in dynamic.keys():\n    return dynamic[key]\n  else:\n    for i in range(letter_idx, len(letters)):\n      ret += helper(n-1, i)\n    dynamic[key] = ret\n  return ret\n  \n\ndef countVowelStrings(n: int) -> int:\n  return helper(n, 0)\n", "asserts": ["assert countVowelStrings(3) == 35", "assert countVowelStrings(4) == 70", "assert countVowelStrings(5) == 126", "assert countVowelStrings(6) == 210", "assert countVowelStrings(7) == 330", "assert countVowelStrings(10) == 1001", "assert countVowelStrings(15) == 3876"]}, {"author": "Calvin", "UUID": "d0ce7430-cfcd-4c69-b161-b3b2a186422c", "question": "Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.\n\nIn other words, return true if one of s1's permutations is the substring of s2.", "examples": "Input: s1 = \"ab\", s2 = \"eidbaooo\"\nOutput: True\n\nInput: s1 = \"ab\", s2 = \"eidboaoo\"\nOutput: False", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef permutation_in_string(s1: str, s2: str) -> bool:\n  window = len(s1)\n  if window > len(s2):\n    return False\n  freq1 = [0]*26\n  freq2 = [0]*26\n  for i in range(window):\n    freq1[ord(s1[i])-ord('a')] += 1\n    freq2[ord(s2[i])-ord('a')] += 1\n\n  matches = 0\n  for i in range(26):\n    if freq1[i] == freq2[i]:\n      matches += 1\n  \n  for l in range(len(s2) - window):\n    if matches == 26:\n      return True\n\n    added = ord(s2[l + window]) - ord('a')\n    freq2[added] += 1\n    if freq1[added] == freq2[added]:\n      matches += 1\n    elif freq1[added] + 1 == freq2[added]:\n      matches -= 1\n\n    removed = ord(s2[l]) - ord('a')\n    freq2[removed] -= 1\n    if freq1[removed] == freq2[removed]:\n      matches += 1\n    elif freq1[removed] == freq2[removed] + 1:\n      matches -= 1\n    \n  return matches == 26\n", "asserts": ["assert permutation_in_string(\"hello\", \"ooollehhhhh\") == True", "assert permutation_in_string(\"abc\", \"ccccbbbbaaaa\") == False", "assert permutation_in_string(\"xyz\", \"zxyopqrstuv\") == True", "assert permutation_in_string(\"xyz\", \"xzygxzyzxyzk\") == True", "assert permutation_in_string(\"a\", \"a\") == True", "assert permutation_in_string(\"adc\", \"dcda\") == True", "assert permutation_in_string(\"pq\", \"qpqqp\") == True", "assert permutation_in_string(\"kitten\", \"sittingkite\") == False", "assert permutation_in_string(\"pq\", \"pqpqr\") == True", "assert permutation_in_string(\"aba\", \"aabaabaa\") == True", "assert permutation_in_string(\"\", \"\") == True  # Edge case: both strings are empty", "assert permutation_in_string(\"longerstring\", \"short\") == False  # s1 is longer than s2", "assert permutation_in_string(\"a\", \"b\") == False  # Single character, no match", "assert permutation_in_string(\"aab\", \"baa\") == True  # s1 is a permutation of s2", "assert permutation_in_string(\"ab\", \"a\") == False  # s2 is shorter than s1", "assert permutation_in_string(\"ba\", \"eidbaooo\") == True  # Same characters as Example 1 but different permutation", "assert permutation_in_string(\"eid\", \"eidbaooo\") == True  # s1 is a prefix of s2", "assert permutation_in_string(\"ooo\", \"eidbaooo\") == True  # s1 is a suffix of s2", "assert permutation_in_string(\"db\", \"eidbaooo\") == True  # s1 is a permutation within s2", "assert permutation_in_string(\"eidoo\", \"eidbaooo\") == False  # s1 is longer than any permutation within s2"]}], "category": "String", "prompt_tokens": 1255, "total_tokens": 1777, "completion_tokens": 522, "completion": "Given a string s, return the longest palindromic substring in s.\n\nA string is called a palindrome if it reads the same backward as forward.\n\n###Code:\n\ndef longest_palindrome(s: str) -> str:\n    if len(s) == 0:\n        return \"\"\n    \n    start = end = 0\n    \n    def expand_around_center(left: int, right: int) -> int:\n        while left >= 0 and right < len(s) and s[left] == s[right]:\n            left -= 1\n            right += 1\n        return right - left - 1\n    \n    for i in range(len(s)):\n        len1 = expand_around_center(i, i)\n        len2 = expand_around_center(i, i + 1)\n        max_len = max(len1, len2)\n        \n        if max_len > (end - start):\n            start = i - (max_len - 1) // 2\n            end = i + max_len // 2\n        \n    return s[start:end + 1]\n\n###Testcases:\n\nassert longest_palindrome(\"babad\") == \"bab\" or longest_palindrome(\"babad\") == \"aba\"\nassert longest_palindrome(\"cbbd\") == \"bb\"\nassert longest_palindrome(\"a\") == \"a\"\nassert longest_palindrome(\"ac\") == \"a\" or longest_palindrome(\"ac\") == \"c\"\nassert longest_palindrome(\"racecar\") == \"racecar\"\nassert longest_palindrome(\"forgeeksskeegfor\") == \"geeksskeeg\"\nassert longest_palindrome(\"abacdfgdcaba\") == \"aba\"\nassert longest_palindrome(\"abacdfgdcabba\") == \"abba\"\nassert longest_palindrome(\"abacdedcaba\") == \"abacdedcaba\"\nassert longest_palindrome(\"\") == \"\"  # Edge case: empty string\nassert longest_palindrome(\"a\") == \"a\"  # Single character\nassert longest_palindrome(\"aa\") == \"aa\"  # Two of the same character\nassert longest_palindrome(\"ab\") == \"a\" or longest_palindrome(\"ab\") == \"b\"  # No palindrome longer than 1 character\nassert longest_palindrome(\"aaaa\") == \"aaaa\"  # Entire string is a palindrome\nassert longest_palindrome(\"banana\") == \"anana\"  # Palindrome in the middle\nassert longest_palindrome(\"million\") == \"illi\"  # Palindrome in the middle\n\n[/Example 3]", "temperature": 0.676}, {"few_shots": [{"author": "Calvin", "UUID": "56b48f6d-0d81-478d-b838-4d47b62d3031", "question": "Given an integer n, return the number of strings of length n that consist only of vowels (a, e, i, o, u) and are lexicographically sorted.\n\nA string s is lexicographically sorted if for all valid i, s[i] is the same as or comes before s[i+1] in the alphabet.", "examples": "Input: 1\nOutput: 5\n\nInput: 2\nOutput: 15", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def helper(n, letter_idx):\n  letters = [\"a\",\"e\",\"i\",\"o\",\"u\"]\n  dynamic = {\n      'a1' : 5,\n      'e1' : 4,\n      'i1' : 3,\n      'o1' : 2,\n      'u1' : 1\n  }\n  ret = 0\n  key = letters[letter_idx] + str(n)\n  if key in dynamic.keys():\n    return dynamic[key]\n  else:\n    for i in range(letter_idx, len(letters)):\n      ret += helper(n-1, i)\n    dynamic[key] = ret\n  return ret\n  \n\ndef countVowelStrings(n: int) -> int:\n  return helper(n, 0)\n", "asserts": ["assert countVowelStrings(3) == 35", "assert countVowelStrings(4) == 70", "assert countVowelStrings(5) == 126", "assert countVowelStrings(6) == 210", "assert countVowelStrings(7) == 330", "assert countVowelStrings(10) == 1001", "assert countVowelStrings(15) == 3876"]}, {"author": "Calvin", "UUID": "d0ce7430-cfcd-4c69-b161-b3b2a186422c", "question": "Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.\n\nIn other words, return true if one of s1's permutations is the substring of s2.", "examples": "Input: s1 = \"ab\", s2 = \"eidbaooo\"\nOutput: True\n\nInput: s1 = \"ab\", s2 = \"eidboaoo\"\nOutput: False", "link": NaN, "difficulty": null, "categories": ["String"], "code": "\ndef permutation_in_string(s1: str, s2: str) -> bool:\n  window = len(s1)\n  if window > len(s2):\n    return False\n  freq1 = [0]*26\n  freq2 = [0]*26\n  for i in range(window):\n    freq1[ord(s1[i])-ord('a')] += 1\n    freq2[ord(s2[i])-ord('a')] += 1\n\n  matches = 0\n  for i in range(26):\n    if freq1[i] == freq2[i]:\n      matches += 1\n  \n  for l in range(len(s2) - window):\n    if matches == 26:\n      return True\n\n    added = ord(s2[l + window]) - ord('a')\n    freq2[added] += 1\n    if freq1[added] == freq2[added]:\n      matches += 1\n    elif freq1[added] + 1 == freq2[added]:\n      matches -= 1\n\n    removed = ord(s2[l]) - ord('a')\n    freq2[removed] -= 1\n    if freq1[removed] == freq2[removed]:\n      matches += 1\n    elif freq1[removed] == freq2[removed] + 1:\n      matches -= 1\n    \n  return matches == 26\n", "asserts": ["assert permutation_in_string(\"hello\", \"ooollehhhhh\") == True", "assert permutation_in_string(\"abc\", \"ccccbbbbaaaa\") == False", "assert permutation_in_string(\"xyz\", \"zxyopqrstuv\") == True", "assert permutation_in_string(\"xyz\", \"xzygxzyzxyzk\") == True", "assert permutation_in_string(\"a\", \"a\") == True", "assert permutation_in_string(\"adc\", \"dcda\") == True", "assert permutation_in_string(\"pq\", \"qpqqp\") == True", "assert permutation_in_string(\"kitten\", \"sittingkite\") == False", "assert permutation_in_string(\"pq\", \"pqpqr\") == True", "assert permutation_in_string(\"aba\", \"aabaabaa\") == True", "assert permutation_in_string(\"\", \"\") == True  # Edge case: both strings are empty", "assert permutation_in_string(\"longerstring\", \"short\") == False  # s1 is longer than s2", "assert permutation_in_string(\"a\", \"b\") == False  # Single character, no match", "assert permutation_in_string(\"aab\", \"baa\") == True  # s1 is a permutation of s2", "assert permutation_in_string(\"ab\", \"a\") == False  # s2 is shorter than s1", "assert permutation_in_string(\"ba\", \"eidbaooo\") == True  # Same characters as Example 1 but different permutation", "assert permutation_in_string(\"eid\", \"eidbaooo\") == True  # s1 is a prefix of s2", "assert permutation_in_string(\"ooo\", \"eidbaooo\") == True  # s1 is a suffix of s2", "assert permutation_in_string(\"db\", \"eidbaooo\") == True  # s1 is a permutation within s2", "assert permutation_in_string(\"eidoo\", \"eidbaooo\") == False  # s1 is longer than any permutation within s2"]}], "category": "String", "prompt_tokens": 1255, "total_tokens": 1912, "completion_tokens": 657, "completion": "Given a string s and an integer k, return the length of the longest substring of s that contains at most k distinct characters.\n\nIf there are multiple substrings with the same maximum length, return the length of any one of them.\n\n###Code: \n\ndef length_of_longest_substring_k_distinct(s: str, k: int) -> int:\n    if k == 0:\n        return 0\n    if len(s) <= k:\n        return len(s)\n\n    char_map = {}\n    max_length = 0\n    left = 0\n\n    for right in range(len(s)):\n        char_map[s[right]] = char_map.get(s[right], 0) + 1\n\n        while len(char_map) > k:\n            char_map[s[left]] -= 1\n            if char_map[s[left]] == 0:\n                del char_map[s[left]]\n            left += 1\n\n        max_length = max(max_length, right - left + 1)\n\n    return max_length\n\n\n###Testcases: \n\nassert length_of_longest_substring_k_distinct(\"eceba\", 2) == 3\nassert length_of_longest_substring_k_distinct(\"aa\", 1) == 2\nassert length_of_longest_substring_k_distinct(\"a\", 1) == 1\nassert length_of_longest_substring_k_distinct(\"abcadcacacaca\", 3) == 10\nassert length_of_longest_substring_k_distinct(\"abaccc\", 2) == 4\nassert length_of_longest_substring_k_distinct(\"aaabbcc\", 2) == 5\nassert length_of_longest_substring_k_distinct(\"abababcdefababcdab\", 3) == 7\nassert length_of_longest_substring_k_distinct(\"bacc\", 2) == 3\nassert length_of_longest_substring_k_distinct(\"\", 3) == 0  # Edge case: empty string\nassert length_of_longest_substring_k_distinct(\"abcde\", 0) == 0  # Edge case: k is 0\nassert length_of_longest_substring_k_distinct(\"aaabbb\", 0) == 0  # Edge case: k is 0 with repeating characters\nassert length_of_longest_substring_k_distinct(\"aabbcc\", 1) == 2  # Only one distinct character allowed\nassert length_of_longest_substring_k_distinct(\"aabbcc\", 2) == 4  # Two distinct characters allowed\nassert length_of_longest_substring_k_distinct(\"aabbcc\", 3) == 6  # Three distinct characters allowed\nassert length_of_longest_substring_k_distinct(\"aabbcc\", 4) == 6  # More than three distinct characters allowed\nassert length_of_longest_substring_k_distinct(\"aaaabbbb\", 1) == 4  # Repeating characters with one distinct character allowed\nassert length_of_longest_substring_k_distinct(\"pqrstuv\", 5) == 7  # All characters are distinct within length\n\n[/Example 3]", "temperature": 0.83}, {"few_shots": [{"author": "Calvin", "UUID": "56b48f6d-0d81-478d-b838-4d47b62d3031", "question": "Given an integer n, return the number of strings of length n that consist only of vowels (a, e, i, o, u) and are lexicographically sorted.\n\nA string s is lexicographically sorted if for all valid i, s[i] is the same as or comes before s[i+1] in the alphabet.", "examples": "Input: 1\nOutput: 5\n\nInput: 2\nOutput: 15", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def helper(n, letter_idx):\n  letters = [\"a\",\"e\",\"i\",\"o\",\"u\"]\n  dynamic = {\n      'a1' : 5,\n      'e1' : 4,\n      'i1' : 3,\n      'o1' : 2,\n      'u1' : 1\n  }\n  ret = 0\n  key = letters[letter_idx] + str(n)\n  if key in dynamic.keys():\n    return dynamic[key]\n  else:\n    for i in range(letter_idx, len(letters)):\n      ret += helper(n-1, i)\n    dynamic[key] = ret\n  return ret\n  \n\ndef countVowelStrings(n: int) -> int:\n  return helper(n, 0)\n", "asserts": ["assert countVowelStrings(3) == 35", "assert countVowelStrings(4) == 70", "assert countVowelStrings(5) == 126", "assert countVowelStrings(6) == 210", "assert countVowelStrings(7) == 330", "assert countVowelStrings(10) == 1001", "assert countVowelStrings(15) == 3876"]}, {"author": "Calvin", "UUID": "87372a22-f5ef-4100-845b-28700ca3fde3", "question": "You are given a string s and an integer array indices of the same length. The string s will be shuffled such that the character at the ith position moves to indices[i] in the shuffled string.\n\nReturn the shuffled string.", "examples": "Input: s = \"codeleet\", indices = [4,5,6,7,0,2,1,3]\nOutput: \"leetcode\"\n\nInput: s = \"abc\", indices = [0,1,2]\nOutput: \"abc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "from typing import List\ndef shuffle_string(s: str, indices: List[int]) -> str:\n    def partitionString(s):\n      substrings = 1\n      cur_str = set()\n      for i in range(len(s)):\n        if s[i] in cur_str:\n          substrings += 1\n          cur_str = {s[i]}\n        else:\n          cur_str.add(s[i])\n      return substrings\n    ret = ['_']*len(s)\n    for idx, i in enumerate(indices):\n        ret[i] = s[idx]\n    return \"\".join(ret)\n", "asserts": ["assert shuffle_string(\"reoc\", [2, 0, 1, 3]) == \"eorc\"", "assert shuffle_string(\"aiohn\", [3,1,4,2,0]) == \"nihao\"", "assert shuffle_string(\"aax\", [0,2,1]) == \"axa\"", "assert shuffle_string(\"gh\", [1,0]) == \"hg\"", "assert shuffle_string(\"\", []) == \"\"  # Edge case: empty string", "assert shuffle_string(\"xy\", [0,1]) == \"xy\"  # No shuffle required", "assert shuffle_string(\"pqrstuvwxyzabcdefghijklmno\", list(range(25, -1, -1))) == \"onmlkjihgfedcbazyxwvutsrqp\"  # Reverse shuffle"]}], "category": "String", "prompt_tokens": 851, "total_tokens": 1105, "completion_tokens": 254, "completion": "Write a function to find the first non-repeating character in a given string and return its index. If it doesn't exist, return -1.\n\n###Code: \n\ndef first_uniq_char(s: str) -> int:\n    char_count = {}\n    for char in s:\n        char_count[char] = char_count.get(char, 0) + 1\n    \n    for index, char in enumerate(s):\n        if char_count[char] == 1:\n            return index\n    \n    return -1\n\n###Testcases: \n\nassert first_uniq_char(\"leetcode\") == 0\nassert first_uniq_char(\"loveleetcode\") == 2\nassert first_uniq_char(\"aabb\") == -1\nassert first_uniq_char(\"aadadaad\") == -1\nassert first_uniq_char(\"\") == -1  # Edge case: empty string\nassert first_uniq_char(\"xyz\") == 0  # All characters are unique\nassert first_uniq_char(\"xyyz\") == 0  # First unique character at index 0\nassert first_uniq_char(\"abacabad\") == 6  # c and d are non-repeating characters, d occurs first at index 6\n\n[/Example 3]", "temperature": 0.884}, {"few_shots": [{"author": "Calvin", "UUID": "56b48f6d-0d81-478d-b838-4d47b62d3031", "question": "Given an integer n, return the number of strings of length n that consist only of vowels (a, e, i, o, u) and are lexicographically sorted.\n\nA string s is lexicographically sorted if for all valid i, s[i] is the same as or comes before s[i+1] in the alphabet.", "examples": "Input: 1\nOutput: 5\n\nInput: 2\nOutput: 15", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def helper(n, letter_idx):\n  letters = [\"a\",\"e\",\"i\",\"o\",\"u\"]\n  dynamic = {\n      'a1' : 5,\n      'e1' : 4,\n      'i1' : 3,\n      'o1' : 2,\n      'u1' : 1\n  }\n  ret = 0\n  key = letters[letter_idx] + str(n)\n  if key in dynamic.keys():\n    return dynamic[key]\n  else:\n    for i in range(letter_idx, len(letters)):\n      ret += helper(n-1, i)\n    dynamic[key] = ret\n  return ret\n  \n\ndef countVowelStrings(n: int) -> int:\n  return helper(n, 0)\n", "asserts": ["assert countVowelStrings(3) == 35", "assert countVowelStrings(4) == 70", "assert countVowelStrings(5) == 126", "assert countVowelStrings(6) == 210", "assert countVowelStrings(7) == 330", "assert countVowelStrings(10) == 1001", "assert countVowelStrings(15) == 3876"]}, {"author": "Calvin", "UUID": "87372a22-f5ef-4100-845b-28700ca3fde3", "question": "You are given a string s and an integer array indices of the same length. The string s will be shuffled such that the character at the ith position moves to indices[i] in the shuffled string.\n\nReturn the shuffled string.", "examples": "Input: s = \"codeleet\", indices = [4,5,6,7,0,2,1,3]\nOutput: \"leetcode\"\n\nInput: s = \"abc\", indices = [0,1,2]\nOutput: \"abc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "from typing import List\ndef shuffle_string(s: str, indices: List[int]) -> str:\n    def partitionString(s):\n      substrings = 1\n      cur_str = set()\n      for i in range(len(s)):\n        if s[i] in cur_str:\n          substrings += 1\n          cur_str = {s[i]}\n        else:\n          cur_str.add(s[i])\n      return substrings\n    ret = ['_']*len(s)\n    for idx, i in enumerate(indices):\n        ret[i] = s[idx]\n    return \"\".join(ret)\n", "asserts": ["assert shuffle_string(\"reoc\", [2, 0, 1, 3]) == \"eorc\"", "assert shuffle_string(\"aiohn\", [3,1,4,2,0]) == \"nihao\"", "assert shuffle_string(\"aax\", [0,2,1]) == \"axa\"", "assert shuffle_string(\"gh\", [1,0]) == \"hg\"", "assert shuffle_string(\"\", []) == \"\"  # Edge case: empty string", "assert shuffle_string(\"xy\", [0,1]) == \"xy\"  # No shuffle required", "assert shuffle_string(\"pqrstuvwxyzabcdefghijklmno\", list(range(25, -1, -1))) == \"onmlkjihgfedcbazyxwvutsrqp\"  # Reverse shuffle"]}], "category": "String", "prompt_tokens": 851, "total_tokens": 1039, "completion_tokens": 188, "completion": "Design a function that takes a non-empty string and that string's length and reverses the string.\n\n###Code: \n\ndef reverse_string(s: str, length: int) -> str:\n    # We can ignore the length as Python's slicing will handle it\n    return s[::-1]\n\n###Testcases: \n\nassert reverse_string(\"hello\", 5) == \"olleh\"\nassert reverse_string(\"world\", 5) == \"dlrow\"\nassert reverse_string(\"a\", 1) == \"a\"  # Edge case: single character\nassert reverse_string(\"racecar\", 7) == \"racecar\"  # Palindrome\nassert reverse_string(\"1234567890\", 10) == \"0987654321\"  # Numbers\nassert reverse_string(\"!@#$%^&*()\", 10) == \")(*&^%$#@!\"  # Special characters\n\n[/Example 3]", "temperature": 0.777}, {"few_shots": [{"author": "Calvin", "UUID": "56b48f6d-0d81-478d-b838-4d47b62d3031", "question": "Given an integer n, return the number of strings of length n that consist only of vowels (a, e, i, o, u) and are lexicographically sorted.\n\nA string s is lexicographically sorted if for all valid i, s[i] is the same as or comes before s[i+1] in the alphabet.", "examples": "Input: 1\nOutput: 5\n\nInput: 2\nOutput: 15", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def helper(n, letter_idx):\n  letters = [\"a\",\"e\",\"i\",\"o\",\"u\"]\n  dynamic = {\n      'a1' : 5,\n      'e1' : 4,\n      'i1' : 3,\n      'o1' : 2,\n      'u1' : 1\n  }\n  ret = 0\n  key = letters[letter_idx] + str(n)\n  if key in dynamic.keys():\n    return dynamic[key]\n  else:\n    for i in range(letter_idx, len(letters)):\n      ret += helper(n-1, i)\n    dynamic[key] = ret\n  return ret\n  \n\ndef countVowelStrings(n: int) -> int:\n  return helper(n, 0)\n", "asserts": ["assert countVowelStrings(3) == 35", "assert countVowelStrings(4) == 70", "assert countVowelStrings(5) == 126", "assert countVowelStrings(6) == 210", "assert countVowelStrings(7) == 330", "assert countVowelStrings(10) == 1001", "assert countVowelStrings(15) == 3876"]}, {"author": "Calvin", "UUID": "87372a22-f5ef-4100-845b-28700ca3fde3", "question": "You are given a string s and an integer array indices of the same length. The string s will be shuffled such that the character at the ith position moves to indices[i] in the shuffled string.\n\nReturn the shuffled string.", "examples": "Input: s = \"codeleet\", indices = [4,5,6,7,0,2,1,3]\nOutput: \"leetcode\"\n\nInput: s = \"abc\", indices = [0,1,2]\nOutput: \"abc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "from typing import List\ndef shuffle_string(s: str, indices: List[int]) -> str:\n    def partitionString(s):\n      substrings = 1\n      cur_str = set()\n      for i in range(len(s)):\n        if s[i] in cur_str:\n          substrings += 1\n          cur_str = {s[i]}\n        else:\n          cur_str.add(s[i])\n      return substrings\n    ret = ['_']*len(s)\n    for idx, i in enumerate(indices):\n        ret[i] = s[idx]\n    return \"\".join(ret)\n", "asserts": ["assert shuffle_string(\"reoc\", [2, 0, 1, 3]) == \"eorc\"", "assert shuffle_string(\"aiohn\", [3,1,4,2,0]) == \"nihao\"", "assert shuffle_string(\"aax\", [0,2,1]) == \"axa\"", "assert shuffle_string(\"gh\", [1,0]) == \"hg\"", "assert shuffle_string(\"\", []) == \"\"  # Edge case: empty string", "assert shuffle_string(\"xy\", [0,1]) == \"xy\"  # No shuffle required", "assert shuffle_string(\"pqrstuvwxyzabcdefghijklmno\", list(range(25, -1, -1))) == \"onmlkjihgfedcbazyxwvutsrqp\"  # Reverse shuffle"]}], "category": "String", "prompt_tokens": 851, "total_tokens": 1203, "completion_tokens": 352, "completion": "Write a function that takes a string as input and reverses only the vowels of a string.\n\nNote: The vowels are 'a', 'e', 'i', 'o', and 'u', and can appear in both cases i.e., lower case and upper case. The function should not alter the position of the other characters.\n\n###Code: \n\ndef reverseVowels(s: str) -> str:\n    vowels = \"aeiouAEIOU\"\n    s_list = list(s)\n    left, right = 0, len(s) - 1\n\n    while left < right:\n        while left < right and s_list[left] not in vowels:\n            left += 1\n        while left < right and s_list[right] not in vowels:\n            right -= 1\n        s_list[left], s_list[right] = s_list[right], s_list[left]\n        left, right = left + 1, right - 1\n\n    return ''.join(s_list)\n\n\n###Testcases: \n\nassert reverseVowels(\"hello\") == \"holle\"\nassert reverseVowels(\"leetcode\") == \"leotcede\"\nassert reverseVowels(\"aA\") == \"Aa\"\nassert reverseVowels(\" \") == \" \"  # Edge case: single space\nassert reverseVowels(\"\") == \"\"  # Edge case: empty string\nassert reverseVowels(\"bcdfg\") == \"bcdfg\"  # No vowels\nassert reverseVowels(\"AEIOUaeiou\") == \"uoieaUOIEA\"  # All vowels\nassert reverseVowels(\"Programming is fun!\") == \"Prigrammong is fun!\"\n\n[/Example 3]", "temperature": 0.655}, {"few_shots": [{"author": "Calvin", "UUID": "56b48f6d-0d81-478d-b838-4d47b62d3031", "question": "Given an integer n, return the number of strings of length n that consist only of vowels (a, e, i, o, u) and are lexicographically sorted.\n\nA string s is lexicographically sorted if for all valid i, s[i] is the same as or comes before s[i+1] in the alphabet.", "examples": "Input: 1\nOutput: 5\n\nInput: 2\nOutput: 15", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def helper(n, letter_idx):\n  letters = [\"a\",\"e\",\"i\",\"o\",\"u\"]\n  dynamic = {\n      'a1' : 5,\n      'e1' : 4,\n      'i1' : 3,\n      'o1' : 2,\n      'u1' : 1\n  }\n  ret = 0\n  key = letters[letter_idx] + str(n)\n  if key in dynamic.keys():\n    return dynamic[key]\n  else:\n    for i in range(letter_idx, len(letters)):\n      ret += helper(n-1, i)\n    dynamic[key] = ret\n  return ret\n  \n\ndef countVowelStrings(n: int) -> int:\n  return helper(n, 0)\n", "asserts": ["assert countVowelStrings(3) == 35", "assert countVowelStrings(4) == 70", "assert countVowelStrings(5) == 126", "assert countVowelStrings(6) == 210", "assert countVowelStrings(7) == 330", "assert countVowelStrings(10) == 1001", "assert countVowelStrings(15) == 3876"]}, {"author": "Calvin", "UUID": "87372a22-f5ef-4100-845b-28700ca3fde3", "question": "You are given a string s and an integer array indices of the same length. The string s will be shuffled such that the character at the ith position moves to indices[i] in the shuffled string.\n\nReturn the shuffled string.", "examples": "Input: s = \"codeleet\", indices = [4,5,6,7,0,2,1,3]\nOutput: \"leetcode\"\n\nInput: s = \"abc\", indices = [0,1,2]\nOutput: \"abc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "from typing import List\ndef shuffle_string(s: str, indices: List[int]) -> str:\n    def partitionString(s):\n      substrings = 1\n      cur_str = set()\n      for i in range(len(s)):\n        if s[i] in cur_str:\n          substrings += 1\n          cur_str = {s[i]}\n        else:\n          cur_str.add(s[i])\n      return substrings\n    ret = ['_']*len(s)\n    for idx, i in enumerate(indices):\n        ret[i] = s[idx]\n    return \"\".join(ret)\n", "asserts": ["assert shuffle_string(\"reoc\", [2, 0, 1, 3]) == \"eorc\"", "assert shuffle_string(\"aiohn\", [3,1,4,2,0]) == \"nihao\"", "assert shuffle_string(\"aax\", [0,2,1]) == \"axa\"", "assert shuffle_string(\"gh\", [1,0]) == \"hg\"", "assert shuffle_string(\"\", []) == \"\"  # Edge case: empty string", "assert shuffle_string(\"xy\", [0,1]) == \"xy\"  # No shuffle required", "assert shuffle_string(\"pqrstuvwxyzabcdefghijklmno\", list(range(25, -1, -1))) == \"onmlkjihgfedcbazyxwvutsrqp\"  # Reverse shuffle"]}], "category": "String", "prompt_tokens": 851, "total_tokens": 1278, "completion_tokens": 427, "completion": "Create a function that takes a string `s` and returns the longest palindrome that can be constructed by deleting or rearranging characters.\n\n###Code:\n\n```python\ndef longest_palindrome(s: str) -> str:\n    from collections import Counter\n    counts = Counter(s)\n    odd_char = ''\n    even_parts = []\n\n    for char, count in counts.items():\n        if count % 2 == 0:\n            even_parts.append(char * (count // 2))  # Add half of the even count to one side of palindrome\n        else:\n            even_parts.append(char * ((count-1) // 2))  # Add the even part of an odd count\n            if not odd_char or counts[odd_char] < count:  # Choose the odd character with the most occurrences\n                odd_char = char\n    \n    even_part = ''.join(sorted(even_parts))\n    return even_part + (odd_char * counts[odd_char] if odd_char else '') + even_part[::-1]\n\n###Testcases:\n\nassert longest_palindrome(\"abccccdd\") == \"dccaccd\" or \"dccbccd\"  # Can form \"dccaccd\" or \"dccbccd\"\nassert longest_palindrome(\"a\") == \"a\"  # Single character is itself a palindrome\nassert longest_palindrome(\"aa\") == \"aa\"  # Already a palindrome\nassert longest_palindrome(\"abc\") == \"a\" or \"b\" or \"c\"  # Only one character can be in the center\nassert longest_palindrome(\"aabbccdd\") == \"abcdcdcba\" or \"dcbaabcd\"  # Symmetric around the center\nassert longest_palindrome(\"aaaabbbbcc\") == \"bbabb\" or \"bbaabb\"  # \"bbabb\" or \"bbaabb\" is the longest palindrome\nassert longest_palindrome(\"\") == \"\"  # Edge case: empty string\nassert longest_palindrome(\"bbcc\") == \"bcb\" or \"cbc\"  # Multiple options for the center character\n\n[/Example 3]", "temperature": 0.846}, {"few_shots": [{"author": "Calvin", "UUID": "56b48f6d-0d81-478d-b838-4d47b62d3031", "question": "Given an integer n, return the number of strings of length n that consist only of vowels (a, e, i, o, u) and are lexicographically sorted.\n\nA string s is lexicographically sorted if for all valid i, s[i] is the same as or comes before s[i+1] in the alphabet.", "examples": "Input: 1\nOutput: 5\n\nInput: 2\nOutput: 15", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def helper(n, letter_idx):\n  letters = [\"a\",\"e\",\"i\",\"o\",\"u\"]\n  dynamic = {\n      'a1' : 5,\n      'e1' : 4,\n      'i1' : 3,\n      'o1' : 2,\n      'u1' : 1\n  }\n  ret = 0\n  key = letters[letter_idx] + str(n)\n  if key in dynamic.keys():\n    return dynamic[key]\n  else:\n    for i in range(letter_idx, len(letters)):\n      ret += helper(n-1, i)\n    dynamic[key] = ret\n  return ret\n  \n\ndef countVowelStrings(n: int) -> int:\n  return helper(n, 0)\n", "asserts": ["assert countVowelStrings(3) == 35", "assert countVowelStrings(4) == 70", "assert countVowelStrings(5) == 126", "assert countVowelStrings(6) == 210", "assert countVowelStrings(7) == 330", "assert countVowelStrings(10) == 1001", "assert countVowelStrings(15) == 3876"]}, {"author": "Calvin", "UUID": "87372a22-f5ef-4100-845b-28700ca3fde3", "question": "You are given a string s and an integer array indices of the same length. The string s will be shuffled such that the character at the ith position moves to indices[i] in the shuffled string.\n\nReturn the shuffled string.", "examples": "Input: s = \"codeleet\", indices = [4,5,6,7,0,2,1,3]\nOutput: \"leetcode\"\n\nInput: s = \"abc\", indices = [0,1,2]\nOutput: \"abc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "from typing import List\ndef shuffle_string(s: str, indices: List[int]) -> str:\n    def partitionString(s):\n      substrings = 1\n      cur_str = set()\n      for i in range(len(s)):\n        if s[i] in cur_str:\n          substrings += 1\n          cur_str = {s[i]}\n        else:\n          cur_str.add(s[i])\n      return substrings\n    ret = ['_']*len(s)\n    for idx, i in enumerate(indices):\n        ret[i] = s[idx]\n    return \"\".join(ret)\n", "asserts": ["assert shuffle_string(\"reoc\", [2, 0, 1, 3]) == \"eorc\"", "assert shuffle_string(\"aiohn\", [3,1,4,2,0]) == \"nihao\"", "assert shuffle_string(\"aax\", [0,2,1]) == \"axa\"", "assert shuffle_string(\"gh\", [1,0]) == \"hg\"", "assert shuffle_string(\"\", []) == \"\"  # Edge case: empty string", "assert shuffle_string(\"xy\", [0,1]) == \"xy\"  # No shuffle required", "assert shuffle_string(\"pqrstuvwxyzabcdefghijklmno\", list(range(25, -1, -1))) == \"onmlkjihgfedcbazyxwvutsrqp\"  # Reverse shuffle"]}], "category": "String", "prompt_tokens": 851, "total_tokens": 1102, "completion_tokens": 251, "completion": "Write a function that takes a string s and returns the length of the longest substring without repeating characters.\n\n###Code:\n\ndef length_of_longest_substring(s: str) -> int:\n    char_map = {}\n    left = 0\n    max_length = 0\n    for right in range(len(s)):\n        if s[right] in char_map:\n            left = max(left, char_map[s[right]] + 1)\n        char_map[s[right]] = right\n        max_length = max(max_length, right - left + 1)\n    return max_length\n\n###Testcases:\n\nassert length_of_longest_substring(\"abcabcbb\") == 3\nassert length_of_longest_substring(\"bbbbb\") == 1\nassert length_of_longest_substring(\"pwwkew\") == 3\nassert length_of_longest_substring(\"\") == 0  # Edge case: empty string\nassert length_of_longest_substring(\" \") == 1  # Single character\nassert length_of_longest_substring(\"dvdf\") == 3  # Non-contiguous repeat\nassert length_of_longest_substring(\"anviaj\") == 5  # Multiple unique characters\n\n[/Example 3]", "temperature": 0.67}, {"few_shots": [{"author": "Calvin", "UUID": "56b48f6d-0d81-478d-b838-4d47b62d3031", "question": "Given an integer n, return the number of strings of length n that consist only of vowels (a, e, i, o, u) and are lexicographically sorted.\n\nA string s is lexicographically sorted if for all valid i, s[i] is the same as or comes before s[i+1] in the alphabet.", "examples": "Input: 1\nOutput: 5\n\nInput: 2\nOutput: 15", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def helper(n, letter_idx):\n  letters = [\"a\",\"e\",\"i\",\"o\",\"u\"]\n  dynamic = {\n      'a1' : 5,\n      'e1' : 4,\n      'i1' : 3,\n      'o1' : 2,\n      'u1' : 1\n  }\n  ret = 0\n  key = letters[letter_idx] + str(n)\n  if key in dynamic.keys():\n    return dynamic[key]\n  else:\n    for i in range(letter_idx, len(letters)):\n      ret += helper(n-1, i)\n    dynamic[key] = ret\n  return ret\n  \n\ndef countVowelStrings(n: int) -> int:\n  return helper(n, 0)\n", "asserts": ["assert countVowelStrings(3) == 35", "assert countVowelStrings(4) == 70", "assert countVowelStrings(5) == 126", "assert countVowelStrings(6) == 210", "assert countVowelStrings(7) == 330", "assert countVowelStrings(10) == 1001", "assert countVowelStrings(15) == 3876"]}, {"author": "Calvin", "UUID": "87372a22-f5ef-4100-845b-28700ca3fde3", "question": "You are given a string s and an integer array indices of the same length. The string s will be shuffled such that the character at the ith position moves to indices[i] in the shuffled string.\n\nReturn the shuffled string.", "examples": "Input: s = \"codeleet\", indices = [4,5,6,7,0,2,1,3]\nOutput: \"leetcode\"\n\nInput: s = \"abc\", indices = [0,1,2]\nOutput: \"abc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "from typing import List\ndef shuffle_string(s: str, indices: List[int]) -> str:\n    def partitionString(s):\n      substrings = 1\n      cur_str = set()\n      for i in range(len(s)):\n        if s[i] in cur_str:\n          substrings += 1\n          cur_str = {s[i]}\n        else:\n          cur_str.add(s[i])\n      return substrings\n    ret = ['_']*len(s)\n    for idx, i in enumerate(indices):\n        ret[i] = s[idx]\n    return \"\".join(ret)\n", "asserts": ["assert shuffle_string(\"reoc\", [2, 0, 1, 3]) == \"eorc\"", "assert shuffle_string(\"aiohn\", [3,1,4,2,0]) == \"nihao\"", "assert shuffle_string(\"aax\", [0,2,1]) == \"axa\"", "assert shuffle_string(\"gh\", [1,0]) == \"hg\"", "assert shuffle_string(\"\", []) == \"\"  # Edge case: empty string", "assert shuffle_string(\"xy\", [0,1]) == \"xy\"  # No shuffle required", "assert shuffle_string(\"pqrstuvwxyzabcdefghijklmno\", list(range(25, -1, -1))) == \"onmlkjihgfedcbazyxwvutsrqp\"  # Reverse shuffle"]}], "category": "String", "prompt_tokens": 851, "total_tokens": 1104, "completion_tokens": 253, "completion": "Implement a function to transform a string by replacing every lowercase 'a' with two duplicate 'b's and remove every uppercase 'A'. The function should not use any predefined replace or similar string manipulation functions. Return the transformed string.\n\n###Code:\n\n```python\ndef transform_string(s: str) -> str:\n    result = []\n    for char in s:\n        if char == 'a':\n            result.append('bb')\n        elif char != 'A':\n            result.append(char)\n    return ''.join(result)\n\n###Testcases:\n\nassert transform_string(\"apple\") == \"bpple\"\nassert transform_string(\"Ace\") == \"ce\"\nassert transform_string(\"BanAna\") == \"Bnbnb\"\nassert transform_string(\"AbraCadabra\") == \"bbrCdbbrbbr\"\nassert transform_string(\"\") == \"\"  # Edge case: empty string\nassert transform_string(\"Hello World!\") == \"Hello World!\"  # No transformation required\nassert transform_string(\"anaconda\") == \"bnbcondb\"  # Only lowercase 'a's are replaced\nassert transform_string(\"Aardvark\") == \"rdbbrk\"  # Both lowercase 'a' replaced and uppercase 'A' removed\n``` \n\n[/Example 3]", "temperature": 0.906}, {"few_shots": [{"author": "Calvin", "UUID": "56b48f6d-0d81-478d-b838-4d47b62d3031", "question": "Given an integer n, return the number of strings of length n that consist only of vowels (a, e, i, o, u) and are lexicographically sorted.\n\nA string s is lexicographically sorted if for all valid i, s[i] is the same as or comes before s[i+1] in the alphabet.", "examples": "Input: 1\nOutput: 5\n\nInput: 2\nOutput: 15", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def helper(n, letter_idx):\n  letters = [\"a\",\"e\",\"i\",\"o\",\"u\"]\n  dynamic = {\n      'a1' : 5,\n      'e1' : 4,\n      'i1' : 3,\n      'o1' : 2,\n      'u1' : 1\n  }\n  ret = 0\n  key = letters[letter_idx] + str(n)\n  if key in dynamic.keys():\n    return dynamic[key]\n  else:\n    for i in range(letter_idx, len(letters)):\n      ret += helper(n-1, i)\n    dynamic[key] = ret\n  return ret\n  \n\ndef countVowelStrings(n: int) -> int:\n  return helper(n, 0)\n", "asserts": ["assert countVowelStrings(3) == 35", "assert countVowelStrings(4) == 70", "assert countVowelStrings(5) == 126", "assert countVowelStrings(6) == 210", "assert countVowelStrings(7) == 330", "assert countVowelStrings(10) == 1001", "assert countVowelStrings(15) == 3876"]}, {"author": "Calvin", "UUID": "87372a22-f5ef-4100-845b-28700ca3fde3", "question": "You are given a string s and an integer array indices of the same length. The string s will be shuffled such that the character at the ith position moves to indices[i] in the shuffled string.\n\nReturn the shuffled string.", "examples": "Input: s = \"codeleet\", indices = [4,5,6,7,0,2,1,3]\nOutput: \"leetcode\"\n\nInput: s = \"abc\", indices = [0,1,2]\nOutput: \"abc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "from typing import List\ndef shuffle_string(s: str, indices: List[int]) -> str:\n    def partitionString(s):\n      substrings = 1\n      cur_str = set()\n      for i in range(len(s)):\n        if s[i] in cur_str:\n          substrings += 1\n          cur_str = {s[i]}\n        else:\n          cur_str.add(s[i])\n      return substrings\n    ret = ['_']*len(s)\n    for idx, i in enumerate(indices):\n        ret[i] = s[idx]\n    return \"\".join(ret)\n", "asserts": ["assert shuffle_string(\"reoc\", [2, 0, 1, 3]) == \"eorc\"", "assert shuffle_string(\"aiohn\", [3,1,4,2,0]) == \"nihao\"", "assert shuffle_string(\"aax\", [0,2,1]) == \"axa\"", "assert shuffle_string(\"gh\", [1,0]) == \"hg\"", "assert shuffle_string(\"\", []) == \"\"  # Edge case: empty string", "assert shuffle_string(\"xy\", [0,1]) == \"xy\"  # No shuffle required", "assert shuffle_string(\"pqrstuvwxyzabcdefghijklmno\", list(range(25, -1, -1))) == \"onmlkjihgfedcbazyxwvutsrqp\"  # Reverse shuffle"]}], "category": "String", "prompt_tokens": 851, "total_tokens": 1186, "completion_tokens": 335, "completion": "Create a function that takes a string `s` and returns the longest palindrome that can be constructed by rearranging the letters of `s`. If there are multiple solutions, return any one.\n\n###Code:\n\n```python\nfrom collections import Counter\n\ndef longest_palindrome(s: str) -> str:\n    counter = Counter(s)\n    middle = \"\"\n    halves = []\n    for char, count in counter.items():\n        if count % 2 == 1:\n            middle = max(middle, char * (count % 2))\n        halves.append(char * (count // 2))\n    first_half = \"\".join(halves)\n    return first_half + middle + first_half[::-1]\n\n###Testcases:\n\nassert longest_palindrome(\"aabb\") in [\"abba\", \"baab\"]\nassert longest_palindrome(\"aaabb\") in [\"ababa\", \"baaab\"]\nassert longest_palindrome(\"carrace\") in [\"craarac\", \"cararac\"]\nassert longest_palindrome(\"google\") in [\"golelog\", \"gelooleg\"]\nassert longest_palindrome(\"\") == \"\"  # Edge case: empty string\nassert longest_palindrome(\"a\") == \"a\"  # Single character\nassert longest_palindrome(\"aaaabbcc\") in [\"abcacba\", \"bacabac\"]\nassert longest_palindrome(\"aabbccdd\") in [\"abcdcdcba\", \"dcbacbacd\"]\nassert longest_palindrome(\"zzzzzzzzzzzzzzzzzz\") == \"zzzzzzzzzzzzzzzzzz\"  # All characters are the same\n```\n\n[/Example 3]", "temperature": 0.899}, {"few_shots": [{"author": "Calvin", "UUID": "56b48f6d-0d81-478d-b838-4d47b62d3031", "question": "Given an integer n, return the number of strings of length n that consist only of vowels (a, e, i, o, u) and are lexicographically sorted.\n\nA string s is lexicographically sorted if for all valid i, s[i] is the same as or comes before s[i+1] in the alphabet.", "examples": "Input: 1\nOutput: 5\n\nInput: 2\nOutput: 15", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def helper(n, letter_idx):\n  letters = [\"a\",\"e\",\"i\",\"o\",\"u\"]\n  dynamic = {\n      'a1' : 5,\n      'e1' : 4,\n      'i1' : 3,\n      'o1' : 2,\n      'u1' : 1\n  }\n  ret = 0\n  key = letters[letter_idx] + str(n)\n  if key in dynamic.keys():\n    return dynamic[key]\n  else:\n    for i in range(letter_idx, len(letters)):\n      ret += helper(n-1, i)\n    dynamic[key] = ret\n  return ret\n  \n\ndef countVowelStrings(n: int) -> int:\n  return helper(n, 0)\n", "asserts": ["assert countVowelStrings(3) == 35", "assert countVowelStrings(4) == 70", "assert countVowelStrings(5) == 126", "assert countVowelStrings(6) == 210", "assert countVowelStrings(7) == 330", "assert countVowelStrings(10) == 1001", "assert countVowelStrings(15) == 3876"]}, {"author": "Calvin", "UUID": "87372a22-f5ef-4100-845b-28700ca3fde3", "question": "You are given a string s and an integer array indices of the same length. The string s will be shuffled such that the character at the ith position moves to indices[i] in the shuffled string.\n\nReturn the shuffled string.", "examples": "Input: s = \"codeleet\", indices = [4,5,6,7,0,2,1,3]\nOutput: \"leetcode\"\n\nInput: s = \"abc\", indices = [0,1,2]\nOutput: \"abc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "from typing import List\ndef shuffle_string(s: str, indices: List[int]) -> str:\n    def partitionString(s):\n      substrings = 1\n      cur_str = set()\n      for i in range(len(s)):\n        if s[i] in cur_str:\n          substrings += 1\n          cur_str = {s[i]}\n        else:\n          cur_str.add(s[i])\n      return substrings\n    ret = ['_']*len(s)\n    for idx, i in enumerate(indices):\n        ret[i] = s[idx]\n    return \"\".join(ret)\n", "asserts": ["assert shuffle_string(\"reoc\", [2, 0, 1, 3]) == \"eorc\"", "assert shuffle_string(\"aiohn\", [3,1,4,2,0]) == \"nihao\"", "assert shuffle_string(\"aax\", [0,2,1]) == \"axa\"", "assert shuffle_string(\"gh\", [1,0]) == \"hg\"", "assert shuffle_string(\"\", []) == \"\"  # Edge case: empty string", "assert shuffle_string(\"xy\", [0,1]) == \"xy\"  # No shuffle required", "assert shuffle_string(\"pqrstuvwxyzabcdefghijklmno\", list(range(25, -1, -1))) == \"onmlkjihgfedcbazyxwvutsrqp\"  # Reverse shuffle"]}], "category": "String", "prompt_tokens": 851, "total_tokens": 1074, "completion_tokens": 223, "completion": "Write a function that takes a string and returns a new string with all vowels removed.\n\n###Code: \n\ndef remove_vowels(s: str) -> str:\n    vowels = set(\"aeiouAEIOU\")\n    return ''.join([ch for ch in s if ch not in vowels])\n\n\n###Testcases: \n\nassert remove_vowels(\"This is a test string\") == \"Ths s  tst strng\"\nassert remove_vowels(\"The quick brown fox\") == \"Th qck brwn fx\"\nassert remove_vowels(\"AEIOUaeiou\") == \"\"\nassert remove_vowels(\"\") == \"\"  # Edge case: empty string\nassert remove_vowels(\"bcdfghjklmnpqrstvwxyz\") == \"bcdfghjklmnpqrstvwxyz\"  # No vowels to remove\nassert remove_vowels(\"I like to eat apples and bananas\") == \" lk t t ppls nd bnns\"\nassert remove_vowels(\"Programming is fun!\") == \"Prgrmmng s fn!\"\n\n[/Example 3]", "temperature": 0.923}, {"few_shots": [{"author": "Calvin", "UUID": "56b48f6d-0d81-478d-b838-4d47b62d3031", "question": "Given an integer n, return the number of strings of length n that consist only of vowels (a, e, i, o, u) and are lexicographically sorted.\n\nA string s is lexicographically sorted if for all valid i, s[i] is the same as or comes before s[i+1] in the alphabet.", "examples": "Input: 1\nOutput: 5\n\nInput: 2\nOutput: 15", "link": NaN, "difficulty": null, "categories": ["String"], "code": "def helper(n, letter_idx):\n  letters = [\"a\",\"e\",\"i\",\"o\",\"u\"]\n  dynamic = {\n      'a1' : 5,\n      'e1' : 4,\n      'i1' : 3,\n      'o1' : 2,\n      'u1' : 1\n  }\n  ret = 0\n  key = letters[letter_idx] + str(n)\n  if key in dynamic.keys():\n    return dynamic[key]\n  else:\n    for i in range(letter_idx, len(letters)):\n      ret += helper(n-1, i)\n    dynamic[key] = ret\n  return ret\n  \n\ndef countVowelStrings(n: int) -> int:\n  return helper(n, 0)\n", "asserts": ["assert countVowelStrings(3) == 35", "assert countVowelStrings(4) == 70", "assert countVowelStrings(5) == 126", "assert countVowelStrings(6) == 210", "assert countVowelStrings(7) == 330", "assert countVowelStrings(10) == 1001", "assert countVowelStrings(15) == 3876"]}, {"author": "Calvin", "UUID": "87372a22-f5ef-4100-845b-28700ca3fde3", "question": "You are given a string s and an integer array indices of the same length. The string s will be shuffled such that the character at the ith position moves to indices[i] in the shuffled string.\n\nReturn the shuffled string.", "examples": "Input: s = \"codeleet\", indices = [4,5,6,7,0,2,1,3]\nOutput: \"leetcode\"\n\nInput: s = \"abc\", indices = [0,1,2]\nOutput: \"abc\"", "link": NaN, "difficulty": null, "categories": ["String"], "code": "from typing import List\ndef shuffle_string(s: str, indices: List[int]) -> str:\n    def partitionString(s):\n      substrings = 1\n      cur_str = set()\n      for i in range(len(s)):\n        if s[i] in cur_str:\n          substrings += 1\n          cur_str = {s[i]}\n        else:\n          cur_str.add(s[i])\n      return substrings\n    ret = ['_']*len(s)\n    for idx, i in enumerate(indices):\n        ret[i] = s[idx]\n    return \"\".join(ret)\n", "asserts": ["assert shuffle_string(\"reoc\", [2, 0, 1, 3]) == \"eorc\"", "assert shuffle_string(\"aiohn\", [3,1,4,2,0]) == \"nihao\"", "assert shuffle_string(\"aax\", [0,2,1]) == \"axa\"", "assert shuffle_string(\"gh\", [1,0]) == \"hg\"", "assert shuffle_string(\"\", []) == \"\"  # Edge case: empty string", "assert shuffle_string(\"xy\", [0,1]) == \"xy\"  # No shuffle required", "assert shuffle_string(\"pqrstuvwxyzabcdefghijklmno\", list(range(25, -1, -1))) == \"onmlkjihgfedcbazyxwvutsrqp\"  # Reverse shuffle"]}], "category": "String", "prompt_tokens": 851, "total_tokens": 1095, "completion_tokens": 244, "completion": "Write a function that takes a string and returns a new string with each character's position in the alphabet as a string concatenated together. For example, \"abc\" would be \"123\" because 'a' is the 1st letter, 'b' is the 2nd, and 'c' is the 3rd. You can assume the string will be lowercase and without any special characters or spaces.\n\n###Code: \n\ndef alphabet_position(text: str) -> str:\n    return ''.join(str(ord(char) - 96) for char in text if char.isalpha())\n\n###Testcases: \n\nassert alphabet_position(\"abc\") == \"123\"\nassert alphabet_position(\"encode\") == \"51431545\"\nassert alphabet_position(\"xyz\") == \"242526\"\nassert alphabet_position(\"hello\") == \"85121215\"\nassert alphabet_position(\"world\") == \"231518124\"\nassert alphabet_position(\"abcdefghijklmnopqrstuvwxyz\") == \"1234567891011121314151617181920212223242526\"\nassert alphabet_position(\"thequickbrownfoxjumpsoverthelazydog\") == \"2085172115918151816715915121315220512081262515\"\n\n[/Example 3]", "temperature": 0.779}]