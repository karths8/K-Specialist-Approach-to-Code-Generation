[{"keywords": "['array', 'triplet', 'sum', 'absolute difference', 'sorting', 'iteration']", "prompt_tokens": 574, "total_tokens": 889, "completion_tokens": 315, "completion": "[Question 2]\n\nGiven a list of lists representing temperatures in Fahrenheit for different days, write a function to find the minimum time to reach a triplet of days with the lowest sum of absolute differences between temperatures.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\ndef minimumTimeToTripletWithLowestSum(temps: List[List[float]]) -> int:\n\tmin_time = float('inf')\n\ttemps.sort(key=lambda x: sum(x))\n\tfor i in range(len(temps) - 2):\n\t\tdiff_sum = sum(temps[i]) + sum(temps[i + 1]) + sum(temps[i + 2])\n\t\tmin_time = min(min_time, diff_sum)\n\treturn min_time\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minimumTimeToTripletWithLowestSum([[32, 45, 50], [20, 30, 40], [10, 25, 35], [15, 27, 38]]) == 140\nassert minimumTimeToTripletWithLowestSum([[70, 80, 90], [60, 75, 85], [55, 65, 75], [72, 78, 88]]) == 175\nassert minimumTimeToTripletWithLowestSum([[40, 50, 60], [30, 55, 65], [25, 35, 45], [28, 42, 58]]) == 145\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['sorted', 'range', 'smallest', 'lists', 'integers', 'min', 'inclusive']", "prompt_tokens": 665, "total_tokens": 1015, "completion_tokens": 350, "completion": "[Question 2]\n\nGiven a sorted matrix of integers in row-wise fashion, write a Python function to find the smallest range that includes at least one element from each row. The matrix is guaranteed to be sorted. Find a top-down approach to solve this problem and use halving to optimize the search for the smallest range.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List, Tuple\n\ndef smallestRangeMatrix(matrix: List[List[int]]) -> Tuple[int, int]:\n    n = len(matrix)\n    start, end = min(matrix[0]), max(matrix[0])\n\n    for i in range(1, n):\n        low, high = 0, len(matrix[i]) - 1\n        while low <= high:\n            mid = (low + high) // 2\n            if matrix[i][mid] < start:\n                low = mid + 1\n            else:\n                high = mid - 1\n        if low == len(matrix[i]):  # All values in this row are less than the current start\n            return (start, end)\n        if matrix[i][low] > end:\n            end = matrix[i][low]\n        start = matrix[i][low]\n\n    return (start, end)\n\n[/Code 2]\n\n[Asserts 2]\n\nassert smallestRangeMatrix([[1, 5, 9], [3, 6, 8], [2, 4, 7]]) == (2, 6)\nassert smallestRangeMatrix([[2, 5, 8, 11], [4, 7, 10, 13], [6, 9, 12, 15]]) == (6, 9)", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['integer', 'binary', 'string', 'neighboring', 'different', 'generation', 'recursion', 'helper function']", "prompt_tokens": 528, "total_tokens": 776, "completion_tokens": 248, "completion": "[Question 2]\n\nGiven the freezing point of a substance represented as a single integer variable temp, write a recursive function to generate all maximal binary strings of length temp such that all neighboring characters are different.\n\n[/Question 2]\n\n[Code 2]\n\ndef generateMaximalStrings(temp: int):\n    def generateMaximalStringsHelper(prefix, temp, result):\n        if len(prefix) == temp:\n            result.append(prefix)\n            return\n        generateMaximalStringsHelper(prefix + '0', temp, result)\n        if not prefix or prefix[-1] == '0':\n            generateMaximalStringsHelper(prefix + '1', temp, result)\n    \n    result = []\n    generateMaximalStringsHelper('', temp, result)\n    return result\n\n[/Code 2]\n\n[Asserts 2]\n\nassert generateMaximalStrings(3) == ['010', '101']\nassert generateMaximalStrings(4) == ['0101', '1010']\nassert generateMaximalStrings(5) == ['01010', '10101']\nassert generateMaximalStrings(1) == ['0', '1']\nassert generateMaximalStrings(2) == ['01', '10']\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['integer', 'palindromic', 'divisible', 'sum', 'digits', 'form', 'pattern', 'math']", "prompt_tokens": 579, "total_tokens": 825, "completion_tokens": 246, "completion": "[Question 2]\n\nYou are given a positive integer N. Write a function to return the sum of all palindromic numbers with N digits which are divisible by 3 and arranged in lexicographical order.\n\n[/Question 2]\n\n[Code 2]\n\ndef sumOfPalindromicDivisibleBy3(N: int) -> int:\n    palindromic_numbers = []\n    for i in range(10**(N-1), 10**N):\n        if str(i) == str(i)[::-1] and i % 3 == 0:\n            palindromic_numbers.append(i)\n    \n    return sum(palindromic_numbers)\n\n[/Code 2]\n\n[Asserts 2]\n\nassert(sumOfPalindromicDivisibleBy3(1))==45\nassert(sumOfPalindromicDivisibleBy3(2)) == 495\nassert(sumOfPalindromicDivisibleBy3(3)) == 4995\nassert(sumOfPalindromicDivisibleBy3(4)) == 49995\nassert(sumOfPalindromicDivisibleBy3(5)) == 499995\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'subset', 'Fibonacci', 'set', 'pair', 'sequence']", "prompt_tokens": 754, "total_tokens": 1141, "completion_tokens": 387, "completion": "[Question 2]\n\nGiven a sequence of years, find the first pair of years in the sequence where the absolute difference of the years is a Fibonacci number.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef isPerfectSquare(x: int) -> bool:\n    s = int(x**0.5)\n    return s*s == x\n\ndef isFibonacci(n: int) -> bool:\n    return isPerfectSquare(5*n*n + 4) or isPerfectSquare(5*n*n - 4)\n\ndef firstFibonacciYearPair(years: List[int]) -> List[int]:\n    s = set(years)\n    for i in range(len(years)):\n        for j in range(i+1, len(years)):\n            if isFibonacci(abs(years[i] - years[j])):\n                return [years[i], years[j]]\n    return []\n\n[/Code 2]\n\n[Asserts 2]\n\nassert firstFibonacciYearPair([1990, 1991, 1995, 2000, 2005, 2010, 2015, 2020]) == [1990, 2005]\nassert firstFibonacciYearPair([2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009]) == []\nassert firstFibonacciYearPair([2018, 2019, 2020, 2021, 2022, 2023, 2024, 2025]) == [2018, 2023]\nassert firstFibonacciYearPair([1987, 1988, 1989, 1990, 1991, 1992, 1993]) == [1989, 1992]\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'subarray', 'maximize', 'sum', 'multiplication', 'integer', 'algorithm']", "prompt_tokens": 627, "total_tokens": 1057, "completion_tokens": 430, "completion": "[Question 2]\n\nGiven an array of integers, find the maximum sum of the product of two distant subarrays. A distant subarray is defined by a subarray where the starting indices of the two subarrays are at a distance greater than K.\n\n[/Question 2]\n\n[Code 2]\n\ndef maxProductSubarray(arr, n, k):\n    prefix, suffix = [0] * n, [0] * n\n  \n    curr_max = arr[0]\n    prefix[0] = arr[0]\n    for i in range(1, n):\n        curr_max = max(arr[i], curr_max + arr[i])\n        prefix[i] = curr_max\n  \n    curr_max = arr[n - 1]\n    suffix[n - 1] = arr[n - 1]\n    for i in range(n - 2, -1, -1):\n        curr_max = max(arr[i], curr_max + arr[i])\n        suffix[i] = curr_max\n  \n    max_product = float('-inf')\n    for i in range(k, n - k - 1):\n        max_product = max(max_product, prefix[i - k] * suffix[i + k])\n  \n    return max_product\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maxProductSubarray([1, -2, 3, 4, -1, 5], 6, 1) == 28\nassert maxProductSubarray([2, 3, -4, 2, 3, 4], 6, 2) == 48\nassert maxProductSubarray([2, -3, -4, 2, -3, 4], 6, 1) == 48\nassert maxProductSubarray([-2, -3, 4, -2, 3, 4], 6, 2) == 24\nassert maxProductSubarray([2, -3, -4, 2, 3, -4], 6, 2) == 48\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'integer', 'circular', 'element', 'next greater', 'stack']", "prompt_tokens": 596, "total_tokens": 944, "completion_tokens": 348, "completion": "[Question 2]\n\nYou are given a budget and an array of integer prices. Determine the next greater price for each item within the budget, considering a circular arrangement of the array. If a next greater price for an item is not present within the budget, mark it as not present. Assume the next greater price for an item is irreflexive - the price is greater and different from the item's original price.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef nextGreaterPriceWithinBudget(prices: List[int], budget: int) -> List[int]:\n    n = len(prices)\n    stack = []\n    nextGreater = [-1] * n\n    for i in list(range(n)) * 2:\n        while stack and (i - stack[-1]) < n and prices[i % n] > prices[stack[-1]] and prices[i % n] <= budget:\n            nextGreater[stack.pop()] = prices[i % n]            \n        stack.append(i % n)\n    return nextGreater\n\n[/Code 2]\n\n[Asserts 2]\n\nassert nextGreaterPriceWithinBudget([1, 2, 3, 4, 3], 3)==[2, 3, 4, -1, 4]\nassert nextGreaterPriceWithinBudget([3, 3, 3, 3, 3], 3)==[-1, -1, -1, -1, -1]\nassert nextGreaterPriceWithinBudget([4, 3, 2, 1, 0], 5)==[-1, -1, 4, 4, 4]\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'sorting', 'math', 'iteration', 'comparison', 'counting', 'difference']", "prompt_tokens": 648, "total_tokens": 909, "completion_tokens": 261, "completion": "[Question 2]\n\nYou are given an array of integers. Your task is to find the count of the number of non-decreasing subarrays in the given array.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef countNonDecreasingSubarrays(arr: List[int]) -> int:\n    count = 1\n    result = 0\n    for i in range(1, len(arr)):\n        if arr[i] >= arr[i-1]:\n            count += 1\n        else:\n            result += (count*(count + 1))//2\n            count = 1\n    result += (count*(count + 1))//2\n    return result\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countNonDecreasingSubarrays([1, 2, 3, 4, 5])==15\nassert countNonDecreasingSubarrays([5, 4, 3, 2, 1])==1\nassert countNonDecreasingSubarrays([1, 3, 4, 2, 2, 2, 1])==13\nassert countNonDecreasingSubarrays([1, 1, 1, 1])==10\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['number', 'maximum', 'distinct', 'digits', 'sum', 'formation']", "prompt_tokens": 487, "total_tokens": 746, "completion_tokens": 259, "completion": "[Question 2]\n\nYou are planning to purchase a new mobile number, and you believe in lucky numbers. A lucky number is a number in which the sum of its digits is unique and falls in a specific range. Write a function that takes a range and returns the maximum lucky number that falls within that range.\n\n[/Question 2]\n\n[Code 2]\n\ndef maxLuckyNumberInRange(start: int, end: int) -> int:\n    maxLucky = -1\n    for num in range(end, start - 1, -1):\n        if isLucky(num):\n            maxLucky = num\n            break\n    return maxLucky\n\ndef isLucky(num: int) -> bool:\n    digitSum = sum(int(digit) for digit in str(num))\n    return len(set(str(digitSum))) == len(str(digitSum))\n\n[/Code 2]\n\n[Asserts 2]\n\nassert(maxLuckyNumberInRange(1, 100)) == 97\nassert(maxLuckyNumberInRange(100, 1000)) == 997\nassert(maxLuckyNumberInRange(1000, 10000)) == 9997\nassert(maxLuckyNumberInRange(10000, 100000)) == 99991", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['integer', 'arithmetic progression', 'series', 'minimum', 'term']", "prompt_tokens": 438, "total_tokens": 683, "completion_tokens": 245, "completion": "[Question 2]\n\nGiven an integer series and its arithmetic progression (AP) where the terms are at even indices, write a function to find the minimum possible value in the series at the even indices.\n\n[/Question 2]\n\n[Code 2]\n\ndef findMinValueAtEvenIndex(arr: list) -> int:\n    min_val = arr[0]\n    for i in range(2, len(arr), 2):\n        if arr[i] < min_val:\n            min_val = arr[i]\n    return min_val\n\n[/Code 2]\n\n[Asserts 2]\n\nassert findMinValueAtEvenIndex([3, 8, 2, 10, 4, 5, 7])==2\nassert findMinValueAtEvenIndex([12, 6, 5, 9, 8, 3, 10])==3\nassert findMinValueAtEvenIndex([11, 2, 13, 6, 7, 4, 5])==2\nassert findMinValueAtEvenIndex([5, 9, 4, 8, 3, 10, 6])==3\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['matrix', 'traverse', 'connected cells', 'minimum', 'moves', 'positive integers', 'dfs', 'adjacent']", "prompt_tokens": 841, "total_tokens": 1091, "completion_tokens": 250, "completion": "[Question 2]\n\nYou want to re-arrange a set of matchsticks to form the minimum number of positive integer values that satisfy a given constraint satisfaction problem. The matchsticks can be arranged in a matrix, and we need to traverse the connected cells to find the minimum number of moves to satisfy the constraint. Implement a function to solve this problem.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\ndef minMovesToSatisfyConstraint(matrix: List[List[int]]) -> int:\n    # Your code to find the minimum moves to satisfy the constraint here\n    pass\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minMovesToSatisfyConstraint([[1, 2, 3],[4, 5, 6],[7, 8, 9]]) == 5\nassert minMovesToSatisfyConstraint([[3, 3, 3],[3, 3, 3],[3, 3, 3]]) == 8\nassert minMovesToSatisfyConstraint([[1, 1, 1],[2, 2, 2],[3, 3, 3]]) == 4\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'subsets', 'median', 'sorting', 'iteration', 'comparison']", "prompt_tokens": 639, "total_tokens": 861, "completion_tokens": 222, "completion": "[Question 2]\n\nGiven an array of integers, write a function to find the median of the given array.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\ndef findMedian(nums: List[int]) -> float:\n    nums.sort()\n    n = len(nums)\n    if n % 2 == 0:\n        return (nums[n//2 - 1] + nums[n//2]) / 2\n    else:\n        return nums[n//2]\n\n[/Code 2]\n\n[Asserts 2]\n\nassert findMedian([1, 2, 3, 4, 5]) == 3\nassert findMedian([3, 2, 1, 5, 4]) == 3\nassert findMedian([9, 1, 5, 3, 7, 2, 8, 6, 4]) == 5\nassert findMedian([5, 4, 3, 2, 1, 0]) == 2.5\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['GCD', 'repeating', 'integers', 'division', 'algorithm']", "prompt_tokens": 429, "total_tokens": 550, "completion_tokens": 121, "completion": "[Question 2]\n\nDesign an algorithm to find the greatest common divisor (GCD) of two integers using the method of repeated division. The algorithm should exit once the GCD is found.\n\n[/Question 2]\n\n[Code 2]\n\ndef gcdRepeatedDivision(a: int, b: int) -> int:\n    while b:\n        a, b = b, a % b\n    return a\n\n[/Code 2]\n\n[Asserts 2]\n\nassert gcdRepeatedDivision(48, 18) == 6\nassert gcdRepeatedDivision(17, 5) == 1", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['integer', 'range', 'list', 'digits', 'same', 'set', 'append']", "prompt_tokens": 560, "total_tokens": 1011, "completion_tokens": 451, "completion": "[Question 2]\n\nGiven a list of lists, merge all the sublists that have the same set of unique elements, creating a new list of those merged sublists.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\ndef mergeSameSetLists(input_list: List[List[int]]) -> List[List[int]]:\n    result = []\n    visited = set()\n    for lst in input_list:\n        unique_set = set(lst)\n        if frozenset(unique_set) not in visited:\n            visited.add(frozenset(unique_set))\n            temp = [lst]\n            for other in input_list:\n                if other != lst and set(other) == unique_set:\n                    temp.append(other)\n            result.append(temp)\n    return result\n\n[/Code 2]\n\n[Asserts 2]\n\nassert mergeSameSetLists([[1, 2, 3], [3, 2, 1], [4, 5, 6], [7, 8, 9], [9, 8, 7]]) == [[[1, 2, 3], [3, 2, 1]], [[4, 5, 6]], [[7, 8, 9], [9, 8, 7]]]\nassert mergeSameSetLists([[1, 2, 3], [4, 5, 6], [7, 8, 9], [9, 8, 7]]) == [[[1, 2, 3]], [[4, 5, 6]], [[7, 8, 9], [9, 8, 7]]]\nassert mergeSameSetLists([[1, 2, 3], [3, 2, 1], [1, 2, 3], [4, 5, 6], [7, 8, 9], [9, 8, 7]]) == [[[1, 2, 3], [3, 2, 1]], [[4, 5, 6]], [[7, 8, 9], [9, 8, 7]]]\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'triplet', 'sum', 'unique', 'integer', 'target']", "prompt_tokens": 739, "total_tokens": 1345, "completion_tokens": 606, "completion": "[Question 2]\n\nGiven a grid represented as a 2D array arr of integers, the task is to find all unique triplets in the grid such that the sum of elements in each triplet is equal to the given target. You are also required to sort the triplets using the insertion sort algorithm and return the resulting sorted triplets.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\ndef insertion_sort(arr: List[int]) -> List[int]:\n    for i in range(1, len(arr)):\n        key = arr[i]\n        j = i - 1\n        while j >= 0 and key < arr[j]:\n            arr[j + 1] = arr[j]\n            j -= 1\n        arr[j + 1] = key\n    return arr\n\ndef find_unique_triplets(grid: List[List[int]], target: int) -> List[List[int]]:\n    m, n = len(grid), len(grid[0])\n    triplets = set()\n    for i in range(m - 2):\n        for j in range(n - 2):\n            for k in range(3):\n                for l in range(3):\n                    for p in range(3):\n                        if i + k < m and j + l < n:\n                            triplets.add(tuple(sorted([grid[i][j], grid[i + k][j + l], grid[i + p][j]])))\n    result = []\n    for triplet in triplets:\n        if sum(triplet) == target:\n            result.append(list(triplet))\n    result.sort()\n    for i in range(len(result)):\n        result[i] = insertion_sort(result[i])\n    return result\n\n[/Code 2]\n\n[Asserts 2]\n\nassert find_unique_triplets([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 16) == [[1, 6, 9], [3, 5, 8]]\nassert find_unique_triplets([[3, 1, 2], [4, 6, 5], [7, 8, 9]], 17) == [[1, 8, 8], [2, 7, 8], [3, 6, 8], [3, 7, 7], [4, 5, 8], [4, 6, 7], [5, 5, 7], [5, 6, 6]]\nassert find_unique_triplets([[3, 2, 2], [6, 2, 1], [3, 8, 1]], 6) == [[2, 2, 2]]\nassert find_unique_triplets([[1, 1, 3], [1, 2, 1], [1, 8, 1]], 4) == []\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'integer', 'absolute difference', 'sum', 'sorting', 'pair']", "prompt_tokens": 513, "total_tokens": 838, "completion_tokens": 325, "completion": "[Question 2]\n\nYou are given an array of integers representing the amounts of money customers want to withdraw from an ATM. The ATM only has an unlimited supply of bills in the following denominations: 10, 20, 50. You need to write a function to determine if it is possible to provide the exact amount of money requested by each customer using the available denominations.\n\n[/Question 2]\n\n[Code 2]\n\ndef isValidWithdrawal(amounts: List[int]) -> bool:\n    for amount in amounts:\n        if amount % 10 != 0:\n            return False\n        tens = 0\n        twenties = 0\n        fifties = 0\n        while amount >= 50 and fifties < 1:\n            amount -= 50\n            fifties += 1\n        while amount >= 20 and twenties < 1:\n            amount -= 20\n            twenties += 1\n        while amount >= 10:\n            amount -= 10\n            tens += 1\n        if amount != 0:\n            return False\n    return True\n\n[/Code 2]\n\n[Asserts 2]\n\nassert isValidWithdrawal([10, 20, 50, 20, 30]) == False\nassert isValidWithdrawal([20, 50, 30, 50, 20]) == True\nassert isValidWithdrawal([10, 10, 10, 10, 20, 20, 20, 50, 50, 50]) == True\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['series', 'term', 'sequence', 'mathematical', 'integer', 'calculation']", "prompt_tokens": 471, "total_tokens": 680, "completion_tokens": 209, "completion": "[Question 2]\n\nGiven two identical sequences of integers, the task is to find the common characters in the focal chords of the sequences.\n\n[/Question 2]\n\n[Code 2]\n\ndef findCommonCharacters(sequence1: str, sequence2: str) -> set:\n    focal_chord_1 = sequence1[len(sequence1)//4:3*len(sequence1)//4]\n    focal_chord_2 = sequence2[len(sequence2)//4:3*len(sequence2)//4]\n    return set(focal_chord_1).intersection(set(focal_chord_2))\n\n[/Code 2]\n\n[Asserts 2]\n\nassert findCommonCharacters(\"123456789\", \"987654321\")=={'5', '6', '7', '8', '9'}\nassert findCommonCharacters(\"abcdef\", \"xyzabc\")=={'a', 'c'}\nassert findCommonCharacters(\"programming\", \"coding\")=={'g'}\nassert findCommonCharacters(\"apple\", \"mango\")==set()\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['integer', 'array', 'positive', 'sum', 'lexicographically', 'largest', 'generation']", "prompt_tokens": 597, "total_tokens": 914, "completion_tokens": 317, "completion": "[Question 2]\n\nGiven a positive integer N and an array A of size N, write a function to find the lexicographically largest array B of size N such that the sum of the perpendiculars of A and B is largest.\n\nThe perpendicular of an array C of size N is defined as the sum of product of each element of C with its rank in the array (rank starting from 1).\n\nWrite a function to find and return the lexicographically largest array B that maximizes the sum of perpendiculars of A and B.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\ndef perpendicularSum(nums: List[int]) -> int:\n    n = len(nums)\n    nums.sort()\n    res = 0\n    for i in range(n):\n        res += nums[i] * (i + 1)\n    return res\n\ndef largestPerpendicularSumArray(nums: List[int]) -> List[int]:\n    nums.sort()\n    return nums[::-1]\n\n[/Code 2]\n\n[Asserts 2]\n\nassert perpendicularSum([4, 2, 1, 3]) == 20\nassert perpendicularSum([3, 1, 2, 4]) == 20\nassert largestPerpendicularSumArray([4, 2, 1, 3]) == [4, 3, 2, 1]\nassert largestPerpendicularSumArray([3, 1, 2, 4]) == [4, 3, 2, 1]\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['binary', 'string', 'integer', 'range', 'changes', 'array', 'optimization', 'greedy']", "prompt_tokens": 708, "total_tokens": 1128, "completion_tokens": 420, "completion": "[Question 2]\n\nYou are given a binary string S and an integer K. The string S represents a binary array, where each i-th character of the string denotes the i-th element of the array. The task is to find the maximum number of consecutive 1s that can be achieved by flipping at most K 0s to 1s.\n\nFor example, if the binary string is \"10010101\" and K is 2, the optimal solution would be to flip the two 0s at position 2 and 3, resulting in the string \"10111101\" with the maximum number of consecutive 1s being 4.\n\nWrite a function `maxConsecutiveOnes` to find the maximum number of consecutive 1s that can be achieved by flipping at most K 0s to 1s.\n\nFunction Signature: def maxConsecutiveOnes(s: str, k: int) -> int:\n\n[/Question 2]\n\n[Code 2]\n\ndef maxConsecutiveOnes(s: str, k: int) -> int:\n    start, max_ones = 0, 0\n    changes = 0\n    for end in range(len(s)):\n        if s[end] == '0':\n            changes += 1\n        while changes > k:\n            if s[start] == '0':\n                changes -= 1\n            start += 1\n        max_ones = max(max_ones, end - start + 1)\n    return max_ones\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maxConsecutiveOnes(\"10010101\", 2) == 4\nassert maxConsecutiveOnes(\"1110111001\", 3) == 7\nassert maxConsecutiveOnes(\"000011110000\", 4) == 8\nassert maxConsecutiveOnes(\"111110101010\", 1) == 6\nassert maxConsecutiveOnes(\"101010101010\", 2) == 7\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['binary', 'matrix', 'operations', 'submatrix', 'negate', 'minimum', 'set', 'elements']", "prompt_tokens": 679, "total_tokens": 1099, "completion_tokens": 420, "completion": "[Question 2]\n\nGiven an unordered list of unsigned integers, find the minimum number of operations required to set all elements of a submatrix of a given matrix to 1. The operation involves negating elements of the submatrix. A submatrix is a matrix that is formed by selecting a contiguous set of rows and columns of the matrix.\n\n[/Question 2]\n\n[Code 2]\n\ndef minOperationsForSubmatrix(matrix: List[List[int]], elements: List[int]) -> int:\n    rowSet = set()\n    colSet = set()\n    for ele in elements:\n        rowSet.add(ele[0])\n        colSet.add(ele[1])\n    rowOps = len(matrix)-len(rowSet)\n    colOps = len(matrix[0])-len(colSet)\n    return max(rowOps, colOps)\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minOperationsForSubmatrix([[1, 0, 1], [0, 1, 1], [0, 0, 1]], [[0, 1], [1, 0], [2, 2]])==1\nassert minOperationsForSubmatrix([[0, 1, 1, 1], [1, 0, 1, 1], [1, 1, 0, 1], [1, 1, 1, 0]], [[1, 1], [2, 2], [3, 3]])==2\nassert minOperationsForSubmatrix([[1, 0, 1], [0, 1, 1], [0, 0, 1]], [[0, 0], [1, 1], [2, 2]])==2\nassert minOperationsForSubmatrix([[1, 1, 1], [1, 1, 1], [1, 1, 1]], [[0, 0], [1, 1], [2, 2]])==0\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'indexes', 'product', 'element', 'left', 'right', 'greater', 'stack']", "prompt_tokens": 688, "total_tokens": 1000, "completion_tokens": 312, "completion": "[Question 2]\n\nGiven a binary tree where each node contains an integer, write a function to find the total number of root-to-leaf paths in which the product of all the elements in the path is greater than a given limit. Assume the integers are within a limited range.\n\n[/Question 2]\n\n[Code 2]\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef totalPaths(root: TreeNode, limit: int) -> int:\n    if not root:\n        return 0\n\n    def dfs(node, curProduct):\n        if not node:\n            return 0\n        curProduct *= node.val\n        if not node.left and not node.right and curProduct > limit:\n            return 1\n        return dfs(node.left, curProduct) + dfs(node.right, curProduct)\n\n    return dfs(root, 1)\n\n[/Code 2]\n\n[Asserts 2]\n\n# Constructing the tree\n#      2\n#     / \\\n#    4   8\n#   /   / \\\n#  3   7   6\nroot = TreeNode(2)\nroot.left = TreeNode(4, TreeNode(3))\nroot.right = TreeNode(8, TreeNode(7), TreeNode(6))\n\nassert totalPaths(root, 50) == 2\nassert totalPaths(root, 5) == 3\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['integer', 'centered figurate number', 'polygon', 'formula', 'positive integer', 'Icosihenagonal number']", "prompt_tokens": 583, "total_tokens": 927, "completion_tokens": 344, "completion": "[Question 2]\n\nYou are given a set of pigs in a 2D grid, represented by a matrix where 1 represents the position of a pig and 0 represents an empty space. Write a function to find the level of the grid where the Icosihenagonal number of the total number of pigs is located. The formula to find the n-th Icosihenagonal number is: n(3n\u22121)/2, where n is a positive integer.\n\n[/Question 2]\n\n[Code 2]\n\ndef findLevel(grid: List[List[int]]) -> int:\n    total_pigs = sum(row.count(1) for row in grid)\n    n = 0\n    icosihenagonal_num = 0\n    while icosihenagonal_num < total_pigs:\n        n += 1\n        icosihenagonal_num = n * (3*n - 1) // 2\n    return n\n\n[/Code 2]\n\n[Asserts 2]\n\nassert findLevel([[1, 0, 1, 0],\n                  [0, 1, 0, 1],\n                  [1, 0, 0, 1],\n                  [0, 0, 1, 1]]) == 3\n\nassert findLevel([[0, 0, 0],\n                  [1, 1, 1],\n                  [0, 0, 0]]) == 2\n\nassert findLevel([[1, 1, 1],\n                  [1, 1, 1],\n                  [1, 1, 1]]) == 4\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['number', 'minimum length', 'paths', 'inclusive', 'formula', 'program', 'count', 'nodes', 'formula']", "prompt_tokens": 453, "total_tokens": 691, "completion_tokens": 238, "completion": "[Question 2]\n\nAn autobiographical number is a number such that the digits at index i in its decimal representation count the number of times digit i appears in the number. For example, 1210 is an autobiographical number because it contains one 0, two 1s, one 2, and zero 3s.\n\nWrite a program to check whether a given number is an autobiographical number. Your program should output True if the number is autobiographical, and False otherwise.\n\n[/Question 2]\n\n[Code 2]\n\ndef is_autobiographical_number(number: int) -> bool:\n\tdigits = [int(d) for d in str(number)]\n\tcounts = [0] * 10\n\tfor digit in digits:\n\t\tcounts[digit] += 1\n\tfor i in range(len(digits)):\n\t\tif counts[i] != digits[i]:\n\t\t\treturn False\n\treturn True\n\n[/Code 2]\n\n[Asserts 2]\n\nassert is_autobiographical_number(1210)==True\nassert is_autobiographical_number(2020)==False\nassert is_autobiographical_number(6210001000)==True\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['integer', 'sum', 'power of 2', 'binary', 'bitwise', 'logical']", "prompt_tokens": 546, "total_tokens": 923, "completion_tokens": 377, "completion": "[Question 2]\n\nYou are given an array of integers. Write a function to determine if the array contains a consecutive sequence of integers whose sum is a power of 2 (i.e., 2^x) and if so, return the start and end indices of the sequence. If no such sequence is found, return an empty list.\n\n[/Question 2]\n\n[Code 2]\n\ndef isPowerOfTwo(n: int) -> bool:\n    return n and (not(n & (n - 1)))\n\ndef consecutiveSequenceWithPowerOfTwo(arr: List[int]) -> List[int]:\n    prefix_sums = [0]\n    for num in arr:\n        prefix_sums.append(prefix_sums[-1] + num)\n\n    power_of_two_sum_indices = {}\n    result = []\n    for i, cur_sum in enumerate(prefix_sums):\n        for p in range(32):\n            if cur_sum - 2**p in power_of_two_sum_indices:\n                result = [power_of_two_sum_indices[cur_sum - 2**p] + 1, i]\n                break\n        power_of_two_sum_indices[cur_sum] = i\n\n    return result\n\n[/Code 2]\n\n[Asserts 2]\n\nassert consecutiveSequenceWithPowerOfTwo([1, 2, 3, 4, 5]) == [0, 2]\nassert consecutiveSequenceWithPowerOfTwo([4, 2, 3, 1, 6, 8, 5, 7]) == [1, 3]\nassert consecutiveSequenceWithPowerOfTwo([1, 2, 3, 4, 5, 6]) == []\nassert consecutiveSequenceWithPowerOfTwo([8, 3, 7, 2, 9, 1]) == [0, 1]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['relation', 'irreflexive', 'antisymmetric', 'set', 'elements', 'combinations', 'exponential', 'math']", "prompt_tokens": 522, "total_tokens": 723, "completion_tokens": 201, "completion": "[Question 2]\n\nWrite a recursive function to calculate the totient function (also known as Euler's totient function) for a given set of n elements. The totient function \u03c6(n) is the number of positive integers up to n that are relatively prime to n. Relatively prime numbers are those that have no common factors other than 1.\n\n[/Question 2]\n\n[Code 2]\n\ndef totientFunction(n: int) -> int:\n    if n == 1:\n        return 1\n    else:\n        result = 0\n        for i in range(1, n):\n            if math.gcd(i, n) == 1:\n                result += 1\n        return result\n\n[/Code 2]\n\n[Asserts 2]\n\nassert totientFunction(10) == 4\nassert totientFunction(15) == 8\nassert totientFunction(20) == 8\nassert totientFunction(25) == 20", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['math', 'sum', 'natural numbers', 'odd numbers', 'even numbers']", "prompt_tokens": 473, "total_tokens": 746, "completion_tokens": 273, "completion": "[Question 2]\n\nWrite a function that takes two lists of natural numbers and computes the squared-difference sum of the interleaved elements from the two lists. The squared-difference sum of two numbers is the difference between them squared.\n\n[/Question 2]\n\n[Code 2]\n\ndef squaredDifferenceSum(list1: List[int], list2: List[int]) -> float:\n\t\n\t# Ensure both lists are of the same length\n\tassert len(list1) == len(list2), \"Input lists must be of equal length\"\n\t\n\t# Calculate the squared-difference sum of interleaved elements\n\ttotal_sum = sum((x - y)**2 for x, y in zip(list1, list2))\n\t\n\treturn total_sum\n\n[/Code 2]\n\n[Asserts 2]\n\nassert squaredDifferenceSum([1, 3, 5], [2, 4, 6]) == 27\nassert squaredDifferenceSum([10, 20, 30, 40], [15, 25, 35, 45]) == 200\nassert squaredDifferenceSum([5, 10, 15], [5, 10, 15]) == 0\nassert squaredDifferenceSum([1, 3, 5], [2, 4])  #Assert error\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'subarray', 'size', 'removed', 'count', 'strictly', 'less than', 'greater than']", "prompt_tokens": 775, "total_tokens": 1072, "completion_tokens": 297, "completion": "[Question 2]\n\nYou are given an array of positive integers. Write a function to count the number of subarrays where the sum of all elements is strictly less than the sum of all elements when the subarray is reversed.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef countSubarraysWithReversedSum(arr: List[int]) -> int:\n    n = len(arr)\n    count = 0\n    for i in range(n):\n        sum_forward = 0\n        sum_reverse = 0\n        for j in range(i, n):\n            sum_forward += arr[j]\n            sum_reverse += arr[j]\n            if sum_forward < sum_reverse:\n                count += 1\n    return count\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countSubarraysWithReversedSum([1, 2, 3, 4]) == 9\nassert countSubarraysWithReversedSum([2, 4, 6, 8]) == 6\nassert countSubarraysWithReversedSum([5, 5, 5, 5, 5]) == 0\nassert countSubarraysWithReversedSum([1, 2, 3, 4, 5]) == 14\nassert countSubarraysWithReversedSum([3, 1, 2, 4, 5]) == 9\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'distinct', 'pairs', 'count', 'comparison']", "prompt_tokens": 594, "total_tokens": 796, "completion_tokens": 202, "completion": "[Question 2]\n\nYou are given an array of integers where each integer occurs twice except for one integer, which occurs only once. Write a function to find this distinct integer.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\ndef findDistinctInteger(nums: List[int]) -> int:\n    distinct_integer = 0\n    for num in nums:\n        distinct_integer ^= num\n    return distinct_integer\n\n[/Code 2]\n\n[Asserts 2]\n\nassert findDistinctInteger([4, 3, 4, 2, 3]) == 2\nassert findDistinctInteger([7, 9, 9, 12, 7]) == 12\nassert findDistinctInteger([10, 11, 10, 11, 13, 13, 14]) == 14\nassert findDistinctInteger([5, 6, 7, 7, 6]) == 5\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'non-negative integers', 'unordered pairs', 'power of 2', 'bit manipulation', 'counting', 'even', 'odd']", "prompt_tokens": 735, "total_tokens": 1073, "completion_tokens": 338, "completion": "[Question 2]\n\nYou are given an array of n non-negative integers where each integer represents the state of a bulb in a row. Initially, all the bulbs are off. You are also given an integer k, where k is the position you need to focus on. The task is to find the minimum number of operations needed to turn all the bulbs to the same state. A single operation consists of flipping the state of the bulbs in the range [i, k - i] using bit manipulation. Find the minimum number of operations needed to achieve the task.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef minOperations(arr: List[int], k: int) -> int:\n    n = len(arr)\n    cnt = 0\n    for i in range(n//k):\n        cnt += min(arr[i], 1-arr[i])\n    return cnt\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minOperations([0, 1, 0, 1, 0, 1], 1) == 3\nassert minOperations([0, 1, 0, 1, 0, 1], 2) == 0\nassert minOperations([1, 0, 1, 0, 1, 0], 2) == 2\nassert minOperations([0, 0, 0, 0, 0, 0], 3) == 0\nassert minOperations([1, 1, 1, 1, 1, 1], 2) == 3\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'integer', 'subtraction', 'minimum', 'sum', 'modulo']", "prompt_tokens": 515, "total_tokens": 742, "completion_tokens": 227, "completion": "[Question 2]\n\nGiven an array of integers, write a function to find the minimum sum of integers that are the result of the intersection of all subarrays after performing a subtraction operation.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef minSumOfIntersectionAfterSubtraction(arr: List[int]) -> int:\n    result = set(arr)\n    current = set(arr)\n    for num in arr:\n        current = {abs(x - num)  for x in current}\n        result = result.intersection(current)\n    return min(result)\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minSumOfIntersectionAfterSubtraction([10, 5, 11, 7]) == 1\nassert minSumOfIntersectionAfterSubtraction([20, 19, 17, 12]) == 1\nassert minSumOfIntersectionAfterSubtraction([15, 30, 25]) == 0\nassert minSumOfIntersectionAfterSubtraction([18, 22, 31, 29, 35]) == 6\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['number', 'function', 'sum', 'parts', 'smallest', 'calculation', 'iteration']", "prompt_tokens": 534, "total_tokens": 809, "completion_tokens": 275, "completion": "[Question 2]\n\nYou are given a list of numbers representing the prisoner numbers in a jail. A number pattern is defined as a sub-sequence of the prisoner numbers. Your task is to find the smallest number 'k' such that the sum of the parts of 'k' is equal to the sum of the prisoner numbers in the list. The parts of a number 'm' are defined as the numbers from 1 to m.\n\nWrite a function to find the smallest number pattern 'k' for a given list of prisoner numbers.\n\n[/Question 2]\n\n[Code 2]\n\ndef smallestNumberPattern(prisoner_numbers):\n    total_sum = sum(prisoner_numbers)\n    parts_sum = 0\n    k = 0\n    while parts_sum < total_sum:\n        k += 1\n        parts_sum += k\n    return k\n\n[/Code 2]\n\n[Asserts 2]\n\nassert smallestNumberPattern([1, 2, 3, 4, 5]) == 5\nassert smallestNumberPattern([2, 3, 5, 7, 11]) == 7\nassert smallestNumberPattern([10, 20, 30, 40, 50]) == 11\nassert smallestNumberPattern([100, 200, 300, 400, 500]) == 32", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['matrix', 'submatrix', 'transpose', 'adjacent', 'sorting', 'equality']", "prompt_tokens": 695, "total_tokens": 1163, "completion_tokens": 468, "completion": "[Question 2]\n\nGiven a matrix of integers, we are interested in finding all \"square-free\" submatrices from the given matrix. A submatrix is considered \"square-free\" if the product of all its elements is not a perfect square.\n\nWrite a function `countSquareFreeSubmatrices` to find the number of square-free submatrices in the given matrix. The function should take the matrix as input and return the count of square-free submatrices.\n\nFor example, given the matrix [[2, 3], [4, 5]], the function should return 4 (as there are 4 square-free submatrices: [[2], [4]], [[2, 3], [4, 5]], [[3], [5]], [[4]]).\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\ndef countSquareFreeSubmatrices(matrix: List[List[int]]) -> int:\n    def isSquareFree(num):\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % (i ** 2) == 0:\n                return False\n        return True\n\n    def countSubmatrix(matrix):\n        count = 0\n        for i in range(len(matrix)):\n            for j in range(len(matrix[0])):\n                submatrix_list = []\n                for x in range(i, len(matrix)):\n                    for y in range(j, len(matrix[0])):\n                        submatrix_list.append(matrix[x][y])\n                        product = 1\n                        for num in submatrix_list:\n                            product *= num\n                        if isSquareFree(product):\n                            count += 1\n        return count\n\n    return countSubmatrix(matrix)\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countSquareFreeSubmatrices([[2, 3], [4, 5]]) == 4\nassert countSquareFreeSubmatrices([[1, 4, 3], [3, 2, 7], [6, 9, 1]]) == 11\nassert countSquareFreeSubmatrices([[2, 2, 2], [2, 2, 2], [2, 2, 2]]) == 0\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['number', 'divisible', 'smallest', 'common multiple', 'factor', 'lcm', 'gcd', 'math']", "prompt_tokens": 454, "total_tokens": 638, "completion_tokens": 184, "completion": "[Question 2]\n\nYou are given an array of integers. Find the smallest positive integer X such that each element in the array is divisible by X.\n\n[/Question 2]\n\n[Code 2]\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef smallest_divisor(arr):\n    result = arr[0]\n    for i in range(1, len(arr)):\n        result = lcm(result, arr[i])\n    return result\n\n[/Code 2]\n\n[Asserts 2]\n\nassert smallest_divisor([3, 5, 10]) == 30\nassert smallest_divisor([7, 14, 21]) == 42\nassert smallest_divisor([4, 6, 8, 10]) == 120", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'integers', 'indices', 'division', 'pairs', 'count']", "prompt_tokens": 511, "total_tokens": 824, "completion_tokens": 313, "completion": "[Question 2]\n\nGiven an array of integers, how many possible pairs of indices (i, j) are there such that the floor function of the division of the elements at those indices is the same and the bitwise LED of the elements at those indices is also the same?\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\nimport math\n\ndef countPairsWithSameFloorAndLEDBIT(arr: List[int], n: int) -> int:\n    count = 0\n    for i in range(n-1):\n        for j in range(i+1, n):\n            if math.floor(arr[i] / arr[j]) == math.floor(arr[j] / arr[i]) and (arr[i] & arr[j]) == (arr[i] | arr[j]):\n                count += 1\n    return count\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countPairsWithSameFloorAndLEDBIT([1, 2, 3, 4, 5], 5) == 7\nassert countPairsWithSameFloorAndLEDBIT([3, 3, 3, 3, 3], 5) == 10\nassert countPairsWithSameFloorAndLEDBIT([5, 10, 15, 20, 25], 5) == 7\nassert countPairsWithSameFloorAndLEDBIT([8, 4, 2, 1], 4) == 1\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['series', 'pattern', 'calculation', 'math', 'integer', 'function']", "prompt_tokens": 529, "total_tokens": 899, "completion_tokens": 370, "completion": "[Question 2]\n\nYou are given a binary tree and are asked to find the sum of all the integers formed by traversing from root to leaf nodes. The integer formed at each leaf node is calculated by considering the path from the root to that leaf node as a concatenated string of the values traversed. For example, given the binary tree:\n\n```\n    1\n   / \\\n  2   3\n / \\\n4   5\n```\nThe integers formed by traversing each root to leaf path are 124, 125, and 13. The sum of these integers is 262.\n\nWrite a function sum_root_to_leaf(tree) that takes the root of the binary tree as input and returns the sum of all integers formed by traversing from root to leaf nodes.\n\n[/Question 2]\n\n[Code 2]\n\nclass TreeNode:\n    def __init__(self, value=0, left=None, right=None):\n        self.value = value\n        self.left = left\n        self.right = right\n\ndef sum_root_to_leaf(root: TreeNode) -> int:\n    def dfs(node, current_sum):\n        if not node:\n            return 0\n        current_sum = 10 * current_sum + node.value\n        if not node.left and not node.right:\n            return current_sum\n        return dfs(node.left, current_sum) + dfs(node.right, current_sum)\n    return dfs(root, 0)\n\n[/Code 2]\n\n[Asserts 2]\n\ntree = TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(5)), TreeNode(3))\nassert sum_root_to_leaf(tree) == 262\n\ntree = TreeNode(4, TreeNode(9, TreeNode(5), TreeNode(1)), TreeNode(0))\nassert sum_root_to_leaf(tree) == 1026", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'integer', 'perfect square', 'nearest', 'math', 'sqrt']", "prompt_tokens": 561, "total_tokens": 967, "completion_tokens": 406, "completion": "[Question 2]\n\nGiven an array of integers representing distances in cardinal directions (north, south, east, west) from a central point, find the nearest perfect square distance from the central point using Kruskal's algorithm.\n\n[/Question 2]\n\n[Code 2]\n\nimport math\nfrom typing import List\n\ndef nearestPerfectSquareDistance(distances: List[int]) -> int:\n\n    def isPerfectSquare(n):\n        sqrt_n = int(math.sqrt(n))\n        return sqrt_n * sqrt_n == n\n\n    def kruskalMST(graph):\n        # Implement Kruskal's algorithm to find the minimum spanning tree\n        pass  # Actual implementation not provided\n\n    graph = {}  # Convert distances to a weighted undirected graph\n    for i, distance in enumerate(distances):\n        for j, other_distance in enumerate(distances):\n            if i != j:\n                weight = abs(distance - other_distance)\n                if weight > 0:\n                    if i not in graph:\n                        graph[i] = {}\n                    if j not in graph:\n                        graph[j] = {}\n                    graph[i][j] = weight\n                    graph[j][i] = weight\n\n    kruskal_tree = kruskalMST(graph)\n    nearest_dist = float('inf')\n\n    for i, distance in enumerate(distances):\n        for j, other_distance in enumerate(distances):\n            if i != j:\n                if (i, j) in kruskal_tree or (j, i) in kruskal_tree:\n                    total_dist = distance + other_distance\n                    if isPerfectSquare(total_dist):\n                        nearest_dist = min(nearest_dist, total_dist)\n\n    return nearest_dist\n\n[/Code 2]\n\n[Asserts 2]\n\nassert nearestPerfectSquareDistance([1, 2, 3, 4, 5])==4\nassert nearestPerfectSquareDistance([3, 5, 8, 2, 1])==1\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['complex number', 'real part', 'imaginary part', 'split', 'string manipulation']", "prompt_tokens": 528, "total_tokens": 757, "completion_tokens": 229, "completion": "[Question 2]\n\nWrite a program to find the unique numbers present in a nested list and return them as a flattened list.\n\n[/Question 2]\n\n[Code 2]\n\ndef findUniqueNumbers(nestedList: list) -> list:\n    flattened_list = [num for sublist in nestedList for num in sublist]\n    return list(set(flattened_list))\n\n[/Code 2]\n\n[Asserts 2]\n\nassert findUniqueNumbers([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == [1, 2, 3, 4, 5, 6, 7, 8, 9]\nassert findUniqueNumbers([[3, 2, 3], [4, 5, 4], [7, 8, 7]]) == [2, 3, 4, 5, 7, 8]\nassert findUniqueNumbers([[7, 7, 7], [7, 7, 7], [7, 7, 7]]) == [7]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'integer', 'sum', 'differences', 'selection', 'minimize']", "prompt_tokens": 521, "total_tokens": 800, "completion_tokens": 279, "completion": "[Question 2]\n\nYou are given an array of integers. Write a function to select a subset of integers from the array in such a way that the subset is strictly decreasing and the sum of the differences between consecutive integers is minimized. \n\nAdditionally, each selected integer's Log value should be computed and added to the sum of differences.\n\nWrite a function to implement the above and return the minimized sum of differences after adding the Log values.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\nimport math\n\ndef minimizeDifferencesWithLog(arr: List[int]) -> int:\n    arr.sort(reverse=True)\n    ans = 0\n    for i in range(1, len(arr)):\n        diff = arr[i-1]-arr[i]\n        ans += diff\n    ans += sum([math.log(x) for x in arr])\n    return ans\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minimizeDifferencesWithLog([5, 10, 15, 20])==15\nassert minimizeDifferencesWithLog([3, 7, 9, 12, 18])==16\nassert minimizeDifferencesWithLog([10, 8, 6, 4, 2])==10\nassert minimizeDifferencesWithLog([20, 15, 10, 5])==10\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['math', 'array', 'sort', 'sum', 'absolute difference', 'maximum value']", "prompt_tokens": 549, "total_tokens": 915, "completion_tokens": 366, "completion": "[Question 2]\n\nGiven two arrays arr1[] and arr2[] of equal length N containing integers, the task is to find the pair of elements (one from arr1 and one from arr2) such that their sum is closest to a given value x.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List, Tuple\nimport sys\n\ndef closestSumPair(arr1: List[int], arr2: List[int], x: int) -> Tuple[int, int]:\n    n = len(arr1)\n    arr1.sort()\n    arr2.sort()\n    \n    diff = sys.maxsize\n    res = ()\n    \n    left = 0\n    right = n - 1\n    \n    while left < n and right >= 0:\n        if abs(arr1[left] + arr2[right] - x) < diff:\n            diff = abs(arr1[left] + arr2[right] - x)\n            res = (arr1[left], arr2[right])\n        \n        if arr1[left] + arr2[right] > x:\n            right -= 1\n        else:\n            left += 1\n    \n    return res\n\n[/Code 2]\n\n[Asserts 2]\n\nassert closestSumPair([1, 4, 5, 7], [10, 20, 30, 40], 32) == (5, 30)\nassert closestSumPair([1, 4, 5, 7], [10, 20, 30, 40], 28) == (7, 20)\nassert closestSumPair([4, 8, 9, 12], [3, 6, 7, 10], 16) == (8, 8)\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['cost', 'quantity', 'ratio', 'range', 'comparison', 'possibility', 'product']", "prompt_tokens": 600, "total_tokens": 928, "completion_tokens": 328, "completion": "[Question 2]\n\nGiven the costs and quantities of products, we want to compare the ratio of costs to quantities for different products. Find if it is possible to form a subgraph of products such that the ratio of costs to quantities are similar within a given range. Return True if it is possible, else return False.\n\n[/Question 2]\n\n[Code 2]\n\ndef isPossibleToCompareRatioInRange(products: List[Tuple[str, int, int]], range: float) -> bool :\n\t\n\tratios = {}\n\t\n\tfor product in products:\n\t\tratio = product[1]/product[2]\n\t\tratios[product[0]] = ratio\n\t\n\tfor i in range(len(products)):\n\t\tfor j in range(i+1,len(products)):\n\t\t\tif abs(ratios[products[i][0]]-ratios[products[j][0]]) > range:\n\t\t\t\treturn False\n\t\n\treturn True\n\n[/Code 2]\n\n[Asserts 2]\n\nassert isPossibleToCompareRatioInRange([('A', 5, 10), ('B', 8, 12), ('C', 3, 6)], 0.3)==True\nassert isPossibleToCompareRatioInRange([('X', 8, 12), ('Y', 3, 6), ('Z', 4, 7)], 0.2)==False\nassert isPossibleToCompareRatioInRange([('P1', 5, 8), ('P2', 3, 5), ('P3', 7, 11)], 0.4)==True\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'subarray', 'contiguous', 'distinct', 'integers', 'length', 'maximum', 'minimum', 'containing', 'consecutive']", "prompt_tokens": 676, "total_tokens": 1046, "completion_tokens": 370, "completion": "[Question 2]\n\nIn a cricket match, the score of a team of non-negative integers is represented by an array of integers, where each element represents the runs scored in a ball. The task is to find the maximum percentage increase in the score if the team can rearrange a contiguous subarray of the given scores. Return the maximum percentage increase as an integer (rounded down to the nearest integer).\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef maxScoreIncrease(prices: List[int]) -> int:\n    \n    n = len(prices)\n    max_increase = 0\n    \n    for i in range(n):\n        for j in range(i, n):\n            subarray = prices[i:j+1]\n            min_price = min(subarray)\n            max_price = max(subarray)\n            increase = ((max_price - min_price) / min_price) * 100\n            max_increase = max(max_increase, int(increase))\n    \n    return max_increase\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maxScoreIncrease([10, 7, 5, 8, 11, 9]) == 42\nassert maxScoreIncrease([30, 25, 14, 22, 19]) == 31\nassert maxScoreIncrease([15, 25, 19, 30, 18, 20, 29]) == 100\nassert maxScoreIncrease([12, 68, 49, 40, 32, 40, 32, 31, 50]) == 467\nassert maxScoreIncrease([20, 42, 15, 2, 82, 25, 97, 50, 40, 45]) == 850\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['graph', 'tree', 'degrees', 'vertices', 'edges', 'connected', 'cycle', 'sum', 'validation']", "prompt_tokens": 581, "total_tokens": 984, "completion_tokens": 403, "completion": "[Question 2]\n\nYou are given a graph with 'n' vertices and 'm' edges arranged in a specific order. The task is to validate whether the given arrangement of edges forms a connected graph. A connected graph is a graph in which there is a path between every pair of vertices.\n\nWrite a function to determine if the given arrangement of edges forms a connected graph.\n\n[/Question 2]\n\n[Code 2]\n\ndef isConnectedGraph(n: int, edges: list) -> bool:\n    if len(edges) < n-1:\n        return False\n    parent = list(range(n))\n    size = [1]*n\n    \n    def find(x):\n        if x != parent[x]:\n            parent[x] = find(parent[x])\n        return parent[x]\n    \n    def union(u, v):\n        pu, pv = find(u), find(v)\n        if size[pu] < size[pv]:\n            pu, pv = pv, pu\n        if pu != pv:\n            size[pv] += size[pu]\n            parent[pu] = pv\n    \n    for edge in edges:\n        u, v = edge\n        if find(u) != find(v):\n            union(u, v)\n    \n    num_of_components = sum(1 for i in range(n) if parent[i] == i)\n    \n    return num_of_components == 1\n\n[/Code 2]\n\n[Asserts 2]\n\nassert isConnectedGraph(4, [[0, 1], [1, 2], [2, 3]]) == True\nassert isConnectedGraph(4, [[0, 1], [1, 2]]) == False\nassert isConnectedGraph(5, [[0, 1], [1, 2], [2, 3], [3, 4]]) == True\nassert isConnectedGraph(5, [[0, 1], [2, 3], [3, 4]]) == False\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['integer', 'list', 'order', 'search', 'string', 'boolean', 'find', 'iteration']", "prompt_tokens": 575, "total_tokens": 872, "completion_tokens": 297, "completion": "[Question 2]\n\nYou are given a list of categories, each containing a list of strings. The task is to find the category with the minimum area under the condition that it must contain at least one string with an even length. If no category satisfies the condition, return None.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List, Union\n\ndef findCategoryWithMinimumArea(categories: List[List[str]]) -> Union[str, None]:\n    minArea = float('inf')\n    minAreaCategory = None\n    \n    for category in categories:\n        area = len(category)\n        for string in category:\n            if any(len(s)%2==0 for s in category):\n                if area < minArea:\n                    minArea = area\n                    minAreaCategory = category\n    \n    return minAreaCategory\n\n[/Code 2]\n\n[Asserts 2]\n\nassert findCategoryWithMinimumArea([['apple', 'banana', 'cherry'], ['pear', 'grape'], ['kiwi', 'orange', 'plum']])==['pear', 'grape']\nassert findCategoryWithMinimumArea([['home', 'dock', 'ship'], ['school', 'bus', 'car']])==None\nassert findCategoryWithMinimumArea([['one', 'two', 'three'], ['four', 'five', 'six', 'seven'], ['eight', 'nine', 'ten']])==['four', 'five', 'six', 'seven']", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['string', 'rotation', 'minimum', 'pattern', 'algorithm']", "prompt_tokens": 556, "total_tokens": 728, "completion_tokens": 172, "completion": "[Question 2]\n\nYou are given a string composed of plus and dots, where each plus represents a unique value and each dot represents a non-unique value. Your task is to detect the minimum number of rotations required to identify a pattern in the string.\n\n[/Question 2]\n\n[Code 2]\n\ndef minRotationForPattern(s: str) -> int:\n    countPlus, countDot = s.count('+'), s.count('.')\n    return min(countPlus, countDot)\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minRotationForPattern('+++..++..') == 2\nassert minRotationForPattern('..+..+++...++') == 4\nassert minRotationForPattern('..+..+..') == 2\nassert minRotationForPattern('.+...+...+..') == 3", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'subarray', 'LCM', 'least common multiple', 'math', 'gcd']", "prompt_tokens": 575, "total_tokens": 864, "completion_tokens": 289, "completion": "[Question 2]\n\nYou have been given an array of integers. Your task is to find the length of the longest subarray such that the LCM (Least Common Multiple) of all its elements is a perfect square.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\nfrom math import gcd\n\ndef isPerfectSquare(n: int) -> bool:\n    return (int(n ** 0.5))**2 == n\n\ndef longestSubarrayWithSquareLCM(arr: List[int]) -> int:\n    res = 0\n    LCM = 0\n    i = 0\n    for j in range(len(arr)):\n        LCM = arr[j] if not LCM else (arr[j]*LCM)//(gcd(arr[j], LCM))\n        if isPerfectSquare(LCM):\n            res = max(res, j - i + 1)\n        else:\n            i = j\n    return res\n\n[/Code 2]\n\n[Asserts 2]\n\nassert longestSubarrayWithSquareLCM([2, 3, 5, 7, 11, 13]) == 1\nassert longestSubarrayWithSquareLCM([6, 8, 9, 12, 15]) == 3\nassert longestSubarrayWithSquareLCM([4, 8, 9, 16, 25]) == 5", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'positive integers', 'sum', 'subarray', 'strictly increasing', 'strictly decreasing']", "prompt_tokens": 730, "total_tokens": 1097, "completion_tokens": 367, "completion": "[Question 2]\n\nYou are given an array of positive integers. Write a function to find the volume of the largest water-filled subarray, where the volume of water is calculated based on the negative difference between the heights of the left and right boundary of the subarray. You can assume that the array represents the heights of bars, and adjacent integers represent the width of each bar. Implement the function using a Breadth-First Search (BFS) approach.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef largestWaterVolume(A: List[int]) -> int:\n    left, right = 0, len(A) - 1\n    maxVolume = 0\n    while left < right:\n        width = right - left\n        height = min(A[left], A[right])\n        volume = width * height\n        maxVolume = max(maxVolume, volume)\n        if A[left] < A[right]:\n            left += 1\n        else:\n            right -= 1\n    return maxVolume\n\n[/Code 2]\n\n[Asserts 2]\n\nassert largestWaterVolume([1, 8, 6, 2, 5, 4, 8, 3, 7]) == 49\nassert largestWaterVolume([4, 3, 2, 1, 4]) == 16\nassert largestWaterVolume([1, 2, 1]) == 2\nassert largestWaterVolume([1, 3, 2, 4, 5, 2, 8]) == 12\nassert largestWaterVolume([1, 2, 4, 2, 5, 8, 7, 4, 5]) == 20\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['string', 'decode', 'character', 'transformation', 'difference', 'ASCII', 'mapping']", "prompt_tokens": 526, "total_tokens": 757, "completion_tokens": 231, "completion": "[Question 2]\n\nYou are given a string containing a series of valid numbers separated by a space. Write a Python function to calculate the mean of the second half of the valid numbers and return the result.\n\n[/Question 2]\n\n[Code 2]\n\ndef calculateMeanSecondHalf(inputString: str) -> float:\n    numbers = list(map(int, inputString.split()))\n    second_half = numbers[len(numbers)//2:]\n    mean = sum(second_half) / len(second_half)\n    return mean\n\n[/Code 2]\n\n[Asserts 2]\n\nassert calculateMeanSecondHalf(\"4 7 2 9 5 1\") == 4.0\nassert calculateMeanSecondHalf(\"12 45 32 78 90 65 21 34\") == 49.75\nassert calculateMeanSecondHalf(\"3 6 8 12 7 4 9 25 19 15\") == 14.833333333333334\nassert calculateMeanSecondHalf(\"100 200 300 400 500 600\") == 450.0\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['integer', 'arithmetic', 'progression', 'missing', 'unordered', 'binary search', 'algorithm']", "prompt_tokens": 608, "total_tokens": 961, "completion_tokens": 353, "completion": "[Question 2]\n\nYou are given an unordered list of n-1 integers that form an arithmetic progression with one integer missing. You are also given an integer k. Your task is to find the kth missing integer in the arithmetic progression.\n\nWrite a function `kthMissingInteger` to find the kth missing integer in an unordered arithmetic progression using the binary search algorithm.\n\n[/Question 2]\n\n[Code 2]\n\ndef kthMissingInteger(arr, k):\n    n = len(arr)\n    common_diff = (arr[n - 1] - arr[0]) // n\n    count_missing = lambda idx: arr[idx] - arr[0] - idx * common_diff\n    low, high = 0, n - 1\n    while low < high:\n        mid = (low + high) // 2\n        if count_missing(mid) < k:\n            low = mid + 1\n        else:\n            high = mid\n    return arr[0] + low * common_diff + (k - count_missing(low - 1))\n\n[/Code 2]\n\n[Asserts 2]\n\nassert kthMissingInteger([1, 3, 5, 7, 11, 13], 2) == 4\nassert kthMissingInteger([2, 6, 10, 14, 22, 26], 3) == 8\nassert kthMissingInteger([5, 10, 20, 35, 55], 1) == 3\nassert kthMissingInteger([1, 2, 4, 7, 11, 16], 5) == 9\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'operation', 'queries', 'frequency', 'count', 'element', 'change', '1s']", "prompt_tokens": 654, "total_tokens": 986, "completion_tokens": 332, "completion": "[Question 2]\n\nDuring an interview process, you are given an array consisting of 0s and 1s. You are allowed to perform individual operations that change an element from 0 to 1 or vice versa. After performing a series of queries of changing elements, you are required to calculate the percentile of 1s in the array based on the total number of elements.\n\n[/Question 2]\n\n[Code 2]\n\ndef calculatePercentile(arr: List[int], queries: List[str]) -> float:\n    ones_count = arr.count(1)\n    total_elements = len(arr)\n    for operation in queries:\n        if operation == \"change\":\n            element_index = int(queries[queries.index(operation) + 1])\n            if arr[element_index] == 0:\n                ones_count += 1\n            else:\n                ones_count -= 1\n            arr[element_index] = 1 if arr[element_index] == 0 else 0\n\n    return (ones_count / total_elements) * 100\n\n[/Code 2]\n\n[Asserts 2]\n\nassert calculatePercentile([0, 1, 0, 1, 1, 0, 1, 0, 1], [\"change\", \"2\", \"change\", \"4\"]) == 55.55555555555556\nassert calculatePercentile([1, 1, 0, 0, 1, 0, 1, 0], [\"change\", \"2\", \"change\", \"5\", \"change\", \"0\"]) == 62.5\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'integers', 'positive', 'negative', 'pairs', 'multiplication', 'count']", "prompt_tokens": 550, "total_tokens": 846, "completion_tokens": 296, "completion": "[Question 2]\n\nYou are given an array of integers representing the number of working days for employees. Write a Python program to count the number of pairs of employees who have worked for a positive number of days in reverse order such that the multiplication of their working days is greater than a given threshold.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\ndef countPositiveWorkingDayPairs(arr: List[int], threshold: int) -> int:\n    arr.sort(reverse=True)\n    count = 0\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            if arr[i] > 0 and arr[j] > 0 and arr[i] * arr[j] > threshold:\n                count += 1\n            else:\n                break\n    return count\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countPositiveWorkingDayPairs([3, 5, 2, 4, 1], 10) == 4\nassert countPositiveWorkingDayPairs([1, 2, 3, 4, 5], 10) == 0\nassert countPositiveWorkingDayPairs([7, 6, 4, 2, 1], 10) == 6\nassert countPositiveWorkingDayPairs([3, 5, 2, 4, 1], 5) == 6\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'integers', 'maximize', 'difference', 'maximum', 'minimum', 'operations', 'adding', 'subtracting', 'math']", "prompt_tokens": 641, "total_tokens": 892, "completion_tokens": 251, "completion": "[Question 2]\n\nGiven an array of integers, the task is to maximize the difference between the maximum and minimum array elements after performing a minimum number of operations to make the integers at even places capitalized.\n\n[/Question 2]\n\n[Code 2]\n\ndef capitalizeEvenPlaces(arr):\n    for i in range(len(arr)):\n        if i % 2 == 0:\n            arr[i] = arr[i].capitalize()\n    return arr\n\ndef maxDifferenceAfterCapitalization(arr):\n    capitalizedArr = capitalizeEvenPlaces(arr)\n    maxNum = max(capitalizedArr)\n    minNum = min(capitalizedArr)\n    return maxNum - minNum\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maxDifferenceAfterCapitalization([2, 6, 3, 4, 7]) == 3\nassert maxDifferenceAfterCapitalization([10, 21, 35, 42, 55]) == 45\nassert maxDifferenceAfterCapitalization([8, 4, 14, 6, 18]) == 8\nassert maxDifferenceAfterCapitalization([5, 8, 12, 16, 20]) == 15\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['perfect square', 'digits', 'math', 'boolean']", "prompt_tokens": 579, "total_tokens": 805, "completion_tokens": 226, "completion": "[Question 2]\n\nYou are given a fraction in the form of numerator/denominator. Create a function to determine if the decimal representation of the fraction will terminate. If the decimal representation terminates, return True, otherwise, return False.\n\n[/Question 2]\n\n[Code 2]\n\ndef isPerfectSquare(n):\n    root = n ** 0.5\n    return int(root + 0.5) ** 2 == n\n\ndef hasPerfectSquareInDenominator(num: int, den: int) -> bool:\n    return isPerfectSquare(den)\n\ndef isTerminatingDecimal(num: int, den: int) -> bool:\n    return hasPerfectSquareInDenominator(num, den)\n\n[/Code 2]\n\n[Asserts 2]\n\nassert isTerminatingDecimal(1, 2)==False\nassert isTerminatingDecimal(1, 4)==True\nassert isTerminatingDecimal(2, 5)==True\nassert isTerminatingDecimal(1, 3)==False\nassert isTerminatingDecimal(5, 8)==True\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'integer', 'largest number', 'rearrange']", "prompt_tokens": 490, "total_tokens": 825, "completion_tokens": 335, "completion": "[Question 2]\n\nYou are given an array of natural numbers. You need to rearrange the array in such a way that the largest number comes first, followed by the modified array where each element is multiplied by 2. You should use DFS for the rearrangement and implement a marking scheme to keep track of visited elements.\n\nWrite a function to perform the rearrangement as mentioned above.\n\n[/Question 2]\n\n[Code 2]\n\ndef rearrangeArray(nums):\n    visited = [False] * len(nums)\n    result = []\n    \n    def dfs(curr):\n        result.append(nums[curr])\n        visited[curr] = True\n        \n        for i in range(len(nums)):\n            if not visited[i]:\n                dfs(i)\n    \n    max_num_index = nums.index(max(nums))\n    dfs(max_num_index)\n    \n    modified_array = [num*2 for num in nums if num not in result]\n    \n    return result + modified_array\n\n[/Code 2]\n\n[Asserts 2]\n\nassert rearrangeArray([1, 2, 3, 4, 5])==[5, 4, 3, 2, 1, 6, 8, 10]\nassert rearrangeArray([10, 20, 30, 40, 50])==[50, 40, 30, 20, 10, 60, 80, 100]\nassert rearrangeArray([5, 10, 15, 20, 25])==[25, 20, 15, 10, 5, 30, 40, 50]\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['strings', 'count', 'characters', 'removal', 'comparison', 'frequency']", "prompt_tokens": 514, "total_tokens": 713, "completion_tokens": 199, "completion": "[Question 2]\n\nGiven two strings s and t, write a function to determine if t is a subsequence of s. A string s is a subsequence of string t, if t can be obtained by removing some characters from s without changing the order of the remaining characters.\n\n[/Question 2]\n\n[Code 2]\n\ndef isSubsequence(s: str, t: str) -> bool:\n    if len(t) == 0:\n        return True\n    index_s = 0\n    for char in s:\n        if char == t[index_s]:\n            index_s += 1\n            if index_s == len(t):\n                return True\n    return False\n\n[/Code 2]\n\n[Asserts 2]\n\nassert isSubsequence(\"abcde\", \"ace\") == True\nassert isSubsequence(\"abcde\", \"aec\") == False\nassert isSubsequence(\"helloworld\", \"horl\") == True\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'integer', 'distinct', 'replacements', 'elements']", "prompt_tokens": 618, "total_tokens": 903, "completion_tokens": 285, "completion": "[Question 2]\n\nYou are given an array of integers and an integer K. The task is to find the Kth distinct element in the array, considering only the distinct elements in the array. If Kth distinct element doesn't exist, return -1. \n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef findKthDistinct(arr: List[int], K: int) -> int:\n    distinct_elements = list(set(arr))\n    distinct_elements.sort()\n    if K <= len(distinct_elements):\n        return distinct_elements[K-1]\n    else:\n        return -1\n\n[/Code 2]\n\n[Asserts 2]\n\nassert findKthDistinct([1, 2, 3, 4, 5, 3, 4, 5, 6], 3) == 4\nassert findKthDistinct([1, 1, 1, 2, 2, 3, 3, 4, 4], 5) == -1\nassert findKthDistinct([9, 8, 7, 6, 5, 4, 3, 2, 1], 2) == 2\nassert findKthDistinct([1, 2, 1, 2, 3], 2) == 2\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['set', 'integers', 'subsets', 'GCD', 'divisor', 'count', 'bitwise', 'iteration', 'math']", "prompt_tokens": 583, "total_tokens": 862, "completion_tokens": 279, "completion": "[Question 2]\n\nGiven a set of integers, find the count of subsets where the GCD (Greatest Common Divisor) of all elements is greater than a given integer K.\n\n[/Question 2]\n\n[Code 2]\n\ndef gcd(a, b):\n\twhile b:\n\t\ta, b = b, a % b\n\treturn a\n\ndef countSubsetsWithGCDGreaterThanK(arr, k):\n\tn = len(arr)\n\tcnt = 0\n\tfor i in range(1, (1 << n)):\n\t\tg = 0\n\t\tfor j in range(n):\n\t\t\tif (i & (1 << j)):\n\t\t\t\tg = gcd(g, arr[j])\n\t\tif g > k:\n\t\t\tcnt += 1\n\treturn cnt\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countSubsetsWithGCDGreaterThanK([2, 3, 4], 1) == 3\nassert countSubsetsWithGCDGreaterThanK([5, 10, 15], 2) == 5\nassert countSubsetsWithGCDGreaterThanK([3, 6, 9, 12], 2) == 11\nassert countSubsetsWithGCDGreaterThanK([3, 5, 7, 9, 11], 3) == 16\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['string', 'subsequence', 'dynamic programming', 'length', 'common', '3 strings', 'algorithm']", "prompt_tokens": 711, "total_tokens": 1096, "completion_tokens": 385, "completion": "[Question 2]\n\nYou are given three strings A, B, and C. Write a dynamic programming algorithm to find the length of the longest common non-repeating subsequence among the three strings.\n\n[/Question 2]\n\n[Code 2]\n\ndef longestCommonNonRepeatingSubsequence(A: str, B: str, C: str) -> int:\n    n1, n2, n3 = len(A), len(B), len(C)\n    \n    dp = [[[0] * (n3 + 1) for _ in range(n2 + 1)] for _ in range(n1 + 1)]\n    \n    for i in range(1, n1 + 1):\n        for j in range(1, n2 + 1):\n            for k in range(1, n3 + 1):\n                if A[i - 1] == B[j - 1] == C[k - 1]:\n                    dp[i][j][k] = dp[i - 1][j - 1][k - 1] + 1\n                else:\n                    dp[i][j][k] = max(dp[i - 1][j][k], dp[i][j - 1][k], dp[i][j][k - 1])\n                    \n    return dp[n1][n2][n3]\n\n[/Code 2]\n\n[Asserts 2]\n\nassert longestCommonNonRepeatingSubsequence(\"abc\", \"acd\", \"bcd\") == 1\nassert longestCommonNonRepeatingSubsequence(\"abc\", \"def\", \"ghi\") == 0\nassert longestCommonNonRepeatingSubsequence(\"aaa\", \"aaa\", \"aaa\") == 1\nassert longestCommonNonRepeatingSubsequence(\"aggtab\", \"gxtxayb\", \"gtab\") == 4\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'elements', 'operations', 'sum', 'average', 'count', 'equality', 'minimum', 'replace']", "prompt_tokens": 574, "total_tokens": 988, "completion_tokens": 414, "completion": "[Question 2]\n\nGiven a 2D square matrix, write a program to perform the following operation. Replace all the elements below the main diagonal with their sum and all elements above the main diagonal with their average.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef modifyMatrix(matrix: List[List[int]]) -> List[List[int]]:\n    n = len(matrix)\n    modified_matrix = [[0]*n for _ in range(n)]\n    \n    for i in range(n):\n        for j in range(n):\n            if i > j:  # elements below the main diagonal\n                modified_matrix[i][j] = sum(matrix[i][:j+1])\n            elif i < j:  # elements above the main diagonal\n                modified_matrix[i][j] = sum(matrix[i][:j+1])/(j+1)\n            else:  # elements on the main diagonal\n                modified_matrix[i][j] = matrix[i][j]\n    \n    return modified_matrix\n\n[/Code 2]\n\n[Asserts 2]\n\nassert modifyMatrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == [[1, 1.5, 2], [4, 5, 3.0], [7, 8, 9]]\nassert modifyMatrix([[10, 20, 30], [40, 50, 60], [70, 80, 90]]) == [[10, 15.0, 20.0], [40, 50, 33.333333333333336], [70, 80, 90]]\nassert modifyMatrix([[2, 4, 6], [8, 10, 12], [14, 16, 18]]) == [[2, 3.0, 4.0], [8, 10, 6.0], [14, 16, 18]]\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['linked list', 'rearrange', 'position', 'node', 'even', 'odd']", "prompt_tokens": 621, "total_tokens": 1014, "completion_tokens": 393, "completion": "[Question 2]\n\nGiven a linked list, implement a function to rearrange the list such that all the even positioned nodes are together followed by the odd positioned nodes, as per their original order.\n\n[/Question 2]\n\n[Code 2]\n\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef rearrangeLinkedList(head: ListNode) -> ListNode:\n        if head is None or head.next is None or head.next.next is None:\n            return head\n        \n        oddIndex = head\n        evenIndex = head.next\n        oddHead = oddIndex\n        evenHead = evenIndex\n        index = 1  # Index starts from 1\n        \n        while oddIndex.next and evenIndex.next:\n            index += 2  # Increment index by 2 for even node\n            oddIndex.next = evenIndex.next\n            oddIndex = oddIndex.next\n            evenIndex.next = oddIndex.next\n            evenIndex = evenIndex.next\n        \n        oddIndex.next = evenHead  # Connect the odd positioned nodes with the even positioned nodes\n        return head\n\n[/Code 2]\n\n[Asserts 2]\n\n# Create linked list: 1 -> 2 -> 3 -> 4 -> 5\nnode5 = ListNode(5)\nnode4 = ListNode(4, node5)\nnode3 = ListNode(3, node4)\nnode2 = ListNode(2, node3)\nnode1 = ListNode(1, node2)\nresult = rearrangeLinkedList(node1)\n# Resulting linked list: 1 -> 3 -> 5 -> 2 -> 4\nassert result.val == 1\nassert result.next.val == 3\nassert result.next.next.val == 5\nassert result.next.next.next.val == 2\nassert result.next.next.next.next.val == 4\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'integer', 'subset', 'sum', 'smallest', 'greater than', 'sort', 'iteration']", "prompt_tokens": 632, "total_tokens": 992, "completion_tokens": 360, "completion": "[Question 2]\n\nGiven a 2D array in column-major order, determine the subset with the smallest sum overall by iterating down the columns.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef smallestSubsetColumnMajor(arr: List[List[int]]) -> List[int]:\n    # Initialize a list to store the column sums\n    column_sums = [sum(col) for col in zip(*arr)]  # calculate column sum by summing up the items in each column using zip and then sum\n    # Sort the column sums to get the indices of columns with the smallest sums\n    sorted_indices = sorted(range(len(column_sums)), key=lambda i: column_sums[i])  # return the sorted index of the smallest sum\n    \n    # Return the first column (with the smallest sum overall)\n    return [arr[i][sorted_indices[0]] for i in range(len(arr))]\n\n[/Code 2]\n\n[Asserts 2]\n\narr1 = [\n    [1, 2, 3],\n    [4, 5, 6],\n    [7, 8, 9]\n]\nassert smallestSubsetColumnMajor(arr1)== [1, 4, 7]\narr2 = [\n    [3, 1, 7],\n    [1, 2, 8],\n    [5, 6, 9]\n]\nassert smallestSubsetColumnMajor(arr2)== [3, 1, 5]\narr3 = [\n    [9, 8, 7],\n    [6, 5, 4],\n    [3, 2, 1]\n]\nassert smallestSubsetColumnMajor(arr3)== [9, 6, 3]\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'positive integers', 'divide', 'subsets', 'sum', 'dynamic programming', 'feasibility', 'target', 'mask']", "prompt_tokens": 757, "total_tokens": 997, "completion_tokens": 240, "completion": "[Question 2]\n\nGiven an array of positive integers, find the waiting time required for a particular task. The array represents the time required for each task to be completed, and the waiting time is defined as the sum of the times for all tasks to be completed before the given task.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\ndef waitingTime(arr: List[int], taskIndex: int) -> int:\n    if taskIndex >= len(arr):\n        return 0\n    waiting_time = 0\n    for i in range(taskIndex):\n        waiting_time += arr[i]\n    return waiting_time\n\n[/Code 2]\n\n[Asserts 2]\n\nassert waitingTime([3, 2, 1, 4], 2) == 5\nassert waitingTime([3, 2, 1, 4], 0) == 0\nassert waitingTime([1, 2, 3, 4, 5], 3) == 6\nassert waitingTime([5, 4, 3, 2, 1], 4) == 10\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['string', 'lexicographically', 'substring', 'occurrences', 'character', 'max', 'frequency']", "prompt_tokens": 538, "total_tokens": 823, "completion_tokens": 285, "completion": "[Question 2]\n\nGiven a string s, write a function to find the lexicographically smallest sub-string of length k which has the maximum number of occurrences of a given character c.\n\n[/Question 2]\n\n[Code 2]\n\ndef maxOccurrenceSubstring(s: str, k: int, c: str) -> str:\n    max_freq = 0\n    start = 0\n    freq = [0]*26\n    result = \"\"\n\n    for end in range(len(s)):\n        freq[ord(s[end]) - ord('a')] += 1\n        max_freq = max(max_freq, freq[ord(s[end]) - ord('a')])\n\n        if end - start + 1 > k:\n            freq[ord(s[start]) - ord('a')] -= 1\n            start += 1\n\n        if end - start + 1 == k:\n            if freq[ord(c) - ord('a')] == max_freq:\n                result = s[start:end+1]\n    \n    return result\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maxOccurrenceSubstring(\"abcaabbca\", 3, \"a\") == \"bca\"\nassert maxOccurrenceSubstring(\"abcdaabbca\", 2, \"c\") == \"cc\"\nassert maxOccurrenceSubstring(\"abcdabcdea\", 4, \"a\") == \"abcd\"", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'subarray', 'counting', 'binary', 'bitwise', 'nested loops']", "prompt_tokens": 573, "total_tokens": 812, "completion_tokens": 239, "completion": "[Question 2]\n\nGiven an array arr of integers, find the lowest common value of any contiguous subarray in the array. Return True if the lowest common value is divisible by 5, otherwise return False.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef lowestCommonValue(arr: List[int]) -> bool:\n    n = len(arr)\n    for i in range(n):\n        common_value = arr[i]\n        for j in range(i, n):\n            common_value &= arr[j]\n            if common_value % 5 == 0:\n                return True\n    return False\n\n[/Code 2]\n\n[Asserts 2]\n\nassert lowestCommonValue([3, 5, 10, 15, 6, 21]) == True\nassert lowestCommonValue([3, 7, 11, 15, 6, 21]) == False\nassert lowestCommonValue([2, 4, 8, 16, 32]) == True\nassert lowestCommonValue([2, 3, 5, 7, 11, 13]) == False\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'integer', 'XOR', 'maximum', 'value', 'selection']", "prompt_tokens": 642, "total_tokens": 967, "completion_tokens": 325, "completion": "[Question 2]\n\nYou are given an array of integers. Find the maximum XOR value of any two elements in the array.\n\nFor example, if the input array is [3, 10, 5, 25, 2, 8], then the maximum XOR value is 28, obtained by XOR of 5 and 25.\n\nWrite a function that takes in the array and returns the maximum XOR value of any two elements in the array.\n\n[/Question 2]\n\n[Code 2]\n\ndef max_xor_value(arr):\n    max_xor = 0\n    n = len(arr)\n    for i in range(n):\n        for j in range(i+1, n):\n            max_xor = max(max_xor, arr[i] ^ arr[j])\n    return max_xor\n\n[/Code 2]\n\n[Asserts 2]\n\nassert max_xor_value([3, 10, 5, 25, 2, 8]) == 28\nassert max_xor_value([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == 15\nassert max_xor_value([10, 20, 30, 40, 50]) == 60\nassert max_xor_value([8, 1, 2, 12, 7, 6, 5]) == 15\nassert max_xor_value([4, 6, 8, 2, 1, 5, 7, 3]) == 15\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['prime', 'factor', 'count', 'range', 'division', 'math', 'integer', 'loop']", "prompt_tokens": 513, "total_tokens": 895, "completion_tokens": 382, "completion": "[Question 2]\n\nGiven a list of integers, the task is to count the number of prime numbers and numbers divisible by 3 in the list and return the count of both sets of numbers.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef countPrimesAndDivisibleBy3(nums: List[int]) -> (int, int):\n\tprime_count = 0\n\tdivisible_by_3_count = 0\n\tfor num in nums:\n\t\tif num < 2:\n\t\t\tcontinue\n\t\tis_prime = True\n\t\tfor i in range(2, int(num**0.5) + 1):\n\t\t\tif num % i == 0:\n\t\t\t\tis_prime = False\n\t\t\t\tbreak\n\t\tif is_prime:\n\t\t\tprime_count += 1\n\t\tif num % 3 == 0:\n\t\t\tdivisible_by_3_count += 1\n\treturn prime_count, divisible_by_3_count\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countPrimesAndDivisibleBy3([2, 3, 5, 6, 7, 9, 11, 13, 15])==(5, 4)\nassert countPrimesAndDivisibleBy3([17, 19, 20, 21, 22, 23, 24, 25, 26, 27])==(5, 5)\nassert countPrimesAndDivisibleBy3([28, 29, 30, 31, 32, 33, 34, 35, 36])==(2, 6)\nassert countPrimesAndDivisibleBy3([37, 38, 39, 40, 41, 42, 43, 44, 45])==(3, 5)\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['string', 'split', 'substrings', 'set', 'characters', 'boolean', 'sorting']", "prompt_tokens": 523, "total_tokens": 860, "completion_tokens": 337, "completion": "[Question 2]\n\nYou are given a list of strings representing different flavors of donuts. Write a function to sort the list of donut flavors in such a way that all the flavors containing the substring \"horn\" appear first, followed by the remaining flavors in lexicographic order.\n\n[/Question 2]\n\n[Code 2]\n\ndef sortDonutFlavors(donut_flavors):\n    horn_flavors = [flavor for flavor in donut_flavors if \"horn\" in flavor]\n    remaining_flavors = [flavor for flavor in donut_flavors if \"horn\" not in flavor]\n    horn_flavors.sort()  # Sort the horn flavors\n    remaining_flavors.sort()  # Sort the remaining flavors\n    return horn_flavors + remaining_flavors\n\n[/Code 2]\n\n[Asserts 2]\n\nassert sortDonutFlavors([\"chocolate\", \"glazed\", \"unicorn\", \"maple\", \"vanilla\", \"horned melon\"]) == [\"horned melon\", \"unicorn\", \"chocolate\", \"glazed\", \"maple\", \"vanilla\"]\nassert sortDonutFlavors([\"apple\", \"blackberry\", \"blueberry\", \"cherry\", \"peach\", \"strawberry\"]) == [\"apple\", \"blackberry\", \"blueberry\", \"cherry\", \"peach\", \"strawberry\"]\nassert sortDonutFlavors([\"horned melon\", \"lemon\", \"apricot\", \"cherry\", \"hornet\"]) == [\"horned melon\", \"hornet\", \"apricot\", \"cherry\", \"lemon\"]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['preorder', 'traversal', 'full', 'binary', 'tree', 'mirror', 'construct', 'node', 'children']", "prompt_tokens": 631, "total_tokens": 889, "completion_tokens": 258, "completion": "[Question 2]\n\nGiven a numeric string representing the preorder traversal of a Fibonomial tree, construct the Fibonomial tree.\n\nA Fibonomial tree is a specific type of binary tree where each node in the tree holds a numeric value, and the shape of the tree follows a Fibonomial pattern.\n\n[/Question 2]\n\n[Code 2]\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef buildFibonomialTree(preorder: str) -> TreeNode:\n    def helper(preorder, index):\n        if index > len(preorder) or preorder[index] == '#':\n            return None\n        root = TreeNode(int(preorder[index]))\n        root.left = helper(preorder, 2 * index + 1)\n        root.right = helper(preorder, 2 * index + 2)\n        return root\n\n    return helper(preorder, 0)\n\n[/Code 2]\n\n[Asserts 2]\n\npreorder = \"1#23#4##\"\nassert buildFibonomialTree(preorder) == [1, 2, 3, 4]\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'permutations', 'recursion', 'combinatorics', 'backtracking']", "prompt_tokens": 867, "total_tokens": 1007, "completion_tokens": 140, "completion": "[Question 2]\n\nGiven a collection of words, find all possible permutations of the words and return the count of unique permutations.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\nimport itertools\n\ndef word_permutations_count(words: List[str]) -> int:\n    permutations = set(itertools.permutations(words))\n    return len(permutations)\n\n[/Code 2]\n\n[Asserts 2]\n\nassert word_permutations_count([\"cat\", \"dog\", \"bat\"]) == 6\nassert word_permutations_count([\"apple\", \"banana\", \"orange\"]) == 6\nassert word_permutations_count([\"red\", \"blue\", \"green\", \"yellow\"]) == 24", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['power', '2', 'determine', 'program', 'True', 'False']", "prompt_tokens": 459, "total_tokens": 724, "completion_tokens": 265, "completion": "[Question 2]\n\nWrite a program to determine if a given number is a tetrahedral number. A tetrahedral number is the sum of the first n triangular numbers, and can be represented by the formula T(n) = (n * (n + 1) * (n + 2)) / 6. If the given number is a tetrahedral number, the program should return True; otherwise, it should return False.\n\n[/Question 2]\n\n[Code 2]\n\ndef isTetrahedralNumber(num: int) -> bool:\n    n = 1\n    while True:\n        tetrahedral_num = (n * (n + 1) * (n + 2)) // 6\n        if tetrahedral_num == num:\n            return True\n        elif tetrahedral_num > num:\n            return False\n        n += 1\n\n[/Code 2]\n\n[Asserts 2]\n\nassert isTetrahedralNumber(10)==False\nassert isTetrahedralNumber(20)==True\nassert isTetrahedralNumber(35)==True\nassert isTetrahedralNumber(40)==False\nassert isTetrahedralNumber(56)==True\nassert isTetrahedralNumber(100)==False", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'integers', 'product', 'first digit', 'function']", "prompt_tokens": 474, "total_tokens": 733, "completion_tokens": 259, "completion": "[Question 2]\n\nGiven an array of consecutive integer side-lengths, write a function to perform an update query that multiplies the consecutive pairs of side-lengths and returns the first digit of the product.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef firstDigitProductUpdate(arr: List[int], index: int, value: int) -> int:\n    arr[index] = value\n    product = 1\n    for i in range(len(arr)-1):\n        product *= arr[i] * arr[i+1]\n    while product >= 10:\n        product //= 10\n    \n    return product\n\n[/Code 2]\n\n[Asserts 2]\n\nassert firstDigitProductUpdate([2, 3, 4, 5, 6], 2, 2)==6\nassert firstDigitProductUpdate([1, 2, 3, 4, 5], 3, 6)==6\nassert firstDigitProductUpdate([9, 8, 7, 6, 5], 0, 1)==5\nassert firstDigitProductUpdate([3, 4, 1, 6, 2], 4, 3)==7\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'subarray', 'product', 'prime', 'count', 'loop', 'multiplication']", "prompt_tokens": 586, "total_tokens": 923, "completion_tokens": 337, "completion": "[Question 2]\n\nYou are given an array of integers, and your task is to find the count of subarrays whose product is a prime number. \n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef countSubarraysWithPrimeProduct(nums: List[int]) -> int:\n    def is_prime(n):\n        if n <= 1:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    \n    def count_subarrays(start, end):\n        count = 0\n        product = 1\n        for i in range(start, end+1):\n            product *= nums[i]\n            if is_prime(product):\n                count += 1\n        return count\n    \n    result = 0\n    for i in range(len(nums)):\n        for j in range(i, len(nums)):\n            result += count_subarrays(i, j)\n    return result\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countSubarraysWithPrimeProduct([2, 3, 5, 7]) == 7\nassert countSubarraysWithPrimeProduct([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == 35\nassert countSubarraysWithPrimeProduct([6, 7, 8, 9, 10]) == 5\nassert countSubarraysWithPrimeProduct([2, 3, 4, 5]) == 6\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['hash map', 'frequency', 'elements', 'array', 'occurrences', 'threshold']", "prompt_tokens": 620, "total_tokens": 1036, "completion_tokens": 416, "completion": "[Question 2]\n\nGiven an array of integers and a threshold value, the task is to find all elements in the array that occur more frequently than the threshold value and are also considered \"ugly numbers.\" Ugly numbers are defined here as numbers whose only prime factors are 2, 3, or 5.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef findUglyFrequentElements(arr: List[int], threshold: int) -> List[int]:\n    def isUgly(num):\n        while num % 2 == 0:\n            num /= 2\n        while num % 3 == 0:\n            num /= 3\n        while num % 5 == 0:\n            num /= 5\n        return num == 1\n        \n    freq_map = {}\n    ugly_nums = set()\n    result = []\n    \n    for num in arr:\n        if num in freq_map:\n            freq_map[num] += 1\n        else:\n            freq_map[num] = 1\n    \n    for num, freq in freq_map.items():\n        if freq > threshold and isUgly(num):\n            result.append(num)\n    \n    return result\n\n[/Code 2]\n\n[Asserts 2]\n\nassert findUglyFrequentElements([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 2) == [6, 8, 9, 10]\nassert findUglyFrequentElements([12, 15, 18, 24, 30, 36, 42, 48], 2) == [12, 18, 24, 30, 36, 42, 48]\nassert findUglyFrequentElements([2, 3, 3, 5, 5, 5, 7, 7, 7, 11, 11, 11], 3) == [3, 5]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['binary', 'string', 'adjacent', 'set bits', 'count', 'length', 'recursion', 'combinations']", "prompt_tokens": 531, "total_tokens": 926, "completion_tokens": 395, "completion": "[Question 2]\n\nGiven a 3D space containing a set of points represented as (x, y, z), write a function to find the number of unique combinations of points that form a valid 3D string. A valid string is defined as a sequence of points where each of their distances is within a specified maximum length.\n\n[/Question 2]\n\n[Code 2]\n\nimport itertools\nimport math\n\ndef distance(point1, point2):\n    return math.sqrt((point2[0] - point1[0])**2 + \n                     (point2[1] - point1[1])**2 + \n                     (point2[2] - point1[2])**2)\n\ndef countValidStrings(points, max_length):\n    valid_strings = set()\n    for combination in itertools.combinations(points, 3):\n        d1, d2, d3 = distance(combination[0], combination[1]), distance(combination[1], combination[2]), distance(combination[2], combination[0])\n        if d1 <= max_length and d2 <= max_length and d3 <= max_length:\n            valid_strings.add(tuple(sorted(combination)))\n    return len(valid_strings)\n\n[/Code 2]\n\n[Asserts 2]\n\npoints1 = [(0, 0, 0), (1, 1, 1), (2, 2, 2), (3, 3, 3)]\nassert countValidStrings(points1, 1.732) == 4 # 1.732 is the square root of 3\npoints2 = [(0, 0, 0), (3, 4, 5), (5, 12, 13), (8, 15, 17)]\nassert countValidStrings(points2, 9.0) == 1 # 9.0 is the square root of 81\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['sum', 'multiples', 'iteration', 'math', 'division', 'modulus', 'loop']", "prompt_tokens": 469, "total_tokens": 767, "completion_tokens": 298, "completion": "[Question 2]\n\nYou are given a function f(x) = x^2. Write a Python function to numerically integrate f(x) over the interval [a, b] using the trapezoidal rule. The trapezoidal rule approximates the integral of a function by breaking the interval into trapezoids and summing the areas of the trapezoids. Return the result of the numerical integration.\n\n[/Question 2]\n\n[Code 2]\n\ndef numericalIntegration(a: float, b: float, n: int) -> float:\n    h = (b - a) / n\n    result = 0.5 * (f(a) + f(b))\n    for i in range(1, n):\n        result += f(a + i * h)\n    return result * h\n\ndef f(x: float) -> float:\n    return x**2\n\n[/Code 2]\n\n[Asserts 2]\n\nassert numericalIntegration(0, 1, 1000) == 0.3333335\nassert numericalIntegration(0, 2, 1000) == 2.6666665\nassert numericalIntegration(0, 3, 1000) == 9.0000015\nassert numericalIntegration(0, 4, 1000) == 21.3333355\nassert numericalIntegration(0, 5, 1000) == 41.6666685", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'sum', 'index', 'even', 'odd', 'possible ways', 'remove', 'element']", "prompt_tokens": 679, "total_tokens": 981, "completion_tokens": 302, "completion": "[Question 2]\n\nYou are given a tuple of integer elements representing the direction cosines in 3D space. Write a function to find all possible ways to remove one element from the tuple such that the sum of the remaining elements is even. Return the count of such possible ways.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import Tuple\ndef countWaysToRemoveForEvenSum(t: Tuple[int, int, int]) -> int:\n    count_odd = 0\n    count_even = 0\n    for i in t:\n        if i % 2 == 0:\n            count_even += 1\n        else:\n            count_odd += 1\n    if count_even == 0:\n        return len(t)\n    elif count_odd == 1:\n        return count_even\n    else:\n        return 0\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countWaysToRemoveForEvenSum((1, 2, 3)) == 1\nassert countWaysToRemoveForEvenSum((2, 2, 6)) == 3\nassert countWaysToRemoveForEvenSum((1, 5, 7)) == 3\nassert countWaysToRemoveForEvenSum((1, 3, 5, 7)) == 0\nassert countWaysToRemoveForEvenSum((2, 4, 6, 8)) == 4\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'integer', 'power', 'exponent', 'set', 'math', 'iteration', 'list', 'expression']", "prompt_tokens": 589, "total_tokens": 1057, "completion_tokens": 468, "completion": "[Question 2]\n\nYou are given a list of mathematical expressions represented as strings. Your task is to iterate through the list and identify expressions that contain the tangent function (tan). For such expressions, convert the angle values in degrees to radians and return the updated list of expressions.\n\n[/Question 2]\n\n[Code 2]\n\nimport math\nfrom typing import List\ndef updateTanExpressions(expressions: List[str]) -> List[str]:\n    updated_expressions = []\n    for exp in expressions:\n        if 'tan' in exp:\n            exp_parts = exp.split('tan(')\n            exp_parts[1] = exp_parts[1].split(')')[0]\n            angle = float(exp_parts[1])\n            angle_radians = math.radians(angle)\n            updated_expression = exp_parts[0] + 'tan(' + str(angle_radians) + ')' + exp_parts[1][len(str(angle)):]\n            updated_expressions.append(updated_expression)\n        else:\n            updated_expressions.append(exp)\n    return updated_expressions\n\n[/Code 2]\n\n[Asserts 2]\n\nassert updateTanExpressions(['sin(30) + tan(45)', 'cos(60) + tan(90)', 'tan(120)']) == ['sin(30) + tan(0.7853981633974483)', 'cos(60) + tan(1.5707963267948966)', 'tan(120)']\nassert updateTanExpressions(['tan(45) + tan(60)', 'tan(30) + cos(45)', 'sin(60) + tan(90)', 'tan(120)']) == ['tan(0.7853981633974483)', 'tan(1.0471975511965976) + cos(45)', 'sin(60) + tan(1.5707963267948966)', 'tan(120)']\nassert updateTanExpressions(['sin(30) + cos(45)', 'sin(60) + cos(tan(45))', 'tan(30) + tan(45)', 'tan(90)']) == ['sin(30) + cos(45)', 'sin(60) + cos(tan(45))', 'tan(30) + tan(45)', 'tan(90)']", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['string', 'transformation', 'operation', 'check', 'character']", "prompt_tokens": 577, "total_tokens": 861, "completion_tokens": 284, "completion": "[Question 2]\n\nGiven a string representing a sequence of parenthesis, write a Python function to check if it is possible to perform a transformation operation to make the string represent a valid sequence of parenthesis. The transformation operation involves flipping a parenthesis from '(' to ')' or from ')' to '('.\n\nThe function should return True if the transformation is possible, and False otherwise.\n\n[/Question 2]\n\n[Code 2]\n\ndef isValidParenthesis(s: str) -> bool:\n  \n    # Keep track of the count of open and close parenthesis\n    open_count = 0\n    close_count = 0\n\n    # Iterate through each character in the string\n    for char in s:\n        if char == '(':\n            open_count += 1\n        elif char == ')':\n            close_count += 1\n\n        # If close parenthesis count exceeds open parenthesis count,\n        # then transformation is not possible\n        if close_count > open_count:\n            return False\n\n    # Check if open and close counts are equal\n    return open_count == close_count\n\n[/Code 2]\n\n[Asserts 2]\n\nassert isValidParenthesis(\"(()\") == True\nassert isValidParenthesis(\")()(\") == False\nassert isValidParenthesis(\"()\") == True\nassert isValidParenthesis(\"((()))\") == True\nassert isValidParenthesis(\"())(\") == False\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['string', 'modification', 'rearrange', 'character', 'insert', 'position']", "prompt_tokens": 754, "total_tokens": 1133, "completion_tokens": 379, "completion": "[Question 2]\n\nYou are given a string S and a list of positions and characters to be replaced in the string. The characters in the string can be rearranged in any order after each replacement.\n\nWrite a function `replaceAndRearrange` to return the final string after replacing characters at specified positions and rearranging them.\n\nFunction Signature: `def replaceAndRearrange(s: str, replacements: List[Tuple[int, str]]) -> str:`\n\n**Input**\n- s: a string (1 <= |s| <= 10^5)\n- replacements: a list of tuples where each tuple contains a position and a character to be replaced at that position\n\n**Output**\n- return the final state of the string after replacements and rearrangements.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List, Tuple\n\ndef replaceAndRearrange(s: str, replacements: List[Tuple[int, str]]) -> str:\n    for pos, char in replacements:\n        s = s[:pos] + char + s[pos+1:]\n    return ''.join(sorted(s))\n\n[/Code 2]\n\n[Asserts 2]\n\nassert replaceAndRearrange(\"abc\", [(1, \"x\"), (2, \"y\")]) == \"abcyx\"\nassert replaceAndRearrange(\"leetcode\", [(1, \"z\"), (3, \"k\"), (5, \"p\")]) == \"cedklopet\"\nassert replaceAndRearrange(\"xyz\", [(0, \"a\"), (2, \"b\")]) == \"abz\"\nassert replaceAndRearrange(\"aabb\", [(0, \"z\"), (3, \"y\")]) == \"abby\"\nassert replaceAndRearrange(\"a\", [(0, \"x\")]) == \"x\"\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['integer', 'array', 'subarray', 'divisibility', 'unique', 'modulus']", "prompt_tokens": 543, "total_tokens": 926, "completion_tokens": 383, "completion": "[Question 2]\n\nYou are given an array of integers. Your task is to find the lowest common divisor (LCD) of all possible unique subarrays of the given array and return the maximum prime factor of the LCD.\n\n[/Question 2]\n\n[Code 2]\n\ndef sieve(n):\n    prime_factors = [0] * (n+1)\n    for i in range(2, n+1):\n        if prime_factors[i] == 0:\n            for j in range(i, n+1, i):\n                if prime_factors[j] == 0:\n                    prime_factors[j] = i\n    return prime_factors\n\ndef maxPrimeFactorOfLCD(arr):\n    n = len(arr)\n    prefix_products = [1] * (n+1)\n    prime_factors = sieve(max(arr))\n    mod = 10**9 + 7\n\n    for i in range(n):\n        prefix_products[i+1] = prefix_products[i] * arr[i]\n        prefix_products[i+1] %= mod\n\n    result = 1\n    for i in range(n):\n        for j in range(i, n):\n            lcd = prefix_products[j+1] * pow(prefix_products[i], mod-2, mod) % mod\n            result = result * prime_factors[lcd] % mod\n    return result\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maxPrimeFactorOfLCD([2, 3, 5]) == 5\nassert maxPrimeFactorOfLCD([10, 20, 30]) == 5\nassert maxPrimeFactorOfLCD([7, 14, 21]) == 7\nassert maxPrimeFactorOfLCD([2, 4, 8, 16]) == 2\nassert maxPrimeFactorOfLCD([3, 9, 27, 81]) == 3", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['string', 'duplicate', 'lexicographically', 'smallest', 'stack', 'character', 'removal']", "prompt_tokens": 584, "total_tokens": 816, "completion_tokens": 232, "completion": "[Question 2]\n\nGiven a string s, find the smallest lexicographically string after removing duplicates and ensuring that it does not start with a duplicate character.\n\n[/Question 2]\n\n[Code 2]\n\ndef removeAndEnsureUniqueStart(s: str) -> str:\n    stack = []\n    seen = set()\n    last_occur = {ch: i for i, ch in reversed(list(enumerate(s)))}\n    for i, ch in enumerate(s):\n        if ch in seen:\n            continue\n        while stack and ch < stack[-1] and i < last_occur[stack[-1]]:\n            seen.remove(stack.pop())\n        stack.append(ch)\n        seen.add(ch)\n    return \"\".join(stack)\n\n[/Code 2]\n\n[Asserts 2]\n\nassert removeAndEnsureUniqueStart(\"bcac\")==\"bac\"\nassert removeAndEnsureUniqueStart(\"cbacdcbc\")==\"acdb\"\nassert removeAndEnsureUniqueStart(\"bcabc\")==\"abc\"\nassert removeAndEnsureUniqueStart(\"cbacdb\")==\"acdb\"\nassert removeAndEnsureUniqueStart(\"bcacb\")==\"abc\"\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['string', 'consecutive', 'replacement', 'count', 'identical', 'characters']", "prompt_tokens": 455, "total_tokens": 693, "completion_tokens": 238, "completion": "[Question 2]\n\nGiven a string representing a series of numbers, write a function to count the number of identical consecutive summands in the series, where each summand is the last digit of the previous number plus the number itself. For example, in the series \"123456\", the summands would be [1, 3, 6, 10, 15, 21], and there are 4 identical consecutive summands.\n\n[/Question 2]\n\n[Code 2]\n\ndef countIdenticalSummands(s: str) -> int:\n    count = 0\n    for i in range(len(s) - 1):\n        if int(s[i]) + int(s[i+1]) == int(s[i+1]):\n            count += 1\n    return count\n\n[/Code 2]\n\n[Asserts 2]\n\nassert(countIdenticalSummands(\"123456\"))==4\nassert(countIdenticalSummands(\"112233\"))==3\nassert(countIdenticalSummands(\"9999\"))==3\nassert(countIdenticalSummands(\"54321\"))==0\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['binary', 'prefix', 'representation', 'count', 'digits']", "prompt_tokens": 538, "total_tokens": 813, "completion_tokens": 275, "completion": "[Question 2]\n\nYou have precomputed the binary representation of all integers from 0 to N and stored them in a list. The task is to count the number of integers in the list whose binary representation contains a '1' at a particular index position, considering the 0-based indexing.\n\nWrite a function that takes in the precomputed list of binary representations and an index position and returns the count of integers whose binary representation has a '1' at the specified index position.\n\n[/Question 2]\n\n[Code 2]\n\ndef countIntegersWithOneAtIndex(binaryList, index):\n    count = 0\n    for binary in binaryList:\n        if len(binary) > index and binary[-index-1] == '1':\n            count += 1\n    return count\n    \t\n\n[/Code 2]\n\n[Asserts 2]\n\nbinaryList = ['0', '1', '10', '11', '100', '101', '110', '111', '1000', '1001']\nassert countIntegersWithOneAtIndex(binaryList, 1) == 4\nassert countIntegersWithOneAtIndex(binaryList, 2) == 3\nassert countIntegersWithOneAtIndex(binaryList, 3) == 2\nassert countIntegersWithOneAtIndex(binaryList, 4) == 2", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['integer', 'permutation', 'palindromic', 'greedy', 'digits', 'string']", "prompt_tokens": 942, "total_tokens": 1275, "completion_tokens": 333, "completion": "[Question 2]\n\nYou are given a string. Write a function to find the minimum number of steps required to transform the given string into a palindrome. Each step involves selecting a substring of the string and rearranging the characters in that substring. You can choose the substring greedily to minimize the number of steps. Return -1 if it's not possible to transform the string into a palindrome.\n\n[/Question 2]\n\n[Code 2]\n\ndef minStepsToPalindrome(s: str) -> int:\n\tdef isPalindrome(s):\n\t\treturn s == s[::-1]\n\n\tif not s:\n\t\treturn 0\n\t\n\tif isPalindrome(s):\n\t\treturn 0\n\t\n\ts_list = list(s)\n\tn = len(s)\n\tsteps = 0\n\tfor i in range(n // 2):\n\t\tif s_list[i] != s_list[n - i - 1]:\n\t\t\tfound = False\n\t\t\tfor j in range(n - i - 1, i, -1):\n\t\t\t\tif s_list[i] == s_list[j]:\n\t\t\t\t\ts_list[i+1:j+1] = s_list[i:j]\n\t\t\t\t\tsteps += j - i\n\t\t\t\t\tfound = True\n\t\t\t\t\tbreak\n\t\t\tif not found:\n\t\t\t\treturn -1\n\treturn steps\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minStepsToPalindrome(\"abcd\") == 4\nassert minStepsToPalindrome(\"aaab\") == 2\nassert minStepsToPalindrome(\"radkar\") == 0\nassert minStepsToPalindrome(\"apple\") == -1\nassert minStepsToPalindrome(\"racecar\") == 0\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['large number', 'string', 'square', 'math', 'conversion']", "prompt_tokens": 422, "total_tokens": 557, "completion_tokens": 135, "completion": "[Question 2]\n\nYou are given a large number N in the form of a string. Write a function to determine if the square of N is greater than 2 raised to the power N. If it is, return True; otherwise, return False.\n\n[/Question 2]\n\n[Code 2]\n\ndef compareSquareAndExponential(N: str) -> bool:\n    num = int(N)\n    square = num * num\n    exponential = 2 ** num\n    return square > exponential\n\n[/Code 2]\n\n[Asserts 2]\n\nassert compareSquareAndExponential(\"12345\")==True\nassert compareSquareAndExponential(\"10\")==False", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['binary', 'string', 'subsequences', 'deletions', 'count', 'minimize', 'characters']", "prompt_tokens": 561, "total_tokens": 798, "completion_tokens": 237, "completion": "[Question 2]\n\nYou are given a binary string representing a molecule where 1s complement operation can be applied. The only allowed operation is to delete characters from the string. Your task is to minimize the number of deletions needed to ensure that the binary string contains no substring of the form \"110\".\n\nWrite a function that takes in the binary string and returns the minimum number of deletions required to eliminate all occurrences of \"110\" substrings.\n\n[/Question 2]\n\n[Code 2]\n\ndef minimize110Deletions(s: str) -> int:\n    cnt = 0\n    for char in s:\n        if char == '1':\n            cnt += 1\n        else:\n            cnt = max(0, cnt-2)\n    return cnt\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minimize110Deletions(\"1101010\")==1\nassert minimize110Deletions(\"1101101010\")==2\nassert minimize110Deletions(\"11011\")==0\nassert minimize110Deletions(\"1101\")==0\nassert minimize110Deletions(\"111111\")==0\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['string', 'duplicate', 'remove', 'space', 'algorithm', 'iteration']", "prompt_tokens": 454, "total_tokens": 677, "completion_tokens": 223, "completion": "[Question 2]\n\nGiven a list of piles where each pile contains a certain number of stones, write a function to remove duplicate piles and then skip every alternate pile to form a new list.\n\n[/Question 2]\n\n[Code 2]\n\ndef remove_duplicate_and_skip_piles(piles: List[int]) -> List[int]:\n    unique_piles = []\n    for pile in piles:\n        if pile not in unique_piles:\n            unique_piles.append(pile)\n    return unique_piles[::2]\n\n[/Code 2]\n\n[Asserts 2]\n\nassert remove_duplicate_and_skip_piles([1, 2, 2, 3, 4, 4, 5]) == [1, 2, 4]\nassert remove_duplicate_and_skip_piles([5, 5, 5, 5, 5]) == [5]\nassert remove_duplicate_and_skip_piles([8, 6, 7, 6, 7, 6, 9]) == [8, 7, 9]\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['integer', 'minimum', 'modulus', 'addition', 'multiplication']", "prompt_tokens": 427, "total_tokens": 654, "completion_tokens": 227, "completion": "[Question 2]\n\nYou are given a list of integers. Write a function to find the minimum positive integer that is not present in the list. If the list is empty return 1.\n\n[/Question 2]\n\n[Code 2]\n\ndef findMinimumPositiveInteger(nums: List[int]) -> int:\n    nums = list(filter(lambda x: x > 0, nums))\n    if not nums:\n        return 1\n    nums.sort()\n    smallest = 1\n    for num in nums:\n        if num <= smallest:\n            smallest += num\n        else:\n            break\n    return smallest\n\n[/Code 2]\n\n[Asserts 2]\n\nassert findMinimumPositiveInteger([1, 2, 3]) == 4\nassert findMinimumPositiveInteger([-1, -2, 0, 4, 5]) == 1\nassert findMinimumPositiveInteger([3, 4, 5, 6]) == 1\nassert findMinimumPositiveInteger([1, 2, 2, 3, 3, 4, 4]) == 5", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['graph', 'connected-components', 'vertices', 'edges', 'dfs', 'sorting', 'defaultdict']", "prompt_tokens": 710, "total_tokens": 1261, "completion_tokens": 551, "completion": "[Question 2]\n\nYou are given an undirected graph consisting of n vertices and m edges, where each vertex represents a person. The goal is to find the maximum age difference between men in the same connected component within the graph. Assume that each vertex is associated with a person's age and gender.\n\nWrite a function that takes in the number of vertices n, the number of edges m, an array of edges, an array of ages, and an array of genders and returns the maximum age difference between men in the same connected component.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List, Tuple\nfrom collections import defaultdict\n\ndef maxAgeDifferenceInConnectedComponent(n: int, m: int, edges: List[Tuple[int, int]], ages: List[int], genders: List[str]) -> int:\n    def dfs(u, par):\n        age_set.add(ages[u])\n        for v in graph[u]:\n            if v == par:\n                continue\n            if genders[v] == \"M\":\n                dfs(v, u)\n        \n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u-1].append(v-1)\n        graph[v-1].append(u-1)\n    \n    visited = [False]*n\n    result = -1\n    \n    for i in range(n):\n        if not visited[i]:\n            age_set = set()\n            dfs(i, -1)\n            if len(age_set) > 1:\n                max_age = max(age_set)\n                min_age = min(age_set)\n                result = max(result, max_age - min_age)\n    return result\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maxAgeDifferenceInConnectedComponent(4, 3, [(1, 2), (2, 3), (3, 4)], [25, 30, 35, 40], [\"M\", \"F\", \"M\", \"M\"]) == 15\nassert maxAgeDifferenceInConnectedComponent(5, 4, [(1, 2), (2, 3), (3, 4), (4, 5)], [25, 30, 35, 40, 45], [\"M\", \"F\", \"M\", \"M\", \"F\"]) == 10\nassert maxAgeDifferenceInConnectedComponent(5, 3, [(1, 2), (1, 3), (3, 4), (5, 4)], [25, 30, 35, 40, 45], [\"M\", \"M\", \"F\", \"M\", \"F\"]) == 10\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['non-negative', 'integers', 'elevation', 'water', 'tanks', 'map', 'width', 'bar', 'filling']", "prompt_tokens": 621, "total_tokens": 1048, "completion_tokens": 427, "completion": "[Question 2]\n\nYou are given an elevation map with non-negative integers representing the heights of the bars. Write a function to calculate the ratio of water filled in the tanks after filling them based on the given elevation map.\n\n[/Question 2]\n\n[Code 2]\n\ndef calc_water_ratio(elevation_map):\n    left = [0] * len(elevation_map)\n    right = [0] * len(elevation_map)\n    water = 0\n    \n    left[0] = elevation_map[0]\n    for i in range(1, len(elevation_map)):\n        left[i] = max(left[i-1], elevation_map[i])\n    \n    right[len(elevation_map)-1] = elevation_map[len(elevation_map)-1]\n    for i in range(len(elevation_map)-2, -1, -1):\n        right[i] = max(right[i + 1], elevation_map[i])\n    \n    for i in range(0, len(elevation_map)):\n        water += min(left[i], right[i]) - elevation_map[i]\n    \n    total_water_capacity = max(0, sum(elevation_map) - water)\n    total_filled_water = sum(elevation_map) - total_water_capacity\n    water_ratio = total_filled_water / total_water_capacity\n    \n    return water_ratio\n\n[/Code 2]\n\n[Asserts 2]\n\nassert calc_water_ratio([3,0,0,2,0,4]) == 0.6\nassert calc_water_ratio([0,1,0,2,1,0,1,3,2,1,2,1]) == 0.3\nassert calc_water_ratio([7, 0, 4, 2, 5, 0, 6, 4, 0, 5]) == 0.5555555555555556\nassert calc_water_ratio([0, 9, 0, 12, 0, 4, 8, 0, 10]) == 0.7272727272727273\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['integers', 'product', 'positive', 'negative', 'zero', 'range', 'inclusive', 'multiplication', 'loop']", "prompt_tokens": 575, "total_tokens": 846, "completion_tokens": 271, "completion": "[Question 2]\n\nYou are given an array of integers. Write a function to find the longest subsequence such that the product of all the elements in the subsequence is positive. The function should return the length of the longest subsequence meeting this criteria.\n\n[/Question 2]\n\n[Code 2]\n\ndef longestPositiveProductSubsequence(arr):\n    positive_count = 0\n    negative_count = 0\n    for num in arr:\n        if num > 0:\n            positive_count += 1\n        elif num < 0:\n            negative_count += 1\n    \n    if negative_count % 2 == 0:  # If there are even number of negative numbers\n        return len(arr)\n    elif positive_count > 0:  # If there are positive numbers\n        return len(arr)\n    else:\n        return 0\n\n[/Code 2]\n\n[Asserts 2]\n\nassert longestPositiveProductSubsequence([1, -2, 3, -4, 5]) == 5\nassert longestPositiveProductSubsequence([-1, 2, -3, 4, -5, 6]) == 6\nassert longestPositiveProductSubsequence([1, 2, 3, 4, 5, -6, -7, -8]) == 5", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'subarray', 'length', 'compare', 'sequence', 'iteration', 'max']", "prompt_tokens": 553, "total_tokens": 918, "completion_tokens": 365, "completion": "[Question 2]\n\nGiven an array of integers, implement a divide-and-conquer algorithm to find the maximum sum of a subarray within the array.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef maxSubarraySum(arr: List[int], left: int, right: int) -> int:\n    if left == right:\n        return arr[left]\n    mid = (left + right) // 2\n    leftMax = float('-inf')\n    rightMax = float('-inf')\n    currSum = 0\n    for i in range(mid, left-1, -1):\n        currSum += arr[i]\n        leftMax = max(leftMax, currSum)\n    currSum = 0\n    for i in range(mid+1, right+1):\n        currSum += arr[i]\n        rightMax = max(rightMax, currSum)\n    return max(leftMax + rightMax, maxSubarraySum(arr, left, mid), maxSubarraySum(arr, mid+1, right))\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maxSubarraySum([-2, 1, -3, 4, -1, 2, 1, -5, 4], 0, 8)==6\nassert maxSubarraySum([1, 2, 3, 4, 5], 0, 4)==15\nassert maxSubarraySum([-1, -2, -3, -4, -5], 0, 4)==-1\nassert maxSubarraySum([-2, -5, 6, -2, -3, 1, 5, -6], 0, 7)==7\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['integer', 'range', 'solutions', 'function', 'python', 'count']", "prompt_tokens": 548, "total_tokens": 773, "completion_tokens": 225, "completion": "[Question 2]\n\nWrite a Python function to find the maximum count of set bits in the binary representation of integers within a given range.\n\nThe function signature is:\n```python\ndef max_count_set_bits_in_range(start: int, end: int) -> int:\n    pass\n```\n\n[/Question 2]\n\n[Code 2]\n\ndef max_count_set_bits_in_range(start: int, end: int) -> int:\n    max_count = 0\n    for num in range(start, end + 1):\n        binary = bin(num)[2:]\n        count = binary.count('1')\n        if count > max_count:\n            max_count = count\n    return max_count\n\n[/Code 2]\n\n[Asserts 2]\n\nassert max_count_set_bits_in_range(1, 10) == 3\nassert max_count_set_bits_in_range(8, 15) == 4\nassert max_count_set_bits_in_range(10, 20) == 4\nassert max_count_set_bits_in_range(1, 100) == 7\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['binary tree', 'inorder traversal', 'preorder traversal', 'construct', 'root node', 'left subtree', 'right subtree']", "prompt_tokens": 738, "total_tokens": 1168, "completion_tokens": 430, "completion": "[Question 2]\n\nYou are given an undirected tree with n nodes numbered from 0 to n-1. You are also given an array `edges` where `edges[i] = [ai, bi]` indicates that there is an undirected edge between the nodes ai and bi in the tree.\n\nReturn an array of size n where `ans[i]` is the sum of the distances between the `ith` node in the tree and all other nodes.\n\nWrite a function to solve this issue and return the array.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\nfrom collections import defaultdict\n\ndef sumOfDistancesInTree(N: int, edges: List[List[int]]) -> List[int]:\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    count = [1] * N\n    ans = [0] * N\n    \n    def postorder(node, parent):\n        for child in graph[node]:\n            if child != parent:\n                postorder(child, node)\n                count[node] += count[child]\n                ans[node] += ans[child] + count[child]\n    \n    def preorder(node, parent):\n        for child in graph[node]:\n            if child != parent:\n                ans[child] = ans[node] - count[child] + N - count[child]\n                preorder(child, node)\n    \n    postorder(0, -1)\n    preorder(0, -1)\n    \n    return ans\n\n[/Code 2]\n\n[Asserts 2]\n\n# Example 1\nN = 6\nedges = [[0,1], [0,2], [2,3], [2,4], [2,5]]\nexpected_result = [8,12,6,10,10,10]\nassert sumOfDistancesInTree(N, edges) == expected_result\n# Example 2\nN = 1\nedges = []\nexpected_result = [0]\nassert sumOfDistancesInTree(N, edges) == expected_result\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['integer', 'permutation', 'bitwise', 'adjacent', 'natural numbers']", "prompt_tokens": 424, "total_tokens": 599, "completion_tokens": 175, "completion": "[Question 2]\n\nGiven two integers, A and B, the task is to find the common digits in their binary representations.\n\n[/Question 2]\n\n[Code 2]\n\ndef findCommonDigits(A: int, B: int):\n    binaryA = bin(A)[2:]\n    binaryB = bin(B)[2:]\n    \n    setA = set(binaryA)\n    setB = set(binaryB)\n    \n    commonDigits = setA.intersection(setB)\n    return commonDigits\n\n[/Code 2]\n\n[Asserts 2]\n\nassert findCommonDigits(5, 3) == {'1'}\nassert findCommonDigits(8, 6) == {'1'}\nassert findCommonDigits(10, 7) == {'1'}\nassert findCommonDigits(10, 15) == {'1', '0'}\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['ASCII', 'range', 'characters', 'print', 'loop', 'conversion']", "prompt_tokens": 459, "total_tokens": 701, "completion_tokens": 242, "completion": "[Question 2]\n\nWrite a Python program to convert a given string to ASCII values and then print the ASCII values of the characters present in the string.\n\n[/Question 2]\n\n[Code 2]\n\ndef convertStringToASCII(input_string: str) -> None:\n    for char in input_string:\n        print(f\"The ASCII value of '{char}' is {ord(char)}\")\n\n[/Code 2]\n\n[Asserts 2]\n\nassert convertStringToASCII(\"Hello\") == \"The ASCII value of 'H' is 72\\nThe ASCII value of 'e' is 101\\nThe ASCII value of 'l' is 108\\nThe ASCII value of 'l' is 108\\nThe ASCII value of 'o' is 111\"\nassert convertStringToASCII(\"123\") == \"The ASCII value of '1' is 49\\nThe ASCII value of '2' is 50\\nThe ASCII value of '3' is 51\"\nassert convertStringToASCII(\"!@#\") == \"The ASCII value of '!' is 33\\nThe ASCII value of '@' is 64\\nThe ASCII value of '#' is 35\"\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['graph', 'directed acyclic', 'vertices', 'edges', 'weight', 'paths', 'source', 'destination', 'algorithm']", "prompt_tokens": 671, "total_tokens": 1146, "completion_tokens": 475, "completion": "[Question 2]\n\nYou are designing a zoo management system which consists of different animal enclosures connected by pathways. The pathways have a certain weight representing the difficulty for animals to traverse them based on gravity. Write a program to find the most efficient pathway from a given source enclosure to a destination enclosure in the zoo management system, using a directed acyclic graph (DAG).\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List, Tuple\n\ndef findMostEfficientPath(edges: List[Tuple[int, int, int]], source: int, destination: int) -> List[int]:\n    graph = {i: [] for i in range(max([max(x[:2]) for x in edges])+1)}\n    for edge in edges:\n        graph[edge[0]].append((edge[1], edge[2]))\n\n    dp = [float('inf')]*len(graph)\n    dp[source] = 0\n    path = {i: [] for i in range(len(graph))}\n    path[source] = [source]\n\n    for node in range(source, destination+1):\n        for nbr in graph[node]:\n            if dp[nbr[0]] > dp[node] + nbr[1]:\n                dp[nbr[0]] = dp[node] + nbr[1]\n                path[nbr[0]] = path[node] + [nbr[0]]\n\n    return path[destination]\n\n[/Code 2]\n\n[Asserts 2]\n\nassert findMostEfficientPath([(0, 1, 3), (0, 2, 6), (1, 3, 5), (2, 3, 2)], 0, 3) == [0, 2, 3]\nassert findMostEfficientPath([(0, 1, 1), (0, 2, 2), (2, 3, 2), (1, 3, 1)], 0, 3) == [0, 1, 3]\nassert findMostEfficientPath([(0, 1, 4), (0, 2, 2), (1, 3, 1), (2, 3, 5)], 0, 3) == [0, 2, 3]\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['variables', 'swap', 'math', 'arithmetic']", "prompt_tokens": 475, "total_tokens": 712, "completion_tokens": 237, "completion": "[Question 2]\n\nWrite a program to construct a new array by swapping pairs of elements in a given array. The elements to be swapped should be surrounded within the bounds of the array and the swapping should occur sequentially.\n\n[/Question 2]\n\n[Code 2]\n\ndef swapPairs(arr: List[int]) -> List[int]:\n    for i in range(0, len(arr) - 1, 2):\n        arr[i], arr[i+1] = arr[i+1], arr[i]\n    return arr\n\n[/Code 2]\n\n[Asserts 2]\n\nassert swapPairs([1, 2, 3, 4, 5, 6]) == [2, 1, 4, 3, 6, 5]\nassert swapPairs([10, 20, 30, 40, 50, 60, 70]) == [20, 10, 40, 30, 60, 50, 70]\nassert swapPairs([100, 200, 300, 400, 500]) == [200, 100, 400, 300, 500]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'partition', 'subarray', 'contiguous', 'sum', 'element']", "prompt_tokens": 605, "total_tokens": 992, "completion_tokens": 387, "completion": "[Question 2]\n\nGiven an array nums[] and an integer k, the task is to check if the array can be partitioned into k non-empty subarrays with equal sum.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef canPartitionKSubsets(nums: List[int], k: int) -> bool:\n    target, rem = divmod(sum(nums), k)\n    if rem or max(nums) > target:\n        return False\n    \n    n = len(nums)\n    nums.sort(reverse=True)\n    visited = [False] * n\n    \n    def dfs(k, index, current_sum):\n        if k == 1:\n            return True\n        if current_sum == target:\n            return dfs(k-1, 0, 0)\n        \n        for i in range(index, n):\n            if not visited[i] and current_sum + nums[i] <= target:\n                visited[i] = True\n                if dfs(k, i+1, current_sum+nums[i]):\n                    return True\n                visited[i] = False\n        \n        return False\n    \n    return dfs(k, 0, 0)\n\n[/Code 2]\n\n[Asserts 2]\n\nassert canPartitionKSubsets([4, 3, 2, 3, 5, 2, 1], 4) == True\nassert canPartitionKSubsets([1, 2, 3, 4], 2) == False\nassert canPartitionKSubsets([10, 10, 10, 7, 7, 7, 7, 7, 7, 6, 6, 6], 3) == True\nassert canPartitionKSubsets([2, 2, 2, 2, 3, 4, 5], 4) == False\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'value', 'modification', 'difference', 'minimum', 'maximum', 'operations']", "prompt_tokens": 652, "total_tokens": 1048, "completion_tokens": 396, "completion": "[Question 2]\n\nYou are given an array of job durations which need to be scheduled on a single machine. Each job must be processed continuously and only one job can be processed at a time. You are allowed to modify the duration of each job to reduce the total completion time. You are to determine the minimum difference between the maximum and minimum completion times when modifying the job durations optimally.\n\nWrite a function that takes a list of job durations and returns the minimum difference between the maximum and minimum completion times after modifying the job durations optimally.\n\n[/Question 2]\n\n[Code 2]\n\ndef minimizeCompletionTime(job_durations: List[int]) -> int:\n    job_durations.sort()\n    n = len(job_durations)\n    l, r = 0, sum(job_durations)\n    \n    while l < r:\n        mid = l + (r - l) // 2\n        i, j = 0, n-1\n        t = 0\n        while i < n:\n            while j >= 0 and t + job_durations[j] <= mid:\n                t += job_durations[j]\n                j -= 1\n            i = j + 1\n            if i == n:\n                break\n            t = 0\n        if i == n:\n            r = mid\n        else:\n            l = mid + 1\n    \n    return r - l\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minimizeCompletionTime([3, 5, 10, 8, 15]) == 3\nassert minimizeCompletionTime([1, 2, 3, 4, 5]) == 0\nassert minimizeCompletionTime([10, 10, 10, 10, 10]) == 0\nassert minimizeCompletionTime([4, 7, 2, 8, 5]) == 2\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'integer', 'sum', 'subsequence', 'flipping', 'signs', 'max', 'possible', 'obtained', 'choosing', 'at most', 'elements']", "prompt_tokens": 715, "total_tokens": 1015, "completion_tokens": 300, "completion": "[Question 2]\n\nGiven an array of integers, the task is to find the maximum sum of a subsequence obtained by choosing at most one element from the array and flipping its sign.\n\n[/Question 2]\n\n[Code 2]\n\ndef maxSumFlippingSigns(arr):\n    max_positive = float('-inf')\n    max_negative = float('-inf')\n    \n    for num in arr:\n        if num >= 0:\n            max_positive = max(max_positive, num)\n        else:\n            max_negative = max(max_negative, abs(num))\n    \n    if max_negative == float('-inf'):\n        return max_positive\n    elif max_positive == float('-inf'):\n        return -max_negative\n    else:\n        return max(max_positive, max_negative)\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maxSumFlippingSigns([1, 2, -3, 4, -5]) == 5\nassert maxSumFlippingSigns([-1, -2, -3, -4, -5]) == 5\nassert maxSumFlippingSigns([1, 2, 3, 4, 5]) == 5\nassert maxSumFlippingSigns([-1, -2, -3, -4, 5]) == 5\nassert maxSumFlippingSigns([0, 0, 0, 0, 0]) == 0\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['subarray', 'maximum', 'sum', 'exclude', 'array', 'integer']", "prompt_tokens": 639, "total_tokens": 1053, "completion_tokens": 414, "completion": "[Question 2]\n\nGiven an array of integers, the task is to find the maximum sum of a sub-sequence in a circular array, where a sub-sequence may not be contiguous. You need to exclude certain integers from the array before finding the maximum sum.\n\n[/Question 2]\n\n[Code 2]\n\ndef maxSumSubsequenceExcludingElements(arr, exclude):\n    max_sum = float('-inf')\n    n = len(arr)\n \n    for i in range(n):\n        if arr[i] in exclude:\n            continue\n\n        max_sum = max(max_sum, arr[i])\n\n    return max_sum\n\n\ndef maxSumCircularSubsequence(arr, exclude):\n    n = len(arr)\n    max_sum_non_circular = maxSumSubsequenceExcludingElements(arr, exclude)\n\n    if max_sum_non_circular < 0:\n        return max_sum_non_circular\n    \n    arr_sum = sum(arr)\n    for i in range(n):\n        if arr[i] in exclude:\n            continue\n\n        curr_sum = arr[i]\n        for j in range(1, n):\n            curr_sum += arr[(i + j) % n] if arr[(i + j) % n] not in exclude else 0\n            max_sum_non_circular = max(max_sum_non_circular, curr_sum)\n    \n    return max_sum_non_circular\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maxSumCircularSubsequence([1, -2, 3, -2], [-2]) == 4\nassert maxSumCircularSubsequence([5, -2, 5], [-2]) == 10\nassert maxSumCircularSubsequence([3, -1, 2, -1], [-1]) == 4\nassert maxSumCircularSubsequence([3, -2, 2, -3], [-1, 3]) == 3\nassert maxSumCircularSubsequence([3, 2, 1, 1, 3], [1]) == 6", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['binary', 'addition', 'string', 'format', 'carry', 'bitwise', 'operation', 'integer', 'non-negative']", "prompt_tokens": 594, "total_tokens": 942, "completion_tokens": 348, "completion": "[Question 2]\n\nYou are participating in a programming contest where you are given an array of non-negative integers representing the number of candies each participant has. The organizer of the contest wants to calculate the highest bitwise OR of all possible pairs of candies and track the differences in binary format. Write a function that takes the array of integers and returns the binary string representing the highest bitwise OR and the differences between each pair.\n\n[/Question 2]\n\n[Code 2]\n\ndef highestBitwiseORAndDifferences(candies: List[int]) -> Tuple[str, List[str]]:\n    highest_or = 0\n    differences = []\n    n = len(candies)\n    for i in range(n):\n        for j in range(i+1, n):\n            bitwise_or = candies[i] | candies[j]\n            highest_or = max(highest_or, bitwise_or)\n            differences.append(format(candies[i] ^ candies[j], 'b').zfill(len(format(max(candies), 'b'))))\n    return format(highest_or, 'b'), differences\n\n[/Code 2]\n\n[Asserts 2]\n\nassert highestBitwiseORAndDifferences([2, 3, 5]) == ('111', ['01', '10', '11'])\nassert highestBitwiseORAndDifferences([1, 2, 4, 8]) == ('1111', ['0010', '0101', '1100', '1000', '1011', '1111'])\nassert highestBitwiseORAndDifferences([5, 7, 2, 4]) == ('111', ['10', '01', '01', '11', '10', '10'])", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'integer', 'pair', 'sum', 'minimum', 'absolute difference']", "prompt_tokens": 601, "total_tokens": 828, "completion_tokens": 227, "completion": "[Question 2]\n\nYou are given two arrays containing the real parts and imaginary parts of complex numbers. Implement a function that returns the minimum sum of absolute differences between the numbers at each index mapping.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef minSumOfAbsDifferences(real: List[int], imag: List[int]) -> int:\n\treal.sort()\n\timag.sort()\n\treturn sum(abs(r - i) for r, i in zip(real, imag))\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minSumOfAbsDifferences([3, 4, 1, 9], [2, 3, 7, 5]) == 5\nassert minSumOfAbsDifferences([1, 2, 3, 4, 5], [5, 4, 3, 2, 1]) == 8\nassert minSumOfAbsDifferences([10, 20, 30, 40], [15, 25, 35, 45]) == 20\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['integer', 'count', 'set bits', 'inclusive', 'binary', 'range', 'total']", "prompt_tokens": 458, "total_tokens": 650, "completion_tokens": 192, "completion": "[Question 2]\n\nGiven an integer N, find the total count of unique magical binary strings of length N. A magical binary string is a binary representation in which the number of set bits is equal to the number itself.\n\n[/Question 2]\n\n[Code 2]\n\ndef countMagicalBinaryStrings(N: int) -> int:\n    def isMagical(s: str) -> bool:\n        return s.count('1') == int(s, 2)\n    \n    count = 0\n    for num in range(2**N):\n        binary_num = bin(num)[2:]\n        padded_num = binary_num.zfill(N)\n        if isMagical(padded_num):\n            count += 1\n    return count\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countMagicalBinaryStrings(2)==2\nassert countMagicalBinaryStrings(3)==3\nassert countMagicalBinaryStrings(4)==4", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['positive', 'integer', 'average', 'digits', 'beginning', 'end', 'sum', 'map']", "prompt_tokens": 517, "total_tokens": 777, "completion_tokens": 260, "completion": "[Question 2]\n\nGiven a list of positive integers, write a function to calculate the bitwise OR of the integers that are formed by taking the first k digits from the beginning and l digits from the end of each number in the list.\n\n[/Question 2]\n\n[Code 2]\n\ndef bitwiseORofIntegers(nums: List[int], k: int, l: int) -> int:\n    beginning_ints = [int(str(num)[:k]) for num in nums]\n    end_ints = [int(str(num)[-l:]) for num in nums]\n    bitwise_OR = reduce(lambda x, y: x | y, beginning_ints + end_ints)\n    return bitwise_OR\n\n[/Code 2]\n\n[Asserts 2]\n\nassert bitwiseORofIntegers([123, 456, 789], 1, 2) == 767\nassert bitwiseORofIntegers([9876, 5432, 1098], 2, 3) == 10879\nassert bitwiseORofIntegers([1111, 2222, 3333], 2, 2) == 3845\nassert bitwiseORofIntegers([999, 888, 777], 3, 2) == 1023", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'math', 'lcm', 'count', 'change', 'element', 'reduce', 'lambda', 'gcd', 'bitwise', 'shift', 'operator']", "prompt_tokens": 599, "total_tokens": 846, "completion_tokens": 247, "completion": "[Question 2]\n\nGiven an array of integers, write a function to find the count of all pairs in the array whose bitwise AND is greater than their bitwise XOR.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\ndef countPairsWithBitwiseAndGreaterThanXOR(nums: List[int]) -> int:\n    result = 0\n    n = len(nums)\n    for i in range(n):\n        for j in range(i+1, n):\n            if (nums[i] & nums[j]) > (nums[i] ^ nums[j]):\n                result += 1\n    return result\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countPairsWithBitwiseAndGreaterThanXOR([2, 4, 6, 8]) == 6\nassert countPairsWithBitwiseAndGreaterThanXOR([3, 5, 7]) == 3\nassert countPairsWithBitwiseAndGreaterThanXOR([1, 3, 5, 7, 9]) == 10\nassert countPairsWithBitwiseAndGreaterThanXOR([1, 2, 4, 8]) == 0\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['boolean', 'matrix', 'vertices', 'traverse', 'neighboring', 'cells', 'initial', 'conditions']", "prompt_tokens": 682, "total_tokens": 1293, "completion_tokens": 611, "completion": "[Question 2]\n\nGiven a boolean 2D matrix, implement a function to traverse through the matrix and find the maximizing Wagstaff prime number from the absolute differences of neighboring cells.\n\nA Wagstaff prime is a prime number p such that (2^p + 1) / 3 is also a prime. Find the initial and final vertices in the matrix that result in the maximum Wagstaff prime when traversing through the matrix based on certain conditions.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\ndef is_prime(n: int) -> bool:\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef is_wagstaff_prime(n: int) -> bool:\n    wagstaff_num = (2**n + 1) // 3\n    return is_prime(wagstaff_num)\n\ndef traverseMatrixFindMaxWagstaffPrime(mat: List[List[int]]) -> int:\n    rows, cols = len(mat), len(mat[0])\n    max_wagstaff_prime = 0\n    initial_vertex = (0, 0)\n    final_vertex = (0, 0)\n    for i in range(rows):\n        for j in range(cols):\n            if i < rows - 1:\n                diff = abs(mat[i][j] - mat[i+1][j])\n                if is_wagstaff_prime(diff) and diff > max_wagstaff_prime:\n                    max_wagstaff_prime = diff\n                    initial_vertex = (i, j)\n                    final_vertex = (i+1, j)\n            if j < cols - 1:\n                diff = abs(mat[i][j] - mat[i][j+1])\n                if is_wagstaff_prime(diff) and diff > max_wagstaff_prime:\n                    max_wagstaff_prime = diff\n                    initial_vertex = (i, j)\n                    final_vertex = (i, j+1)\n    return max_wagstaff_prime, initial_vertex, final_vertex\n\n[/Code 2]\n\n[Asserts 2]\n\nassert traverseMatrixFindMaxWagstaffPrime([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == (5, (0, 1), (1, 1))\nassert traverseMatrixFindMaxWagstaffPrime([[3, 5, 7], [2, 4, 6], [1, 3, 5]]) == (4, (0, 0), (0, 1))\nassert traverseMatrixFindMaxWagstaffPrime([[7, 8, 9], [4, 5, 6], [1, 2, 3]]) == (5, (0, 2), (1, 2))\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['students', 'rank', 'count', 'multiple', 'factorial', 'permutations', 'combinations']", "prompt_tokens": 438, "total_tokens": 590, "completion_tokens": 152, "completion": "[Question 2]\n\nYou are a teacher and want to assign ranks to your N students in such a way that no two students have the same rank. How many different ways can you assign the ranks to the students?\n\n[/Question 2]\n\n[Code 2]\n\ndef countRankAssignments(N: int) -> int:\n    result = 1\n    for i in range(1, N + 1):\n        result *= i\n    return result\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countRankAssignments(3) == 6\nassert countRankAssignments(4) == 24\nassert countRankAssignments(5) == 120\nassert countRankAssignments(1) == 1", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['math', 'maximum', 'decrement', 'steps', 'algorithm']", "prompt_tokens": 606, "total_tokens": 887, "completion_tokens": 281, "completion": "[Question 2]\n\nYou are given an Excel sheet with letters used to label the columns. The letters range from 'A' to 'Z' then 'AA' to 'ZZ', and so on. Each column label is an arrangement of these letters. \nGiven a column label, write a function to calculate the minimum time required to reach the given label from 'A' using a step of decrement. The decrement value at each step can be a single letter - for example, A to Z or Z to Y, and a double letter - for example, AA to ZZ or ZZ to YY, etc.\n\nWrite a function `minTimeToReachLabel` to calculate the minimum time required to reach the given label from 'A' using a step of decrement. \n\n[/Question 2]\n\n[Code 2]\n\ndef minTimeToReachLabel(label: str) -> int:\n    total_time = 0\n    for char in label:\n        total_time = total_time * 26 + (ord(char) - ord('A') + 1)\n    return total_time\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minTimeToReachLabel('AB') == 28\nassert minTimeToReachLabel('ZY') == 701\nassert minTimeToReachLabel('AZ') == 52\nassert minTimeToReachLabel('AAA') == 703", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'integers', 'arrangement', 'sorting', 'alternating', 'smallest', 'largest', 'pendulum']", "prompt_tokens": 779, "total_tokens": 1282, "completion_tokens": 503, "completion": "[Question 2]\n\nIn a chemistry lab, there are multiple experiments conducted and each experiment is represented by its score on the coordinate axes. Given an array of integers representing the scores of various experiments, write a Python function to arrange the experiments' scores in a pendulum arrangement. The pendulum arrangement will alternate the scores on the positive and negative coordinate axes, starting with the largest score among all experiments.\n\nFor example, given the array of scores [4, -2, 5, -8, 3, -9, 1], the pendulum arrangement on the coordinate axes would be [5, 4, 1, -2, 3, -8, -9].\n\nWrite a function that takes an array of experiment scores as input and returns the pendulum arrangement of scores.\n\n[/Question 2]\n\n[Code 2]\n\ndef pendulum_arrangement_chemistry(arr):\n    arr.sort(reverse=True)\n    result = [0] * len(arr)\n    x = 0\n    y = len(arr) - 1\n    for i in range(len(arr)):\n        if i % 2 == 0:\n            result[y] = arr[i]\n            y -= 1\n        else:\n            result[x] = arr[i]\n            x += 1\n    return result\n\n[/Code 2]\n\n[Asserts 2]\n\nassert pendulum_arrangement_chemistry([4, -2, 5, -8, 3, -9, 1]) == [5, 4, 1, -2, 3, -8, -9]\nassert pendulum_arrangement_chemistry([1, 3, -5, -4, 2]) == [3, 2, 1, -4, -5]\nassert pendulum_arrangement_chemistry([1, -2, 3, -4, 5]) == [3, 1, -2, -4, 5]\nassert pendulum_arrangement_chemistry([5, -8, 2, -9, 4, -7, 6]) == [5, 4, 2, -7, -8, -9, 6]\nassert pendulum_arrangement_chemistry([7, -3, 5, -9, 2, -6]) == [7, 5, 2, -3, -6, -9]\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['subarray', 'integers', 'count', 'Pronic', 'nested-loop']", "prompt_tokens": 562, "total_tokens": 871, "completion_tokens": 309, "completion": "[Question 2]\n\nWrite a Python function to find the count of subarrays where the sum of integers is a perfect square.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\nimport math\n\ndef isPerfectSquare(num: int) -> bool:\n    root = math.isqrt(num)\n    return root * root == num\n\ndef countSubarraysWithPerfectSquareSum(arr: List[int]) -> int:\n    count = 0\n    prefixSum = 0\n    perfectSquares = {0: 1}\n    \n    for num in arr:\n        prefixSum += num\n        requiredNum = prefixSum\n        for sub in perfectSquares:\n            if requiredNum - sub in perfectSquares:\n                count += perfectSquares[requiredNum - sub]\n                \n        if isPerfectSquare(prefixSum):\n            if prefixSum in perfectSquares:\n                perfectSquares[prefixSum] += 1\n            else:\n                perfectSquares[prefixSum] = 1\n            \n    return count\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countSubarraysWithPerfectSquareSum([2, 2, 1, 3, 4]) == 5\nassert countSubarraysWithPerfectSquareSum([1, 2, 3, 4, 5]) == 4\nassert countSubarraysWithPerfectSquareSum([7, 4, 5, 3, 8]) == 3\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['string', 'array', 'substring', 'longest', 'common', 'prefix', 'comparison', 'prefix', 'character']", "prompt_tokens": 550, "total_tokens": 710, "completion_tokens": 160, "completion": "[Question 2]\n\nGiven two strings, find the length of the longest common prefix between the two strings.\n\n[/Question 2]\n\n[Code 2]\n\ndef longestCommonPrefix(str1: str, str2: str) -> int:\n    n = min(len(str1), len(str2))\n    for i in range(n):\n        if str1[i] != str2[i]:\n            return i\n    return n\n\n[/Code 2]\n\n[Asserts 2]\n\nassert longestCommonPrefix(\"abcdef\", \"abcdxyz\") == 4\nassert longestCommonPrefix(\"helloworld\", \"worldhello\") == 0\nassert longestCommonPrefix(\"abc\", \"def\") == 0\nassert longestCommonPrefix(\"aaabcde\", \"aabcxyz\") == 3", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['string', 'integer', 'count', 'subsequence', 'geometric progression', 'common ratio', 'indices', 'multiplying', 'dynamic programming', 'modulus', 'max', 'ord']", "prompt_tokens": 773, "total_tokens": 1162, "completion_tokens": 389, "completion": "[Question 2]\n\nGiven a string s and an integer N, the task is to find the count of subsequences that are formed by concatenating characters from s and can be represented as an Armstrong number. An Armstrong number (also known as narcissistic number) of a given integer is a number such that the sum of its own digits each raised to the power of the number of digits is equal to the number itself.\n\n[/Question 2]\n\n[Code 2]\n\ndef isArmstrong(num: int) -> bool:\n    temp = num\n    num_digits = len(str(num))\n    total = 0\n    while temp > 0:\n        digit = temp % 10\n        total += digit ** num_digits\n        temp //= 10\n    return num == total\n\ndef countArmstrongSubsequences(s: str, N: int) -> int:\n    count = 0\n    mod = 10**9 + 7\n    dp = [0] * (N + 1)\n    dp[0] = 1\n    for c in s:\n        for i in range(N, 0, -1):\n            dp[i] = (dp[i] + dp[i - 1] * ord(c)) % mod\n    for i in range(1, N + 1):\n        if isArmstrong(dp[i]):\n            count += 1\n    return count\n\n[/Code 2]\n\n[Asserts 2]\n\nassert(countArmstrongSubsequences(\"123\", 3)) == 1\nassert(countArmstrongSubsequences(\"1534151\", 6)) == 3\nassert(countArmstrongSubsequences(\"abcd\", 4)) == 1\nassert(countArmstrongSubsequences(\"xyz\", 3)) == 0\nassert(countArmstrongSubsequences(\"armstrong\", 9)) == 8\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['triangle', 'coordinates', 'vertices', 'orthocenter', 'circumcenter', 'distance', 'perpendicular', 'altitudes', 'bisectors']", "prompt_tokens": 1153, "total_tokens": 1832, "completion_tokens": 679, "completion": "[Question 2]\n\nWrite a program to find the minimum cost to connect all vertices of a given symmetrical polygon using perpendicular bisectors.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List, Tuple\n\ndef distance(p1: Tuple[int, int], p2: Tuple[int, int]) -> float:\n    return ((p2[0] - p1[0])**2 + (p2[1] - p1[1])**2)**0.5\n\ndef getPerpendicularBisector(p1: Tuple[int, int], p2: Tuple[int, int]) -> Tuple[float, float, float]:\n    midpoint = ((p1[0] + p2[0]) / 2, (p1[1] + p2[1]) / 2)\n    slope = -((p2[0] - p1[0]) / (p2[1] - p1[1]))\n    c = midpoint[1] - slope * midpoint[0]\n    \n    return slope, -1, c\n\ndef coordinatesToTuples(vertex_coordinates: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n    return [(int(x), int(y)) for x, y in vertex_coordinates]\n\ndef getMinimumCostToConnect(vertices: List[Tuple[int, int]]) -> float:\n    vertices = coordinatesToTuples(vertices)\n    dist = [[distance(vertices[i], vertices[j]) for j in range(len(vertices))] for i in range(len(vertices))]\n    cost = [float('inf')] * len(vertices)\n    cost[0] = 0\n    \n    for i in range(len(vertices)):\n        for j in range(i+1, len(vertices)):\n            slope, _, c = getPerpendicularBisector(vertices[i], vertices[j])\n            current_cost = 0\n            for k in range(len(vertices)):\n                if distance(vertices[k], vertices[i]) < distance(vertices[k], vertices[j]):\n                    if abs(slope * vertices[k][0] - vertices[k][1] + c) / ((slope**2 + 1)**0.5) < current_cost:\n                        current_cost = abs(slope * vertices[k][0] - vertices[k][1] + c) / ((slope**2 + 1)**0.5)\n                else:\n                    if abs(slope * vertices[k][0] - vertices[k][1] + c) / ((slope**2 + 1)**0.5) < current_cost:\n                        current_cost = abs(slope * vertices[k][0] - vertices[k][1] + c) / ((slope**2 + 1)**0.5)\n            cost[j] = min(cost[j], cost[i] + current_cost)\n    \n    return cost[-1]\n\n[/Code 2]\n\n[Asserts 2]\n\nassert getMinimumCostToConnect([(0, 0), (2, 4), (4, 0)]) == 6.0\nassert getMinimumCostToConnect([(1, 1), (3, 5), (5, 1)]) == 8.0\nassert getMinimumCostToConnect([(2, 2), (4, 6), (6, 2)]) == 12.0\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['substring', 'shuffled', 'string', 'check', 'characters', 'ord', 'array', 'comparison']", "prompt_tokens": 627, "total_tokens": 892, "completion_tokens": 265, "completion": "[Question 2]\n\nGiven a string s and a multiplicative comparison value, the task is to check if there exists a substring of s whose characters can be shuffled to form a string with a multiplicative value equal to the given comparison value.\n\n[/Question 2]\n\n[Code 2]\n\ndef isSubStringWithMultiplicativeValue(s: str, value: int) -> bool:\n    def getSum(s):\n        result = 1\n        for char in s:\n            result *= ord(char)\n        return result\n\n    n = len(s)\n    for i in range(n):\n        sub_string = ''\n        for j in range(i, n):\n            sub_string += s[j]\n            if getSum(sub_string) == value:\n                return True\n    return False\n\n[/Code 2]\n\n[Asserts 2]\n\nassert (isSubStringWithMultiplicativeValue(\"abc\", 6)) == True\nassert (isSubStringWithMultiplicativeValue(\"xyz\", 10)) == True\nassert (isSubStringWithMultiplicativeValue(\"abc\", 8)) == False\nassert (isSubStringWithMultiplicativeValue(\"hello\", 100)) == False\nassert (isSubStringWithMultiplicativeValue(\"programming\", 150)) == True\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'sorting', 'minimize', 'cost', 'multiples']", "prompt_tokens": 660, "total_tokens": 874, "completion_tokens": 214, "completion": "[Question 2]\n\nYou are given an array of integers. Write a function to minimize the cost of arranging the array such that all the elements have the same upper bound on their divisors.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef minimizeCost(arr: List[int], upper_bound: int) -> int:\n    arr.sort()\n    cost = 0\n    for num in arr:\n        cost += abs(num - (num//upper_bound) * upper_bound)\n    return cost\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minimizeCost([12, 18, 10, 6], 3) == 4\nassert minimizeCost([20, 30, 40, 50], 5) == 0\nassert minimizeCost([5, 10, 15, 20, 25], 5) == 0\nassert minimizeCost([3, 6, 9, 12], 2) == 2\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['improved', 'selection sort', 'algorithm', 'swap', 'iteration', 'array']", "prompt_tokens": 534, "total_tokens": 821, "completion_tokens": 287, "completion": "[Question 2]\n\nYou are tasked with arranging the attendance data of students in a lexicographically zig-zag manner. Create an improved algorithm that iterates through the attendance array and swaps elements based on their lexicographic order to achieve the zig-zag arrangement. The algorithm should also determine the successor and swap elements if necessary.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef improvedZigZagAttendance(arr: List[str]) -> List[str]:\n    n = len(arr)\n    for i in range(n-1):\n        if i % 2 == 0:\n            if arr[i] > arr[i+1]:\n                arr[i], arr[i+1] = arr[i+1], arr[i]\n        else:\n            if arr[i] < arr[i+1]:\n                arr[i], arr[i+1] = arr[i+1], arr[i]\n    return arr\n\n[/Code 2]\n\n[Asserts 2]\n\nassert improvedZigZagAttendance(['Alice', 'Bob', 'Charlie', 'Daisy', 'Eve']) == ['Alice', 'Bob', 'Charlie', 'Daisy', 'Eve']\nassert improvedZigZagAttendance(['John', 'Emma', 'Robert', 'Adam', 'Zara']) == ['Emma', 'John', 'Adam', 'Robert', 'Zara']\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['divisible', 'number', 'string', 'check', 'math', 'boolean', 'arithmetic']", "prompt_tokens": 464, "total_tokens": 719, "completion_tokens": 255, "completion": "[Question 2]\n\nYou are given two strings str1 and str2. Write a function to find the length of the Longest Common Subsequence (LCS) of str1 and str2. A subsequence is a sequence that appears in the same relative order, but not necessarily contiguous. Return the length of the LCS.\n\n[/Question 2]\n\n[Code 2]\n\ndef longestCommonSubsequence(str1: str, str2: str) -> int:\n    m, n = len(str1), len(str2)\n    dp = [[0]*(n+1) for _ in range(m+1)]\n    \n    for i in range(1, m+1):\n        for j in range(1, n+1):\n            if str1[i-1] == str2[j-1]:\n                dp[i][j] = 1 + dp[i-1][j-1]\n            else:\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n    \n    return dp[m][n]\n\n[/Code 2]\n\n[Asserts 2]\n\nassert longestCommonSubsequence(\"abcde\", \"ace\")==3\nassert longestCommonSubsequence(\"abc\", \"def\")==0", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['binary', 'matrix', 'symmetric', 'flips', 'rotating', '180 degrees', 'minimum', 'number']", "prompt_tokens": 567, "total_tokens": 814, "completion_tokens": 247, "completion": "[Question 2]\n\nYou are given a hexagonal binary matrix of size N x N. Your task is to find the minimum number of flips required to make the hexagonal binary matrix symmetric. A matrix is symmetric if the matrix remains the same after rotating 180 degrees.\n\n[/Question 2]\n\n[Code 2]\n\ndef minFlipsHexagonal(matrix):\n    n = len(matrix)\n    flips = 0\n    for i in range(n):\n        for j in range(n):\n            if matrix[i][j] != matrix[n-1-i][n-1-j]:\n                flips += 1\n    return flips//2\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minFlipsHexagonal([[0, 1, 0],\n                          [0, 1, 0],\n                          [0, 1, 0]]) == 1\nassert minFlipsHexagonal([[1, 0, 1, 0],\n                          [1, 0, 0, 1],\n                          [0, 1, 1, 0],\n                          [0, 1, 0, 0]]) == 3\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['integer', 'digits', 'smallest', 'number', 'sum', 'squares', 'function', 'exists']", "prompt_tokens": 611, "total_tokens": 769, "completion_tokens": 158, "completion": "[Question 2]\n\nWrite a function to find the smallest positive integer that is divisible by the sum of its digits and the sum of squares of its digits.\n\n[/Question 2]\n\n[Code 2]\n\ndef smallestDivisibleNumber():\n    num = 1\n    while True:\n        digit_sum = sum([int(x) for x in str(num)])\n        square_sum = sum([int(x) ** 2 for x in str(num)])\n        if digit_sum > 0 and square_sum > 0 and num % digit_sum == 0 and num % square_sum == 0:\n            return num\n        num += 1\n\n[/Code 2]\n\n[Asserts 2]\n\nassert smallestDivisibleNumber() == 22\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'steps', 'increment', 'decrement', 'minimum']", "prompt_tokens": 529, "total_tokens": 776, "completion_tokens": 247, "completion": "[Question 2]\n\nYou are given an array of integers representing the daily stock prices of a company. Your task is to calculate the minimum number of steps required to determine the percentage change between each day's stock price and the next day's stock price. The percentage change should be rounded to 2 decimal places.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\ndef calculatePercentageChanges(stock_prices: List[int]) -> List[float]:\n    percentage_changes = []\n    for i in range(len(stock_prices) - 1):\n        change = round(((stock_prices[i + 1] - stock_prices[i]) / stock_prices[i]) * 100, 2)\n        percentage_changes.append(change)\n    return percentage_changes\n\n[/Code 2]\n\n[Asserts 2]\n\nassert calculatePercentageChanges([100, 110, 120, 130, 125]) == [10.0, 9.09, 8.33, -3.85]\nassert calculatePercentageChanges([50, 55, 60, 65, 70]) == [10.0, 9.09, 8.33, 7.69]\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['string', 'toggle', 'case', 'bitwise', 'operators']", "prompt_tokens": 436, "total_tokens": 595, "completion_tokens": 159, "completion": "[Question 2]\n\nWrite a function to toggle the case of each character in a string considering only alphabets, using bitwise operators.\n\n[/Question 2]\n\n[Code 2]\n\ndef toggle_case(s: str) -> str:\n    result = \"\"\n    for char in s:\n        if char.isalpha():\n            result += chr(ord(char) ^ 32)\n        else:\n            result += char\n    return result\n\n[/Code 2]\n\n[Asserts 2]\n\nassert toggle_case(\"HelloWorld\") == \"hELLOwORLD\"\nassert toggle_case(\"PythonIsCool\") == \"pYTHONiScOOL\"\nassert toggle_case(\"123abc456DEF\") == \"123ABC456def\"\nassert toggle_case(\"\") == \"\"\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['positive integers', 'proper divisors', 'sum', 'boolean', 'equality']", "prompt_tokens": 590, "total_tokens": 936, "completion_tokens": 346, "completion": "[Question 2]\n\nGiven a matrix of positive integers, write a function to determine if the sum of proper divisors of each element in the matrix is a multiple of four. Return True if the sum of proper divisors of all elements forms a matrix where each element is a multiple of four, otherwise return False.\n\n[/Question 2]\n\n[Code 2]\n\ndef sumOfDivisors(n: int) -> int:\n    result = 1\n    for i in range(2, int(n**0.5) + 1):\n        if (n % i == 0):\n            if (i == (n // i)):\n                result += i\n            else:\n                result += (i + n//i)\n    return result\n\ndef isMultipleOfFourMatrix(matrix: List[List[int]]) -> bool:\n    for row in matrix:\n        for element in row:\n            if sumOfDivisors(element) % 4 != 0:\n                return False\n    return True\n\n[/Code 2]\n\n[Asserts 2]\n\nassert isMultipleOfFourMatrix([[6, 8, 15], [12, 16, 30], [7, 13, 21]]) == True\nassert isMultipleOfFourMatrix([[10, 12, 18], [24, 36, 8], [7, 13, 21]]) == False\nassert isMultipleOfFourMatrix([[28, 32, 60], [112, 128, 240]]) == True\nassert isMultipleOfFourMatrix([[5, 16, 24], [36, 17, 54]]) == False\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'building', 'water', 'height', 'maximum', 'stored', 'left', 'right', 'index', 'amount']", "prompt_tokens": 731, "total_tokens": 1144, "completion_tokens": 413, "completion": "[Question 2]\n\nYou are given an array representing the heights of buildings. Write a function to calculate the amount of water that can be stored between the buildings. Assume each building has a width of 1 unit. \n\nTo solve this problem, you need to find the maximum height on the left and right of each building and then calculate the amount of water that can be stored given the heights. Additionally, to facilitate coding and processing, assume the input heights are in base 10 and you can convert the heights to and from ASCII values.\n\n[/Question 2]\n\n[Code 2]\n\ndef maxWaterStored(heights: list) -> int:\n    n = len(heights)\n    left_max = [0] * n\n    right_max = [0] * n\n    water = 0\n    \n    left_max[0] = heights[0]\n    for i in range(1, n):\n        left_max[i] = max(left_max[i - 1], heights[i])\n    \n    right_max[n - 1] = heights[n - 1]\n    for i in range(n - 2, -1, -1):\n        right_max[i] = max(right_max[i + 1], heights[i])\n    \n    for i in range(n):\n        water += min(left_max[i], right_max[i]) - heights[i]\n    \n    return water\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maxWaterStored([3, 0, 0, 2, 0, 4]) == 10\nassert maxWaterStored([3, 5, 3, 2, 3, 4]) == 3\nassert maxWaterStored([3, 1, 3, 4, 2, 1, 3, 0, 3, 1]) == 9\nassert maxWaterStored([5, 2, 1, 0, 2, 3]) == 9\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'concatenation', 'pairs', 'divisible', 'count', 'modulus']", "prompt_tokens": 679, "total_tokens": 1123, "completion_tokens": 444, "completion": "[Question 2]\n\nYou are given an array of integers. Write a function to count the number of completely filled quartan prime pairs in the array. Quartan primes are prime numbers that are of the form 3n+1. Two prime numbers are considered as a completely filled quartan prime pair if they are anagrams of each other and their concatenation is divisible by 3.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\ndef isPrime(n: int) -> bool:\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5)+1):\n        if n % i == 0:\n            return False\n    return True\n\ndef countQuartanPrimePairs(arr: List[int]) -> int:\n    def isQuartanPrime(n: int) -> bool:\n        return isPrime(n) and (n % 3 == 1)\n\n    prime_dict = {}\n    quartan_prime_count = 0\n    for num in arr:\n        if isQuartanPrime(num):\n            sorted_num = ''.join(sorted(str(num)))\n            if sorted_num in prime_dict and (int(sorted_num+str(num)) % 3 == 0):\n                quartan_prime_count += 1\n            else:\n                prime_dict[sorted_num] = 1\n\n    return quartan_prime_count\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countQuartanPrimePairs([1, 2, 3, 4, 5, 6, 7, 8, 9, 31, 13, 121, 313])==2\nassert countQuartanPrimePairs([11, 13, 31, 113, 131, 311])==3\nassert countQuartanPrimePairs([101, 103, 107, 113, 127, 131, 137, 139, 149, 157])==0\nassert countQuartanPrimePairs([3, 33, 333, 13, 31, 130])==1\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['geometry', 'circles', 'radii', 'distance', 'math', 'sequence']", "prompt_tokens": 514, "total_tokens": 715, "completion_tokens": 201, "completion": "[Question 2]\n\nGiven a sequence of circles, each inscribed within the previous one, you are asked to find the sum of the radii of all the circles in the sequence. Assume the distance between the centers of each pair of consecutive circles is the same.\n\n[/Question 2]\n\n[Code 2]\n\ndef sumInscribedCircleRadii(n: int, distance: float) -> float:\n    total_radii = 0\n    current_radius = distance / 2\n    for _ in range(n):\n        total_radii += current_radius\n        current_radius /= 2\n    return total_radii\n\n[/Code 2]\n\n[Asserts 2]\n\nassert sumInscribedCircleRadii(3, 10) == 15.0\nassert sumInscribedCircleRadii(4, 8) == 14.0\nassert sumInscribedCircleRadii(5, 12) == 31.0\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['prime', 'factor', 'range', 'query', 'count', 'sum', 'prefix', 'array', 'math']", "prompt_tokens": 718, "total_tokens": 1208, "completion_tokens": 490, "completion": "[Question 2]\n\nGiven an array of lowercase letters, you need to process Q queries. Each query contains a range from L to R. The task is to find the count of prime factors of the product of all the factors present in the given range. Return the sum of these prime factors across all the queries.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef sumOfPrimeFactors(arr: List[str], queries: List[List[int]]) -> int:\n    def isPrime(n):\n        if n <= 1:\n            return False\n        for i in range(2, int(n**0.5)+1):\n            if n % i == 0:\n                return False\n        return True\n\n    def primeFactorsCount(n):\n        count = 0\n        for i in range(2, n+1):\n            if isPrime(i) and n % i == 0:\n                while n % i == 0:\n                    n //= i\n                    count += 1\n        return count\n\n    result = 0\n    for query in queries:\n        product = 1\n        for i in range(query[0], query[1]+1):\n            num = ord(arr[i]) - ord('a') + 1\n            product *= num\n        result += primeFactorsCount(product)\n    return result\n\n[/Code 2]\n\n[Asserts 2]\n\nassert sumOfPrimeFactors(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'], [[1, 3], [2, 5], [0, 6]]) == 7\nassert sumOfPrimeFactors(['z', 'x', 'y', 'w', 'v', 'u', 't', 's', 'r'], [[2, 4], [0, 6], [3, 7]]) == 8\nassert sumOfPrimeFactors(['m', 'n', 'o', 'p', 'q', 'r', 's', 't'], [[1, 2], [0, 5]]) == 5\nassert sumOfPrimeFactors(['a', 'b', 'c', 'd', 'e', 'f'], [[3, 5], [0, 2], [1, 4]]) == 11\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['quadratic equation', 'roots', 'discriminant', 'math', 'conditions', 'logical', 'comparison']", "prompt_tokens": 617, "total_tokens": 918, "completion_tokens": 301, "completion": "[Question 2]\n\nYou are given a doubly circular linked list containing integer values in Binary Coded Decimal (BCD) format. Write a function to find the largest integer value represented by the BCD values in the linked list and return it in integer format.\n\n[/Question 2]\n\n[Code 2]\n\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n        self.prev = None\n\ndef bcdToInt(head: Node) -> int:\n    max_val = -1\n    current = head\n    while True:\n        bcd_val = int(current.data, 2)  # Convert BCD to integer\n        if bcd_val > max_val:\n            max_val = bcd_val\n        current = current.next\n        if current == head:  # Exit when circular loop completes\n            break\n    return max_val\n\n[/Code 2]\n\n[Asserts 2]\n\nnode1 = Node('1001')  # BCD for 9\nnode2 = Node('1100')  # BCD for 12\nnode3 = Node('0110')  # BCD for 6\nnode1.next = node2\nnode2.prev = node1\nnode2.next = node3\nnode3.prev = node2\nnode3.next = node1\nnode1.prev = node3\nassert bcdToInt(node1)==12\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['positive integer', 'count', 'n digit numbers', 'sum of digits', 'dynamic programming', 'combinations', 'recursion']", "prompt_tokens": 613, "total_tokens": 945, "completion_tokens": 332, "completion": "[Question 2]\n\nYou are organizing a party and you have a cocktail glass that can be flipped ny times. You want to distribute prizes to the guests based on a game where they make k jumps. The game awards prizes to guests who land on a number divisible by ny. You need to find the total number of combinations of k jumps that result in a sum of digits divisible by ny.\n\n[/Question 2]\n\n[Code 2]\n\ndef countCombination(n, k, ny) :\n\tdp = [[0 for i in range(ny)]for j in range(k + 1)]\n\tdp[0][0] = 1\n\tfor i in range(1, k + 1) :\n\t\tfor j in range(ny) :\n\t\t\tfor digit in range(10) :\n\t\t\t\tif (i == 1 and digit == 0) :\n\t\t\t\t\tcontinue\n\t\t\t\tif (j + digit < ny) :\n\t\t\t\t\tdp[i][(j + digit) % ny] += dp[i - 1][j]\n\t\t\t\telse :\n\t\t\t\t\tdp[i][(j + digit) % ny] += dp[i - 1][j]\n\treturn dp[k][0]\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countCombination(10, 2, 3) == 37\nassert countCombination(5, 3, 2) == 4\nassert countCombination(5, 4, 5) == 10\nassert countCombination(20, 5, 4) == 869\nassert countCombination(10, 3, 5) == 126", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['integer', 'difference', 'squares', 'positive', 'list']", "prompt_tokens": 543, "total_tokens": 912, "completion_tokens": 369, "completion": "[Question 2]\n\nWrite a function to find all special numbers in a list of integers. A special number is an integer where the difference between the square of its position (0-based) in the list and the integer itself is a triangular pyramidal number. The function should only consider intermediate nodes (positions other than the first and last) and return a list of the uppercase special numbers. If no special numbers are found, the function should return an empty list.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\ndef isTriangularPyramidalNumber(num: int) -> bool:\n    if num < 0:\n        return False\n    n = int((2 * num)**0.5)\n    return n * (n + 1) == 2 * num\n\ndef findSpecialNumbers(numbers: List[int]) -> List[str]:\n    special_numbers = []\n    for i in range(1, len(numbers) - 1):\n        position_square = i * i\n        if isTriangularPyramidalNumber(abs(position_square - numbers[i])):\n            special_numbers.append(str(numbers[i]).upper())\n    return special_numbers\n\n[/Code 2]\n\n[Asserts 2]\n\nassert findSpecialNumbers([3, 7, 9, 12, 5, 10, 8, 6])==['7', '12', '10']\nassert findSpecialNumbers([1, 4, 9, 16, 25, 36])==['16']\nassert findSpecialNumbers([5, 12, 18, 14, 20, 25, 15])==[]\nassert findSpecialNumbers([2, 8, 14, 13, 18, 29, 20, 35, 26])==['29']", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['binary tree', 'swap', 'level', 'multiples', 'children', 'list of lists', 'node', 'index', 'left child', 'right child']", "prompt_tokens": 1019, "total_tokens": 1748, "completion_tokens": 729, "completion": "[Question 2]\n\nYou are given a binary tree and two nodes with coordinates (x1, y1) and (x2, y2). You have to swap the positions of the nodes in the tree if their y-coordinates are multiples of a given number K. After swapping, return the resulting binary tree represented as a list of lists where each sublist contains the value of a node, the index of its left child, and the index of its right child.\n\nWrite a function to perform the node swapping based on the y-coordinates and return the modified binary tree.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\nclass TreeNode:\n    def __init__(self, value: int, left_child_index: int, right_child_index: int, x: int, y: int):\n        self.value = value\n        self.left = None\n        self.right = None\n        self.left_child_index = left_child_index\n        self.right_child_index = right_child_index\n        self.x = x\n        self.y = y\n\ndef swapNodesByYCoordinate(tree: List[List[int]], x1: int, y1: int, x2: int, y2: int, K: int) -> List[List[int]]:\n    nodes = {}\n    for i in range(len(tree)):\n        nodes[i+1] = TreeNode(tree[i][0], tree[i][1], tree[i][2], tree[i][3], tree[i][4])\n\n    def dfs(node, result):\n        if not node:\n            return\n        if node.y % K == 0:\n            node.left, node.right = node.right, node.left\n        result.append([node.value, node.left_child_index, node.right_child_index, node.x, node.y])\n        dfs(nodes[node.left_child_index], result)\n        dfs(nodes[node.right_child_index], result)\n\n    result = []\n    dfs(nodes[1], result)\n    return result\n\n[/Code 2]\n\n[Asserts 2]\n\nassert swapNodesByYCoordinate([[1, 2, 3, 0, 0], [2, -1, 4, 1, 1], [3, -1, -1, 2, 2], [4, -1, -1, 3, 3]], 1, 1, 2, 2, 2) == [[1, 3, 2, 0, 0], [3, -1, -1, 2, 2], [2, 4, -1, 1, 1], [4, -1, -1, 3, 3]]\nassert swapNodesByYCoordinate([[1, 2, 3, 0, 0], [2, 4, 5, 1, 1], [3, -1, -1, 2, 6], [4, -1, -1, 3, 2], [5, -1, -1, 4, 3]], 1, 1, 3, 6, 3) == [[1, 3, 2, 0, 0], [3, -1, -1, 2, 6], [2, 5, 4, 1, 1], [5, -1, -1, 4, 3], [4, -1, -1, 3, 2]]\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['string', 'palindrome', 'substring', 'rearrange', 'queries', 'count', 'odd', 'collections']", "prompt_tokens": 574, "total_tokens": 778, "completion_tokens": 204, "completion": "[Question 2]\n\nGiven a list of strings and an integer n, the task is to find the count of strings where the last n characters form a palindrome.\n\n[/Question 2]\n\n[Code 2]\n\ndef countLastNPalindrome(strings, n):\n    def isPalindrome(s):\n        return s == s[::-1]\n\n    count = 0\n    for string in strings:\n        if len(string) >= n:\n            if isPalindrome(string[-n:]):\n                count += 1\n    return count\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countLastNPalindrome([\"abcdcba\", \"xyzzyx\", \"hello\", \"madam\"], 3) == 2\nassert countLastNPalindrome([\"abcba\", \"xyz\", \"1221\", \"12321\"], 2) == 3\nassert countLastNPalindrome([\"ab\", \"xyzzyx\", \"hello\", \"madam\"], 3) == 1\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'triplet', 'sorting', 'target', 'sum', 'closest', 'abs']", "prompt_tokens": 622, "total_tokens": 1004, "completion_tokens": 382, "completion": "[Question 2]\n\nYou are given an array of integers representing the rainfall measured over several days. Write a function to find the day of the week with the closest total rainfall to a given target total rainfall. Assume that Monday is the first day of the week (index 0) and Sunday is the last day of the week (index 6).\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef closestRainfallDay(rainfall: List[int], target: int) -> int:\n    total_rainfall = [0] * 7\n    for i in range(len(rainfall)):\n        total_rainfall[i % 7] += rainfall[i]\n\n    min_difference = abs(total_rainfall[0] - target)\n    closest_day = 0\n    for i in range(1, 7):\n        diff = abs(total_rainfall[i] - target)\n        if diff < min_difference:\n            min_difference = diff\n            closest_day = i\n    return closest_day\n\n[/Code 2]\n\n[Asserts 2]\n\nassert closestRainfallDay([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13], 30) == 6  # Sunday\nassert closestRainfallDay([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 50, 0, 0, 0, 0], 50) == 3  # Wednesday\nassert closestRainfallDay([10, 20, 30, 15, 25, 35, 25], 100) == 0  # Monday\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['string', 'swap', 'number', 'permutation', 'sorting']", "prompt_tokens": 533, "total_tokens": 939, "completion_tokens": 406, "completion": "[Question 2]\n\nYou are given a linked list where each node contains a single digit. The digits are stored in reverse order, such that the 1's digit is at the head of the list. Write a function `addTwoNumbers` to add the two numbers and return the sum as a linked list.\n\nAdditionally, if the sum contains leading zeros, ignore them.\n\n[/Question 2]\n\n[Code 2]\n\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef addTwoNumbers(l1: ListNode, l2: ListNode) -> ListNode:\n    carry = 0\n    dummy = ListNode(0)\n    current = dummy\n\n    while l1 or l2 or carry:\n        value = carry\n        if l1:\n            value += l1.val\n            l1 = l1.next\n        if l2:\n            value += l2.val\n            l2 = l2.next\n\n        carry, value = divmod(value, 10)\n        current.next = ListNode(value)\n        current = current.next\n\n    return dummy.next\n\n[/Code 2]\n\n[Asserts 2]\n\n# Test case 1\n# Input: (2 -> 4 -> 3) + (5 -> 6 -> 4)\n# Output: 7 -> 0 -> 8\nl1 = ListNode(2, ListNode(4, ListNode(3)))\nl2 = ListNode(5, ListNode(6, ListNode(4)))\nresult = addTwoNumbers(l1, l2)\nassert result.val == 7\nassert result.next.val == 0\nassert result.next.next.val == 8\n\n# Test case 2\n# Input: (0) + (0)\n# Output: 0\nl3 = ListNode(0)\nl4 = ListNode(0)\nresult2 = addTwoNumbers(l3, l4)\nassert result2.val == 0", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'elements', 'range', 'missing', 'increasing order', 'boolean', 'iteration']", "prompt_tokens": 545, "total_tokens": 827, "completion_tokens": 282, "completion": "[Question 2]\n\nGiven an array arr[ ] of N elements, rearrange the elements in such a way that the elements are concatenated to form a series of increasing order. Each element has a weight, and the total weight capacity is given. The function should return True if it's possible to rearrange the elements such that the series formed is in increasing order and the total weight doesn't exceed the given capacity, otherwise return False.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef rearrangeAndCheck(N: int, arr: List[int], capacity: int) -> bool:\n    arr.sort()\n    total_weight = 0\n    for i in arr:\n        total_weight += i\n        if total_weight > capacity:\n            return False\n    return True\n\n[/Code 2]\n\n[Asserts 2]\n\nassert rearrangeAndCheck(5, [1, 2, 4, 5], 10)==True\nassert rearrangeAndCheck(6, [5, 2, 1, 3, 4, 6], 12)==False\nassert rearrangeAndCheck(3, [1, 2, 3], 3)==True\nassert rearrangeAndCheck(4, [4, 3, 2, 1], 10)==True\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['task', 'completion', 'remaining', 'people', 'days', 'calculate', 'total']", "prompt_tokens": 489, "total_tokens": 647, "completion_tokens": 158, "completion": "[Question 2]\n\nYou are given the total number of days taken by a group of people to complete a task and the number of remaining people to complete the task. Calculate the total accumulation of days required for each remaining person to complete the task based on the instances of completion.\n\n[/Question 2]\n\n[Code 2]\n\ndef calculateAccumulatedDays(total_days: int, remaining_people: int) -> int:\n    return total_days // remaining_people\n\n[/Code 2]\n\n[Asserts 2]\n\nassert calculateAccumulatedDays(30, 3) == 10\nassert calculateAccumulatedDays(50, 5) == 10\nassert calculateAccumulatedDays(45, 9) == 5\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['matrix', 'movement', 'minimum', 'jumps', 'cell', 'height', 'index', 'dynamic programming', 'path', 'reach']", "prompt_tokens": 802, "total_tokens": 1274, "completion_tokens": 472, "completion": "[Question 2]\n\nYou are given a matrix representing a terrain, with each cell containing the height. Your task is to find the minimum number of jumps required to reach from the top-left cell to the bottom-right cell, where you can only move down or right. However, there are clusters of cells with concurrent heights, and you can make a jump to move to the cell with the same height within the cluster.\n\nWrite a function that takes the terrain matrix and returns the minimum number of jumps required to reach the bottom-right cell.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef minJumpsToReach(matrix: List[List[int]]) -> int:\n    n = len(matrix)\n    m = len(matrix[0])\n    jumps = [[float('inf')] * m for _ in range(n)]\n    jumps[0][0] = 0\n    for i in range(n):\n        for j in range(m):\n            for x, y in [(1, 0), (0, 1)]:\n                r, c = i + x, j + y\n                if r < n and c < m:\n                    jumps[r][c] = min(jumps[r][c], jumps[i][j] + (0 if matrix[i][j] == matrix[r][c] else 1))\n    return jumps[-1][-1]\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minJumpsToReach([[1, 2, 2], [1, 1, 3], [1, 1, 1]]) == 2\nassert minJumpsToReach([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 2\nassert minJumpsToReach([[1, 2, 2, 3], [1, 2, 2, 3], [3, 2, 2, 3]]) == 3\nassert minJumpsToReach([[1, 2, 1, 3, 3], [4, 2, 2, 3, 3], [7, 2, 2, 3, 3]]) == 4\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'distinct', 'remove', 'length', 'check']", "prompt_tokens": 551, "total_tokens": 798, "completion_tokens": 247, "completion": "[Question 2]\n\nYou are given an array of integral coordinates representing points in a 2D plane. Write a function to remove any duplicate coordinates from the array and return the length of the modified array.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef removeDuplicateCoordinates(coordinates: List[List[int]]) -> int:\n    distinct_coordinates = []\n    for coord in coordinates:\n        if coord not in distinct_coordinates:\n            distinct_coordinates.append(coord)\n    return len(distinct_coordinates)\n\n[/Code 2]\n\n[Asserts 2]\n\nassert removeDuplicateCoordinates([[1, 2], [3, 4], [1, 2], [5, 6], [3, 4]]) == 3\nassert removeDuplicateCoordinates([[1, 2], [3, 4], [5, 6]]) == 3\nassert removeDuplicateCoordinates([[1, 2], [1, 2], [1, 2], [1, 2]]) == 1\nassert removeDuplicateCoordinates([[1, 2], [3, 4], [5, 6], [7, 8]]) == 4\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'permutation', 'inverse', 'index', 'element']", "prompt_tokens": 512, "total_tokens": 827, "completion_tokens": 315, "completion": "[Question 2]\n\nGiven an array of integers arr[], the task is to find the index i such that the element at index i creates a ternary number that is the largest possible number by permuting the remaining elements of the array. If there are multiple such indices, print the smallest one.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef findMaxTernaryIndex(arr: List[int]) -> int:\n    max_val = -1\n    max_index = -1\n    for i in range(len(arr)):\n        remaining = arr[:i] + arr[i+1:]\n        remaining.sort(reverse=True)\n        ternary = 0\n        for j in range(len(remaining)):\n            ternary += remaining[j]*(3**j)\n        if ternary > max_val:\n            max_val = ternary\n            max_index = i\n    return max_index\n\n[/Code 2]\n\n[Asserts 2]\n\nassert findMaxTernaryIndex([3, 6, 1, 5, 2, 4]) == 2\nassert findMaxTernaryIndex([5, 3, 7, 2, 8, 6, 4]) == 4\nassert findMaxTernaryIndex([9, 12, 15, 6, 3]) == 3\nassert findMaxTernaryIndex([10, 8, 12, 6, 9]) == 0\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['string', 'ternary', 'expression', 'binary tree', 'conditional', 'evaluation', 'stack']", "prompt_tokens": 788, "total_tokens": 1315, "completion_tokens": 527, "completion": "[Question 2]\n\nYou are given a Binary Tree and you need to transform the values of the tree nodes by evaluating a given expression. The given expression will be in the form of a string and will involve a conditional operation. For every node in the binary tree, evaluate the given expression and transform the value of the node by considering the last two digits of the result after the evaluation.\n\n[/Question 2]\n\n[Code 2]\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef evaluateAndTransform(tree: TreeNode, expression: str) -> None:\n    stack = [tree]\n    while stack:\n        node = stack.pop()\n        if node:\n            expression_result = eval(expression, {}, {'x': node.val, 'y': node.val})\n            node.val = int(str(expression_result)[-2:])\n            stack.append(node.right)\n            stack.append(node.left)\n\n[/Code 2]\n\n[Asserts 2]\n\n# Testing evaluateAndTransform function\n# Given Binary Tree:     1\n#                      /   \\\n#                     2     3\n# Given expression: 'x + y'\ntree = TreeNode(1, TreeNode(2), TreeNode(3))\nevaluateAndTransform(tree, 'x + y')\nassert tree.val == 03  # 2 + 1 % 100 = 03\nassert tree.left.val == 04  # 2 + 2 % 100 = 04\nassert tree.right.val == 04  # 3 + 3 % 100 = 04\n\n# Given Binary Tree:     10\n#                      /    \\\n#                     20     30\n#                    /  \\    /  \\\n#                   40  50  60  70\n# Given expression: 'x * y + y - x'\ntree = TreeNode(10, TreeNode(20, TreeNode(40), TreeNode(50)), TreeNode(30, TreeNode(60), TreeNode(70)))\nevaluateAndTransform(tree, 'x * y + y - x')\nassert tree.val == 20  # 10 * 10 + 10 - 10 % 100 = 20\nassert tree.left.val == 0  # 20 * 40 + 40 - 20 % 100 = 00\nassert tree.right.val == 70  # 30 * 60 + 60 - 30 % 100 = 70\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['number', 'minimum length', 'paths', 'inclusive', 'formula', 'program', 'count', 'nodes', 'formula']", "prompt_tokens": 464, "total_tokens": 654, "completion_tokens": 190, "completion": "[Question 2]\n\nYou are given a fair-coin tree with N nodes, where each node is marked with an integer value. The task is to write a program to find the number of minimum length paths between the middle node and all other nodes in the tree.\n\nWrite a program to calculate the count of minimum length paths between the middle node and all other nodes in the tree.\n\n[/Question 2]\n\n[Code 2]\n\ndef countMinimumLengthPaths(nodes: List[int]) -> int:\n    return (len(nodes) + 1) // 2\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countMinimumLengthPaths([4, 7, 2, 9, 5])==3\nassert countMinimumLengthPaths([1, 3, 5, 7, 9, 11])==3\nassert countMinimumLengthPaths([2, 4, 6, 8])==2", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'segment tree', 'query', 'count', 'range', 'integer', 'greater than', 'sub-array']", "prompt_tokens": 765, "total_tokens": 1418, "completion_tokens": 653, "completion": "[Question 2]\n\nYou are given two arrays of equal length, arr1 and arr2. You have to handle Q queries, where each query consists of an index range (l, r) and an integer K. For each query, you need to find and replace all elements in the sub-array (l, r) of arr1 which are greater than K with the corresponding elements from arr2, using a Segment Tree.\n\n[/Question 2]\n\n[Code 2]\n\nclass SegmentTreeNode:\n    def __init__(self, idx=0):\n        self.idx = idx\n        self.left = None\n        self.right = None\n\ndef buildTree(arr, l, r):\n    if l == r:\n        return SegmentTreeNode(l)\n    mid = (l + r) // 2\n    left = buildTree(arr, l, mid)\n    right = buildTree(arr, mid + 1, r)\n    node = SegmentTreeNode()\n    if arr[left.idx] > arr[right.idx]:\n        node.idx = left.idx\n    else:\n        node.idx = right.idx\n    node.left = left\n    node.right = right\n    return node\n\ndef replaceElements(arr1, arr2, queries):\n    n = len(arr1)\n    root = buildTree(arr1, 0, n - 1)\n    for l, r, K in queries:\n        replaceElementsUtil(arr1, arr2, root, l, r, 0, n-1, K)\n    return arr1\n\ndef replaceElementsUtil(arr1, arr2, root, l, r, low, high, K):\n    if low > r or high < l:\n        return\n    if low == high:\n        if arr1[low] > K:\n            arr1[low] = arr2[low]\n        return\n    if arr1[root.idx] <= K:\n        return\n    mid = (low + high) // 2\n    replaceElementsUtil(arr1, arr2, root.left, l, r, low, mid, K)\n    replaceElementsUtil(arr1, arr2, root.right, l, r, mid + 1, high, K)\n\narr1 = [6, 8, 3, 5, 2, 7]\narr2 = [9, 4, 11, 10, 1, 12]\nqueries = [(1, 4, 4), (0, 5, 6)]\n\nassert replaceElements(arr1, arr2, queries) == [6, 4, 11, 10, 1, 12]\n\n[/Code 2]\n\n[Asserts 2]\n\narr1 = [6, 8, 3, 5, 2, 7]\narr2 = [9, 4, 11, 10, 1, 12]\nqueries = [(1, 4, 4), (0, 5, 6)]\nassert replaceElements(arr1, arr2, queries) == [6, 4, 11, 10, 1, 12]\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['tree', 'node', 'subtree', 'bitwise OR', 'query', 'DFS']", "prompt_tokens": 752, "total_tokens": 1291, "completion_tokens": 539, "completion": "[Question 2]\n\nYou are given a tree with N nodes numbered from 1 to N. Each node has a value associated with it. For each query, you are given a node X and a number K. You need to find the largest power of K that divides the Bitwise OR of the values of the nodes present in the subtree rooted at node X. If the node is not present in the tree, then return -1. If the Bitwise OR of the values in the subtree is 0, return 0. \n\nWrite a function to solve the above problem and handle the queries.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List, Tuple\n\nclass TreeNode:\n    def __init__(self, value: int):\n        self.value = value\n        self.children = []\n\ndef largest_power_of_k_in_subtree(root: TreeNode, arr: List[int], queries: List[Tuple[int, int]]) -> List[int]:\n    subtree = {}\n    for query in queries:\n        subtree[query] = -1\n\n    def dfs(node: TreeNode) -> int:\n        if not node:\n            return 0\n        current_or = arr[node.value - 1]\n        for child in node.children:\n            current_or |= dfs(child)\n        subtree[node.value] = current_or\n        return current_or\n\n    dfs(root)\n    result = []\n    for node, k in queries:\n        if node in subtree and subtree[node] == 0:\n            result.append(0)\n        else:\n            largest_power = 0\n            while subtree[node] % (k ** (largest_power + 1)) == 0:\n                largest_power += 1\n            result.append(k ** largest_power)\n    return result\n\n[/Code 2]\n\n[Asserts 2]\n\nroot = TreeNode(1)\nroot.children = [TreeNode(2), TreeNode(3), TreeNode(4)]\nroot.children[0].children = [TreeNode(5), TreeNode(6)]\nroot.children[1].children = [TreeNode(7), TreeNode(8)]\narr = [1, 2, 3, 4, 5, 6, 7, 8]\nassert largest_power_of_k_in_subtree(root, arr, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 2), (6, 3), (7, 4), (8, 5)]) == [2, 4, 4, 1, 1, 2, 4, 1]\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'integer', 'cost', 'candy', 'minimum', 'maximum', 'buying']", "prompt_tokens": 500, "total_tokens": 756, "completion_tokens": 256, "completion": "[Question 2]\n\nYou are given a list of envelopes, where each envelope is represented as a tuple of width and height. The task is to find the earliest possible envelope that can fit inside another envelope, i.e., the smallest envelope that can be nested within another envelope.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List, Tuple\n\ndef earliestNestedEnvelope(envelopes: List[Tuple[int, int]]) -> Tuple[int, int]:\n    envelopes.sort(key=lambda x: (x[0], -x[1]))\n    dp = []\n    \n    for w, h in envelopes:\n        i = bisect.bisect_left(dp, h)\n        if i == len(dp):\n            dp.append(h)\n        else:\n            dp[i] = h\n    return (len(dp), dp[-1])\n\n[/Code 2]\n\n[Asserts 2]\n\nassert earliestNestedEnvelope([(5, 4), (6, 4), (6, 7), (2, 3)]) == (3, 4)\nassert earliestNestedEnvelope([(1, 1), (2, 2), (3, 3), (4, 4)]) == (1, 1)\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['string', 'logical expression', 'evaluate', 'boolean', 'AND', 'OR', 'NOT', 'stack', 'pop', 'append']", "prompt_tokens": 602, "total_tokens": 1000, "completion_tokens": 398, "completion": "[Question 2]\n\nGiven a list of integers representing the local minima in a sequence, write a function to evaluate if the sequence can be represented as a truncatable diamond. A truncatable diamond is a sequence that can be formed using logical AND and OR operations on its elements, where the operators are applied in a \"truncatable\" manner: the operations start from the first element and carry over to the next element in the sequence.\n\nFor example, given the list of local minima [2, 3, 6, 4, 5], the sequence can be represented as (2 AND 3) OR (6 AND 4) OR 5, which equals 5.\n\nWrite a Python function to determine if a given sequence can be represented as a truncatable diamond.\n\n[/Question 2]\n\n[Code 2]\n\ndef isTruncatableDiamond(minima: list) -> bool:\n    stack = []\n    for num in minima:\n        stack.append(num)\n        while len(stack) >= 3:\n            op2 = stack.pop()\n            op1 = stack.pop()\n            if stack and (op1 + op2) % 2 == 0:\n                carry = stack.pop()\n                stack.append(op1 | op2 if carry else op1 & op2)\n            else:\n                stack.append(op1)\n                stack.append(op2)\n                break\n    return len(stack) == 1\n\n[/Code 2]\n\n[Asserts 2]\n\nassert isTruncatableDiamond([2, 3, 6, 4, 5]) == True\nassert isTruncatableDiamond([1, 2, 3, 2, 1]) == True\nassert isTruncatableDiamond([5, 4, 3, 2, 1]) == False\nassert isTruncatableDiamond([4, 3, 5, 2, 1]) == False", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['series', 'sum', 'math', 'pattern', 'progression', 'triangular', 'formula']", "prompt_tokens": 396, "total_tokens": 511, "completion_tokens": 115, "completion": "[Question 2]\n\nWrite a Python function to find the sum of the first n terms of the following series: 2, 6, 12, 20, 30, ...\n\n[/Question 2]\n\n[Code 2]\n\ndef series_sum(n):\n    return n * (n + 1) * (n + 2) // 6\n\n[/Code 2]\n\n[Asserts 2]\n\nassert series_sum(5) == 140\nassert series_sum(3) == 20\nassert series_sum(1) == 2", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['binary tree', 'nodes', 'sum', 'leaf node', 'left child', 'right child', 'recursive', 'traversal']", "prompt_tokens": 704, "total_tokens": 1018, "completion_tokens": 314, "completion": "[Question 2]\n\nYou are given a binary tree where each node contains a binary digit. The value of a leaf node is represented by the binary digits in the path from the root to that leaf node. Your task is to find the sum of all the leaf node values, where each leaf node value is represented as the decimal number and then convert it into base 10. \n\n[/Question 2]\n\n[Code 2]\n\n# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef decimalValue(root: TreeNode) -> int:\n    def dfs(node, num):\n        if not node:\n            return 0\n        num = (num << 1) | node.val\n        if not node.left and not node.right:\n            return num\n        return dfs(node.left, num) + dfs(node.right, num)\n\n    return dfs(root, 0)\n\n[/Code 2]\n\n[Asserts 2]\n\n# Create a binary tree for testing\n#          1\n#         / \\\n#        0   1\n#       / \\ / \\\n#      0  1 0  1\nroot = TreeNode(1, \n                TreeNode(0, TreeNode(0), TreeNode(1)), \n                TreeNode(1, TreeNode(0), TreeNode(1)))\nassert decimalValue(root) == 22\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['collision', 'trucks', 'speed', 'position', 'time', 'probability', 'math', 'linear equation', 'distance']", "prompt_tokens": 600, "total_tokens": 844, "completion_tokens": 244, "completion": "[Question 2]\n\nYou are given a list of trucks' positions and their speeds. Write a function to find the position of the Kth truck after T seconds, given that all the trucks continue to move at their respective speeds without any collisions. If the Kth truck does not exist at that time, return -1. Assume the speeds and positions are all non-negative integers.\n\n[/Question 2]\n\n[Code 2]\n\ndef findKthTruckPosition(positions: List[int], speeds: List[int], K: int, T: int) -> int:\n    arr = [(positions[i] + speeds[i]*T, i) for i in range(len(positions))]\n    arr.sort()\n    if K > len(arr):\n        return -1\n    return arr[K-1][1]\n\n[/Code 2]\n\n[Asserts 2]\n\nassert findKthTruckPosition([1, 3, 5], [2, 2, 2], 2, 5) == 1\nassert findKthTruckPosition([1, 3, 5], [2, 2, 2], 4, 5) == -1", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'subsequence', 'sequence', 'boundary', 'length', 'increasing']", "prompt_tokens": 780, "total_tokens": 1258, "completion_tokens": 478, "completion": "[Question 2]\n\nYou are given an array representing the lengths of different foot races. The array represents a sequence of foot race lengths. Write a function to determine the size of the longest increasing subsequence that represents a cycle. \n\nA cycle is a non-empty subsequence of the array such that the first and last elements of the subsequence are considered as boundary elements, and the sequence increases in length from the first element to the last element (wrapping around if necessary). \n\nFor example, given the array [3, 5, 2, 3, 4, 6, 3, 7, 8], the longest increasing subsequence that represents a cycle is [2, 3, 4, 6, 7, 8] with a cycle size of 6.\n\nWrite a function that takes in the array and returns the size of the longest increasing subsequence that represents a cycle.\n\n[/Question 2]\n\n[Code 2]\n\ndef longestIncreasingCycleSize(arr):\n    n = len(arr)\n    res = 0\n    for i in range(n):\n        seq_len = 1\n        j = (i+1)%n\n        while j != i:\n            if arr[j] > arr[(j-1)%n]:\n                seq_len += 1\n            else:\n                res = max(res, seq_len)\n                seq_len = 1\n            j = (j+1)%n\n        res = max(res, seq_len)\n    return res\n\n[/Code 2]\n\n[Asserts 2]\n\nassert longestIncreasingCycleSize([3, 5, 2, 3, 4, 6, 3, 7, 8]) == 6\nassert longestIncreasingCycleSize([1, 2, 3, 4, 5]) == 2\nassert longestIncreasingCycleSize([5, 4, 3, 2, 1]) == 1\nassert longestIncreasingCycleSize([5, 4, 3, 2, 1, 6, 7, 8, 9]) == 5\nassert longestIncreasingCycleSize([10, 20, 30, 25, 40, 35, 45]) == 3\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'integers', 'product', 'triplet', 'subsequence', 'maximum']", "prompt_tokens": 616, "total_tokens": 967, "completion_tokens": 351, "completion": "[Question 2]\n\nGiven an array of integers, find the maximum product of a subsequence of size 3, where the subsequence is chosen such that the bitwise OR of the selected integers results in a single variable. This process should be randomized.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\nimport random\n\ndef findMaxTripletProductWithBitwiseOR(arr: List[int]) -> int:\n    max_product = float('-inf')\n    for _ in range(1000):  # Perform the process multiple times to randomize\n        a, b, c = random.sample(arr, 3)  # Choose 3 random integers from the array\n        bitmask = a | b | c  # Bitwise OR of the selected integers\n        if bin(bitmask).count('1') == 1:  # Check if the OR result is a single variable\n            max_product = max(max_product, a * b * c)  # Update max product if condition satisfied\n    return max_product\n\n[/Code 2]\n\n[Asserts 2]\n\nassert findMaxTripletProductWithBitwiseOR([1, 2, 3, 4, 5, 6, 7, 8, 9]) == 504  # In this case, the subsequence [7, 8, 9] results in 504\nassert findMaxTripletProductWithBitwiseOR([2, 3, 10, 8, 5, 14, 10]) == 1400  # In this case, the subsequence [10, 8, 14] results in 1400\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['matrix', 'submatrix', 'smallest element', 'nested loops', 'nested lists', 'minimum', 'iteration']", "prompt_tokens": 831, "total_tokens": 1205, "completion_tokens": 374, "completion": "[Question 2]\n\nGiven a matrix of size N x N, write a function to find the smallest element in each submatrix of size K x K and return the maximum of these smallest elements.\n\n[/Question 2]\n\n[Code 2]\n\ndef maxMinSubmatrix(matrix, k):\n    n = len(matrix)\n    result = float('-inf')\n\n    for i in range(n - k + 1):\n        for j in range(n - k + 1):\n            cur_min = float('inf')\n            for l in range(k):\n                for m in range(k):\n                    if matrix[i + l][j + m] < cur_min:\n                        cur_min = matrix[i + l][j + m]\n            result = max(result, cur_min)\n\n    return result\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maxMinSubmatrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 2) == 5\nassert maxMinSubmatrix([[4, 7, 2, 4], [8, 2, 9, 1], [12, 3, 5, 6], [4, 2, 8, 5]], 3) == 6\nassert maxMinSubmatrix([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 2) == 1\nassert maxMinSubmatrix([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 2) == 7\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'integer', 'subsequence', 'length', 'longest', 'LCM', 'math', 'gcd', 'lcm', 'range']", "prompt_tokens": 703, "total_tokens": 1143, "completion_tokens": 440, "completion": "[Question 2]\n\nGiven an array arr[] of integers and a range [L, R], find the length of the longest subsequence such that the LCM of all the elements of this subsequence lies in the given range.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef longestSubsequenceInRange(arr: List[int], L: int, R: int) -> int:\n    def gcd(a, b):\n        while b:\n            a, b = b, a%b\n        return a\n    \n    def lcm(a, b):\n        return (a*b)//gcd(a,b)\n        \n    def check(x):\n        if x < L or x > R:\n            return False\n        return True\n\n    n = len(arr)\n    l = 0\n    ans = 0\n\n    for i in range(n):\n        f = []\n        for j in range(i, n):\n            n = len(f)\n            flag = 0\n            for k in range(n):\n                if (gcd(f[i], arr[j]) == 1):\n                    flag = 1\n                    break\n            if (f == [] or flag == 0):\n                f.append(arr[j])\n                \n        pro = 1\n        for it in f:\n            pro = pro*it;\n\n        if (check(pro) and len(f) > l):\n            ans = len(f)\n    \n    return ans\n\n[/Code 2]\n\n[Asserts 2]\n\nassert longestSubsequenceInRange([2, 3, 5, 7], 10, 30)==3\nassert longestSubsequenceInRange([4, 6, 8, 9], 15, 100)==4\nassert longestSubsequenceInRange([2, 3, 7, 30], 10, 40)==3\nassert longestSubsequenceInRange([2, 3, 7, 30], 50, 60)==2\nassert longestSubsequenceInRange([1, 2, 3, 4, 5, 6], 10, 50)==4\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['matrix', 'rectangle', 'area', 'occupied cells', 'submatrix', 'sum', 'count', 'nested loop']", "prompt_tokens": 734, "total_tokens": 1326, "completion_tokens": 592, "completion": "[Question 2]\n\nYou are given a matrix of size NxM representing the occupancy of cells. You need to write a program to check the eligibility of a submatrix to be updated. A submatrix is eligible for an update if the sum of its elements is greater than a given threshold value T. You are also required to implement the functionality to update the elements of an eligible submatrix.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\ndef isEligible(matrix: List[List[int]], n: int, m: int, threshold: int, i1: int, j1: int, i2: int, j2: int) -> bool:\n    total = 0\n    for i in range(i1, i2+1):\n        for j in range(j1, j2+1):\n            total += matrix[i][j]\n    return total > threshold\n\ndef updateSubmatrix(matrix: List[List[int]], n: int, m: int, i1: int, j1: int, i2: int, j2: int, newValue: int) -> None:\n    for i in range(i1, i2+1):\n        for j in range(j1, j2+1):\n            matrix[i][j] = newValue\n\n[/Code 2]\n\n[Asserts 2]\n\nmatrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nupdateSubmatrix(matrix, 3, 3, 0, 0, 1, 1, 0)\nassert matrix == [[0, 0, 3], [0, 0, 6], [7, 8, 9]]\n\nassert isEligible([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3, 3, 15, 0, 0, 1, 1) == True\nassert isEligible([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3, 3, 30, 0, 0, 2, 2) == False\nassert isEligible([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3, 3, 10, 0, 0, 2, 1) == True\nassert isEligible([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3, 3, 20, 0, 0, 2, 2) == True\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['binary', 'string', 'condition', 'comparison', 'substring', 'boolean']", "prompt_tokens": 438, "total_tokens": 845, "completion_tokens": 407, "completion": "[Question 2]\n\nGiven a binary tree, write a function to determine if the non-leaf nodes of the tree form a triplet-connected string based on a given condition. The condition is that each non-leaf node's value should be a substring of its immediate parent's value. The function should return a boolean indicating whether the condition is met or not.\n\n[/Question 2]\n\n[Code 2]\n\nclass TreeNode:\n\tdef __init__(self, val=0, left=None, right=None):\n\t\tself.val = val\n\t\tself.left = left\n\t\tself.right = right\n\ndef isTripletConnected(root: TreeNode) -> bool:\n\tdef isSubstring(s1, s2):\n\t\treturn s1 in s2\n\n\tif not root or (not root.left and not root.right):\n\t\treturn False\n\tqueue = [root]\n\twhile queue:\n\t\tnode = queue.pop(0)\n\t\tif node.left or node.right:\n\t\t\tif (node.left and not isSubstring(node.left.val, node.val)) or (node.right and not isSubstring(node.right.val, node.val)):\n\t\t\t\treturn False\n\t\t\tif node.left:\n\t\t\t\tqueue.append(node.left)\n\t\t\tif node.right:\n\t\t\t\tqueue.append(node.right)\n\treturn True\n\n[/Code 2]\n\n[Asserts 2]\n\n# Create a binary tree:     1\n#                         /   \\\n#                        10     101\n#                                  \\\n#                                   1010\n\nroot = TreeNode(1)\nroot.left = TreeNode(10)\nroot.right = TreeNode(101)\nroot.right.right = TreeNode(1010)\n\nassert isTripletConnected(root) == True\n\n# Create a binary tree:     1\n#                         /   \\\n#                        10     101\n#                       /  \\\n#                      100  1010\n\nroot = TreeNode(1)\nroot.left = TreeNode(10)\nroot.left.left = TreeNode(100)\nroot.left.right = TreeNode(1010)\n\nassert isTripletConnected(root) == False", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['queue', 'single', 'wives', 'men', 'standing', 'initial', 'formula', 'natural numbers']", "prompt_tokens": 533, "total_tokens": 787, "completion_tokens": 254, "completion": "[Question 2]\n\nIn a counting-out game played by a group of men standing in a queue, a number is called out and every nth man is asked to leave the queue until no more men are left. The game continues until the number of men remaining in the queue exceeds a certain value. Given the initial count of men in the queue, write a program to calculate the number of times the counting-out game will be played before the queue exceeds a certain number of men.\n\nWrite a function to calculate the number of times the counting-out game will be played.\n\n[/Question 2]\n\n[Code 2]\n\ndef countingOutGame(initialCount: int, exceedCount: int) -> int:\n    if initialCount <= exceedCount:\n        return 0\n    else:\n        return initialCount - exceedCount - 1\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countingOutGame(10, 8) == 1\nassert countingOutGame(15, 10) == 4\nassert countingOutGame(5, 5) == 0\nassert countingOutGame(20, 15) == 4\nassert countingOutGame(7, 3) == 3\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'update', 'add', 'multiply', 'indexing', 'queries', 'print']", "prompt_tokens": 715, "total_tokens": 1170, "completion_tokens": 455, "completion": "[Question 2]\n\nYou are given an array 'arr' of 'n' elements. There are 'q' queries of two types: \nType 1: Add the Fibonacci sequence number at index 'idx' to the elements from index 'l' to 'r' (1-based indexing)\nType 2: Multiply the elements from index 'l' to 'r' (1-based indexing) by the Euler Totient Function of the value at index 'idx'.\nAfter processing the queries, print the resulting array.\n\nWrite a function to handle the 'q' queries and print the updated array.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\nimport math\n\ndef updateAndPrintArray(arr: List[int], queries: List[List[int]]) -> List[int]:\n    fib = [0, 1]\n    for i in range(2, max(arr)+1):\n        fib.append(fib[i-1] + fib[i-2])\n\n    res = []\n    for query in queries:\n        type = query[0]\n        l = query[1]\n        r = query[2]\n        idx = query[3]\n        if type == 1:  # Add the Fibonacci sequence number at index 'idx' to the elements from index 'l' to 'r'\n            for i in range(l-1, r):\n                arr[i] += fib[arr[idx-1]]\n        elif type == 2:  # Multiply the elements from index 'l' to 'r' by the Euler Totient Function of the value at index 'idx'\n            factor = math.totient(arr[idx-1])  # Euler Totient Function\n            for i in range(l-1, r):\n                arr[i] *= factor\n        res = arr.copy()\n    return res\n\n[/Code 2]\n\n[Asserts 2]\n\narr = [1, 2, 3, 4, 5]\nqueries = [[1, 1, 3, 2], [2, 2, 5, 3]]\nassert updateAndPrintArray(arr, queries) == [2, 3, 6, 8, 15]\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['integer', 'sum', 'perfect number', 'range', 'proper divisors', 'positive']", "prompt_tokens": 535, "total_tokens": 799, "completion_tokens": 264, "completion": "[Question 2]\n\nGiven a numeric string s, the task is to find the sum of all perfect numbers formed by the segments of the numeric string.\n\nA perfect number is a positive integer that is equal to the sum of its proper divisors, excluding itself.\n\n[/Question 2]\n\n[Code 2]\n\ndef isPerfect(x: int) -> bool:\n    if x < 2:\n        return False\n    sum = 1\n    for i in range(2, int(x ** 0.5) + 1):\n        if x % i == 0:\n            sum += i\n            sum += x // i\n    return sum == x\n\ndef sumOfPerfectSegments(s: str) -> int:\n    segments = [int(s[i:j]) for i in range(len(s)) for j in range(i + 1, len(s) + 1)]\n    ans = 0\n    for seg in segments:\n        if isPerfect(seg):\n            ans += seg\n    return ans\n\n[/Code 2]\n\n[Asserts 2]\n\nassert sumOfPerfectSegments('12345') == 28\nassert sumOfPerfectSegments('333') == 6\nassert sumOfPerfectSegments('8128') == 8128\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['positive', 'integer', 'divisor', 'modify', 'add', 'value', 'task', 'return', 'smallest', 'times']", "prompt_tokens": 469, "total_tokens": 629, "completion_tokens": 160, "completion": "[Question 2]\n\nWrite a function that prompts the user for a positive integer value and a prompt for the number of times, and then returns the modified value by adding the smallest odd number as a divisor exactly that many times.\n\n[/Question 2]\n\n[Code 2]\n\ndef modify_positive_integer_with_smallest_odd_divisor():\n    value = int(input(\"Enter a positive integer value: \"))\n    times = int(input(\"Enter the number of times to add the smallest odd divisor: \"))\n    ans = value + (2 * times)  # The smallest odd divisor is always 1, so adding 2 times will work for any positive integer\n    return ans\n\n[/Code 2]\n\n[Asserts 2]\n\n# Unable to provide assert statements as they rely on user input.", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'binary', 'removal', 'adjacency']", "prompt_tokens": 541, "total_tokens": 764, "completion_tokens": 223, "completion": "[Question 2]\n\nYou are given an array of binary values representing the states of bulbs. At each step, you can choose one bulb and toggle its state, as well as the states of all the bulbs to its top, bottom, left, and right (adjacent bulbs). Determine the minimum number of steps to turn off all the bulbs.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef minStepsToTurnOffBulbs(bulbs: List[int]) -> int:\n    count = 0\n    state = 0\n    for bulb in bulbs:\n        if bulb == state:\n            count += 1\n            state = 1 - state\n    return count\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minStepsToTurnOffBulbs([0, 1, 0, 1, 1, 0, 1])== 3\nassert minStepsToTurnOffBulbs([1, 1, 1, 1, 1])== 2\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['string', 'split', 'prime numbers', 'backtracking', 'recursion', 'valid split', 'list', 'combinations', 'validation']", "prompt_tokens": 699, "total_tokens": 1060, "completion_tokens": 361, "completion": "[Question 2]\n\nWrite a function to validate whether a given list of strings can be split into two sublists such that the concatenation of the two sublists forms a valid prime number. Return True if such a split is possible, otherwise return False.\n\n[/Question 2]\n\n[Code 2]\n\nfrom itertools import permutations\nfrom math import isqrt\n\ndef isPrime(n: int) -> bool:\n\tif n < 2:\n\t\treturn False\n\tfor i in range(2, 1 + isqrt(n)):\n\t\tif n % i == 0:\n\t\t\treturn False\n\treturn True\n\ndef validateSplitIntoPrimes(strings: List[str]) -> bool:\n\tdef concatenate(strings):\n\t\treturn int(''.join(strings))\n\n\tdef is_valid_prime_split(sublists):\n\t\tfor perm in permutations(sublists):\n\t\t\tnum = concatenate(perm)\n\t\t\tif isPrime(num):\n\t\t\t\treturn True\n\t\treturn False\n\n\tdef backtrack(index, first, second):\n\t\tif index == len(strings):\n\t\t\treturn is_valid_prime_split([first, second])\n\n\t\tif backtrack(index + 1, first + [strings[index]], second):\n\t\t\treturn True\n\n\t\tif backtrack(index + 1, first, second + [strings[index]]):\n\t\t\treturn True\n\n\t\treturn False\n\n\treturn backtrack(0, [], [])\n\n[/Code 2]\n\n[Asserts 2]\n\nassert validateSplitIntoPrimes([\"113\", \"73\"]) == True\nassert validateSplitIntoPrimes([\"317\", \"5\"]) == True\nassert validateSplitIntoPrimes([\"2357\", \"11\"]) == True\nassert validateSplitIntoPrimes([\"24\", \"7\", \"13\"]) == False\nassert validateSplitIntoPrimes([\"2357\", \"12\"]) == False\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'integer', 'difference', 'minimize', 'removal', 'sorting', 'greedy', 'optimization']", "prompt_tokens": 569, "total_tokens": 918, "completion_tokens": 349, "completion": "[Question 2]\n\nYou are given an array of integers and an integer K. Your task is to find the minimum number of elements that need to be removed from the array such that the difference between the maximum and minimum integer is minimized within the remaining elements.\n\nWrite a function `minimizeDifferenceByRemoval` to find the minimum number of elements to be removed to minimize the difference between maximum and minimum integers.\n\nYour function should take in the array of integers and an integer K and should return the minimum number of elements to be removed.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef minimizeDifferenceByRemoval(arr: List[int], k: int) -> int:\n    arr.sort()\n    n = len(arr)\n    prefix_sum = [0] * (n + 1)\n    for i in range(1, n + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + arr[i - 1]\n\n    ans = n\n    for i in range(0, n):\n        r = i + 1\n        while r < n and arr[r] * (r - i) - (prefix_sum[r] - prefix_sum[i]) <= k:\n            r += 1\n        ans = min(ans, n - (r - i))\n\n    return ans\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minimizeDifferenceByRemoval([1, 5, 6, 2, 4, 8], 3) == 2\nassert minimizeDifferenceByRemoval([3, 7, 8, 10, 14], 2) == 1\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['divisibility', 'counting', 'looping', 'integer', 'modulus']", "prompt_tokens": 494, "total_tokens": 753, "completion_tokens": 259, "completion": "[Question 2]\n\nGiven a list of integers, write a function to count the numbers that are divisible by 3 and not divisible by 5.\n\n[/Question 2]\n\n[Code 2]\n\n```\ndef countDivisibleBy3NotBy5(arr: List[int]) -> int:\n    count = 0\n    for num in arr:\n        if num % 3 == 0 and num % 5 != 0:\n            count += 1\n    return count\n```\n\n[/Code 2]\n\n[Asserts 2]\n\n```\nassert countDivisibleBy3NotBy5([3, 5, 9, 15, 18, 20, 25, 27]) == 2\nassert countDivisibleBy3NotBy5([2, 4, 6, 8, 10, 12, 14, 30]) == 5\nassert countDivisibleBy3NotBy5([45, 60, 75, 90, 105]) == 0\nassert countDivisibleBy3NotBy5([33, 35, 39, 45, 51, 55, 57]) == 2\n```\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['graph', 'directed', 'acyclic', 'DAG', 'node', 'ancestor', 'maximum difference', 'DFS', 'edges']", "prompt_tokens": 749, "total_tokens": 1302, "completion_tokens": 553, "completion": "[Question 2]\n\nGiven a Directed Acyclic Graph (DAG) with N nodes and M edges, the task is to find the maximum difference between a node and its ancestor in the given graph. Additionally, each node has a value, and we need to connect nodes with unlike values through their edges. A node with value v is unlike another node with value u if the absolute difference between u and v does not exceed a given maximum difference.\n\n[/Question 2]\n\n[Code 2]\n\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = defaultdict(list)\n        self.visited = [0] * (vertices + 1)\n        self.precal = [-1] * (vertices + 1)\n  \n    def addEdge(self, u, v):\n        self.graph[u].append(v)\n      \n    def dfs(self, u, values, max_diff, prog):\n        self.visited[u] = 1\n        for child in self.graph[u]:\n            if not self.visited[child]:\n                prog = min(prog, values[u] - values[child])\n                if abs(values[u] - values[child]) <= max_diff:\n                    self.dfs(child, values, max_diff, prog)\n                else:\n                    self.precal[child] = max(self.precal[child], values[child])\n            else:\n                prog = min(prog, self.precal[child])\n        self.precal[u] = prog\n        return prog\n    \n    def maxDiffWithUnalikeColumns(self, values, max_diff):\n        result = -1000000007\n        for i in range(1, self.V + 1):\n            if not self.visited[i]:\n                tempo = self.dfs(i, values, max_diff, 1000000007)\n                result = max(result, (values[i] - tempo))\n        return result\n\n[/Code 2]\n\n[Asserts 2]\n\ng = Graph(6)\ng.addEdge(1, 2)\ng.addEdge(1, 3)\ng.addEdge(2, 4)\ng.addEdge(3, 5)\ng.addEdge(3, 6)\nassert g.maxDiffWithUnalikeColumns([0, 4, 3, 2, 5, 1], 1)==5\nassert g.maxDiffWithUnalikeColumns([0, 6, 5, 3, 4, 2], 2)==6\nassert g.maxDiffWithUnalikeColumns([0, 2, 7, 3, 5, 4], 1)==7\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['integer', 'prime numbers', 'distinct', 'product', 'count']", "prompt_tokens": 499, "total_tokens": 772, "completion_tokens": 273, "completion": "[Question 2]\n\nWrite a program to calculate the distinct count of integers with a prime product less than a given integer x, using an iterative method, and considering the elevation factor.\n\n[/Question 2]\n\n[Code 2]\n\ndef isPrime(num):\n\tif num < 2:\n\t\treturn False\n\tfor i in range(2, int(num ** 0.5) + 1):\n\t\tif num % i == 0:\n\t\t\treturn False\n\treturn True\n\ndef distinctCountOfIntegersWithPrimeProduct(x: int, elevation: int) -> int:\n\tcount = 0\n\tfor i in range(2, x):\n\t\tproduct = 1\n\t\tfor j in range(2, i):\n\t\t\tif isPrime(j):\n\t\t\t\tproduct *= j\n\t\tif product < x and product % elevation == 0:\n\t\t\tcount += 1\n\treturn count\n\n[/Code 2]\n\n[Asserts 2]\n\nassert distinctCountOfIntegersWithPrimeProduct(10, 3) == 3\nassert distinctCountOfIntegersWithPrimeProduct(20, 4) == 6\nassert distinctCountOfIntegersWithPrimeProduct(30, 5) == 8\nassert distinctCountOfIntegersWithPrimeProduct(50, 6) == 11\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['perfect square', 'perfect cube', 'number', 'count', 'math', 'iteration', 'power', 'range']", "prompt_tokens": 478, "total_tokens": 763, "completion_tokens": 285, "completion": "[Question 2]\n\nGiven a range of numbers from X to Y (both inclusive), write a function to count the number of clusters in the range where each cluster contains odd values. An odd value cluster is defined as a group of adjacent numbers whose sum is a perfect square or a perfect cube.\n\n[/Question 2]\n\n[Code 2]\n\ndef countOddValueClusters(X: int, Y: int) -> int:\n    odd_cluster_count = 0\n    for num in range(X, Y+1):\n        if num % 2 != 0:\n            dx = 1\n            while num + (dx * (dx + 1)) // 2 <= Y:\n                cluster_sum = num + (dx * (dx + 1)) // 2\n                if int(cluster_sum**0.5)**2 == cluster_sum or int(cluster_sum**(1/3))**3 == cluster_sum:\n                    odd_cluster_count += 1\n                dx += 1\n    return odd_cluster_count\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countOddValueClusters(1, 10) == 3\nassert countOddValueClusters(10, 30) == 4\nassert countOddValueClusters(50, 100) == 8\nassert countOddValueClusters(100, 200) == 12\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['subarray', 'contiguous', 'distinct', 'minimum']", "prompt_tokens": 684, "total_tokens": 948, "completion_tokens": 264, "completion": "[Question 2]\n\nGiven an array of percentages, find the length of the smallest contiguous subarray with the minimum difference between any two distinct percentages and return the value of the difference.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef minDifferenceSubarrayLength(arr: List[float]) -> int:\n    arr.sort()\n    min_diff = float('inf')\n    n = len(arr)\n    for i in range(1, n):\n        min_diff = min(min_diff, arr[i] - arr[i-1])\n    return min_diff\n\n[/Code 2]\n\n[Asserts 2]\n\nassert(minDifferenceSubarrayLength([3.5, 6.2, 8.9, 5.1, 9.3, 10.7, 12.4, 11.0, 13.8])) == 0.8\nassert(minDifferenceSubarrayLength([1.0, 5.0, 3.0])) == 2.0\nassert(minDifferenceSubarrayLength([2.5, 1.3, 6.7, 8.9, 4.2, 3.1, 9.8])) == 0.4\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['divisible', 'largest number', 'digits', 'set', 'sort', 'divisibility', 'algorithm']", "prompt_tokens": 759, "total_tokens": 1376, "completion_tokens": 617, "completion": "[Question 2]\n\nYou are given a set of N positive integers. Your task is to sort the integers in such a way that the largest number formed from these integers is divisible by 3. If there are multiple possible such arrangements, the order of integers should be preserved as much as possible.\n\nWrite a function `largestDivisibleBy3` to solve this problem. The function should take a list of positive integers and return the sorted list of integers that forms the largest number divisible by 3, or an empty list if no such arrangement is possible.\n\nFor example, given the set of integers [8, 1, 9], the largest number formed that is divisible by 3 is 981, so the function should return [9, 8, 1].\n\nWrite a function `largestDivisibleBy3` to solve the problem.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\ndef largestDivisibleBy3(nums: List[int]) -> List[int]:\n    total_sum = sum(nums)\n    remainder = total_sum % 3\n    \n    if remainder == 1:\n        # Try to remove the smallest number with remainder 1 or two smallest numbers with remainder 2\n        remove_1 = sorted([num for num in nums if num % 3 == 1])\n        remove_2 = sorted([num for num in nums if num % 3 == 2])\n        \n        if remove_1:\n            nums.remove(remove_1[0])\n        elif len(remove_2) >= 2:\n            nums.remove(remove_2[0])\n            nums.remove(remove_2[1])\n        else:\n            return []\n    elif remainder == 2:\n        # Try to remove the smallest number with remainder 2 or two smallest numbers with remainder 1\n        remove_1 = sorted([num for num in nums if num % 3 == 1])\n        remove_2 = sorted([num for num in nums if num % 3 == 2])\n        \n        if remove_2:\n            nums.remove(remove_2[0])\n        elif len(remove_1) >= 2:\n            nums.remove(remove_1[0])\n            nums.remove(remove_1[1])\n        else:\n            return []\n    \n    nums.sort(reverse=True)\n    return nums\n\n[/Code 2]\n\n[Asserts 2]\n\nassert largestDivisibleBy3([8, 1, 9]) == [9, 8, 1]\nassert largestDivisibleBy3([5, 8, 7, 1]) == [8, 7, 5, 1]\nassert largestDivisibleBy3([2, 3, 4, 6, 8, 9]) == [9, 6, 3]\nassert largestDivisibleBy3([1, 2, 3, 4, 5, 6, 7, 8, 9]) == [9, 6, 3]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['string', 'palindromic', 'length', 'concatenating']", "prompt_tokens": 626, "total_tokens": 1030, "completion_tokens": 404, "completion": "[Question 2]\n\nYou are given a list of strings that contain both palindromic and non-palindromic strings. The task is to find the length of the longest palindromic string that can be formed by concatenating a mixture of palindromic and non-palindromic strings in any order.\n\nWrite a function to find the length of the longest palindromic string that can be formed by concatenating the given strings in any inorder.\n\n[/Question 2]\n\n[Code 2]\n\ndef longestPalindromicConcatenation(strings: list) -> int:\n    palindromic_strings = []\n    non_palindromic_strings = []\n    \n    for s in strings:\n        if s == s[::-1]:\n            palindromic_strings.append(s)\n        else:\n            non_palindromic_strings.append(s)\n    \n    non_palindromic_length = sum(len(s) for s in non_palindromic_strings)\n    \n    if not palindromic_strings:\n        return non_palindromic_length\n    \n    longest_palindromic = max(palindromic_strings, key=len)\n    \n    return len(longest_palindromic) + non_palindromic_length\n\n[/Code 2]\n\n[Asserts 2]\n\nassert longestPalindromicConcatenation([\"a\", \"ab\", \"cd\", \"aba\"]) == 7\nassert longestPalindromicConcatenation([\"abc\", \"def\", \"ghi\"]) == 3\nassert longestPalindromicConcatenation([\"ab\", \"abcddcba\", \"cd\", \"abcdedcba\"]) == 14\nassert longestPalindromicConcatenation([\"abcd\", \"dcba\", \"abcd\"]) == 8\nassert longestPalindromicConcatenation([\"a\", \"b\", \"c\", \"d\", \"a\", \"a\"]) == 5\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['integer', 'cost', 'divisor', 'operation', 'dynamic programming']", "prompt_tokens": 558, "total_tokens": 956, "completion_tokens": 398, "completion": "[Question 2]\n\nGiven a binary tree, write a function to find the minimum cost to insert a new node with a given integer value X into the tree. The cost of inserting a new node is calculated as the sum of all the integers on the path from the root to the closest quadrilateral node containing a divisor of X.\n\n[/Question 2]\n\n[Code 2]\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef minCostToInsert(root: TreeNode, X: int) -> int:\n    def findClosestQuadrilateralWithDivisor(node, divisors):\n        if node is None:\n            return float('inf')\n        if node.val % X == 0:\n            return 0\n        if any(node.val % d == 0 for d in divisors):\n            return node.val\n        return min(findClosestQuadrilateralWithDivisor(node.left, divisors), findClosestQuadrilateralWithDivisor(node.right, divisors))\n    \n    divisors = [d for d in range(1, X+1) if X % d == 0]\n    closestQuadrilateral = findClosestQuadrilateralWithDivisor(root, divisors)\n    return sum(d for d in divisors if closestQuadrilateral % d == 0)\n\n[/Code 2]\n\n[Asserts 2]\n\nroot = TreeNode(10)\nroot.left = TreeNode(5)\nroot.right = TreeNode(20)\nroot.left.left = TreeNode(4)\nroot.left.right = TreeNode(8)\nroot.right.left = TreeNode(15)\nroot.right.right = TreeNode(30)\n\nassert minCostToInsert(root, 6) == 18\nassert minCostToInsert(root, 7) == 7\nassert minCostToInsert(root, 12) == 36", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['modulus', 'division', 'large number', 'remainder', 'math']", "prompt_tokens": 448, "total_tokens": 855, "completion_tokens": 407, "completion": "[Question 2]\n\nYou are given a pile of booked chess bishops on a chessboard. Each bishop occupies a unique square. Your task is to determine the number of pairs of bishops that can attack each other. In chess, bishops can attack each other if they share the same diagonal.\n\n[/Question 2]\n\n[Code 2]\n\ndef countAttackingBishopPairs(booked_positions):\n    n = len(booked_positions)\n    pair_count = 0\n    diagonal_counts = {}\n\n    for i in range(n):\n        x1, y1 = booked_positions[i]\n        for j in range(i+1, n):\n            x2, y2 = booked_positions[j]\n            x_diff = abs(x2 - x1)\n            y_diff = abs(y2 - y1)\n            if x_diff == y_diff:\n                pair_count += 1\n                if (x_diff, y_diff) in diagonal_counts:\n                    diagonal_counts[(x_diff, y_diff)] += 1\n                else:\n                    diagonal_counts[(x_diff, y_diff)] = 1\n\n    return pair_count, diagonal_counts\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countAttackingBishopPairs([(1, 1), (3, 3), (2, 5), (5, 2)]) == (2, {(2, 2): 1, (3, 3): 1})\nassert countAttackingBishopPairs([(2, 2), (4, 4), (6, 6), (8, 8)]) == (6, {(2, 2): 3, (4, 4): 2, (6, 6): 1})\nassert countAttackingBishopPairs([(1, 1), (1, 3), (3, 1), (3, 3)]) == (4, {(2, 2): 2, (2, 0): 2})", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'maximize', 'minimum distance', 'permutation']", "prompt_tokens": 634, "total_tokens": 888, "completion_tokens": 254, "completion": "[Question 2]\n\nYou are given a string S consisting of only lowercase letters. You can perform a right rotation on the string which means moving the last character of the string to the beginning. Your task is to find the lowest lexicographically smallest string that can be obtained by performing right rotations on the string. If the string is empty, return an empty string.\n\nWrite a function to return the lowest lexicographically smallest string after performing right rotations.\n\n[/Question 2]\n\n[Code 2]\n\ndef lowestLexicographicallySmallestString(s: str) -> str:\n    if not s:\n        return \"\"\n\n    n = len(s)\n    res = s\n    for _ in range(n):\n        s = s[-1] + s[:-1]\n        res = min(res, s)\n    \n    return res\n\n[/Code 2]\n\n[Asserts 2]\n\nassert lowestLexicographicallySmallestString(\"abcde\")==\"abcde\"\nassert lowestLexicographicallySmallestString(\"cba\")==\"abc\"\nassert lowestLexicographicallySmallestString(\"z\")==\"z\"\nassert lowestLexicographicallySmallestString(\"\")==\"\"\nassert lowestLexicographicallySmallestString(\"acbd\")==\"abcd\"\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['string', 'ASCII', 'range', 'comparison', 'print']", "prompt_tokens": 516, "total_tokens": 790, "completion_tokens": 274, "completion": "[Question 2]\n\nYou are given a deque of strings and a range of ASCII values. Write a function to find and print the maximum size of unordered pairs of strings from the deque such that the ASCII value of the first character in the pair is within the given range.\n\n[/Question 2]\n\n[Code 2]\n\nfrom collections import deque\n\ndef maxUnorderedPairsSize(strings: deque[str], l: int, r: int) -> None:\n    max_size = 0\n    for i in range(len(strings)):\n        for j in range(i+1, len(strings)):\n            if l <= ord(strings[i][0]) <= r and l <= ord(strings[j][0]) <= r:\n                max_size = max(max_size, len(strings[i]) + len(strings[j]))\n    print(max_size)\n\n[/Code 2]\n\n[Asserts 2]\n\nstrings = deque([\"apple\", \"axe\", \"banana\", \"cat\", \"dog\", \"zebra\"])\nmaxUnorderedPairsSize(strings, 97, 122) == 10\nmaxUnorderedPairsSize(strings, 65, 90) == 0\nmaxUnorderedPairsSize(strings, 98, 99) == 10\nmaxUnorderedPairsSize(deque([]), 97, 122) == 0\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['math', 'iteration', 'concatenation', 'digits', 'ordering', 'smallest number', 'multiples']", "prompt_tokens": 513, "total_tokens": 813, "completion_tokens": 300, "completion": "[Question 2]\n\nYou are given a list of positive integers. Write a function to concatenate the integers in such a way that the resulting number is the smallest possible. For example, given the list [8, 56, 32, 12, 5], the smallest concatenated number is 12563281256.\n\n[/Question 2]\n\n[Code 2]\n\nfrom functools import cmp_to_key\n\ndef smallestConcatenatedNumber(nums: List[int]) -> int:\n    custom_sort = lambda a, b: int(str(a) + str(b)) - int(str(b) + str(a))\n    nums.sort(key=cmp_to_key(custom_sort))\n    return int(''.join(map(str, nums)))\n\n[/Code 2]\n\n[Asserts 2]\n\nassert(smallestConcatenatedNumber([8, 56, 32, 12, 5])) == 12563281256\nassert(smallestConcatenatedNumber([79, 82, 43, 27, 91])) == 2743279182\nassert(smallestConcatenatedNumber([5, 50, 56, 554, 53])) == 5053554556\nassert(smallestConcatenatedNumber([990, 9, 98, 979, 989])) == 9799899998\nassert(smallestConcatenatedNumber([420, 42, 423])) == 42342420\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['integer', 'sum', 'squares', 'consecutive', 'boolean', 'sqrt']", "prompt_tokens": 500, "total_tokens": 707, "completion_tokens": 207, "completion": "[Question 2]\n\nWrite a function to determine if a given integer is a perfect square and if the sum of its digits is also a perfect square.\n\n[/Question 2]\n\n[Code 2]\n\ndef isPerfectSquare(n: int) -> bool:\n    sqrt_n = int(sqrt(n))\n    return sqrt_n*sqrt_n == n\n\ndef digitSumIsPerfectSquare(n: int) -> bool:\n    digit_sum = 0\n    original_n = n\n    while n > 0:\n        digit_sum += (n % 10)\n        n = n // 10\n    return isPerfectSquare(digit_sum)\n\n[/Code 2]\n\n[Asserts 2]\n\nassert isPerfectSquare(16)==True\nassert isPerfectSquare(20)==False\nassert isPerfectSquare(25)==True\nassert digitSumIsPerfectSquare(81)==True\nassert digitSumIsPerfectSquare(101)==False\nassert digitSumIsPerfectSquare(36)==True\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['graph', 'nodes', 'edges', 'connect', 'cost', 'minimize', 'union-find', 'sorting']", "prompt_tokens": 827, "total_tokens": 1365, "completion_tokens": 538, "completion": "[Question 2]\n\nYou are given a list of tuples, where each tuple represents an edge in a graph. Each tuple contains two nodes and the cost to connect them. Your task is to write a function to minimize the total cost to connect all the nodes in the graph using the union-find algorithm.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List, Tuple\n\ndef find(parent: List[int], x: int) -> int:\n    if parent[x] == x:\n        return x\n    parent[x] = find(parent, parent[x])\n    return parent[x]\n\ndef union(parent: List[int], rank: List[int], x: int, y: int) -> None:\n    xroot = find(parent, x)\n    yroot = find(parent, y)\n    if rank[xroot] < rank[yroot]:\n        parent[xroot] = yroot\n    elif rank[xroot] > rank[yroot]:\n        parent[yroot] = xroot\n    else:\n        parent[yroot] = xroot\n        rank[xroot] += 1\n\ndef minCostConnect(edges: List[Tuple[int, int, int]], n: int) -> int:\n    parent = [i for i in range(n)]\n    rank = [0] * n\n    edges.sort(key=lambda x: x[2])\n    ans = 0\n    for u, v, w in edges:\n        if find(parent, u) != find(parent, v):\n            union(parent, rank, u, v)\n            ans += w\n    return ans\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minCostConnect([(0, 1, 10), (1, 2, 20), (2, 3, 30)], 4)==60\nassert minCostConnect([(0, 1, 10), (1, 2, 30), (2, 3, 5), (3, 0, 30), (2, 0, 32)], 4)==47\nassert minCostConnect([(0, 1, 10), (1, 2, 30), (2, 3, 5), (3, 0, 30), (2, 0, 3), (3, 1, 6)], 4)==34\nassert minCostConnect([(0, 1, 2), (1, 2, 3), (2, 3, 4), (3, 0, 6)], 4)==15\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'integer', 'division', 'sum', 'minimum', 'smallest', 'target']", "prompt_tokens": 628, "total_tokens": 915, "completion_tokens": 287, "completion": "[Question 2]\n\nGiven an array of integers, find the smallest integer that can be obtained by taking the sum of all elements encountered until a target sum is reached, and then dividing this sum by the number of elements encountered. If the target sum is not encountered, return -1.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\ndef smallestDivisorSum(arr: List[int], target: int) -> int:\n    totalSum = 0\n    count = 0\n    for num in arr:\n        totalSum += num\n        count += 1\n        if totalSum >= target:\n            return (totalSum // count)\n    return -1\n\n[/Code 2]\n\n[Asserts 2]\n\nassert smallestDivisorSum([1, 2, 3, 4, 5], 10) == 3\nassert smallestDivisorSum([3, 1, 2, 4, 7], 8) == 3\nassert smallestDivisorSum([5, 10, 15, 20], 30) == 10\nassert smallestDivisorSum([1, 1, 1, 1, 1], 10) == 3\nassert smallestDivisorSum([2, 3, 5, 7], 20) == -1\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'integers', 'modulo', 'remainder', 'parity', 'maximize']", "prompt_tokens": 591, "total_tokens": 882, "completion_tokens": 291, "completion": "[Question 2]\n\nYou are given an array of integers where some elements have been jumbled and are in a different order. Write a function to rearrange the array and maximize the remainder of the sum of elements with different parity when divided by a given integer K.\n\n[/Question 2]\n\n[Code 2]\n\ndef maximizeRemainder(arr, K):\n    odd_nums = [x for x in arr if x % 2 != 0]\n    even_nums = [x for x in arr if x % 2 == 0]\n    \n    odd_nums.sort(reverse=True)\n    even_nums.sort(reverse=True)\n    \n    remainder = 0\n    if odd_nums and even_nums:\n        remainder = (odd_nums[0] + even_nums[0]) % K\n    return remainder\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maximizeRemainder([1, 2, 3, 4, 5], 7) == 6\nassert maximizeRemainder([9, 12, 13, 8, 6, 11], 5) == 3\nassert maximizeRemainder([7, 3, 12, 5, 9], 6) == 3\nassert maximizeRemainder([2, 4, 6, 8, 10], 3) == 2\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['backtracking', 'subset', 'sum', 'maximum size', 'positive integers']", "prompt_tokens": 656, "total_tokens": 1026, "completion_tokens": 370, "completion": "[Question 2]\n\nYou are given a cubic equation and a target sum. Write a function to find the subset of positive integers that provides the best fit for the given sum with respect to the cubic equation using backtracking and differentiation.\n\n[/Question 2]\n\n[Code 2]\n\nimport itertools\n\ndef cubicEquation(x, a, b, c, d):\n    return a*x**3 + b*x**2 + c*x + d\n\ndef bestFitSubset(cubicCoefficients, targetSum):\n    bestSubset = []\n    maxVal = float('-inf')\n\n    for r in range(1, len(cubicCoefficients)+1):\n        for subset in itertools.combinations(cubicCoefficients, r):\n            subsetSum = sum(subset)\n            if subsetSum <= targetSum:\n                result = cubicEquation(subsetSum, *cubicCoefficients)\n                if result > maxVal and subsetSum <= targetSum:\n                    maxVal = result\n                    bestSubset = subset\n\n    return bestSubset\n\n[/Code 2]\n\n[Asserts 2]\n\nassert bestFitSubset([1, 2, 3, 4], 10) == (2, 3, 4)\nassert bestFitSubset([2, 4, 6, 8], 15) == (2, 4, 6)\nassert bestFitSubset([3, 3, 3, 3], 12) == (3, 3, 3, 3)\nassert bestFitSubset([1, 3, 5, 7], 8) == (1, 3, 4)\nassert bestFitSubset([2, 2, 3, 3], 10) == (2, 2, 2, 3)", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['perimeter', 'right-angled', 'triangles', 'count', 'geometry', 'math', 'calculation']", "prompt_tokens": 476, "total_tokens": 752, "completion_tokens": 276, "completion": "[Question 2]\n\nGiven a list of integers, write a function to count the number of right-angled triangles that can be formed using three consecutive elements from the list as the sides, and then determine if the count matches a specified OTP (One-Time Password) received.\n\n[/Question 2]\n\n[Code 2]\n\nfrom itertools import combinations\n\ndef countAndCheckOTP(nums: list, otp: int) -> bool:\n    count = 0\n    for triplet in combinations(nums, 3):\n        a, b, c = sorted(triplet)\n        if a**2 + b**2 == c**2:\n            count += 1\n    return count == otp\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countAndCheckOTP([3, 4, 5, 6, 8, 10, 12], 2) == True\nassert countAndCheckOTP([5, 12, 13, 7, 24, 25], 1) == True\nassert countAndCheckOTP([2, 3, 4, 5, 6, 7], 3) == False\nassert countAndCheckOTP([9, 40, 41, 8, 15, 17], 2) == False\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['geometry', 'triangle', 'equilateral', 'area', 'perimeter', 'math', 'formula', 'function', 'input']", "prompt_tokens": 607, "total_tokens": 848, "completion_tokens": 241, "completion": "[Question 2]\n\nWrite a function that takes three integers as input representing the side lengths of a triangle and returns the perimeter of the triangle using bitwise operations.\n\nThe perimeter of a triangle is the sum of its three sides. Use bitwise operations to calculate the perimeter without using the standard addition operator.\n\nFor example, for a triangle with side lengths 3, 4, and 5, the perimeter would be 12.\n\n[/Question 2]\n\n[Code 2]\n\ndef bitwise_triangle_perimeter(side1: int, side2: int, side3: int) -> int:\n    perimeter = side1 ^ side2 ^ side3\n    return perimeter\n\n[/Code 2]\n\n[Asserts 2]\n\nassert bitwise_triangle_perimeter(3, 4, 5) == 12\nassert bitwise_triangle_perimeter(5, 12, 13) == 28\nassert bitwise_triangle_perimeter(7, 24, 25) == 56\nassert bitwise_triangle_perimeter(8, 15, 17) == 40\nassert bitwise_triangle_perimeter(9, 40, 41) == 90\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['series', 'print', 'terms', 'number', 'sequence', 'pattern', 'increment', 'task']", "prompt_tokens": 519, "total_tokens": 766, "completion_tokens": 247, "completion": "[Question 2]\n\nGiven an unordered list of complex numbers, write a program to print the series of imaginary parts of the numbers till N terms and increment each term by a specific pattern.\n\n[/Question 2]\n\n[Code 2]\n\ndef print_imaginary_series(complex_list, N, increment):\n    series = []\n    for num in complex_list:\n        series.append(num.imag)\n    updated_series = [x + increment for x in series[:N]]\n    return updated_series\n\n[/Code 2]\n\n[Asserts 2]\n\nassert print_imaginary_series([2+3j, 4+5j, 6+7j, 8+9j], 3, 2)==[3, 5, 7]\nassert print_imaginary_series([1+2j, 3+4j, 5+6j, 7+8j], 2, 1)==[3, 5]\nassert print_imaginary_series([10+20j, 30+40j, 50+60j, 70+80j], 4, 5)==[25, 45, 65, 85]\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['positive number', 'distinct digits', 'integer', 'iteration', 'comparison', 'set']", "prompt_tokens": 489, "total_tokens": 690, "completion_tokens": 201, "completion": "[Question 2]\n\nWrite a function to take a positive integer N and iterate through all the numbers less than N. For each number, check if all its digits are distinct. If the digits are distinct, find the power of 2 closest to the number and print both the number and the closest power of 2.\n\n[/Question 2]\n\n[Code 2]\n\ndef findPowerOf2AndPrint(N: int) -> None:\n    for num in range(1, N):\n        digits = set(str(num))\n        if len(digits) == len(str(num)):\n            power = 1\n            while 2**power < num:\n                power += 1\n            print(f\"Number: {num}, Closest Power of 2: {2**(power-1)}\")\n\n[/Code 2]\n\n[Asserts 2]\n\n# Asserts can't be effectively provided for this type of output-printing function. The function can be tested by running it with different inputs.\n", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['python', 'string', 'capital letter', 'check', 'start']", "prompt_tokens": 419, "total_tokens": 593, "completion_tokens": 174, "completion": "[Question 2]\n\nWrite a Python function to check if a given string represents a valid update query for a database table.\n\n[/Question 2]\n\n[Code 2]\n\ndef isValidUpdateQuery(query: str) -> bool:\n\t# Assuming a valid update query should start with \"UPDATE\" and end with a semicolon\n\tif query.startswith(\"UPDATE\") and query.endswith(\";\"):\n\t\treturn True\n\telse:\n\t\treturn False\n\n[/Code 2]\n\n[Asserts 2]\n\nassert isValidUpdateQuery(\"UPDATE employees SET salary = salary * 1.1;\")==True\nassert isValidUpdateQuery(\"Select * from employees where id = 10\")==False\nassert isValidUpdateQuery(\"update employees set name='John';\")==False\nassert isValidUpdateQuery(\"update products set price = price + 10;\")==True\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['infinite sequence', 'number', 'pattern', 'mathematics', 'search', 'boolean']", "prompt_tokens": 485, "total_tokens": 709, "completion_tokens": 224, "completion": "[Question 2]\n\nYou are given an infinite sequence where each number represents a direction: 0 for North and 1 for South. You are also given a pattern as a string of 0s and 1s. Your task is to search for the given pattern in the infinite sequence and return True if the pattern exists; otherwise, return False. The sequence is 1-based indexed.\n\n[/Question 2]\n\n[Code 2]\n\ndef searchPattern(sequence: str, pattern: str) -> bool:\n    if len(pattern) > len(sequence):\n        return False\n    for i in range(len(sequence) - len(pattern) + 1):\n        if sequence[i:i + len(pattern)] == pattern:\n            return True\n    return False\n\n[/Code 2]\n\n[Asserts 2]\n\nassert searchPattern(\"0110110101\", \"1101\")==True\nassert searchPattern(\"0101010101\", \"1101\")==False\nassert searchPattern(\"0110110101\", \"0110110101\")==True\nassert searchPattern(\"1001001001\", \"100\")==True", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['string', 'manipulation', 'alternating', 'zeros', 'ones', 'removal', 'counting', 'iteration']", "prompt_tokens": 543, "total_tokens": 856, "completion_tokens": 313, "completion": "[Question 2]\n\nYou are given a list of employees with their hire date. Write a function to find the number of employees hired in the alternating manner of vowels and consonants in their names.\n\n[/Question 2]\n\n[Code 2]\n\nfrom datetime import datetime\n\ndef is_alternating(name: str) -> bool:\n    vowels = set(\"aeiouAEIOU\")\n    alternating = [name[0] in vowels]\n    for i in range(1, len(name)):\n        if (name[i] in vowels and not alternating[-1]) or (name[i] not in vowels and alternating[-1]):\n            alternating.append(not alternating[-1])\n        else:\n            return False\n    return True\n\ndef countAlternatingHires(employees: dict) -> int:\n    alternating_hires = 0\n    for hire_date in employees.values():\n        if is_alternating(hire_date.strftime(\"%B\")):\n            alternating_hires += 1\n    return alternating_hires\n\n[/Code 2]\n\n[Asserts 2]\n\nemployees = {\n    \"John\": datetime(2022, 5, 10),\n    \"Alice\": datetime(2022, 3, 15),\n    \"Bob\": datetime(2022, 4, 20),\n    \"Eve\": datetime(2021, 6, 25),\n    \"Oscar\": datetime(2022, 7, 30)\n}\n\nassert countAlternatingHires(employees) == 2\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['math', 'binary search', 'maximum', 'integer', 'sum']", "prompt_tokens": 472, "total_tokens": 648, "completion_tokens": 176, "completion": "[Question 2]\n\nGiven a positive integer N, the task is to find the Nth harmonic number (the sum of the reciprocals of the first N natural numbers).\n\n[/Question 2]\n\n[Code 2]\n\ndef nthHarmonicNumber(N: int) -> float:\n    if N == 1:\n        return 1\n    else:\n        return nthHarmonicNumber(N-1) + 1/N\n\n[/Code 2]\n\n[Asserts 2]\n\nassert nthHarmonicNumber(1)==1\nassert nthHarmonicNumber(2)==1.5\nassert nthHarmonicNumber(3)==1.8333333333333333\nassert nthHarmonicNumber(4)==2.083333333333333\nassert nthHarmonicNumber(5)==2.283333333333333\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['integer', 'permutation', 'decreasing', 'increasing', 'dynamic programming']", "prompt_tokens": 499, "total_tokens": 760, "completion_tokens": 261, "completion": "[Question 2]\n\nYou are given an integer N representing the flow of a uniform system. The system can have a permutation of N in such a way that the permutation is first decreasing then increasing. Find the count of such permutations for the given flow N.\n\n[/Question 2]\n\n[Code 2]\n\ndef countUniformPermutations(N):\n    if N < 3:\n        return 0\n    dp = [[0 for i in range(N + 1)] for j in range(N + 1)]\n    for i in range(1, N + 1):\n        dp[1][i] = 1\n    for i in range(3, N + 1):\n        for j in range(2, N + 1):\n            for k in range(1, j):\n                dp[i][j] += dp[i - 1][k]\n    ans = 0\n    for i in range(1, N + 1):\n        ans += dp[N][i]\n    return ans\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countUniformPermutations(3)==5\nassert countUniformPermutations(4) == 14\nassert countUniformPermutations(5) == 42\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'search', 'unsorted', 'minimize', 'comparisons', 'index']", "prompt_tokens": 474, "total_tokens": 656, "completion_tokens": 182, "completion": "[Question 2]\n\nGiven an unsorted array containing the heights of people, we need to find the index of the tallest person in the array while minimizing the number of comparisons.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef findIndexOfTallestPerson(arr: List[int]) -> int:\n    max_height = float('-inf')\n    max_index = -1\n    for i in range(len(arr)):\n        if arr[i] > max_height:\n            max_height = arr[i]\n            max_index = i\n    return max_index\n\n[/Code 2]\n\n[Asserts 2]\n\nassert findIndexOfTallestPerson([165, 172, 158, 180, 169]) == 3\nassert findIndexOfTallestPerson([150, 155, 160, 140, 149]) == 2\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['string', 'concatenation', 'count', 'max', 'occurrences', 'array', 'order']", "prompt_tokens": 586, "total_tokens": 944, "completion_tokens": 358, "completion": "[Question 2]\n\nGiven an array of strings, write a function to find the string with the maximum number of occurrences of its own substring when concatenated with itself. For example, in the string \"ABABAB\", the substring \"AB\" appears 3 times when concatenated with itself, resulting in \"ABABABABABAB\". You need to find the string in the array that maximizes this occurrence count.\n\n[/Question 2]\n\n[Code 2]\n\nfrom collections import Counter\n\ndef maxSubstringOccurrences(strings):\n    def countOccurrences(s, sub):\n        count = 0\n        i = s.find(sub)\n        while i != -1:\n            count += 1\n            i = s.find(sub, i + 1)\n        return count\n\n    max_occurrences = 0\n    max_string = \"\"\n    \n    for s in strings:\n        occurrences = countOccurrences(s + s, s)\n        if occurrences > max_occurrences:\n            max_occurrences = occurrences\n            max_string = s\n    \n    return max_string, max_occurrences\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maxSubstringOccurrences([\"ABABAB\", \"AABBBAAA\", \"CCCC\"]) == (\"ABABAB\", 3)\nassert maxSubstringOccurrences([\"XYXYXY\", \"ZZZ\", \"ABCDEFG\"]) == (\"XYXYXY\", 3)\nassert maxSubstringOccurrences([\"AAA\", \"BB\", \"AABBAABB\"]) == (\"AABBAABB\", 4)\nassert maxSubstringOccurrences([\"AAAA\", \"AAAAA\", \"A\"]) == (\"AAAAA\", 5)\nassert maxSubstringOccurrences([\"123123123\", \"123\", \"123123\"]) == (\"123123123\", 3)\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['positive number', 'distinct digits', 'integer', 'iteration', 'comparison', 'set']", "prompt_tokens": 482, "total_tokens": 774, "completion_tokens": 292, "completion": "[Question 2]\n\nYou are given a positive integer N. Generate N pairs of integers (a, b), where a and b are both positive integers and both a and b have distinct digits. Ensure that the pairs are distinct and unique. Return these pairs as a set.\n\nWrite a function to generate and return N pairs of (a, b) such that a and b have distinct digits and all pairs are unique.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import Set, Tuple\n\ndef generateDistinctDigitPairs(N: int) -> Set[Tuple[int, int]]:\n    distinct_pairs = set()\n    count = 0\n    while (count < N):\n        a = random.randint(10, 99)\n        b = random.randint(10, 99)\n        if(len(set(str(a))) == len(str(a)) and len(set(str(b))) == len(str(b)) and (a, b) not in distinct_pairs and (b, a) not in distinct_pairs):\n            distinct_pairs.add((a, b))\n            count += 1\n    return distinct_pairs\n\n[/Code 2]\n\n[Asserts 2]\n\npair_set = generateDistinctDigitPairs(5)\nassert len(pair_set) == 5\nfor pair in pair_set:\n    assert len(set(str(pair[0]))) == len(str(pair[0]))\n    assert len(set(str(pair[1]))) == len(str(pair[1]))", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['integer', 'range', 'sum', 'digits', 'counting']", "prompt_tokens": 515, "total_tokens": 1147, "completion_tokens": 632, "completion": "[Question 2]\n\nYou are given a chessboard represented by an 8x8 grid. Each cell of the board is assigned an integer value. The task is to count the number of cells in the chessboard whose sum of digits is within a specified range.\n\n[/Question 2]\n\n[Code 2]\n\ndef sumOfDigits(num: int) -> int:\n    sum = 0\n    while num > 0:\n        sum += num % 10\n        num = num // 10\n    return sum\n\ndef countCellsWithSumOfDigitsInRange(board: List[List[int]], lower: int, upper: int) -> int:\n    count = 0\n    for row in board:\n        for cell in row:\n            if lower <= sumOfDigits(cell) <= upper:\n                count += 1\n    return count\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countCellsWithSumOfDigitsInRange([[23, 45, 12, 67, 89, 34, 56, 78],\n                                         [99, 100, 101, 102, 103, 104, 105, 106],\n                                         [57, 48, 39, 30, 21, 12, 3, 4],\n                                         [10, 20, 30, 40, 50, 60, 70, 80],\n                                         [11, 22, 33, 44, 55, 66, 77, 88],\n                                         [90, 91, 92, 93, 94, 95, 96, 97],\n                                         [77, 78, 79, 80, 81, 82, 83, 84],\n                                         [92, 93, 94, 95, 96, 97, 98, 99]], 6, 8) == 10\n\nassert countCellsWithSumOfDigitsInRange([[123, 456, 789, 101, 202, 303, 404, 505],\n                                         [111, 222, 333, 444, 555, 666, 777, 888],\n                                         [999, 1000, 1001, 1002, 1003, 1004, 1005, 1006],\n                                         [907, 806, 705, 604, 503, 402, 301, 200],\n                                         [100, 200, 300, 400, 500, 600, 700, 800],\n                                         [628, 538, 448, 358, 268, 178, 88, 98],\n                                         [1008, 1009, 1010, 1011, 1012, 1013, 1014, 1015],\n                                         [143, 254, 365, 476, 587, 698, 809, 910]], 5, 7) == 20", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['integer', 'sequence', 'product', 'largest', 'smallest', 'digit', 'addition', 'loop', 'while', 'function']", "prompt_tokens": 622, "total_tokens": 953, "completion_tokens": 331, "completion": "[Question 2]\n\nYou are given a sequence of integers. Write a function to find the product of the largest and smallest digit of each integer in the sequence and add all the products together to get a final sum.\n\nFor example, given the sequence [123, 45, 789], the product of the largest and smallest digit for each integer is (3*1 + 5*4 + 9*7) = 3 + 20 + 63, which equals 86.\n\nWrite a function to compute this sum for any given sequence of integers.\n\n[/Question 2]\n\n[Code 2]\n\ndef computeSumOfProducts(sequence: List[int]) -> int:\n    total_sum = 0\n    for num in sequence:\n        largest = -1\n        smallest = 10\n        temp = num\n        while temp > 0:\n            digit = temp % 10\n            largest = max(largest, digit)\n            smallest = min(smallest, digit)\n            temp = temp // 10\n        total_sum += (largest * smallest)\n    return total_sum\n\n[/Code 2]\n\n[Asserts 2]\n\nassert computeSumOfProducts([123, 45, 789]) == 86\nassert computeSumOfProducts([563, 874, 291]) == 70\nassert computeSumOfProducts([777, 888, 999]) == 189\nassert computeSumOfProducts([111, 222, 333]) == 18\nassert computeSumOfProducts([876, 543, 219]) == 77\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'integer', 'difference', 'insert', 'remove', 'count', 'minimum', 'adjacent', 'elements', 'occurrences']", "prompt_tokens": 685, "total_tokens": 1025, "completion_tokens": 340, "completion": "[Question 2]\n\nGiven an array of integers, your task is to find the minimum count of occurrences that need to be removed (or inserted) from the array in order to form a consecutive set of numbers. A consecutive set of numbers is a set of integers where no two numbers are more than 1 apart. Return the minimum count of occurrences that need to be removed or inserted to form a consecutive set of numbers.\n\nFor example, given the array [6, 1, 3, 5, 7, 9], the minimum count of occurrences that need to be removed or inserted to form a consecutive set of numbers is 2 (one occurrence of 2 needs to be inserted and one occurrence of 4 needs to be inserted).\n\n[/Question 2]\n\n[Code 2]\n\ndef minOccurrenceToRemoveOrInsert(arr: List[int]) -> int:\n    arr.sort()\n    prev = arr[0]\n    count = 0\n    for num in arr[1:]:\n        if num - prev > 1:\n            count += num - prev - 1\n        prev = num\n    return count\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minOccurrenceToRemoveOrInsert([6, 1, 3, 5, 7, 9]) == 2\nassert minOccurrenceToRemoveOrInsert([-2, 0, 2, 3, 6, 8, 9, 10]) == 0\nassert minOccurrenceToRemoveOrInsert([1, 3, 5, 7, 9, 11]) == 0\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['graph', 'adjacency matrix', 'directed', 'universal sink', 'vertex', 'in-degree', 'out-degree', 'index']", "prompt_tokens": 686, "total_tokens": 1074, "completion_tokens": 388, "completion": "[Question 2]\n\nGiven a directed graph represented by an adjacency matrix, write a function to find the smallest number that can be obtained as the sum of path sums from a vertex to all its right children. If there is no universal sink in the graph, return -1.\n\n[/Question 2]\n\n[Code 2]\n\ndef smallestRightChildPathSum(graph: List[List[int]]) -> int:\n    n = len(graph)\n    result = float('inf')\n    u_sink = -1\n\n    for i in range(n):\n        flag1 = True\n        flag2 = False\n        for j in range(n):\n            if graph[i][j] == 1:\n                flag1 = False\n            if graph[j][i] == 1:\n                flag2 = True\n        if flag1 and not flag2:\n            u_sink = i\n\n    if u_sink == -1:\n        return -1\n\n    for i in range(n):\n        if graph[u_sink][i] == 1:\n            result = min(result, u_sink + i)\n\n    return result\n\n[/Code 2]\n\n[Asserts 2]\n\nassert smallestRightChildPathSum([[0, 1, 0], [0, 0, 0], [0, 1, 0]]) == 1\nassert smallestRightChildPathSum([[0, 1, 0], [0, 0, 1], [0, 0, 0]]) == 1\nassert smallestRightChildPathSum([[0, 1, 0], [0, 0, 1], [0, 1, 0]]) == 2\nassert smallestRightChildPathSum([[0, 0, 0], [0, 0, 0], [1, 1, 0]]) == -1\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['rectangle', 'circumscribed', 'area', 'maximum', 'diagonal']", "prompt_tokens": 556, "total_tokens": 956, "completion_tokens": 400, "completion": "[Question 2]\n\nYou are given a list of coordinates representing intermediate nodes of a triangular field. Your task is to find the maximum area of a circumscribed rectangle around the triangular field.\n\nWrite a program to find the maximum area of a circumscribed rectangle and the coefficient of the multiplication of the lengths of its diagonal.\n\n[/Question 2]\n\n[Code 2]\n\ndef maxAreaCircumscribedRectangle(coordinates: List[Tuple[int, int]]) -> Tuple[int, float]:\n    x_coordinates = [coord[0] for coord in coordinates]\n    y_coordinates = [coord[1] for coord in coordinates]\n    max_x, min_x = max(x_coordinates), min(x_coordinates)\n    max_y, min_y = max(y_coordinates), min(y_coordinates)\n    length = max_x - min_x\n    width = max_y - min_y\n    area = length * width\n    diagonal = (length**2 + width**2)**0.5\n    coefficient = length * width * diagonal\n    return area, coefficient\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maxAreaCircumscribedRectangle([(1, 2), (3, 8), (5, 4)])==(12, 36.0)\nassert maxAreaCircumscribedRectangle([(8, 5), (3, 6), (10, 12)])==(35, 84.0)\nassert maxAreaCircumscribedRectangle([(2, 4), (7, 5), (11, 8)])==(45, 96.0)\nassert maxAreaCircumscribedRectangle([(5, 3), (9, 7), (13, 10)])==(35, 84.0)\nassert maxAreaCircumscribedRectangle([(3, 2), (7, 4), (9, 12)])==(24, 60.0)\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'index', 'equality', 'iteration', 'comparison', 'minimum']", "prompt_tokens": 525, "total_tokens": 768, "completion_tokens": 243, "completion": "[Question 2]\n\nWrite a function to find the in-place minimum element in an array, starting from a given index and iterating through the array.\n\n[/Question 2]\n\n[Code 2]\n\ndef findInPlaceMin(arr, start_index):\n    min_element = arr[start_index]\n    min_index = start_index\n    for i in range(start_index, len(arr)):\n        if arr[i] < min_element:\n            min_element = arr[i]\n            min_index = i\n    return min_index\n\n[/Code 2]\n\n[Asserts 2]\n\nassert findInPlaceMin([3, 5, 2, 8, 1, 7], 2) == 4\nassert findInPlaceMin([1, 4, 2, 7, 5, 9, 3], 3) == 6\nassert findInPlaceMin([10, 20, 5, 8, 12, 5], 1) == 2\nassert findInPlaceMin([1, 2, 3, 4, 5, 6], 0) == 0\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'subsequence', 'GCD', 'maximize', 'adjacent pairs', 'sum']", "prompt_tokens": 604, "total_tokens": 837, "completion_tokens": 233, "completion": "[Question 2]\n\nGiven an array A[] of integers, the task is to find the maximum sum of a subsequence such that no two elements in the subsequence are adjacent.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n  \ndef maxSumNoAdjacent(A: List[int]) -> int:\n    incl = 0\n    excl = 0\n    \n    for i in A:\n        new_excl = max(incl, excl)\n        \n        incl = excl + i\n        excl = new_excl\n        \n    return max(incl, excl)\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maxSumNoAdjacent([3, 2, 7, 10]) == 13\nassert maxSumNoAdjacent([3, 2, 5, 10, 7]) == 15\nassert maxSumNoAdjacent([5, 5, 10, 100, 10, 5]) == 110\nassert maxSumNoAdjacent([1, 2, 3, 4, 5, 6]) == 12\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['string', 'HTML', 'parsing', 'remove', 'tags', 'content']", "prompt_tokens": 544, "total_tokens": 795, "completion_tokens": 251, "completion": "[Question 2]\n\nWrite a Python function to parse a given string representing a grid of numbers separated by commas. The function should then remove all the HTML tags from the content and return the approximated modulus of each number in the grid.\n\n[/Question 2]\n\n[Code 2]\n\ndef parse_and_modulus(grid_content: str) -> list:\n    cleaned_content = ''.join(c if c not in \"<>\" else ' ' for c in grid_content)\n    numbers = [int(x) for x in cleaned_content.split(',') if x.strip()]\n    modulus_numbers = [abs(x) % 23 for x in numbers]\n    return modulus_numbers\n\n[/Code 2]\n\n[Asserts 2]\n\nassert parse_and_modulus(\"<div>23, 45, 67, 89</div>\") == [0, 22, 1, 20]\nassert parse_and_modulus(\"<p>12, 34, 56, 78, 90</p>\") == [12, 11, 10, 5, 18]\nassert parse_and_modulus(\"<span>33, 44, 55</span>\") == [10, 21, 9]\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['series', 'math', 'sequence', 'multiplication', 'addition']", "prompt_tokens": 550, "total_tokens": 823, "completion_tokens": 273, "completion": "[Question 2]\n\nYou are given a sequence of positive integers. Write a function to find the sum of the prime factors of each number in the sequence.\n\nWrite a function `sumOfPrimeFactors` that takes a sequence of positive integers as input and returns the sum of prime factors of each number in the sequence.\n\n[/Question 2]\n\n[Code 2]\n\ndef sumOfPrimeFactors(sequence):\n    def isPrime(n):\n        if n <= 1:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    def primeFactors(n):\n        factors = []\n        divisor = 2\n        while n > 1:\n            while n % divisor == 0:\n                factors.append(divisor)\n                n //= divisor\n            divisor += 1\n        return sum(set(factors))\n\n    return sum(primeFactors(num) for num in sequence)\n\n[/Code 2]\n\n[Asserts 2]\n\nassert sumOfPrimeFactors([10, 15, 21]) == 17\nassert sumOfPrimeFactors([3, 7, 13, 17]) == 40\nassert sumOfPrimeFactors([18, 24, 30, 36]) == 26", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'integers', 'bitwise', 'OR', 'even', 'odd', 'count', 'pairs', 'operation']", "prompt_tokens": 555, "total_tokens": 967, "completion_tokens": 412, "completion": "[Question 2]\n\nYou are given an n x n grid representing a chessboard, where each cell of the grid can be either active or inactive. Two cells are considered a pair if they are in the same row, column, or diagonal. Write a program to count the total number of pairs of active cells that result in an even number when performing a bitwise OR operation on the pair.\n\n[/Question 2]\n\n[Code 2]\n\ndef countEvenBitwisePairs(grid: List[List[int]]) -> int:\n    n = len(grid)\n    count = 0\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                for r in range(i+1, n):\n                    if grid[r][j] == 1:\n                        count += 1\n                for c in range(j+1, n):\n                    if grid[i][c] == 1:\n                        count += 1\n                for d in range(1, n):\n                    if i+d<n and j+d<n and grid[i+d][j+d]==1:\n                        count += 1\n                    if i+d<n and j-d>=0 and grid[i+d][j-d]==1:\n                        count += 1\n    return count\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countEvenBitwisePairs([[1, 0, 1], [1, 1, 0], [0, 1, 1]]) == 4\nassert countEvenBitwisePairs([[1, 1, 0], [0, 1, 0], [1, 0, 1]]) == 6\nassert countEvenBitwisePairs([[1, 0, 0], [0, 1, 0], [0, 0, 1]]) == 0\nassert countEvenBitwisePairs([[1, 1], [1, 1]]) == 6\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['string', 'camel case', 'uppercase', 'lowercase', 'count']", "prompt_tokens": 466, "total_tokens": 750, "completion_tokens": 284, "completion": "[Question 2]\n\nWrite a function that takes a string as input and returns a new string with the characters reversed and the case (uppercase/lowercase) of all alphabets masked as per the given rules. For masking, if a character is in lowercase, it should be converted to uppercase, and if it is in uppercase, it should be converted to lowercase. Additionally, count the number of uppercase characters in the original string and return it as well.\n\n[/Question 2]\n\n[Code 2]\n\ndef reverseAndMask(s: str) -> (str, int):\n    count = sum(1 for char in s if char.isupper())\n    masked_string = \"\".join(char.lower() if char.isupper() else char.upper() for char in reversed(s))\n    return masked_string, count\n\n[/Code 2]\n\n[Asserts 2]\n\nassert reverseAndMask(\"HelloWorld\") == (\"DLROwOLLEh\", 5)\nassert reverseAndMask(\"ThisisAString\") == (\"GNIRTSAsIsiht\", 3)\nassert reverseAndMask(\"UPPERlower\") == (\"REWOLreppu\", 5)\nassert reverseAndMask(\"rEVERSEcASE\") == (\"EsacEsreveR\", 7)\nassert reverseAndMask(\"CamelCase\") == (\"ESACemalc\", 4)\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'integer', 'bitwise XOR', 'subsequences', 'count']", "prompt_tokens": 519, "total_tokens": 733, "completion_tokens": 214, "completion": "[Question 2]\n\nGiven an array of integers, the task is to count the total number of subsequences where each integer is bitwise XOR-ed with a letter shift and then appended to a new array.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef countXorLetterShiftSubsequences(arr: List[int]) -> int:\n    result = []\n    for num in arr:\n        result.append(chr(ord('a') + (num ^ 1)))\n    return len(result)\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countXorLetterShiftSubsequences([1, 2, 3, 4, 5]) == 5\nassert countXorLetterShiftSubsequences([5, 3, 7, 8]) == 4\nassert countXorLetterShiftSubsequences([2, 4, 6, 8, 10]) == 5\nassert countXorLetterShiftSubsequences([4, 9, 12, 15]) == 4", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['string', 'minimum', 'cost', 'dynamic-programming', 'sum', 'characters', 'deletion']", "prompt_tokens": 709, "total_tokens": 982, "completion_tokens": 273, "completion": "[Question 2]\n\nYou are given a binary string s, which contains only the characters '0' and '1'. Your task is to find the minimum cost to delete all characters such that there are no consecutive characters of the same type in the resulting string.\n\nFor example, given the string s = \"1001001\", the minimum cost to delete all characters is 2. One possible way is to delete the 1st and the 2nd characters, resulting in the string \"01001\".\n\nWrite a function to calculate the minimum cost to achieve the desired string.\n\n[/Question 2]\n\n[Code 2]\n\ndef minCostToDeleteConsecutive(s: str) -> int:\n    n = len(s)\n    count = 0\n    for i in range(1, n):\n        if s[i] == s[i - 1]:\n            count += 1\n    return count\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minCostToDeleteConsecutive(\"1001001\") == 2\nassert minCostToDeleteConsecutive(\"1010101\") == 0\nassert minCostToDeleteConsecutive(\"11111\") == 4\nassert minCostToDeleteConsecutive(\"000000\") == 5\nassert minCostToDeleteConsecutive(\"11001100\") == 4\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['string', 'lexicographically', 'smallest', 'character', 'alphabet', 'comparison', 'iteration', 'conditional']", "prompt_tokens": 594, "total_tokens": 880, "completion_tokens": 286, "completion": "[Question 2]\n\nYou are given a list of strings. Write a function to find the lexicographically smallest string that can be obtained by concatenating all the strings in any order.\n\nHowever, there is a restriction: \nThe concatenation should be done in such a way that the first character of each string is lexicographically ordered and, if there is a tie, the second character is then considered.\n\nWrite a function to accomplish this and assume valid input is given.\n\n[/Question 2]\n\n[Code 2]\n\nfrom itertools import permutations\n\ndef smallestLexicographicallyString(strings: List[str]) -> str:\n    result = float('inf')\n    \n    for perm in permutations(strings):\n        current = ''.join(perm)\n        if current < result:\n            result = current\n    \n    return result\n\n[/Code 2]\n\n[Asserts 2]\n\nassert smallestLexicographicallyString([\"hello\", \"how\", \"are\", \"you\"]) == \"arehellohowyou\"\nassert smallestLexicographicallyString([\"abc\", \"def\", \"ghi\"]) == \"abcdefghi\"\nassert smallestLexicographicallyString([\"aaa\", \"aab\"]) == \"aaaaab\"\nassert smallestLexicographicallyString([\"cat\", \"dog\", \"apple\"]) == \"applecatdog\"\nassert smallestLexicographicallyString([\"zoo\", \"hello\", \"world\"]) == \"helloworldzoo\"\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['string', 'parentheses', 'stack', 'indices', 'removal', 'empty string']", "prompt_tokens": 497, "total_tokens": 724, "completion_tokens": 227, "completion": "[Question 2]\n\nYou are given a string S consisting of only lowercase alphabetical characters. You need to transform the string in the following way:\n- If a character is not less than the last character in the new string, append it to the new string.\n- If a character is less than or equal to the last character in the new string, remove the last character from the new string.\n- At the end of the transformation, return the new string or an empty string if there are no characters remaining.\n\n[/Question 2]\n\n[Code 2]\n\ndef transformString(s: str) -> str:\n    stack = []\n    for char in s:\n        while stack and char <= stack[-1]:\n            stack.pop()\n        stack.append(char)\n    return ''.join(stack)\n\n[/Code 2]\n\n[Asserts 2]\n\nassert transformString(\"abac\") == \"c\"\nassert transformString(\"abcde\") == \"e\"\nassert transformString(\"zyx\") == \"\"\nassert transformString(\"aaaabbbb\") == \"b\"\nassert transformString(\"\") == \"\"\nassert transformString(\"hello\") == \"o\"", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'sort', 'descending', 'prime', 'integer', 'function', 'boolean', 'iteration']", "prompt_tokens": 590, "total_tokens": 842, "completion_tokens": 252, "completion": "[Question 2]\n\nWrite a function to check if an array of integers contains any prime numbers. If it does, return True; otherwise, return False. Additionally, sort the array in descending order.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef isPrime(num: int) -> bool:\n    if num <= 1:\n        return False\n    for i in range(2, int(num ** 0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef checkPrimeAndSortDescending(arr: List[int]) -> bool:\n    prime_present = False\n    for i in range(len(arr)):\n        if isPrime(arr[i]):\n            prime_present = True\n            break\n    arr.sort(reverse=True)\n    return prime_present\n\n[/Code 2]\n\n[Asserts 2]\n\nassert checkPrimeAndSortDescending([6, 8, 12, 15, 20])==False\nassert checkPrimeAndSortDescending([6, 17, 12, 15, 20])==True\nassert checkPrimeAndSortDescending([29, 11, 7, 3])==True\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['sequence', 'sum', 'previous', 'size', 'print', 'integer']", "prompt_tokens": 561, "total_tokens": 783, "completion_tokens": 222, "completion": "[Question 2]\n\nIn a chemistry competition, there are N participants. The scores of the participants are stored in a file where each line contains the score of the participant. Write a program to find the winner of the competition and print the winner's score. The file size is too large to read into memory at once. Can you approach this problem with space optimization in mind?\n\n[/Question 2]\n\n[Code 2]\n\ndef findWinner(filePath: str) -> int:\n    winner_score = float('-inf')\n    with open(filePath, 'r') as file:\n        for line in file:\n            score = int(line.strip())\n            if score > winner_score:\n                winner_score = score\n    return winner_score\n\n[/Code 2]\n\n[Asserts 2]\n\n# Create a sample file\nwith open('chemistry_scores.txt', 'w') as file:\n    file.write(\"90\\n\")\n    file.write(\"85\\n\")\n    file.write(\"95\\n\")\n    file.write(\"88\\n\")\n\nassert findWinner('chemistry_scores.txt') == 95\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['matrix', 'index', 'cell', 'sum', 'cost', 'path', 'dimension', 'integer']", "prompt_tokens": 571, "total_tokens": 885, "completion_tokens": 314, "completion": "[Question 2]\n\nGiven a matrix mat[][] of dimensions N x N and two integers X1, Y1, X2, Y2 which represents the indices of two cells. The task is to find the sum of costs of all the paths from the cell with indexes (X1, Y1) to the cell with indexes (X2, Y2).\n\n[/Question 2]\n\n[Code 2]\n\ndef getPathSum(mat, N, X1, Y1, X2, Y2):\n\tsum = 0\n\tfor i in range(X1, X2+1):\n\t\tfor j in range(Y1, Y2+1):\n\t\t\tsum += mat[i][j]\n\treturn sum\n\n[/Code 2]\n\n[Asserts 2]\n\nassert getPathSum([[4, 2, 1],\n\t\t\t\t[4, 8, 3],\n\t\t\t\t[9, 9, 5]], 3, 0, 0, 1, 1)==18\nassert getPathSum([[4, 2, 1],\n\t\t\t\t[4, 8, 3],\n\t\t\t\t[9, 9, 5]], 3, 1, 1, 2, 2)==25\nassert getPathSum([[1, 2, 3],\n\t\t\t\t[4, 5, 6],\n\t\t\t\t[7, 8, 9]], 3, 0, 0, 2, 2)==45\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['number', 'format', 'conversion', 'count', 'digit', 'step', 'final', 'performing']", "prompt_tokens": 649, "total_tokens": 977, "completion_tokens": 328, "completion": "[Question 2]\n\nYou are given a list of numbers in the icositrigonal format. Perform a step to re-order the list and remove any duplicates. Write a program to find the final list after performing the given number of steps.\n\n\nFor example, if the initial list is [1, 2, 2, 1, 3, 4], performing one step involves re-ordering the list and removing duplicates, resulting in the list [1, 2, 3, 4].\n\n\nWrite a program to find the final list after performing \u2018n\u2019 steps.\n\n[/Question 2]\n\n[Code 2]\n\ndef perform_steps(lst: list, n: int) -> list:\n    for _ in range(n):\n        lst = list(dict.fromkeys(lst))\n        lst.sort()\n    return lst\n\n[/Code 2]\n\n[Asserts 2]\n\nassert perform_steps([1, 2, 2, 1, 3, 4], 1) == [1, 2, 3, 4]\nassert perform_steps([5, 3, 2, 5, 8, 2, 1], 2) == [1, 2, 3, 5, 8]\nassert perform_steps([9, 9, 9, 9, 9], 3) == [9]\nassert perform_steps([4, 0, 7, 4, 2, 6, 7], 4) == [0, 2, 4, 6, 7]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['sequence', 'sum', 'function', 'compute', 'numbers', 'loop', 'iteration']", "prompt_tokens": 449, "total_tokens": 719, "completion_tokens": 270, "completion": "[Question 2]\n\nSuppose you are given a tree data structure where each node represents a prisoner and has a modifier associated with it. The modifier represents the probability of heads occurring in a coin toss for that prisoner. Write a function to compute the expected sum of the numbers of heads obtained from the coin toss for all the prisoners in the tree structure.\n\n[/Question 2]\n\n[Code 2]\n\nclass TreeNode:\n    def __init__(self, modifier, children=[]):\n        self.modifier = modifier\n        self.children = children\n        \ndef expected_sum_of_heads(root):\n    if root is None:\n        return 0\n    \n    sum = root.modifier\n    for child in root.children:\n        sum += expected_sum_of_heads(child)\n    return sum\n\n[/Code 2]\n\n[Asserts 2]\n\n# Create a sample tree structure\n#      1\n#     / \\\n#    0.5 0.7\n#       / | \\\n#     0.3 0.9 0.4\nroot = TreeNode(1, [TreeNode(0.5), TreeNode(0.7, [TreeNode(0.3), TreeNode(0.9), TreeNode(0.4)])])\n\nassert expected_sum_of_heads(root) == 3.8\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'subarray', 'length', 'binary', 'counting', 'equal']", "prompt_tokens": 649, "total_tokens": 926, "completion_tokens": 277, "completion": "[Question 2]\n\nGiven a binary tree, count the number of subtrees with equal number of 0s and 1s.\n\n[/Question 2]\n\n[Code 2]\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef countSubtreesWithEqualZeroAndOne(root: TreeNode) -> int:\n    def helper(node):\n        nonlocal count\n        if not node:\n            return 0\n        left = helper(node.left)\n        right = helper(node.right)\n        subtree_sum = left + right + node.val\n        if subtree_sum == 0:\n            count += 1\n        return subtree_sum\n    count = 0\n    helper(root)\n    return count\n\n[/Code 2]\n\n[Asserts 2]\n\ntree = TreeNode(1, TreeNode(0, TreeNode(1), TreeNode(1)), TreeNode(0, TreeNode(1), TreeNode(1)))\nassert countSubtreesWithEqualZeroAndOne(tree) == 5\n\ntree = TreeNode(0, TreeNode(0, TreeNode(0), TreeNode(0)), TreeNode(1, TreeNode(1), TreeNode(1)))\nassert countSubtreesWithEqualZeroAndOne(tree) == 4\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'integers', 'product', 'first digit', 'function']", "prompt_tokens": 481, "total_tokens": 789, "completion_tokens": 308, "completion": "[Question 2]\n\nGiven a deterministic finite automaton (DFA) represented by an adjacency matrix as an array of arrays, write a function to perform a depth-first search (DFS) to find a state with the greatest value and return its first digit.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef findGreatestStateFirstDigit(dfa: List[List[int]]) -> int:\n    max_value = -float('inf')\n    state_with_max_value = -1\n    for i in range(len(dfa)):\n        if max(dfa[i]) > max_value:\n            max_value = max(dfa[i])\n            state_with_max_value = i\n    return int(str(state_with_max_value)[0])\n\n[/Code 2]\n\n[Asserts 2]\n\nassert findGreatestStateFirstDigit([[1, 2, 3], [4, 5, 6], [7, 8, 9]])==2\nassert findGreatestStateFirstDigit([[1, 2, 3], [4, 50, 6], [7, 8, 9]])==1\nassert findGreatestStateFirstDigit([[10, 2, 3], [4, 5, 6], [7, 8, 9]])==1\nassert findGreatestStateFirstDigit([[1, 2, 3], [4, 5, 6], [7, 88, 9]])==2", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['number', 'exponent', 'greater value', 'comparison', 'power', 'program']", "prompt_tokens": 465, "total_tokens": 706, "completion_tokens": 241, "completion": "[Question 2]\n\nWrite a program to determine the biggest value obtainable by flipping signs of a given list of numbers and raising them to a certain power.\n\n[/Question 2]\n\n[Code 2]\n\nfrom itertools import product\n\ndef biggestFlippedValue(nums: List[int], exponent: int) -> int:\n    max_val = float('-inf')\n    for signs in product([-1, 1], repeat=len(nums)):\n        val = abs(sum(nums[i]*sign for i, sign in enumerate(signs)))**exponent\n        max_val = max(max_val, val)\n    return max_val\n\n[/Code 2]\n\n[Asserts 2]\n\nassert biggestFlippedValue([2, 3, 4], 2)==144\nassert biggestFlippedValue([5, 6, 7], 3)==9261\nassert biggestFlippedValue([8, 9, 10], 2)==100\nassert biggestFlippedValue([2, 2, 2], 5)==32\nassert biggestFlippedValue([3, 4, 5, 6], 3)==17576\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['linked list', 'singly linked list', 'node', 'prime', 'count', 'values']", "prompt_tokens": 663, "total_tokens": 1174, "completion_tokens": 511, "completion": "[Question 2]\n\nYou are given a singly linked list where each node contains a value 'x' and a globally unique identifier (GUID). Write a method to count the number of prime nodes in the linked list based on the value of 'x'.\n\n[/Question 2]\n\n[Code 2]\n\nclass Node:\n    def __init__(self, x, guid):\n        self.x = x\n        self.guid = guid\n        self.next = None\n\ndef isPrime(n):\n\tif n <= 1:\n\t\treturn False\n\tfor i in range(2, int(n**0.5)+1):\n\t\tif n % i == 0:\n\t\t\treturn False\n\treturn True\n\ndef countPrimeNodesByValue(head: Node, value: int) -> int:\n\tcount = 0\n\ttemp = head\n\twhile temp:\n\t\tif temp.x == value and isPrime(temp.x):\n\t\t\tcount += 1\n\t\ttemp = temp.next\n\treturn count\n\n[/Code 2]\n\n[Asserts 2]\n\n# Create a linked list 1 -> 2 -> 3 -> 4 -> 5 with GUIDs\nnode1 = Node(1, \"GUID1\")\nnode2 = Node(2, \"GUID2\")\nnode3 = Node(3, \"GUID3\")\nnode4 = Node(4, \"GUID4\")\nnode5 = Node(5, \"GUID5\")\nnode1.next = node2\nnode2.next = node3\nnode3.next = node4\nnode4.next = node5\nassert countPrimeNodesByValue(node1, 2)==1\nassert countPrimeNodesByValue(node1, 3)==1\nassert countPrimeNodesByValue(node1, 5)==1\n\n# Create a linked list 7 -> 10 -> 11 -> 15 -> 17 with different GUIDs\nnode7 = Node(7, \"GUID6\")\nnode10 = Node(10, \"GUID7\")\nnode11 = Node(11, \"GUID8\")\nnode15 = Node(15, \"GUID9\")\nnode17 = Node(17, \"GUID10\")\nnode7.next = node10\nnode10.next = node11\nnode11.next = node15\nnode15. next = node17\nassert countPrimeNodesByValue(node7, 7)==1\nassert countPrimeNodesByValue(node7, 11)==1\nassert countPrimeNodesByValue(node7, 17)==1\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['integer', 'multiples', 'count', 'math', 'lcm', 'gcd']", "prompt_tokens": 546, "total_tokens": 702, "completion_tokens": 156, "completion": "[Question 2]\n\nWrite a program to find the count of non-negative integer multiples of two given integers a and b which are less than the least common multiple (LCM) of a and b.\n\n[/Question 2]\n\n[Code 2]\n\ndef countNonNegativeMultiples(a: int, b: int) -> int:\n    lcm = (a * b) // math.gcd(a, b)\n    count = lcm // max(a, b)\n    return count\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countNonNegativeMultiples(3, 5) == 5\nassert countNonNegativeMultiples(7, 13) == 13\nassert countNonNegativeMultiples(6, 8) == 8", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'pairs', 'integers', 'parity', 'counting']", "prompt_tokens": 561, "total_tokens": 901, "completion_tokens": 340, "completion": "[Question 2]\n\nYou have been given a phone keypad and you are supposed to output the count of all valid pairs of numbers that can be dialed using the North-South movement on the keypad. The keypad layout is represented as an array of strings where each string represents a row of the keypad.\n\n[/Question 2]\n\n[Code 2]\n\ndef countValidNorthSouthPairs(keypad: List[str]) -> int:\n    movements = {1: [4, 2], 2: [1, 5, 3], 3: [2, 6], 4: [1, 5, 7], 5: [2, 4, 6, 8], 6: [3, 5, 9], 7: [4, 8], 8: [5, 7, 9], 9: [6, 8]}\n    count = 0\n    for row in range(len(keypad)):\n        for col in range(len(keypad[0])):\n            current_number = int(keypad[row][col])\n            for movement in movements[current_number]:\n                new_row = row + 1\n                new_col = col\n                if movement in movements[int(keypad[new_row][new_col])]:\n                    count += 1\n    return count\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countValidNorthSouthPairs([\"123\", \"456\", \"789\"]) == 12\nassert countValidNorthSouthPairs([\"258\", \"147\", \"036\"]) == 8\nassert countValidNorthSouthPairs([\"369\", \"258\", \"147\"]) == 6", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['balanced ternary', 'numeral system', 'game', 'players', 'turns', 'alternating', 'digits', 'non-zero', 'win', 'optimally']", "prompt_tokens": 545, "total_tokens": 813, "completion_tokens": 268, "completion": "[Question 2]\n\nIn a game involving a tree structure, two players take turns alternately adding a non-zero digit to the state codes of the nodes. The maximum height of the tree is restricted to three levels. The player who achieves the maximum possible state code at the leaf nodes wins the game. Given the initial state codes of the nodes, how can the players optimally make their moves to ensure a win?\n\n[/Question 2]\n\n[Code 2]\n\ndef maximumStateCodeWin(initialStateCodes: List[str]) -> str:\n    # Logic to determine the optimal move for each player to win the game\n    # Write your code here\n    pass\n\n[/Code 2]\n\n[Asserts 2]\n\ninitialStateCodes1 = [\"100\", \"210\", \"002\"]\nassert maximumStateCodeWin(initialStateCodes1) == \"First Player\"\n\ninitialStateCodes2 = [\"001\", \"011\", \"101\"]\nassert maximumStateCodeWin(initialStateCodes2) == \"Second Player\"\n\ninitialStateCodes3 = [\"222\", \"212\", \"121\"]\nassert maximumStateCodeWin(initialStateCodes3) == \"First Player\"\n\ninitialStateCodes4 = [\"001\", \"010\", \"100\"]\nassert maximumStateCodeWin(initialStateCodes4) == \"Second Player\"\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['string', 'distinct', 'characters', 'order', 'dictionary', 'frequency', 'unordered', 'set', 'ordered', 'collection']", "prompt_tokens": 716, "total_tokens": 1224, "completion_tokens": 508, "completion": "[Question 2]\n\nYou are tasked with designing a system to allocate classrooms based on the width of the classrooms. Each classroom has a constant width, and you need to maintain an ordered collection of classrooms based on their width. Create a class that stores the classrooms and implements the following functionalities:\n\n1. Add a new classroom with its width to the collection.\n2. Remove a classroom from the collection based on its width.\n3. Get the distinct widths of all the classrooms.\n4. Check if a particular width exists in the collection.\n5. If a width exists, return the frequency of the occurrence of that width in the collection; otherwise, return 0.\n\nImplement the class with the required functionalities.\n\n[/Question 2]\n\n[Code 2]\n\nclass ClassroomCollection:\n    def __init__(self):\n        self.classrooms = []\n\n    def addClassroom(self, width: float):\n        self.classrooms.append(width)\n        self.classrooms.sort()\n\n    def removeClassroom(self, width: float):\n        self.classrooms.remove(width)\n\n    def getDistinctWidths(self) -> set:\n        return set(self.classrooms)\n\n    def checkWidthExists(self, width: float) -> bool:\n        return width in self.classrooms\n\n    def getFrequency(self, width: float) -> int:\n        return self.classrooms.count(width)\n\n\n# Usage\nclassroom_collection = ClassroomCollection()\nclassroom_collection.addClassroom(10.5)\nclassroom_collection.addClassroom(8.0)\nclassroom_collection.addClassroom(10.5)\nclassroom_collection.addClassroom(12.0)\nprint(classroom_collection.getDistinctWidths())\nprint(classroom_collection.checkWidthExists(8.0))\nprint(classroom_collection.getFrequency(10.5))\nclassroom_collection.removeClassroom(8.0)\n\n[/Code 2]\n\n[Asserts 2]\n\nclassroom_collection = ClassroomCollection()\nclassroom_collection.addClassroom(10.5)\nclassroom_collection.addClassroom(8.0)\nclassroom_collection.addClassroom(10.5)\nclassroom_collection.addClassroom(12.0)\nassert classroom_collection.getDistinctWidths() == {8.0, 10.5, 12.0}\nassert classroom_collection.checkWidthExists(8.0) == True\nassert classroom_collection.getFrequency(10.5) == 2\nclassroom_collection.removeClassroom(8.0)\nassert classroom_collection.getDistinctWidths() == {10.5, 12.0}\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['rectangle', 'coordinates', 'integral points', 'geometry', 'nested loops', 'iteration', 'class', 'list']", "prompt_tokens": 609, "total_tokens": 1131, "completion_tokens": 522, "completion": "[Question 2]\n\nCreate a class to represent a rectangle in a 2D coordinate system. Implement a method to find all integral points on the boundary of the rectangle.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\nclass Point:\n    def __init__(self, x: int, y: int):\n        self.x = x\n        self.y = y\n\nclass Rectangle:\n    def __init__(self, bottomLeft: Point, topRight: Point):\n        self.bottomLeft = bottomLeft\n        self.topRight = topRight\n\n    def integralPointsOnBoundary(self) -> List[Point]:\n        integralPoints = []\n        for x in range(self.bottomLeft.x, self.topRight.x + 1):\n            integralPoints.append(Point(x, self.bottomLeft.y))\n            integralPoints.append(Point(x, self.topRight.y))\n        for y in range(self.bottomLeft.y + 1, self.topRight.y):\n            integralPoints.append(Point(self.bottomLeft.x, y))\n            integralPoints.append(Point(self.topRight.x, y))\n        return integralPoints\n\n[/Code 2]\n\n[Asserts 2]\n\nr1 = Rectangle(Point(1, 1), Point(4, 4))\nassert r1.integralPointsOnBoundary() == [Point(1, 1), Point(2, 1), Point(3, 1), Point(4, 1), Point(1, 4), Point(2, 4), Point(3, 4), Point(4, 4), Point(1, 2), Point(1, 3), Point(1, 4), Point(4, 2), Point(4, 3), Point(4, 4), Point(2, 1), Point(3, 1), Point(4, 1), Point(2, 4), Point(3, 4), Point(4, 4)]\n\nr2 = Rectangle(Point(0, 0), Point(2, 3))\nassert r2.integralPointsOnBoundary() == [Point(0, 0), Point(1, 0), Point(2, 0), Point(0, 3), Point(1, 3), Point(2, 3), Point(0, 1), Point(0, 2), Point(0, 3), Point(2, 1), Point(2, 2), Point(2, 3)]\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'triplet', 'minimum', 'product', 'sorting', 'positive integers']", "prompt_tokens": 591, "total_tokens": 929, "completion_tokens": 338, "completion": "[Question 2]\n\nGiven a 2D array representing unit cells in a space, write a function to draw a dot on the cell representing the minimum product of suppliers.\n\n[/Question 2]\n\n[Code 2]\n\ndef drawDotOnMinimumProductCell(array: List[List[int]]) -> None:\n    min_product = float('inf')\n    min_cell = None\n    for row in range(len(array)):\n        for col in range(len(array[0])):\n            product = 1\n            for val in array[row][col]:\n                product *= val\n            if product < min_product:\n                min_product = product\n                min_cell = (row, col)\n    # Draw a dot on the cell representing the minimum product\n    array[min_cell[0]][min_cell[1]] = \".\"\n\n[/Code 2]\n\n[Asserts 2]\n\nExample 1:\nunit_cells = [\n    [2, 3, 5],\n    [4, 6, 2],\n    [1, 5, 7]\n]\ndrawDotOnMinimumProductCell(unit_cells)\nassert unit_cells == [\n    [2, 3, 5],\n    [4, \".\", 2],\n    [1, 5, 7]\n]\n\nExample 2:\nunit_cells = [\n    [1, 2, 3],\n    [4, 5, 6],\n    [7, 8, 9]\n]\ndrawDotOnMinimumProductCell(unit_cells)\nassert unit_cells == [\n    [1, 2, 3],\n    [4, \".\", 6],\n    [7, 8, 9]\n]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['positive', 'integer', 'absolute difference', 'adjacent digits', 'sequence', 'iteration', 'math']", "prompt_tokens": 565, "total_tokens": 851, "completion_tokens": 286, "completion": "[Question 2]\n\nYou are working for a transportation company and are tasked with detecting fraudulent use of transportation cards based on fare usage. The transportation card requires that the fare for each trip be a positive integer and has a specific rule - the fare for each trip must be an integer whose absolute difference of any two adjacent digits is at most 1. \n\nWrite a function that takes a list of fares visited by a transportation card, and returns the total sum of fares that are valid according to the transportation card's rule.\n\n[/Question 2]\n\n[Code 2]\n\ndef validFareSum(fares: List[int]) -> int:\n    total_sum = 0\n    for fare in fares:\n        fare_str = str(fare)\n        valid = True\n        for i in range(len(fare_str) - 1):\n            if abs(int(fare_str[i]) - int(fare_str[i+1])) > 1:\n                valid = False\n                break\n        if valid:\n            total_sum += fare\n    return total_sum\n\n[/Code 2]\n\n[Asserts 2]\n\nassert validFareSum([123, 45, 67, 101]) == 45\nassert validFareSum([122, 333, 545, 57]) == 57\nassert validFareSum([111, 222, 333, 444]) == 111", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'positive', 'integers', 'maximum', 'division', 'value']", "prompt_tokens": 480, "total_tokens": 675, "completion_tokens": 195, "completion": "[Question 2]\n\nYou are given an array of positive integers that represent the lengths of the sides of a triangle. You need to write a function to determine if the triangle is a right-angled triangle using the Pythagorean theorem.\n\n[/Question 2]\n\n[Code 2]\n\ndef isRightAngledTriangle(arr):\n    arr.sort()\n    a, b, c = arr\n    return a**2 + b**2 == c**2\n\n[/Code 2]\n\n[Asserts 2]\n\nassert isRightAngledTriangle([3, 4, 5])==True\nassert isRightAngledTriangle([5, 12, 13])==True\nassert isRightAngledTriangle([6, 8, 10])==True\nassert isRightAngledTriangle([7, 24, 25])==True\nassert isRightAngledTriangle([4, 7, 9])==False\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'subarray', 'integer', 'sum', 'representation', 'exponentiation', 'math', 'iteration']", "prompt_tokens": 603, "total_tokens": 867, "completion_tokens": 264, "completion": "[Question 2]\n\nWrite a function to find the maximum sum of a subarray in an array of integers. Consider solving it using heap data structure and efficient iteration techniques.\n\n[/Question 2]\n\n[Code 2]\n\nimport heapq\n\ndef maxSubarraySum(nums):\n    max_sum = float('-inf')\n    current_sum = 0\n    max_heap = []\n\n    for num in nums:\n        current_sum += num\n        max_sum = max(max_sum, current_sum)\n\t\t\n        heapq.heappush(max_heap, current_sum)\n        if current_sum < 0:\n            current_sum = 0\n            max_heap = []\n\n    if max_sum < 0:\n        return max(nums)\n    else:\n        return max_sum\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maxSubarraySum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) == 6\nassert maxSubarraySum([1, 2, -1, 3, 4, -1]) == 9\nassert maxSubarraySum([-2, -3, 4, -1, -2, 1, 5, -3]) == 7\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['string', 'split', 'substrings', 'set', 'characters', 'boolean', 'sorting']", "prompt_tokens": 499, "total_tokens": 760, "completion_tokens": 261, "completion": "[Question 2]\n\nYou are given a string and you are allowed to perform a maximum of M character replacements. Write a function to check whether it is possible to convert the given string into a title string, where each word starts with an uppercase letter and the rest of the letters are lowercase.\n\n[/Question 2]\n\n[Code 2]\n\ndef canBeTitleString(s: str, M: int) -> bool:\n    if M < 0:\n        return False\n    words = s.split()\n    for word in words:\n        if not word[0].isupper() or not word[1:].islower():\n            if M == 0:\n                return False\n            else:\n                M -= 1\n    return True\n\n[/Code 2]\n\n[Asserts 2]\n\nassert canBeTitleString(\"The Quick Brown Fox\", 1) == True\nassert canBeTitleString(\"ThE quICk BROWN foX\", 2) == True\nassert canBeTitleString(\"tHe QUick BROWN fox\", 0) == False\nassert canBeTitleString(\"TheQuick BrownFox\", 1) == False\nassert canBeTitleString(\"The Quick BrownFox\", 2) == True\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['string', 'minimize', 'cost', 'conversion', 'substring', 'operations', 'character', 'increase', 'decrease']", "prompt_tokens": 684, "total_tokens": 1018, "completion_tokens": 334, "completion": "[Question 2]\n\nYou are given a string composed of lowercase English letters and two integers, a and b. The string represents a language where each character in the string represents a unique job. You need to select a substring of the given string and perform a series of unique operations in order to minimize the cost of the conversion. The operations include decreasing the frequency of a particular character by a units and increasing the frequency of another character by b units, where a and b are integers. Find the minimum cost to convert the given string using these operations. If the conversion is not possible, return -1.\n\n[/Question 2]\n\n[Code 2]\n\ndef minimizeConversionCost(s: str, a: int, b: int) -> int:\n        count = [0] * 26\n        for c in s:\n            count[ord(c) - ord('a')] += 1\n\n        uniqueChars = sum(1 for x in count if x > 0)\n\n        if len(s) - uniqueChars < 2:\n            return -1\n\n        return min(a*x, b*(uniqueChars-1) + b)\n\n[/Code 2]\n\n[Asserts 2]\n\nassert(minimizeConversionCost(\"abacaba\", 1, 2))==4\nassert(minimizeConversionCost(\"abcabc\", 2, 3))==3\nassert(minimizeConversionCost(\"abcd\", 2, 2))==-1\nassert(minimizeConversionCost(\"abbc\", 3, 3))==9\nassert(minimizeConversionCost(\"abcc\", 4, 2))==6\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['positive integers', 'digits', 'divisible', 'counting', 'dynamic programming', 'sum', 'loops']", "prompt_tokens": 589, "total_tokens": 842, "completion_tokens": 253, "completion": "[Question 2]\n\nWrite a program to find the sum of all positive integers in the original array that are divisible by the number of digits in the integer and the number of years elapsed since the management system was established.\n\n[/Question 2]\n\n[Code 2]\n\ndef sumOfDivisibleByDigitsAndYears(arr, years):\n    total_sum = 0\n    for num in arr:\n        num_digits = len(str(num))\n        if years != 0 and num % num_digits == 0 and years % num_digits == 0:\n            total_sum += num\n    return total_sum\n\n[/Code 2]\n\n[Asserts 2]\n\nassert sumOfDivisibleByDigitsAndYears([123, 45, 600, 700], 3) == 123\nassert sumOfDivisibleByDigitsAndYears([12, 44, 55, 600, 789], 7) == 44\nassert sumOfDivisibleByDigitsAndYears([111, 222, 333, 444, 555], 0) == 0\nassert sumOfDivisibleByDigitsAndYears([100, 200, 300, 400, 500], 5) == 200", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['integer', 'flips', 'bit', 'minimize', 'binary', 'operation', 'conditional']", "prompt_tokens": 529, "total_tokens": 779, "completion_tokens": 250, "completion": "[Question 2]\n\nGiven a positive integer N, write a function to determine the minimum number of flips required to remove the integer N from the Fibonacci sequence. A flip operation involves changing a single bit, and the Fibonacci sequence is in dictionary order.\n\n[/Question 2]\n\n[Code 2]\n\ndef minFlipsToRemoveFromFibonacciSequence(N: int) -> int:\n    fib_seq = [0, 1]\n    while True:\n        next_num = fib_seq[-1] + fib_seq[-2]\n        fib_seq.append(next_num)\n        if next_num == N:\n            break\n\n    return min(bin(fib_seq[-1]).count(\"1\"), bin(fib_seq[-2]).count(\"1\"))\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minFlipsToRemoveFromFibonacciSequence(5) == 2\nassert minFlipsToRemoveFromFibonacciSequence(8) == 1\nassert minFlipsToRemoveFromFibonacciSequence(13) == 2\nassert minFlipsToRemoveFromFibonacciSequence(21) == 3\nassert minFlipsToRemoveFromFibonacciSequence(89) == 4\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'remove', 'element', 'non-negative', 'modify', 'empty', 'length', 'possible']", "prompt_tokens": 668, "total_tokens": 947, "completion_tokens": 279, "completion": "[Question 2]\n\nYou are given an array of current bookings for a hotel. The length of the array represents the total number of rooms in the hotel, and each element represents the current booking for that room. You need to modify the array by removing the bookings that are non-negative and then skip the elements from top to bottom to form the new array. If it is not possible, return an empty array.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef modifyBookings(bookings: List[int]) -> List[int]:\n    new_bookings = [i for i in bookings if i < 0]\n    return new_bookings[::2]\n\n[/Code 2]\n\n[Asserts 2]\n\nassert modifyBookings([3, -1, 2, 4, -5, 6, -3, 8]) == [-1, 4, 6, 8]\nassert modifyBookings([5, 8, 2, -3, 7, 6, -4, 10]) == []\nassert modifyBookings([-2, -5, -3, -7, -1, -8]) == [-2, -3, -1]\nassert modifyBookings([1, 2, 3, 4, 5]) == []\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'minimum', 'jumps', 'reach', 'end', 'forward', 'direction', '0', 'maximum', 'positions']", "prompt_tokens": 680, "total_tokens": 1029, "completion_tokens": 349, "completion": "[Question 2]\n\nYou are given an array representing positions of people standing in a row. Each person is either polite (denoted as 1) or not polite (denoted as 0). You need to find the minimum number of jumps a polite person needs to make in order to reach the end of the row, assuming they can only move in the forward direction and in a parallel line.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef minPoliteJumps(arr: List[int]) -> int:\n    n = len(arr)\n    jumps = [float('inf')] * n\n    jumps[0] = 0\n    for i in range(1, n):\n        for j in range(i):\n            if (i <= j + arr[j]) and (arr[j]):\n                jumps[i] = min(jumps[i], jumps[j] + 1)\n    return jumps[n - 1] if jumps[n - 1] != float('inf') else -1\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minPoliteJumps([1, 1, 0, 1, 0, 1, 0, 0, 1]) == 3\nassert minPoliteJumps([1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1]) == 1\nassert minPoliteJumps([1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1]) == 4\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['number', 'factor', 'product', 'sum', 'math']", "prompt_tokens": 452, "total_tokens": 588, "completion_tokens": 136, "completion": "[Question 2]\n\nWrite a function to determine if two given strings are anagrams of each other.\n\n[/Question 2]\n\n[Code 2]\n\ndef areAnagrams(str1, str2):\n    if len(str1) != len(str2):\n        return False\n    return sorted(str1) == sorted(str2)\n\n[/Code 2]\n\n[Asserts 2]\n\nassert areAnagrams('listen', 'silent') == True\nassert areAnagrams('triangle', 'integral') == True\nassert areAnagrams('hello', 'world') == False\nassert areAnagrams('abc', 'abcd') == False\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['recursion', 'math', 'division', 'greedy', 'minimum', 'subtraction']", "prompt_tokens": 447, "total_tokens": 685, "completion_tokens": 238, "completion": "[Question 2]\n\nYou are given a list of integers representing the distances to a set of destinations. Your task is to find the minimum distance that needs to be covered by a single destination given that you can only choose consecutive destinations.\n\n[/Question 2]\n\n[Code 2]\n\ndef minDistanceToCover(destinations):\n    min_distance = float('inf')\n    current_distance = 0\n    for distance in destinations:\n        current_distance += distance\n        min_distance = min(min_distance, current_distance)\n        if current_distance < 0:\n            current_distance = 0\n    return min_distance\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minDistanceToCover([1, 2, 3, 4, 5]) == 1\nassert minDistanceToCover([5, 15, 10, 20, 8]) == 8\nassert minDistanceToCover([2, 4, 6, 9, 2, 1]) == 1\nassert minDistanceToCover([10, 20, 5, 3, 15, 20, 10]) == 3", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'integer', 'modulo', 'pairs', 'count', 'divisibility']", "prompt_tokens": 637, "total_tokens": 1012, "completion_tokens": 375, "completion": "[Question 2]\n\nYou are given an array of integers. Your task is to arrange the integers in the array in pairs such that the sum of the pair is divisible by a given integer K. The goal is to maximize the count of such pairs for efficiency and population distribution. Implement a function to calculate the count of such pairs in the array.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef countPairsWithSumDivisibleByK(arr: List[int], K: int) -> int:\n    remainder_count = [0] * K\n    for num in arr:\n        remainder_count[num % K] += 1\n    count = min(remainder_count[0], 1)\n    for i in range(1, (K // 2) + 1):\n        if i != K - i:\n            count += max(remainder_count[i], remainder_count[K - i])\n        else:\n            count += min(remainder_count[i], 1)\n    return count\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countPairsWithSumDivisibleByK([3, 1, 2, 6, 4, 5], 3)==5\nassert countPairsWithSumDivisibleByK([14, 7, 6, 5, 8, 4, 3, 2, 13], 7)==7\nassert countPairsWithSumDivisibleByK([9, 11, 13, 15, 17, 19, 21, 23, 25], 10)==5\nassert countPairsWithSumDivisibleByK([20, 30, 40, 50, 60, 70, 80, 90], 15)==4\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['game', 'coins', 'maximum', 'dynamic programming', 'array', 'strategy', 'pick', 'values']", "prompt_tokens": 714, "total_tokens": 1099, "completion_tokens": 385, "completion": "[Question 2]\n\nIn a game of picking coins, each player can either pick a coin from the left end or the right end of the array, with the goal of maximizing their total sum. Given an array representing the values of the coins, write a dynamic programming function to return the maximum possible amount of money a player can win. Each player is allowed to pick a coin or cons of coins. Can you implement a dynamic programming strategy to solve this problem efficiently?\n\n[/Question 2]\n\n[Code 2]\n\ndef maxCoinsDP(arr):\n    n = len(arr)\n    dp = [[0 for x in range(n)] for y in range(n)]\n\n    for gap in range(n):\n        for i in range(n - gap):\n            j = i + gap\n\n            x = 0\n            if ((i + 2) <= j):\n                x = dp[i + 2][j]\n\n            y = 0\n            if ((i + 1) <= (j - 1)):\n                y = dp[i + 1][j - 1]\n\n            z = 0\n            if (i <= (j - 2)):\n                z = dp[i][j - 2]\n\n            dp[i][j] = max(arr[i] + min(x, y), arr[j] + min(y, z))\n\n    return dp[0][n - 1]\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maxCoinsDP([8, 15, 3, 7])==22\nassert maxCoinsDP([2, 2, 2, 2])==4\nassert maxCoinsDP([20, 30, 2, 2, 2, 10])==42\nassert maxCoinsDP([8, 22, 4, 5, 16, 4])==38\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'subarray', 'repetition', 'distinct', 'element', 'continuous', 'check']", "prompt_tokens": 664, "total_tokens": 1034, "completion_tokens": 370, "completion": "[Question 2]\n\nGiven an array arr[] representing the elements of a vector, the task is to check if there exists a subarray in the given array such that the average of all elements in the subarray is a distinct element from right to left.\n\n[/Question 2]\n\n[Code 2]\n\n```python\nfrom typing import List\n\ndef existsDistinctAverageSubarray(arr: List[int]) -> bool:\n    n = len(arr)\n    distinct_averages = set()\n    prefix_sum = 0\n    \n    for i in range(n):\n        prefix_sum += arr[i]\n        average = prefix_sum / (i + 1)\n        distinct_averages.add(average)\n    \n    prefix_sum = 0\n    for i in range(n - 1, 0, -1):\n        prefix_sum += arr[i]\n        average = prefix_sum / (n - i)\n        if average in distinct_averages:\n            return True\n    \n    return False\n```\n\n[/Code 2]\n\n[Asserts 2]\n\n```python\nassert existsDistinctAverageSubarray([1, 2, 3, 4, 5]) == True\nassert existsDistinctAverageSubarray([2, 3, 1, 4, 1, 2, 4, 5]) == False\nassert existsDistinctAverageSubarray([3, 1, 2, 3, 2, 4, 1]) == True\nassert existsDistinctAverageSubarray([5, 4, 2, 1, 3, 4, 1]) == False\nassert existsDistinctAverageSubarray([6, 2, 1, 3, 2, 3, 4]) == True\n```\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['binary', 'bit', 'difference', 'sum', 'number', 'count', 'set', 'bits']", "prompt_tokens": 558, "total_tokens": 914, "completion_tokens": 356, "completion": "[Question 2]\n\nGiven a list of numbers, write a function to find the longest polite subsequence, where a polite subsequence is one where the absolute difference between consecutive elements is 1, and return the sum of the elements in that subsequence.\n\n[/Question 2]\n\n[Code 2]\n\ndef longestPoliteSubsequence(arr):\n    max_len = 0\n    start = 0\n    for i in range(len(arr)):\n        j = i\n        current_set = set()\n        subsequence_sum = 0\n        while j < len(arr):\n            if arr[j] - 1 in current_set or arr[j] + 1 in current_set or arr[j] in current_set:\n                current_set.add(arr[j])\n                subsequence_sum += arr[j]\n                j += 1\n            else:\n                break\n        if len(current_set) > max_len:\n            max_len = len(current_set)\n            start = i\n    return sum(arr[start:start+max_len])\n\n[/Code 2]\n\n[Asserts 2]\n\nassert longestPoliteSubsequence([1, 2, 3, 4, 5, 6, 7]) == 28\nassert longestPoliteSubsequence([7, 8, 6, 5, 3, 2, 4]) == 21\nassert longestPoliteSubsequence([10, 9, 7, 8, 6, 5, 3, 2, 1]) == 25\nassert longestPoliteSubsequence([3, 2, 1, 4, 5, 6, 8, 7]) == 15\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['arrays', 'frequency', 'subarray', 'replacement', 'minimum length', 'distinct elements']", "prompt_tokens": 652, "total_tokens": 1109, "completion_tokens": 457, "completion": "[Question 2]\n\nYou are given an array consisting of single-digit integers. Write a function to replace a specific subarray within the array in such a way that the frequency of each distinct element in the subarray is equal to its offset from a specific value. Return the minimum length of the subarray that needs to be replaced to satisfy these conditions.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef minReplacementLength(arr: List[int], specific: int) -> int:\n    freq = dict()\n    distinct_elements = 0\n    for num in arr:\n        if num not in freq:\n            freq[num] = 1\n            distinct_elements += 1\n        else:\n            freq[num] += 1\n    \n    # check if all elements have same frequency with specific offset\n    for key, val in freq.items():\n        if val != abs(key - specific):\n            return len(arr)\n\n    # find the minimum length of subarray to be replaced\n    count = 0\n    start = 0\n    min_len = len(arr)\n    for i in range(len(arr)):\n        freq[arr[i]] -= 1\n        if freq[arr[i]] == 0:\n            count += 1\n        while count == distinct_elements:\n            min_len = min(min_len, i - start + 1)\n            freq[arr[start]] += 1\n            if freq[arr[start]] > 0:\n                count -= 1\n            start += 1\n\n    return min_len\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minReplacementLength([1, 2, 3, 4, 5], 3) == 5\nassert minReplacementLength([1, 2, 2, 2, 1, 1, 2, 2], 2) == 3\nassert minReplacementLength([4, 4, 4, 4, 4, 7, 7], 3) == 7\nassert minReplacementLength([1, 1, 2, 2, 2, 3, 3, 3], 2) == 3\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['circle', 'chord', 'angle', 'intersection', 'center', 'math']", "prompt_tokens": 429, "total_tokens": 830, "completion_tokens": 401, "completion": "[Question 2]\n\nWrite a program to find the intersection points of two circles in a 2D plane given their center coordinates and radii.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List, Tuple\n\ndef circleIntersection(circle1: Tuple[float, float, float], circle2: Tuple[float, float, float]) -> List[Tuple[float, float]]:\n    x1, y1, r1 = circle1\n    x2, y2, r2 = circle2\n    \n    d = math.sqrt((x2 - x1)**2 + (y2 - y1)**2)\n    \n    if d > r1 + r2 or d < abs(r1 - r2):\n        return []  # No intersection\n    \n    a = (r1**2 - r2**2 + d**2) / (2 * d)\n    h = math.sqrt(r1**2 - a**2)\n    \n    x = x1 + a * (x2 - x1) / d\n    y = y1 + a * (y2 - y1) / d\n    \n    x3 = x + h * (y2 - y1) / d\n    y3 = y - h * (x2 - x1) / d\n    x4 = x - h * (y2 - y1) / d\n    y4 = y + h * (x2 - x1) / d\n    \n    return [(x3, y3), (x4, y4)]\n\n[/Code 2]\n\n[Asserts 2]\n\nassert circleIntersection((0, 0, 3), (4, 0, 3)) == [(2, 1.732), (2, -1.732)]\nassert circleIntersection((1, 1, 2), (4, 1, 2)) == [(3, 1), (2, 1)]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['matrix', 'rectangle', 'area', 'occupied cells', 'submatrix', 'sum', 'count', 'nested loop']", "prompt_tokens": 725, "total_tokens": 1204, "completion_tokens": 479, "completion": "[Question 2]\n\nYou run a flower garden and have a matrix representing the garden. The matrix contains 0s and 1s, where 1 represents the occupied cells by flowers. Each flower needs to be watered with at least a certain amount of water, represented by a positive integer. Write a function to count the total number of submatrices with an area equal to or larger than a given threshold, where the sum of occupied cells is at least the required amount of water for each cell within the submatrix.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\ndef countWateredSubmatrices(matrix: List[List[int]], n: int, m: int, threshold: int) -> int:\n\tcount = 0\n\tfor i in range(n):\n\t\tfor j in range(m):\n\t\t\tfor p in range(i, n):\n\t\t\t\tfor q in range(j, m):\n\t\t\t\t\tif submatrixArea(matrix, i, j, p, q) >= threshold:\n\t\t\t\t\t\tcount += 1\n\treturn count\n\ndef submatrixArea(matrix, i1, j1, i2, j2):\n\tarea = 0\n\tfor i in range(i1, i2 + 1):\n\t\tfor j in range(j1, j2 + 1):\n\t\t\tarea += matrix[i][j]\n\treturn area\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countWateredSubmatrices([[1, 0, 0], [0, 1, 1], [1, 1, 1]], 3, 3, 3) == 6\nassert countWateredSubmatrices([[1, 0, 0], [0, 1, 1], [1, 1, 1]], 3, 3, 4) == 9\nassert countWateredSubmatrices([[1, 0, 0], [0, 1, 1], [1, 1, 1]], 3, 3, 5) == 9\nassert countWateredSubmatrices([[0, 0, 0], [0, 0, 0], [0, 0, 0]], 3, 3, 1) == 9\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'subarray', 'size', 'sum', 'perfect square']", "prompt_tokens": 616, "total_tokens": 962, "completion_tokens": 346, "completion": "[Question 2]\n\nYou are given an array of positive integers. Your task is to determine if the array can be divided into two sets such that the sum of the elements in each set is a perfect square.\n\n[/Question 2]\n\n[Code 2]\n\ndef isPerfectSquare(n: int) -> bool:\n    sqrt_n = int(n**0.5)\n    return sqrt_n*sqrt_n == n\n\ndef canDivideIntoTwoSets(arr: List[int]) -> bool:\n    n = len(arr)\n    total_sum = sum(arr)\n    \n    # Check if the total sum is a perfect square\n    if not isPerfectSquare(total_sum):\n        return False\n    \n    target_sum = total_sum // 2\n    dp = [False] * (target_sum + 1)\n    dp[0] = True\n    \n    for num in arr:\n        for j in range(target_sum, num-1, -1):\n            if dp[j-num]:\n                dp[j] = True\n    \n    return dp[target_sum]\n\n[/Code 2]\n\n[Asserts 2]\n\nassert(canDivideIntoTwoSets([1, 2, 3, 4, 5])) == True\nassert(canDivideIntoTwoSets([1, 2, 3, 4, 5, 6])) == False\nassert(canDivideIntoTwoSets([3, 1, 4, 1, 5, 9, 2, 6, 5, 3])) == True\nassert(canDivideIntoTwoSets([10, 20, 34, 56, 70])) == False\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['square', 'size', 'integer', 'math', 'sqrt', 'compute', 'smallest']", "prompt_tokens": 453, "total_tokens": 633, "completion_tokens": 180, "completion": "[Question 2]\n\nGiven an integer N, compute the size of the smallest octahedron that can be formed by appending N pairs of squares and subtractions. \n\n[/Question 2]\n\n[Code 2]\n\ndef sizeOfSmallestOctahedron(N: int) -> int:\n    # Size of octahedron = 2 * sqrt(N)\n    return 2 * int(N ** 0.5)\n\n[/Code 2]\n\n[Asserts 2]\n\nassert sizeOfSmallestOctahedron(4) == 4\nassert sizeOfSmallestOctahedron(9) == 6\nassert sizeOfSmallestOctahedron(16) == 8\nassert sizeOfSmallestOctahedron(25) == 10\nassert sizeOfSmallestOctahedron(36) == 12", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['number', 'perfect fourth power', 'smallest', 'N-digit', 'integer', 'power', 'iteration', 'search']", "prompt_tokens": 562, "total_tokens": 727, "completion_tokens": 165, "completion": "[Question 2]\n\nGiven a positive integer N, write a function to count the number of set bits in the binary representation of N and return the count. A set bit is a binary digit that is set to 1. \n\n[/Question 2]\n\n[Code 2]\n\ndef countSetBits(N: int) -> int:\n    count = 0\n    while N > 0:\n        count += N & 1\n        N >>= 1\n    return count\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countSetBits(6) == 2\nassert countSetBits(13) == 3\nassert countSetBits(128) == 1\nassert countSetBits(255) == 8\nassert countSetBits(1023) == 10", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['repeated addition', 'repeated subtraction', 'gcd', 'math', 'counting', 'division', 'iteration']", "prompt_tokens": 534, "total_tokens": 917, "completion_tokens": 383, "completion": "[Question 2]\n\nYou are given an array of n integers. A \"bitonic subarray\" is a subarray such that it is first strictly increasing then strictly decreasing. Write a function to find the length of the longest bitonic subarray within the given array.\n\n[/Question 2]\n\n[Code 2]\n\ndef longestBitonicSubarray(arr):\n    n = len(arr)\n    inc = [1]*n\n    dec = [1]*n\n    for i in range(1,n):\n        if arr[i]>arr[i-1]:\n            inc[i] = inc[i-1] + 1\n    for i in range(n-2,-1,-1):\n        if arr[i]>arr[i+1]:\n            dec[i] = dec[i+1] + 1\n    max_len = 0\n    for i in range(n):\n        if inc[i]>1 and dec[i]>1:\n            max_len = max(max_len, inc[i] + dec[i] - 1)\n    return max_len\n\n[/Code 2]\n\n[Asserts 2]\n\nassert longestBitonicSubarray([1, 11, 2, 10, 4, 5, 2, 1])==6\nassert longestBitonicSubarray([12, 4, 78, 90, 45, 23])==5\nassert longestBitonicSubarray([10, 20, 30, 40])==4\nassert longestBitonicSubarray([4, 5, 6, 7, 8, 9, 10, 20, 30, 40, 50])==11\nassert longestBitonicSubarray([1, 3, 1, 4, 7, 3, 2, 1])==5\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'increment', 'decrement', 'comparison', 'absolute difference', 'operations', 'odd', 'even']", "prompt_tokens": 628, "total_tokens": 961, "completion_tokens": 333, "completion": "[Question 2]\n\nGiven an array of integers, arrange the array such that all odd numbers appear before even numbers, and the absolute difference between the sum of odd and even numbers in the array is minimized. Find the minimum number of operations needed to achieve this arrangement.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\ndef minimizeAbsoluteDifference(arr: List[int]) -> int:\n    odd_sum, even_sum = 0, 0\n    odd_count = 0\n    for num in arr:\n        if num % 2 == 0:\n            even_sum += num\n        else:\n            odd_sum += num\n            odd_count += 1\n    even_count = len(arr) - odd_count\n\n    if odd_count == 0 or even_count == 0:\n        return 0\n\n    ops = abs(odd_sum - even_sum) // min(odd_count, even_count)\n    remaining_ops = abs(odd_sum - even_sum) % min(odd_count, even_count)\n\n    return ops + remaining_ops\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minimizeAbsoluteDifference([1, 2, 3, 4, 5])==1\nassert minimizeAbsoluteDifference([3, 2, 3, 4, 5, 6])==2\nassert minimizeAbsoluteDifference([7, 8, 9, 10])==8\nassert minimizeAbsoluteDifference([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])==0\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'flipping', 'consecutive', 'sequence', 'maximize', 'zeros', 'count']", "prompt_tokens": 692, "total_tokens": 1138, "completion_tokens": 446, "completion": "[Question 2]\n\nIn a train attacking game, there are n trains, each having an array of zeros and ones representing the presence or absence of enemy attacks. The task is to maximize the number of consecutive trains that can be attacked by flipping at most k zeros to ones. Write a function to find the maximum number of consecutive trains that can be attacked.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef maxConsecutiveAttacks(trains: List[List[int]], k: int) -> int:\n\n    n = len(trains)\n    result = 0\n    zeroCount = 0\n    wL = 0\n    \n    for wR in range(n):\n        if trains[wR] == 0:\n            zeroCount += 1\n        \n        while zeroCount > k:\n            if trains[wL] == 0:\n                zeroCount -= 1\n            wL += 1\n        \n        result = max(result, wR - wL + 1)\n    \n    return result\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maxConsecutiveAttacks([[1, 0, 1, 1, 0], [0, 0, 0, 1, 1], [1, 1, 0, 0, 1], [0, 1, 0, 0, 0]], 2) == 3\nassert maxConsecutiveAttacks([[1, 0, 1, 1, 0], [0, 0, 0, 1, 1], [1, 1, 0, 0, 1], [0, 1, 0, 0, 0]], 1) == 2\nassert maxConsecutiveAttacks([[1, 0, 1, 1, 0], [0, 0, 0, 1, 1], [1, 1, 0, 0, 1], [0, 1, 0, 0, 0]], 3) == 4\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['binary', 'string', 'remove', 'occurrences', 'manipulation', 'iteration', 'conditional', 'logic']", "prompt_tokens": 519, "total_tokens": 795, "completion_tokens": 276, "completion": "[Question 2]\n\nYou are given a string representing a binary number. Write a function to determine if the binary representation of a stock price in a URL is palindrome or not using conditional logic, string manipulation, and iteration.\n\n[/Question 2]\n\n[Code 2]\n\ndef isStockPriceBinaryPalindrome(url: str) -> bool :\n    # Assume the stock price is represented by a binary string in the URL\n    start_index = url.find(\"stock=\") + 6\n    end_index = url.find(\"&\", start_index)\n    if end_index == -1:\n        binary_str = url[start_index:]\n    else:\n        binary_str = url[start_index:end_index]\n\n    # Remove leading zeros\n    binary_str = binary_str.lstrip('0')\n\n    # Check if the binary string is a palindrome\n    return binary_str == binary_str[::-1]\n\n[/Code 2]\n\n[Asserts 2]\n\nassert isStockPriceBinaryPalindrome(\"https://example.com?stock=10011001\") == True\nassert isStockPriceBinaryPalindrome(\"https://example.com?stock=1010110\") == False\nassert isStockPriceBinaryPalindrome(\"https://example.com?stock=00011000\") == True\nassert isStockPriceBinaryPalindrome(\"https://example.com?stock=1111\") == True\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['integer', 'numeric', 'string', 'concatenations', 'divisible', 'count', 'ways']", "prompt_tokens": 603, "total_tokens": 826, "completion_tokens": 223, "completion": "[Question 2]\n\nYou are given an array of integers representing the lengths of line segments. The task is to find the maximum perimeter of a triangle that can be formed using any three of the line segments. If no triangle can be formed, return 0.\n\n[/Question 2]\n\n[Code 2]\n\ndef maxPerimeter(nums: List[int]) -> int:\n    nums.sort(reverse=True)\n    for i in range(len(nums) - 2):\n        if nums[i] < nums[i+1] + nums[i+2]:\n            return nums[i] + nums[i+1] + nums[i+2]\n    return 0\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maxPerimeter([2, 1, 2]) == 5\nassert maxPerimeter([1, 2, 1]) == 0\nassert maxPerimeter([3, 2, 3, 4]) == 10\nassert maxPerimeter([3, 6, 2, 3]) == 8\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'integers', 'subsequence', 'composite', 'sum', 'digits', 'dynamic programming']", "prompt_tokens": 680, "total_tokens": 1140, "completion_tokens": 460, "completion": "[Question 2]\n\nGiven an array of integers, the problem is to find the length of the longest subsequence such that the sum of the digits forms a composite number as per the given conjecture. The conjecture states that if the sum of digits of a number forms a number that is a power of 2 (i.e., 2^N), then it is considered as a composite number.\n\n[/Question 2]\n\n[Code 2]\n\ndef isPowerOfTwo(n: int) -> bool:\n    return (n & (n - 1)) == 0 and n != 0\n\ndef isComposite(n: int) -> bool:\n    if n < 4:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return True\n    return False\n\ndef digitSumCompositePowerOf2(arr: List[int]) -> int:\n    ans = 0\n    dp = {}\n    def solve(i, n, start, a):\n        if i == n:\n            if isPowerOfTwo(a) and a > 1:\n                return 0\n            return -float('inf')\n        if (i, a) in dp:\n            return dp[(i, a)]\n        res = max(solve(i+1, n, start, a), solve(i+1, n, start, a + arr[i]) + 1)\n        dp[(i, a)] = res\n        return res\n    for i in range(0, len(arr)):\n        ans = max(ans, solve(i, len(arr), i, arr[i]))\n    return ans\n\n[/Code 2]\n\n[Asserts 2]\n\nassert digitSumCompositePowerOf2([12, 6, 3, 22, 5, 25, 9, 10]) == 4\nassert digitSumCompositePowerOf2([123, 456, 789, 12, 34, 56, 78, 90]) == 7\nassert digitSumCompositePowerOf2([11, 22, 33, 44, 55]) == 0\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['string', 'split', 'substring', 'check', 'non-empty', 'three', 'true', 'false']", "prompt_tokens": 590, "total_tokens": 878, "completion_tokens": 288, "completion": "[Question 2]\n\nGiven a non-empty string in camel case, write a function to split the string into three non-empty substrings such that the sum of their ASCII values is the maximum possible. Return True if such a split is possible, otherwise return False.\n\nFor example, if the input string is \"HelloWorldInCamelCase\", a possible split into three substrings can be \"Hello\", \"World\", and \"InCamelCase\", and the function should return True.\n\n[/Question 2]\n\n[Code 2]\n\ndef maxSumAsciiSplit(s: str) -> bool:\n    n = len(s)\n    maxval = 0\n    for i in range(1, n-1):\n        for j in range(i+1, n):\n            x = s[:i]\n            y = s[i:j]\n            z = s[j:]\n            total = sum(map(ord, [x, y, z]))\n            maxval = max(maxval, total)\n    return maxval\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maxSumAsciiSplit(\"HelloWorldInCamelCase\")==True\nassert maxSumAsciiSplit(\"GoodMorningEveryone\")==False\nassert maxSumAsciiSplit(\"MaximumValueSubstring\")==True\nassert maxSumAsciiSplit(\"CodingQuestionsAndAnswers\")==True\nassert maxSumAsciiSplit(\"TwoThreeFourFiveSix\")==False\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['mean', 'median', 'average', 'sorting', 'array', 'statistics']", "prompt_tokens": 527, "total_tokens": 939, "completion_tokens": 412, "completion": "[Question 2]\n\nYou are given an array of integers. Find the median of the array using a parent-pointer tree-based approach.\n\n[/Question 2]\n\n[Code 2]\n\nclass Node:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n        self.left_count = 0\n\ndef insert(root, key):\n    if root is None:\n        return Node(key)\n    if key < root.value:\n        root.left = insert(root.left, key)\n        root.left_count += 1\n    else:\n        root.right = insert(root.right, key)\n    return root\n\ndef median(arr):\n    n = len(arr)\n    root = Node(arr[0])\n    median_node = None\n\n    for i in range(1, n):\n        root = insert(root, arr[i])\n\n    if n % 2 != 0:\n        target = (n + 1) // 2\n        median_node = find_kth_smallest(root, target)\n        return median_node.value\n    else:\n        target1 = n // 2\n        target2 = n // 2 + 1\n        median_node1 = find_kth_smallest(root, target1)\n        median_node2 = find_kth_smallest(root, target2)\n        return (median_node1.value + median_node2.value) / 2\n\ndef find_kth_smallest(root, k):\n    if root.left_count == k - 1:\n        return root\n    elif root.left_count < k - 1:\n        return find_kth_smallest(root.right, k - root.left_count - 1)\n    else:\n        return find_kth_smallest(root.left, k)\n\n[/Code 2]\n\n[Asserts 2]\n\nassert median([1, 2, 3, 4, 5]) == 3\nassert median([4, 2, 1, 5, 3]) == 3", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['graph', 'vertices', 'subset', 'colors', 'edges', 'largest', 'connected', 'count', 'defaultdict']", "prompt_tokens": 709, "total_tokens": 1116, "completion_tokens": 407, "completion": "[Question 2]\n\nGiven a graph with N vertices and M edges, find the largest valid subset of vertices where each vertex is connected to at least one other vertex, and the sum of the missing digits of the vertices is a valid color code. The missing digit for a vertex is the digit not present in the vertex number.\n\n[/Question 2]\n\n[Code 2]\n\nfrom collections import defaultdict\n\ndef sumOfMissingDigits(num: int) -> int:\n    present_digits = set(str(num))\n    missing_digit = next(i for i in range(10) if str(i) not in present_digits)\n    return missing_digit\n\ndef isValidColorCode(number: int) -> bool:\n    color_sum = sumOfMissingDigits(number)\n    return color_sum % 2 == 0 and color_sum % 3 == 0\n\ndef largestValidSubset(graph: dict) -> int:\n    if not graph:\n        return 0\n\n    valid_vertices = set()\n    for vertex, edges in graph.items():\n        connected_to = set()\n        for edge in edges:\n            connected_to.add(edge)\n\n        if connected_to:\n            valid_vertices.add(vertex)\n\n    largest_subset = 0\n    for size in range(len(valid_vertices), 0, -1):\n        for subset in combinations(valid_vertices, size):\n            if all(isValidColorCode(v) for v in subset):\n                largest_subset = size\n                break\n        if largest_subset:\n            break\n\n    return largest_subset\n\n[/Code 2]\n\n[Asserts 2]\n\nassert largestValidSubset({1: [2, 3], 2: [1, 3], 3: [1, 2]}) == 3\nassert largestValidSubset({1: [2], 2: [1], 3: []}) == 2\nassert largestValidSubset({1: [2], 2: [3], 3: [1]}) == 1\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'XOR', 'even', 'odd', 'integer']", "prompt_tokens": 489, "total_tokens": 859, "completion_tokens": 370, "completion": "[Question 2]\n\nGiven an array of integers, write a function to determine if the XOR of all the odd integers in the array is a Moran number or not. (Note: A Moran number is a non-negative integer for which the sum of its digits is equal to the sum of the digits of its prime factors, excluding 1.)\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\ndef isXORofOddMoranNumber(arr: List[int]) -> bool:\n    odd_sum = 0\n    for num in arr:\n        if num % 2 != 0:\n            odd_sum += num\n    return isMoranNumber(odd_sum)\n\ndef isMoranNumber(num: int) -> bool:\n    if num < 2:\n        return False\n    i = 2\n    while i*i <= num:\n        if num % i == 0:\n            return sumOfDigits(num) == sumOfDigits(i) + sumOfDigits(num//i)\n        i += 1\n    return False\n\ndef sumOfDigits(n: int) -> int:\n    return 0 if n == 0 else n % 10 + sumOfDigits(n//10)\n\n[/Code 2]\n\n[Asserts 2]\n\nassert isXORofOddMoranNumber([3, 5, 7, 9, 11])== True\nassert isXORofOddMoranNumber([2, 4, 6, 8, 10])== False\nassert isXORofOddMoranNumber([1, 3, 5, 7, 9])== False\nassert isXORofOddMoranNumber([1, 2, 3, 4, 5])== True\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'concatenation', 'infinite', 'sum', 'modulus', 'division', 'iteration', 'math']", "prompt_tokens": 538, "total_tokens": 886, "completion_tokens": 348, "completion": "[Question 2]\n\nGiven an array of temperatures for a number of days, find the first warmer day for each day. The first warmer day for a particular day is the next day where the temperature is higher. If there is no warmer day, return -1.\n\n[/Question 2]\n\n[Code 2]\n\ndef nextWarmerDay(temperatures: list) -> list:\n    stack, res = [], [-1]*len(temperatures)\n    for i in range(len(temperatures)):\n        while stack and temperatures[i] > temperatures[stack[-1]]:\n            res[stack.pop()] = i\n        stack.append(i)\n    return res\n\n[/Code 2]\n\n[Asserts 2]\n\nassert nextWarmerDay([73, 74, 75, 71, 69, 72, 76, 73])==[1, 2, 6, 2, 5, 6, -1, -1]\nassert nextWarmerDay([30, 40, 50, 60, 70, 80, 90])==[1, 2, 3, 4, 5, -1, -1]\nassert nextWarmerDay([90, 80, 70, 60, 50, 40, 30])==[-1, -1, -1, -1, -1, -1, -1]\nassert nextWarmerDay([60, 65, 70, 65, 60, 55, 50])==[1, 2, -1, 2, -1, -1, -1]\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['circular array', 'sum', 'replacement', 'modified', 'print', 'integer', 'array', 'circular']", "prompt_tokens": 606, "total_tokens": 898, "completion_tokens": 292, "completion": "[Question 2]\n\nYou have an array of integers representing the number of atoms of each element. Given a circular array, find the maximum count of a particular element after a series of replacements. After the replacements, print the modified circular array and the maximum count of the specified element.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef maxCountAfterReplacement(arr: List[int], k: int, element: int) -> int:\n    n = len(arr)\n    max_count = 0\n    for i in range(n):\n        curr_count = arr[i]\n        for j in range(1, k+1):\n            curr_count += arr[(i+j)%n]\n        max_count = max(max_count, curr_count)\n    print(arr)\n    return max_count\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maxCountAfterReplacement([1, 2, 3, 4, 5], 2, 1)==12\nassert maxCountAfterReplacement([3, 1, 4, 1, 5], 3, 3)==15\nassert maxCountAfterReplacement([1, 2, 3, 4, 5], 3, 2)==14\nassert maxCountAfterReplacement([5, 6, 3, 4, 5], 1, 4)==12\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['Binary Search Tree', 'BST', 'pairs', 'sum', 'value', 'node', 'inorder', 'stack', 'left', 'right']", "prompt_tokens": 817, "total_tokens": 1200, "completion_tokens": 383, "completion": "[Question 2]\n\nGiven a Binary Search Tree (BST), implement a function to calculate the sum of values at odd-indexed nodes when the nodes are visited in inorder traversal. \n\nAssume the node structure for a single node of the BST is provided.\n\n[/Question 2]\n\n[Code 2]\n\n# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef sumOddIndexedValues(root: TreeNode) -> int:\n    stack = []\n    curr = root\n    index = 1\n    sum_odd = 0\n\n    while True:\n        if curr is not None:\n            stack.append(curr)\n            curr = curr.left\n        elif stack:\n            curr = stack.pop()\n            if index % 2 == 1:\n                sum_odd += curr.val\n            index += 1\n            curr = curr.right\n        else:\n            break\n\n    return sum_odd\n\n[/Code 2]\n\n[Asserts 2]\n\n# Example BST:          4\n#                      / \\\n#                     2   6\n#                    / \\ / \\\n#                   1  3 5  7\nnode1 = TreeNode(4, TreeNode(2, TreeNode(1), TreeNode(3)), TreeNode(6, TreeNode(5), TreeNode(7))\nassert sumOddIndexedValues(node1) == 16\n\n# Example BST:          3\n#                      / \\\n#                     1   5\n#                    /     \\\n#                   0       7\nnode2 = TreeNode(3, TreeNode(1, TreeNode(0)), TreeNode(5, None, TreeNode(7)))\nassert sumOddIndexedValues(node2) == 3\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'string', 'frequency', 'concatenating', 'even', 'maximum length', 'dictionary', 'tuple', 'zip']", "prompt_tokens": 671, "total_tokens": 986, "completion_tokens": 315, "completion": "[Question 2]\n\nGiven a circular array arr[] of integers, the task is to form a new array which contains the least possible frequency of each element after concatenating the original array with itself, and then removing one element at a time in a circular fashion. Return the updated array after each removal.\n\n[/Question 2]\n\n[Code 2]\n\ndef updateFrequency(arr: list) -> list:\n    freq = {}\n    for num in arr:\n        freq[num] = freq.get(num, 0) + 1\n    results = []\n    for i in range(len(arr)):\n        freq[arr[i]] -= 1\n        if freq[arr[i]] == 0:\n            del freq[arr[i]]\n        results.append(len(freq))\n    return results\n\n[/Code 2]\n\n[Asserts 2]\n\nassert updateFrequency([1, 2, 3, 4, 5]) == [4, 3, 2, 1, 1]\nassert updateFrequency([4, 2, 4, 2, 4, 2]) == [2, 1, 3, 2, 1, 3]\nassert updateFrequency([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]) == [10, 9, 9, 8, 7, 7, 7, 7, 8, 9, 10]\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'integer', 'pairs', 'unique', 'set', 'list', 'tuple']", "prompt_tokens": 650, "total_tokens": 926, "completion_tokens": 276, "completion": "[Question 2]\n\nGiven a list of levels representing events, create a function to find the proportion of decrements in the list.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\ndef findDecrementProportion(levels: List[int]) -> float:\n    total_count = len(levels)\n    decrement_count = sum(1 for i in range(1, total_count) if levels[i] < levels[i-1])\n    proportion = decrement_count / total_count\n    return proportion\n\n[/Code 2]\n\n[Asserts 2]\n\nassert findDecrementProportion([5, 4, 3, 2, 1]) == 1.0\nassert findDecrementProportion([1, 2, 3, 2, 4, 3, 5, 4, 6]) == 0.222\nassert findDecrementProportion([10, 9, 8, 8, 7, 6, 6, 5, 4, 4, 3, 2, 1]) == 0.769\nassert findDecrementProportion([3, 4, 5, 3, 2, 1, 6, 7, 8]) == 0.333\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['BST', 'tree', 'traversal', 'nodes', 'leftmost', 'rightmost']", "prompt_tokens": 631, "total_tokens": 1047, "completion_tokens": 416, "completion": "[Question 2]\n\nGiven a Binary Search Tree (BST), the task is to find the negative difference between the values of the rightmost and the leftmost nodes in the BST, considering only the repeating numbers in the longest increasing subsequence of the BST nodes.\n\n[/Question 2]\n\n[Code 2]\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef inorderTraversal(root):\n    if root:\n        return inorderTraversal(root.left) + [root.val] + inorderTraversal(root.right)\n    else:\n        return []\n\ndef longestIncreasingSubsequence(nums):\n    n = len(nums)\n    lis = [1] * n\n    for i in range(1, n):\n        for j in range(0, i):\n            if nums[i] > nums[j] and lis[i] < lis[j] + 1:\n                lis[i] = lis[j] + 1\n    return max(lis)\n\ndef findNegativeDifference(root):\n    nums = inorderTraversal(root)\n    longest_seq_length = longestIncreasingSubsequence(nums)\n    repeating_nums = [x for x in nums if nums.count(x) > 1]\n    repeating_seq_length = longestIncreasingSubsequence(repeating_nums)\n    rightmost = max(nums[-longest_seq_length:])\n    leftmost = min(nums[:longest_seq_length])\n    negative_difference = -(rightmost - leftmost)\n    return negative_difference\n\n[/Code 2]\n\n[Asserts 2]\n\nroot = TreeNode(5, TreeNode(3, TreeNode(2), TreeNode(4)), TreeNode(8, TreeNode(7), TreeNode(10)))\nassert findNegativeDifference(root) == -4\n\nroot = TreeNode(10, TreeNode(5, TreeNode(3, TreeNode(3), TreeNode(7)), TreeNode(8)), TreeNode(15, TreeNode(12), TreeNode(20)))\nassert findNegativeDifference(root) == -2\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['integer', 'sum', 'partition', 'subset', 'closest']", "prompt_tokens": 490, "total_tokens": 1000, "completion_tokens": 510, "completion": "[Question 2]\n\nGiven a list of integers, we want to find all friendly pairs, where a friendly pair is a pair of integers whose sum of the divisors (excluding itself) is equal to the other number in the pair. Your task is to write a function to find all friendly pairs in the given list.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List, Tuple\n\ndef sum_of_divisors(n: int) -> int:\n    result = 1\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            result += i\n            if i != n // i:\n                result += n // i\n    return result\n\ndef findFriendlyPairs(nums: List[int]) -> List[Tuple[int, int]]:\n    friendly_pairs = []\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            if sum_of_divisors(nums[i]) == nums[j] and sum_of_divisors(nums[j]) == nums[i]:\n                friendly_pairs.append((nums[i], nums[j]))\n    return friendly_pairs\n\n[/Code 2]\n\n[Asserts 2]\n\nassert findFriendlyPairs([220, 284, 1184, 1210, 2620, 2924, 5020, 5564, 6232, 6368, 10744, 10856, 12285, 14595, 17296, 18416, 63020, 76084, 66928, 66992, 67095, 71145, 69615, 87633, 79750, 88730, 100485, 124155, 122265]) == [(220, 284), (1184, 1210), (2620, 2924), (5020, 5564), (6232, 6368), (10744, 10856), (12285, 14595), (17296, 18416), (63020, 76084), (66928, 66992)]\nassert findFriendlyPairs([220, 221, 222, 223, 224, 225]) == []\nassert findFriendlyPairs([1184, 1210, 2821, 2924]) == [(1184, 1210), (2821, 2924)]\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['integer', 'palindrome', 'list', 'digits', 'range', 'iteration']", "prompt_tokens": 740, "total_tokens": 936, "completion_tokens": 196, "completion": "[Question 2]\n\nYou are given a list of cities and you need to find all the palindrome cities from the list. A city is considered a palindrome city if the name of the city is a palindrome. Write a function that takes the list of cities as input and returns a list of all the palindrome cities.\n\n[/Question 2]\n\n[Code 2]\n\ndef getPalindromeCities(cities: list) -> list:\n    result = []\n    for city in cities:\n        if city.lower() == city[::-1].lower():\n            result.append(city)\n    return result\n\n[/Code 2]\n\n[Asserts 2]\n\nassert getPalindromeCities(['madam', 'level', 'radar', 'RotOr', 'deified']) == ['madam', 'level', 'radar', 'RotOr', 'deified']\nassert getPalindromeCities(['Paris', 'Rome', 'London', 'Madrid']) == []\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['interview', 'candidate', 'hire', 'optimal stopping', 'strategy', 'math', 'probability', 'selection']", "prompt_tokens": 464, "total_tokens": 628, "completion_tokens": 164, "completion": "[Question 2]\n\nYou are organizing a job fair where companies will interview candidates throughout the day. Each company has a different strategy for how many candidates to interview before making a hiring decision. Can you use the concept of optimal stopping and probability to advise these companies on an optimal hiring strategy that maximizes their chances of selecting the best candidate?\n\n[/Question 2]\n\n[Code 2]\n\ndef optimalHiringStrategy(interviews):\n    import math\n    return round(math.e / interviews)\n\n[/Code 2]\n\n[Asserts 2]\n\nassert optimalHiringStrategy(10) == 1\nassert optimalHiringStrategy(20) == 1\nassert optimalHiringStrategy(30) == 1\nassert optimalHiringStrategy(50) == 1\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['ternary', 'string', 'substring', 'count']", "prompt_tokens": 560, "total_tokens": 775, "completion_tokens": 215, "completion": "[Question 2]\n\nGiven a string str, compose a function that checks if it is possible to partition the string into substrings such that the count of distinct characters in each substring is between the given minimum and maximum value.\n\n[/Question 2]\n\n[Code 2]\n\ndef isPossiblePartition(str: str, min_count: int, max_count: int) -> bool:\n    for i in range(len(str)):\n        for j in range(i, len(str)):\n            substring = str[i:j+1]\n            distinct_chars = len(set(substring))\n            if distinct_chars < min_count or distinct_chars > max_count:\n                return False\n    return True\n\n[/Code 2]\n\n[Asserts 2]\n\nassert isPossiblePartition(\"abbbcde\", 2, 3) == True\nassert isPossiblePartition(\"abcdabc\", 1, 2) == True\nassert isPossiblePartition(\"aaaabbbccc\", 2, 3) == True\nassert isPossiblePartition(\"abcde\", 2, 3) == False", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['integer', 'factorial', 'calculation', 'data type', 'memory limitations', 'machine', 'maximum value']", "prompt_tokens": 436, "total_tokens": 593, "completion_tokens": 157, "completion": "[Question 2]\n\nWrite a program to determine the maximum value of an integer that can be used to calculate the factorial of the number of tasks, considering the data type and memory limitations of the machine.\n\n[/Question 2]\n\n[Code 2]\n\ndef maxIntegerForFactorial(tasks: int) -> int:\n    fact = 1\n    count = 1\n    while fact <= tasks:\n        fact *= count\n        if fact < 0:\n            return count - 1\n        count += 1\n    return count - 2\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maxIntegerForFactorial(5) == 2\nassert maxIntegerForFactorial(10) == 3\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['series', 'positive', 'integer', 'term', 'math', 'sequence']", "prompt_tokens": 434, "total_tokens": 627, "completion_tokens": 193, "completion": "[Question 2]\n\nYou are given a sequence of positive integers as input. Your task is to determine if the sequence contains a term where the carry ahead when adding the digits is greater than a given positive integer.\n\n[/Question 2]\n\n[Code 2]\n\ndef hasLargeCarryAhead(sequence, threshold):\n    for num in sequence:\n        digits = [int(x) for x in str(num)]\n        carry = 0\n        for digit in digits:\n            carry = (carry + digit) // 10\n        if carry > threshold:\n            return True\n    return False\n\n[/Code 2]\n\n[Asserts 2]\n\nassert hasLargeCarryAhead([123, 456, 789], 1) == False\nassert hasLargeCarryAhead([123, 456, 789], 2) == False\nassert hasLargeCarryAhead([123, 456, 789], 3) == True", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['integer', 'flips', 'bit', 'minimize', 'binary', 'operation', 'conditional']", "prompt_tokens": 533, "total_tokens": 802, "completion_tokens": 269, "completion": "[Question 2]\n\nGiven an array of integers representing months in binary notation, you need to minimize the number of flips required to convert all the months to their last index (1-based index). A flip is defined as changing a 0 bit to 1 or vice versa. Your task is to compute the total number of flips required to achieve this.\n\n[/Question 2]\n\n[Code 2]\n\ndef countFlipsToLastIndex(months: List[int]) -> int:\n    flips = 0\n    for i, month in enumerate(months):\n        binaryMonth = bin(month)[2:].zfill(4)\n        flips += sum([1 for bit in binaryMonth if bit=='1'])\n    return flips\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countFlipsToLastIndex([5, 10, 3, 12])==10\nassert countFlipsToLastIndex([6, 9, 8, 7])==11\nassert countFlipsToLastIndex([1, 2, 3, 4])==9\nassert countFlipsToLastIndex([15, 15, 15, 15])==0\nassert countFlipsToLastIndex([0, 0, 0, 0])==16\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['arrays', 'strings', 'vowels', 'count', 'comparison', 'pairs', 'length', 'conditions']", "prompt_tokens": 643, "total_tokens": 891, "completion_tokens": 248, "completion": "[Question 2]\n\nGiven an array of strings, the task is to find the string that is \"warmer\", in terms of string length, compared to all other strings in the array. The string that is warmer has a length closer to the average length of all strings in the array. Write a function that takes in the array of strings and returns the warmer string based on this comparison.\n\n[/Question 2]\n\n[Code 2]\n\ndef findWarmerString(arr: List[str]) -> str:\n    avg_length = sum(len(s) for s in arr) / len(arr)\n    diffs = [abs(len(s) - avg_length) for s in arr]\n    index = diffs.index(min(diffs))\n    return arr[index]\n\n[/Code 2]\n\n[Asserts 2]\n\nassert findWarmerString([\"apple\", \"banana\", \"orange\", \"kiwi\"]) == \"orange\"\nassert findWarmerString([\"hello\", \"world\", \"hi\"]) == \"world\"\nassert findWarmerString([\"python\", \"java\", \"csharp\", \"javascript\"]) == \"csharp\"\nassert findWarmerString([\"code\", \"challenge\", \"programming\"]) == \"challenge\"\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'bitwise', 'sum', 'pairs', 'integer', 'logic']", "prompt_tokens": 541, "total_tokens": 911, "completion_tokens": 370, "completion": "[Question 2]\n\nYou are given an array of integers, you need to re-order the array such that all even numbers come before all odd numbers. The re-ordering should be done using bitwise logic operations. Can you write a function to achieve this efficiently?\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef reOrderArray(arr: List[int]) -> List[int]:\n    left, right = 0, len(arr) - 1\n    while left < right:\n        while arr[left] & 1 == 0 and left < right:\n            left += 1\n        while arr[right] & 1 == 1 and left < right:\n            right -= 1\n        if left < right:\n            arr[left], arr[right] = arr[right], arr[left]\n    return arr\n\n[/Code 2]\n\n[Asserts 2]\n\nassert reOrderArray([1, 2, 3, 4, 5, 6, 7, 8, 9]) == [8, 2, 6, 4, 5, 3, 7, 1, 9]\nassert reOrderArray([2, 4, 6, 8, 10, 1, 3, 5, 7, 9]) == [10, 2, 4, 6, 8, 1, 3, 5, 7, 9]\nassert reOrderArray([11, 22, 33, 44, 55, 66, 77, 88, 99]) == [88, 22, 66, 44, 55, 33, 77, 11, 99]\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['string', 'character', 'occurrence', 'multiple', 'accept', 'regex', 'pattern']", "prompt_tokens": 503, "total_tokens": 670, "completion_tokens": 167, "completion": "[Question 2]\n\nWrite a Python function that accepts a string and checks if it matches a pattern where the characters form a rectangle when printed, and if so, return True.\n\n[/Question 2]\n\n[Code 2]\n\nimport re\n\ndef formsRectangle(s: str) -> bool:\n    if re.match(r'^(\\w+)\\n\\1\\n\\1$', s):\n        return True\n    return False\n\n[/Code 2]\n\n[Asserts 2]\n\nassert formsRectangle(\"abc\\nabc\\nabc\")==True\nassert formsRectangle(\"abcd\\nabcd\\nabcd\")==False\nassert formsRectangle(\"1234\\n1234\\n1234\")==True\nassert formsRectangle(\"ab\\nab\\nab\")==False\nassert formsRectangle(\"xyz\\nxyz\\nxyz\\nxyz\")==False\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'integers', 'Fibonacci', 'series', 'increment', 'decrement', 'operation', 'math']", "prompt_tokens": 614, "total_tokens": 884, "completion_tokens": 270, "completion": "[Question 2]\n\nYou have been given a series of integers forming an array. Your task is to write a function that returns True if the array forms a valid Fibonacci series, otherwise it should return False. In Fibonacci series, each number is the sum of the two preceding ones, typically starting with 0 and 1.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\ndef isFibonacci(arr: List[int]) -> bool:\n    if len(arr) < 3:\n        return False\n        \n    for i in range(2, len(arr)):\n        if arr[i-2] + arr[i-1] != arr[i]:\n            return False\n    return True\n\n[/Code 2]\n\n[Asserts 2]\n\nassert isFibonacci([0, 1, 1, 2, 3, 5, 8]) == True\nassert isFibonacci([0, 1, 1, 2, 3, 6, 9]) == False\nassert isFibonacci([1, 1, 2, 3, 5, 8]) == False\nassert isFibonacci([0, 1, 2, 3, 5, 8]) == True\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['list', 'coins', 'values', 'minimum cost', 'selection', 'extra', 'sort', 'suffix', 'cost']", "prompt_tokens": 579, "total_tokens": 969, "completion_tokens": 390, "completion": "[Question 2]\n\nYou are given a list of N coins with values v1, v2, ..., vn, and you want to make a selection of coins such that the sum of their values is maximum without exceeding a given cost C. Each selection can have extra coins added at a cost of rupees R per coin. Write a function to find the maximum sum of values that can be obtained within the given cost.\n\n[/Question 2]\n\n[Code 2]\n\ndef maxSumWithinCost(n: int, coins: list, cost: int, R: int) -> int:\n    coins.sort(reverse=True)\n    max_sum = 0\n    current_sum = 0\n    for i in range(n):\n        if (current_sum + coins[i]) <= cost:\n            current_sum += coins[i]\n            max_sum = max(max_sum, current_sum)\n        else:\n            extra_coins = (cost - current_sum) // R\n            current_sum += (min(extra_coins, n - (i+1)) * R)\n            max_sum = max(max_sum, current_sum)\n            break\n    return max_sum\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maxSumWithinCost(4, [10, 7, 5, 3], 14, 2) == 12\nassert maxSumWithinCost(5, [20, 15, 10, 8, 5], 30, 3) == 28\nassert maxSumWithinCost(3, [50, 40, 30], 70, 5) == 70\nassert maxSumWithinCost(3, [50, 40, 30], 50, 7) == 47\nassert maxSumWithinCost(2, [20, 10], 15, 4) == 14\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['positive integer', 'list', 'subarray', 'increasing', 'decreasing', 'sequence']", "prompt_tokens": 557, "total_tokens": 875, "completion_tokens": 318, "completion": "[Question 2]\n\nGiven a positive integer N, the task is to create a 2D space with N rows and N columns, where the values start from math.pi and increase in an increasing sequence up to N^2. Then, for each row, sort the elements in decreasing order and return the updated 2D space.\n\n[/Question 2]\n\n[Code 2]\n\nimport math\nfrom typing import List\ndef create2DSpace(N: int) -> List[List[float]]:\n    space = [[0 for _ in range(N)] for _ in range(N)]\n    val = math.pi\n    for i in range(N):\n        for j in range(N):\n            space[i][j] = val\n            val += 1\n    for i in range(N):\n        space[i].sort(reverse=True)\n    return space\n\n[/Code 2]\n\n[Asserts 2]\n\nassert create2DSpace(2)==[[3.141592653589793, 4.141592653589793],[5.141592653589793, 6.141592653589793]]\nassert create2DSpace(3)==[[5.141592653589793, 4.141592653589793, 3.141592653589793],[6.141592653589793, 5.141592653589793, 4.141592653589793],[7.141592653589793, 6.141592653589793, 5.141592653589793]]\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['series', 'nth term', 'math', 'sequence', 'pattern', 'cubic', 'function', 'calculation']", "prompt_tokens": 479, "total_tokens": 630, "completion_tokens": 151, "completion": "[Question 2]\n\nYou are given a sequence of numbers: 1, 8, 27, 64, 125, 216, ... . Write a function to find the Nth term of the sequence.\n\n[/Question 2]\n\n[Code 2]\n\ndef findNthTerm(n: int) -> int:\n    return n**3\n\n[/Code 2]\n\n[Asserts 2]\n\nassert findNthTerm(1)==1\nassert findNthTerm(2)==8\nassert findNthTerm(3)==27\nassert findNthTerm(4)==64\nassert findNthTerm(5)==125\nassert findNthTerm(6)==216\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'maximum', 'minimum', 'decrement', 'binary search', 'subtraction', 'math']", "prompt_tokens": 615, "total_tokens": 814, "completion_tokens": 199, "completion": "[Question 2]\n\nYou are given an array of integers representing the latitude values of a set of locations. Perform a binary search to find the minimum difference between any two latitude values in the array.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\ndef minLatitudeDifference(latitude: List[int]) -> int:\n    \n    n = len(latitude)\n    latitude.sort()\n    result = float('inf')\n    \n    for i in range(1, n):\n        result = min(result, latitude[i] - latitude[i-1])\n    \n    return result\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minLatitudeDifference([1, 3, 6, 7, 9]) == 1\nassert minLatitudeDifference([10, 20, 30, 40, 50]) == 10\nassert minLatitudeDifference([5, 7, 10, 12]) == 2\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['integer', 'subsequence', 'GCD', 'math', 'binary', 'bitwise']", "prompt_tokens": 616, "total_tokens": 1053, "completion_tokens": 437, "completion": "[Question 2]\n\nGiven a weighted undirected graph with edge weights represented as integers, write a function to compute the minimum weight of an acyclic subsequence of the graph using bitwise operations.\n\n[/Question 2]\n\n[Code 2]\n\ndef minWeightAcyclicSubsequence(graph: dict) -> int:\n    n = len(graph)\n    dp = [-1] * (1<<n)\n    \n    def dfs(mask: int) -> int:\n        if dp[mask] != -1:\n            return dp[mask]\n        dp[mask] = float('inf')\n        for v in range(n):\n            if not (mask & (1<<v)):\n                future_w = 0\n                for u, w in graph[v]:\n                    if mask & (1<<u):\n                        future_w = max(future_w, w)\n                dp[mask] = min(dp[mask], max(future_w, dfs(mask | (1<<v))))\n        return dp[mask]\n    \n    return dfs(0)\n\n[/Code 2]\n\n[Asserts 2]\n\ngraph1 = {\n    0: [(1, 2), (2, 6)],\n    1: [(0, 2), (2, 3)],\n    2: [(0, 6), (1, 3)]\n}\n\ngraph2 = {\n    0: [(1, 3), (3, 2)],\n    1: [(0, 3), (2, 4)],\n    2: [(1, 4), (3, 6)],\n    3: [(0, 2), (2, 6)]\n}\n\ngraph3 = {\n    0: [(1, 5), (2, 7)],\n    1: [(0, 5), (2, 8)],\n    2: [(0, 7), (1, 8)]\n}\n\nassert minWeightAcyclicSubsequence(graph1) == 6\nassert minWeightAcyclicSubsequence(graph2) == 6\nassert minWeightAcyclicSubsequence(graph3) == 8\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['integer', 'array', 'XOR', 'prefix', 'construct', 'bitwise', 'operation']", "prompt_tokens": 598, "total_tokens": 1056, "completion_tokens": 458, "completion": "[Question 2]\n\nYou are given an array of integers representing the number of tickets sold for each day. The task is to find the maximum XOR value for any pair of ticket sale days.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\nclass TrieNode:\n    def __init__(self):\n        self.children = {}\n        \ndef insert(num, root):\n    node = root\n    for i in range(31, -1, -1):\n        bit = (num >> i) & 1\n        if bit not in node.children:\n            node.children[bit] = TrieNode()\n        node = node.children[bit]\n        \ndef findMaxXOR(nums: List[int]) -> int:\n    root = TrieNode()\n    for num in nums:\n        insert(num, root)\n    ans = 0\n    for num in nums:\n        node = root\n        current_xor = 0\n        for i in range(31, -1, -1):\n            bit = (num >> i) & 1\n            if bit ^ 1 in node.children:\n                current_xor += (1 << i)\n                node = node.children[bit ^ 1]\n            else:\n                node = node.children[bit]\n        ans = max(ans, current_xor)\n    return ans\n\n[/Code 2]\n\n[Asserts 2]\n\nassert findMaxXOR([4, 6, 7, 2, 8, 9, 5, 1]) == 15\nassert findMaxXOR([10, 11, 7, 6, 9, 3, 8, 14, 7]) == 9\nassert findMaxXOR([22, 5, 11, 15, 7, 9, 3, 28, 10]) == 31\nassert findMaxXOR([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == 15\nassert findMaxXOR([3, 10, 5, 25, 2, 8]) == 28\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['integer', 'multiply', 'add', 'alternatively', 'final number', 'positive', 'number']", "prompt_tokens": 524, "total_tokens": 847, "completion_tokens": 323, "completion": "[Question 2]\n\nYou are given a set of distinct line segments on a 2D plane. You need to write a function to determine the strength of the set, which is calculated by multiplying the slopes of all the line segments alternatively and then adding the number of distinct lines. Additionally, if the final number is positive, return True; otherwise, return False.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\ndef strengthOfSet(lineSegments: List[List[int]]) -> bool:\n    slopes = [getSlope(segment) for segment in lineSegments]\n    strength = 0\n    for i in range(len(slopes)):\n        if i % 2 == 0:\n            strength *= slopes[i]\n        else:\n            strength += slopes[i]\n    return strength + len(lineSegments) > 0\n\ndef getSlope(segment: List[int]) -> float:\n    # Implement the logic to get slope from line segment\n    pass\n\n[/Code 2]\n\n[Asserts 2]\n\n# Assuming getSlope function is implemented correctly\nassert strengthOfSet([[1, 2], [3, 4], [5, 6]]) == True\nassert strengthOfSet([[2, 4], [3, 6], [7, 8]]) == False\nassert strengthOfSet([[1, 1], [2, 2], [3, 3]]) == False\nassert strengthOfSet([[1, 2], [2, 4], [5, 6]]) == True\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['binary', 'string', 'flip', 'prefix', 'minimum', 'convert']", "prompt_tokens": 625, "total_tokens": 979, "completion_tokens": 354, "completion": "[Question 2]\n\nGiven a binary string, write a function to find the minimum number of reversals needed to make every pair of consecutive characters as \"01\". The string may contain multiple occurrences of \"10\" or \"01\". If it's not possible to make every pair of consecutive characters as \"01\", then return -1.\n\n[/Question 2]\n\n[Code 2]\n\ndef minReversals(s: str) -> int:\n    n = len(s)\n    if n % 2 != 0:\n        return -1\n    ones = 0\n    twos = 0\n    for i in range(n):\n        if s[i] == '1':\n            ones += 1\n        else:\n            twos += 1\n        ones %= 2\n        twos %= 2\n    if ones != twos:\n        return -1\n    ans = 0\n    for i in range(0, n, 2):\n        if s[i] == '1':\n            if s[i + 1] == '1':\n                ans += 2\n            else:\n                ans += 1\n        else:\n            if s[i + 1] == '0':\n                ans += 2\n            else:\n                ans += 1\n    return ans\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minReversals(\"1010\") == 0\nassert minReversals(\"0101\") == 0\nassert minReversals(\"111000\") == 3\nassert minReversals(\"100111001\") == 3\nassert minReversals(\"001010110\") == 4\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['prime', 'integer', 'reverse', 'square', 'adam', 'number', 'range', 'task', 'find', 'return', 'reversed']", "prompt_tokens": 1098, "total_tokens": 1459, "completion_tokens": 361, "completion": "[Question 2]\n\nYou are given a list of integers. Write a function to return the count of prime Adam integers in the list. An integer is considered a prime Adam integer if it is a prime number and the result of performing an AND operation between the number and its reverse is prime. For example, 13 is a prime Adam integer because 13 & 31 = 1, and 1 is a prime number.\n\n[/Question 2]\n\n[Code 2]\n\ndef isPrime(n: int) -> bool:\n\tif n <= 1:\n\t\treturn False\n\tfor i in range(2, int(n**0.5) + 1):\n\t\tif n % i == 0:\n\t\t\treturn False\n\treturn True\n\ndef reverse_number(n: int) -> int:\n\treturn int(str(n)[::-1])\n\ndef isAdamNumber(n: int) -> bool:\n\treverse_n = reverse_number(n)\n\treturn isPrime(n & reverse_n)\n\ndef countPrimeAdamIntegers(arr: list) -> int:\n\tcount = 0\n\tfor num in arr:\n\t\tif isPrime(num) and isAdamNumber(num):\n\t\t\tcount += 1\n\treturn count\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countPrimeAdamIntegers([13, 23, 43, 53, 67, 89])==6\nassert countPrimeAdamIntegers([113, 311, 121, 787, 171, 353])==3\nassert countPrimeAdamIntegers([101, 131, 141, 151, 787, 797])==3\nassert countPrimeAdamIntegers([123, 234, 345, 456, 567, 678])==0\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['string', 'substring', 'repeated', 'smallest', 'pattern', 'concatenation', 'multiple']", "prompt_tokens": 515, "total_tokens": 929, "completion_tokens": 414, "completion": "[Question 2]\n\nGiven a list of strings, find the smallest substring which has all the letters of the given pattern.\n\n[/Question 2]\n\n[Code 2]\n\ndef minWindow(s: str, t: str) -> str:\n    if not s or not t or len(s) < len(t):\n        return \"\"\n\n    hash_map = {}\n    for char in t:\n        if char in hash_map:\n            hash_map[char] += 1\n        else:\n            hash_map[char] = 1\n\n    required = len(hash_map)\n    left, right, formed = 0, 0, 0\n    window_counts = {}\n\n    ans = float(\"inf\"), None, None\n\n    while right < len(s):\n        character = s[right]\n        window_counts[character] = window_counts.get(character, 0) + 1\n        if character in hash_map and window_counts[character] == hash_map[character]:\n            formed += 1\n\n        while left <= right and formed == required:\n            character = s[left]\n\n            if right - left + 1 < ans[0]:\n                ans = (right - left + 1, left, right)\n\n            window_counts[character] -= 1\n            if character in hash_map and window_counts[character] < hash_map[character]:\n                formed -= 1\n\n            left += 1\n\n        right += 1\n\n    return \"\" if ans[0] == float(\"inf\") else s[ans[1]: ans[2] + 1]\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minWindow(\"ADOBECODEBANC\", \"ABC\") == \"BANC\"\nassert minWindow(\"this is a test string\", \"tist\") == \"t stri\"\nassert minWindow(\"a\", \"a\") == \"a\"\nassert minWindow(\"a\", \"aa\") == \"\"\nassert minWindow(\"cabwefgewcwaefgcf\", \"cae\") == \"cwae\"", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'pairs', 'count', 'comparison', 'iteration', 'math']", "prompt_tokens": 560, "total_tokens": 844, "completion_tokens": 284, "completion": "[Question 2]\n\nGiven an array arr of integers and a target integer K, write a function to count the number of pairs (i, j) where arr[i] + arr[j] is equal to K.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List, Dict\ndef countPairsWithSum(arr: List[int], K: int) -> int:\n    pair_count = 0\n    num_frequency: Dict[int, int] = {}\n    for num in arr:\n        difference = K - num\n        if difference in num_frequency:\n            pair_count += num_frequency[difference]\n        if num in num_frequency:\n            num_frequency[num] += 1\n        else:\n            num_frequency[num] = 1\n    return pair_count\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countPairsWithSum([1, 3, 5, 7], 8)==2\nassert countPairsWithSum([4, 6, 8, 2, 10, 12], 10)==3\nassert countPairsWithSum([7, 5, 3, 1, 6, 4, 2], 8)==3\nassert countPairsWithSum([3, 3, 3, 3, 3, 3], 6)==15\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['tree', 'leaves', 'subtree', 'minimum', 'depth-first search', 'dfs', 'node', 'integer', 'remove']", "prompt_tokens": 589, "total_tokens": 973, "completion_tokens": 384, "completion": "[Question 2]\n\nGiven a tree with integer values at each node, the task is to find the minimum start index of a subtree such that the sum of all nodes in the subtree is a composite integer. If no such subtree exists, return -1.\n\n[/Question 2]\n\n[Code 2]\n\nclass TreeNode:\n    def __init__(self, value: int, children: List['TreeNode'] = None):\n        self.value = value\n        self.children = children if children is not None else []\n\ndef is_composite(num):\n    if num < 4:\n        return False\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            return True\n    return False\n\ndef dfs(node, prefix_sum, index, target, result):\n    if node is None:\n        return 0\n    prefix_sum += node.value\n    index += 1\n    if is_composite(prefix_sum):\n        result[0] = min(result[0], index)\n    for child in node.children:\n        dfs(child, prefix_sum, index, target, result)\n\ndef minStartIndexForCompositeSubtree(root: TreeNode) -> int:\n    result = [float('inf')]\n    dfs(root, 0, -1, 0, result)\n    return result[0] if result[0] != float('inf') else -1\n\n[/Code 2]\n\n[Asserts 2]\n\n# Creating a tree for testing\ntree = TreeNode(1, [TreeNode(2, [TreeNode(3), TreeNode(4)]), TreeNode(5)])\nassert minStartIndexForCompositeSubtree(tree) == 2\n\ntree = TreeNode(8, [TreeNode(3), TreeNode(5)])\nassert minStartIndexForCompositeSubtree(tree) == 0\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['triangle', 'coordinates', 'perimeter', 'distance', 'geometry', 'shape', 'point', 'inside', 'count']", "prompt_tokens": 733, "total_tokens": 1088, "completion_tokens": 355, "completion": "[Question 2]\n\nGiven a string representing a set of coordinates in the format \"x1,y1 x2,y2 x3,y3\", write a function to check if the given coordinates form a valid triangle on the Cartesian plane. If it forms a valid triangle, return the perimeter of the triangle; otherwise, return -1.\n\n[/Question 2]\n\n[Code 2]\n\ndef distance(x1, y1, x2, y2):\n    return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5\n\ndef isTriangleAndPerimeter(s: str) -> float:\n    coordinates = list(map(int, s.split()))\n    x1, y1, x2, y2, x3, y3 = coordinates\n    side1 = distance(x1, y1, x2, y2)\n    side2 = distance(x2, y2, x3, y3)\n    side3 = distance(x3, y3, x1, y1)\n\n    if side1 + side2 > side3 and side2 + side3 > side1 and side3 + side1 > side2:\n        return side1 + side2 + side3\n    else:\n        return -1\n\n[/Code 2]\n\n[Asserts 2]\n\nassert isTriangleAndPerimeter(\"1,2 4,6 7,3\") == 14.288\nassert isTriangleAndPerimeter(\"1,1 1,2 1,3\") == -1\nassert isTriangleAndPerimeter(\"-1,-1 -1,1 1,0\") == 6.472\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['factors', 'number', 'product', 'max', 'math']", "prompt_tokens": 579, "total_tokens": 817, "completion_tokens": 238, "completion": "[Question 2]\n\nWrite a function to find the maximum product of two distinct factors of a given number N. The function should have O(1) space complexity. If the number N has less than 2 factors, the function should return 0.\n\n[/Question 2]\n\n[Code 2]\n\ndef maxProductTwoFactors(num: int) -> int:\n    if num < 4:\n        return 0\n    factor1 = 1\n    factor2 = num\n    i = 2\n    while i*i <= num:\n        if num % i == 0:\n            factor1 = i\n            factor2 = num // i\n        i += 1\n    return factor1 * factor2\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maxProductTwoFactors(10) == 20\nassert maxProductTwoFactors(20) == 100\nassert maxProductTwoFactors(5) == 0\nassert maxProductTwoFactors(100) == 500\nassert maxProductTwoFactors(30) == 150\nassert maxProductTwoFactors(7) == 0\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['staircase', 'steps', 'unique', 'count', 'combinations', 'recursion', 'bitwise', 'math']", "prompt_tokens": 483, "total_tokens": 764, "completion_tokens": 281, "completion": "[Question 2]\n\nYou are given a list of integers representing the weights of items. You want to approximate the median weight of the items. Write a function to find the approximate median weight using integer division (//) and without using any built-in median functions.\n\n[/Question 2]\n\n[Code 2]\n\ndef approximateMedian(weights: List[int]) -> int:\n    weights.sort()\n    n = len(weights)\n    if n % 2 == 0:\n        return (weights[n//2 - 1] + weights[n//2]) // 2\n    else:\n        return weights[n//2]\n\n[/Code 2]\n\n[Asserts 2]\n\nassert approximateMedian([1, 3, 5, 7, 9]) == 5\nassert approximateMedian([1, 2, 3, 4, 5, 6]) == 3\nassert approximateMedian([4, 1, 3, 2, 5]) == 3\nassert approximateMedian([10, 20, 30, 40, 50, 60, 70, 80, 90, 100]) == 55\nassert approximateMedian([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]) == 4", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['string', 'ternary', 'expression', 'binary tree', 'conditional', 'evaluation', 'stack']", "prompt_tokens": 791, "total_tokens": 1054, "completion_tokens": 263, "completion": "[Question 2]\n\nYou are given an expression in the form of a string that represents a mathematical function. Write a function to interpolate this string expression using the Lagrange interpolation formula and return the resulting function. The Lagrange interpolation formula is used to find a polynomial which passes through a given set of points. The given expression contains conditional ternary expressions and needs to be interpolated to obtain a meaningful function.\n\n[/Question 2]\n\n[Code 2]\n\ndef lagrange_interpolation(expression: str) -> str:\n    # Write your code here to perform lagrange interpolation on the given expression\n    interpolated_function = \"\"\n    # Your code logic here\n    return interpolated_function\n\n[/Code 2]\n\n[Asserts 2]\n\n# Testing lagrange_interpolation function\n# \"x>0?x:-x\" is the given expression which needs to be interpolated\nexpression = \"x>0?x:-x\"\n# Expected interpolated function result should be \"x\"\nassert lagrange_interpolation(expression) == \"x\"\n# \"y<0?-y:y\" is the given expression which needs to be interpolated\nexpression = \"y<0?-y:y\"\n# Expected interpolated function result should be \"y\"\nassert lagrange_interpolation(expression) == \"y\"\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'integers', 'minimum', 'difference', 'sorting', 'comparison']", "prompt_tokens": 510, "total_tokens": 742, "completion_tokens": 232, "completion": "[Question 2]\n\nWrite a function to find the minimum difference between any two integers in a given array of integers, without using any extra space and sorting the array. \n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef minDifferenceNoExtraSpace(arr: List[int]) -> int:\n    min_diff = float('inf')\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            diff = abs(arr[j] - arr[i])\n            if diff < min_diff:\n                min_diff = diff\n    return min_diff\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minDifferenceNoExtraSpace([4, 2, 1, 3]) == 1\nassert minDifferenceNoExtraSpace([3, 10, 8, 17]) == 2\nassert minDifferenceNoExtraSpace([1, 5, 3, 19, 18, 25]) == 1\nassert minDifferenceNoExtraSpace([30, 5, 20, 9]) == 4\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['count', 'stairs', 'climb', 'ways', 'dynamic programming', 'combinations', 'recursive']", "prompt_tokens": 570, "total_tokens": 1011, "completion_tokens": 441, "completion": "[Question 2]\n\nYou are given an array of integers representing the heights of the walls of a circular courtyard. A circular arc of 30 degrees subtends an angle of 30 degrees at the center. You have to transform this array into an array representing the x-coordinates of the endpoints of the circular arcs with the highest possible total length. Write a function to find the maximum total length that can be achieved by placing circular arcs over the walls.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\ndef maxCircularArcsLength(walls: List[int]) -> float:\n    def maxTotalLength(i: int, prevHeight: int, memo) -> float:\n        if i == len(walls):\n            return 0\n        if (i, prevHeight) in memo:\n            return memo[(i, prevHeight)]\n        takeCurr = 0\n        if walls[i] > prevHeight:\n            takeCurr = maxTotalLength(\n                i + 1, walls[i], memo) + walls[i]\n        skipCurr = maxTotalLength(i + 1, prevHeight, memo)\n        memo[(i, prevHeight)] = max(takeCurr, skipCurr)\n        return memo[(i, prevHeight)]\n\n    return maxTotalLength(0, 0, {})\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maxCircularArcsLength([1, 2, 3, 4, 5]) == 9.03\nassert maxCircularArcsLength([3, 4, 5, 6, 1, 2, 3, 7]) == 18.89\nassert maxCircularArcsLength([5, 4, 3, 2, 1]) == 9.03\nassert maxCircularArcsLength([1, 2, 1, 2, 1, 2, 1, 2]) == 8.70\nassert maxCircularArcsLength([2, 2, 2, 2, 2, 2]) == 10.47\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['coordinates', 'distinct', 'squares', 'sorting', 'finding']", "prompt_tokens": 643, "total_tokens": 1066, "completion_tokens": 423, "completion": "[Question 2]\n\nYou are given a list of distinct coordinates representing the bottom-left and top-right coordinates of squares. Write a function to allocate the squares into two distinct groups such that the sum of x-coordinates and y-coordinates in each group is odd.\n\nWrite a function to allocate the squares into two distinct groups such that the sum of x-coordinates and y-coordinates in each group is odd.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List, Tuple\ndef allocateSquares(coords: List[Tuple[int, int, int, int]]) -> List[List[Tuple[int, int, int, int]]]:\n    odd_sum_x = []\n    even_sum_x = []\n    \n    for coord in coords:\n        x1, y1, x2, y2 = coord\n        if (x1 + x2) % 2 != 0 and (y1 + y2) % 2 != 0:\n            odd_sum_x.append(coord)\n        else:\n            even_sum_x.append(coord)\n    \n    return [odd_sum_x, even_sum_x]\n\n[/Code 2]\n\n[Asserts 2]\n\nassert allocateSquares([(1, 1, 2, 2), (2, 3, 5, 8), (4, 4, 6, 6), (3, 1, 7, 5)]) == [[(2, 3, 5, 8)], [(1, 1, 2, 2), (4, 4, 6, 6), (3, 1, 7, 5)]]\nassert allocateSquares([(0, 0, 1, 1), (2, 2, 4, 4), (5, 5, 7, 7)]) == [[(0, 0, 1, 1), (2, 2, 4, 4), (5, 5, 7, 7)], []]\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['positive', 'integer', 'sum', 'product', 'consecutive', 'binomial coefficient', 'dynamic programming']", "prompt_tokens": 506, "total_tokens": 774, "completion_tokens": 268, "completion": "[Question 2]\n\nYou are given an array of positive integers representing the energy levels at various positions. Write a function to find the maximum energy that can be obtained by joining consecutive energy levels and finding the sum of their products.\n\n[/Question 2]\n\n[Code 2]\n\ndef maxEnergy(nums: List[int]) -> int:\n    n = len(nums)\n    if n == 0:\n        return 0\n    if n == 1:\n        return nums[0]\n\n    dp = [0] * n\n    dp[0] = nums[0]\n    dp[1] = max(nums[0]*nums[1], nums[1])\n\n    for i in range(2, n):\n        dp[i] = max(nums[i] + nums[i-1]*nums[i], dp[i-1] + nums[i])\n\n    return max(dp)\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maxEnergy([1, 2, 3, 4])==33\nassert maxEnergy([1, 2, 3, 4, 5])==53\nassert maxEnergy([3, 1, 2, 4, 6])==63\nassert maxEnergy([2, 1, 3, 2, 4, 1])==36", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['insertion sort', 'array', 'sorting', 'ascending', 'descending', 'even', 'odd', 'positioned', 'algorithm']", "prompt_tokens": 797, "total_tokens": 1280, "completion_tokens": 483, "completion": "[Question 2]\n\nYou are given an array representing the costs of glasses at various positions. You need to sort the array in such a way that the costs of glasses at odd positions are in descending order, and the costs of glasses at even positions are in ascending order. Implement an algorithm to achieve this and return the sorted array.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef sortGlassesCosts(arr: List[int]) -> List[int]:\n    n = len(arr)\n    for i in range(1, n):\n        if i % 2 == 0:\n            key = arr[i]\n            j = i - 1\n            while j >= 0 and arr[j] > key:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key\n        else:\n            key = arr[i]\n            j = i - 1\n            while j >= 0 and arr[j] < key:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key\n    return arr\n\n[/Code 2]\n\n[Asserts 2]\n\nassert sortGlassesCosts([40, 30, 35, 20, 25, 15, 10, 5])==[35, 10, 30, 15, 25, 20, 40, 5]\nassert sortGlassesCosts([100, 90, 80, 70, 60, 50, 40, 30, 20, 10])==[80, 20, 90, 30, 70, 40, 60, 50, 100, 10]\nassert sortGlassesCosts([25, 30, 35, 40, 10, 15, 20, 5])==[30, 5, 35, 10, 25, 15, 40, 20]\nassert sortGlassesCosts([18, 22, 15, 10, 13, 17, 21, 25])==[17, 10, 18, 13, 22, 15, 25, 21]\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['palindromic', 'substrings', 'count', 'positive integer', 'modulus', 'iteration']", "prompt_tokens": 522, "total_tokens": 822, "completion_tokens": 300, "completion": "[Question 2]\n\nGiven a list of positive integers, find the minimum difference between any pair of palindromic integers formed by taking substrings of each number at even positions.\n\n[/Question 2]\n\n[Code 2]\n\ndef minPalindromicDifference(nums):\n    def isPalindromic(s):\n        return s == s[::-1]\n    \n    min_diff = float('inf')\n    for num in nums:\n        num_str = str(num)\n        for i in range(1, len(num_str), 2):\n            for j in range(i+1, len(num_str)+1, 2):\n                substr = num_str[i:j]\n                if isPalindromic(substr):\n                    diff = abs(int(substr) - int(substr[::-1]))\n                    min_diff = min(min_diff, diff)\n    return min_diff\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minPalindromicDifference([12345, 67890, 54321]) == 0\nassert minPalindromicDifference([98765, 12321, 99999]) == 1\nassert minPalindromicDifference([1001, 23432, 56765]) == 0\nassert minPalindromicDifference([13579, 24680, 2468642]) == 2\nassert minPalindromicDifference([97531, 86420, 135798642]) == 3", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['integer', 'sum', 'distinct', 'LCM', 'math', 'gcd', 'lcm']", "prompt_tokens": 497, "total_tokens": 1026, "completion_tokens": 529, "completion": "[Question 2]\n\nGiven a list of distinct integers, write a function to find the maximum sum of a bitonic subsequence, and then find the least common multiple (LCM) of the elements in that subsequence.\n\n[/Question 2]\n\n[Code 2]\n\ndef gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef maxSumAndLCM(arr):\n    n = len(arr)\n    lis = [0] * n\n    lds = [0] * n\n\n    for i in range(n):\n        lis[i] = arr[i]\n        lds[i] = arr[i]\n\n    for i in range(1, n):\n        for j in range(i):\n            if arr[i] > arr[j] and lis[i] < lis[j] + arr[i]:\n                lis[i] = lis[j] + arr[i]\n\n    for i in range(n - 2, -1, -1):\n        for j in range(n - 1, i, -1):\n            if arr[i] > arr[j] and lds[i] < lds[j] + arr[i]:\n                lds[i] = lds[j] + arr[i]\n\n    max_sum = lis[0] + lds[0] - arr[0]\n    for i in range(1, n):\n        max_sum = max(max_sum, lis[i] + lds[i] - arr[i])\n\n    subsequence = [arr[i] for i in range(n) if lis[i] + lds[i] - arr[i] == max_sum]\n    subsequence_lcm = 1\n    for el in subsequence:\n        subsequence_lcm = lcm(subsequence_lcm, el)\n\n    return max_sum, subsequence_lcm\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maxSumAndLCM([1, 11, 2, 10, 4, 5, 2, 1]) == (31, 110)\nassert maxSumAndLCM([80, 60, 30, 40, 20, 10]) == (210, 240)\nassert maxSumAndLCM([1, 3, 2, 5, 4, 6]) == (15, 60)\nassert maxSumAndLCM([10, 20, 30, 40]) == (100, 120)", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['integer', 'product', 'digits', 'maximum', 'less than', 'positive', 'loop']", "prompt_tokens": 458, "total_tokens": 594, "completion_tokens": 136, "completion": "[Question 2]\n\nWrite a function to count the total number of set bits (1s) in the binary representations of integers less than or equal to a given positive integer N.\n\n[/Question 2]\n\n[Code 2]\n\ndef countSetBits(N: int) -> int:\n    count = 0\n    for i in range(1, N+1):\n        count += bin(i).count('1')\n    return count\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countSetBits(5)==7\nassert countSetBits(10)==17\nassert countSetBits(15)==24\nassert countSetBits(20)==31", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['power', 'modulus', 'math', 'last digits', 'computation']", "prompt_tokens": 434, "total_tokens": 666, "completion_tokens": 232, "completion": "[Question 2]\n\nGiven a list of integers representing the degree sequence of a graph, determine if it is a correct degree sequence or not. A degree sequence is correct if the sum of the degrees is even and each element in the sequence is non-negative.\n\n[/Question 2]\n\n[Code 2]\n\ndef isCorrectDegreeSequence(degrees: List[int]) -> bool:\n    if sum(degrees) % 2 != 0:\n        return False\n    if any(d < 0 for d in degrees):\n        return False\n    return True\n\n[/Code 2]\n\n[Asserts 2]\n\nassert isCorrectDegreeSequence([2, 3, 4, 3, 2]) == True\nassert isCorrectDegreeSequence([1, 0, 3, 2]) == False\nassert isCorrectDegreeSequence([5, 5, 5, 5]) == True\nassert isCorrectDegreeSequence([3, 3, 3, 3, 3, 3]) == False\nassert isCorrectDegreeSequence([0, 0, 0, 0]) == True", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['geometry', 'coordinates', 'vertices', 'rectangle', 'triangle', 'base', 'isosceles']", "prompt_tokens": 592, "total_tokens": 856, "completion_tokens": 264, "completion": "[Question 2]\n\nGiven a rectangle with coordinates of its vertices, write a function to determine if the rectangle contains a repeated digit in its coordinates. \n\n[/Question 2]\n\n[Code 2]\n\ndef containsRepeatedDigit(rectangle_vertices: list) -> bool:\n    for vertex in rectangle_vertices:\n        x, y = vertex\n        x_digits = [int(d) for d in str(abs(x))]  # Extracting digits of x\n        y_digits = [int(d) for d in str(abs(y))]  # Extracting digits of y\n        all_digits = x_digits + y_digits\n        digit_set = set(all_digits)\n        if len(all_digits) != len(digit_set):\n            return True\n    return False\n\n[/Code 2]\n\n[Asserts 2]\n\nassert containsRepeatedDigit([(12, 34), (56, 78)]) == False\nassert containsRepeatedDigit([(11, 23), (45, 67)]) == True\nassert containsRepeatedDigit([(123, 456), (789, 210)]) == False\nassert containsRepeatedDigit([(987, 654), (321, 345)]) == True\nassert containsRepeatedDigit([(111, 222), (333, 444)]) == True\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['bitwise', 'integer', 'OR', 'sum']", "prompt_tokens": 462, "total_tokens": 684, "completion_tokens": 222, "completion": "[Question 2]\n\nGiven an array of integers arr, find if there exists a pair of elements (arr[i], arr[j]) such that arr[i] | arr[j] > arr[i] + arr[j].\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\ndef existsPairWithORGreaterThanSum(arr: List[int]) -> bool:\n    for i in range(len(arr)-1):\n        for j in range(i+1, len(arr)):\n            if arr[i] | arr[j] > arr[i] + arr[j]:\n                return True\n    return False\n\n[/Code 2]\n\n[Asserts 2]\n\nassert existsPairWithORGreaterThanSum([2, 3, 5, 7])==True\nassert existsPairWithORGreaterThanSum([1, 2, 4, 8])==False\nassert existsPairWithORGreaterThanSum([3, 6, 9, 12])==True\nassert existsPairWithORGreaterThanSum([5, 10, 15, 20])==True\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'pairs', 'GCD', 'counting', 'frequency']", "prompt_tokens": 612, "total_tokens": 1342, "completion_tokens": 730, "completion": "[Question 2]\n\nGiven an array of integers, write a Python function to find and return all pairs of numbers where the GCD (Greatest Common Divisor) of the pair is a globally unique identifier (GUID). Additionally, return the frequency of each unique GCD within the pairs.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\nfrom math import gcd\n\ndef findPairsWithUniqueGCD(arr: List[int]) -> List[tuple]:\n    pairs = [(arr[i], arr[j]) for i in range(len(arr)) for j in range(i+1, len(arr))]\n    gcd_freq = {}\n    for pair in pairs:\n        x, y = pair\n        pair_gcd = gcd(x, y)\n        if pair_gcd in gcd_freq:\n            gcd_freq[pair_gcd] += 1\n        else:\n            gcd_freq[pair_gcd] = 1\n    unique_gcd_pairs = [(pair, gcd_val) for pair, gcd_val in gcd_freq.items() if gcd_val == 1]\n    return unique_gcd_pairs\n\n[/Code 2]\n\n[Asserts 2]\n\nassert findPairsWithUniqueGCD([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == [((1, 2), 1), ((1, 3), 1), ((1, 4), 1), ((1, 5), 1), ((1, 6), 1), ((1, 7), 1), ((1, 8), 1), ((1, 9), 1), ((1, 10), 1), ((2, 3), 1), ((2, 5), 1), ((3, 4), 1), ((3, 5), 1), ((3, 6), 1), ((3, 7), 1), ((3, 8), 1), ((3, 9), 1), ((4, 5), 1), ((5, 6), 1), ((5, 7), 1), ((5, 8), 1), ((5, 9), 1), ((6, 7), 1), ((7, 8), 1), ((7, 9), 1), ((8, 9), 1), ((9, 10), 1)]\nassert findPairsWithUniqueGCD([2, 3, 7, 11, 13]) == [((2, 3), 1), ((2, 7), 1), ((2, 11), 1), ((2, 13), 1), ((3, 7), 1), ((3, 11), 1), ((3, 13), 1), ((7, 11), 1), ((7, 13), 1), ((11, 13), 1)]\nassert findPairsWithUniqueGCD([15, 30, 45, 60, 75, 90]) == [((15, 45), 1), ((15, 60), 1), ((30, 75), 1), ((45, 60), 1), ((45, 75), 1), ((45, 90), 1), ((60, 75), 1), ((60, 90), 1)]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'integers', 'pairs', 'XOR', 'comparison', 'count']", "prompt_tokens": 530, "total_tokens": 877, "completion_tokens": 347, "completion": "[Question 2]\n\nYou are given an array arr of integers. Write a function to find the count of pairs of elements that are positioned at odd and even indices respectively, such that their XOR is a prime number.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\ndef isPrime(n: int) -> bool:\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef countPairsWithPrimeXOR(arr: List[int]) -> int:\n    odd_nums = [arr[i] for i in range(len(arr)) if i % 2 != 0]\n    even_nums = [arr[i] for i in range(len(arr)) if i % 2 == 0]\n    count = 0\n    for x in odd_nums:\n        for y in even_nums:\n            if isPrime(x ^ y):\n                count += 1\n    return count\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countPairsWithPrimeXOR([3, 5, 7, 4, 6, 9]) == 4\nassert countPairsWithPrimeXOR([11, 2, 7, 8, 15]) == 3\nassert countPairsWithPrimeXOR([17, 22, 13, 10, 29, 4]) == 7\nassert countPairsWithPrimeXOR([2, 4, 6, 8, 10, 12]) == 0\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['rectangle', 'circle', 'arrangement', 'touch', 'axis-parallel', 'cuboid', 'possible', 'arrange']", "prompt_tokens": 771, "total_tokens": 1202, "completion_tokens": 431, "completion": "[Question 2]\n\nYou are given a set of scrambled rectangles where some of them are arranged in a circle and the rest are arranged in a line as an axis-parallel arrangement. Write a function to determine if it is possible to add another rectangle to the circle arrangement such that it touches exactly 2 other rectangles and forms a complete circle, and if it is possible, return the rectangle numbers that form the circle; otherwise, return \"Not possible\".\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\ndef addRectangleToCircle(arrangement: List[str]) -> Union[str, List[int]]:\n    circle_rectangles = []\n    line_rectangles = []\n    \n    for rectangle in arrangement:\n        if 'circle' in rectangle:\n            circle_rectangles.append(int(rectangle.split('_')[1]))\n        else:\n            line_rectangles.append(int(rectangle.split('_')[1]))\n    \n    if len(circle_rectangles) == 0:\n        return \"Not possible\"\n    \n    for rect in line_rectangles:\n        if (rect - 1) in circle_rectangles or (rect + 1) in circle_rectangles:\n            return circle_rectangles + [rect]\n    \n    return \"Not possible\"\n\n# Sample Input\narrangement = [\"circle_1\", \"circle_2\", \"circle_3\", \"rectangle_4\", \"rectangle_5\"]\nprint(addRectangleToCircle(arrangement)) # Output: [1, 2, 4]\n\n[/Code 2]\n\n[Asserts 2]\n\nassert addRectangleToCircle([\"circle_1\", \"circle_2\", \"circle_3\", \"rectangle_4\", \"rectangle_5\"]) == [1, 2, 4]\nassert addRectangleToCircle([\"rectangle_1\", \"rectangle_2\", \"rectangle_3\", \"rectangle_4\", \"rectangle_5\"]) == \"Not possible\"\nassert addRectangleToCircle([\"circle_1\", \"rectangle_2\", \"circle_3\", \"rectangle_4\", \"rectangle_5\"]) == [3, 5, 2]\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['integer', 'number', 'digits', 'same', 'function', 'boolean', 'set']", "prompt_tokens": 451, "total_tokens": 643, "completion_tokens": 192, "completion": "[Question 2]\n\nGiven an integer number, write a Python function to determine if its binary representation contains the same number of 0s and 1s.\n\nFunction Signature:  def same_number_of_0s_and_1s(n: int) -> bool\n\n[/Question 2]\n\n[Code 2]\n\ndef same_number_of_0s_and_1s(n: int) -> bool:\n    binary_rep = bin(n)[2:]\n    return binary_rep.count('0') == binary_rep.count('1')\n\n[/Code 2]\n\n[Asserts 2]\n\nassert same_number_of_0s_and_1s(5) == True\nassert same_number_of_0s_and_1s(6) == False\nassert same_number_of_0s_and_1s(15) == False\nassert same_number_of_0s_and_1s(42) == True\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['circle', 'diameter', 'center', 'midpoint formula', 'endpoints']", "prompt_tokens": 544, "total_tokens": 842, "completion_tokens": 298, "completion": "[Question 2]\n\nYou are given a list of boolean values representing the availability of team members for a task. Each boolean value indicates whether the team member is available (True) or not (False). Write a function to check if the team can be formed in a circular formation, meaning that there should be an uninterrupted sequence of available team members that adds up to the length of the circle's diameter.\n\nFor example, given the availability list [True, False, True, True, True], and a diameter of 3, the function should return True as a circular formation can be formed starting from the second team member.\n\n[/Question 2]\n\n[Code 2]\n\ndef canFormCircularFormation(availabilities: list, diameter: int) -> bool:\n    # As the list is circular, we can concatenate it with itself to check for circular formation\n    availabilities *= 2\n    n = len(availabilities)\n    for i in range(n - diameter + 1):\n        if all(availabilities[i:i + diameter]):\n            return True\n    return False\n\n[/Code 2]\n\n[Asserts 2]\n\nassert canFormCircularFormation([True, False, True, True, True], 3)==True\nassert canFormCircularFormation([True, True, True, False, True, True, True], 5)==True\nassert canFormCircularFormation([False, True, False, True, True, True], 4)==False", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['line segments', 'intersections', 'movement', 'radius', 'sorting', 'maximum']", "prompt_tokens": 685, "total_tokens": 1089, "completion_tokens": 404, "completion": "[Question 2]\n\nYou are given a list of cone objects with their respective radii and heights. Your task is to sort the cones in descending order based on their volumes. Then, calculate the maximum number of intersections when one cone is moved along the z-axis, and finally return the sorted list of cone objects with their new positions in the final array.\n\nWrite a function to achieve the mentioned task.\n\n[/Question 2]\n\n[Code 2]\n\nimport math\n\nclass Cone:\n    def __init__(self, radius, height, z_position):\n        self.radius = radius\n        self.height = height\n        self.z_position = z_position\n\ndef sortConesByVolumeAndMove(cones: list) -> list:\n    cones.sort(key=lambda x: (math.pi * x.radius**2 * x.height), reverse=True)\n    for i in range(len(cones)):\n        cones[i].z_position = 9 * math.log(10*(i+1))\n    return cones\n\n[/Code 2]\n\n[Asserts 2]\n\ncone1 = Cone(3, 4, 0)\ncone2 = Cone(5, 6, 0)\ncone3 = Cone(2, 8, 0)\ncone4 = Cone(4, 7, 0)\nsorted_cones = sortConesByVolumeAndMove([cone1, cone2, cone3, cone4])\nassert sorted_cones[0].radius == 5 and sorted_cones[0].z_position == 9.0\nassert sorted_cones[1].radius == 4 and sorted_cones[1].z_position == 13.815510557964274\nassert sorted_cones[2].radius == 3 and sorted_cones[2].z_position == 17.916313462498292\nassert sorted_cones[3].radius == 2 and sorted_cones[3].z_position == 21.66390004036366\n", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['binary tree', 'structure', 'iterative', 'identical', 'nodes', 'value']", "prompt_tokens": 674, "total_tokens": 1193, "completion_tokens": 519, "completion": "[Question 2]\n\nGiven a binary tree, write an iterative function to check if all the nodes at odd indexed levels have constant width and the values are within a specified range. Nodes at odd indexed levels are the nodes at level 1, level 3, level 5, and so on (considering the root as level 1).\n\n[/Question 2]\n\n[Code 2]\n\nclass TreeNode:\n    def __init__(self, value=0, left=None, right=None):\n        self.value = value\n        self.left = left\n        self.right = right\n\ndef isConstantWidthAndInRange(root: TreeNode, width: int, low: int, high: int) -> bool:\n    if not root:\n        return True\n    \n    queue = [(root, 1)]  # (node, level)\n    level_width = {}  # level: list of indices\n    \n    while queue:\n        node, level = queue.pop(0)\n        if level % 2 != 0:\n            if level not in level_width:\n                level_width[level] = [1, 1]  # initialize range for odd indexed levels\n            else:\n                level_width[level][0] = min(level_width[level][0], 1)\n                level_width[level][1] = max(level_width[level][1], 1)\n        \n        if node.left:\n            queue.append((node.left, level + 1))\n        if node.right:\n            queue.append((node.right, level + 1))\n    \n    for level in level_width:\n        if level_width[level][1] - level_width[level][0] != width:\n            return False\n    \n    return True\n\n[/Code 2]\n\n[Asserts 2]\n\ntree1 = TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(5)), TreeNode(3, TreeNode(6), TreeNode(7)))\nassert isConstantWidthAndInRange(tree1, 2, 1, 7) == True\ntree2 = TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(5)), TreeNode(3, TreeNode(6), TreeNode(8)))\nassert isConstantWidthAndInRange(tree2, 2, 1, 7) == False\ntree3 = TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(5)), TreeNode(3, TreeNode(6), TreeNode(7, TreeNode(8))))\nassert isConstantWidthAndInRange(tree3, 2, 1, 7) == False\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['string', 'mathematical expression', 'brackets', 'balanced', 'positions']", "prompt_tokens": 505, "total_tokens": 776, "completion_tokens": 271, "completion": "[Question 2]\n\nYou are given a set of positions in a string representing mathematical expressions. Your task is to calculate the distance between each pair of positions and determine if the result is a balanced expression or not.\n\n[/Question 2]\n\n[Code 2]\n\ndef calculateDistanceAndBalance(expression: str, positions: List[int]) -> List[bool]:\n    distances = []\n    for i in range(len(positions)):\n        for j in range(i+1, len(positions)):\n            distance = abs(positions[i] - positions[j])\n            distances.append((distance, i, j))\n    \n    result = []\n    for distance, i, j in distances:\n        sub_expression = expression[min(positions[i], positions[j]): max(\n            positions[i], positions[j])+1]\n        count_open = sub_expression.count(\"(\")\n        count_close = sub_expression.count(\")\")\n        result.append(count_open == count_close)\n    return result\n\n[/Code 2]\n\n[Asserts 2]\n\nassert calculateDistanceAndBalance(\"(()())\", [0, 1, 3])==[True, False, True, False, True, True]\nassert calculateDistanceAndBalance(\"()((())())\", [0, 1, 4])==[True, True, True, True, False, True]\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['binary trees', 'merge', 'node sum', 'recursive approach', 'iterative approach']", "prompt_tokens": 897, "total_tokens": 1678, "completion_tokens": 781, "completion": "[Question 2]\n\nGiven two balanced binary trees, the task is to merge them such that the values at the nodes are added together and then the result is sorted in alphabetical order. Implement the merging operation using both recursive and iterative approaches.\n\n[/Question 2]\n\n[Code 2]\n\n# Recursive Approach\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef mergeTreesRecursive(t1: TreeNode, t2: TreeNode) -> TreeNode:\n    if not t1:\n        return t2\n    if not t2:\n        return t1\n    t1.val += t2.val\n    t1.left = mergeTreesRecursive(t1.left, t2.left)\n    t1.right = mergeTreesRecursive(t1.right, t2.right)\n    return t1\n\ndef inorderTraversal(node, result):\n    if not node:\n        return\n    inorderTraversal(node.left, result)\n    result.append(node.val)\n    inorderTraversal(node.right, result)\n\ndef mergeAndSortRecursive(t1: TreeNode, t2: TreeNode) -> list:\n    merged_tree = mergeTreesRecursive(t1, t2)\n    result = []\n    inorderTraversal(merged_tree, result)\n    return result\n\n# Iterative Approach\ndef mergeTreesIterative(t1: TreeNode, t2: TreeNode) -> TreeNode:\n    if not t1:\n        return t2\n    stack = []\n    stack.append((t1, t2))\n    while stack:\n        node1, node2 = stack.pop()\n        if not node1 or not node2:\n            continue\n        node1.val += node2.val\n        if not node1.left:\n            node1.left = node2.left\n        else:\n            stack.append((node1.left, node2.left))\n        if not node1.right:\n            node1.right = node2.right\n        else:\n            stack.append((node1.right, node2.right))\n    return t1\n\ndef inorderTraversalAndMerge(t1: TreeNode, t2: TreeNode) -> list:\n    merged_tree = mergeTreesIterative(t1, t2)\n    result = []\n    inorderTraversal(merged_tree, result)\n    return result\n\n[/Code 2]\n\n[Asserts 2]\n\n# Example 1\nt1 = TreeNode('b', TreeNode('a', TreeNode('c')), TreeNode('f', TreeNode('d'), TreeNode('g')))\nt2 = TreeNode('d', TreeNode('b', TreeNode('a'), TreeNode('c')), TreeNode('h', TreeNode('f'), TreeNode('j')))\nmerged_recursive = mergeAndSortRecursive(t1, t2)\nassert merged_recursive == ['a', 'b', 'c', 'd', 'f', 'g', 'h', 'j']\nmerged_iterative = inorderTraversalAndMerge(t1, t2)\nassert merged_iterative == ['a', 'b', 'c', 'd', 'f', 'g', 'h', 'j']\n# Example 2\nt1 = TreeNode('c', TreeNode('a', TreeNode('b')), TreeNode('e', TreeNode('d'), TreeNode('f')))\nt2 = TreeNode('d', TreeNode('b', TreeNode('a'), TreeNode('c')), TreeNode('h', TreeNode('f'), TreeNode('j')))\nmerged_recursive = mergeAndSortRecursive(t1, t2)\nassert merged_recursive == ['a', 'b', 'c', 'd', 'e', 'f', 'h', 'j']\nmerged_iterative = inorderTraversalAndMerge(t1, t2)\nassert merged_iterative == ['a', 'b', 'c', 'd', 'e', 'f', 'h', 'j']\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['binary tree', 'doubly linked list', 'in-order traversal', 'node', 'pointer', 'recursion', 'linked structure', 'data structure']", "prompt_tokens": 677, "total_tokens": 1093, "completion_tokens": 416, "completion": "[Question 2]\n\nWrite a program to find and print all Pronic numbers available in a binary tree. Pronic numbers are numbers that are the product of two consecutive integers. The binary tree should be traversed using in-order traversal.\n\n[/Question 2]\n\n[Code 2]\n\nclass Node:\n    def __init__(self, data: int):\n        self.data = data\n        self.left = None\n        self.right = None\n\n\ndef findPronicNumbersInBinaryTree(root: Node):\n    def inOrderTraversal(node):\n        if node is not None:\n            inOrderTraversal(node.left)\n            checkForPronicNumber(node.data)\n            inOrderTraversal(node.right)\n\n    def checkForPronicNumber(num):\n        for i in range(1, num):\n            if i * (i + 1) == num:\n                print(num, \"is a pronic number\")\n\n    inOrderTraversal(root)\n\n\n[/Code 2]\n\n[Asserts 2]\n\n# Create a Binary Tree\nroot = Node(12)\nroot.left = Node(6)\nroot.right = Node(20)\nroot.left.left = Node(2)\nroot.left.right = Node(14)\n# Find Pronic Numbers in Binary Tree\noutput = StringIO()\nsys.stdout = output\nfindPronicNumbersInBinaryTree(root)\nsys.stdout = sys.__stdout__\nresult = output.getvalue().strip()\nassert result == \"6 is a pronic number\\n12 is a pronic number\\n20 is a pronic number\"\n# Create a Binary Tree with no Pronic Numbers\nroot2 = Node(10)\nroot2.left = Node(8)\nroot2.right = Node(15)\nroot2.left.left = Node(3)\nroot2.left.right = Node(6)\n# Find Pronic Numbers in Binary Tree\noutput2 = StringIO()\nsys.stdout = output2\nfindPronicNumbersInBinaryTree(root2)\nsys.stdout = sys.__stdout__\nresult2 = output2.getvalue().strip()\nassert result2 == \"\"\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['sequence', 'divisible', 'operation', 'remainder', 'modulo', 'addition', 'boolean']", "prompt_tokens": 687, "total_tokens": 1039, "completion_tokens": 352, "completion": "[Question 2]\n\nYou are given a list of integers. Your task is to find if there exists a subsequence of the given list such that the sum of the subsequence is divisible by a given integer D.\n\nWrite a function that takes the list of integers and the integer D as input and returns True if such a subsequence exists, otherwise return False.\n\nFor example, given the list [1, 7, 2, 4] and D = 3, the subsequence [1, 2] has a sum of 3, which is divisible by 3. Hence, the return value will be True.\n\n[/Question 2]\n\n[Code 2]\n\nfrom itertools import combinations\n\ndef isSubsequenceSumDivisible(arr: List[int], D: int) -> bool:\n    n = len(arr)\n    for i in range(1, n+1):\n        for subset in combinations(arr, i):\n            if sum(subset) % D == 0:\n                return True\n    return False\n\n[/Code 2]\n\n[Asserts 2]\n\nassert isSubsequenceSumDivisible([1, 7, 2, 4], 3) == True\nassert isSubsequenceSumDivisible([3, 5, 1, 8], 4) == True\nassert isSubsequenceSumDivisible([2, 4, 6, 8], 5) == False\nassert isSubsequenceSumDivisible([10, 20, 30], 7) == True\nassert isSubsequenceSumDivisible([1, 2, 3, 4, 5], 6) == True\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['figurate number', 'icositrigonal', 'regular polygon', 'formula', 'integer', 'sqrt', 'boolean']", "prompt_tokens": 621, "total_tokens": 1134, "completion_tokens": 513, "completion": "[Question 2]\n\nYou are given a list of numeric values representing the side lengths of different regular polygons. Write a function that takes this list as input and returns the index pairs of the largest rectangle that can be formed by selecting two different side lengths from the list. If a valid rectangle can be formed, return the index pairs (i, j); otherwise, return False.\n\nFor example, given the side lengths [3, 4, 5, 6, 7], the largest rectangle would be formed by selecting sides 4 and 6 (index 1 and 3) resulting in a 4x6 rectangle.\n\nWrite a function `largestRectangleIndexPairs` to find the index pairs of the largest rectangle that can be formed.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List, Union\n\ndef largestRectangleIndexPairs(side_lengths: List[int]) -> Union[tuple, bool]:\n    largest_area = 0\n    index_pairs = False\n    for i in range(len(side_lengths)):\n        for j in range(i+1, len(side_lengths)):\n            area = side_lengths[i] * side_lengths[j]\n            if area > largest_area:\n                largest_area = area\n                index_pairs = (i, j)\n    return index_pairs\n\n[/Code 2]\n\n[Asserts 2]\n\nassert largestRectangleIndexPairs([3, 4, 5, 6, 7]) == (1, 3)\nassert largestRectangleIndexPairs([2, 8, 6, 5, 4, 7]) == (1, 5)\nassert largestRectangleIndexPairs([1, 2, 3, 4, 5]) == (3, 4)\nassert largestRectangleIndexPairs([7, 10, 9, 11, 8]) == (1, 3)\nassert largestRectangleIndexPairs([5, 12, 4, 7, 9, 6]) == (1, 4)\nassert largestRectangleIndexPairs([3, 4, 5, 6]) == (2, 3)\nassert largestRectangleIndexPairs([1, 2, 3]) == (0, 1)\nassert largestRectangleIndexPairs([5, 7, 11, 13]) == (2, 3)\nassert largestRectangleIndexPairs([2, 3, 5, 7, 11, 13]) == (4, 5)", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['binary', 'grid', 'connected', 'sequence', 'DFS', 'visited', 'neighbours', 'length', 'cells']", "prompt_tokens": 934, "total_tokens": 1555, "completion_tokens": 621, "completion": "[Question 2]\n\nYou are given a binary grid of size N x M where each cell is initially white (0) and represents a programming task. You are allowed to perform a rotation operation on a connected group of white cells. A rotation operation on a group of cells changes all the 1's to 0's and vice versa. Design a program to find the minimum number of rotations required to make all cells of the grid contain 1's, and the sequence of rotations to achieve this in increasing order.\n\n[/Question 2]\n\n[Code 2]\n\ndef isValid(grid, i, j, visited):\n    if i >= 0 and i < len(grid) and j >= 0 and j < len(grid[0]) and grid[i][j] == 1 and not visited[i][j]:\n        return True\n    return False\n\ndef dfs(grid, i, j, visited, rotation_sequence):\n    visited[i][j] = True\n    rows = [-1, 0, 0, 1]\n    cols = [0, -1, 1, 0]\n    rotation_sequence.append((i, j))\n    for k in range(4):\n        if isValid(grid, i + rows[k], j + cols[k], visited):\n            dfs(grid, i + rows[k], j + cols[k], visited, rotation_sequence)\n\ndef countRotations(grid):\n    n = len(grid)\n    m = len(grid[0])\n    visited = [[False for _ in range(m)] for _ in range(n)]\n    rotations = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and not visited[i][j]:\n                rotation_sequence = []\n                dfs(grid, i, j, visited, rotation_sequence)\n                rotations.append(rotation_sequence)\n    return rotations\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countRotations([[1, 0, 1, 0, 1],\n                       [0, 1, 0, 1, 0],\n                       [1, 0, 1, 0, 1],\n                       [0, 1, 0, 1, 0],\n                       [1, 0, 1, 0, 1]]) == [[(0, 0)],\n                                             [(2, 0)],\n                                             [(4, 0)],\n                                             [(0, 2)],\n                                             [(0, 4)],\n                                             [(2, 4)],\n                                             [(4, 2)],\n                                             [(4, 4)]]\n\nassert countRotations([[0, 0, 0, 0, 0],\n                       [0, 0, 0, 0, 0],\n                       [0, 0, 0, 0, 0],\n                       [0, 0, 0, 0, 0],\n                       [0, 0, 0, 0, 0]]) == []\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['fare', 'travel', 'cab', 'cost', 'time', 'money', 'trip', 'calculate']", "prompt_tokens": 534, "total_tokens": 764, "completion_tokens": 230, "completion": "[Question 2]\n\nYou have been given a list of the cost of cab rides for different trips. Each trip has a fare. You are required to calculate the total money you spent on traveling by cab, with a condition - if the fare for a trip occurs more than once, you will only pay for that trip once. \n\nWrite a function to calculate the total money you spent on travel based on the given list of fares.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\ndef totalMoneySpent(fares: List[int]) -> int:\n    unique_fares = set(fares)\n    total_money = 0\n    for fare in unique_fares:\n        total_money += fare\n    return total_money\n\n[/Code 2]\n\n[Asserts 2]\n\nassert totalMoneySpent([10, 20, 10, 30, 20, 40])==60\nassert totalMoneySpent([5, 10, 15, 20, 25])==75\nassert totalMoneySpent([10, 10, 10, 10, 10])==10", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['binary tree', 'exponential', 'path', 'absolute difference', 'levels', 'nodes']", "prompt_tokens": 613, "total_tokens": 912, "completion_tokens": 299, "completion": "[Question 2]\n\nYou are working on a software to validate driving licenses. Given a binary tree representing the hierarchy of driving licenses, write a function to determine if there exists a path from the root to a leaf where the absolute difference between the levels of the nodes is an exponential value.\n\n[/Question 2]\n\n[Code 2]\n\nclass Node:\n\tdef __init__(self, data):\n\t\tself.data = data\n\t\tself.left = None\n\t\tself.right = None\n\ndef checkExponentialPath(root):\n\tif root is None:\n\t\treturn False\n\tqueue = []\n\tqueue.append([root, root.data, 0])\n\twhile queue:\n\t\ttemp = queue.pop(0)\n\t\tnode = temp[0]\n\t\tprevData = temp[1]\n\t\tlevel = temp[2]\n\t\tif node.left is None and node.right is None:\n\t\t\treturn True\n\t\tif node.left:\n\t\t\tqueue.append([node.left, node.left.data, level + 1])\n\t\tif node.right:\n\t\t\tqueue.append([node.right, node.right.data, level + 1])\n\treturn False\n\n[/Code 2]\n\n[Asserts 2]\n\nroot = Node(1)\nroot.left = Node(2)\nroot.right = Node(3)\nroot.left.left = Node(4)\nroot.left.right = Node(5)\nroot.right.left = Node(6)\nroot.right.right = Node(7)\nassert checkExponentialPath(root)==True\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'integers', 'product', 'prime numbers', 'perfect square', 'boolean', 'function']", "prompt_tokens": 653, "total_tokens": 1042, "completion_tokens": 389, "completion": "[Question 2]\n\nYou are given a graph representing train connections between cities. Each train connection has a feasibility status associated with it, indicated by a boolean value. You need to write a function to determine if it is feasible to travel from city A to city B using the available train connections, such that the product of the prime numbers encountered during the journey is a perfect square.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List, Dict\n\ndef isPrime(num: int) -> bool:\n\tif num <= 1:\n\t\treturn False\n\tfor i in range(2, int(num ** 0.5) + 1):\n\t\tif num % i == 0:\n\t\t\treturn False\n\treturn True\n\ndef productOfPrimesIsPerfectSquareGraph(graph: Dict[str, List[str]], start: str, end: str) -> bool:\n\tqueue = [start]\n\tvisited = set()\n\twhile queue:\n\t\tnode = queue.pop(0)\n\t\tif node == end:\n\t\t\treturn True\n\t\tfor neighbor in graph.get(node, []):\n\t\t\tif neighbor not in visited:\n\t\t\t\tvisited.add(neighbor)\n\t\t\t\tqueue.append(neighbor)\n\treturn False\n\n[/Code 2]\n\n[Asserts 2]\n\ngraph = {\n\t\"A\": [\"B\", \"C\"],\n\t\"B\": [\"A\", \"C\"],\n\t\"C\": [\"A\", \"B\", \"D\"],\n\t\"D\": [\"C\", \"E\"],\n\t\"E\": [\"D\"]\n}\nassert productOfPrimesIsPerfectSquareGraph(graph, \"A\", \"E\")==True\n\ngraph2 = {\n\t\"A\": [\"B\", \"C\"],\n\t\"B\": [\"A\"],\n\t\"C\": [\"A\", \"D\"],\n\t\"D\": [\"C\", \"E\"],\n\t\"E\": [\"D\"]\n}\nassert productOfPrimesIsPerfectSquareGraph(graph2, \"A\", \"E\")==False\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['string', 'subsequence', 'substring', 'length', 'dynamic programming', 'comparison', 'iteration']", "prompt_tokens": 548, "total_tokens": 939, "completion_tokens": 391, "completion": "[Question 2]\n\nYou are given a list of strings representing train schedules. Each schedule is a string of the form \"hh:mm-hh:mm\", representing the departure and arrival times of a train. Write a function to find the longest consecutive time gap between the trains in the schedule.\n\n[/Question 2]\n\n[Code 2]\n\nfrom datetime import datetime\n\ndef longestConsecutiveTimeGap(schedule: List[str]) -> int:\n    times = []\n    for s in schedule:\n        departure, arrival = s.split('-')\n        fmt = \"%H:%M\"\n        departure_time = datetime.strptime(departure, fmt)\n        arrival_time = datetime.strptime(arrival, fmt)\n        times.append((departure_time, arrival_time))\n    times.sort()\n    max_gap = 0\n    for i in range(1, len(times)):\n        time_gap = (times[i][0] - times[i-1][1]).seconds // 60\n        max_gap = max(max_gap, time_gap)\n    return max_gap\n\n[/Code 2]\n\n[Asserts 2]\n\nassert longestConsecutiveTimeGap([\"09:00-09:30\", \"10:00-10:30\", \"11:00-11:30\"]) == 30\nassert longestConsecutiveTimeGap([\"10:00-12:00\", \"13:00-14:00\", \"14:30-15:00\", \"15:15-16:00\"]) == 45\nassert longestConsecutiveTimeGap([\"10:00-12:00\", \"12:30-13:00\", \"13:15-14:00\"]) == 30\nassert longestConsecutiveTimeGap([\"09:00-09:30\", \"10:00-11:00\", \"11:30-13:00\", \"14:00-14:30\"]) == 60\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'jump', 'minimum', 'reach', 'end', 'position', 'maximum', 'steps']", "prompt_tokens": 619, "total_tokens": 1030, "completion_tokens": 411, "completion": "[Question 2]\n\nYou are given a nested array representing a graph where each element denotes the maximum number of steps you can jump from that position. Write a function to efficiently find the minimum number of jumps to reach the end of the graph, starting from the root node. It is also guaranteed that the root node is at position (0, 0).\n\nWrite a function to return the minimum number of jumps required to reach the end of the graph.\n\n[/Question 2]\n\n[Code 2]\n\ndef minJumps(graph):\n    n = len(graph)\n    if n == 1:\n        return 0\n    jumps = 1\n    farthest = graph[0][0]\n    currentEnd = graph[0][0]\n    for i in range(1, n):\n        if i == n-1:\n            return jumps\n        farthest = max(farthest, i + graph[i][0])\n        if i == currentEnd:\n            jumps += 1\n            currentEnd = farthest\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minJumps([[2], [3, 4], [1, 5, 1], [2, 1, 1, 1]])==2\nassert minJumps([[2], [3, 4], [1, 5, 1], [2, 1, 1, 10]])==2\nassert minJumps([[2], [3, 10], [1, 5, 1], [2, 1, 1, 1]])==2\nassert minJumps([[1], [2, 1], [1, 1, 1], [1, 1, 1, 1]])==3\nassert minJumps([[1], [1, 1], [1, 1, 1], [1, 1, 1, 1]])==3\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'sum', 'element', 'four', 'search', 'sort', 'iteration', 'range']", "prompt_tokens": 768, "total_tokens": 949, "completion_tokens": 181, "completion": "[Question 2]\n\nGiven an array of integers, the task is to find the Kth smallest element in the array.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef kth_smallest(arr: List[int], k: int) -> int:\n    arr.sort()\n    return arr[k-1]\n\n[/Code 2]\n\n[Asserts 2]\n\nassert kth_smallest([4, 2, 6, 1, 5], 3) == 4\nassert kth_smallest([3, 1, 7, 8, 2, 4, 5], 5) == 5\nassert kth_smallest([10, 20, 15, 25, 40, 30, 60, 50], 4) == 25\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'position', 'cost', 'move', 'sort', 'median', 'absolute difference']", "prompt_tokens": 567, "total_tokens": 979, "completion_tokens": 412, "completion": "[Question 2]\n\nYou are given an array of strings representing images and their positions in a sequence. You need to evaluate the cost of moving all images to the same position in the sequence. The cost of moving an image is given by the absolute difference in position from the median position. Additionally, for images containing a vowel as the first letter, the cost is doubled. Write a function to evaluate the total cost of moving all images to the same position, considering the conditional cost for images starting with a vowel.\n\n[/Question 2]\n\n[Code 2]\n\ndef evaluateMovingCost(images, positions):\n    combined = list(zip(images, positions))\n    combined.sort(key=lambda x: x[1])\n    median_position = combined[len(combined) // 2][1]\n    total_cost = 0\n    for image, position in combined:\n        cost = abs(position - median_position)\n        if image[0].lower() in ['a', 'e', 'i', 'o', 'u']:\n            cost *= 2\n        total_cost += cost\n    return total_cost\n\n[/Code 2]\n\n[Asserts 2]\n\nassert evaluateMovingCost(['apple', 'banana', 'orange', 'pear'], [1, 2, 3, 4]) == 7\nassert evaluateMovingCost(['cat', 'dog', 'elephant', 'iguana'], [1, 2, 3, 4]) == 4\nassert evaluateMovingCost(['zebra', 'lion', 'tiger', 'rabbit'], [10, 100, 1000, 10000]) == 15025\nassert evaluateMovingCost(['image1', 'image2', 'image3', 'image4'], [5, 10, 15, 20]) == 20\nassert evaluateMovingCost(['bird', 'owl', 'eagle', 'flamingo'], [3, 5, 7, 9]) == 8\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'integers', 'jump', 'forward', 'cells', 'minimum', 'reach', 'last cell', 'maximum number of steps']", "prompt_tokens": 700, "total_tokens": 1036, "completion_tokens": 336, "completion": "[Question 2]\n\nYou are given an array of integers representing the cost of painting each cell of a fence. The cost of painting each cell is represented by a positive integer. You have to paint all the cells of the fence and you can only paint either the ith cell or the i+1th cell with some cost. Write a program to find the minimum cost to paint all the cells of the fence such that no two adjacent cells have the same color.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef minCost(cost: List[int]) -> int:\n\tif len(cost)==0:\n\t\treturn 0\n\tif len(cost)==1:\n\t\treturn cost[0]\n\tif len(cost)==2:\n\t\treturn min(cost[0], cost[1])\n\n\tn = len(cost)\n\tdp = [0]*n\n\tdp[0] = cost[0]\n\tdp[1] = cost[1]\n\tfor i in range(2,n):\n\t\tdp[i] = cost[i] + min(dp[i-1],dp[i-2])\n\treturn min(dp[-1], dp[-2])\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minCost([1, 2, 3, 4, 5])==5\nassert minCost([5, 7, 1, 3, 6, 2, 4])==10\nassert minCost([5, 1, 1, 3, 6, 2, 4])==9\nassert minCost([5, 7, 1, 3, 6])==9\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['sorted', 'arrays', 'union', 'intersection', 'distinct', 'common', 'elements', 'set', 'order']", "prompt_tokens": 945, "total_tokens": 1486, "completion_tokens": 541, "completion": "[Question 2]\n\nYou are given two sorted arrays A[] and B[], representing the transaction fees for different speed levels of two financial networks. Each transaction fee is represented in kilobytes. Your task is to find the minimum steps required to process transactions in both networks such that they are in ascending order. Return the minimum number of steps required. Additionally, you need to determine the common elements or intersections between the two arrays.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\ndef minStepsAndIntersection(arr1: List[float], arr2: List[float]) -> List[int]:\n    steps = 0\n    i = 0\n    j = 0\n    intersection = []\n    while i < len(arr1) and j < len(arr2):\n        if arr1[i] < arr2[j]:\n            i += 1\n        elif arr2[j] < arr1[i]:\n            j += 1\n        else:\n            intersection.append(arr1[i])\n            i += 1\n            j += 1\n    return [len(intersection), steps]\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minStepsAndIntersection([0.1, 0.2, 0.3, 0.4, 0.5], [0.2, 0.3, 0.5, 0.7]) == [3, 0]\nassert minStepsAndIntersection([0.5, 0.6, 0.7, 0.8, 0.9], [0.1, 0.3, 0.5, 0.7]) == [2, 0]\nassert minStepsAndIntersection([0.1, 0.2, 0.3, 0.4, 0.5], [0.6, 0.7, 0.8, 0.9, 1.0]) == [0, 0]\nassert minStepsAndIntersection([0.1, 0.2, 0.3, 0.4, 0.5], [0.1, 0.2, 0.3, 0.4, 0.5]) == [5, 0]\nassert minStepsAndIntersection([0.1, 0.2, 0.3, 0.4, 0.5], [0.6, 0.7, 0.8, 0.9, 1.0]) == [0, 0]\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['pair', 'symmetric', 'mapping', 'equality']", "prompt_tokens": 555, "total_tokens": 867, "completion_tokens": 312, "completion": "[Question 2]\n\nYou are given an array of integers. Write a function to find and return the cost of the minimum path from the first occurrence of x to the last occurrence of y. The cost of a path is the sum of all the elements present in the path. If no path exists return -1\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\ndef minCostPath(arr: List[int], x: int, y: int) -> int:\n\tfirstOccurrence = -1\n\tlastOccurrence = -1\n\tcost = 0\n\tfor i in range(len(arr)):\n\t\tif arr[i] == x and firstOccurrence == -1:\n\t\t\tfirstOccurrence = i\n\t\tif arr[i] == y:\n\t\t\tlastOccurrence = i\n\tif firstOccurrence == -1 or lastOccurrence == -1:\n \t\treturn -1\n\tfor i in range(firstOccurrence, lastOccurrence + 1):\n\t\tcost += arr[i]\n\treturn cost\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minCostPath([1, 2, 3, 4, 5, 6, 7, 8, 3, 10, 9], 3, 10) == 30\nassert minCostPath([1, 2, 3, 4, 5, 6, 7, 8, 3, 10, 9], 3, 11) == -1", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'integer', 'merge', 'operation', 'palindrome', 'consecutive', 'sum']", "prompt_tokens": 616, "total_tokens": 950, "completion_tokens": 334, "completion": "[Question 2]\n\nYou are given an array of integers representing the level order traversal of a Binary Search Tree. Your task is to mark the nodes in the BST which have the property that the sum of their children equals the node value (sink nodes). Implement a function to mark these nodes in the BST. \n\n[/Question 2]\n\n[Code 2]\n\nclass TreeNode:\n    def __init__(self, key):\n        self.left = None\n        self.right = None\n        self.val = key\n\ndef markSinkNodes(root, arr):\n    if not root:\n        return\n\n    def search(root, arr, i):\n        if not root:\n            return\n        root.val -= arr[i]\n        search(root.left, arr, i + 1)\n        search(root.right, arr, i + 1)\n\n    search(root, arr, 0)\n\n[/Code 2]\n\n[Asserts 2]\n\nroot = TreeNode(8)\nroot.left = TreeNode(3)\nroot.right = TreeNode(5)\nroot.left.left = TreeNode(4)\nroot.left.right = TreeNode(4)\nroot.right.left = TreeNode(5)\nroot.right.right = TreeNode(5)\narr = [8, 3, 5, 4, 4, 5, 5]\nmarkSinkNodes(root, arr)\nassert root.val == 0\nassert root.left.val == 2\nassert root.right.val == 0\nassert root.left.left.val == 0\nassert root.left.right.val == 0\nassert root.right.left.val == 0\nassert root.right.right.val == 0\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['math', 'divisibility', 'integer', 'product', 'sum', 'digits', 'even', 'odd']", "prompt_tokens": 542, "total_tokens": 808, "completion_tokens": 266, "completion": "[Question 2]\n\nGiven an integer n, write a function to find the smallest number that can be obtained by rearranging the digits of n such that the sum of the digits at even positions is divisible by the product of the digits at odd positions.\n\n[/Question 2]\n\n[Code 2]\n\ndef rearrangeDigits(n: int) -> int :\n    digits = [int(x) for x in str(n)]\n    min_num = float('inf')\n    from itertools import permutations\n    for perm in permutations(digits):\n        even_sum = 0\n        odd_prod = 1\n        for i, digit in enumerate(perm):\n            if i % 2 == 0:  # even position\n                even_sum += digit\n            else:  # odd position\n                odd_prod *= digit\n        if odd_prod != 0 and even_sum % odd_prod == 0:\n            num = int(''.join(map(str, perm)))\n            min_num = min(min_num, num)\n    return min_num\n\n[/Code 2]\n\n[Asserts 2]\n\nassert rearrangeDigits(123)== 123\nassert rearrangeDigits(356)== 356\nassert rearrangeDigits(246)== 246\nassert rearrangeDigits(135)== 315\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['binary', 'string', 'count', 'substrings', 'even number', 'decimal equivalent']", "prompt_tokens": 480, "total_tokens": 726, "completion_tokens": 246, "completion": "[Question 2]\n\nGiven a list of binary strings, the task is to count the number of substrings in each string that represents an even number in their decimal equivalent and have trailing zeroes when converted to binary.\n\n[/Question 2]\n\n[Code 2]\n\ndef countEvenDecimalSubstringsWithTrailingZeroes(strings: List[str]) -> List[int]:\n    result = []\n    for s in strings:\n        count = 0\n        for i in range(len(s)):\n            for j in range(i, len(s)):\n                decimal_value = int(s[i:j+1], 2)\n                if decimal_value % 2 == 0 and decimal_value % 10 == 0:\n                    count += 1\n        result.append(count)\n    return result\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countEvenDecimalSubstringsWithTrailingZeroes([\"1010\", \"1101\", \"1111\", \"1001\"]) == [7, 6, 10, 8]\nassert countEvenDecimalSubstringsWithTrailingZeroes([\"1110\", \"1001\", \"1100\"]) == [7, 8, 6]\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['range', 'integer', 'multiples', 'even', 'sum', 'max', 'possible']", "prompt_tokens": 572, "total_tokens": 809, "completion_tokens": 237, "completion": "[Question 2]\n\nGiven a list of integers, find the smallest element that corresponds to a multiple of 3 when each element is rotated 180 degrees (considering only the digits). If no such element is possible, return -1.\n\n[/Question 2]\n\n[Code 2]\n\ndef smallestElementRotated180(nums: List[int]) -> int:\n    smallest = float('inf')\n    for num in nums:\n        rotated = int(str(num)[::-1])\n        if rotated % 3 == 0:\n            smallest = min(smallest, rotated)\n    return smallest if smallest != float('inf') else -1\n\n[/Code 2]\n\n[Asserts 2]\n\nassert smallestElementRotated180([123, 456, 789]) == 198\nassert smallestElementRotated180([321, 987, 654]) == 654\nassert smallestElementRotated180([111, 222, 333]) == 111\nassert smallestElementRotated180([456, 789, 135]) == 654\nassert smallestElementRotated180([11, 22, 55, 88]) == -1", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['string', 'anagram', 'substring', 'lexicographically', 'permutations']", "prompt_tokens": 550, "total_tokens": 871, "completion_tokens": 321, "completion": "[Question 2]\n\nYou are given a string S and a list of strings paint. Your task is to find the lexicographically smallest anagram of S that contains all the substrings of each string in paint.\n\n[/Question 2]\n\n[Code 2]\n\ndef smallestAnagramWithSubstrings(s: str, paint: List[str]) -> str:\n    def isAnagram(s1, s2):\n        return sorted(s1) == sorted(s2)\n\n    def allSubstrings(s):\n        return [s[i:j] for i in range(len(s)) for j in range(i + 1, len(s) + 1)]\n\n    substrings = []\n    for p in paint:\n        substrings.extend(allSubstrings(p))\n\n    perms = [''.join(p) for p in permutations(s)]\n    perms.sort()\n    for perm in perms:\n        found = True\n        for sub in substrings:\n            if sub not in perm:\n                found = False\n                break\n        if found:\n            return perm\n\n    return \"\"\n\n[/Code 2]\n\n[Asserts 2]\n\nassert smallestAnagramWithSubstrings(\"abac\", [\"ab\", \"ac\"]) == \"abac\"\nassert smallestAnagramWithSubstrings(\"hello\", [\"lo\", \"el\"]) == \"hello\"\nassert smallestAnagramWithSubstrings(\"abcde\", [\"ab\", \"cd\", \"de\"]) == \"abcde\"\nassert smallestAnagramWithSubstrings(\"racecar\", [\"car\", \"ace\"]) == \"acecarr\"\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'integers', 'sum', 'composite number', 'frequency', 'divisor', 'counter', 'math', 'iteration']", "prompt_tokens": 694, "total_tokens": 1295, "completion_tokens": 601, "completion": "[Question 2]\n\nYou are given a 2D array representing a calendar where each cell contains the number of events happening on that day. Each row represents a month, and each column represents a day of the month. Find the sum of events happening on days occurring on composite numbered days of the month for a target year.\n\nAssume that the first row represents January, the second row represents February, and so on, and there are always 30 days in each month.\n\nA composite number is a positive integer that has at least one positive divisor other than one or itself.\n\n[/Question 2]\n\n[Code 2]\n\ndef isComposite(n):\n    if n < 4:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return True\n    return False\n\ndef sumOfEventsOnCompositeDays(calendar, targetYear):\n    totalSum = 0\n    for month in calendar:\n        for day, events in enumerate(month):\n            if isComposite(day+1):\n                totalSum += events\n    return totalSum\n\n[/Code 2]\n\n[Asserts 2]\n\ncalendar = [\n    [0, 1, 3, 0, 2, 0, 5, 1, 0, 4, 0, 0, 6, 0, 0, 1, 0, 2, 0, 6, 0, 3, 0, 1, 2, 0, 0, 7, 0, 4],\n    [0, 2, 4, 0, 3, 0, 6, 2, 0, 5, 0, 0, 7, 0, 0, 2, 0, 3, 0, 7, 0, 4, 0, 2, 3, 0, 0, 8, 0, 5],\n    [0, 3, 5, 0, 4, 0, 7, 3, 0, 6, 0, 0, 8, 0, 0, 3, 0, 4, 0, 8, 0, 5, 0, 3, 4, 0, 0, 9, 0, 6],\n    # ... (remaining months)\n]\n\nassert sumOfEventsOnCompositeDays(calendar, 2022) == 40\nassert sumOfEventsOnCompositeDays(calendar, 2023) == 41\nassert sumOfEventsOnCompositeDays(calendar, 2024) == 42\nassert sumOfEventsOnCompositeDays(calendar, 2025) == 43\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['string', 'lexicographically', 'greater', 'smaller', 'comparison']", "prompt_tokens": 659, "total_tokens": 918, "completion_tokens": 259, "completion": "[Question 2]\n\nGiven a list of strings and their corresponding locations, write a function to sort the strings lexicographically based on their locations. If two strings have the same location, the string which is greater lexicographically should appear first in the sorted list.\n\n[/Question 2]\n\n[Code 2]\n\ndef sortStringsByLocation(strings: List[str], locations: List[int]) -> List[str]:\n    temp = list(zip(strings, locations))\n    \n    def custom_sort(s):\n        return (s[1], -ord(s[0][0]), s[0])\n\n    temp = sorted(temp, key=custom_sort)\n    return [x[0] for x in temp]\n\n[/Code 2]\n\n[Asserts 2]\n\nassert(sortStringsByLocation([\"abc\", \"def\", \"ghi\"], [2, 1, 2]))==[\"ghi\", \"abc\", \"def\"]\nassert(sortStringsByLocation([\"dog\", \"cat\", \"rat\"], [2, 1, 3]))==[\"cat\", \"dog\", \"rat\"]\nassert(sortStringsByLocation([\"apple\", \"banana\", \"cherry\"], [1, 1, 1]))==[\"banana\", \"cherry\", \"apple\"]\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['divisible', 'large number', 'string', 'check', 'boolean', 'modulo', 'sum']", "prompt_tokens": 507, "total_tokens": 713, "completion_tokens": 206, "completion": "[Question 2]\n\nWrite a function that takes a string representing a large number and returns True if the sum of the digits of the number is divisible by 7, otherwise return False. If the input number is not a valid number, return False.\n\n[/Question 2]\n\n[Code 2]\n\ndef isSumDivisibleBy7(num: str) -> bool:\n    try:\n        num_sum = sum(int(digit) for digit in num)\n        return num_sum % 7 == 0\n    except ValueError:\n        return False\n\n[/Code 2]\n\n[Asserts 2]\n\nassert isSumDivisibleBy7(\"1234567890\") == False\nassert isSumDivisibleBy7(\"7777777\") == True\nassert isSumDivisibleBy7(\"12345\") == False\nassert isSumDivisibleBy7(\"777777777777777777\") == True\nassert isSumDivisibleBy7(\"1000000\") == False\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['string', 'game', 'winner', 'count', 'character', 'draw', 'player']", "prompt_tokens": 523, "total_tokens": 877, "completion_tokens": 354, "completion": "[Question 2]\n\nYou are given an unsorted list of player names and their corresponding gains in a shell game. Write a function to determine the winner of the shell game, where the winner is the player who gained the most.\n\n[/Question 2]\n\n[Code 2]\n\ndef findShellGameWinner(players: list, gains: list) -> str:\n    max_gain = max(gains)\n    winners = [player for player, gain in zip(players, gains) if gain == max_gain]\n    if len(winners) == 1:\n        return winners[0]\n    else:\n        return \"Draw\"\n\n[/Code 2]\n\n[Asserts 2]\n\nassert findShellGameWinner([\"Alice\", \"Bob\", \"Charlie\", \"David\", \"Eve\"], [100, 150, 120, 200, 150]) == \"David\"\nassert findShellGameWinner([\"Adam\", \"Eve\", \"Jack\", \"Sophia\", \"Liam\"], [80, 80, 80, 80, 80]) == \"Draw\"\nassert findShellGameWinner([\"Michael\", \"Emma\", \"Olivia\", \"William\", \"Ava\"], [90, 110, 100, 95, 110]) == \"Draw\"\nassert findShellGameWinner([\"Lucas\", \"Isabella\", \"Mia\", \"Benjamin\", \"Charlotte\"], [130, 100, 90, 130, 100]) == \"Draw\"\nassert findShellGameWinner([\"Sophia\", \"Ethan\", \"Mia\", \"Noah\", \"Olivia\"], [120, 100, 120, 110, 90]) == \"Sophia\"\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['matrix', 'sorted', 'row', 'column', 'print']", "prompt_tokens": 548, "total_tokens": 831, "completion_tokens": 283, "completion": "[Question 2]\n\nGiven a matrix of size RxC, print the elements of the matrix in reverse row-major order.\n\n[/Question 2]\n\n[Code 2]\n\ndef reverseRowMajorOrder(mat):\n    rows = len(mat)\n    cols = len(mat[0])\n    result = []\n    for i in range(rows - 1, -1, -1):\n        for j in range(cols - 1, -1, -1):\n            result.append(mat[i][j])\n    return result\n\n[/Code 2]\n\n[Asserts 2]\n\nassert reverseRowMajorOrder([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == [9, 8, 7, 6, 5, 4, 3, 2, 1]\nassert reverseRowMajorOrder([[10, 20, 30, 40], [15, 25, 35, 45], [27, 29, 37, 48], [32, 33, 39, 50]]) == [50, 39, 33, 32, 48, 37, 29, 27, 45, 35, 25, 15, 40, 30, 20, 10]\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['string', 'recursion', 'adjacent', 'duplicates', 'count', 'ways', 'remove']", "prompt_tokens": 527, "total_tokens": 841, "completion_tokens": 314, "completion": "[Question 2]\n\nYou are given a list of 2D points representing positions on a tape storage. The tape contains duplicates of some points. Write a recursive function to remove the duplicates and return the count of unique points on the tape.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\ndef removeDuplicatesAndCount(points: List[List[int]]) -> int:\n    if len(points) <= 1:\n        return len(points)  # If the list contains 0 or 1 point, return the length as it is unique\n    if points[0] == points[1]:\n        del points[0]  # If adjacent points are duplicate, remove the first one\n        return removeDuplicatesAndCount(points)  # Recur for the modified list\n    else:\n        return 1 + removeDuplicatesAndCount(points[1:])  # If adjacent points are different, count 1 and recur for the remaining list\n\n[/Code 2]\n\n[Asserts 2]\n\nassert removeDuplicatesAndCount([[1, 2], [3, 4], [1, 2], [5, 6], [3, 4]]) == 3\nassert removeDuplicatesAndCount([[1, 2], [1, 2], [1, 2], [1, 2]]) == 1\nassert removeDuplicatesAndCount([[1, 2], [3, 4], [5, 6]]) == 3\nassert removeDuplicatesAndCount([]) == 0", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'triplets', 'divisibility', 'iteration', 'modulo', 'combinations']", "prompt_tokens": 571, "total_tokens": 812, "completion_tokens": 241, "completion": "[Question 2]\n\nYou are given an array of strings representing words in a dictionary. Write a function to determine the longest palindrome that can be formed by combining any two words from the array.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef longestPalindrome(words: List[str]) -> str:\n    def isPalindrome(s):\n        return s == s[::-1]\n    \n    max_length = 0\n    result = \"\"\n    \n    for i in range(len(words)):\n        for j in range(len(words)):\n            if i != j:\n                combined = words[i] + words[j]\n                if isPalindrome(combined) and len(combined) > max_length:\n                    max_length = len(combined)\n                    result = combined\n    \n    return result\n\n[/Code 2]\n\n[Asserts 2]\n\nassert longestPalindrome([\"code\", \"edoc\", \"da\", \"ad\"]) == \"daad\"\nassert longestPalindrome([\"ab\", \"deed\", \"abc\", \"xy\", \"yxa\"]) == \"deedy\"\nassert longestPalindrome([\"ab\", \"deed\", \"abc\", \"xy\"]) == \"deedy\"\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['integer', 'fourth power', 'difference', 'list', 'loop', 'iteration']", "prompt_tokens": 509, "total_tokens": 799, "completion_tokens": 290, "completion": "[Question 2]\n\nGiven a list of integers, find all pairs of numbers whose fourth power's difference is equal to a given integer N. Return the list of pairs. If there are no such pairs, return an empty list.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List, Tuple\ndef findPairs(numbers: List[int], N: int) -> List[Tuple[int, int]]:\n    result = []\n    for i in range(len(numbers)):\n        for j in range(i+1, len(numbers)):\n            if abs(numbers[i]**4 - numbers[j]**4) == N:\n                result.append((numbers[i], numbers[j]))\n    return result\n\n[/Code 2]\n\n[Asserts 2]\n\nassert findPairs([1, 2, 3, 4, 5], 80)==[(4, 1)]\nassert findPairs([1, 2, 3, 4, 5], 40)==[(2, 2)]\nassert findPairs([1, 2, 3, 4, 5], 100)==[(2, -2)]\nassert findPairs([1, 2, 3, 4, 5], 20)==[(2, 0)]\nassert findPairs([1, 2, 3, 4, 5], 50)==[(3, 1)]\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['mean', 'mode', 'median', 'average', 'middle', 'sorted', 'ascending', 'descending', 'even', 'odd', 'multiple', 'possible', 'smallest']", "prompt_tokens": 559, "total_tokens": 829, "completion_tokens": 270, "completion": "[Question 2]\n\nYou are given a list of integers representing the side lengths of tiles. Find the maximum possible perimeter of a rectangle that can be formed using any two different tiles from the list. If there are multiple rectangles with the largest perimeter, return the smallest one based on the area of the rectangle.\n\n[/Question 2]\n\n[Code 2]\n\ndef maxPerimeterRectangle(tiles: List[int]) -> int:\n    tiles.sort(reverse=True)\n    max_perimeter = 0\n    selected_tiles = []\n    for i in range(len(tiles)-1):\n        perimeter = 2 * (tiles[i] + tiles[i+1])\n        if perimeter > max_perimeter:\n            max_perimeter = perimeter\n            selected_tiles = [tiles[i], tiles[i+1]]\n    return max_perimeter, selected_tiles\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maxPerimeterRectangle([3, 7, 2, 9, 10])==34, [10, 9]\nassert maxPerimeterRectangle([4, 5, 2, 10, 8, 7])==36, [10, 8]\nassert maxPerimeterRectangle([6, 4, 3, 9, 11, 5])==34, [11, 9]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['pair', 'integers', 'difference', 'fifth power', 'unordered', 'count', 'math', 'collection']", "prompt_tokens": 504, "total_tokens": 743, "completion_tokens": 239, "completion": "[Question 2]\n\nWrite a program to count the number of trailing spaces in the product of the fifth powers of a collection of integers. Given a collection of integers, find the difference between the total count of trailing spaces in the product of the fifth powers and the total count of trailing spaces in the original numbers.\n\n[/Question 2]\n\n[Code 2]\n\ndef countTrailingSpacesProductDifference(arr):\n    product = 1\n    for num in arr:\n        product *= pow(num, 5)\n    trailing_spaces_product = len(str(product)) - len(str(product).rstrip('0'))\n    trailing_spaces_original = sum(len(str(num)) - len(str(num).rstrip('0')) for num in arr)\n    return abs(trailing_spaces_product - trailing_spaces_original)\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countTrailingSpacesProductDifference([2, 3, 4])==0\nassert countTrailingSpacesProductDifference([1, 5, 6])==1\nassert countTrailingSpacesProductDifference([7, 2, 9])==2\nassert countTrailingSpacesProductDifference([3, 4, 8])==1", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['geometry', 'circles', 'concentric', 'distance', 'center', 'radius', 'inside', 'outside', 'boolean']", "prompt_tokens": 702, "total_tokens": 1113, "completion_tokens": 411, "completion": "[Question 2]\n\nYou are given the center and radius of two concentric circles. Write a C++ function to determine if one circle is completely inside the other. The function should return true if one circle is inside the other, and false otherwise.\n\n[/Question 2]\n\n[Code 2]\n\n```cpp\n#include <iostream>\n#include <cmath>\n\nbool isCircleInside(int x1, int y1, int r1, int x2, int y2, int r2) {\n    double distance = sqrt(pow(x2 - x1, 2) + pow(y2 - y1, 2));\n    if (distance + r2 <= r1) {\n        return true;\n    } else if (distance + r1 <= r2) {\n        return true;\n    } else {\n        return false;\n    }\n}\n\nint main() {\n    int x1 = 0, y1 = 0, r1 = 5;\n    int x2 = 0, y2 = 0, r2 = 3;\n    std::cout << std::boolalpha << isCircleInside(x1, y1, r1, x2, y2, r2) << std::endl; // Output: true\n    \n    int x3 = 1, y3 = 1, r3 = 2;\n    int x4 = 1, y4 = 1, r4 = 4;\n    std::cout << std::boolalpha << isCircleInside(x3, y3, r3, x4, y4, r4) << std::endl; // Output: false\n    \n    return 0;\n}\n```\n\n[/Code 2]\n\n[Asserts 2]\n\n```cpp\nassert(isCircleInside(0, 0, 5, 0, 0, 3) == true);\nassert(isCircleInside(1, 1, 2, 1, 1, 4) == false);\n```", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['string', 'lexicographic', 'rank', 'factorial', 'math', 'modulus', 'iteration']", "prompt_tokens": 534, "total_tokens": 982, "completion_tokens": 448, "completion": "[Question 2]\n\nGiven two strings s1 and s2, the task is to find the largest lexicographical string that can be formed by taking a character from s1 and s2 at every iteration and the length of the formed string should be the factorial of the length of the longer string. Return the lexicographic rank of the formed string.\n\n[/Question 2]\n\n[Code 2]\n\nfrom math import factorial\ndef largestLexicographicalRank(s1: str, s2: str) -> int:\n    MOD = 1000000007\n    n1, n2 = len(s1), len(s2)\n    max_len = max(n1, n2)\n    target_len = factorial(max_len)\n    formed_string = \"\"\n    i, j = 0, 0\n    for _ in range(target_len):\n        if i < n1 and j < n2:\n            if s1[i] > s2[j]:\n                formed_string += s1[i]\n                i += 1\n            else:\n                formed_string += s2[j]\n                j += 1\n        elif i < n1:\n            formed_string += s1[i]\n            i += 1\n        else:\n            formed_string += s2[j]\n            j += 1\n    rank = 1\n    for i in range(max_len):\n        mul = factorial(max_len - i - 1)\n        smaller_in_right = 0\n        for j in range(i + 1, max_len):\n            if formed_string[i] > formed_string[j]:\n                smaller_in_right += 1\n        rank = (rank + ((smaller_in_right * mul) % MOD)) % MOD\n    return rank\n\n[/Code 2]\n\n[Asserts 2]\n\nassert largestLexicographicalRank(\"cba\", \"xyz\")==6\nassert largestLexicographicalRank(\"acb\", \"xyz\") == 10\nassert largestLexicographicalRank(\"string\", \"ranking\")==513\nassert largestLexicographicalRank(\"abcd\", \"efghijk\")==1\nassert largestLexicographicalRank(\"azbycx\", \"abc\")==21\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['capacity', 'water', 'glass', 'row', 'stack', 'dynamic programming', 'math', 'algorithm']", "prompt_tokens": 674, "total_tokens": 1041, "completion_tokens": 367, "completion": "[Question 2]\n\nYou are given a list of numbers representing the water capacity at each index in a row of glasses. Write a program to find the total water capacity in the row using dynamic programming and the quickselect algorithm.\n\n[/Question 2]\n\n[Code 2]\n\nimport numpy as np\n\ndef totalWaterCapacity(row: List[float]) -> float:\n    n = len(row)\n    if n == 0:\n        return 0\n    left_max = np.zeros(n)\n    right_max = np.zeros(n)\n    left_max[0] = row[0]\n    right_max[n - 1] = row[n - 1]\n    for i in range(1, n):\n        left_max[i] = max(left_max[i - 1], row[i])\n    for i in range(n - 2, -1, -1):\n        right_max[i] = max(right_max[i + 1], row[i])\n    water = 0\n    for i in range(n):\n        water += min(left_max[i], right_max[i]) - row[i]\n    return water\n\n[/Code 2]\n\n[Asserts 2]\n\nassert totalWaterCapacity([1.5, 2.0, 1.7, 1.2, 1.8])==1.2\nassert totalWaterCapacity([3.0, 1.0, 2.0, 4.0, 5.0, 1.0])==6.0\nassert totalWaterCapacity([2.0, 1.0, 0.5, 3.0, 2.5, 1.0, 4.0])==6.5\nassert totalWaterCapacity([])==0.0\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['arrays', 'subarray', 'subsequence', 'contiguous', 'length', 'mapping', 'enumeration']", "prompt_tokens": 707, "total_tokens": 1142, "completion_tokens": 435, "completion": "[Question 2]\n\nGiven an array of integers, implement a function to find the contiguous subarray with the largest sum. Additionally, provide a series expansion of the contiguous subarray and its length based on given rules.\n\n[/Question 2]\n\n[Code 2]\n\ndef maxSubarray(arr):\n    max_sum = arr[0]\n    current_sum = arr[0]\n    start = 0\n    end = 0\n    for i in range(1, len(arr)):\n        if arr[i] > current_sum + arr[i]:\n            start = i\n            current_sum = arr[i]\n        else:\n            current_sum += arr[i]\n        if current_sum > max_sum:\n            end = i\n            max_sum = current_sum\n    return arr[start:end+1], max_sum\n\ndef seriesExpansion(arr, start, end):\n    return arr[start:end+1]\n\ndef subarrayLength(start, end):\n    return end - start + 1\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maxSubarray([-2, 1, -3, 4, -1, 2, 1, -5, 4]) == ([4, -1, 2, 1], 6)\nassert seriesExpansion([-2, 1, -3, 4, -1, 2, 1, -5, 4], 3, 6) == [4, -1, 2, 1]\nassert subarrayLength(3, 6) == 4\nassert maxSubarray([-2, -3, 4, -1, -2, 1, 5, -3]) == ([4, -1, -2, 1, 5], 7)\nassert seriesExpansion([-2, -3, 4, -1, -2, 1, 5, -3], 2, 6) == [4, -1, -2, 1, 5]\nassert subarrayLength(2, 6) == 5\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'incrementing', 'index', 'swap', 'unmarked', 'counting', 'iteration']", "prompt_tokens": 575, "total_tokens": 946, "completion_tokens": 371, "completion": "[Question 2]\n\nYou are constructing a shopping list tree for a grocery store. Each node in the tree represents an item to be purchased, and the index of the node represents the priority of the item. You are given an array of items where the index of the array represents the priority, and the value at that index represents the quantity of that item to be purchased. If you want to swap the position of two items in the array, you need to increment the counter for the number of swaps. Write a function to construct the shopping list tree and count the number of swaps required to ensure the items are in the correct order.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\nclass TreeNode:\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\n\ndef constructTreeAndCountSwaps(items: List[int]) -> TreeNode:\n    root = TreeNode(items[0])\n    swaps = 0\n    for i in range(1, len(items)):\n        temp = root\n        while temp:\n            if items[i] < temp.val:\n                if temp.left is None:\n                    temp.left = TreeNode(items[i])\n                else:\n                    temp = temp.left\n                    swaps += 1\n            else:\n                if temp.right is None:\n                    temp.right = TreeNode(items[i])\n                else:\n                    temp = temp.right\n                    swaps += 1\n    return root, swaps\n\n[/Code 2]\n\n[Asserts 2]\n\ntree, swaps = constructTreeAndCountSwaps([3, 1, 2])\nassert swaps == 3\ntree, swaps = constructTreeAndCountSwaps([5, 2, 7, 4, 8, 1, 6])\nassert swaps == 7", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'prime', 'pairs', 'difference', 'counting']", "prompt_tokens": 559, "total_tokens": 985, "completion_tokens": 426, "completion": "[Question 2]\n\nYou are given a 3D space represented by an array of points. Write a function to count the number of prime pairs of points in the 3D space. Two points are considered a prime pair if the absolute difference between their x, y, and z coordinates are all prime numbers.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\ndef isPrime(num: int) -> bool:\n\tif num < 2:\n\t\treturn False\n\tfor i in range(2, int(num**0.5) + 1):\n\t\tif num % i == 0:\n\t\t\treturn False\n\treturn True\n\ndef isPrimePair(point1: List[int], point2: List[int]) -> bool:\n\tdiff_x = abs(point1[0] - point2[0])\n\tdiff_y = abs(point1[1] - point2[1])\n\tdiff_z = abs(point1[2] - point2[2])\n\treturn isPrime(diff_x) and isPrime(diff_y) and isPrime(diff_z)\n\ndef countPrimePairs(points: List[List[int]]) -> int:\n\tcount = 0\n\tfor i in range(len(points)):\n\t\tfor j in range(i + 1, len(points)):\n\t\t\tif isPrimePair(points[i], points[j]):\n\t\t\t\tcount += 1\n\treturn count\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countPrimePairs([[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]])==3\nassert countPrimePairs([[2, 3, 5], [7, 11, 13], [17, 19, 23]])==3\nassert countPrimePairs([[3, 4, 6], [8, 10, 12]])==0\nassert countPrimePairs([[2, 5, 7], [11, 13, 17], [19, 23, 29]])==6\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['integer', 'binary', 'count', 'form', 'representation', 'loop']", "prompt_tokens": 482, "total_tokens": 717, "completion_tokens": 235, "completion": "[Question 2]\n\nGiven an array of integers, find the mode of the binary representation of the count of odd values in the array.\n\n[/Question 2]\n\n[Code 2]\n\nfrom collections import Counter\n\ndef modeOfBinaryCountMode(arr):\n\toddCount = sum(1 for num in arr if num % 2 != 0)\n\tbinaryOddCount = bin(oddCount)[2:]\n\tcounts = Counter(binaryOddCount)\n\tmode = counts.most_common(1)[0][0]\n\treturn mode\n\n[/Code 2]\n\n[Asserts 2]\n\nassert modeOfBinaryCountMode([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])=='1'\nassert modeOfBinaryCountMode([11, 12, 13, 14, 15, 16, 17, 18, 19, 20])=='11'\nassert modeOfBinaryCountMode([21, 22, 23, 24, 25, 26, 27, 28, 29, 30])=='111'", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['integer', 'digit', 'sum', 'pair', 'list']", "prompt_tokens": 504, "total_tokens": 838, "completion_tokens": 334, "completion": "[Question 2]\n\nYou are given a list of email addresses. Each email address consists of a local name and a domain name, separated by the '@' symbol. The local name and the domain name may contain digits. \n\nWrite a function to convert the local names of all email addresses to an integer by summing the ASCII values of each character, and then represent the sum in octal format. Return a list of pairs where each pair contains the original email address and its corresponding octal representation of the local name.\n\n[/Question 2]\n\n[Code 2]\n\ndef convertToOctal(emails: list) -> list:\n    result = []\n    for email in emails:\n        local_name, domain_name = email.split('@')\n        local_sum = sum(ord(char) for char in local_name if char.isalnum())\n        octal_representation = oct(local_sum)\n        result.append((email, octal_representation))\n    return result\n\n[/Code 2]\n\n[Asserts 2]\n\nassert convertToOctal(['johndoe123@example.com', 'alice456@example.org']) == [('johndoe123@example.com', '0o315'), ('alice456@example.org', '0o321')]\nassert convertToOctal(['bob22@example.com', '123smith@example.net']) == [('bob22@example.com', '0o361'), ('123smith@example.net', '0o310')]\nassert convertToOctal(['test999@example.com', 'user123@example.org']) == [('test999@example.com', '0o412'), ('user123@example.org', '0o360')]\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['range', 'minimum', 'cost', 'conversion', 'division', 'subtraction', 'optimization', 'brute force']", "prompt_tokens": 622, "total_tokens": 1005, "completion_tokens": 383, "completion": "[Question 2]\n\nYou are given a string consisting of lowercase English letters. Your task is to find the minimum number of substitutions required to convert the given string into a Morse code representation containing the least number of vowels.\n\nMorse code representation of vowels are:\n'a' : '.-'\n'e' : '.'\n'i' : '..'\n'o' : '---'\n'u' : '..-'\n\nWrite a function to calculate the minimum number of substitutions required to convert the given string into Morse code with the least number of vowels.\n\n[/Question 2]\n\n[Code 2]\n\ndef minSubstitutionsMorseCode(s: str) -> int:\n    morse_dict = {'a': '.-', 'e': '.', 'i': '..', 'o': '---', 'u': '..-'}\n\n    vowels = set('aeiou')\n    minSubs = float('inf')\n    \n    def morseConversion(s):\n        mc = \"\"\n        for ch in s:\n            if ch in morse_dict:\n                mc += morse_dict[ch]\n        return mc\n\n    def countVowels(s):\n        return sum([1 for ch in s if ch in vowels])\n\n    for i in range(1 << len(s)):\n        tempStr = ''\n        for j in range(len(s)):\n            if i & (1 << j):\n                tempStr += s[j]\n        if tempStr:\n            temp_morse = morseConversion(tempStr)\n            vowel_count = countVowels(temp_morse)\n            minSubs = min(minSubs, vowel_count)\n\n    return minSubs\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minSubstitutionsMorseCode(\"leetcode\") == 2\nassert minSubstitutionsMorseCode(\"programming\") == 3\nassert minSubstitutionsMorseCode(\"algorithm\") == 2\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'subset', 'operations', 'OR', 'AND', 'XOR', 'combinations', 'bitwise', 'math', 'count']", "prompt_tokens": 695, "total_tokens": 957, "completion_tokens": 262, "completion": "[Question 2]\n\nYou are given an array of buildings represented by their heights. Write a function to determine the total count of all possible rectangular and square buildings that can be built using the heights of the buildings.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef countPossibleBuildings(heights: List[int]) -> int :\n    n = len(heights)\n    count = 0\n    for i in range(n):\n        for j in range(i, n):\n            minHeight = min(heights[i:j+1])\n            sideLength = j - i + 1\n            if minHeight == sideLength:\n                count += 1\n            else:\n                break\n    return count\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countPossibleBuildings([3, 1, 4, 1, 1, 1]) == 3\nassert countPossibleBuildings([4, 2, 2, 2, 2]) == 5\nassert countPossibleBuildings([1, 1, 1, 1, 1]) == 5\nassert countPossibleBuildings([3, 2, 1, 2, 3]) == 1\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'positive integers', 'jumps', 'minimum', 'dynamic programming', 'reach', 'last element', 'inf', 'if', 'possible', 'return']", "prompt_tokens": 734, "total_tokens": 1190, "completion_tokens": 456, "completion": "[Question 2]\n\nGiven an array of positive integers, find the minimum difference between the index of the last element and the index of an element with the maximum occurrences, such that the difference is a Proth number. If no such element exists or the difference is not a Proth number, return -1.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef minDiffProthNumber(arr: List[int]) -> int:\n    n = len(arr)\n    max_occurrence = 0\n    max_occurrence_element = -1\n    for i in range(n):\n        occurrences = arr.count(arr[i])\n        if occurrences > max_occurrence:\n            max_occurrence = occurrences\n            max_occurrence_element = arr[i]\n    if max_occurrence_element == -1:\n        return -1\n    max_index = -1\n    for i in range(n-1, -1, -1):\n        if arr[i] == max_occurrence_element:\n            max_index = i\n            break\n    if max_index == -1:\n        return -1\n    proth_num = lambda k: (2**k)+1\n    for i in range(max_index-1, -1, -1):\n        diff = max_index - i\n        if proth_num(diff) == max_index - i:\n            return diff\n    return -1\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minDiffProthNumber([1, 3, 5, 8, 2, 4, 8, 5, 9, 10, 8]) == 3\nassert minDiffProthNumber([2, 2, 5, 1, 3, 5, 5, 3, 2, 2]) == 2\nassert minDiffProthNumber([3, 3, 3, 3, 3, 3, 2]) == -1\nassert minDiffProthNumber([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == -1\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'subarray', 'distinct', 'count', 'integer', 'mapping']", "prompt_tokens": 581, "total_tokens": 861, "completion_tokens": 280, "completion": "[Question 2]\n\nYou are given an array of integers that is sorted in ascending order. Write a function to count the number of subarrays where the difference between the maximum and minimum element in the subarray is equal to the expected integer value.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\ndef countSubarraysWithDifference(arr: List[int], expected: int) -> int:\n    count = 0\n    n = len(arr)\n    for i in range(n):\n        for j in range(i, n):\n            subarray = arr[i:j+1]\n            if max(subarray) - min(subarray) == expected:\n                count += 1\n    return count\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countSubarraysWithDifference([1, 1, 2, 2, 3, 3, 4, 4], 1) == 20\nassert countSubarraysWithDifference([2, 4, 6, 8, 10], 3) == 5\nassert countSubarraysWithDifference([3, 5, 7, 9], 2) == 4\nassert countSubarraysWithDifference([5, 6, 7, 8, 9], 3) == 3\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['string', 'minimum', 'removal', 'rearrange', 'palindrome', 'frequency', 'odd', 'even']", "prompt_tokens": 533, "total_tokens": 766, "completion_tokens": 233, "completion": "[Question 2]\n\nGiven a string str, the task is to find the minimum number of characters to be removed to form a palindrome. If there are multiple choices, considering the characters in their heptadecagonal order, return the lexicographically smallest string.\n\n[/Question 2]\n\n[Code 2]\n\ndef minRemovalsToFormPalindrome(s: str) -> str:\n    def isPalindrome(s: str) -> bool:\n        return s == s[::-1]\n\n    if isPalindrome(s):\n        return s\n\n    for i in range(len(s)):\n        if isPalindrome(s[i:]):\n            return s[:i]\n    \n    return s[:-1]\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minRemovalsToFormPalindrome(\"ababa\")==\"\"\nassert minRemovalsToFormPalindrome(\"abb\")==\"a\"\nassert minRemovalsToFormPalindrome(\"geeksforgeeks\")==\"geeksforgeek\"\nassert minRemovalsToFormPalindrome(\"abcde\")==\"abcd\"\nassert minRemovalsToFormPalindrome(\"aaabbb\")==\"aaa\"\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'contiguous', 'subarray', 'smallest', 'sum', 'pair', 'indices', 'algorithm', 'nested-loop']", "prompt_tokens": 660, "total_tokens": 955, "completion_tokens": 295, "completion": "[Question 2]\n\nGiven an array of integers, determine if there exists a pair of contiguous subarrays whose sums are balanced. Two subarrays are considered balanced if their sums are equal.\n\nWrite a function `balancedSubarrayPair(arr: List[int]) -> bool` to check whether such a pair exists in the given array.\n\nFor example, given the array [3, 4, 1, 2, 5], the contiguous subarrays [3, 4, 1] and [2] have balanced sums, as both sum up to 8.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\ndef balancedSubarrayPair(arr: List[int]) -> bool:\n    n = len(arr)\n    for i in range(n-1):\n        sum1 = arr[i]\n        for j in range(i+1, n):\n            sum1 += arr[j]\n            sum2 = 0\n            for k in range(j+1, n):\n                sum2 += arr[k]\n            if sum1 == sum2:\n                return True\n    return False\n\n[/Code 2]\n\n[Asserts 2]\n\nassert balancedSubarrayPair([1, 2, 3, 6, 3, 2, 1])== True\nassert balancedSubarrayPair([1, 2, -1, -1, 2, 1])== False\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'XOR', 'sum', 'pair', 'element', 'calculation', 'frequency']", "prompt_tokens": 485, "total_tokens": 770, "completion_tokens": 285, "completion": "[Question 2]\n\nYou are given an array of positive integers representing the frequency of elements. Your task is to construct pairs of elements in such a way that the XOR of elements in each pair is maximized. Additionally, each pair has a cost associated with it, where the cost of a pair is the sum of the elements in that pair multiplied by the frequency of the element. You need to find the maximum cost in rupees for constructing pairs in the array.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef maxPairXORCost(arr: List[int]) -> int:\n    max_xor = 0\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            xor_val = arr[i] ^ arr[j]\n            cost = (arr[i] + arr[j]) * min(arr[i], arr[j])\n            max_xor = max(max_xor, xor_val * arr[i] * arr[j] + cost)\n    return max_xor\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maxPairXORCost([1, 2, 3, 2, 1])==11\nassert maxPairXORCost([2, 4, 2, 2])==28\nassert maxPairXORCost([3, 3, 3, 3, 3, 3])==45", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['substring', 'adjacent', 'characters', 'English', 'alphabets', 'length', 'longest']", "prompt_tokens": 551, "total_tokens": 919, "completion_tokens": 368, "completion": "[Question 2]\n\nYou have an unordered list of English alphabets. Write a function that finds the length of the longest substring of the list such that no pair of adjacent characters are English alphabets that can move like a Rook in chess.\n\n[/Question 2]\n\n[Code 2]\n\ndef longestNonAdjacentRookSubstring(alphabets: List[str]) -> int:\n    max_length = 0\n    current_length = 1\n    \n    for i in range(1,len(alphabets)):\n        if ord(alphabets[i][0]) - ord(alphabets[i-1][0]) not in [0, 1, -1] or abs(int(alphabets[i][1]) - int(alphabets[i-1][1])) not in [0, 1, -1]:\n            current_length += 1\n            max_length = max(max_length, current_length)\n        else:\n            current_length = 1\n            \n    return max_length\n    \n[/Code 2]\n\n[Asserts 2]\n\nassert longestNonAdjacentRookSubstring([\"a1\", \"b3\", \"c5\", \"d7\"]) == 4\nassert longestNonAdjacentRookSubstring([\"e3\", \"f6\", \"g8\", \"h1\"]) == 4\nassert longestNonAdjacentRookSubstring([\"a1\", \"b2\", \"c3\", \"d4\"]) == 1\nassert longestNonAdjacentRookSubstring([\"a1\", \"b5\", \"c4\", \"d6\", \"e8\"]) == 5\nassert longestNonAdjacentRookSubstring([\"h8\", \"g1\", \"f2\", \"e4\", \"d7\"]) == 5\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['binary', 'string', 'subset', 'minimize', 'products', 'occurrences', 'dynamic programming', 'count']", "prompt_tokens": 656, "total_tokens": 1040, "completion_tokens": 384, "completion": "[Question 2]\n\nGiven two binary strings, find the length of the longest common subsequence such that the sum of weights of 0s and 1s in the subsequence is minimized. The weights of 0 and 1 are given by cost0 and cost1 respectively.\n\n[/Question 2]\n\n[Code 2]\n\ndef minimizeWeightedLCS(s1: str, s2: str, cost0: int, cost1: int) -> int:\n    m, n = len(s1), len(s2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if s1[i - 1] == s2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + (cost0 if s1[i - 1] == '0' else cost1)\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    return dp[m][n]\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minimizeWeightedLCS(\"1010\", \"11100\", 1, 2) == 5\nassert minimizeWeightedLCS(\"1101\", \"101\", 1, 3) == 4\nassert minimizeWeightedLCS(\"100100\", \"111000\", 2, 1) == 7\nassert minimizeWeightedLCS(\"1010101\", \"110110\", 2, 2) == 8\nassert minimizeWeightedLCS(\"10101\", \"11011\", 3, 2) == 10\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['string', 'substring', 'concatenate', 'palindrome', 'check', 'form']", "prompt_tokens": 573, "total_tokens": 868, "completion_tokens": 295, "completion": "[Question 2]\n\nGiven a string, the task is to find the longest palindrome substring that can be formed by concatenating the substrings of the given string. If no palindrome substring can be formed, return an empty string.\n\n[/Question 2]\n\n[Code 2]\n\ndef longestPalindrome(s: str) -> str:\n\tdef isPalindrome(s: str) -> bool:\n\t\treturn s == s[::-1]\n\n\tlongest = ''\n\tfor i in range(len(s)):\n\t\tfor j in range(i, len(s)):\n\t\t\tsubstr = s[i:j+1]\n\t\t\tif isPalindrome(substr) and len(substr) > len(longest):\n\t\t\t\tlongest = substr\n\treturn longest\n\ndef longestPalindromeConcatSubstring(s: str) -> str:\n\tlongest_palindrome = ''\n\tfor i in range(len(s)):\n\t\tfor j in range(i, len(s)):\n\t\t\tsubstr = s[i:j+1]\n\t\t\tif substr != '' and isPalindrome(substr) and len(substr) > len(longest_palindrome):\n\t\t\t\tlongest_palindrome = substr\n\treturn longest_palindrome\n\n[/Code 2]\n\n[Asserts 2]\n\nassert(longestPalindromeConcatSubstring('abcdcbaf'))=='abcdcba'\nassert(longestPalindromeConcatSubstring('abbdefggfedbcsk'))=='defggfed'\nassert(longestPalindromeConcatSubstring('acebbbc'))=='bbb'\nassert(longestPalindromeConcatSubstring('xyz'))==''\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['string', 'count', 'occurrences', 'array', 'integer', 'character', 'position', 'index']", "prompt_tokens": 591, "total_tokens": 830, "completion_tokens": 239, "completion": "[Question 2]\n\nYou are given a string s. Write a function to find the count of occurrences of each character in the string and return a dictionary where the keys are the characters and the values are the counts of occurrences, but only for characters whose ASCII value is greater than the given integer value. \n\n[/Question 2]\n\n[Code 2]\n\ndef countOccurrencesGreaterThan(s: str, value: int) -> dict:\n    char_count = {}\n    for char in s:\n        if ord(char) > value:\n            if char in char_count:\n                char_count[char] += 1\n            else:\n                char_count[char] = 1\n    return char_count\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countOccurrencesGreaterThan(\"abacabad\", 97) == {'b': 2, 'd': 1}\nassert countOccurrencesGreaterThan(\"apple\", 100) == {'p': 2}\nassert countOccurrencesGreaterThan(\"coding\", 99) == {'o': 1}\nassert countOccurrencesGreaterThan(\"mississippi\", 109) == {'s': 4, 'p': 2}\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'integers', 'prefix sum', 'reversals', 'subarray', 'maximum', 'dynamic programming', 'iteration']", "prompt_tokens": 789, "total_tokens": 1151, "completion_tokens": 362, "completion": "[Question 2]\n\nYou are given an array of integers. Write a function to find the maximum value that can be obtained by deleting exactly one element from the array and then finding the maximum subarray sum of the resulting array.\n\n[/Question 2]\n\n[Code 2]\n\ndef maxSubarraySumAfterDeletion(arr: List[int]) -> int:\n    n = len(arr)\n    maxPrefixSum = [0] * n\n    minPrefixSum = [0] * n\n    maxVal = arr[0]\n    minVal = arr[0]\n    res = arr[0]\n    for i in range(n):\n        maxVal = max(maxVal + arr[i], arr[i])\n        minVal = min(minVal + arr[i], arr[i])\n        maxPrefixSum[i] = maxVal\n        minPrefixSum[i] = minVal\n    for i in range(1, n - 1):\n        res = max(res, maxPrefixSum[i - 1], maxPrefixSum[i + 1], maxPrefixSum[i - 1] + minPrefixSum[i + 1])\n    return res\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maxSubarraySumAfterDeletion([1, -2, 0, 3]) == 4\nassert maxSubarraySumAfterDeletion([1, -2, -2, 3]) == 3\nassert maxSubarraySumAfterDeletion([-1, -1, -1, -1]) == -1\nassert maxSubarraySumAfterDeletion([8, -1, 6, -7, -4, 5, -4, 7, -6]) == 21\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['bitwise', 'addition', 'recursion', 'integer', 'sum', 'binary']", "prompt_tokens": 468, "total_tokens": 914, "completion_tokens": 446, "completion": "[Question 2]\n\nGiven a binary array representing the transitions of a system, where arr[i] is the state of the system at time i. The task is to find the length of the longest contiguous subarray with the same sum of 0's and 1's.\n\nWrite a function to find the length of the longest contiguous subarray with equal number of 0's and 1's using a recursive approach.\n\n[/Question 2]\n\n[Code 2]\n\ndef longestContiguousSubarray(arr: List[int], start: int, end: int) -> int:\n    if start == end:\n        return 0\n    mid = (start + end) // 2\n    leftLength = longestContiguousSubarray(arr, start, mid)\n    rightLength = longestContiguousSubarray(arr, mid + 1, end)\n    \n    leftSum = 0\n    rightSum = 0\n    maxLength = 0\n    for i in range(mid, start - 1, -1):\n        leftSum += arr[i]\n        for j in range(mid + 1, end + 1):\n            rightSum += arr[j]\n            if leftSum == rightSum:\n                maxLength = max(maxLength, j - i + 1)\n    return max(maxLength, leftLength, rightLength)\n\n[/Code 2]\n\n[Asserts 2]\n\nassert longestContiguousSubarray([0, 1, 0, 0, 1, 1, 0], 0, 6) == 6\nassert longestContiguousSubarray([1, 1, 1, 0, 0, 0, 1, 1], 0, 7) == 6\nassert longestContiguousSubarray([1, 0, 1, 0, 1, 0, 1], 0, 6) == 4\nassert longestContiguousSubarray([0, 0, 1, 1, 0, 0, 1, 1, 1], 0, 8) == 8\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'maximize', 'subsequence', 'constraint', 'adjacent', 'sum', 'positive integers']", "prompt_tokens": 530, "total_tokens": 813, "completion_tokens": 283, "completion": "[Question 2]\n\nYou are given an array of positive integers and a constraint K. Your task is to maximize the sum of K adjacent elements in the array, ensuring that the sum of K adjacent elements is minimized.\n\n[/Question 2]\n\n[Code 2]\n\ndef maxSumMinimizeKAdjacent(arr, k):\n    n = len(arr)\n\n    if k > n:\n        return \"Constraint Violated: K cannot be greater than the size of the array.\"\n\n    min_sum = float('inf')\n    window_sum = sum(arr[:k])\n\n    for i in range(n - k + 1):\n        min_sum = min(min_sum, window_sum)\n        if i + k < n:\n            window_sum = window_sum - arr[i] + arr[i + k]\n\n    return min_sum\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maxSumMinimizeKAdjacent([3, 7, 2, 8, 4, 5, 1], 3) == 9\nassert maxSumMinimizeKAdjacent([1, 2, 3, 4, 5, 6, 7], 4) == 10\nassert maxSumMinimizeKAdjacent([5, 5, 10, 100, 10, 5], 2) == 15\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'distinct', 'pairs', 'counting', 'Counter']", "prompt_tokens": 541, "total_tokens": 852, "completion_tokens": 311, "completion": "[Question 2]\n\nGiven an array arr[] of size N, the task is to find the maximum distance between two distinct pairs of elements in the second half of the array.\n\n[/Question 2]\n\n[Code 2]\n\nfrom collections import Counter\nfrom typing import List\ndef maxDistanceSecondHalf(arr: List[int]) -> int:\n\tcounter = Counter(arr)\n\tdistinct_vals = [val for val, freq in counter.items() if freq >= 2]\n\tmax_distance = 0\n\tfor val in distinct_vals:\n\t\tindices = [i for i, x in enumerate(arr) if x == val]\n\t\tmax_distance = max(max_distance, max(indices) - min(indices))\n\treturn max_distance\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maxDistanceSecondHalf([1, 3, 2, 1, 4, 4, 3, 2]) == 3\nassert maxDistanceSecondHalf([2, 2, 3, 3, 4, 4, 5, 5, 6, 6]) == 5\nassert maxDistanceSecondHalf([5, 6, 7, 8, 9, 9, 8, 7, 6, 5]) == 5\nassert maxDistanceSecondHalf([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == 0\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['equation', 'plane', 'parallel', 'axis', 'normal', 'direction ratios', 'points']", "prompt_tokens": 847, "total_tokens": 1337, "completion_tokens": 490, "completion": "[Question 2]\n\nWrite a program to find the equation of a plane passing through three given points. Additionally, the plane should be parallel to a specific axis (x-axis, y-axis, or z-axis) and the equation for the plane should be calculated using an iterative approach. The equation of the plane is represented in the form ax + by + cz = d, where a, b, and c are the direction ratios normal to the plane.\n\n[/Question 2]\n\n[Code 2]\n\ndef planeEquationIterative(p1, p2, p3, axis:str) -> str:\n\t# Calculate the direction ratios for the normal to the plane\n\tif axis==\"x\":\n\t\ta, b, c = 0, p1[2]-p2[2], p2[1]-p1[1]\n\telif axis==\"y\":\n\t\ta, b, c = p2[2]-p1[2], 0, p1[0]-p2[0]\n\telif axis==\"z\":\n\t\ta, b, c = p1[1]-p2[1], p2[0]-p1[0], 0\n\n\t# Calculate the numeric value 'd' in the plane equation ax + by + cz = d by iterating through all the given points\n\tnumeric_val = 0\n\tfor point in [p1, p2, p3]:\n\t\tnumeric_val += a*point[0] + b*point[1] + c*point[2]\n\n\treturn f'{a}x + {b}y + {c}z = {numeric_val}'\n\n[/Code 2]\n\n[Asserts 2]\n\nassert planeEquationIterative([1,2,3], [4,5,6], [7,8,9], \"x\") == '0x + 3y + -3z = 6'\nassert planeEquationIterative([1,2,3], [4,5,6], [7,8,9], \"y\") == '3x + 0y + -3z = 6'\nassert planeEquationIterative([1,2,3], [4,5,6], [7,8,9], \"z\") == '3x + 3y + 0z = 6'\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'integers', 'divisor', 'factor', 'iteration', 'conditional', 'mathematical']", "prompt_tokens": 590, "total_tokens": 867, "completion_tokens": 277, "completion": "[Question 2]\n\nWrite a function to iterate through an array of integers and delete elements that do not meet a specific conditional criteria, based on their greatest divisor.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef deleteElements(arr: List[int], criteria: int) -> List[int]:\n    result = []\n    for num in arr:\n        max_divisor = -1\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                max_divisor = max(max_divisor, i, num // i)\n        if max_divisor >= criteria:\n            result.append(num)\n    return result\n\n[/Code 2]\n\n[Asserts 2]\n\nassert deleteElements([10, 15, 21, 29, 33, 49], 5)==[15, 21, 29, 33, 49]\nassert deleteElements([56, 72, 102, 111, 125, 144], 30)==[56, 72, 102, 144]\nassert deleteElements([30, 49, 63, 81, 100, 121], 20)==[30, 49, 63, 81, 100, 121]\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['factors', 'composite', 'counting', 'math', 'divisibility', 'iteration']", "prompt_tokens": 461, "total_tokens": 658, "completion_tokens": 197, "completion": "[Question 2]\n\nGiven a list of non-negative integers, write a function to count the numbers which have their first digit equal to the last digit.\n\n[/Question 2]\n\n[Code 2]\n\ndef countFirstLastEqual(numbers: List[int]) -> int:\n    count = 0\n    for num in numbers:\n        last_digit = num % 10\n        first_digit = int(str(num)[0])\n        if first_digit == last_digit:\n            count += 1\n    return count\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countFirstLastEqual([123, 252, 303, 456]) == 2\nassert countFirstLastEqual([101, 202, 333, 555]) == 3\nassert countFirstLastEqual([111, 222, 333, 444]) == 4\nassert countFirstLastEqual([123, 456, 789, 987]) == 1", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'sum', 'addition', 'increment', 'minimum', 'iteration', 'loop', 'comparison']", "prompt_tokens": 549, "total_tokens": 811, "completion_tokens": 262, "completion": "[Question 2]\n\nYou are given an array of side lengths representing the sides of different triangles. Your task is to find the minimum number of additions required in the array to make it represent a harmonic series.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef minAddToMakeHarmonic(arr: List[int]) -> int:\n    n = len(arr)\n    target_sum = 0\n    for i in range(1, n+1):\n        target_sum += 1/i\n    current_sum = sum(arr)\n    minAdd = 0\n    while current_sum < target_sum:\n        minAdd += 1\n        arr.append(1)\n        current_sum = sum(arr)\n    return minAdd\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minAddToMakeHarmonic([1, 2, 3, 4, 5])==7\nassert minAddToMakeHarmonic([3, 6, 11])==0\nassert minAddToMakeHarmonic([2, 3, 4, 5, 6, 7, 8])==9\nassert minAddToMakeHarmonic([1, 3, 5, 7])==3\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['string', 'substring', 'conversion', 'comparison', 'boolean']", "prompt_tokens": 477, "total_tokens": 681, "completion_tokens": 204, "completion": "[Question 2]\n\nWrite a function that takes a nested list of integers and returns the sum of the squares of all the values present in the list.\n\n[/Question 2]\n\n[Code 2]\n\ndef sum_of_squares(lst: list) -> int:\n    total = 0\n    for val in lst:\n        if isinstance(val, list):\n            total += sum_of_squares(val)\n        elif isinstance(val, int):\n            total += val ** 2\n    return total\n\n[/Code 2]\n\n[Asserts 2]\n\nassert sum_of_squares([1, 2, 3, [4, 5], 6]) == 95\nassert sum_of_squares([[1, 2, [3, 4]], [5, 6], 7, 8]) == 120\nassert sum_of_squares([9, [10, 11, [12, 13, 14], 15], 16]) == 1445", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['integer', 'set bits', 'increment', 'count', 'binary', 'next', 'greater', 'existence', 'return']", "prompt_tokens": 493, "total_tokens": 740, "completion_tokens": 247, "completion": "[Question 2]\n\nGiven a list of integers, return the integer with the greatest number of set bits. If there are multiple integers with the same count of set bits, return the integer that has a greater value.\n\n[/Question 2]\n\n[Code 2]\n\ndef countSetBits(n):\n\tcount = 0\n\twhile (n):\n\t\tcount += n & 1\n\t\tn >>= 1\n\treturn count\n\ndef greatestSetBitInteger(nums):\n\tmax_bits = -1\n\tmax_val = float('-inf')\n\tfor num in nums:\n\t\tbits = countSetBits(num)\n\t\tif bits > max_bits or (bits == max_bits and num > max_val):\n\t\t\tmax_bits = bits\n\t\t\tmax_val = num\n\treturn max_val\n\n[/Code 2]\n\n[Asserts 2]\n\nassert greatestSetBitInteger([5, 3, 7, 9])==3\nassert greatestSetBitInteger([2, 10, 6, 12])==10\nassert greatestSetBitInteger([15, 6, 10, 7])==6\nassert greatestSetBitInteger([30, 20, 25, 15])==15\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['string', 'reverse', 'space', 'position', 'preserving']", "prompt_tokens": 556, "total_tokens": 791, "completion_tokens": 235, "completion": "[Question 2]\n\nWrite a Python program to reverse the string positions of non-overlapping octagonal jobs while preserving their positions in the string.\n\n[/Question 2]\n\n[Code 2]\n\ndef reverseNonOverlappingOctagonalJobs(string: str) -> str:\n    jobs = [i for i in range(len(string)) if string.startswith('job', i)]\n    jobs.reverse()\n    result = list(string)\n    for start_index in jobs:\n        end_index = start_index + 3\n        result = result[:start_index] + result[start_index:end_index][::-1] + result[end_index:]\n    return ''.join(result)\n\n[/Code 2]\n\n[Asserts 2]\n\nassert reverseNonOverlappingOctagonalJobs(\"jobxwrejobabcoctagonaljobdef\") == \"jobxwrecobajlagnatcocjobdef\"\nassert reverseNonOverlappingOctagonalJobs(\"jobhellojobworldoctagonaljobs\") == \"jobhellojobdlrowoctagonaljobs\"\nassert reverseNonOverlappingOctagonalJobs(\"jobtestjobnonjoboverlapping\") == \"jobtestjobnonjobgnivarepolo\"", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['2D', 'matrix', 'path', 'sum', 'movement', 'dynamic programming', 'maximum', 'down', 'right']", "prompt_tokens": 812, "total_tokens": 1305, "completion_tokens": 493, "completion": "[Question 2]\n\nGiven a 2D matrix grid of size N x M representing a gold mine, each cell contains a certain amount of gold. You start at the first column and can move right and up/down (diagonally) to the adjacent cells. The task is to find the maximum amount of gold that can be collected starting from any column in the first row to any column in the last row while moving only right, up, or down (no left movement allowed).\n\n[/Question 2]\n\n[Code 2]\n\ndef maxGoldCollection(grid):\n    n = len(grid)\n    m = len(grid[0])\n    \n    dp = [[0] * m for _ in range(n)]\n    for j in range(m):\n        dp[0][j] = grid[0][j]\n        \n    for i in range(1, n):\n        for j in range(m):\n            current_gold = grid[i][j]\n            if j > 0:\n                dp[i][j] = max(dp[i][j], dp[i-1][j-1] + current_gold)\n            dp[i][j] = max(dp[i][j], dp[i-1][j] + current_gold)\n            if j < m-1:\n                dp[i][j] = max(dp[i][j], dp[i-1][j+1] + current_gold)\n    \n    return max(max(row) for row in dp)\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maxGoldCollection([[1, 3, 1, 5], [2, 2, 4, 1], [5, 0, 2, 3], [0, 6, 1, 2]]) == 16\nassert maxGoldCollection([[10, 33, 13, 15], [22, 21, 4, 1], [5, 0, 2, 3], [0, 6, 14, 2]]) == 83\nassert maxGoldCollection([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 24\nassert maxGoldCollection([[1, 3, 5], [2, 6, 8], [7, 4, 3]]) == 23\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'sequence', 'change', 'minimum', 'mathematical', 'iteration', 'comparison']", "prompt_tokens": 774, "total_tokens": 1305, "completion_tokens": 531, "completion": "[Question 2]\n\nYou are given a 2D array of characters representing the board, where 'X' represents a wall and 'O' represents an open space. A cell is surrounded by walls if it is not on the border and all the cells adjacent to it are walls. Every time a cell is surrounded by walls, you have to change it from 'O' to 'X'. \n\nWrite a function ```surroundedRegions``` to iterate through the board and change the surrounded regions.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\ndef surroundedRegions(board: List[List[str]]) -> None:\n    if not board:\n        return\n    m, n = len(board), len(board[0])\n\n    def dfs(x, y):\n        if 0 <= x < m and 0 <= y < n and board[x][y] == 'O':\n            board[x][y] = '*'\n            dfs(x + 1, y)\n            dfs(x - 1, y)\n            dfs(x, y + 1)\n            dfs(x, y - 1)\n\n    for i in range(m):\n        dfs(i, 0)\n        dfs(i, n - 1)\n\n    for j in range(1, n - 1):\n        dfs(0, j)\n        dfs(m - 1, j)\n\n    for i in range(m):\n        for j in range(n):\n            if board[i][j] == 'O':\n                board[i][j] = 'X'\n            elif board[i][j] == '*':\n                board[i][j] = 'O'\n\n[/Code 2]\n\n[Asserts 2]\n\nboard = [\n  [\"X\",\"X\",\"X\",\"X\"],\n  [\"X\",\"O\",\"O\",\"X\"],\n  [\"X\",\"X\",\"O\",\"X\"],\n  [\"X\",\"O\",\"X\",\"X\"]\n]\nsurroundedRegions(board)\nassert board == [\n  [\"X\",\"X\",\"X\",\"X\"],\n  [\"X\",\"X\",\"X\",\"X\"],\n  [\"X\",\"X\",\"X\",\"X\"],\n  [\"X\",\"O\",\"X\",\"X\"]\n]\n\nboard = [\n  [\"X\",\"X\",\"X\",\"X\"],\n  [\"X\",\"X\",\"X\",\"X\"],\n  [\"X\",\"X\",\"X\",\"X\"],\n  [\"X\",\"X\",\"X\",\"X\"]\n]\nsurroundedRegions(board)\nassert board == [\n  [\"X\",\"X\",\"X\",\"X\"],\n  [\"X\",\"X\",\"X\",\"X\"],\n  [\"X\",\"X\",\"X\",\"X\"],\n  [\"X\",\"X\",\"X\",\"X\"]\n]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['Nude Number', 'perfect squares', 'difference', 'consecutive', 'boolean', 'math']", "prompt_tokens": 518, "total_tokens": 875, "completion_tokens": 357, "completion": "[Question 2]\n\nYou are given an array of numbers. Write a function to find and return all unique combinations of two numbers from the array such that their absolute difference is a perfect square. If no such combinations exist, return an empty list.\n\n[/Question 2]\n\n[Code 2]\n\nfrom itertools import combinations\nimport math\n\ndef isPerfectSquare(n: int) -> bool:\n    root = math.isqrt(n)\n    return n == root * root\n\ndef uniqueCombinationsWithPerfectSquareDifference(arr: List[int]) -> List[Tuple[int, int]]:\n    result = []\n    for combination in combinations(arr, 2):\n        if isPerfectSquare(abs(combination[0] - combination[1])):\n            result.append(combination)\n    return list(set(result))\n\n[/Code 2]\n\n[Asserts 2]\n\nassert uniqueCombinationsWithPerfectSquareDifference([1, 3, 7, 10, 14, 20])==[(7, 14)]\nassert uniqueCombinationsWithPerfectSquareDifference([2, 5, 6, 8, 9])==[]\nassert uniqueCombinationsWithPerfectSquareDifference([3, 6, 10, 15, 19, 23, 27])==[(10, 19), (15, 27), (6, 15), (10, 19)]\nassert uniqueCombinationsWithPerfectSquareDifference([2, 3, 4, 5, 6])==[(3, 4), (2, 5)]\nassert uniqueCombinationsWithPerfectSquareDifference([8, 12, 18, 24, 30, 36, 48, 60])==[(18, 48), (24, 60)]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['substring', 'binary string', 'flipping', 'counting', 'max length', 'iteration', 'conditional', 'equality']", "prompt_tokens": 557, "total_tokens": 770, "completion_tokens": 213, "completion": "[Question 2]\n\nWrite a Python class that takes a non-negative integer as input and returns the maximum binary substring length that can be obtained by uniformly flipping a single substring of the binary representation of the input integer. If no such substring exists, return 0.\n\n[/Question 2]\n\n[Code 2]\n\nclass BinarySubstring:\n    def maxLengthOfSubstring(self, num: int) -> int:\n        binary_str = bin(num)[2:]\n        max_length, cur_length = 0, 0\n        for bit in binary_str:\n            if bit == '0':\n                cur_length += 1\n                max_length = max(max_length, cur_length)\n            else:\n                cur_length = 0\n        return max_length\n\n[/Code 2]\n\n[Asserts 2]\n\nbs = BinarySubstring()\nassert bs.maxLengthOfSubstring(5) == 1\nassert bs.maxLengthOfSubstring(222) == 3\nassert bs.maxLengthOfSubstring(8) == 1\nassert bs.maxLengthOfSubstring(13) == 2", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['rope', 'segments', 'length', 'cut', 'maximum', 'recursive', 'subproblems', 'optimization']", "prompt_tokens": 604, "total_tokens": 900, "completion_tokens": 296, "completion": "[Question 2]\n\nYou are given a rope of length L and you want to cut it into segments such that the digital sum of each segment is maximized. The digital sum of a number is the sum of its digits. For example, the digital sum of 83 is 8 + 3 = 11.\n\nWrite a function to determine the maximum digital sum that can be achieved by cutting the rope into distinct segments.\n\n[/Question 2]\n\n[Code 2]\n\ndef maxDigitalSumOfSegments(L: int) -> int:\n    def digit_sum(num: int) -> int:\n        return sum(map(int, str(num)))\n\n    def helper(L: int, prev: int, memo: dict) -> int:\n        if L == 0:\n            return 0\n        if L in memo:\n            return memo[L]\n        max_sum = 0\n        for i in range(1, L+1):\n            max_sum = max(max_sum, digit_sum(i) + helper(L - i, i, memo))\n        memo[L] = max_sum\n        return max_sum\n\n    return helper(L, 0, {})\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maxDigitalSumOfSegments(5) == 5\nassert maxDigitalSumOfSegments(14) == 24\nassert maxDigitalSumOfSegments(25) == 35\nassert maxDigitalSumOfSegments(17) == 31", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['number', 'integer', 'square', 'divisible', 'function', 'check']", "prompt_tokens": 467, "total_tokens": 813, "completion_tokens": 346, "completion": "[Question 2]\n\nIn a road construction project, the Prufer sequence is used to represent the construction of roads between nodes in a graph. The harmonic mean of a set of integers is an important value in such constructions. Create a function to check if the harmonic mean of a set of integers contains a specific number of 1s in its decimal representation. The function should take the set of integers and the number of 1s to check for, and return True if the harmonic mean contains the specified number of 1s, otherwise return False.\n\n[/Question 2]\n\n[Code 2]\n\nfrom statistics import harmonic_mean\n\ndef checkHarmonicMeanOnes(numbers: set, num_ones: int) -> bool:\n    harmonic = harmonic_mean(numbers)\n    decimal_representation = str(harmonic - int(harmonic))[2:]\n    count_ones = decimal_representation.count('1')\n    if count_ones == num_ones:\n        return True\n    else:\n        return False\n\n[/Code 2]\n\n[Asserts 2]\n\nassert checkHarmonicMeanOnes({1, 2, 3, 4, 5}, 2)==True\nassert checkHarmonicMeanOnes({5, 8, 13, 20}, 3)==False\nassert checkHarmonicMeanOnes({10, 100, 1000}, 1)==True\nassert checkHarmonicMeanOnes({2, 4, 8, 16, 32}, 4)==False\nassert checkHarmonicMeanOnes({3, 5, 7, 11, 13}, 2)==True\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['distinct', 'words', 'vowels', 'contiguous', 'size', 'count', 'dp', 'maximum', 'allowed', 'task']", "prompt_tokens": 627, "total_tokens": 894, "completion_tokens": 267, "completion": "[Question 2]\n\nGiven a string s, the task is to find the maximum count of distinct substrings with at most M vowels allowed and each substring must have a contiguous count of vowels less than or equal to K.\n\n[/Question 2]\n\n[Code 2]\n\ndef countDistinctSubstrings(s: str, M: int, K: int) -> int:\n    vowels = ['a', 'e', 'i', 'o', 'u']\n    count = 0\n    for i in range(len(s)):\n        for j in range(i, len(s)):\n            substring = s[i:j+1]\n            if substring.count('') <= M and max([len(list(vowel)) for vowel in vowels]) <= K:\n                count += 1\n    return count\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countDistinctSubstrings(\"leetcode\", 2, 1) == 17\nassert countDistinctSubstrings(\"programming\", 1, 2) == 35\nassert countDistinctSubstrings(\"example\", 3, 1) == 13\nassert countDistinctSubstrings(\"coding\", 1, 1) == 9\nassert countDistinctSubstrings(\"question\", 2, 2) == 19\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'string', 'rearrange', 'common prefix', 'maximum length']", "prompt_tokens": 553, "total_tokens": 793, "completion_tokens": 240, "completion": "[Question 2]\n\nGiven an array of strings, rearrange the strings in any order to maximize the length of the common prefix between all the strings. After rearranging the strings, calculate the maximum length of the common prefix possible.\n\n[/Question 2]\n\n[Code 2]\n\ndef maxCommonPrefixLength(strs):\n    strs.sort()\n    n = min(len(strs[0]), len(strs[-1]))\n    i = 0\n    while i < n and (strs[0][i] == strs[-1][i]):\n        i += 1\n    return i\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maxCommonPrefixLength([\"flower\", \"flow\", \"flight\"]) == 4\nassert maxCommonPrefixLength([\"dog\", \"racecar\", \"car\"]) == 0\nassert maxCommonPrefixLength([\"apple\", \"ape\", \"april\"]) == 3\nassert maxCommonPrefixLength([\"geeksforgeeks\", \"geeks\", \"geek\"]) == 4\nassert maxCommonPrefixLength([\"hello\", \"hell\", \"hello\", \"hello there\"]) == 4\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'integer', 'maximum', 'minimum', 'splits', 'subarray', 'contiguous', 'binary search', 'possible']", "prompt_tokens": 735, "total_tokens": 1204, "completion_tokens": 469, "completion": "[Question 2]\n\nYou are given an array of integers with an initial quantity of q. Given a query array, for each element in the query array, you need to elect the smallest possible contiguous subarray such that the quantity of the given element is at least q. If no such subarray exists, return -1 for that query. Write a function to perform these elections and return their results.\n\n[/Question 2]\n\n[Code 2]\n\ndef minSubarrayWithQuantity(arr, n, q, queryArr):\n    result = []\n    # Preprocessing to store the leftmost occurrence of each element\n    leftmost = {}\n    for i in range(n):\n        if arr[i] not in leftmost:\n            leftmost[arr[i]] = i\n    for query in queryArr:\n        if query not in leftmost:\n            result.append(-1)\n        else:\n            left = leftmost[query]\n            count = 0\n            minLen = float('inf')\n            for i in range(n):\n                if arr[i] == query:\n                    count += 1\n                    if count >= q:\n                        minLen = min(minLen, i - left + 1)\n                        left = i - q + 1\n            result.append(minLen if minLen != float('inf') else -1)\n    return result\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minSubarrayWithQuantity([1, 2, 1, 3, 2, 1, 3, 2], 8, 2, [1, 2, 3]) == [3, 2, 4]\nassert minSubarrayWithQuantity([1, 2, 1, 3, 2, 1, 3, 2], 8, 3, [1, 2, 3]) == [5, 5, -1]\nassert minSubarrayWithQuantity([4, 4, 4, 4, 4], 5, 4, [4]) == [1]\nassert minSubarrayWithQuantity([4, 4, 4, 4, 4], 5, 5, [4]) == [5]\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['string', 'substrings', 'vowels', 'count']", "prompt_tokens": 480, "total_tokens": 669, "completion_tokens": 189, "completion": "[Question 2]\n\nWrite a Python function to calculate the sum of distances between all pairs of substrings within a given string, where the distance between two substrings is defined as the absolute difference of their lengths.\n\n[/Question 2]\n\n[Code 2]\n\ndef sumOfSubstringDistances(s: str) -> int:\n    result = 0\n    for i in range(len(s)):\n        for j in range(i, len(s)):\n            result += abs(len(s[i:j+1]) - len(s))\n    return result\n\n[/Code 2]\n\n[Asserts 2]\n\nassert sumOfSubstringDistances(\"abcde\")==5\nassert sumOfSubstringDistances(\"aeiou\")==35\nassert sumOfSubstringDistances(\"hello\")==20\nassert sumOfSubstringDistances(\"aaaeiouuu\")==99\nassert sumOfSubstringDistances(\"thequickbrownfoxjumpsoverthelazydog\")==399", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['geometry', 'lines', 'slope', 'coordinates', 'parallel', 'pattern']", "prompt_tokens": 628, "total_tokens": 909, "completion_tokens": 281, "completion": "[Question 2]\n\nYou are given coordinates of N points on a 2D plane. Write a function to determine if these points form a straight line.\n\n[/Question 2]\n\n[Code 2]\n\ndef checkStraightLine(coordinates) -> bool:\n    x0, y0 = coordinates[0]\n    x1, y1 = coordinates[1]\n    for i in range(2, len(coordinates)):\n        x, y = coordinates[i]\n        if (x1 - x0) * (y - y1) != (x - x1) * (y1 - y0):\n            return False\n    return True\n\n[/Code 2]\n\n[Asserts 2]\n\nassert checkStraightLine([[1,1],[2,2],[3,3],[4,4],[5,5]])==True\nassert checkStraightLine([[1,2],[2,3],[3,5],[4,6],[5,7]])==False\nassert checkStraightLine([[1,1],[2,2],[5,5],[8,8],[10,10]])==True\nassert checkStraightLine([[-3,-2],[-1,-2],[2,-2],[4,-2]])==True\nassert checkStraightLine([[1,1],[1,2],[1,3],[1,4]])==True\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['box', 'balls', 'colors', 'choose', 'number', 'ways']", "prompt_tokens": 426, "total_tokens": 664, "completion_tokens": 238, "completion": "[Question 2]\n\nYou are given a nested list of numbers representing the balls in different boxes. Each box can hold a single digit number. Write a function to calculate the maximum number maximized by choosing the digits from the nested list and concatenating them in different ways.\n\n[/Question 2]\n\n[Code 2]\n\nfrom itertools import permutations\n\ndef maximizeNumber(nested_list: list) -> int:\n    all_numbers = [int(''.join(map(str, sublist))) for sublist in permutations(flatten(nested_list))]\n    return max(all_numbers)\n\ndef flatten(nested_list):\n    for item in nested_list:\n        if isinstance(item, list):\n            yield from flatten(item)\n        else:\n            yield item\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maximizeNumber([[1, 2], [3, 4]]) == 4321\nassert maximizeNumber([[5, 6, 7], [8, 9]]) == 987765432\nassert maximizeNumber([[9, 8, 7, 6], [5, 4, 3], [2, 1]]) == 987654321321765432", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['number', 'sum', 'digits', 'minimize', 'function', 'map', 'asserts']", "prompt_tokens": 554, "total_tokens": 821, "completion_tokens": 267, "completion": "[Question 2]\n\nYou are given a list of employee arrival times at a circular lock. The lock consists of digits 0 to 9. Each employee entered a specific integer as their password. You need to find the remaining element in the circular lock after considering the intersection of digits entered by the employees. Write a function to find this remaining element.\n\n[/Question 2]\n\n[Code 2]\n\nfrom functools import reduce\nfrom operator import __or__\n\ndef remainingElement(arrival_times: List[str]) -> int:\n    employee_digits = [set(map(int, str(n))) for n in arrival_times]\n    intersected_digits = reduce(lambda x, y: x & y, employee_digits)\n    remaining = list(set(range(10)) - intersected_digits)\n    return remaining[0]\n\n[/Code 2]\n\n[Asserts 2]\n\nassert remainingElement(['123', '456', '789']) == 0\nassert remainingElement(['111', '222', '333']) == 4\nassert remainingElement(['9876', '5432', '1098']) == 5\nassert remainingElement(['12345', '56789', '98765']) == 4\nassert remainingElement(['11111', '22222', '33333']) == 4\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['string', 'correspondence', 'mapping', 'number', 'array']", "prompt_tokens": 580, "total_tokens": 861, "completion_tokens": 281, "completion": "[Question 2]\n\nYou are given an array of integers. Write a function that takes the array as input and returns the maximum integer that is present at a specific position when the array is unrolled and mapped to a string based on a given correspondence rule. The correspondence rule indicates that each number is mapped to a specific letter of the English alphabet starting from 'a' for 1, 'b' for 2, and so on. The unrolling step involves considering all possible subsequences of the array and finding the maximum element after mapping each subsequence to a string based on the corresponding rule.\n\n[/Question 2]\n\n[Code 2]\n\nfrom itertools import combinations\n\ndef maxElementAfterUnrolling(arr: List[int]) -> int:\n    def mapToLetter(num):\n        return chr(ord('a') + num - 1)\n    \n    max_element = float('-inf')\n    for i in range(1, len(arr)+1):\n        for subsequence in combinations(arr, i):\n            mapped_str = ''.join(map(mapToLetter, subsequence))\n            max_element = max(max_element, max(mapToLetter(max(subsequence))))\n    return max_element\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maxElementAfterUnrolling([1, 2, 3])==99\nassert maxElementAfterUnrolling([4, 5, 6])==102", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['string', 'diagonal', 'alphabetical', 'order', 'index', 'comparison']", "prompt_tokens": 514, "total_tokens": 717, "completion_tokens": 203, "completion": "[Question 2]\n\nWrite a function to find the smallest string (lexical order) that is not present in the list of strings. The strings are provided in alphabetical order, and the function should return the smallest string that does not exist in the list.\n\n[/Question 2]\n\n[Code 2]\n\ndef findSmallestMissingString(strings):\n    prev = \"\"\n    for s in strings:\n        if s != prev and s != prev + \"a\":\n            return prev + \"a\"\n        prev = s\n    return prev + \"a\"\n\n[/Code 2]\n\n[Asserts 2]\n\nassert findSmallestMissingString([\"a\", \"b\", \"d\", \"f\"])==\"c\"\nassert findSmallestMissingString([\"aa\", \"ab\", \"ac\"])==\"ad\"\nassert findSmallestMissingString([\"apples\", \"oranges\", \"pears\"])==\"apr\"\nassert findSmallestMissingString([\"dog\", \"elephant\", \"giraffe\"])==\"don\"", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['binary search', 'randomized', 'count', 'array', 'bit manipulation', 'set bits', 'algorithm']", "prompt_tokens": 588, "total_tokens": 944, "completion_tokens": 356, "completion": "[Question 2]\n\nYou are given an array containing N elements, each representing a location. Write a function to count the number of locations that can be considered in a randomized cryptography algorithm using bit manipulation. The algorithm involves a binary search approach to identify the locations meeting the criteria.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\nfrom collections import defaultdict\n\ndef countRandomizedLocations(arr: List[int]) -> int:\n    def countSetBits(num: int) -> int:\n        count = 0\n        while num:\n            count += num & 1\n            num >>= 1\n        return count\n\n    # Store all the set bit counts in a defaultdict\n    count_dict = defaultdict(int)\n    for location in arr:\n        count_dict[countSetBits(location)] += 1\n\n    # Count the number of locations that meet the criteria for the algorithm\n    ans = 0\n    for count in count_dict:\n        ans += count_dict[count] * (count_dict[count] - 1) // 2\n    return ans\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countRandomizedLocations([3, 5, 6, 9, 10, 12]) == 4\nassert countRandomizedLocations([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == 25\nassert countRandomizedLocations([15, 16, 17, 18, 19, 20]) == 0\nassert countRandomizedLocations([7, 14, 21, 28, 35, 42]) == 0\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'prizes', 'students', 'line', 'minimize', 'count', 'distribution', 'adjacent', 'pair', 'value']", "prompt_tokens": 716, "total_tokens": 1167, "completion_tokens": 451, "completion": "[Question 2]\n\nYou are given an array representing the heights of n students standing in a line. The height of each student is represented as an integer value in the array. Your task is to find the highest floor where a \"wave\" can start at the first student and travel through the line such that the heights form a \"wave\" pattern, where each student's height is greater than its two adjacent neighbors.\n\nWrite a function `highestWaveFloor` to accomplish the task. The function should take in an array of `heights` as a parameter and return the highest floor number where a \"wave\" can start.\n\nFor example, given an input array `heights = [1, 3, 2, 4, 1, 5, 2]`, the output would be `5` because a \"wave\" can start at the first student and travel through the line such that the heights form a \"wave\" pattern up to the 5th floor.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\ndef highestWaveFloor(heights: List[int]) -> int:\n    n = len(heights)\n    highest_floor = 0\n    for i in range(1, n - 1):\n        if (heights[i - 1] < heights[i] and heights[i] > heights[i + 1]) or (heights[i - 1] > heights[i] and heights[i] < heights[i + 1]):\n            highest_floor = i + 1\n    return highest_floor\n\n[/Code 2]\n\n[Asserts 2]\n\nassert highestWaveFloor([1, 3, 2, 4, 1, 5, 2]) == 5\nassert highestWaveFloor([1, 2, 3, 4, 3, 2, 1]) == 4\nassert highestWaveFloor([5, 4, 5, 4, 5, 4, 5]) == 5\nassert highestWaveFloor([1, 2, 3, 2, 3, 2, 3]) == 3\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['2D grid', 'cell', 'coins', 'exit gate', 'dead end', 'move', 'directions', 'blocked', 'boundary', 'maximum']", "prompt_tokens": 964, "total_tokens": 1681, "completion_tokens": 717, "completion": "[Question 2]\n\nYou are given a 2D grid of size N x M representing a prison, where each cell in the grid represents a prison cell. Each cell is either empty (represented by 0) or blocked (represented by 1). In order to keep the prisoners engaged, the warden wants to draw a path that allows the prisoners to move from the top-left cell (0, 0) to the exit gate at the bottom-right cell (N-1, M-1). The path should maximize the harmonic mean of the values encountered along the path.\n\nWrite a function `maxHarmonicMeanPath` to draw a path from the top-left cell to the bottom-right cell and returns the maximum harmonic mean of the values encountered along the path. If a path is not possible, return 0.\n\n[/Question 2]\n\n[Code 2]\n\nfrom queue import PriorityQueue\n\ndef maxHarmonicMeanPath(grid: List[List[int]]) -> float:\n        n = len(grid)\n        m = len(grid[0])\n        pq = PriorityQueue()\n        pq.put((-grid[0][0], (0, 0)))\n        visited = [[False] * m for _ in range(n)]\n        directions = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n\n        def isValid(x, y):\n            return 0 <= x < n and 0 <= y < m and not visited[x][y] and grid[x][y] == 0\n\n        while not pq.empty():\n            val, (x, y) = pq.get()\n            val = -val\n            visited[x][y] = True\n            if x == n - 1 and y == m - 1:\n                return (2 * val) / (x + y)\n            for dx, dy in directions:\n                nx, ny = x + dx, y + dy\n                if isValid(nx, ny):\n                    pq.put((-max(val, grid[nx][ny]), (nx, ny)))\n\n        return 0.0\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maxHarmonicMeanPath([[0, 1, 0, 0, 0],\n                            [0, 1, 0, 1, 0],\n                            [0, 0, 0, 1, 0],\n                            [1, 1, 0, 1, 0],\n                            [0, 0, 0, 0, 0]]) == 0.0\nassert maxHarmonicMeanPath([[0, 1, 0, 0, 0],\n                            [0, 1, 0, 1, 0],\n                            [0, 0, 0, 1, 0],\n                            [1, 0, 0, 0, 0],\n                            [0, 0, 0, 0, 0]]) == 0.4\nassert maxHarmonicMeanPath([[0, 1, 0, 0, 0],\n                            [0, 1, 1, 1, 0],\n                            [0, 0, 0, 1, 0],\n                            [1, 1, 0, 1, 0],\n                            [0, 0, 0, 0, 0]]) == 0.25\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['sorted', 'array', 'frequency', 'occurrences', 'binary search']", "prompt_tokens": 777, "total_tokens": 1220, "completion_tokens": 443, "completion": "[Question 2]\n\nYou are given a sorted array of integers containing both positive and negative numbers. Write a function to find the frequency of occurrences of a specific number in the array using the binary search algorithm.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef findFrequency(arr: List[int], target: int) -> int:\n    def binarySearchLeft(arr, target):\n        left, right = 0, len(arr)-1\n        while left <= right:\n            mid = left + (right - left) // 2\n            if arr[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return left\n    leftIndex = binarySearchLeft(arr, target)\n    if leftIndex == len(arr) or arr[leftIndex] != target:\n        return 0\n    def binarySearchRight(arr, target):\n        left, right = 0, len(arr)-1\n        while left <= right:\n            mid = left + (right - left) // 2\n            if arr[mid] <= target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return right\n    rightIndex = binarySearchRight(arr, target)\n    return rightIndex - leftIndex + 1\n\n[/Code 2]\n\n[Asserts 2]\n\nassert findFrequency([-4, -2, 0, 0, 2, 2, 2, 3, 4], 2) == 3\nassert findFrequency([1, 2, 3, 4, 5], 6) == 0\nassert findFrequency([-5, -3, -1, 0, 0, 0, 1, 2, 4, 4, 6, 8], 0) == 3\nassert findFrequency([-5, -3, -1, 0, 0, 0, 1, 2, 4, 4, 6, 8], -2) == 0\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['matrix', 'XOR', 'bitwise', 'sorting', 'reversed', 'integer', 'diagonal', 'highest', 'set bit']", "prompt_tokens": 694, "total_tokens": 1078, "completion_tokens": 384, "completion": "[Question 2]\n\nYou are given a square matrix of integers representing temperature values in Celsius. Write a function to insert an integer value representing the adjusted temperature in Celsius into the matrix in such a way that the Manhattan distance between the newly inserted value and the nearest value in the diagonal is minimized. The adjusted temperature should be inserted at the position that maximizes the XOR of all the diagonal elements after the insertion.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List, Tuple\n\ndef insertAdjustedTemp(matrix: List[List[int]], temp: int) -> Tuple[int, int]:\n    n = len(matrix)\n    max_xor = 0\n    insert_row, insert_col = 0, 0\n    for i in range(n):\n        if(i == 0):\n            diag_xor = matrix[i][i]\n        elif(i < n):\n            diag_xor ^= matrix[i][i]\n        if(diag_xor > max_xor):\n            max_xor = diag_xor\n            insert_row, insert_col = i, i\n    matrix[insert_row][insert_col] = temp\n    return (insert_row, insert_col)\n\n[/Code 2]\n\n[Asserts 2]\n\nmatrix = [[12, 5, 7], [3, 17, 9], [15, 8, 4]]\ninsertAdjustedTemp(matrix, 20)\nassert(matrix) == [[12, 5, 7], [3, 20, 9], [15, 8, 4]]\n\nmatrix = [[10, 11, 12], [13, 14, 15], [16, 17, 18]]\ninsertAdjustedTemp(matrix, 25)\nassert(matrix) == [[10, 11, 12], [13, 25, 15], [16, 17, 18]]\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'bitwise XOR', 'operations', 'triplet', 'minimum']", "prompt_tokens": 548, "total_tokens": 810, "completion_tokens": 262, "completion": "[Question 2]\n\nGiven an array A of n integers and a value K, the task is to find the minimum number of operations required to make the XOR of any triplet in the array equal to the potential XOR value K. Each operation involves picking a triplet of the form (A[i], A[j], A[k]) where 0 <= i < j < k < n and replacing it with (A[i] ^ A[j] ^ A[k], A[i] ^ A[j] ^ A[k], A[i] ^ A[j] ^ A[k]).\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef minOperationsToGetXOR(arr: List[int], K: int) -> int:\n    n = len(arr)\n    result = 0\n    for i in range(n):\n        result ^= arr[i]\n    \n    return result ^ K\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minOperationsToGetXOR([1, 2, 3], 0) == 0\nassert minOperationsToGetXOR([4, 5, 6, 7], 3) == 3\nassert minOperationsToGetXOR([3, 3, 3, 3], 1) == 2", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['prime', 'nearest', 'array', 'positive integers', 'algorithm', 'search', 'distance', 'calculation', 'math']", "prompt_tokens": 739, "total_tokens": 984, "completion_tokens": 245, "completion": "[Question 2]\n\nYou are given an array representing the positions of shelves along a wall. Write a function to determine the two shelves that are farthest apart. Return the distance between these two shelves.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef farthestShelvesDistance(shelves: List[int]) -> int:\n    max_distance = 0\n    n = len(shelves)\n    for i in range(n):\n        for j in range(i+1, n):\n            distance = abs(shelves[i] - shelves[j])\n            max_distance = max(max_distance, distance)\n    return max_distance\n\n[/Code 2]\n\n[Asserts 2]\n\nassert farthestShelvesDistance([1, 3, 7, 10, 15])==14\nassert farthestShelvesDistance([5, 8, 12, 20, 25, 30])==25\nassert farthestShelvesDistance([2, 4, 6, 8, 10, 12])==10\nassert farthestShelvesDistance([1, 2, 3, 4, 5])==4\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['geometry', 'line', 'intercepts', 'normal', 'origin']", "prompt_tokens": 544, "total_tokens": 767, "completion_tokens": 223, "completion": "[Question 2]\n\nYou are working for CG Corporation and are given a task to find the number of unique sums of intercepts of obstacles on a straight line, considering the obstacles as points in a 2D space. Write a function to calculate the number of unique sums of intercepts on the line.\n\n[/Question 2]\n\n[Code 2]\n\ndef uniqueInterceptSums(obstacles):\n    unique_sums = set()\n    for obstacle in obstacles:\n        for other_obstacle in obstacles:\n            if obstacle != other_obstacle:\n                intercept_sum = obstacle + other_obstacle\n                unique_sums.add(intercept_sum)\n    return len(unique_sums)\n\n[/Code 2]\n\n[Asserts 2]\n\nassert uniqueInterceptSums([2, 3, 4, 5])==12\nassert uniqueInterceptSums([1, 2, 3])==8\nassert uniqueInterceptSums([5, 5, 5, 5])==20\nassert uniqueInterceptSums([1, 3, 5, 8])==26", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['coordinates', 'move', 'reachability', 'destination', 'source', 'integer', 'boolean']", "prompt_tokens": 598, "total_tokens": 973, "completion_tokens": 375, "completion": "[Question 2]\n\nGiven a binary tree, write a program to check if there exists a path from the root to a leaf node where the sum of values along the path equals a given integer target. The nodes in the binary tree are represented by coordinates, and you need to check the reachability of the destination leaf node to meet the given criteria.\n\n[/Question 2]\n\n[Code 2]\n\nclass TreeNode:\n    def __init__(self, value=0, left=None, right=None):\n        self.value = value\n        self.left = left\n        self.right = right\n\ndef hasPathWithGivenSum(root: TreeNode, target: int) -> bool:\n    if root is None:\n        return False\n    if root.left is None and root.right is None and target - root.value == 0:\n        return True\n    return hasPathWithGivenSum(root.left, target - root.value) or hasPathWithGivenSum(root.right, target - root.value)\n\n[/Code 2]\n\n[Asserts 2]\n\n# Constructing the binary tree\n#        1\n#       / \\\n#      2   3\n#     / \\\n#    4   5\nnode1 = TreeNode(1)\nnode2 = TreeNode(2)\nnode3 = TreeNode(3)\nnode4 = TreeNode(4)\nnode5 = TreeNode(5)\nnode1.left = node2\nnode1.right = node3\nnode2.left = node4\nnode2.right = node5\nassert hasPathWithGivenSum(node1, 8) == True\nassert hasPathWithGivenSum(node1, 10) == False\nassert hasPathWithGivenSum(node1, 6) == True\nassert hasPathWithGivenSum(node1, 11) == True\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['bitwise', 'XOR', 'OR', 'count', 'inclusive', 'range']", "prompt_tokens": 413, "total_tokens": 600, "completion_tokens": 187, "completion": "[Question 2]\n\nYou are given a range of integers from L to R (both inclusive). Your task is to determine if there exists a number X in this range such that bitwise OR of X with all numbers in the range results in X itself.\n\n[/Question 2]\n\n[Code 2]\n\ndef isBitwiseORIdentityInRange(L, R):\n    if R > L | ((R-1) >> 1) == (R-1):\n        return \"Yes\"\n    else:\n        return \"No\"\n\n[/Code 2]\n\n[Asserts 2]\n\nassert isBitwiseORIdentityInRange(3, 5)==\"No\"\nassert isBitwiseORIdentityInRange(6, 8)==\"Yes\"\nassert isBitwiseORIdentityInRange(10, 15)==\"No\"\nassert isBitwiseORIdentityInRange(16, 20)==\"Yes\"\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['integer', 'numeric', 'string', 'concatenations', 'divisible', 'count', 'ways']", "prompt_tokens": 602, "total_tokens": 884, "completion_tokens": 282, "completion": "[Question 2]\n\nGiven a singly-linked list of numeric strings, return the count of ways to form an integer, such that it is divisible by a given integer K when the numeric strings are concatenated from bottom to top.\n\n[/Question 2]\n\n[Code 2]\n\nclass ListNode:\n    def __init__(self, value=0, next=None):\n        self.value = value\n        self.next = next\n\ndef countWaysToFormDivisibleInteger(bottom: ListNode, k: int) -> int:\n    num_string = \"\"\n    while bottom:\n        num_string = bottom.value + num_string\n        bottom = bottom.next\n\n    num = int(num_string)\n    if num % k == 0:\n        return 1\n    else:\n        return 0\n\n[/Code 2]\n\n[Asserts 2]\n\n# Create a linked list: 1 -> 2 -> 3\nnode_3 = ListNode(\"3\")\nnode_2 = ListNode(\"2\", node_3)\nnode_1 = ListNode(\"1\", node_2)\n\nassert countWaysToFormDivisibleInteger(node_1, 2) == 1\nassert countWaysToFormDivisibleInteger(node_1, 3) == 1\nassert countWaysToFormDivisibleInteger(node_1, 5) == 0\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['string', 'integer', 'lexicographically', 'smallest', 'operations', 'character', 'replace']", "prompt_tokens": 544, "total_tokens": 822, "completion_tokens": 278, "completion": "[Question 2]\n\nGiven a string S and an integer K, the task is to find the smallest lexicographically string that is K-reachable from the given string S. A string is K-reachable if it can be obtained after exactly K operations. In each operation, a character can be replaced by any other character.\n\n[/Question 2]\n\n[Code 2]\n\ndef kReachableString(s: str, k: int) -> str:\n    s = list(s)\n    for i in range(len(s)):\n        cost = 26 - (ord(s[i]) - ord('a')) if s[i] != 'a' else 0\n        if k >= cost:\n            s[i] = 'a'\n            k -= cost\n    lastChar = ord(s[-1]) - ord('a')\n    lastChar = (lastChar + k) % 26\n    s[-1] = chr(lastChar + ord('a'))\n    return \"\".join(s)\n\n[/Code 2]\n\n[Asserts 2]\n\nassert(kReachableString(\"azbz\", 2))==\"aaa\"\nassert(kReachableString(\"adz\", 5))==\"aaa\"\nassert(kReachableString(\"abcd\", 10))==\"aaaa\"\nassert(kReachableString(\"abcde\", 26))==\"aaaaa\"\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['sorting', 'even', 'odd', 'ascending', 'descending', 'list', 'array']", "prompt_tokens": 619, "total_tokens": 1018, "completion_tokens": 399, "completion": "[Question 2]\n\nYou are given an array of integers. Write a function to sort the array in such a way that all the even numbers appear before the odd numbers, and the even numbers are in ascending order while the odd numbers are in descending order. The solution should be implemented in an optimal manner using a minimal number of variables.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef sortEvenOddAscending(arr: List[int]) -> List[int]:\n\tstart = 0\n\tend = len(arr) - 1\n\t\n\twhile start < end:\n\t\tif arr[start] % 2 != 0 and arr[end] % 2 == 0:\n\t\t\tarr[start], arr[end] = arr[end], arr[start]\n\t\tif arr[start] % 2 == 0:\n\t\t\tstart += 1\n\t\tif arr[end] % 2 != 0:\n\t\t\tend -= 1\n\n\tarr[:start] = sorted(arr[:start])\n\tarr[start:] = sorted(arr[start:], reverse=True)\n\treturn arr\n\n[/Code 2]\n\n[Asserts 2]\n\nassert sortEvenOddAscending([1, 2, 3, 4, 5])==[4, 2, 1, 3, 5]\nassert sortEvenOddAscending([6, 9, 4, 3, 1])==[4, 6, 9, 3, 1]\nassert sortEvenOddAscending([2, 4, 6, 8, 10, 1, 3, 5, 7, 9])==[2, 4, 6, 8, 10, 9, 7, 5, 3, 1]\nassert sortEvenOddAscending([10, 8, 6, 4, 2])==[2, 4, 6, 8, 10]\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['range', 'composite', 'magic number', 'prime', 'sum of digits', 'count', 'sqrt']", "prompt_tokens": 586, "total_tokens": 893, "completion_tokens": 307, "completion": "[Question 2]\n\nGiven a range [L, R], we need to count the total number of composite magic numbers. A composite magic number is a number where the sum of its digits is prime, and it can be represented as an ordered pair (i, j) such that L <= i < j <= R.\n\n[/Question 2]\n\n[Code 2]\n\ndef isprime(n: int) -> bool:\n\tif n <= 1:\n\t\treturn False\n\tfor i in range(2, int(sqrt(n)) + 1):\n\t\tif n % i == 0:\n\t\t\treturn False\n\treturn True\n\ndef checkCompositeMagicNumbers(L: int, R: int) -> int:\n\tcnt = 0\n\tfor i in range(L, R + 1):\n\t\tfor j in range(i + 1, R + 1):\n\t\t\tnum = int(str(i) + str(j))\n\t\t\tsumdig = 0\n\t\t\twhile num > 0:\n\t\t\t\tsumdig += num % 10\n\t\t\t\tnum = num // 10\n\t\t\tif sumdig > 1 and isprime(sumdig):\n\t\t\t\tcnt += 1\n\treturn cnt\n\n[/Code 2]\n\n[Asserts 2]\n\nassert checkCompositeMagicNumbers(1, 5) == 1\nassert checkCompositeMagicNumbers(10, 15) == 1\nassert checkCompositeMagicNumbers(20, 25) == 0\nassert checkCompositeMagicNumbers(50, 55) == 3", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['cube', 'cone', 'inscribed', 'volume', 'math', 'geometry', 'function', 'side length']", "prompt_tokens": 500, "total_tokens": 707, "completion_tokens": 207, "completion": "[Question 2]\n\nYou are given the side length of a cube and an inscribed cone. Write a function to calculate the missing value of the cone's volume if the cube's volume is known.\n\n[/Question 2]\n\n[Code 2]\n\ndef findMissingConeVolume(cubeVolume: float, sideLength: float) -> float:\n    coneVolume = (math.pi * sideLength**3) / 12\n    missingVolume = cubeVolume - coneVolume\n    return missingVolume\n\n[/Code 2]\n\n[Asserts 2]\n\nassert findMissingConeVolume(100, 5) == 117.80972450961724\nassert findMissingConeVolume(200, 8) == 289.9113568640902\nassert findMissingConeVolume(50, 3) == 26.1062315470079\nassert findMissingConeVolume(150, 6) == 184.83935590920464\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['string', 'count', 'consecutive', 'length', 'character', 'integer', 'sequence', 'dynamic programming', 'combinations']", "prompt_tokens": 663, "total_tokens": 931, "completion_tokens": 268, "completion": "[Question 2]\n\nGiven a positive integer N, determine the number of heptadecagonal sequences of length N. A heptadecagonal sequence is a sequence of integers where the absolute difference between any two consecutive elements is a heptadecagonal number.\n\n[/Question 2]\n\n[Code 2]\n\ndef countHeptadecagonalSequences(N: int) -> int:\n    heptadecagonal_numbers = []\n    for i in range(1, N+1):\n        heptadecagonal_numbers.append(i * (5 * i - 3) // 2)\n    \n    dp = [0] * (N+1)\n    dp[0] = 1\n    for length in range(1, N+1):\n        for num in heptadecagonal_numbers:\n            if length - num >= 0:\n                dp[length] += dp[length - num]\n    \n    return dp[N]\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countHeptadecagonalSequences(3) == 1\nassert countHeptadecagonalSequences(4) == 0\nassert countHeptadecagonalSequences(7) == 10\nassert countHeptadecagonalSequences(10) == 412", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['integer', 'binary', 'representation', 'distance', 'set bits', 'comparison', 'boolean']", "prompt_tokens": 556, "total_tokens": 778, "completion_tokens": 222, "completion": "[Question 2]\n\nGiven two strings representing coordinates on a 2D plane, return True if the two points represented by the coordinates are at a Manhattan distance of 3 or less, otherwise return False.\n\n[/Question 2]\n\n[Code 2]\n\ndef isCloseInCoordinatePlane(coord1: str, coord2: str) -> bool:\n    x1, y1 = map(int, coord1.split(\",\"))\n    x2, y2 = map(int, coord2.split(\",\"))\n    return abs(x2 - x1) + abs(y2 - y1) <= 3\n\n[/Code 2]\n\n[Asserts 2]\n\nassert isCloseInCoordinatePlane(\"1,2\", \"1,5\")==True\nassert isCloseInCoordinatePlane(\"0,0\", \"3,0\")==True\nassert isCloseInCoordinatePlane(\"-1,-4\", \"1,1\")==False\nassert isCloseInCoordinatePlane(\"-2,-5\", \"3,3\")==False\nassert isCloseInCoordinatePlane(\"0,0\", \"0,0\")==True", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['guess', 'permutation', 'matches', 'minimum', 'dynamic programming', 'list']", "prompt_tokens": 628, "total_tokens": 1631, "completion_tokens": 1003, "completion": "[Question 2]\n\nWrite a program where the user inputs a list of numbers and then guesses a permutation of the numbers. The program then calculates the number of matches between the guessed permutation and the original list. Using dynamic programming and segment tree, find the minimum number of guesses required to find the original permutation.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\ndef calculateMatches(nums: List[int], guess: List[int]) -> int:\n    matches = 0\n    for i in range(len(nums)):\n        if nums[i] == guess[i]:\n            matches += 1\n    return matches\n\ndef minGuessesWithUserInput(nums: List[int]) -> int:\n    def build_seg_tree(node, start, end):\n        if start == end:\n            seg_tree[node] = nums[start]\n        else:\n            mid = (start + end) // 2\n            build_seg_tree(2 * node, start, mid)\n            build_seg_tree(2 * node + 1, mid + 1, end)\n            seg_tree[node] = min(seg_tree[2 * node], seg_tree[2 * node + 1])\n\n    def query_seg_tree(node, start, end, l, r):\n        if r < start or end < l:\n            return float('inf')\n        if l <= start and end <= r:\n            return seg_tree[node]\n        mid = (start + end) // 2\n        return min(query_seg_tree(2 * node, start, mid, l, r),\n                   query_seg_tree(2 * node + 1, mid + 1, end, l, r))\n\n    N = len(nums)\n    factorial = 1\n    for i in range(1, N + 1):\n        factorial *= i\n\n    seg_tree = [0] * (4 * N)\n    build_seg_tree(1, 0, N - 1)\n\n    dp = [[0 for _ in range(N + 1)] for _ in range(N + 1)]\n    dp[0][0] = 1\n\n    for i in range(1, N + 1):\n        for j in range(1, N + 1):\n            dp[i][j] += dp[i - 1][j] * i\n            if j > 1:\n                dp[i][j] += dp[i - 1][j - 1]\n\n    guess = [i + 1 for i in range(N)]\n    min_guesses = 0\n    while True:\n        matches = calculateMatches(nums, guess)\n        if matches == N:\n            break\n        min_guesses += 1\n        guess_cost = 0\n        for i in range(N):\n            if nums[i] != guess[i]:\n                guess_cost += query_seg_tree(1, 0, N - 1, nums[i] - 1, guess[i] - 1)\n        for j in range(N - 1, -1, -1):\n            if guess[j] != nums[j]:\n                guess_cost += query_seg_tree(1, 0, N - 1, nums[j] - 1, N - 1) - query_seg_tree(1, 0, N - 1, guess[j] - 1, N - 1)\n        if guess_cost >= factorial:\n            min_guesses += 1\n            break\n        for pos in range(N - 1, -1, -1):\n            if guess[pos] != nums[pos]:\n                for toChange in range(guess[pos] + 1, N + 1):\n                    move_cost = query_seg_tree(1, 0, N - 1, guess[pos] - 1, toChange - 1) + query_seg_tree(1, 0, N - 1, nums[pos] - 1, toChange - 1) - query_seg_tree(1, 0, N - 1, nums[pos] - 1, guess[pos] - 1)\n                    if guess_cost - move_cost >= factorial:\n                        guess[pos] = toChange\n                        guess_cost -= move_cost\n                        break\n            if guess[pos] != nums[pos]:\n                break\n    return min_guesses\n\n[/Code 2]\n\n[Asserts 2]\n\nnums = [3, 1, 2, 4]\nassert minGuessesWithUserInput(nums) == 8\n\nnums = [2, 1, 3]\nassert minGuessesWithUserInput(nums) == 3\n\nnums = [1, 2, 3]\nassert minGuessesWithUserInput(nums) == 2\n\nnums = [4, 3, 1, 2]\nassert minGuessesWithUserInput(nums) == 9\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'sum', 'pairs', 'range', 'sorting', 'counting', 'algorithm', 'searching']", "prompt_tokens": 618, "total_tokens": 989, "completion_tokens": 371, "completion": "[Question 2]\n\nGiven an array of angles, your task is to implement a function that filters out pairs of angles which sum up to a specific range.\n\n[/Question 2]\n\n[Code 2]\n\ndef filterAnglePairs(angles, target_range):\n    angles.sort()\n    res = []\n    left = 0\n    right = len(angles) - 1\n    while left < right:\n        if angles[left] + angles[right] < target_range[0]:\n            left += 1\n        elif angles[left] + angles[right] > target_range[1]:\n            right -= 1\n        else:\n            res.append((angles[left], angles[right]))\n            left += 1\n            right -= 1\n    return res\n\n[/Code 2]\n\n[Asserts 2]\n\nassert filterAnglePairs([30, 45, 60, 90, 120, 135, 150, 180], (100, 140)) == [(30, 120), (45, 120)]\nassert filterAnglePairs([15, 20, 25, 30, 35, 40, 45, 50], (50, 60)) == [(15, 40), (25, 35)]\nassert filterAnglePairs([10, 20, 30, 40, 50, 60, 70, 80], (60, 100)) == [(10, 70), (20, 60), (30, 50)]\nassert filterAnglePairs([12, 24, 36, 48, 60, 72, 84, 96], (70, 90)) == [(12, 84), (24, 72), (36, 60)]\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'integers', 'rearrange', 'prefix sum', 'prime numbers', 'sorting', 'math', 'conditional', 'division', 'sorting']", "prompt_tokens": 699, "total_tokens": 1072, "completion_tokens": 373, "completion": "[Question 2]\n\nYou are given an array of integers representing OTP values. The OTPs are generated based on prime numbers and non-prime numbers. Rearrange the array such that OTPs generated from prime numbers appear before those generated from non-prime numbers. Implement a function to rearrange the given array accordingly.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\ndef isPrime(n: int) -> bool:\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef rearrangeOtps(arr: List[int]) -> List[int]:\n    prime_otps = [otp for otp in arr if isPrime(otp)]\n    non_prime_otps = [otp for otp in arr if not isPrime(otp)]\n    return prime_otps + non_prime_otps\n\n[/Code 2]\n\n[Asserts 2]\n\nassert rearrangeOtps([11, 23, 6, 8, 17, 4, 9])==[11, 23, 17, 6, 8, 4, 9]\nassert rearrangeOtps([2, 3, 5, 7, 11, 13, 14, 15, 16, 17])==[2, 3, 5, 7, 11, 13, 17, 14, 15, 16]\nassert rearrangeOtps([4, 6, 8, 9, 22, 25, 27])==[22, 25, 27, 4, 6, 8, 9]\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['random', 'pseudo-random', 'multiplicative congruence', 'seed', 'modulus', 'increment', 'math', 'list']", "prompt_tokens": 579, "total_tokens": 954, "completion_tokens": 375, "completion": "[Question 2]\n\nYou are designing a circular lock system that generates a pseudo-random sequence of floating-point numbers using the Multiplicative Congruence method. The system will start with a given seed and use a multiplier, increment, and modulus. Write a function to generate the pseudo-random sequence based on the provided parameters.\n\n[/Question 2]\n\n[Code 2]\n\ndef generateFloatingPointSequence(seed: float, multiplier: float, increment: float, modulus: float, count: int) -> List[float]:\n    result = []\n    current = seed\n    for _ in range(count):\n        current = (multiplier * current + increment) % modulus\n        result.append(current)\n    return result\n\n[/Code 2]\n\n[Asserts 2]\n\nassert generateFloatingPointSequence(1.5, 10.2, 3.7, 16.5, 5) == [7.25, 12.15, 11.8, 4.3, 4.95]\nassert generateFloatingPointSequence(3.7, 7.9, 6.2, 32.4, 5) == [30.34, 15.16, 24.12, 6.24, 12.4]\nassert generateFloatingPointSequence(2.0, 11.1, 21.6, 100.3, 5) == [22.6, 80.2, 67.6, 71.9, 61.0]\nassert generateFloatingPointSequence(15.3, 4.7, 6.8, 20.5, 5) == [18.65, 13.45, 17.25, 16.0, 10.4]\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'subarray', 'length', 'distinct elements', 'sliding window', 'dictionary']", "prompt_tokens": 617, "total_tokens": 893, "completion_tokens": 276, "completion": "[Question 2]\n\nYou are given a list of dictionary entries containing the names of employees along with their respective lengths of service in years. Write a function to find the percentile of employees who have served for distinct lengths of service within a given range.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import Dict, List\n\ndef percentileOfDistinctLengthsOfService(employees: Dict[str, int], start: int, end: int) -> float:\n    service_lengths = list(employees.values())\n    distinct_lengths = set(service_lengths[start:end+1])\n    num_employees_with_distinct_lengths = 0\n    \n    for length in distinct_lengths:\n        num_employees_with_distinct_lengths += service_lengths.count(length)\n    \n    percentile = (num_employees_with_distinct_lengths / len(service_lengths)) * 100\n    return percentile\n\n[/Code 2]\n\n[Asserts 2]\n\nemployees = {\"Alice\": 3, \"Bob\": 4, \"Charlie\": 3, \"David\": 5, \"Eve\": 4, \"Frank\": 6}\nassert percentileOfDistinctLengthsOfService(employees, 2, 4) == 66.66666666666666\nassert percentileOfDistinctLengthsOfService(employees, 3, 5) == 83.33333333333334", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['graph', 'adjacency list', 'BFS', 'traversal', 'paths']", "prompt_tokens": 619, "total_tokens": 947, "completion_tokens": 328, "completion": "[Question 2]\n\nYou are given an undirected graph represented as an adjacency list and a source node. Write a Python program to find the shortest path from the given source node to every other node in the graph using Breadth-First Search (BFS) traversal. The edge weights are represented as unsigned integers, and the graph may contain cycles.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List, Dict\nfrom collections import deque\n\ndef shortestPath(graph: Dict[int, List[int]], source: int) -> Dict[int, int]:\n    path_lengths = {source: 0}\n    queue = deque([source])\n    while queue:\n        node = queue.popleft()\n        for neighbor in graph[node]:\n            if neighbor not in path_lengths:\n                path_lengths[neighbor] = path_lengths[node] + 1\n                queue.append(neighbor)\n    return path_lengths\n\n[/Code 2]\n\n[Asserts 2]\n\nassert shortestPath({1: [2], 2: [1, 3], 3: [2, 4], 4: [3]}, 1) == {1: 0, 2: 1, 3: 2, 4: 3}\nassert shortestPath({1: [2, 3], 2: [1, 3], 3: [1, 2, 4], 4: [3]}, 1) == {1: 0, 2: 1, 3: 1, 4: 2}\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'split', 'subarray', 'sum', 'check']", "prompt_tokens": 693, "total_tokens": 1063, "completion_tokens": 370, "completion": "[Question 2]\n\nGiven an array of integers, determine if there exists a subarray whose sum is a power of two. If such a subarray exists, return the start and end indices of any one of the possible subarrays. If no such subarray is found, return False.\n\nWrite a function `subarraySumIsPowerOfTwo` which takes in the array of integers as input and returns either the start and end indices of the subarray or False.\n\n[/Question 2]\n\n[Code 2]\n\ndef subarraySumIsPowerOfTwo(arr):\n    prefix_sums = {}\n    prefix_sums[0] = -1\n    current_sum = 0\n    for i, num in enumerate(arr):\n        current_sum += num\n        for j in range(30):\n            target_sum = 2**j\n            complement = current_sum - target_sum\n            if complement in prefix_sums:\n                return [prefix_sums[complement] + 1, i]\n        prefix_sums[current_sum] = i\n    return False\n\n[/Code 2]\n\n[Asserts 2]\n\nassert subarraySumIsPowerOfTwo([1, 3, 4, 2, 2, 5, 7]) == [1, 3]  # Subarray [3, 4, 2]\nassert subarraySumIsPowerOfTwo([1, 2, 3, 2, 4, 8, 1]) == [1, 4]  # Subarray [2, 3, 2, 4]\nassert subarraySumIsPowerOfTwo([3, 6, 9, 12]) == False  # No subarray with sum as power of two\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['arrange', 'word', 'vowels', 'permutation', 'factorial', 'frequency', 'count', 'combination']", "prompt_tokens": 608, "total_tokens": 919, "completion_tokens": 311, "completion": "[Question 2]\n\nYou are given a list of words and you need to find the frequency of occurrence of each word and its mirror image (reversed word) in the list. Return the frequency of each word and its mirror image as a dictionary.\n\n[/Question 2]\n\n[Code 2]\n\ndef wordFrequency(words):\n    result = {}\n    for word in words:\n        if word in result:\n            result[word] += 1\n        else:\n            result[word] = 1\n        reversed_word = word[::-1]\n        if word != reversed_word:\n            if reversed_word in result:\n                result[reversed_word] += 1\n            else:\n                result[reversed_word] = 1\n    return result\n\n[/Code 2]\n\n[Asserts 2]\n\nassert wordFrequency([\"aba\", \"aab\", \"ccc\", \"baa\", \"abc\", \"bca\", \"cba\", \"acb\"]) == {'aba': 2, 'aab': 2, 'ccc': 1, 'baa': 2, 'abc': 2, 'bca': 2, 'cba': 2, 'acb': 2}\nassert wordFrequency([\"hello\", \"world\", \"level\", \"madam\", \"dad\", \"racecar\"]) == {'hello': 1, 'world': 1, 'level': 1, 'madam': 2, 'dad': 2, 'racecar': 1}\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['graph', 'vertices', 'edges', 'triangle', 'adjacency matrix', 'minimum', 'added']", "prompt_tokens": 765, "total_tokens": 1318, "completion_tokens": 553, "completion": "[Question 2]\n\nYou are given a stream of pseudo-random numbers generated by a pseudo-random number generator. Design an algorithm to determine the minimum number of additional edges that need to be added to the graph with under_20 vertices and existing edges, such that it is possible to form a triangle in the graph.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List, Tuple\nimport random\n\ndef minEdgesToAddForTriangle(stream: List[int], edges: List[Tuple[int, int]]) -> int:\n    N = 20\n    adj_matrix = [[0] * N for _ in range(N)]\n    for edge in edges:\n        adj_matrix[edge[0] - 1][edge[1] - 1] = 1\n        adj_matrix[edge[1] - 1][edge[0] - 1] = 1\n\n    triangles_possible = []\n\n    for new_vertex in stream:\n        for i in range(N):\n            if adj_matrix[i][new_vertex - 1] == 1:\n                for j in range(i + 1, N):\n                    if adj_matrix[j][new_vertex - 1] == 1:\n                        if adj_matrix[i][j] == 1:\n                            triangles_possible.append((i, j, new_vertex - 1))\n\n        for i, j, k in triangles_possible:\n            if adj_matrix[i][k] == 0 or adj_matrix[j][k] == 0:\n                adj_matrix[i][k] = 1\n                adj_matrix[k][i] = 1\n                adj_matrix[j][k] = 1\n                adj_matrix[k][j] = 1\n                return 1\n\n    return 0\n\n[/Code 2]\n\n[Asserts 2]\n\nstream = [random.randint(1, 20) for _ in range(100)]\nedges = [(1, 2), (2, 3), (3, 4), (2, 4), (4, 5)]\nassert minEdgesToAddForTriangle(stream, edges) == 0\n\nstream = [random.randint(1, 20) for _ in range(100)]\nedges = [(1, 2), (2, 3), (3, 4), (4, 1), (1, 3)]\nassert minEdgesToAddForTriangle(stream, edges) == 1\n\nstream = [random.randint(1, 20) for _ in range(100)]\nedges = [(1, 2), (1, 3), (2, 3)]\nassert minEdgesToAddForTriangle(stream, edges) == 0\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['integer', 'binary', 'strings', 'backtracking', 'recursion', 'length']", "prompt_tokens": 588, "total_tokens": 882, "completion_tokens": 294, "completion": "[Question 2]\n\nGiven a list of binary strings, write a recursive function that takes the list as input and finds the total number of ways to overwrite the preceding character in each string with a 1, such that the resulting strings are unique.\n\n[/Question 2]\n\n[Code 2]\n\ndef totalWaysToOverwrite(strings: List[str]) -> int:\n    seen = set()\n    \n    def backtrack(s):\n        if s in seen:\n            return 0\n        seen.add(s)\n        count = 1  # count 1 for the current string\n        for i in range(len(s)):\n            if s[i] == '0':\n                new_s = s[:i] + '1' + s[i+1:]\n                count += backtrack(new_s)\n        return count\n    \n    total = 0\n    for string in strings:\n        total += backtrack(string)\n    \n    return total\n\n[/Code 2]\n\n[Asserts 2]\n\nassert totalWaysToOverwrite([\"100\", \"011\", \"101\"]) == 5\nassert totalWaysToOverwrite([\"010\", \"001\", \"110\"]) == 7\nassert totalWaysToOverwrite([\"111\", \"000\"]) == 1\nassert totalWaysToOverwrite([\"10\", \"01\"]) == 3\nassert totalWaysToOverwrite([\"1\", \"0\"]) == 2\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'queries', 'update', 'factorial', 'sum', 'modulus', 'efficiency', 'math']", "prompt_tokens": 895, "total_tokens": 1628, "completion_tokens": 733, "completion": "[Question 2]\n\nGiven an array of N integers, write a program to efficiently process Q queries of two types:\n1. Update a specific element at index L with a new value X.\n2. Find the sum of factorial of all elements in the array which are digits and occur an odd number of times. Also, the sum should be calculated modulo P, where P is a prime number. \n\nDesign an efficient solution such that the time complexity is O(Q + NlogN), where Q is the number of queries and N is the size of the array.\n\n[/Question 2]\n\n[Code 2]\n\nimport math\n\ndef factorial(val):\n    if val == 0 or val == 1:\n        return 1\n    fact = 1\n    for i in range(1, val + 1):\n        fact *= i\n    return fact\n\ndef sumDigitFactorialOddOccurances(arr, queries, mod_p):\n    result = []\n    occurances = {}\n    for val in arr:\n        if str(val).isdigit():\n            if val in occurances:\n                occurances[val] += 1\n            else:\n                occurances[val] = 1\n  \n    odd_digits = [key for key, value in occurances.items() if value % 2 != 0]\n    sum_factorial = sum([factorial(val) for val in odd_digits])\n\n    for query in queries:\n        if query[0] == 'update':\n            idx = query[1]\n            new_val = query[2]\n            if str(arr[idx]).isdigit():\n                occurances[arr[idx]] -= 1\n                arr[idx] = new_val\n                if new_val in occurances:\n                    occurances[new_val] += 1\n                else:\n                    occurances[new_val] = 1\n            else:\n                arr[idx] = new_val\n        elif query[0] == 'sum':\n            result.append(sum_factorial % mod_p)\n    return result\n\n[/Code 2]\n\n[Asserts 2]\n\nassert sumDigitFactorialOddOccurances([1, 22, 333, 4444, 55555], [('sum',), ('update', 2, 3), ('sum',)], 1000000007) == [5890, 5890]\nassert sumDigitFactorialOddOccurances([8, 9, 10, 11, 8, 10], [('update', 0, 12), ('sum',), ('update', 3, 5), ('sum',)], 1000000007) == [162, 162]\nassert sumDigitFactorialOddOccurances([123, 456, 789, 111, 222, 333], [('sum',), ('update', 5, 444), ('sum',)], 1000000007) == [145, 145]\nassert sumDigitFactorialOddOccurances([12, 34, 56, 78, 9, 9, 34, 56, 78, 12], [('update', 4, 67), ('sum',), ('update', 8, 23), ('sum',)], 1000000007) == [126, 126]\nassert sumDigitFactorialOddOccurances([7, 5, 8, 3, 2, 4], [('sum',), ('update', 1, 11), ('sum',)], 1000000007) == [31, 31]\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['string', 'manipulation', 'indexing', 'slice']", "prompt_tokens": 410, "total_tokens": 602, "completion_tokens": 192, "completion": "[Question 2]\n\nWrite a Python function that takes a matrix as input and returns the slice of the matrix representing the East-West direction at a specific row index.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\ndef eastWestSlice(matrix: List[List[int]], rowIndex: int) -> List[int]:\n    return matrix[rowIndex]\n\n[/Code 2]\n\n[Asserts 2]\n\nmatrix = [\n    [1, 2, 3, 4],\n    [5, 6, 7, 8],\n    [9, 10, 11, 12]\n]\n\nassert eastWestSlice(matrix, 0) == [1, 2, 3, 4]\nassert eastWestSlice(matrix, 1) == [5, 6, 7, 8]\nassert eastWestSlice(matrix, 2) == [9, 10, 11, 12]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'largest interval', 'range', 'minimum', 'maximum']", "prompt_tokens": 523, "total_tokens": 781, "completion_tokens": 258, "completion": "[Question 2]\n\nYou are given an array of strings. Write a function to sort the array based on the length of the strings in ascending order. If two strings have the same length, then sort them in lexicographically increasing order.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef sortArrayByLength(arr: List[str]) -> List[str]:\n    return sorted(arr, key=lambda x: (len(x), x))\n\n[/Code 2]\n\n[Asserts 2]\n\nassert sortArrayByLength([\"apple\", \"banana\", \"kiwi\", \"orange\", \"pear\"]) == ['kiwi', 'pear', 'apple', 'banana', 'orange']\nassert sortArrayByLength([\"dog\", \"cat\", \"lion\", \"elephant\", \"ant\"]) == ['dog', 'cat', 'ant', 'lion', 'elephant']\nassert sortArrayByLength([\"a\", \"to\", \"the\", \"on\", \"in\"]) == ['a', 'on', 'in', 'to', 'the']\nassert sortArrayByLength([\"hello\", \"world\", \"python\", \"is\", \"awesome\"]) == ['is', 'hello', 'world', 'python', 'awesome']\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['insertion sort', 'array', 'sorting', 'ascending', 'descending', 'even', 'odd', 'positioned', 'algorithm']", "prompt_tokens": 792, "total_tokens": 1266, "completion_tokens": 474, "completion": "[Question 2]\n\nYou are given an array of integers representing the amount of water at each positioned location. Implement an algorithm to sort the array in such a way that the odd positioned elements are in ascending order, and the even positioned elements are in descending order. Return the sorted array.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\ndef sortOddEvenPositioned(arr: List[int]) -> List[int]:\n    n = len(arr)\n    for i in range(1, n):\n        if i % 2 != 0:  # odd positioned elements\n            key = arr[i]\n            j = i - 1\n            while j >= 0 and arr[j] > key:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key\n        else:  # even positioned elements\n            key = arr[i]\n            j = i - 1\n            while j >= 0 and arr[j] < key:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key\n    return arr\n\n[/Code 2]\n\n[Asserts 2]\n\nassert sortOddEvenPositioned([9, 10, 7, 18, 19, 5, 8, 10])==[5, 10, 7, 10, 9, 18, 19, 8]\nassert sortOddEvenPositioned([20, 21, 15, 30, 35, 40, 22, 25])==[15, 40, 20, 35, 21, 30, 22, 25]\nassert sortOddEvenPositioned([10, 21, 35, 45, 18, 22, 39, 50])==[10, 50, 18, 39, 21, 45, 22, 35]\nassert sortOddEvenPositioned([5, 10, 15, 20, 25, 30, 35, 40])==[5, 40, 10, 35, 15, 30, 20, 25]\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['numeric string', 'combinations', 'DFS', 'recursion', 'backtracking', 'constraint', 'constraint satisfaction', 'search']", "prompt_tokens": 582, "total_tokens": 986, "completion_tokens": 404, "completion": "[Question 2]\n\nYou are given a forest of trees represented as a list of numeric strings, and a destination node. Each node in the forest is numbered from 0 to n-1. The task is to find all possible paths from the root to the destination node considering the given constraints. Write a function to solve the given problem using backtracking and recursion.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef find_paths_forest(forest: List[str], destination: int) -> List[List[int]]:\n    paths = []\n    \n    def dfs(node, path):\n        if node == destination:\n            paths.append(path)\n            return\n        if node < 0 or node >= len(forest) or forest[node] == '-1':\n            return\n        \n        forest[node] = '-1'  # mark as visited\n        for i in range(len(forest[node])):\n            if forest[node][i] == '1' and i != node:  # connected node\n                dfs(i, path + [i])\n        \n        forest[node] = str(node)  # reset\n        \n    for i in range(len(forest)):\n        if i != destination and forest[i] != '-1':\n            dfs(i, [i])\n    \n    return paths\n\n[/Code 2]\n\n[Asserts 2]\n\nassert find_paths_forest([\"101\", \"010\", \"101\"], 2)==[[0, 2]]\nassert find_paths_forest([\"1010\", \"0101\", \"1010\", \"0101\"], 3)==[[0, 2, 1, 3], [1, 2, 0, 3]]\nassert find_paths_forest([\"1010\", \"0101\", \"1010\", \"0101\"], 1)==[[0, 2, 1], [1]]\nassert find_paths_forest([\"10\", \"01\"], 1)==[[0, 1]]\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['bit manipulation', 'binary representation', 'toggle', 'maximize', 'integer array', 'bitwise operations', 'counting']", "prompt_tokens": 618, "total_tokens": 921, "completion_tokens": 303, "completion": "[Question 2]\n\nYou are given an array of integers arr. You need to toggle a single bit in each integer such that the maximum number of integers have a common bit turned on. Determine the bit position to toggle in order to maximize the count of integers with a common bit turned on.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef maximizeCommonBit(arr: List[int]) -> int:\n        zeroCount = [0] * 32\n        oneCount = [0] * 32\n        for num in arr:\n            for bit in range(32):\n                if (num & (1 << bit)) == 0:\n                    zeroCount[bit] += 1\n                else:\n                    oneCount[bit] += 1\n        \n        ans = 0\n        for i in range(32):\n            if zeroCount[i] < oneCount[i]:\n                ans |= (1 << i)\n\n        return ans\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maximizeCommonBit([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])==1\nassert maximizeCommonBit([5, 10, 15, 20])==0\nassert maximizeCommonBit([3, 3, 3, 3])==0\nassert maximizeCommonBit([1, 3, 5, 7])==0\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['string', 'jumble', 'character', 'frequency', 'comparison', 'boolean', 'existence']", "prompt_tokens": 582, "total_tokens": 891, "completion_tokens": 309, "completion": "[Question 2]\n\nYou are given a list of strings and an integer K. Write a function to find whether it is possible to form a string by taking one character from each string such that the bitwise OR of the frequencies of all the characters at distinct indices is completely filled (i.e., all 1s). Return True if it is possible, otherwise return False.\n\n[/Question 2]\n\n[Code 2]\n\ndef canFormCompletelyFilledString(strings: List[str], K: int) -> bool:\n    n = len(strings)\n    for i in range(K):\n        freq = 0\n        for j in range(n):\n            if len(strings[j]) <= i:\n                continue\n            char_ind = ord(strings[j][i]) - ord('a')\n            freq |= (1 << char_ind)\n        if freq != (1 << 26) - 1:\n            return False\n    return True\n\n[/Code 2]\n\n[Asserts 2]\n\nassert canFormCompletelyFilledString([\"abc\", \"def\", \"ghi\"], 3)==True\nassert canFormCompletelyFilledString([\"hello\", \"world\", \"python\"], 5)==False\nassert canFormCompletelyFilledString([\"abcd\", \"efgh\", \"ijkl\"], 4)==False\nassert canFormCompletelyFilledString([\"abc\", \"xy\", \"z\"], 2)==True\nassert canFormCompletelyFilledString([\"abcd\", \"efgh\"], 4)==False\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['string', 'sort', 'lexicographically', 'cyclic shift', 'offset', 'wrap', 'repeat']", "prompt_tokens": 486, "total_tokens": 736, "completion_tokens": 250, "completion": "[Question 2]\n\nWrite a function to sort a list of strings lexicographically in a bottom-up manner. In this sorting order, the strings are sorted based on their last character first, then their second-to-last character, and so on, wrapping around if the string is shorter than the others. Additionally, if two strings have the same character at a particular position, the one occurring earlier in the list should appear earlier in the sorted list.\n\n[/Question 2]\n\n[Code 2]\n\ndef sortBottomUp(strings: List[str]) -> List[str]:\n    max_len = max(map(len, strings))\n    strings = [s.ljust(max_len, \"z\") for s in strings]\n    strings.sort(reverse=True)\n    return [s.rstrip(\"z\") for s in strings]\n\n[/Code 2]\n\n[Asserts 2]\n\nassert sortBottomUp([\"abc\", \"bca\", \"cab\"]) == [\"cab\", \"bca\", \"abc\"]\nassert sortBottomUp([\"cba\", \"aaa\", \"bca\"]) == [\"aaa\", \"bca\", \"cba\"]\nassert sortBottomUp([\"x\", \"yz\", \"z\"]) == [\"z\", \"x\", \"yz\"]\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'subsets', 'absolute-difference', 'minimum', 'sum']", "prompt_tokens": 583, "total_tokens": 896, "completion_tokens": 313, "completion": "[Question 2]\n\nYou are given an array of integers and a target sum. Find the minimum absolute difference between the target sum and any subset sum of the given array.\n\nWrite a function to calculate the minimum absolute difference.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef minAbsDifferenceSubsetSum(arr: List[int], target: int) -> int:\n    n = len(arr)\n\n    dp = [False for _ in range(target + 1)]\n    dp[0] = True\n\n    total_sum = sum(arr)\n\n    for num in arr:\n        for j in range(target, num - 1, -1):\n            dp[j] = dp[j] or dp[j - num]\n\n    best = 0\n    for i in range(target + 1):\n        if dp[i]:\n            best = i\n\n    return abs(target - 2*best)\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minAbsDifferenceSubsetSum([1, 2, 3, 9], 12) == 3\nassert minAbsDifferenceSubsetSum([1, 2, 7], 10) == 0\nassert minAbsDifferenceSubsetSum([5, 6, 7, 8], 15) == 0\nassert minAbsDifferenceSubsetSum([1, 2, 3, 4, 5, 6, 7, 8, 9], 20) == 1\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'pairs', 'sum', 'hash table', 'count']", "prompt_tokens": 634, "total_tokens": 905, "completion_tokens": 271, "completion": "[Question 2]\n\nGiven an array of integers, the task is to find the count of unbounded clusters of integers in the array. A cluster is defined as a group of integers such that the sum of any pair of integers in the cluster results in another integer present in the cluster.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef countUnboundedClusters(arr: List[int]) -> int:\n    count = 0\n    hash_table = {}\n    for num in arr:\n        hash_table[num] = True\n        \n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            if arr[i] + arr[j] in hash_table:\n                count += 1\n    \n    return count\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countUnboundedClusters([1, 2, 3, 4, 5, 6, 7, 8, 9])==28\nassert countUnboundedClusters([5, 10, 20, 30, 40])==0\nassert countUnboundedClusters([1, 2, 4, 8, 16])==10\nassert countUnboundedClusters([3, 7, 12, 25, 50])==1\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['integer', 'divisible', 'swaps', 'minimum', 'math', 'iteration', 'conditional']", "prompt_tokens": 576, "total_tokens": 959, "completion_tokens": 383, "completion": "[Question 2]\n\nGiven an array of integers, write a function to determine the minimum number of swaps required to make the array such that it contains at least one element that is divisible by 3.\n\n[/Question 2]\n\n[Code 2]\n\ndef minSwapsForDivisible(arr):\n    count = 0\n    found_divisible = False\n    for i in range(len(arr)):\n        if arr[i] % 3 == 0:\n            found_divisible = True\n            break\n    if not found_divisible:\n        return -1\n        \n    left, right = 0, len(arr) - 1\n    while left < right:\n        if arr[left] % 3 != 0 and arr[right] % 3 == 0:\n            arr[left], arr[right] = arr[right], arr[left]\n            count += 1\n            left += 1\n            right -= 1\n        elif arr[left] % 3 == 0:\n            left += 1\n        elif arr[right] % 3 != 0:\n            right -= 1\n    return count\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minSwapsForDivisible([1, 2, 3, 4, 5, 6]) == 1\nassert minSwapsForDivisible([7, 8, 9, 10, 11, 12]) == 1\nassert minSwapsForDivisible([4, 5, 8, 11, 14]) == -1\nassert minSwapsForDivisible([3, 6, 9, 12, 15]) == 0\nassert minSwapsForDivisible([18, 21, 24, 27, 30]) == 0\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'sequence', 'change', 'minimum', 'mathematical', 'iteration', 'comparison']", "prompt_tokens": 771, "total_tokens": 1259, "completion_tokens": 488, "completion": "[Question 2]\n\nGiven two arrays A and B of the same length N, both representing vectors. The task is to find the minimum number of elements to be changed in array A, such that the angle (in degrees) between the two vectors A and B is minimized.\n\nWrite a function ```minChangesForMinAngle``` to find and return the minimum number of elements to be changed.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\nimport math\n\ndef minChangesForMinAngle(A: List[float], B: List[float]) -> int:\n    n = len(A)\n    dot_product = 0\n    mod_a = 0\n    mod_b = 0\n    for i in range(n):\n        dot_product += A[i] * B[i]\n        mod_a += A[i] ** 2\n        mod_b += B[i] ** 2\n    mod_a = math.sqrt(mod_a)\n    mod_b = math.sqrt(mod_b)\n    cos_angle = dot_product / (mod_a * mod_b)\n    angle_in_degrees = math.degrees(math.acos(cos_angle))\n    if angle_in_degrees > 90:\n        return sum(1 for i in range(n) if A[i] == 1)\n    else:\n        return sum(1 for i in range(n) if A[i] == 0)\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minChangesForMinAngle([1, 0, 1, 0, 1], [1, 1, 1, 0, 0]) == 2\nassert minChangesForMinAngle([0, 1, 0, 1, 0], [1, 0, 1, 0, 1]) == 0\nassert minChangesForMinAngle([0.5, 0.5, 0.5, 0.5], [0, 1, 0, 1]) == 2\nassert minChangesForMinAngle([0, 0, 0, 0], [1, 1, 1, 1]) == 4\nassert minChangesForMinAngle([1, 0, -1, 0], [0, 1, 0, -1]) == 0\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['string', 'removal', 'indexing', 'split', 'join']", "prompt_tokens": 497, "total_tokens": 674, "completion_tokens": 177, "completion": "[Question 2]\n\nWrite a function to split a given string based on a delimiter and remove any empty strings in the resulting list. \n\n[/Question 2]\n\n[Code 2]\n\ndef splitAndRemoveEmpty(input_string: str, delimiter: str) -> List[str]:\n    parts = input_string.split(delimiter)\n    result = list(filter(lambda x: x != '', parts))\n    return result\n\n[/Code 2]\n\n[Asserts 2]\n\nassert splitAndRemoveEmpty(\"apple,banana,,orange,\", \",\") == [\"apple\", \"banana\", \"orange\"]\nassert splitAndRemoveEmpty(\"hello there how are you\", \" \") == [\"hello\", \"there\", \"how\", \"are\", \"you\"]\nassert splitAndRemoveEmpty(\"111222333444555\", \"4\") == [\"111222333\", \"555\"]\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['string', 'subsequence', 'consecutive', 'English', 'alphabet']", "prompt_tokens": 600, "total_tokens": 897, "completion_tokens": 297, "completion": "[Question 2]\n\nYou are given a list of strings where each string represents the positions of queens on a chessboard. The task is to find the minimum weight of the strings based on the weight of an individual string. The weight of a string is defined as the number of consecutive English alphabets (substring) present in it. For example, in the string \"abcde56fgh\", the weight would be 2 as there are two consecutive English alphabets substrings \"abcde\" and \"fgh\".\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\ndef minWeightOfStrings(strings: List[str]) -> int:\n    weights = []\n    for s in strings:\n        weight = 0\n        i = 0\n        while i < len(s):\n            if s[i].isalpha():\n                j = i\n                while j < len(s) and s[j].isalpha():\n                    j += 1\n                weight = max(weight, j - i)\n                i = j\n            else:\n                i += 1\n        weights.append(weight)\n    return min(weights)\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minWeightOfStrings([\"abcde56fgh\", \"xypqrstuv\"]) == 5\nassert minWeightOfStrings([\"abcd\", \"xy\"]) == 4\nassert minWeightOfStrings([\"abcd\", \"xy\", \"12345\"]) == 4", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'triplets', 'XOR', 'elements', 'comparison', 'count']", "prompt_tokens": 621, "total_tokens": 936, "completion_tokens": 315, "completion": "[Question 2]\n\nYou are given an array of rods of different lengths. Write a function to count the number of triplets of rods which can be nested to form a zero XOR. A triplet (a, b, c) can be nested if (a ^ b ^ c) == 0, where ^ represents the XOR operation.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef countZeroXorTriplets(rods: List[int]) -> int:\n    count = 0\n    n = len(rods)\n    for i in range(n):\n        for j in range(i+1, n):\n            for k in range(j+1, n):\n                if (rods[i] ^ rods[j] ^ rods[k]) == 0:\n                    count += 1\n    return count\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countZeroXorTriplets([3, 5, 6, 9, 2]) == 1\nassert countZeroXorTriplets([4, 2, 2, 6, 4]) == 3\nassert countZeroXorTriplets([7, 3, 3, 7]) == 4\nassert countZeroXorTriplets([1, 2, 3, 4, 5]) == 0\nassert countZeroXorTriplets([1, 2, 3, 0, 3]) == 2\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['pyramid', 'consecutive', 'numbers', 'increasing', 'decreasing', 'list', 'functional programming']", "prompt_tokens": 516, "total_tokens": 682, "completion_tokens": 166, "completion": "[Question 2]\n\nYou are given a list of integers. Write a functional programming code to create a new list such that it contains the consecutive numbers from the original list, and then the same numbers in decreasing order.\n\n[/Question 2]\n\n[Code 2]\n\ndef consecutiveDecreasing(nums):\n    return nums + list(reversed(nums[:-1]))\n\n[/Code 2]\n\n[Asserts 2]\n\nassert consecutiveDecreasing([1, 2, 3])==[1, 2, 3, 2, 1]\nassert consecutiveDecreasing([4, 5, 6, 7])==[4, 5, 6, 7, 6, 5, 4]\nassert consecutiveDecreasing([10, 11])==[10, 11, 10]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['string', 'parentheses', 'integer', 'nested', 'sum', 'stack', 'digits']", "prompt_tokens": 602, "total_tokens": 931, "completion_tokens": 329, "completion": "[Question 2]\n\nGiven a string containing color codes in the format \"#RRGGBB\" and a positive integer n, write a function to calculate the sum of the decimal representations of the red component of the nth nested color code.\n\n[/Question 2]\n\n[Code 2]\n\ndef sumRedComponent(s: str, n: int) -> int:\n    stack = []\n    cur = \"\"\n    for i in range(len(s)):\n        if s[i] == \"#\":\n            stack.append(cur)\n            cur = \"\"\n        elif cur != \"\":\n            cur += s[i]\n        elif s[i] == \"(\":\n            stack.append(s[i])\n        elif s[i] == \")\":\n            component = stack.pop()\n            if len(stack) == n-1:\n                red = int(component[1:3], 16)\n                return red + sumRedComponent(s[i+1:], n)\n    return 0\n\n[/Code 2]\n\n[Asserts 2]\n\nassert sumRedComponent(\"#FF0000#00FF00#0000FF\", 1)==255\nassert sumRedComponent(\"#FF0000(#00FF00#AA0000)##0000FF\", 2)==170\nassert sumRedComponent(\"#FF0000(#00FF00#AA0000)##0000FF\", 1)==255\nassert sumRedComponent(\"#FF0000(#00FF00#AA0000)##0000FF\", 3)==0\nassert sumRedComponent(\"#FF0000#00FF00#0000FF\", 2)==0\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'removal', 'pair', 'absolute difference', 'iteration', 'loop', 'algorithm']", "prompt_tokens": 633, "total_tokens": 976, "completion_tokens": 343, "completion": "[Question 2]\n\nYou are given an array containing heights of water, representing a terrain. You need to implement an algorithm to find the special pair of elements with the maximum absolute difference between their heights, and remove them from the array.\n\n[/Question 2]\n\n[Code 2]\n\ndef findAndRemoveSpecialPair(arr):\n    max_diff = -1\n    special_pair = None\n    n = len(arr)\n    for i in range(n):\n        for j in range(i+1, n):\n            if abs(arr[i]-arr[j]) > max_diff:\n                max_diff = abs(arr[i]-arr[j])\n                special_pair = (i, j)\n    \n    if special_pair:\n        i, j = special_pair\n        del arr[i]\n        del arr[j-1]\n    \n    return arr\n\n[/Code 2]\n\n[Asserts 2]\n\nassert findAndRemoveSpecialPair([1, 3, 5, 2, 4, 6]) == [1, 3, 2, 4, 6]\nassert findAndRemoveSpecialPair([7, 3, 5, 8, 4, 10, 6, 2]) == [7, 3, 5, 4, 6, 2]\nassert findAndRemoveSpecialPair([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]) == [3, 1, 4, 1, 5, 2, 6, 5, 3, 5]\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['exponentiation', 'modulus', 'bitwise', 'math']", "prompt_tokens": 494, "total_tokens": 720, "completion_tokens": 226, "completion": "[Question 2]\n\nYou are working on a project that involves handling and validating strings representing standing positions using regex. Write a function to validate whether a given string represents a valid standing position based on the following criteria:\n- The string should consist of at least 1 digit.\n- The string should only contain digits and an optional positive or negative sign at the beginning.\n- No leading zeroes are allowed unless the string is \"0\".\n\n[/Question 2]\n\n[Code 2]\n\nimport re\n\ndef validatePosition(position: str) -> bool:\n    pattern = r'^[-+]?[1-9]\\d*|0$' # regex pattern to match the standing position\n    return bool(re.match(pattern, position))\n\n[/Code 2]\n\n[Asserts 2]\n\nassert validatePosition(\"0\") == True\nassert validatePosition(\"9\") == True\nassert validatePosition(\"-42\") == True\nassert validatePosition(\"+123\") == True\nassert validatePosition(\"005\") == False\nassert validatePosition(\"-0\") == False\nassert validatePosition(\"abc\") == False\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'subset', 'sum', 'cubes', 'math', 'combinatorics']", "prompt_tokens": 485, "total_tokens": 735, "completion_tokens": 250, "completion": "[Question 2]\n\nYou are given an array arr[] of N integers. Determine if it is impossible to form a subset of the array such that the sum of the cubes of its elements is a perfect cube.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\nimport math\ndef isImpossibleToFormPerfectCubeSubset(arr: List[int], N: int) -> bool:\n    for i in range(1, (1 << N)):\n        subsetSum = 0\n        for j in range(N):\n            if i & (1 << j):\n                subsetSum += arr[j] ** 3\n        cubeRoot = round(subsetSum ** (1/3))\n        if cubeRoot ** 3 == subsetSum:\n            return False\n    return True\n\n[/Code 2]\n\n[Asserts 2]\n\nassert isImpossibleToFormPerfectCubeSubset([1, 2, 3], 3) == False\nassert isImpossibleToFormPerfectCubeSubset([3, 4, 5, 6], 4) == True\nassert isImpossibleToFormPerfectCubeSubset([3, 6, 9], 3) == False\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'integer', 'arrange', 'pendulum', 'in-place', 'sort', 'constant space', 'sorting']", "prompt_tokens": 682, "total_tokens": 996, "completion_tokens": 314, "completion": "[Question 2]\n\nYou are given an array of 7-character strings representing bookings. Each string consists of an integer (representing the booking entry number) followed by a hyphen and a 6-character alphanumeric code. The task is to arrange the bookings in such a way that the entries with the same integer are grouped together and then sorted alphabetically within each group. This operation needs to be performed in-place, using constant space.\n\n[/Question 2]\n\n[Code 2]\n\ndef arrangeBookings(bookings: List[str]) -> None:\n    bookings.sort(key=lambda x: (x[:1], x[2:]))\n    \n[/Code 2]\n\n[Asserts 2]\n\nbookings = ['1234567-abcxyz', '2345678-defabc', '1234566-hijklm', '3456789-mnopqr']\narrangeBookings(bookings)\nassert bookings == ['1234566-hijklm', '1234567-abcxyz', '2345678-defabc', '3456789-mnopqr']\n\nbookings = ['1111111-abcdef', '2222222-bcdefa', '1111112-cdefab', '3333333-defabc', '1111113-efabcd']\narrangeBookings(bookings)\nassert bookings == ['1111111-abcdef', '1111112-cdefab', '1111113-efabcd', '2222222-bcdefa', '3333333-defabc']\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['binary', 'string', 'flipping', 'contiguous', 'set', 'decimal', 'value']", "prompt_tokens": 544, "total_tokens": 931, "completion_tokens": 387, "completion": "[Question 2]\n\nYou are given a binary string and a set of conditions. The goal is to manipulate the binary string by flipping a contiguous set of bits to minimize the binary rates based on the conditions. After manipulation, return the decimal value of the resulting binary string.\n\n[/Question 2]\n\n[Code 2]\n\ndef minManipulatedDecimal(binaryStr: str, conditions: List[bool]) -> int:\n    if all(conditions):  # If all conditions are True, return the decimal value as is\n        return int(binaryStr, 2)\n    \n    # Otherwise, find the leftmost and rightmost indices where conditions are False\n    left, right = 0, len(binaryStr) - 1\n    while left < len(binaryStr) and conditions[left]:\n        left += 1\n    while right >= 0 and conditions[right]:\n        right -= 1\n    \n    flippedBinaryStr = list(binaryStr)\n    for i in range(left, right+1):\n        flippedBinaryStr[i] = '1' if binaryStr[i] == '0' else '0'  # Flip the bits within the range\n    \n    return int(''.join(flippedBinaryStr), 2)  # Return the decimal value of the manipulated binary string\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minManipulatedDecimal(\"110111011\", [True, False, False, True, True, True, False, True, False]) == 25\nassert minManipulatedDecimal(\"1111\", [True, True, True, True]) == 15\nassert minManipulatedDecimal(\"000110011\", [False, False, True, True, True, True, False, False, False]) == 51\nassert minManipulatedDecimal(\"0000\", [False, False, False, False]) == 1\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'subarray', 'contiguous', 'distinct', 'integers', 'length', 'maximum', 'minimum', 'containing', 'consecutive']", "prompt_tokens": 671, "total_tokens": 1005, "completion_tokens": 334, "completion": "[Question 2]\n\nGiven an array of distinct integers, the task is to find the length of the smallest subarray with a contiguous sequence of consecutive integers. The array should contain distinct integers, and the subarray's length should be the floor value of the maximum number of consecutive integers. Implement the solution using pointers in linear time.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef minContiguousSubarrayLength(arr: List[int]) -> int:\n    arr_set = set(arr)\n    max_len = 0\n    for num in arr:\n        if num - 1 not in arr_set:\n            current = num\n            while current in arr_set:\n                current += 1\n            max_len = max(max_len, current - num)\n    return max_len\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minContiguousSubarrayLength([8, 1, 9, 3, 10, 4, 5, 6, 7]) == 5\nassert minContiguousSubarrayLength([3, 2, 4, 10, 5, 6]) == 4\nassert minContiguousSubarrayLength([1, 2, 3, 5, 6, 7, 8, 11, 12, 13]) == 5\nassert minContiguousSubarrayLength([10, 11, 12]) == 3\nassert minContiguousSubarrayLength([5, 7, 8, 10, 12]) == 1\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['string', 'count', 'occurrences', 'array', 'integer', 'character', 'position', 'index']", "prompt_tokens": 593, "total_tokens": 857, "completion_tokens": 264, "completion": "[Question 2]\n\nGiven an array of integers, find the next greater number for each element. Return an array where each element represents the next greater number in the input array. If no greater number exists, append -1.\n\n[/Question 2]\n\n[Code 2]\n\ndef nextGreaterElement(nums: List[int]) -> List[int]:\n    stack = []\n    result = [-1] * len(nums)\n    for i in range(len(nums)):\n        while stack and nums[i] > nums[stack[-1]]:\n            result[stack.pop()] = nums[i]\n        stack.append(i)\n    return result\n\n[/Code 2]\n\n[Asserts 2]\n\nassert nextGreaterElement([4, 1, 2, 5, 3]) == [5, 2, 5, -1, -1]\nassert nextGreaterElement([3, 4, 2, 7, 5, 8, 10, 6]) == [4, 7, 7, 8, 8, 10, -1, -1]\nassert nextGreaterElement([5, 4, 3, 2, 1]) == [-1, -1, -1, -1, -1]\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'integers', 'prefix', 'occurrence', 'maximum']", "prompt_tokens": 569, "total_tokens": 832, "completion_tokens": 263, "completion": "[Question 2]\n\nGiven an array of integers arr[], the task is to randomize the array in such a way that the occurrences of dissimilar prefixes are maximum.\n\n[/Question 2]\n\n[Code 2]\n\nimport random\n\ndef randomizeArray(arr: list) -> list:\n    prefix_occurrences = {}\n    output_arr = []\n    \n    for num in arr:\n        output_arr.append(num)\n        prefix = tuple(output_arr)\n        if prefix in prefix_occurrences:\n            prefix_occurrences[prefix] += 1\n        else:\n            prefix_occurrences[prefix] = 1\n    \n    unique_prefixes = list(prefix_occurrences.keys())\n    random.shuffle(unique_prefixes, random.random)\n    \n    randomized_arr = []\n    for prefix in unique_prefixes:\n        randomized_arr.extend(list(prefix))\n    \n    return randomized_arr\n\n[/Code 2]\n\n[Asserts 2]\n\noriginal_arr = [1, 2, 3, 4, 5]\nassert sorted(randomizeArray(original_arr)) != original_arr\nassert sorted(randomizeArray(original_arr)) == original_arr\nassert len(randomizeArray(original_arr)) == len(original_arr)\nassert sum(randomizeArray(original_arr)) == sum(original_arr)\nassert randomizeArray([]) == []\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'integers', 'queries', 'maximum sum', 'swap', 'positions', 'sorting', 'sorted', 'elements', 'performing']", "prompt_tokens": 674, "total_tokens": 979, "completion_tokens": 305, "completion": "[Question 2]\n\nYou are working on a credit card validation system where each credit card has a unique integer identifier associated with it. To enhance the validation process, you decide to precompute and store the maximum sum of the integers at positions less than or equal to a given position. Design an algorithm to perform this precomputation efficiently using a hashset and constant time operations for queries related to maximum sum retrieval.\n\n[/Question 2]\n\n[Code 2]\n\nclass CreditCardValidator:\n    def __init__(self, arr: list):\n        self.prefixSum = [0] * (len(arr)+1)\n        for i in range(len(arr)):\n            self.prefixSum[i+1] = self.prefixSum[i] + arr[i]\n    \n    def precomputeMaxSum(self) -> set:\n        maxSumSet = set()\n        maxSum = 0\n        for num in self.prefixSum:\n            maxSum = max(maxSum, num)\n            maxSumSet.add(maxSum)\n        return maxSumSet\n\n[/Code 2]\n\n[Asserts 2]\n\nvalidator = CreditCardValidator([3, 2, 1, 4, 5])\nassert validator.precomputeMaxSum()=={0, 3, 5, 6, 10, 15}\nvalidator2 = CreditCardValidator([5, 2, 1, 2])\nassert validator2.precomputeMaxSum()=={0, 5, 7, 8, 10}", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'integer', 'sum', 'subarray', 'product', 'minimum']", "prompt_tokens": 532, "total_tokens": 916, "completion_tokens": 384, "completion": "[Question 2]\n\nYou are given an array of integers. Write a function to find the minimum sum of a right circular subarray of a specified length within the array.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef minSumRightCircularSubarray(nums: List[int], length: int) -> int:\n    n = len(nums)\n    if length > n:\n        return -1  # Invalid length\n    prefix_sum = [0] * (2 * n + 1)\n    for i in range(1, 2 * n + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + nums[(i - 1) % n]\n    min_sum = float('inf')\n    for i in range(n):\n        for j in range(i + length, min(i + 2 * n - length + 1, n + 1)):\n            min_sum = min(min_sum, prefix_sum[j] - prefix_sum[i])\n    return min_sum\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minSumRightCircularSubarray([5, -2, 3, 4, -8, 6], 3) == -11\nassert minSumRightCircularSubarray([1, 2, 3, 4, 5, 6, 7], 4) == 10\nassert minSumRightCircularSubarray([10, -12, 11, -10, 13], 2) == -22\nassert minSumRightCircularSubarray([7, 4, 8, -5, -9, 10, -12], 5) == -18\nassert minSumRightCircularSubarray([3, -2, 2, -3], 1) == -3\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'integers', 'subarray', 'maximum sum', 'first and last elements', 'removing elements']", "prompt_tokens": 555, "total_tokens": 1068, "completion_tokens": 513, "completion": "[Question 2]\n\nGiven a planar grid represented as a 2D array of integers, write a function to find the maximum sum of a subarray such that after removing elements from the subarray, the first and last elements of the subarray remain the same based on the preorder traversal of the grid.\n\n[/Question 2]\n\n[Code 2]\n\ndef maxSumFirstLastSameInPreorder(grid):\n    def preorder_traversal(node, path, result):\n        if node:\n            path.append(node.value)\n            if not node.left and not node.right:\n                result.append(path[:])\n            else:\n                preorder_traversal(node.left, path, result)\n                preorder_traversal(node.right, path, result)\n            path.pop()\n\n    class TreeNode:\n        def __init__(self, value):\n            self.value = value\n            self.left = None\n            self.right = None\n\n    def buildTree(arr):\n        if not arr:\n            return None\n        root = TreeNode(arr[0])\n        stack = [(root, 0)]\n        while stack:\n            node, idx = stack.pop()\n            idx += 1\n            if idx < len(arr) and arr[idx] is not None:\n                node.left = TreeNode(arr[idx])\n                stack.append((node.left, idx))\n            idx += 1\n            if idx < len(arr) and arr[idx] is not None:\n                node.right = TreeNode(arr[idx])\n                stack.append((node.right, idx))\n        return root\n\n    tree = buildTree(grid)\n    paths = []\n    preorder_traversal(tree, [], paths)\n\n    maxSum = float('-inf')\n    for path in paths:\n        n = len(path)\n        for i in range(n):\n            for j in range(i, n):\n                if path[i] == path[j]:\n                    maxSum = max(maxSum, sum(path[i:j+1]))\n\n    return maxSum if maxSum != float('-inf') else -1\n\n[/Code 2]\n\n[Asserts 2]\n\ngrid1 = [\n    [1, 2, 3],\n    [4, 5, 6],\n    [7, 8, 9]\n]\nassert maxSumFirstLastSameInPreorder(grid1) == 15\n\ngrid2 = [\n    [1, 2, 2],\n    [4, 5, 6],\n    [2, 8, 9]\n]\nassert maxSumFirstLastSameInPreorder(grid2) == 11", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['string', 'maximize', 'partitions', 'substrings', 'common', 'character']", "prompt_tokens": 563, "total_tokens": 942, "completion_tokens": 379, "completion": "[Question 2]\n\nYou are given a string 's' and an integer 'n'. The task is to toggle characters of substrings to maximize the count of common characters between substrings. A toggle of a character means changing it from lowercase to uppercase or vice versa.\n\nWrite a function to find the maximum count of common characters that can be achieved after toggling characters of substrings.\n\nFor example:\n\nInput:\ns = \"abCA\"\nn = 2\n\nOutput:\n3\n\nExplanation:\nBy toggling the characters, we can have the substrings \"ab\", \"CA\", which will have 3 common characters: a, b, and C.\n\n[/Question 2]\n\n[Code 2]\n\ndef maxCommonCharacters(s: str, n: int) -> int:\n    result = 0\n    for i in range(len(s) - 1):\n        for j in range(i + 1, len(s)):\n            if len(set(s[i:j+1])) + n >= len(set(s[i:j+1] + s[j+1:])) + len(set(s[i:j+1] + s[j+1:])) - len(set(s[i:j+1])):\n                result = max(result, len(set(s[i:j+1])) + n)\n            else:\n                result = max(result, len(set(s[i:j+1] + s[j+1:])))\n    return result\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maxCommonCharacters(\"abCA\", 2) == 3\nassert maxCommonCharacters(\"abcdEFG\", 3) == 5\nassert maxCommonCharacters(\"abcde\", 1) == 4\nassert maxCommonCharacters(\"abAB\", 2) == 4\nassert maxCommonCharacters(\"abcd\", 0) == 4\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['sudoku', 'board', 'valid', 'solution', 'row', 'column', 'subgrid', 'empty cells', 'partially filled']", "prompt_tokens": 903, "total_tokens": 1590, "completion_tokens": 687, "completion": "[Question 2]\n\nWrite a function to halve the values in the given 9x9 sudoku board's exterior angles. The Sudoku board is partially filled, where empty cells are represented by the character '.'. For each subgrid, the exterior angles are the four values at the corners of the subgrid. The function should update the board with the halved values of the exterior angles and return the modified board.\n\nNote: The input board is guaranteed to be a valid partially filled Sudoku board.\n\n[/Question 2]\n\n[Code 2]\n\ndef halveExteriorAngles(board: List[List[int]]) -> List[List[int]]:\n        for i in range(0, 9, 3):\n            for j in range(0, 9, 3):\n                subgrid = [board[x][y] for x in range(i, i+3) for y in range(j, j+3)]\n                exterior_angles = [subgrid[0], subgrid[2], subgrid[6], subgrid[8]]\n                halved_exterior = [x//2 for x in exterior_angles]\n                idx = 0\n                for x in range(i, i+3):\n                    for y in range(j, j+3):\n                        if (x in [i, i+2]) and (y in [j, j+2]):\n                            board[x][y] = halved_exterior[idx]\n                            idx += 1\n        return board\n\n[/Code 2]\n\n[Asserts 2]\n\nassert halveExteriorAngles([\n  [5,3,0,0,7,0,0,0,0],\n  [6,0,0,1,9,5,0,0,0],\n  [0,9,8,0,0,0,0,6,0],\n  [8,0,0,0,6,0,0,0,3],\n  [4,0,0,8,0,3,0,0,1],\n  [7,0,0,0,2,0,0,0,6],\n  [0,6,0,0,0,0,2,8,0],\n  [0,0,0,4,1,9,0,0,5],\n  [0,0,0,0,8,0,0,7,9]\n])== [\n  [2,3,0,0,3,0,0,0,0],\n  [6,0,0,1,9,5,0,0,0],\n  [0,9,4,0,0,0,0,6,0],\n  [4,0,0,0,6,0,0,0,1],\n  [2,0,0,4,0,3,0,0,1],\n  [3,0,0,0,2,0,0,0,3],\n  [0,6,0,0,0,0,2,8,0],\n  [0,0,0,2,1,5,0,0,2],\n  [0,0,0,0,8,0,0,7,4]\n]\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['number', 'function', 'sum', 'parts', 'smallest', 'calculation', 'iteration']", "prompt_tokens": 541, "total_tokens": 801, "completion_tokens": 260, "completion": "[Question 2]\n\nWrite a function to calculate the sum of the parts of a given number. The parts of a number 'm' are defined as the numbers from 1 to m. For example, the parts of 6 are [1, 2, 3, 4, 5, 6], and their sum is 21.\n\nAdditionally, implement an iterative function that takes a number 'n' and an increment value 'i', and adds the first 'n' natural numbers in steps of 'i' to the sum. If any of the intermediate cells are empty, handle them appropriately in the calculation.\n\n[/Question 2]\n\n[Code 2]\n\ndef sum_of_parts(number):\n    return sum(range(1, number + 1))\n\ndef incremental_sum(n, increment):\n    total_sum = 0\n    current_number = 1\n    for _ in range(n):\n        total_sum += current_number\n        current_number += increment\n    return total_sum\n\n[/Code 2]\n\n[Asserts 2]\n\nassert sum_of_parts(6) == 21\nassert sum_of_parts(10) == 55\nassert incremental_sum(5, 2) == 15\nassert incremental_sum(5, 3) == 25", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['string', 'vowels', 'arrangement', 'distance', 'optimization']", "prompt_tokens": 636, "total_tokens": 1016, "completion_tokens": 380, "completion": "[Question 2]\n\nYou are given a string s and a list of characters that describe the character set. Find the longest substring within the string s that contains at least one character from each of the character set pieces and has the golden ratio of vowels to non-vowels.\n\nWrite a Python function to find the longest substring that satisfies the above conditions.\n\n[/Question 2]\n\n[Code 2]\n\ndef longestSubstringWithGoldenRatio(s: str, charset: list) -> str:\n    vowels = \"aeiou\"\n    char_pieces = set(charset)\n    max_len = 0\n    max_substr = \"\"\n    for i in range(len(s)):\n        for j in range(i + max_len + 1, len(s) + 1):\n            sub = s[i:j]\n            if set(sub).intersection(char_pieces):\n                vowel_count = sum(1 for c in sub if c in vowels)\n                non_vowel_count = len(sub) - vowel_count\n                if non_vowel_count != 0 and vowel_count / non_vowel_count > 1.618:\n                    if len(sub) > max_len:\n                        max_len = len(sub)\n                        max_substr = sub\n    return max_substr\n\n[/Code 2]\n\n[Asserts 2]\n\nassert longestSubstringWithGoldenRatio(\"abcdeiouxy\", ['a', 'b', 'c', 'x', 'y'])==\"deiou\"\nassert longestSubstringWithGoldenRatio(\"abracadabra\", ['a', 'b', 'c'])==\"abrac\"\nassert longestSubstringWithGoldenRatio(\"aeioubcdxy\", ['b', 'c', 'd', 'x', 'y'])==\"aeioubcd\"\nassert longestSubstringWithGoldenRatio(\"xyzpqrs\", ['p', 'q', 'x', 'y'])==\"\"\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['binary', 'string', 'minimum', 'adjacent', 'swaps', 'rearrangement', 'sorting']", "prompt_tokens": 568, "total_tokens": 858, "completion_tokens": 290, "completion": "[Question 2]\n\nYou are given a string S consisting of lowercase characters. You need to find the minimum number of adjacent swaps needed to rearrange the string such that it satisfies a given threshold condition.\n\n[/Question 2]\n\n[Code 2]\n\ndef minSwapsForThreshold(s: str, threshold: int) -> int:\n    n = len(s)\n    count = 0\n    for c in s:\n        if c <= threshold:\n            count += 1\n    ans = 0\n    for i in range(count):\n        if s[i] > threshold:\n            ans += 1\n    res = ans\n    j = count\n    for i in range(n):\n        if j == n:\n            break\n        if s[i] > threshold:\n            ans -= 1\n        if s[j] > threshold:\n            ans += 1\n        res = min(res, ans)\n        j += 1\n    return res\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minSwapsForThreshold(\"abcde\", 'c')==1\nassert minSwapsForThreshold(\"abcdabcd\", 'c')==2\nassert minSwapsForThreshold(\"ababab\", 'c')==3\nassert minSwapsForThreshold(\"aaaaa\", 'c')==0\nassert minSwapsForThreshold(\"abcde\", 'a')==0\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['clock', 'angle', 'time', 'math', 'geometry']", "prompt_tokens": 495, "total_tokens": 914, "completion_tokens": 419, "completion": "[Question 2]\n\nYou have been tasked with writing a program to calculate the total number of driving license applicants who applied during each time period of the day. The time periods are defined as morning (6 AM - 12 PM), afternoon (12 PM - 6 PM), and evening (6 PM - 12 AM). Given a list of application timestamps, write a function to calculate the number of applicants during each time period.\n\n[/Question 2]\n\n[Code 2]\n\nfrom collections import defaultdict\n\ndef calculateApplicantsByTimePeriod(timestamps: list) -> dict:\n    time_periods = defaultdict(int)\n    for timestamp in timestamps:\n        hour = timestamp.hour\n        if 6 <= hour < 12:\n            time_periods['morning'] += 1\n        elif 12 <= hour < 18:\n            time_periods['afternoon'] += 1\n        else:\n            time_periods['evening'] += 1\n    return dict(time_periods)\n\n[/Code 2]\n\n[Asserts 2]\n\nassert calculateApplicantsByTimePeriod([datetime.datetime(2023, 5, 12, 8, 30),\n                                        datetime.datetime(2023, 5, 12, 14, 45),\n                                        datetime.datetime(2023, 5, 12, 18, 20),\n                                        datetime.datetime(2023, 5, 12, 10, 0),\n                                        datetime.datetime(2023, 5, 12, 20, 15)]) == {'morning': 2, 'afternoon': 1, 'evening': 2}\nassert calculateApplicantsByTimePeriod([datetime.datetime(2023, 5, 12, 7, 10),\n                                        datetime.datetime(2023, 5, 12, 13, 30),\n                                        datetime.datetime(2023, 5, 12, 19, 45)]) == {'morning': 1, 'afternoon': 1, 'evening': 1}", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['range', 'distinct', 'pair', 'positive integers', 'divides', 'function', 'criteria']", "prompt_tokens": 512, "total_tokens": 835, "completion_tokens": 323, "completion": "[Question 2]\n\nYou are running a small online store and you have a list of products labeled from 1 to N. Each product has a gravity value, denoted by an array gravity[] of size N, where gravity[i] represents the gravity of the ith product. The gravity value represents the selling rate of the products and it is a positive integer.\n\nYour task is to write a function that calculates the total number of pairs of distinct products (i, j) such that 1 <= i < j <= N and the smaller gravity value product divides the larger gravity value product. In other words, find the number of distinct pairs of products where the gravity of product i divides the gravity of product j.\n\nWrite a function to compute and return the total number of pairs meeting the given criteria.\n\n[/Question 2]\n\n[Code 2]\n\ndef countDistinctPairs(gravity: List[int]) -> int:\n    n = len(gravity)\n    count = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if gravity[j] % gravity[i] == 0:\n                count += 1\n    return count\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countDistinctPairs([1, 2, 3, 4, 5]) == 3\nassert countDistinctPairs([2, 4, 6, 8, 10]) == 10\nassert countDistinctPairs([3, 5, 7, 9, 11]) == 0\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['bitwise', 'integer', 'OR', 'sum']", "prompt_tokens": 449, "total_tokens": 746, "completion_tokens": 297, "completion": "[Question 2]\n\nYou are given a list of integer values and a target sum. Find the pairs of integers in the list whose bitwise OR is greater than the target sum.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List, Tuple\n\ndef findPairsWithORGreaterThanSum(nums: List[int], target_sum: int) -> List[Tuple[int, int]]:\n    result = []\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            if (nums[i] | nums[j]) > target_sum:\n                result.append((nums[i],nums[j]))\n    return result\n\n[/Code 2]\n\n[Asserts 2]\n\nassert findPairsWithORGreaterThanSum([3, 5, 7, 10, 15], 7) == [(7, 10), (7, 15), (10, 15)]\nassert findPairsWithORGreaterThanSum([8, 6, 4, 2, 1], 3) == [(4, 6), (4, 8), (2, 6), (2, 8), (1, 6), (1, 8)]\nassert findPairsWithORGreaterThanSum([9, 12, 15, 18, 21], 12) == [(15, 18), (15, 21), (18, 21)]\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['integer', 'digits', 'division', 'count', 'loop', 'math']", "prompt_tokens": 464, "total_tokens": 692, "completion_tokens": 228, "completion": "[Question 2]\n\nGiven a non-negative integer n, write a function to print a concentric square pattern of 2n digits. The digits should be filled in such a way that only a single color model of digits is used.\n\nFor example, if n=3, the pattern should be:\n3333333\n3222223\n3211123\n3210123\n3211123\n3222223\n3333333\n\n[/Question 2]\n\n[Code 2]\n\ndef printConcentricPattern(n: int) -> None:\n    for i in range(2*n-1):\n        for j in range(2*n-1):\n            print(str(n - min(i, j, 2*n-2-i, 2*n-2-j)), end = \"\")\n        print()\n\n[/Code 2]\n\n[Asserts 2]\n\nprintConcentricPattern(3)\n# Output:\n# 3333333\n# 3222223\n# 3211123\n# 3210123\n# 3211123\n# 3222223\n# 3333333\n", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['integer', 'multiple', 'divisibility', 'modulo', 'math', 'positive', 'smallest']", "prompt_tokens": 488, "total_tokens": 804, "completion_tokens": 316, "completion": "[Question 2]\n\nYou are participating in a contest and want to buy as many atoms of a certain element as possible with the money you have. Each atom costs a certain positive integer amount of money. You want to maximize the number of atoms you can buy with the money you have such that the amount spent is a multiple of a given integer K.\n\nWrite a function that takes the available money amount M, the cost of each atom C, and the required divisibility factor K as inputs and returns the maximum number of atoms you can buy such that the total cost is a multiple of K. If it is not possible to buy any atoms with the given amount of money, return 0.\n\n[/Question 2]\n\n[Code 2]\n\ndef maxAtomsWithDivisibility(M: int, C:int, K:int) -> int:\n    maxAtoms = M // C  # Maximum atoms that can be bought without considering the divisibility\n    maxDivisibleAtoms = (M // K) // C  # Maximum atoms that can be bought while satisfying the divisibility\n    return maxDivisibleAtoms * C\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maxAtomsWithDivisibility(20, 3, 5) == 15\nassert maxAtomsWithDivisibility(100, 7, 3) == 42\nassert maxAtomsWithDivisibility(50, 10, 4) == 40\nassert maxAtomsWithDivisibility(10, 2, 7) == 0", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['string', 'convert', 'replace', 'mapping', 'character', 'possible', 'false']", "prompt_tokens": 524, "total_tokens": 762, "completion_tokens": 238, "completion": "[Question 2]\n\nYou are given a list of strings, where each string represents a person's surname. Write a function to determine if it is possible to convert all surnames into a new list with distinct digits by replacing each character with a unique digit. Return true if it is possible, else return false.\n\n[/Question 2]\n\n[Code 2]\n\ndef isDistinctDigits(surnames: List[str]) -> bool:\n    mapping = {}\n    for surname in surnames:\n        if len(surname) > 10:\n            return False\n        for char in surname:\n            if char in mapping:\n                if len(mapping[char]) > 1:\n                    return False\n            else:\n                mapping[char] = set()\n            mapping[char].add(surname)\n    return True\n\n[/Code 2]\n\n[Asserts 2]\n\nassert(isDistinctDigits([\"Smith\", \"Johnson\", \"Williams\", \"Jones\"]) == True)\nassert(isDistinctDigits([\"Doe\", \"Roe\", \"Moe\"]) == False)\nassert(isDistinctDigits([\"Brown\", \"Miller\", \"Davis\", \"Garcia\"]) == True)\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['substring', 'length', 'characters', 'change', 'frequency', 'max']", "prompt_tokens": 593, "total_tokens": 901, "completion_tokens": 308, "completion": "[Question 2]\n\nGiven a string str and an integer K, the task is to find the length of the longest sub-string S such that after changing at most K characters, the frequency of characters with odd remainder when divided by 3 is maximized.\n\n[/Question 2]\n\n[Code 2]\n\ndef maxOddRemainderSubstring(s: str, k: int) -> int:\n\tn, res, l, odd_count, even_count, prefix_odd = len(s), 0, 0, 0, 0, {0: 1}\n\n\tfor r in range(n):\n\t\tif (int(s[r]) % 2 == 0):\n\t\t\teven_count += 1\n\t\telse:\n\t\t\todd_count += 1\n\n\t\todd_freq = odd_count - even_count\n\t\tif (odd_freq - k) in prefix_odd:\n\t\t\tres = max(res, r - prefix_odd[odd_freq - k])\n\t\tif (odd_freq) in prefix_odd:\n\t\t\tprefix_odd[odd_freq] = r\n\n\treturn res\n\n[/Code 2]\n\n[Asserts 2]\n\nassert(maxOddRemainderSubstring(\"3451234\", 1)) == 1\nassert(maxOddRemainderSubstring(\"12345\", 2)) == 5\nassert(maxOddRemainderSubstring(\"111111\", 2)) == 6\nassert(maxOddRemainderSubstring(\"10101\", 1)) == 6\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'cost', 'remainder', 'minimum', 'element']", "prompt_tokens": 712, "total_tokens": 1008, "completion_tokens": 296, "completion": "[Question 2]\n\nYou are given an array of integers representing the cost of buying elements from a store. You need to find the minimum cost to buy a set of elements such that the sum of the remainders of the elements when divided by a specific number is minimized.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\ndef minCostWithRemainder(arr: List[int], num: int) -> int:\n    n = len(arr)\n    dp = [float('inf')] * (num + 1)\n    dp[0] = 0\n\t\n    for i in range(n):\n        for j in range(arr[i] % num + 1):\n            dp[(j + arr[i]) % num] = min(dp[(j + arr[i]) % num], dp[j] + arr[i])\n\n    return dp[num]\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minCostWithRemainder([3, 7, 5, 6], 4) == 5\nassert minCostWithRemainder([5, 10, 12, 8], 3) == 10\nassert minCostWithRemainder([11, 15, 17, 9], 5) == 10\nassert minCostWithRemainder([9, 13, 16, 20], 7) == 20\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'integer', 'adjacent pairs', 'parity', 'rearranging', 'minimum count']", "prompt_tokens": 567, "total_tokens": 961, "completion_tokens": 394, "completion": "[Question 2]\n\nYou are given an array of integers. Write a function to rearrange the array such that the minimum count of adjacent pairs with different parity is achieved while also ensuring that no leading zero is present in any integer. Return the rearranged array.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef rearrangeArray(nums: List[int]) -> List[int]:\n        even = [x for x in nums if x % 2 == 0]\n        odd = [x for x in nums if x % 2 != 0]\n        arranged = []\n        if len(even) >= len(odd):\n            for e, o in zip(even, odd):\n                arranged.append(e)\n                arranged.append(o)\n            arranged += even[len(odd):]\n        else:\n            for e, o in zip(even, odd):\n                arranged.append(o)\n                arranged.append(e)\n            arranged += odd[len(even):]\n        return arranged\n\n[/Code 2]\n\n[Asserts 2]\n\nassert rearrangeArray([1, 2, 3, 4, 5, 6])== [2, 1, 4, 3, 6, 5]\nassert rearrangeArray([2, 4, 6, 8, 10])==[2, 3, 4, 5, 6, 8, 10]\nassert rearrangeArray([1, 3, 5, 7, 9])==[2, 1, 4, 3, 6, 5, 7, 9]\nassert rearrangeArray([10, 21, 32, 43, 56, 67, 70, 89])==[10, 21, 32, 43, 56, 67, 70, 89] \n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['string', 'palindrome', 'swap', 'character', 'boolean', 'condition', 'iteration']", "prompt_tokens": 650, "total_tokens": 867, "completion_tokens": 217, "completion": "[Question 2]\n\nWrite a Python function that takes a string as input and checks if it is a palindrome. A palindrome is a word, phrase, number, or other sequence of characters that reads the same forward and backward. The function should return True if the input string is a palindrome, otherwise return False. Consider only alphabets and ignore any other characters in the string.\n\n[/Question 2]\n\n[Code 2]\n\ndef isPalindrome(s: str) -> bool:\n    s = ''.join(e for e in s if e.isalpha()).lower()\n    return s == s[::-1]\n\n[/Code 2]\n\n[Asserts 2]\n\nassert isPalindrome(\"racecar\") == True\nassert isPalindrome(\"hello\") == False\nassert isPalindrome(\"A man, a plan, a canal, Panama\") == True\nassert isPalindrome(\"12321\") == True\nassert isPalindrome(\"Was it a car or a cat I saw\") == True\nassert isPalindrome(\"No lemon, no melon\") == False\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['prefix sum', 'maximization', 'subarray', 'optimization', 'array', 'removal', 'sum']", "prompt_tokens": 643, "total_tokens": 1009, "completion_tokens": 366, "completion": "[Question 2]\n\nYou are given an array of distances between N cities represented by an NxN matrix, where distances[i][j] is the distance between city i and city j. Your task is to find the longest possible distance of any subarray of the cities visited consecutively on a tour. It is allowed to start and end at different cities. Implement a function to find the maximum possible distance.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef maxDistance(distances: List[List[int]]) -> int:\n    n = len(distances)\n    max_dist = 0\n    prefix_sum = [0]*(n+1)\n    for i in range(n):\n        for j in range(n):\n            prefix_sum[j+1] = prefix_sum[j] + distances[i][j]\n        for start in range(n):\n            for end in range(start+1, n):\n                subarray_sum = prefix_sum[end+1] - prefix_sum[start]\n                max_dist = max(max_dist, subarray_sum)\n    return max_dist\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maxDistance([[0, 1, 2],\n                    [1, 0, 3],\n                    [2, 3, 0]])==6\n\nassert maxDistance([[0, 4, 8, 5], \n                    [4, 0, 7, 9], \n                    [8, 7, 0, 3], \n                    [5, 9, 3, 0]])==27\n\nassert maxDistance([[0, 2, 8],\n                    [2, 0, 9],\n                    [8, 9, 0]])==19\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['dynamic programming', 'optimization', 'greedy', 'coin', 'denominations', 'combinations', 'amount', 'minimization']", "prompt_tokens": 582, "total_tokens": 829, "completion_tokens": 247, "completion": "[Question 2]\n\nYou are given a list of denominations of coins and an amount of money. Write a function to find the minimum number of coins required to make up the given amount using the coins available. If the amount cannot be made up by any combination of the coins, return -1.\n\n[/Question 2]\n\n[Code 2]\n\ndef minCoinsRequired(coins, amount):\n    dp = [float('inf')] * (amount + 1)\n    dp[0] = 0\n    for coin in coins:\n        for i in range(coin, amount + 1):\n            dp[i] = min(dp[i], dp[i - coin] + 1)\n    return dp[amount] if dp[amount] != float('inf') else -1\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minCoinsRequired([1, 2, 5], 11) == 3\nassert minCoinsRequired([2], 3) == -1\nassert minCoinsRequired([1], 0) == 0\nassert minCoinsRequired([1], 1) == 1\nassert minCoinsRequired([1], 2) == 2", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'integers', 'subarray', 'even', 'odd', 'difference', 'maximize', 'sum', 'prefix sum', 'iteration']", "prompt_tokens": 645, "total_tokens": 1079, "completion_tokens": 434, "completion": "[Question 2]\n\nYou are given an array of integers and a target sum. Your task is to find the number of subarrays whose sum is closest to the target sum. If there are multiple subarrays with the same closest sum, you should return the number of presses needed to type the most significant bit (MSB) of that sum into a computer.\n\nWrite a function `closestSubarraySum` to calculate the number of subarrays whose sum is closest to the target sum and return the number of presses needed to type the MSB of the closest sum.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\ndef closestSubarraySum(arr: List[int], target: int) -> int:\n    closest_sum = float('inf')\n    count = 0\n    prefix_sum = 0\n    presses = 0\n    seen = {0: 1}\n    for num in arr:\n        prefix_sum += num\n        diff = abs(prefix_sum - target)\n        if diff < closest_sum:\n            closest_sum = diff\n            count = seen.get(closest_sum, 0)\n            presses = len(bin(diff)) - 2\n        elif diff == closest_sum:\n            count += 1\n    return count, presses\n\n[/Code 2]\n\n[Asserts 2]\n\nassert closestSubarraySum([10, 2, -2, 3], 7) == (1, 2)\nassert closestSubarraySum([1, 3, 4, 5, 1, 5, 8, 9], 20) == (3, 3)\nassert closestSubarraySum([4, 3, -1, 6, 2], 9) == (3, 4)\nassert closestSubarraySum([2, 4, 6, 8, 3, 1], 9) == (3, 4)\nassert closestSubarraySum([3, 7, -2, 8, 5], 12) == (2, 3)\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['divisors', 'range', 'queries', 'inclusive', 'integers', 'counting', 'maximum']", "prompt_tokens": 571, "total_tokens": 824, "completion_tokens": 253, "completion": "[Question 2]\n\nYou are given a graph with N vertices and M edges. Each edge has an associated weight. Your task is to find the length of the maximum negative cycle in the graph. The graph is periodic in nature and you have to handle Q queries. For each query, you are given a range [L, R] (both inclusive) and you have to determine if there is a negative cycle within this range using Dijkstra's algorithm.\n\n[/Question 2]\n\n[Code 2]\n\ndef maxNegativeCycle(graph, N, M, queries):\n    # Your Dijkstra's algorithm implementation and negative cycle detection logic here\n    pass\n\n[/Code 2]\n\n[Asserts 2]\n\n# Assuming inputs for the asserts\ngraph = [[(1, -1), (2, 4)], [(2, 3), (3, 2), (4, 2)], [], [(3, 5), (1, 1)]]\nN = 4\nM = 5\nqueries = [(1, 2), (2, 3), (1, 3)]\n\nassert maxNegativeCycle(graph, N, M, queries) == [False, True, True]\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'subarray', 'sum', 'manipulation']", "prompt_tokens": 642, "total_tokens": 959, "completion_tokens": 317, "completion": "[Question 2]\n\nYou are given an array of integers and a target sum. Your task is to find all the subarrays that sum up to the given target sum. Return the starting and ending indices of each subarray.\n\nWrite a function to find all the subarrays with the sum equal to the given target sum.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\ndef subarraySum(arr: List[int], target: int) -> List[List[int]]:\n    result = []\n    for start in range(len(arr)):\n        current_sum = 0\n        for end in range(start, len(arr)):\n            current_sum += arr[end]\n            if current_sum == target:\n                result.append([start, end])\n    return result\n\n[/Code 2]\n\n[Asserts 2]\n\nassert subarraySum([1, 2, 3, 4, 5, 6, 7, 8, 9], 15)==[[0, 4], [1, 5], [2, 6], [3, 7]]\nassert subarraySum([10, 2, -2, -20, 10], -10)==[[0, 3], [2, 3]]\nassert subarraySum([3, 4, -7, 1, 3, 3, 1, -4], 7)==[[3, 4], [0, 4], [3, 6], [4, 7]]\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'integers', 'absolute difference', 'nearest powers of two', 'list']", "prompt_tokens": 587, "total_tokens": 916, "completion_tokens": 329, "completion": "[Question 2]\n\nYou are given an array of integers and a list of range updates. For each range update, you need to calculate the counts of integers in the array whose absolute difference from the nearest powers of two falls within the updated range. \n\nImplement a Python function that can handle the range updates efficiently and return the counts after each range update.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List, Tuple\n\ndef calculateCounts(arr: List[int], updates: List[Tuple[int, int]]) -> List[int]:\n    diff_counts = []\n    for start, end in updates:\n        updated_arr = arr[start:end+1]\n        count = 0\n        for num in updated_arr:\n            power = 1\n            while power < num:\n                power *= 2\n            lower = power // 2\n            higher = power\n            if lower - num <= num - higher:\n                if abs(num - lower) <= end:\n                    count += 1\n            else:\n                if abs(num - higher) <= end:\n                    count += 1\n        diff_counts.append(count)\n    return diff_counts\n\n[/Code 2]\n\n[Asserts 2]\n\nassert calculateCounts([6, 10, 3, 12, 8, 9], [(1, 3), (0, 4)]) == [2, 4]\nassert calculateCounts([2, 5, 7, 16, 32, 15], [(0, 2), (2, 5)]) == [2, 4]\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['string', 'substrings', 'increasing', 'count', 'alphabet', 'order']", "prompt_tokens": 509, "total_tokens": 739, "completion_tokens": 230, "completion": "[Question 2]\n\nYou are given a string S consisting of lowercase English alphabets representing activities. The string may contain identical activities. The task is to count the number of different ways to arrange the activities such that the activities are in strictly increasing order.\n\n[/Question 2]\n\n[Code 2]\n\nfrom math import factorial\n\ndef countIncreasingArrangements(s: str) -> int:\n    activity_counts = {}\n    for activity in s:\n        if activity in activity_counts:\n            activity_counts[activity] += 1\n        else:\n            activity_counts[activity] = 1\n    \n    result = factorial(len(s))\n    for count in activity_counts.values():\n        result //= factorial(count)\n    \n    return result\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countIncreasingArrangements(\"abb\") == 3\nassert countIncreasingArrangements(\"aabb\") == 6\nassert countIncreasingArrangements(\"abcd\") == 24\nassert countIncreasingArrangements(\"aaa\") == 1\nassert countIncreasingArrangements(\"abc\") == 6\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['string', 'substring', 'palindrome', 'rearrange', 'characters', 'counting', 'odd', 'length']", "prompt_tokens": 519, "total_tokens": 786, "completion_tokens": 267, "completion": "[Question 2]\n\nGiven a string s, determine the length of the longest substring which has characters that can be rearranged to form a palindrome and has an odd length. If no such substring exists, return 0.\n\n[/Question 2]\n\n[Code 2]\n\ndef longestOddLengthPalindromeSubstring(s: str) -> int:\n\tlongest_length = 0\n\tchar_count = {}\n\todd_count = 0\n\tfor char in s:\n\t\tchar_count[char] = char_count.get(char, 0) + 1\n\t\tif char_count[char] % 2 == 0:\n\t\t\todd_count -= 1\n\t\telse:\n\t\t\todd_count += 1\n\t\tif odd_count <= 1:\n\t\t\tlongest_length += 1\n\t\telse:\n\t\t\tbreak\n\treturn longest_length if longest_length % 2 != 0 else longest_length - 1\n\n[/Code 2]\n\n[Asserts 2]\n\nassert longestOddLengthPalindromeSubstring(\"abccccdd\") == 7\nassert longestOddLengthPalindromeSubstring(\"geeksforskeeg\") == 11\nassert longestOddLengthPalindromeSubstring(\"aabb\") == 0\nassert longestOddLengthPalindromeSubstring(\"abc\") == 0\nassert longestOddLengthPalindromeSubstring(\"aaaabbcc\") == 7", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'XOR', 'replacement', 'adjacent pairs', 'Kth element', 'M replacements']", "prompt_tokens": 662, "total_tokens": 963, "completion_tokens": 301, "completion": "[Question 2]\n\nGiven an array arr[] of N integers and an integer M, the task is to find the Kth element of the array after M replacements. In each replacement, every element of the array is replaced by the XOR of the element with its adjacent element. Return -1 if the Kth element does not exist.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef kthElementAfterMReplacements(arr: List[int], N: int, K: int, M: int) -> int:\n    for m in range(M):\n        newArray = []\n        for i in range(N-1):\n            newArray.append(arr[i] ^ arr[i+1])\n        arr = newArray\n        N -= 1\n        if N == 0:\n            return -1\n    if K > N:\n        return -1\n    return arr[K-1]\n\n[/Code 2]\n\n[Asserts 2]\n\nassert kthElementAfterMReplacements([2, 5, 8, 6, 9], 5, 3, 2)==0\nassert kthElementAfterMReplacements([1, 2, 3, 4], 4, 2, 3)==-1\nassert kthElementAfterMReplacements([3, 6, 2, 7, 9], 5, 4, 4)==5\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['molecule', 'valence', 'atoms', 'sum', 'zero', 'chemistry', 'math', 'boolean']", "prompt_tokens": 539, "total_tokens": 796, "completion_tokens": 257, "completion": "[Question 2]\n\nYou are given a list of scrambled valence numbers of atoms and a target sum. Your task is to determine if it's possible to form a molecule with the given valence numbers that covers the target sum.\n\nWrite a function that takes in a list of integers representing scrambled valence numbers and an integer representing the target sum. The function should return True if it's possible to cover the target sum using the valence numbers, otherwise return False.\n\n[/Question 2]\n\n[Code 2]\n\ndef canCoverSum(valence_numbers: list, target_sum: int) -> bool:\n    return sum(valence_numbers) == target_sum\n\n[/Code 2]\n\n[Asserts 2]\n\nassert canCoverSum([1, 2, -3], 0) == True\nassert canCoverSum([3, -2, 2, -3, 1], 1) == True\nassert canCoverSum([1, 2, 3], 0) == False\nassert canCoverSum([0, 0, 0, 0], 0) == True\nassert canCoverSum([-1, 1, -2, 2], 0) == True\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['integer', 'geometric mean', 'divisors', 'sorting', 'math', 'calculation', 'sqrt', 'exponentiation']", "prompt_tokens": 593, "total_tokens": 1024, "completion_tokens": 431, "completion": "[Question 2]\n\nGiven two arrays A and B, find the common divisor of the geometric mean of their elements. Return the result after exponentiating it to the integer part of the square root of the geometric mean.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\nimport math\n\ndef commonDivisorGeometricMean(A: List[int], B: List[int]) -> int:\n    def geometricMean(arr: List[int]) -> float:\n        product = 1\n        for num in arr:\n            product *= num\n        return pow(product, 1/len(arr))\n\n    def commonDivisor(a: int, b: int) -> int:\n        smaller = min(a, b)\n        common_div = 1\n        for i in range(1, smaller+1):\n            if a % i == 0 and b % i == 0:\n                common_div = i\n        return common_div\n\n    meanA = geometricMean(A)\n    meanB = geometricMean(B)\n\n    commonDiv = commonDivisor(int(meanA), int(meanB))\n\n    result = pow(commonDiv, int(math.sqrt(meanA)))\n\n    return result\n\n[/Code 2]\n\n[Asserts 2]\n\nassert commonDivisorGeometricMean([2, 4, 6], [3, 6, 9]) == 6\nassert commonDivisorGeometricMean([10, 15, 25], [5, 20, 30]) == 5\nassert commonDivisorGeometricMean([3, 5, 7], [2, 4, 8]) == 2\nassert commonDivisorGeometricMean([12, 18, 24], [6, 9, 12]) == 6\nassert commonDivisorGeometricMean([5, 10, 15], [3, 6, 12]) == 3\nassert commonDivisorGeometricMean([8, 12, 16], [4, 8, 12]) == 4\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['subset', 'partition', 'minimum', 'difference', 'set']", "prompt_tokens": 514, "total_tokens": 911, "completion_tokens": 397, "completion": "[Question 2]\n\nA tridecagonal number is a figurate number that extends the concept of triangular and hexagonal numbers to the tridecagon. A tridecagonal number is equal to n(4n-3)/2 for n>=1. \n\nWrite a function `minimizeDifferenceTridecagonal(n: int)` to find the minimum difference between the cubed tridecagonal numbers that can be partitioned into two subsets.\n\n[/Question 2]\n\n[Code 2]\n\ndef isTridecagonal(num):\n    n = int(((24*num+1)**0.5+1)/6)\n    return n*(4*n-3) == num*2\n\ndef minimizeDifferenceTridecagonal(n: int):\n    tridecagonal_nums = [i*(4*i-3)//2 for i in range(1, n+1) if isTridecagonal(i*(4*i-3)//2)]\n    tridecagonal_cubed_nums = [num**3 for num in tridecagonal_nums]\n    total_sum = sum(tridecagonal_cubed_nums)\n    target_sum = total_sum // 2\n    dp = [0] * (target_sum + 1)\n    for num in tridecagonal_cubed_nums:\n        for i in range(target_sum, num-1, -1):\n            dp[i] = max(dp[i], dp[i-num]+num)\n    ans = total_sum - 2 * dp[target_sum]\n    return ans\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minimizeDifferenceTridecagonal(10) == 8388608\nassert minimizeDifferenceTridecagonal(5) == 468\nassert minimizeDifferenceTridecagonal(15) == 33550336\nassert minimizeDifferenceTridecagonal(20) == 8388608\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['series', 'sum', 'pattern', 'sequence', 'iteration', 'arithmetic']", "prompt_tokens": 478, "total_tokens": 635, "completion_tokens": 157, "completion": "[Question 2]\n\nWrite a Python function that takes a target number and returns the sum of all the multiples of 3 or 5 below the target number.\n\n[/Question 2]\n\n[Code 2]\n\ndef sum_of_multiples(target: int) -> int:\n    total_sum = 0\n    for num in range(target):\n        if num % 3 == 0 or num % 5 == 0:\n            total_sum += num\n    return total_sum\n\n[/Code 2]\n\n[Asserts 2]\n\nassert sum_of_multiples(10) == 23\nassert sum_of_multiples(15) == 45\nassert sum_of_multiples(20) == 78\nassert sum_of_multiples(100) == 2318", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['positive', 'integer', 'perfect square', 'math', 'sqrt']", "prompt_tokens": 484, "total_tokens": 779, "completion_tokens": 295, "completion": "[Question 2]\n\nYou are given a list of positive integers. Write a function to find the Kth element in the list that is a perfect square. If the Kth perfect square does not exist in the list, return -1.\n\n[/Question 2]\n\n[Code 2]\n\nimport math\n\ndef findKthPerfectSquareElement(nums: List[int], k: int) -> int:\n    perfect_squares = [x for x in nums if math.isqrt(x)**2 == x]\n    if k <= len(perfect_squares):\n        return perfect_squares[k-1]\n    else:\n        return -1\n\n[/Code 2]\n\n[Asserts 2]\n\nassert findKthPerfectSquareElement([2, 3, 4, 8, 9, 16, 25, 36], 3)==4\nassert findKthPerfectSquareElement([1, 7, 11, 15, 21], 2)==-1\nassert findKthPerfectSquareElement([5, 10, 15, 20, 25, 30], 4)==25\nassert findKthPerfectSquareElement([49, 64, 81, 100, 121], 5)==121\nassert findKthPerfectSquareElement([30, 40, 50, 60, 70], 2)==-1\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['integer', 'consecutive', 'product', 'boolean', 'loop', 'division', 'math']", "prompt_tokens": 546, "total_tokens": 929, "completion_tokens": 383, "completion": "[Question 2]\n\nWrite a function to calculate the perpendicular distance between a point (x, y) and a line formed by two consecutive points (x1, y1) and (x2, y2) in a 2D plane.\n\n[/Question 2]\n\n[Code 2]\n\nimport math\n\ndef perpendicularDistance(x: int, y: int, x1: int, y1: int, x2: int, y2: int) -> float:\n    dx = x2 - x1\n    dy = y2 - y1\n    if dx == 0 and dy == 0:\n        return math.sqrt((x - x1) ** 2 + (y - y1) ** 2)\n    u = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy)\n    if u > 1:\n        u = 1\n    elif u < 0:\n        u = 0\n    closestX = x1 + u * dx\n    closestY = y1 + u * dy\n    return math.sqrt((x - closestX) ** 2 + (y - closestY) ** 2)\n\n[/Code 2]\n\n[Asserts 2]\n\nassert perpendicularDistance(1, 2, 1, 1, 2, 0) == 1.0\nassert math.isclose(perpendicularDistance(2, 3, 1, 1, 2, 2), 0.707, abs_tol=0.001)\nassert perpendicularDistance(0, 0, 1, 1, 2, 2) == 1.414\nassert perpendicularDistance(3, 3, 1, 1, 2, 2) == 2.828", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['path', 'coordinates', 'visited', 'direction', 'loop', 'repetition', 'tracking']", "prompt_tokens": 575, "total_tokens": 833, "completion_tokens": 258, "completion": "[Question 2]\n\nGiven a list of integers, each representing the number of stones in a pile, the task is to determine the winner of the Nim game. In the Nim game, two players take turns removing stones from the piles. On each turn, a player must remove at least one stone, and may remove any number of stones provided they all come from the same pile. The game continues until all the stones are exhausted. The player who removes the last stone is the winner. Assume both players play optimally. Return true if the player who moves first will win, else return false.\n\n[/Question 2]\n\n[Code 2]\n\ndef nimGame(piles: List[int]) -> bool:\n    nim_sum = 0\n    for pile in piles:\n        nim_sum ^= pile\n    return nim_sum != 0\n\n[/Code 2]\n\n[Asserts 2]\n\nassert nimGame([3, 4, 5]) == True\nassert nimGame([1, 1, 1, 1]) == False\nassert nimGame([1, 2, 3, 4, 5]) == False\nassert nimGame([1, 2, 3, 4]) == True\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['fibonacci', 'sequence', 'index', 'constant time', 'O(1)', 'sum', 'preceding', 'number']", "prompt_tokens": 558, "total_tokens": 744, "completion_tokens": 186, "completion": "[Question 2]\n\nYou are given a sequence of numbers constituting the Fibonacci series. Write a function to find the sum of the numbers at even indices in constant time, i.e., O(1).\n\n[/Question 2]\n\n[Code 2]\n\ndef sumOfEvenIndicesFibonacci(n: int) -> int:\n    if n <= 0:\n        return 0\n    return ((4 * (2 ** (n + 1))) // 3) - 1\n\n[/Code 2]\n\n[Asserts 2]\n\nassert sumOfEvenIndicesFibonacci(1) == 2\nassert sumOfEvenIndicesFibonacci(2) == 10\nassert sumOfEvenIndicesFibonacci(3) == 44\nassert sumOfEvenIndicesFibonacci(4) == 188\nassert sumOfEvenIndicesFibonacci(5) == 798", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['string', 'palindromic', 'length', 'concatenating']", "prompt_tokens": 618, "total_tokens": 997, "completion_tokens": 379, "completion": "[Question 2]\n\nGiven a list of strings, the task is to find all special prime palindromic strings of a complete length formed by concatenating the given strings in any order. \n\nA special prime palindromic string is a string that is both a palindrome and a prime number when converted to its integer value by concatenating the individual character ASCII values.\n\nWrite a function to find all the special prime palindromic strings.\n\n[/Question 2]\n\n[Code 2]\n\ndef is_prime(n):\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef is_palindromic(s):\n    return s == s[::-1]\n\ndef specialPrimePalindromicStrings(s: list) -> list:\n    from itertools import permutations\n\n    all_strings = [''.join(p) for p in permutations(s)]\n    special_strings = []\n\n    for string in all_strings:\n        num = int(''.join(str(ord(c)) for c in string))\n        if is_prime(num) and is_palindromic(str(num)):\n            special_strings.append(string)\n\n    return special_strings\n\n[/Code 2]\n\n[Asserts 2]\n\nassert specialPrimePalindromicStrings([\"abc\", \"de\"]) == ['acedb', 'dabec']\nassert specialPrimePalindromicStrings([\"aba\", \"cbc\"]) == []\nassert specialPrimePalindromicStrings([\"ab\", \"cd\", \"ef\"]) == ['fadebc']\nassert specialPrimePalindromicStrings([\"coding\", \"role\"]) == ['codingrole', 'rolecoding']\nassert specialPrimePalindromicStrings([\"abc\", \"def\", \"ghi\"]) == []\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['profit', 'loss', 'percentage', 'calculation', 'cost price', 'selling price', 'comparison']", "prompt_tokens": 550, "total_tokens": 736, "completion_tokens": 186, "completion": "[Question 2]\n\nYou are given a binary heap and you need to determine the probability of finding a unique part at a specific location within the heap. Write a function to calculate the probability of finding a unique part at a given index in the binary heap.\n\n[/Question 2]\n\n[Code 2]\n\ndef calculate_probability(heap_size: int, index: int) -> float:\n    pass\n    if index > heap_size:\n        return 0.0\n    unique_parts = heap_size - index + 1\n    total_parts = heap_size\n    probability = unique_parts / total_parts\n    return probability\n\n[/Code 2]\n\n[Asserts 2]\n\nassert calculate_probability(10, 3) == 0.8\nassert calculate_probability(15, 5) == 0.7333333333333333\nassert calculate_probability(20, 12) == 0.45", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'prefix sums', 'positive', 'minimum', 'addition']", "prompt_tokens": 561, "total_tokens": 963, "completion_tokens": 402, "completion": "[Question 2]\n\nYou are given a chessboard represented as a 2D array of size N x N where each cell represents whether an item is present at that position or not. The task is to place bishops on the board such that the sum of prefix sums of bishops' positions in both diagonals is minimum. Write a function to find the minimum sum.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\ndef minPrefixSumOfBishops(board: List[List[int]], n: int) -> int:\n    diagonal1 = [0] * (2*n)\n    diagonal2 = [0] * (2*n)\n    \n    for i in range(n):\n        for j in range(n):\n            diagonal1[i+j] += board[i][j]\n            diagonal2[i-j+n] += board[i][j]\n    \n    minSum = float('inf')\n    for i in range(n):\n        for j in range(n):\n            minSum = min(minSum, diagonal1[i+j] + diagonal2[i-j+n] - 2*board[i][j])\n    \n    return minSum\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minPrefixSumOfBishops([[1, 0, 1],\n                              [0, 1, 0], \n                              [1, 0, 1]], 3) == 2\nassert minPrefixSumOfBishops([[1, 1, 0],\n                              [0, 0, 0], \n                              [0, 1, 1]], 3) == 2\nassert minPrefixSumOfBishops([[1, 0, 1, 0],\n                              [0, 1, 0, 0], \n                              [1, 0, 1, 0],\n                              [0, 0, 0, 1]], 4) == 2\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['integer', 'range', 'count', 'reverse', 'product']", "prompt_tokens": 511, "total_tokens": 745, "completion_tokens": 234, "completion": "[Question 2]\n\nGiven an integer 'n' and a positive integer 'k', write a function to count the occurrences of numbers in the range [1, n] whose product of digits is a multiple of k.\n\n[/Question 2]\n\n[Code 2]\n\ndef countProductMultipleOfK(n: int, k: int) -> int:\n    count = 0\n    for num in range(1, n+1):\n        product = 1\n        temp = num\n        while temp > 0:\n            digit = temp % 10\n            if digit != 0:\n                product *= digit\n            temp //= 10\n        if product % k == 0:\n            count += 1\n    return count\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countProductMultipleOfK(10, 3) == 3\nassert countProductMultipleOfK(20, 3) == 6\nassert countProductMultipleOfK(50, 5) == 15\nassert countProductMultipleOfK(100, 7) == 15\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['chessboard', 'queens', 'placement', 'attack', 'count', 'iteration', 'nested loops']", "prompt_tokens": 633, "total_tokens": 908, "completion_tokens": 275, "completion": "[Question 2]\n\nWrite a function to find the count of perpendicular lines that can be formed from a list of lists where each sublist represents the coordinates of queens on a chessboard.\n\n[/Question 2]\n\n[Code 2]\n\ndef countPerpendicularLines(queens):\n    count = 0\n    for i in range(len(queens) - 1):\n        for j in range(i + 1, len(queens)):\n            dx = queens[i][0] - queens[j][0]\n            dy = queens[i][1] - queens[j][1]\n            if dx != 0 and dy != 0 and dx != dy and dx + dy != 0:\n                count += 1\n    return count\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countPerpendicularLines([[0,0], [1,2], [3,1], [4,3]]) == 6\nassert countPerpendicularLines([[0,0], [1,2], [3,1]]) == 3\nassert countPerpendicularLines([[0,0], [1,1], [2,2], [3,3]]) == 0\nassert countPerpendicularLines([[0,0], [1,1], [1,2]]) == 0\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['integer', 'binary', 'decimal', 'sum', 'natural numbers', 'representation', 'iteration']", "prompt_tokens": 461, "total_tokens": 842, "completion_tokens": 381, "completion": "[Question 2]\n\nGiven an integer K, the task is to find the sum of decimal numbers formed by concatenating the binary representations of natural numbers from 1 to at most K elements, and then find the root-to-leaf potential of the resulting binary tree.\n\n[/Question 2]\n\n[Code 2]\n\nclass TreeNode:\n  def __init__(self, val=0, left=None, right=None):\n    self.val = val\n    self.left = left\n    self.right = right\n\ndef binaryTreeSumAndPotential(K: int) -> int:\n    def decimalFromBinary(n: int) -> int:\n      return int(bin(n)[2:])\n\n    def sumOfDecimalConcatenations(K: int) -> int:\n        result = 0\n        for i in range(1, K+1):\n            result += int(str(decimalFromBinary(i)))\n        return result\n\n    def rootToLeafPotential(K: int) -> int:\n        def potential(node, val):\n            if not node:\n                return 0\n            val = (val << 1) + node.val\n            if not node.left and not node.right:\n                return val\n            return potential(node.left, val) + potential(node.right, val)\n        root = TreeNode(int(bin(1)[2:]))\n        cur = root\n        for i in range(2, K+1):\n            cur.left = TreeNode(int(bin(i)[2:]))\n            cur = cur.left\n        return potential(root, 0)\n\n    return rootToLeafPotential(K) + sumOfDecimalConcatenations(K)\n\n[/Code 2]\n\n[Asserts 2]\n\nassert binaryTreeSumAndPotential(3)==38\nassert binaryTreeSumAndPotential(1)==2\nassert binaryTreeSumAndPotential(5)==214\nassert binaryTreeSumAndPotential(7)==318", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'integers', 'pairs', 'indices', 'count', 'conditions', 'comparison', 'defaultdict']", "prompt_tokens": 559, "total_tokens": 822, "completion_tokens": 263, "completion": "[Question 2]\n\nYou are given an array of integers. Write a function to count the number of pairs of indices (i, j) where i < j and the absolute difference between array elements at indices i and j is at most K.\n\n[/Question 2]\n\n[Code 2]\n\ndef countPairsWithDifference(arr: list, K: int) -> int:\n    pairs = 0\n    n = len(arr)\n    for i in range(n):\n        for j in range(i+1, n):\n            if abs(arr[i] - arr[j]) <= K:\n                pairs += 1\n    return pairs\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countPairsWithDifference([1, 7, 5, 9, 2, 12, 3], 2) == 9\nassert countPairsWithDifference([3, 8, 6, 10, 12, 15], 3) == 8\nassert countPairsWithDifference([2, 4, 2, 4, 2], 0) == 10\nassert countPairsWithDifference([1, 1, 1, 1, 1], 2) == 10\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['jobs', 'workers', 'time', 'allocation', 'consecutive', 'minimization']", "prompt_tokens": 674, "total_tokens": 1083, "completion_tokens": 409, "completion": "[Question 2]\n\nYou are given a list of jobs, where the ith job is going to take time[i] amount of time. There are K workers available who are supposed to work in a center. The jobs need to be split among the workers in such a way that the time taken by each worker is minimized. The workers must work on consecutive job indices and the center requires the workers to split the jobs in a harmonic progression. Write a program to allocate jobs to workers in order to minimize the maximum time taken by any worker.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef allocateJobsToWorkers(time: List[int], k: int) -> int:\n    \n    def isPossible(time, n, k, mid):\n        workerCount = 1\n        currTime = 0\n        for i in range(n):\n            if (time[i] > mid):\n                return False\n            if (currTime + time[i] > mid):\n                currTime = 0\n                workerCount += 1\n            currTime += time[i]\n        return (workerCount <= k)\n\n    left = max(time)\n    right = sum(time)\n    res = 0\n\n    while (left <= right):\n        mid = (left + (right-left)//2)\n        if (isPossible(time, len(time), k, mid)):\n            res = mid\n            right = mid - 1\n        else:\n            left = mid + 1\n\n    return res\n\n[/Code 2]\n\n[Asserts 2]\n\nassert allocateJobsToWorkers([10, 7, 8, 12, 6, 8], 4)==15\nassert allocateJobsToWorkers([5, 8, 9], 2)==17\nassert allocateJobsToWorkers([3, 2, 3], 3)==3\nassert allocateJobsToWorkers([2, 4, 5], 2)==5\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['string', 'balance', 'character', 'count', 'equality', 'boolean']", "prompt_tokens": 466, "total_tokens": 791, "completion_tokens": 325, "completion": "[Question 2]\n\nYou are given two strings s1 and s2, both consisting of lowercase characters. Write a function to determine if s1 can be rearranged into a palindrome which is also a case-insensitive string, and s2 can be rearranged into a palindrome which is also a case-insensitive string. Return True if both s1 and s2 can be rearranged into case-insensitive palindromes, otherwise return False.\n\n[/Question 2]\n\n[Code 2]\n\ndef canFormPalindrome(s: str) -> bool:\n    count = {}\n    for char in s:\n        count[char] = count.get(char, 0) + 1\n    \n    odd_count = 0\n    for val in count.values():\n        if val % 2 != 0:\n            odd_count += 1\n        if odd_count > 1:\n            return False\n    return True\n\ndef isCaseInsensitivePalindrome(s: str) -> bool:\n    s = s.lower()\n    return canFormPalindrome(s)\n\ndef areStringsCaseInsensitivePalindrome(s1: str, s2: str) -> bool:\n    return isCaseInsensitivePalindrome(s1) and isCaseInsensitivePalindrome(s2)\n\n[/Code 2]\n\n[Asserts 2]\n\nassert areStringsCaseInsensitivePalindrome(\"Aabb\", \"BAAA\")==True\nassert areStringsCaseInsensitivePalindrome(\"Aaabb\", \"BAAA\")==False\nassert areStringsCaseInsensitivePalindrome(\"hello\", \"world\")==False\nassert areStringsCaseInsensitivePalindrome(\"Rotator\", \"Top\")==True\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['arithmetic', 'expression', 'evaluation', 'stack', 'operators', 'addition', 'multiplication', 'characters']", "prompt_tokens": 525, "total_tokens": 737, "completion_tokens": 212, "completion": "[Question 2]\n\nYou are given a string representing a Roman numeral. Write a function to evaluate the given Roman numeral expression and return the result.\n\n[/Question 2]\n\n[Code 2]\n\ndef romanToInt(s: str) -> int:\n    romanMap = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000}\n    result = 0\n    prevValue = 0\n    for i in range(len(s) - 1, -1, -1):\n        if romanMap[s[i]] < prevValue:\n            result -= romanMap[s[i]]\n        else:\n            result += romanMap[s[i]]\n        prevValue = romanMap[s[i]]\n    return result\n\n[/Code 2]\n\n[Asserts 2]\n\nassert romanToInt('III') == 3\nassert romanToInt('IX') == 9\nassert romanToInt('LVIII') == 58", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['positive', 'integer', 'equation', 'modulus', 'smallest', 'satisfying', 'iteration', 'math']", "prompt_tokens": 520, "total_tokens": 847, "completion_tokens": 327, "completion": "[Question 2]\n\nYou are given a binary tree where each node contains an integer value. Your task is to write a function to find the smallest positive integer not present in the tree.\n\nWrite a function to find the smallest missing positive integer satisfying the given conditions.\n\n[/Question 2]\n\n[Code 2]\n\nclass TreeNode:\n    def __init__(self, value=0, left=None, right=None):\n        self.value = value\n        self.left = left\n        self.right = right\n\ndef smallestMissingPositiveInteger(root: TreeNode) -> int:\n    def inorderTraversal(node):\n        if not node:\n            return []\n        return inorderTraversal(node.left) + [node.value] + inorderTraversal(node.right)\n\n    inorder_values = inorderTraversal(root)\n    for i in range(1, len(inorder_values) + 2):\n        if i not in inorder_values:\n            return i\n\n[/Code 2]\n\n[Asserts 2]\n\nnode1 = TreeNode(1)\nnode2 = TreeNode(2)\nnode3 = TreeNode(4)\nnode4 = TreeNode(5)\nnode5 = TreeNode(3, node1, node2)\nnode6 = TreeNode(6, node3, node4)\nroot = TreeNode(7, node5, node6)\nassert smallestMissingPositiveInteger(root) == 8\n\nnode1 = TreeNode(7)\nnode2 = TreeNode(2)\nnode3 = TreeNode(3, node1, node2)\nnode4 = TreeNode(1, None, node3)\nassert smallestMissingPositiveInteger(node4) == 4\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['power', 'maximum', 'math', 'exponentiation', 'comparison']", "prompt_tokens": 460, "total_tokens": 646, "completion_tokens": 186, "completion": "[Question 2]\n\nWrite a function that takes in a list of integers and returns the maximum value after raising each element to the power of the sum of its leading and trailing digits.\n\n[/Question 2]\n\n[Code 2]\n\ndef maxExponentiation(nums):\n    def compute_power(num):\n        num_str = str(num)\n        power = int(num_str[0]) + int(num_str[-1])\n        return num ** power\n\n    max_val = float('-inf')\n    for num in nums:\n        max_val = max(max_val, compute_power(num))\n    return max_val\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maxExponentiation([12, 33, 45]) == 729\nassert maxExponentiation([7, 22, 91]) == 43046721\nassert maxExponentiation([3, 15, 28]) == 324", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'integer', 'sorting', 'absolute difference', 'iteration', 'final element']", "prompt_tokens": 650, "total_tokens": 1077, "completion_tokens": 427, "completion": "[Question 2]\n\nGiven an array of integers, we want to rearrange the array in such a way that the elements alternate between positive and negative, with the final element in the array being positive. \n\nWrite a function that takes an array of integers and rearranges the elements so that they satisfy the aforementioned condition. You can assume that the input array will always contain at least one element.\n\nFor example, given the array [5, -3, 9, -1, 5, 7], the rearranged array would be [-3, 5, -1, 9, 5, 7].\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\ndef rearrangeArray(arr: List[int]) -> List[int]:\n    arr.sort(key=abs) # Sorting the array based on absolute values\n    for i in range(1, len(arr), 2):\n        if arr[i] > 0:\n            arr[i-1], arr[i] = arr[i], arr[i-1] # Swapping positive and negative elements\n    if arr[-1] < 0: # Ensuring the final element is positive\n        arr[-1] *= -1\n    return arr\n\n[/Code 2]\n\n[Asserts 2]\n\nassert rearrangeArray([5, -3, 9, -1, 5, 7]) == [-3, 5, -1, 9, 5, 7]\nassert rearrangeArray([-10, 4, -8, 15, -3, 7, -2]) == [-3, 4, -2, 15, -8, 7, -10]\nassert rearrangeArray([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]\nassert rearrangeArray([-1, -2, -3, -4, -5]) == [1, -2, 3, -4, 5]\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['positive integer', 'count', 'possible numbers', 'length', 'digits', 'leading zeros', 'math']", "prompt_tokens": 492, "total_tokens": 769, "completion_tokens": 277, "completion": "[Question 2]\n\nGiven a positive integer N, the task is to count all possible numbers of length N that can be formed using digits from 1 to 6 (inclusive), and where each digit appears in proportion to its powers of 2: that is, the count of the digit 1 is half the count of 2, the count of 2 is half the count of 4, and so on. The number should not contain any leading zeros.\n\n[/Question 2]\n\n[Code 2]\n\nfrom math import log2\n\ndef countNumbersWithProportion(N: int) -> int:\n\tcount = 0\n\tfor i in range(2**(N-1), 2**N):\n\t\tif sum(int(digit) for digit in str(i) if digit in '123456') == N and all(str(2**i) in str(i) for i in range(1, int(log2(N))+1)):\n\t\t\tcount += 1\n\treturn count\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countNumbersWithProportion(1) == 3\nassert countNumbersWithProportion(2) == 5\nassert countNumbersWithProportion(3) == 12\nassert countNumbersWithProportion(4) == 33\nassert countNumbersWithProportion(5) == 103", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['string', 'arrange', 'character', 'frequency', 'unique', 'together']", "prompt_tokens": 552, "total_tokens": 822, "completion_tokens": 270, "completion": "[Question 2]\n\nGiven a string S, the task is to find the frequency of each character and arrange them together in the order they appear in the string. If a character is repeated, its frequency should be added to the previously arranged frequency.\n\nWrite a function to return a string representing the frequency of characters arranged together in the order they appear in the input string.\n\n[/Question 2]\n\n[Code 2]\n\ndef arrangeCharacterFrequency(s: str) -> str:\n    frequency = {}\n    result = ''\n    for char in s:\n        if char in frequency:\n            frequency[char] += 1\n        else:\n            frequency[char] = 1\n    for char in s:\n        if char in frequency:\n            result += char + str(frequency[char])\n            del frequency[char]\n    return result\n\n[/Code 2]\n\n[Asserts 2]\n\nassert arrangeCharacterFrequency(\"hello\") == \"h1e1l2o1\"\nassert arrangeCharacterFrequency(\"programming\") == \"p1r2o1g2a1m2i1n1\"\nassert arrangeCharacterFrequency(\"mississippi\") == \"m1i4s4p2\"\nassert arrangeCharacterFrequency(\"aaaaabbbbbcccdde\") == \"a5b4c3d2e1\"\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['binary tree', 'exponential', 'path', 'absolute difference', 'levels', 'nodes']", "prompt_tokens": 617, "total_tokens": 944, "completion_tokens": 327, "completion": "[Question 2]\n\nWrite a Python function to find the absolute difference between the levels of the ending nodes of different paths in a binary tree. The ending node of a path is defined as the leaf node in the binary tree. \n\n[/Question 2]\n\n[Code 2]\n\nclass Node:\n\tdef __init__(self, key):\n\t\tself.data = key\n\t\tself.left = None\n\t\tself.right = None\n\ndef findLevelsDifference(root):\n\tif root is None:\n\t\treturn 0\n\tqueue = []\n\tqueue.append(root)\n\tlevel_map = {}\n\tlevel_map[root] = 0\n\twhile len(queue) > 0:\n\t\tnode = queue.pop(0)\n\t\tif node.left:\n\t\t\tqueue.append(node.left)\n\t\t\tlevel_map[node.left] = level_map[node] + 1\n\t\tif node.right:\n\t\t\tqueue.append(node.right)\n\t\t\tlevel_map[node.right] = level_map[node] + 1\n\tending_nodes = [key for key in level_map if key.left is None and key.right is None]\n\tif len(ending_nodes) < 2:\n\t\treturn -1\n\telse:\n\t\treturn abs(level_map[ending_nodes[0]] - level_map[ending_nodes[1]])\n\n[/Code 2]\n\n[Asserts 2]\n\nroot = Node(1)\nroot.left = Node(2)\nroot.right = Node(3)\nroot.left.left = Node(4)\nroot.left.right = Node(5)\nroot.right.left = Node(6)\nroot.right.right = Node(7)\nassert findLevelsDifference(root) == 2\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'integer', 'frequency', 'sorting', 'descending', 'tie', 'order']", "prompt_tokens": 603, "total_tokens": 857, "completion_tokens": 254, "completion": "[Question 2]\n\nWrite a program to find the most frequently occurring integer in an array. If there is a tie, the integer with the smaller ASCII value should be considered the most frequent.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef mostFrequentInteger(nums: List[int]) -> int:\n    freq_map = {}\n    for num in nums:\n        if num in freq_map:\n            freq_map[num] += 1\n        else:\n            freq_map[num] = 1\n    max_freq = max(freq_map.values())\n    most_frequent_nums = [num for num, freq in freq_map.items() if freq == max_freq]\n    return min(most_frequent_nums)\n\n[/Code 2]\n\n[Asserts 2]\n\nassert mostFrequentInteger([1, 2, 2, 3, 3, 3]) == 3\nassert mostFrequentInteger([4, 4, 4, 5, 6, 6, 6]) == 4\nassert mostFrequentInteger([7, 7, 7, 8, 9, 9, 9, 9]) == 7\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['string', 'Python', 'identifier', 'validation', 'regular expression', 'pattern matching']", "prompt_tokens": 442, "total_tokens": 674, "completion_tokens": 232, "completion": "[Question 2]\n\nWrite a Python program to remove trailing spaces from a given string and validate if it follows a specific pattern using regular expressions.\n\n[/Question 2]\n\n[Code 2]\n\nimport re\n\ndef removeTrailingSpaces(s: str, pattern: str) -> str:\n    s = s.strip()  # Remove trailing spaces\n    if re.match(pattern, s):\n        return s\n    else:\n        return \"Invalid pattern\"\n\n[/Code 2]\n\n[Asserts 2]\n\nassert removeTrailingSpaces(\" hello world  \", r'^[a-zA-Z\\s]*$') == \"hello world\"\nassert removeTrailingSpaces(\"   regex  \", r'^[a-z\\s]*$') == \"Invalid pattern\"\nassert removeTrailingSpaces(\"Python   \", r'^[A-Z][a-z]*$') == \"Python\"\nassert removeTrailingSpaces(\"   Python\", r'^[A-Z][a-z]*$') == \"Invalid pattern\"\nassert removeTrailingSpaces(\"Manhattan    \", r'^[A-Z][a-z]*$') == \"Manhattan\"\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['tree', 'rooted', 'nodes', 'ancestor', 'array', 'binary tree', 'algorithm', 'recursive', 'traversal', 'data structure']", "prompt_tokens": 709, "total_tokens": 1003, "completion_tokens": 294, "completion": "[Question 2]\n\nGiven a binary tree, write a function to find all unique paths from the root to the leaves.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\nclass TreeNode:\n    def __init__(self, value: int):\n        self.val = value\n        self.left = None\n        self.right = None\n\ndef rootToLeafPaths(root: TreeNode) -> List[List[int]]:\n    paths = []\n    \n    def backtrack(node, path):\n        if not node:\n            return\n        path.append(node.val)\n        \n        if not node.left and not node.right:  # Leaf node\n            paths.append(path[:])\n        else:\n            backtrack(node.left, path)\n            backtrack(node.right, path)\n        \n        path.pop()  # Backtrack\n    \n    backtrack(root, [])\n    return paths\n\n[/Code 2]\n\n[Asserts 2]\n\n# Tree:\n#       1\n#      / \\\n#     2   3\n#    / \\ \n#   4   5\nnode2 = TreeNode(1)\nnode2.left = TreeNode(2)\nnode2.right = TreeNode(3)\nnode2.left.left = TreeNode(4)\nnode2.left.right = TreeNode(5)\nassert rootToLeafPaths(node2) == [[1, 2, 4], [1, 2, 5], [1, 3]]\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'subset', 'absolute difference', 'sum', 'maximum', 'divide']", "prompt_tokens": 559, "total_tokens": 825, "completion_tokens": 266, "completion": "[Question 2]\n\nGiven an array of integers, find the maximum absolute difference between the sum of elements in any two non-overlapping subranges after transposing the array. Transposing the array involves swapping each element with its bitwise AND value. Subranges are defined as any continuous subset of the array. Implement a function to solve this problem.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\ndef maxAbsoluteDifference(arr: List[int]) -> int:\n    n = len(arr)\n    maxDiff = float('-inf')\n    for i in range(n):\n        total1 = 0\n        total2 = 0\n        for j in range(i, n):\n            total1 += arr[j]\n            total2 ^= arr[j]\n            maxDiff = max(maxDiff, abs(total1 - total2))\n    return maxDiff\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maxAbsoluteDifference([1, 2, 3, 4, 5])==9\nassert maxAbsoluteDifference([5, 10, 15, 20])==20\nassert maxAbsoluteDifference([1, 2, 4, 8])==14\nassert maxAbsoluteDifference([3, 3, 3, 3])==0\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'product', 'multiplication', 'condition', 'zero', 'check']", "prompt_tokens": 521, "total_tokens": 765, "completion_tokens": 244, "completion": "[Question 2]\n\nYou are given an array of integers and a target amount. Write a function to check whether there exists a pair of distinct elements in the array whose product is equal to the target amount.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef checkPairProduct(arr: List[int], target: int) -> bool:\n    seen = set()\n    for num in arr:\n        if num == 0:\n            if target == 0:\n                return True\n            continue\n        if target % num == 0:\n            pair = target // num\n            if pair in seen:\n                return True\n        seen.add(num)\n    return False\n\n[/Code 2]\n\n[Asserts 2]\n\nassert checkPairProduct([2, 4, 5, 3], 8)==True\nassert checkPairProduct([1, 5, 7, 11, 25], 35)==True\nassert checkPairProduct([2, 4, 6, 8], 10)==False\nassert checkPairProduct([0, 4, 0, 7], 0)==True\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['integer', 'sum', 'series', 'decimal', 'iteration', 'pattern', 'math']", "prompt_tokens": 471, "total_tokens": 770, "completion_tokens": 299, "completion": "[Question 2]\n\nYou are given a decimal number series and you need to implement a function to toggle the integer and decimal parts of each number in the series. For example, if the input series is [12.34, 56.78, 90.12], the output should be [34.12, 78.56, 12.90].\n\n[/Question 2]\n\n[Code 2]\n\ndef toggleDecimalParts(series):\n    toggled_series = []\n    for num in series:\n        integer_part, decimal_part = str(num).split('.')\n        new_num = decimal_part + '.' + integer_part\n        toggled_series.append(float(new_num))\n    return toggled_series\n\n[/Code 2]\n\n[Asserts 2]\n\nassert toggleDecimalParts([12.34, 56.78, 90.12]) == [34.12, 78.56, 12.90]\nassert toggleDecimalParts([3.14, 2.72, 1.41]) == [14.3, 72.2, 41.1]\nassert toggleDecimalParts([9.99, 8.88, 7.77]) == [99.9, 88.8, 77.7]\nassert toggleDecimalParts([123.456, 789.012, 345.678]) == [456.123, 12.789, 678.345]\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['integer', 'query', 'divisor', 'product', 'modulo', 'remainder', 'calculation', 'iteration']", "prompt_tokens": 663, "total_tokens": 1013, "completion_tokens": 350, "completion": "[Question 2]\n\nYou are participating in a coding contest and the current challenge requires you to solve the \"Pendulum Product\" problem. The problem statement is as follows: You are given an integer array. The pendulum product of the array is calculated as follows: arrange the elements of the array in a pendulum fashion, i.e., the largest element, then the second smallest, then the second largest, and so on. Finally, calculate the product of all these arranged elements, and find the remainder when divided by a given integer n.\n\nWrite a function to calculate the pendulum product of the given array and find the remainder when divided by n. \n\n[/Question 2]\n\n[Code 2]\n\ndef pendulumProductModulo(arr: List[int], n: int) -> int :\n    arr.sort()\n    result = 1\n    i, j = 0, len(arr) - 1\n    while i <= j:\n        if i != j:\n            result = (result * arr[j] * arr[i]) % n\n        else:\n            result = (result * arr[i]) % n\n        i += 1\n        j -= 1\n    return result\n\n[/Code 2]\n\n[Asserts 2]\n\nassert pendulumProductModulo([3, 5, 2, 8, 4], 10) == 2\nassert pendulumProductModulo([1, 2, 3, 4, 5, 6], 7) == 6\nassert pendulumProductModulo([7, 5, 3, 9, 11], 12) == 2\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['string', 'vowels', 'consonants', 'swap', 'adjacent', 'characters', 'moves', 'minimum']", "prompt_tokens": 568, "total_tokens": 886, "completion_tokens": 318, "completion": "[Question 2]\n\nYou are given a string s consisting of lowercase English letters. Write a Python function to determine the minimum number of moves required to swap two adjacent characters in the string to maximize the number of local maximum points in the string. A local maximum is defined as a character that is strictly greater than its adjacent characters.\n\n[/Question 2]\n\n[Code 2]\n\ndef minMovesForLocalMax(s: str) -> int:\n    moves = 0\n    n = len(s)\n    \n    for i in range(1, n):\n        if s[i] > s[i - 1] and (i == n - 1 or s[i] > s[i + 1]):\n            continue\n        elif s[i] < s[i - 1]:\n            moves += 1\n            s = s[:i-1] + s[i] + s[i-1] + s[i+1:]\n        elif i == n - 1 or s[i] < s[i + 1]:\n            moves += 1\n            s = s[:i] + s[i+1] + s[i] + s[i+2:]\n    \n    return moves\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minMovesForLocalMax(\"abcd\")==0\nassert minMovesForLocalMax(\"dcba\")==3\nassert minMovesForLocalMax(\"aaaaaa\")==0\nassert minMovesForLocalMax(\"cbad\")==3\nassert minMovesForLocalMax(\"abcde\")==0\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['equilateral triangle', 'area', 'biggest', 'inscribed', 'square']", "prompt_tokens": 465, "total_tokens": 742, "completion_tokens": 277, "completion": "[Question 2]\n\nWrite a function to find the combined area of the biggest square that can be inscribed within an equilateral triangle and the biggest square in a Pascal triangle, and return whether the combined area is a valid number by checking whether the Most Significant Bit (MSB) is set.\n\n[/Question 2]\n\n[Code 2]\n\ndef combinedAreaAndValidity(side: float, rows: int) -> (float, bool):\n    area_of_equilateral_triangle = (math.sqrt(3)*side*side)/4\n    area_of_pascal_triangle_square = 4**rows\n    combined_area = area_of_equilateral_triangle + area_of_pascal_triangle_square\n    msb_set = (combined_area & (combined_area-1)) == 0\n    return combined_area, msb_set\n\n[/Code 2]\n\n[Asserts 2]\n\nassert combinedAreaAndValidity(4.0, 3) == (22.92820323027551, False)\nassert combinedAreaAndValidity(6.0, 4) == (61.58845726811989, False)\nassert combinedAreaAndValidity(8.0, 5) == (111.71281292110204, False)\nassert combinedAreaAndValidity(10.0, 6) == (173.30127018922194, False)", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'integer', 'minimum', 'difference', 'maximum', 'pick', 'sort', 'range']", "prompt_tokens": 570, "total_tokens": 883, "completion_tokens": 313, "completion": "[Question 2]\n\nGiven an array of integers, find the minimum possible difference between the maximum and minimum elements of all the subarrays of size K. If the difference of a subarray is the absolute value of the difference between its maximum and minimum elements, what is the minimum possible difference among all subarrays of size K?\n\nWrite a function that takes an array of integers and an integer K as input and returns the minimum possible difference among all subarrays of size K.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef minSubarrayDifference(arr: List[int], K: int) -> int:\n    arr.sort()\n    n = len(arr)\n    min_diff = float('inf')\n    for i in range(n-K+1):\n        subarray_diff = arr[i+K-1] - arr[i]\n        min_diff = min(min_diff, subarray_diff)\n    return min_diff\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minSubarrayDifference([1, 3, 6, 8, 10, 15], 3) == 2\nassert minSubarrayDifference([5, 3, 8, 10, 15], 3) == 4\nassert minSubarrayDifference([5, 3, 8, 10, 15], 1) == 0\nassert minSubarrayDifference([8, 16, 83, 144], 3) == 115\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'product', 'subarray', 'divisible', 'iteration', 'math']", "prompt_tokens": 623, "total_tokens": 977, "completion_tokens": 354, "completion": "[Question 2]\n\nYou are building a system to process customer purchase data. Given an array of customer tags and their purchase amounts, write a method to find the maximum product of the purchase amounts for a subarray of customer data where the total purchase amount is divisible by a given number.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef maxProductSubarrayWithDivisibleSum(tags: List[str], amounts: List[int], target: int) -> int:\n    maxVal = float('-inf')\n    n = len(amounts)\n    for i in range(n):\n        product = 1\n        for j in range(i, n):\n            product *= amounts[j]\n            if product % target == 0 and product > maxVal:\n                maxVal = product\n    return maxVal\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maxProductSubarrayWithDivisibleSum(['A', 'B', 'C'], [1, 2, 3], 2) == 2\nassert maxProductSubarrayWithDivisibleSum(['A', 'B', 'C', 'D'], [10, 5, 7, 8], 5) == 40\nassert maxProductSubarrayWithDivisibleSum(['A', 'B', 'C', 'D', 'E'], [3, 4, 6, 2, 8], 3) == 48\nassert maxProductSubarrayWithDivisibleSum(['A', 'B'], [6, 7], 3) == -inf\nassert maxProductSubarrayWithDivisibleSum(['A'], [12], 2) == 12\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['substring', 'common', 'character', 'minimum', 'length', 'search', 'set', 'index']", "prompt_tokens": 539, "total_tokens": 865, "completion_tokens": 326, "completion": "[Question 2]\n\nGiven a set of strings, find the minimum length of the substring that is common in all the strings. If there is no common substring, return -1.\n\n[/Question 2]\n\n[Code 2]\n\ndef minCommonSubstringLength(str_set):\n    if len(str_set) == 0:\n        return -1\n    if len(str_set) == 1:\n        return len(str_set[0])\n    common_substring = \"\"\n    min_length = float('inf')\n    for i in range(len(str_set[0])):\n        for j in range(i, len(str_set[0])):\n            substring = str_set[0][i:j+1]\n            if all(substring in x for x in str_set[1:]):\n                if len(substring) < min_length:\n                    min_length = len(substring)\n                    common_substring = substring\n    return len(common_substring) if common_substring else -1\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minCommonSubstringLength({\"abcdef\",\"abcdxyz\",\"abcfxyz\",\"abcmnopq\",\"abcefgh\"})==-1\nassert minCommonSubstringLength({\"abcdef\",\"abcdxyz\",\"abcfxyz\",\"abcefabcfxyz\",\"abcefgh\"})==3\nassert minCommonSubstringLength({\"pqr\",\"pqrst\",\"pqrstuvw\",\"pqrxyz\"})==3\nassert minCommonSubstringLength({\"abc\",\"def\",\"ghi\"})==-1\nassert minCommonSubstringLength({\"abc\",\"def\",\"ghi\",\"jkl\",\"abdef\"})==1\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'sum', 'XOR', 'construct', 'feasibility', 'binary', 'integer', 'size']", "prompt_tokens": 557, "total_tokens": 820, "completion_tokens": 263, "completion": "[Question 2]\n\nGiven an array of integers, write a function to check the feasibility of splitting the array into two halves such that the XOR of the first half is equal to the XOR of the second half. If feasible, return True, otherwise return False.\n\n[/Question 2]\n\n[Code 2]\n\ndef isXorSplitFeasible(arr: List[int]) -> bool:\n    total_xor = 0\n    for num in arr:\n        total_xor ^= num\n    n = len(arr)\n    prefix_xor = 0\n    for i in range(n):\n        prefix_xor ^= arr[i]\n        suffix_xor = total_xor ^ prefix_xor\n        if prefix_xor == suffix_xor:\n            return True\n    return False\n\n[/Code 2]\n\n[Asserts 2]\n\nassert isXorSplitFeasible([4, 6, 2, 3]) == True\nassert isXorSplitFeasible([5, 5, 5, 5, 5]) == True\nassert isXorSplitFeasible([1, 2, 3, 4]) == False\nassert isXorSplitFeasible([1, 2, 4, 8]) == False\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['positive', 'integer', 'construct', 'largest number', 'sum', 'costs', 'digits']", "prompt_tokens": 765, "total_tokens": 1137, "completion_tokens": 372, "completion": "[Question 2]\n\nGiven a list of positive integers and their associated costs, write a Python function to construct the largest number using these integers such that the sum of the costs of its digits is minimized. \n\n[/Question 2]\n\n[Code 2]\n\ndef constructLargestNumber(nums: list, costs: list) -> str:\n    num_cost_map = dict(zip(nums, costs))\n    num_cost_map = dict(sorted(num_cost_map.items(), key=lambda x: x[0], reverse=True))\n    \n    result = \"\"\n    for key, value in num_cost_map.items():\n        if value <= min(costs):\n            break\n        while value in costs:\n            result += str(key)\n            costs.remove(value)\n    return result\n\n[/Code 2]\n\n[Asserts 2]\n\nassert constructLargestNumber([2, 5, 4, 8, 9], [3, 4, 2, 5, 1]) == \"99854\"\nassert constructLargestNumber([10, 15, 30, 22, 15], [1, 2, 3, 1, 3]) == \"303022151510\"\nassert constructLargestNumber([20, 35, 67, 45, 28], [4, 6, 7, 9, 2]) == \"67452835420\"\nassert constructLargestNumber([5, 9, 13, 18, 12], [2, 3, 1, 4, 5]) == \"985312\"\nassert constructLargestNumber([3, 6, 9, 12, 15], [1, 1, 1, 1, 1]) == \"1591263\"\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'subsequence', 'sum', 'maximum', 'increasing', 'integer', 'length']", "prompt_tokens": 599, "total_tokens": 836, "completion_tokens": 237, "completion": "[Question 2]\n\nGiven a list of integers, find the length of the maximum sum increasing subsequence.\n\n[/Question 2]\n\n[Code 2]\n\ndef lengthOfMaxSumIncreasingSubsequence(nums):\n    n = len(nums)\n    dp = [0] * n\n    for i in range(n):\n        dp[i] = nums[i]\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + nums[i])\n    return max(dp)\n\n[/Code 2]\n\n[Asserts 2]\n\nassert lengthOfMaxSumIncreasingSubsequence([1, 101, 2, 3, 100, 4, 5]) == 106\nassert lengthOfMaxSumIncreasingSubsequence([3, 4, 5, 10]) == 22\nassert lengthOfMaxSumIncreasingSubsequence([10, 5, 4, 3]) == 10\nassert lengthOfMaxSumIncreasingSubsequence([3, 2, 6, 4, 5, 1]) == 15\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'integers', 'frequency', 'digit', 'maximum', 'smallest']", "prompt_tokens": 613, "total_tokens": 988, "completion_tokens": 375, "completion": "[Question 2]\n\nYou are given an array of integers and an integer K. Your task is to find the starting number in the array that requires the smallest number of allowed moves to transform its digits such that it has the maximum frequency of the digit K. An allowed move is defined as flipping the sign of any integer in the array.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef minMovesForMaxFreqDigitK(arr: List[int], k: int) -> int:\n    min_moves = float('inf')\n    result = 0\n    for num in arr:\n        moves = 0\n        num_copy = abs(num)\n        while num_copy > 0:\n            if num_copy % 10 != k:\n                moves += 1\n            num_copy //= 10\n        if moves < min_moves or (moves == min_moves and num < result):\n            min_moves = moves\n            result = num\n    return result\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minMovesForMaxFreqDigitK([123, 34, 22, 443, 446], 4) == 34\nassert minMovesForMaxFreqDigitK([423, 34, 22, 443, 446], 4) == 34\nassert minMovesForMaxFreqDigitK([99, 888, 7777, 66666], 7) == 7777\nassert minMovesForMaxFreqDigitK([11, 22, 33, 44, 55, 66], 6) == 11\nassert minMovesForMaxFreqDigitK([123456, 78985, 98745, 13569, 35498], 8) == 78985\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['string', 'password', 'strength', 'character count', 'validation']", "prompt_tokens": 566, "total_tokens": 859, "completion_tokens": 293, "completion": "[Question 2]\n\nYou have been given a large string representing a password. Your task is to determine if the password is strong enough. A strong password should have a length of at least 8 characters and should contain at least one uppercase letter, one lowercase letter, one digit, and one special character. Write a Python function to validate whether the given password meets the strength criteria.\n\n[/Question 2]\n\n[Code 2]\n\nimport re\n\ndef is_strong_password(password: str) -> bool:\n    if len(password) < 8:\n        return False\n    if not re.search(\"[a-z]\", password):\n        return False\n    if not re.search(\"[A-Z]\", password):\n        return False\n    if not re.search(\"[0-9]\", password):\n        return False\n    if not re.search(\"[!@#$%^&*()_+{}:<>?]\", password):\n        return False\n    return True\n\n[/Code 2]\n\n[Asserts 2]\n\nassert is_strong_password(\"Password123!\") == True\nassert is_strong_password(\"weakpass\") == False\nassert is_strong_password(\"no1Uppercase\") == False\nassert is_strong_password(\"n0sp3cialChar\") == False\nassert is_strong_password(\"Short6!\") == False\nassert is_strong_password(\"StrongP@ssw0rd\") == True\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['factorial', 'division', 'power', 'math', 'algorithm']", "prompt_tokens": 428, "total_tokens": 847, "completion_tokens": 419, "completion": "[Question 2]\n\nDesign an algorithm to determine if it is feasible to divide a given list of integers into two neighboring sublists such that the sum of factorials of elements in each sublist is equal.\n\n[/Question 2]\n\n[Code 2]\n\ndef isFeasibleToDivideIntoEqualFactorialSumSublists(arr: List[int]) -> bool :\n    total_sum = sum(arr)\n    if total_sum % 2 != 0:\n        return False\n    target_sum = total_sum // 2\n    \n    fact = [1]\n    for i in range(1, max(arr) + 1):\n        fact.append(fact[-1] * i)\n    \n    dp = [False] * (target_sum + 1)\n    dp[0] = True\n    for x in arr:\n        for j in range(target_sum, x - 1, -1):\n            dp[j] |= dp[j - x]\n    \n    return dp[target_sum] and factSumExists(arr, target_sum, fact)\n\ndef factSumExists(arr, target_sum, fact):\n    for i in range(1<<len(arr)):\n        temp_sum = 0\n        for j in range(len(arr)):\n            if i & (1<<j):\n                temp_sum += fact[arr[j]]\n        if temp_sum == target_sum:\n            return True\n    return False\n\n[/Code 2]\n\n[Asserts 2]\n\nassert isFeasibleToDivideIntoEqualFactorialSumSublists([1, 2, 3, 4, 5])==True\nassert isFeasibleToDivideIntoEqualFactorialSumSublists([2, 2, 3, 4, 5])==True\nassert isFeasibleToDivideIntoEqualFactorialSumSublists([1, 2, 3, 4, 9])==False\nassert isFeasibleToDivideIntoEqualFactorialSumSublists([1, 2, 3, 4, 6])==False", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['quadratic', 'equations', 'common', 'roots', 'discriminant', 'math', 'boolean']", "prompt_tokens": 660, "total_tokens": 992, "completion_tokens": 332, "completion": "[Question 2]\n\nGiven a matrix representing a table of quadratic equations, where each row contains the coefficients of a quadratic equation in the form of ax^2 + bx + c = 0, find and return True if there exists a common root in the middle column of the table. Otherwise, return False.\n\n[/Question 2]\n\n[Code 2]\n\ndef haveCommonRoot(matrix: List[List[int]]) -> bool:\n    for row in matrix:\n        a, b, c = row[0], row[1], row[2]\n        discriminant = b**2 - 4*a*c\n        if discriminant >= 0:\n            root1 = (-b + math.sqrt(discriminant)) / (2*a)\n            root2 = (-b - math.sqrt(discriminant)) / (2*a)\n            if root1 == root2:\n                if matrix[matrix.index(row)][1] == root1:\n                    return True\n    return False\n\n[/Code 2]\n\n[Asserts 2]\n\nassert haveCommonRoot([\n    [1, -5, 6],\n    [1, -6, 9],\n    [1, -4, 4]\n]) == True\n\nassert haveCommonRoot([\n    [1, -5, 6],\n    [1, -7, 12],\n    [1, -4, 4]\n]) == False\n\nassert haveCommonRoot([\n    [1, -1, -6],\n    [1, -2, 1],\n    [1, -9, 20]\n]) == True\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['positive integer', 'count', 'possible numbers', 'length', 'digits', 'leading zeros', 'math']", "prompt_tokens": 490, "total_tokens": 665, "completion_tokens": 175, "completion": "[Question 2]\n\nGiven a positive integer N, the task is to count the number of positive integers with exactly N digits that can be formed by rearranging the digits 1 to N such that no digit is repeated and no leading zeros are allowed.\n\n[/Question 2]\n\n[Code 2]\n\nfrom math import factorial\n\ndef countValidNumbers(N: int) -> int:\n\tif N == 1:\n\t\treturn 1\n\telif N == 2:\n\t\treturn 1\n\t\n\tans = factorial(N - 1)\n\treturn ans\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countValidNumbers(1) == 1\nassert countValidNumbers(2) == 1\nassert countValidNumbers(3) == 2\nassert countValidNumbers(4) == 6\nassert countValidNumbers(5) == 24", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['coin', 'denomination', 'sum', 'limited', 'ways', 'count']", "prompt_tokens": 528, "total_tokens": 838, "completion_tokens": 310, "completion": "[Question 2]\n\nWrite a Python function to convert an RGB color to its equivalent HSV representation and count the number of colors that have a specific relation in terms of their HSV components.\n\n[/Question 2]\n\n[Code 2]\n\nimport colorsys\n\ndef countColorsWithRelation(colors, relation):\n    count = 0\n    for color in colors:\n        r, g, b = color\n        hsv = colorsys.rgb_to_hsv(r/255.0, g/255.0, b/255.0)\n        # Check the relation condition here and update the count accordingly\n    return count\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countColorsWithRelation([(255, 0, 0), (0, 255, 0), (0, 0, 255)], 'bright')==3\nassert countColorsWithRelation([(128, 128, 128), (255, 255, 255), (0, 0, 0)], 'dark')==1\nassert countColorsWithRelation([(255, 255, 255), (255, 0, 0), (0, 255, 0), (0, 0, 255)], 'vivid')==4\nassert countColorsWithRelation([(255, 255, 255), (255, 255, 0), (255, 0, 255), (0, 255, 255)], 'saturated')==4\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'sorting', 'swaps', 'minimum', 'distinct', 'increasing', 'order', 'cycle', 'visiting']", "prompt_tokens": 619, "total_tokens": 957, "completion_tokens": 338, "completion": "[Question 2]\n\nGiven an array of n integers where each element represents the digits of a number, the task is to rearrange the array elements such that the number formed by concatenating the elements is minimum. We need to find the minimum number of swaps required to reorder the array elements to form the smallest number.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef minSwapForMinNum(nums: List[int]) -> int:\n    nums_with_index = [(num, i) for i, num in enumerate(nums)]\n    nums_with_index.sort(key=lambda x: str(x[0]))\n    visited = [False] * len(nums)\n    swaps = 0\n    for i in range(len(nums)):\n        if visited[i] or nums_with_index[i][1] == i:\n            continue\n        cycle_size = 0\n        j = i\n        while not visited[j]:\n            visited[j] = True\n            j = nums_with_index[j][1]\n            cycle_size += 1\n        if cycle_size > 0:\n            swaps += (cycle_size - 1)\n    return swaps\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minSwapForMinNum([3, 30, 34, 5, 9])==3\nassert minSwapForMinNum([1, 20, 29, 3, 99])==2\nassert minSwapForMinNum([10, 7, 4, 3])==1\nassert minSwapForMinNum([9, 5, 12, 6, 3])==2\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['series', 'term', 'sequence', 'recursive', 'calculation', 'math']", "prompt_tokens": 460, "total_tokens": 748, "completion_tokens": 288, "completion": "[Question 2]\n\nWrite a recursive function to calculate the Nth term of a series where each term is the semi-perimeter of a cuboid whose sides are consecutive numbers in a given sequence. For example, for the sequence 3, 4, 5, the series would be the semi-perimeter of (3, 4, 5), (4, 5, 6), (5, 6, 7), and so on.\n\n[/Question 2]\n\n[Code 2]\n\ndef nthTermOfCuboidSemiPerimeter(n: int, sequence: list) -> int:\n    if n == 1:\n        return sequence[0] + sequence[1] + sequence[2]\n    else:\n        return nthTermOfCuboidSemiPerimeter(n-1, [x+1 for x in sequence])\n\n[/Code 2]\n\n[Asserts 2]\n\nassert nthTermOfCuboidSemiPerimeter(1, [3, 4, 5])==12\nassert nthTermOfCuboidSemiPerimeter(2, [3, 4, 5])==15\nassert nthTermOfCuboidSemiPerimeter(3, [3, 4, 5])==18\nassert nthTermOfCuboidSemiPerimeter(4, [3, 4, 5])==21", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['ellipse', 'latus rectum', 'major axis', 'minor axis', 'perpendicular', 'foci', 'formula', 'calculate', 'length']", "prompt_tokens": 597, "total_tokens": 835, "completion_tokens": 238, "completion": "[Question 2]\n\nYou have been given the major axis 'a' and the minor axis 'b' of an ellipse. The task is to calculate the maximum distance between any point on the ellipse and its latus rectum. The maximum distance is at the endpoints of the major axis and is equal to 'a'.\n\nWrite a function to calculate and return the maximum distance between the ellipse and its latus rectum given the major axis 'a' and the minor axis 'b'.\n\n[/Question 2]\n\n[Code 2]\n\ndef maxDistanceFromLatusRectum(a: float, b: float) -> float:\n    return a\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maxDistanceFromLatusRectum(5, 3) == 5\nassert maxDistanceFromLatusRectum(8, 4) == 8\nassert maxDistanceFromLatusRectum(10, 6) == 10\nassert maxDistanceFromLatusRectum(6, 2) == 6\nassert maxDistanceFromLatusRectum(7, 5) == 7\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['string', 'consonant', 'sequence', 'replace', 'count']", "prompt_tokens": 552, "total_tokens": 816, "completion_tokens": 264, "completion": "[Question 2]\n\nYou are given a string containing numbers. The string represents a sequence of check sum digits for a series of cocktail glass orders. Each check sum digit represents the count of cocktail glasses for a particular sequence. Replace the check sum digits in the string with the actual count of glasses and return the updated string.\n\nWrite a Python function to replace the check sum digits with the actual count of glasses in the given string.\n\n[/Question 2]\n\n[Code 2]\n\ndef replaceCheckSum(string: str) -> str:\n    newString = ''\n    i = 0\n    while i < len(string):\n        if string[i].isdigit():\n            count = int(string[i])\n            newString += '8' * count\n            i += 1\n        else:\n            newString += string[i]\n            i += 1\n    return newString\n\n[/Code 2]\n\n[Asserts 2]\n\nassert replaceCheckSum(\"1496251\") == \"8888888884462255\"\nassert replaceCheckSum(\"231073\") == \"8881173\"\nassert replaceCheckSum(\"928100\") == \"8888888822100\"\nassert replaceCheckSum(\"111\") == \"888\"\nassert replaceCheckSum(\"809\") == \"88209\"\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['string', 'substring', 'consecutive', 'contiguous', 'length', 'characters', 'iteration', 'max', 'ord']", "prompt_tokens": 537, "total_tokens": 805, "completion_tokens": 268, "completion": "[Question 2]\n\nGiven a string s, determine if the string can be split into two non-empty substrings, such that the absolute difference between the lengths of the two substrings is at most 1 and the characters in the substrings form consecutive numbers in an arithmetic progression.\n\n[/Question 2]\n\n[Code 2]\n\ndef validArithmeticSplit(s: str) -> bool:\n    n = len(s)\n    for i in range(1, n):\n        prefix = s[:i]\n        suffix = s[i:]\n        if abs(len(prefix) - len(suffix)) > 1:\n            continue\n        if prefix == \"\" or suffix == \"\":\n            continue\n        if len(set(prefix)) != len(prefix) or len(set(suffix)) != len(suffix):\n            continue\n        if ord(prefix[0]) - 1 in map(ord, prefix) and ord(suffix[0]) - 1 in map(ord, suffix):\n            return True\n    return False\n\n[/Code 2]\n\n[Asserts 2]\n\nassert validArithmeticSplit(\"123456\")==True\nassert validArithmeticSplit(\"91011\")==True\nassert validArithmeticSplit(\"123\")==False\nassert validArithmeticSplit(\"1\")==False\nassert validArithmeticSplit(\"122345\")==False\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'minimum', 'rotations', 'non-decreasing', 'sorted']", "prompt_tokens": 557, "total_tokens": 932, "completion_tokens": 375, "completion": "[Question 2]\n\nYou are given a board of integers, represented as a 2D array. The task is to find the minimum number of rotations needed to make each row of the board sorted in non-decreasing order (not necessarily in ascending order). \n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\ndef minRowRotations(board: List[List[int]]) -> int:\n    def minRotations(arr: List[int]) -> int:\n        n = len(arr)\n        temp_arr = arr.copy()\n        temp_arr.sort()\n        rotations = 0\n        for _ in range(n):\n            if arr == temp_arr:\n                break\n            ele = arr[0]\n            for j in range(n-1):\n                arr[j] = arr[j+1]\n            arr[n-1] = ele\n            rotations += 1\n        return rotations\n\n    min_rotations = 0\n    for row in board:\n        min_rotations += minRotations(row)\n    return min_rotations\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minRowRotations([[3, 4, 2, 1], [8, 7, 6, 5], [0, 2, 1, 3]]) == 4\nassert minRowRotations([[1, 2, 3, 4], [5, 6, 7, 8], [0, 0, 0, 1]]) == 0\nassert minRowRotations([[5, 4, 3, 2, 1]]) == 4\nassert minRowRotations([[7, 6, 5, 4], [3, 2, 1, 0]]) == 2\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['sum', 'polygon', '20-sided', 'math', 'series']", "prompt_tokens": 440, "total_tokens": 587, "completion_tokens": 147, "completion": "[Question 2]\n\nIn graph theory, a maximal planar graph is a graph in which adding any edge would destroy the property of being planar. Consider a maximal planar graph with a 20-sided polygon. The task is to find the sum of the degrees of all the vertices in the graph.\n\n[/Question 2]\n\n[Code 2]\n\ndef sum_of_vertex_degrees(sides: int) -> int:\n    return 2 * sides\n\n[/Code 2]\n\n[Asserts 2]\n\nassert sum_of_vertex_degrees(20)==40\nassert sum_of_vertex_degrees(10)==20\nassert sum_of_vertex_degrees(5)==10\nassert sum_of_vertex_degrees(30)==60", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['string', 'palindrome', 'halves', 'check', 'comparison', 'boolean']", "prompt_tokens": 519, "total_tokens": 730, "completion_tokens": 211, "completion": "[Question 2]\n\nWrite a function to check if a given date in the format \"MM/DD/YYYY\" is a palindrome date or not. Return True if the date is a palindrome, otherwise return False. A palindrome date is a date that reads the same forwards and backwards.\n\n[/Question 2]\n\n[Code 2]\n\ndef isPalindrome(s: str) -> bool:\n    return s == s[::-1]\n\ndef isPalindromeDate(date: str) -> bool:\n    date_str = date.replace(\"/\", \"\")\n    return isPalindrome(date_str)\n\n[/Code 2]\n\n[Asserts 2]\n\nassert isPalindromeDate(\"02/02/2020\")==True\nassert isPalindromeDate(\"11/12/2021\")==False\nassert isPalindromeDate(\"12/11/2021\")==True\nassert isPalindromeDate(\"05/11/2021\")==False\nassert isPalindromeDate(\"10/02/2001\")==True\nassert isPalindromeDate(\"01/22/2022\")==True\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['string', 'character', 'search', 'binary', 'ascending', 'order', 'comparison']", "prompt_tokens": 540, "total_tokens": 1061, "completion_tokens": 521, "completion": "[Question 2]\n\nYou are given a Deterministic Finite Automaton (DFA) that accepts strings of decimal digits with at most one missing digit. Write a function to determine if a given string is accepted by the DFA. The DFA is defined by its transitions and initial/final states.\n\n[/Question 2]\n\n[Code 2]\n\nclass DFA:\n    def __init__(self, transitions, initial, final):\n        self.transitions = transitions\n        self.initial = initial\n        self.final = final\n\n    def is_valid_string(self, s):\n        state = self.initial\n        for char in s:\n            if char.isdigit():\n                state = self.transitions.get((state, int(char)), None)\n                if state is None:\n                    return False  # missing digit found\n            else:\n                return False  # non-digit character found\n        return state in self.final\n\n[/Code 2]\n\n[Asserts 2]\n\n# Example DFA for accepting strings with at most one missing digit\ntransitions = {\n    (1, 0): 2, (1, 1): 2, (1, 2): 2, (1, 3): 2, (1, 4): 2, (1, 5): 2, (1, 6): 2, (1, 7): 2, (1, 8): 2, (1, 9): 2,\n    (2, 0): 3, (2, 1): 3, (2, 2): 3, (2, 3): 3, (2, 4): 3, (2, 5): 3, (2, 6): 3, (2, 7): 3, (2, 8): 3, (2, 9): 3,\n}\ninitial_state = 1\nfinal_states = {2, 3}\n\ndfa = DFA(transitions, initial_state, final_states)\nassert dfa.is_valid_string(\"123\") == True\nassert dfa.is_valid_string(\"45\") == True\nassert dfa.is_valid_string(\"8\") == True\nassert dfa.is_valid_string(\"9\") == True\nassert dfa.is_valid_string(\"01\") == True\nassert dfa.is_valid_string(\"ABC\") == False\nassert dfa.is_valid_string(\"12A4\") == False\nassert dfa.is_valid_string(\"12345\") == False\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'integers', 'sum', 'absolute differences', 'removal', 'sorting']", "prompt_tokens": 623, "total_tokens": 930, "completion_tokens": 307, "completion": "[Question 2]\n\nYou are given two sorted arrays of integers. Write a function to merge the arrays and return the sum of absolute differences between the elements at odd indices after removing any one element from the merged array.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\ndef mergeAndSumOddIndexDifferences(arr1: List[int], arr2: List[int]) -> int:\n    merged = sorted(arr1 + arr2)\n    n = len(merged)\n    oddSum = 0\n    for i in range(1, n, 2):\n        oddSum += merged[i]\n    minDiff = float('inf')\n    for i in range(n):\n        if i > 0:\n            minDiff = min(minDiff, abs(oddSum - merged[i-1]))\n        if i < n-1:\n            minDiff = min(minDiff, abs(oddSum - merged[i+1]))\n    return minDiff\n\n[/Code 2]\n\n[Asserts 2]\n\nassert mergeAndSumOddIndexDifferences([1, 3, 5], [2, 4, 6]) == 3\nassert mergeAndSumOddIndexDifferences([5, 7, 9], [1, 2, 3, 4]) == 3\nassert mergeAndSumOddIndexDifferences([10, 20, 30], [15, 25, 35]) == 25\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['triangle', 'geometry', 'math', 'sides', 'equilateral', 'isosceles', 'scalene']", "prompt_tokens": 561, "total_tokens": 807, "completion_tokens": 246, "completion": "[Question 2]\n\nYou are given the lengths of the sides of a triangle. Write a function to determine if the triangle is valid, and if valid, calculate and return the perimeter of the triangle.\n\nA triangle is valid if the sum of the lengths of any two sides is greater than the length of the third side. If the triangle is valid, the perimeter can be calculated as the sum of the side lengths.\n\nWrite a function to check the validity of the triangle and calculate its perimeter if valid.\n\n[/Question 2]\n\n[Code 2]\n\ndef trianglePerimeter(side1: int, side2: int, side3: int) -> float:\n    if side1 + side2 > side3 and side2 + side3 > side1 and side1 + side3 > side2:\n        return side1 + side2 + side3\n    else:\n        return 0.0\n\n[/Code 2]\n\n[Asserts 2]\n\nassert trianglePerimeter(3, 4, 5) == 12\nassert trianglePerimeter(5, 9, 3) == 17\nassert trianglePerimeter(2, 2, 8) == 0.0", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['string', 'subsequence', 'dynamic programming', 'length', 'common', '3 strings', 'algorithm']", "prompt_tokens": 705, "total_tokens": 1222, "completion_tokens": 517, "completion": "[Question 2]\n\nYou are given three singly linked lists representing three strings. The task is to find the length of the longest common subsequence in the three strings using dynamic programming.\n\n[/Question 2]\n\n[Code 2]\n\nclass ListNode:\n    def __init__(self, value=0, next=None):\n        self.value = value\n        self.next = next\n\ndef LCSof3LinkedList(head1: ListNode, head2: ListNode, head3: ListNode) -> int:\n    dp = [[[0 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    \n    curr1, curr2, curr3 = head1, head2, head3\n    while curr1:\n        while curr2:\n            while curr3:\n                if curr1.value == curr2.value == curr3.value:\n                    dp[curr1][curr2][curr3] = dp[curr1-1][curr2-1][curr3-1] + 1\n                else:\n                    dp[curr1][curr2][curr3] = max(max(dp[curr1-1][curr2][curr3], dp[curr1][curr2-1][curr3]), dp[curr1][curr2][curr3-1])\n                curr3 = curr3.next\n            curr3 = head3\n            curr2 = curr2.next\n        curr2 = head2\n        curr1 = curr1.next\n    \n    return dp[head1][head2][head3]\n\n[/Code 2]\n\n[Asserts 2]\n\n# Example linked lists representing \"ABC\", \"AC\", and \"BC\"\nlst1 = ListNode('A', ListNode('B', ListNode('C')))\nlst2 = ListNode('A', ListNode('C'))\nlst3 = ListNode('B', ListNode('C'))\nassert LCSof3LinkedList(lst1, lst2, lst3) == 2\n\n# Example linked lists representing \"AGGTAB\", \"GXTXAYB\", and \"GTAB\"\nlst4 = ListNode('A', ListNode('G', ListNode('G', ListNode('T', ListNode('A', ListNode('B'))))))\nlst5 = ListNode('G', ListNode('X', ListNode('T', ListNode('X', ListNode('A', ListNode('Y', ListNode('B'))))))\nlst6 = ListNode('G', ListNode('T', ListNode('A', ListNode('B'))))\nassert LCSof3LinkedList(lst4, lst5, lst6) == 4\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'integer', 'subset', 'size', 'element', 'multiple']", "prompt_tokens": 643, "total_tokens": 1059, "completion_tokens": 416, "completion": "[Question 2]\n\nYou are given a maze represented by a 2D array maze of integers. Each cell can contain either 0 or 1. \n\nFind the smallest divisor of the sum of the last cells of all possible subsets of the maze.\n\nThe last cell is the cell with coordinates (n-1, m-1) in a maze of size n x m.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\ndef smallestDivisorOfSubsetSum(maze: List[List[int]])-> int:\n    n = len(maze)\n    m = len(maze[0])\n    lastCellSum = 0\n    for i in range(1, n):\n        maze[i][0] += maze[i-1][0]\n    for j in range(1, m):\n        maze[0][j] += maze[0][j-1]\n\n    for i in range(1, n):\n        for j in range(1, m):\n            maze[i][j] += max(maze[i-1][j], maze[i][j-1])\n\n    return maze[n-1][m-1]\n\n[/Code 2]\n\n[Asserts 2]\n\nassert smallestDivisorOfSubsetSum([[1, 3, 1], [3, 3, 3], [1, 3, 1]]) == 4\nassert smallestDivisorOfSubsetSum([[1, 3, 5], [7, 9, 11], [13, 15, 17]]) == 13\nassert smallestDivisorOfSubsetSum([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 9\nassert smallestDivisorOfSubsetSum([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]) == 32\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'subsequence', 'special operation', 'minimum', 'sequence', 'remove', 'element']", "prompt_tokens": 508, "total_tokens": 766, "completion_tokens": 258, "completion": "[Question 2]\n\nYou are given an array of workloads representing the amount of work assigned to each worker. You need to perform a special operation to remove a subsequence of workloads with minimal total workload, until the minimum element is greater than a given threshold T. Write a function to find the minimum number of special operations required to achieve this condition.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\ndef minSpecialOperations(workloads: List[int], T: int) -> int:\n    min_element = min(workloads)\n    operations = 0\n    while min_element <= T:\n        workloads.remove(min_element)\n        min_element = min(workloads)\n        operations += 1\n    return operations\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minSpecialOperations([4, 3, 5, 7, 6], 6) == 2\nassert minSpecialOperations([3, 2, 1, 21, 22, 24, 23], 7) == 3\nassert minSpecialOperations([7, 1000, 5, 3, 2, 7, 8], 10) == 1\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['geometry', 'cylinder', 'cube', 'inscribed', 'diagonal', 'math', 'sqrt']", "prompt_tokens": 533, "total_tokens": 772, "completion_tokens": 239, "completion": "[Question 2]\n\nYou are given a 2D grid representing a seating arrangement in a cinema, with each cell representing a seat. Write a function to determine the maximum number of cubes that can be inscribed within the grid by rotating them in any direction, taking into account the 1-based indexing of the seats.\n\n[/Question 2]\n\n[Code 2]\n\ndef maxInscribedCubes(seatingGrid: List[str]) -> int:\n    rows = len(seatingGrid)\n    cols = len(seatingGrid[0])\n    \n    min_dimension = min(rows, cols)\n\n    return min_dimension // 2\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maxInscribedCubes([\"LLLL\", \"LLLL\", \"LLLL\", \"LLLL\"]) == 2\nassert maxInscribedCubes([\"RRRRR\", \"LLLLL\", \"LLLLL\"]) == 2\nassert maxInscribedCubes([\"RLRL\", \"LRLR\", \"RLRL\", \"LRLR\"]) == 1\nassert maxInscribedCubes([\"RL\", \"LR\"]) == 0\nassert maxInscribedCubes([\"R\"]) == 0", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'integers', 'rearrange', 'prefix sum', 'prime numbers', 'sorting', 'math', 'conditional', 'division', 'sorting']", "prompt_tokens": 708, "total_tokens": 1201, "completion_tokens": 493, "completion": "[Question 2]\n\nYou are given an array of integers representing the positions of Rooks on a chessboard. Rearrange the array in such a way that if a Rook can attack another Rook, they must be adjacent in the rearranged array. Return the rearranged array or return None if no rearrangement is possible.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\ndef canAttack(pos1: int, pos2: int) -> bool:\n    # Check if two Rooks can attack each other\n    return pos1 // 8 == pos2 // 8 or pos1 % 8 == pos2 % 8\n\ndef rearrangeRooks(rookPositions: List[int]) -> List[int]:\n    size = len(rookPositions)\n    graph = [[0 for _ in range(size)] for _ in range(size)]\n    sortedPositions = sorted(rookPositions)\n    \n    for i in range(size):\n        for j in range(i+1, size):\n            if canAttack(sortedPositions[i], sortedPositions[j]):\n                graph[i][j] = 1\n                graph[j][i] = 1\n    \n    rearranged = [rookPositions[0]]\n    used = {0}\n    current = 0\n    while len(rearranged) < size:\n        found = False\n        for i in range(size):\n            if graph[current][i] == 1 and i not in used:\n                rearranged.append(rookPositions[i])\n                used.add(i)\n                current = i\n                found = True\n                break\n        if not found:\n            return None\n    \n    return rearranged\n\n[/Code 2]\n\n[Asserts 2]\n\nassert rearrangeRooks([0, 8, 16, 24, 1, 9, 17, 25])==[0, 8, 16, 24, 1, 9, 17, 25]\nassert rearrangeRooks([0, 3, 5, 24, 30, 33, 17, 25])==None\nassert rearrangeRooks([2, 8, 6, 16, 15, 9, 17, 25])==[2, 8, 9, 16, 17, 15, 25, 6]\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'integers', 'composite', 'Fibonacci', 'count', 'perfect square', 'comparison']", "prompt_tokens": 637, "total_tokens": 955, "completion_tokens": 318, "completion": "[Question 2]\n\nYou are given an array of integers. Write a function to count the number of perfect square numbers in the array and return the sum of their integral points.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\ndef isPerfectSquare(n: int) -> bool:\n    if n < 0:\n        return False\n    sqrt_n = int(n**0.5)\n    return sqrt_n*sqrt_n == n\n\ndef countPerfectSquareIntegralPoints(arr: List[int]) -> int:\n    count = 0\n    sum_integral_points = 0\n    for num in arr:\n        if isPerfectSquare(num):\n            count += 1\n            sum_integral_points += int(num**0.5)\n    return sum_integral_points\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countPerfectSquareIntegralPoints([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])==6\nassert countPerfectSquareIntegralPoints([0, 1, 4, 9, 16, 25, 36])==14\nassert countPerfectSquareIntegralPoints([64, 81, 100, 121, 144])==50\nassert countPerfectSquareIntegralPoints([17, 24, 36, 49, 71, 81, 100])==30\nassert countPerfectSquareIntegralPoints([144, 225, 256, 324, 400])==100\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['cashier', 'queue', 'customers', 'notes', 'serve', 'exact amount', 'possible', 'integers', 'list', 'available']", "prompt_tokens": 660, "total_tokens": 1045, "completion_tokens": 385, "completion": "[Question 2]\n\nAs a cashier at a bank, you are required to manage the queue of customers efficiently. The customers are grouped, and each group presents a list of integer notes to be cashed. Write a function to determine if it is possible for the cashier to serve all the groups in a way that meets the exact amount requested by each group. The available notes for each group are provided as a list of integers. Use the breadth-first search algorithm to find out if it is possible to serve all the groups or not, returning True if possible and False otherwise.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\nfrom collections import deque\n\ndef isServePossible(groups: List[List[int]], availableNotes: List[int]) -> bool:\n    queue = deque([(0, 0)])\n\n    while queue:\n        currentIndex, currentAmount = queue.popleft()\n        \n        if currentIndex == len(groups):\n            return True\n        \n        if currentIndex < len(groups):\n            for note in availableNotes:\n                nextAmount = currentAmount + note\n                queue.append((currentIndex + 1, nextAmount))\n        \n    return False\n\n[/Code 2]\n\n[Asserts 2]\n\nassert isServePossible([[10, 20, 50], [100]], [10, 20, 50, 100])==True\nassert isServePossible([[20, 30, 50], [100, 200]], [10, 20, 50, 100])==False\nassert isServePossible([[5, 10], [20, 25, 50, 100]], [5, 10, 20, 50])==True\nassert isServePossible([[23, 45], [89, 100]], [1, 2, 5, 10, 20, 50, 100])==False\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['prime', 'number', 'sum', 'combination', 'SieveOfEratosthenes', 'minimum']", "prompt_tokens": 624, "total_tokens": 1077, "completion_tokens": 453, "completion": "[Question 2]\n\nGiven a list of numbers, find the minimum prime number from the list and its successor. If there are multiple prime numbers in the list, return the combination with the minimum sum of the prime number and its successor.\n\n[/Question 2]\n\n[Code 2]\n\ndef SieveOfEratosthenes(n: int) -> list:\n    prime = [True] * (n+1)\n    p = 2\n    while (p * p <= n):\n        if (prime[p] == True):\n            for i in range(p * p, n+1, p):\n                prime[i] = False\n        p += 1\n    prime[0]= False\n    prime[1]= False\n    primes = []\n    for p in range(n+1):\n        if prime[p]:\n            primes.append(p)\n    return primes\n\ndef minPrimeSuccessor(nums: list) -> (int, int):\n    min_prime = float('inf')\n    min_sum = float('inf')\n    primes = SieveOfEratosthenes(max(nums))\n    for num in nums:\n        if num in primes:\n            idx = primes.index(num)\n            if idx < len(primes) - 1:\n                successor = primes[idx + 1]\n                if num + successor < min_sum:\n                    min_sum = num + successor\n                    min_prime = num\n    return min_prime, min_sum\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minPrimeSuccessor([3, 8, 11, 5, 4, 7, 13, 6]) == (3, 6)\nassert minPrimeSuccessor([2, 3, 7, 10, 11, 13]) == (2, 4)\nassert minPrimeSuccessor([5, 12, 15, 17, 20, 22, 23]) == (5, 10)\nassert minPrimeSuccessor([2, 3, 5, 7, 11, 13, 17, 19, 23, 29]) == (2, 4)\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}]