[{"keywords": "['array', 'merge', 'prefix sum', 'maximum', 'integer', 'prefix sum', 'iteration', 'prefix sum']", "prompt_tokens": 630, "total_tokens": 988, "completion_tokens": 358, "completion": "[Question 2]\n\nYou are given an array of integers. Write a function to find the maximum value among all the elements in the array. Also, determine the number of occurrences of this maximum value in the array. Additionally, check if the array contains any cycles in it, where a cycle is defined as a subarray where the sum of its elements is zero. \n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\ndef maxOccurrenceAndCheckCycles(arr: List[int]) -> (int, int, bool):\n    maxVal = float('-inf')\n    maxCount = 0\n    for num in arr:\n        if num > maxVal:\n            maxVal = num\n            maxCount = 1\n        elif num == maxVal:\n            maxCount += 1\n    \n    prefixSum = 0\n    prefixSums = set()\n    hasCycle = False\n    for num in arr:\n        prefixSum += num\n        if prefixSum in prefixSums or prefixSum == 0:\n            hasCycle = True\n            break\n        prefixSums.add(prefixSum)\n    \n    return maxVal, maxCount, hasCycle\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maxOccurrenceAndCheckCycles([1, 2, 3, 3, 2, 1]) == (3, 2, True)\nassert maxOccurrenceAndCheckCycles([1, 2, 3, 4, 5]) == (5, 1, False)\nassert maxOccurrenceAndCheckCycles([3, 0, -4, 2, 1]) == (3, 1, False)\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['positive', 'integer', 'sum', 'perfect', 'cubes', 'math', 'iteration']", "prompt_tokens": 505, "total_tokens": 720, "completion_tokens": 215, "completion": "[Question 2]\n\nWrite a function that takes a positive integer n as input and returns the count of perfect cubes that are less than or equal to n and have a symmetric sum of their digits.\n\n[/Question 2]\n\n[Code 2]\n\ndef isSymmetric(num: int) -> bool:\n\treturn str(num) == str(num)[::-1]\n\ndef countSymmetricCubes(n: int) -> int:\n\tcount = 0\n\tfor i in range(1, int(n ** (1/3)) + 1):\n\t\tcube = i ** 3\n\t\tif isSymmetric(cube) and cube <= n:\n\t\t\tcount += 1\n\treturn count\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countSymmetricCubes(100) == 4\nassert countSymmetricCubes(1000) == 10\nassert countSymmetricCubes(500) == 3\nassert countSymmetricCubes(50) == 1\nassert countSymmetricCubes(1) == 1", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['integer', 'natural number', 'digit', 'removal', 'pattern']", "prompt_tokens": 455, "total_tokens": 700, "completion_tokens": 245, "completion": "[Question 2]\n\nGiven a list of numeric strings, find the longest numeric string removing any string that is a Bakhshali Approximation of a natural number.\n\n[/Question 2]\n\n[Code 2]\n\ndef isBakhshaliApproximation(s: str) -> bool:\n    # Logic to check if the string is a Bakhshali Approximation\n    pass\n\ndef longestNumericString(strings: List[str]) -> str:\n    maxLen = 0\n    maxStr = \"\"\n    for s in strings:\n        if not isBakhshaliApproximation(s) and len(s) > maxLen:\n            maxLen = len(s)\n            maxStr = s\n    return maxStr\n\n[/Code 2]\n\n[Asserts 2]\n\nassert longestNumericString(['12', '25', '49', '77', '169', '256', '500']) == '500'\nassert longestNumericString(['5', '8', '15', '32', '50', '83', '109']) == '109'\nassert longestNumericString(['100', '121', '144', '289', '361', '441', '625']) == '625'", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['circular', 'rotation', 'shift', 'digits', 'check', 'boolean']", "prompt_tokens": 541, "total_tokens": 823, "completion_tokens": 282, "completion": "[Question 2]\n\nGiven an array of integers, implement a function to check if there exist three integers in the array that can form a collinear sequence when their digits are shifted circularly. A collinear sequence is such that the digits of the three integers form a line in a specific order when shifted circularly. Return True if such a sequence exists, otherwise return False.\n\n[/Question 2]\n\n[Code 2]\n\ndef existCollinearSequence(arr: List[int]) -> bool:\n    def checkCollinear(a, b, c):\n        return (b - a) == (c - b)\n    \n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            for k in range(j+1, len(arr)):\n                if checkCollinear(arr[i], arr[j], arr[k]):\n                    return True\n    return False\n\n[/Code 2]\n\n[Asserts 2]\n\nassert existCollinearSequence([123, 231, 312, 456]) == True\nassert existCollinearSequence([123, 456, 789]) == False\nassert existCollinearSequence([111, 222, 333, 444]) == True\nassert existCollinearSequence([123, 521, 312, 456]) == False\nassert existCollinearSequence([112, 121, 211]) == True", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'quadruples', 'product', 'pair', 'count', 'multiplication', 'math', 'combinations']", "prompt_tokens": 655, "total_tokens": 1024, "completion_tokens": 369, "completion": "[Question 2]\n\nYou are given an array of unsigned integers. Find the count of quadruples (i, j, k, l) present in the array, such that i < j < k < l and the product of the subarray [i, j] is equal to the product of the subarray [k, l].\n\n[/Question 2]\n\n[Code 2]\n\nfrom collections import defaultdict\nfrom typing import List\n\ndef countEqualProductQuadruples(nums: List[int]) -> int:\n    n = len(nums)\n    count = 0\n    product_map = defaultdict(list)\n    result = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            product_map[nums[i] * nums[j]].append((i, j))\n    for i in range(n):\n        for k in range(i + 1, n):\n            product = nums[i] * nums[k]\n            for pair in product_map[product]:\n                if pair[0] > k:\n                    result += 1\n    return result\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countEqualProductQuadruples([2, 3, 5, 7, 11]) == 0\nassert countEqualProductQuadruples([1, 2, 4, 8, 16]) == 2\nassert countEqualProductQuadruples([3, 3, 9, 9, 27]) == 4\nassert countEqualProductQuadruples([1, 4, 16, 64, 256]) == 4\nassert countEqualProductQuadruples([10, 5, 3, 6, 15]) == 0\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['combinations', 'permutations', 'identical', 'distinct', 'placement', 'count', 'objects', 'boxes']", "prompt_tokens": 505, "total_tokens": 647, "completion_tokens": 142, "completion": "[Question 2]\n\nYou are given a list of alphanumeric objects and you need to count the distinct permutations of these alphanumeric objects that can be formed.\n\n[/Question 2]\n\n[Code 2]\n\nfrom itertools import permutations\n\ndef countDistinctPermutations(objects: str) -> int:\n    perms = set(permutations(objects))\n    return len(perms)\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countDistinctPermutations(\"abc\") == 6\nassert countDistinctPermutations(\"aab\") == 3\nassert countDistinctPermutations(\"xyz\") == 6\nassert countDistinctPermutations(\"aabb\") == 6\nassert countDistinctPermutations(\"abcd\") == 24", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'integer', 'graph', 'cycle', 'edge', 'representation', 'algorithm']", "prompt_tokens": 547, "total_tokens": 846, "completion_tokens": 299, "completion": "[Question 2]\n\nYou are given a labeled graph as an array of integers, where each index i represents a node labeled with the integer i, and the value at index i represents the node to which there is an edge from node i. Can you write an algorithm to verify if the given graph contains a cycle? \n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\ndef hasCycle(graph: List[int]) -> bool:\n    visited = [False] * len(graph)\n    for i in range(len(graph)):\n        if not visited[i]:\n            if dfs(graph, i, visited, -1):\n                return True\n    return False\n\ndef dfs(graph, node, visited, parent):\n    visited[node] = True\n    for neighbor in graph[node]:\n        if not visited[neighbor]:\n            if dfs(graph, neighbor, visited, node):\n                return True\n        elif neighbor != parent:\n            return True\n    return False\n\n[/Code 2]\n\n[Asserts 2]\n\nassert hasCycle([1, 0, 2, 2, 1])==True\nassert hasCycle([1, 2, 3, 4, 5])==False\nassert hasCycle([1, 2, 1, 4, 5])==True\nassert hasCycle([1, 0, 3, 2])==False\nassert hasCycle([3, 2, 3, 1])==True", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'operation', 'maximize', 'integer']", "prompt_tokens": 673, "total_tokens": 946, "completion_tokens": 273, "completion": "[Question 2]\n\nYou are given an array A of N integers. Perform the following operation at least once to maximize the median of the array:\nChoose any element in the array and add an integer value to it. Determine the least possible number of operations needed to maximize the median of the array.\n\n[/Question 2]\n\n[Code 2]\n\ndef maximizeMedian(arr: list) -> int:\n    arr.sort()\n    n = len(arr)\n    median = arr[n // 2]\n    operations = 0\n    for i in range(n // 2, n):\n        if arr[i] < median:\n            operations += median - arr[i]\n    return operations\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maximizeMedian([1, 2, 3, 4, 5]) == 6\nassert maximizeMedian([5, 4, 3, 2, 1]) == 6\nassert maximizeMedian([3, 1, 4, 6, 2]) == 3\nassert maximizeMedian([10, 10, 10, 10, 10, 10]) == 0\nassert maximizeMedian([5, 7, 3, 8, 2, 6, 4]) == 8\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['binary', 'matrix', 'swaps', 'adjacent', 'distinct', 'pair', 'row', 'column', 'bitwise', 'manipulation']", "prompt_tokens": 758, "total_tokens": 1176, "completion_tokens": 418, "completion": "[Question 2]\n\nGiven a binary matrix of size N x M, write a function to compute the number of adjacent pairs of elements that are coprime. Two elements are considered adjacent if they are in the same row and adjacent columns, or in the same column and adjacent rows.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef count_coprime_pairs(matrix: List[List[int]]) -> int:\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n    pairs = 0\n    m, n = len(matrix), len(matrix[0])\n    for i in range(m):\n        for j in range+1,n):\n            if matrix[i][j] == 1:\n                pairs += sum(gcd(matrix[i][j], matrix[i][k]) == 1 for k in (j-1, j+1))\n    for j in range(n):\n        for i in range+1,m):\n            if matrix[i][j] == 1:\n                pairs += sum(gcd(matrix[i][j], matrix[k][j]) == 1 for k in (i-1, i+1))\n    return pairs\n\n[/Code 2]\n\n[Asserts 2]\n\nassert count_coprime_pairs([[0, 1, 0], [1, 0, 1], [0, 1, 0]]) == 2\nassert count_coprime_pairs([[1, 0], [1, 0], [0, 0]]) == 1\nassert count_coprime_pairs([[1, 0, 0, 1], [0, 0, 1, 1], [1, 0, 1, 0]]) == 1\nassert count_coprime_pairs([[1, 1, 1], [0, 0, 0], [1, 1, 0]]) == 1\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['positive', 'integer', 'coins', 'powers', 'minimum', 'obtain']", "prompt_tokens": 440, "total_tokens": 613, "completion_tokens": 173, "completion": "[Question 2]\n\nGiven a list of positive integers, write a function to obtain the minimum positive power of 2 such that all the elements in the list are less than or equal to this power of 2.\n\n[/Question 2]\n\n[Code 2]\n\ndef minPowerForList(arr):\n    max_val = max(arr)\n    power = 1\n    while power < max_val:\n        power *= 2\n    return power\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minPowerForList([1, 2, 3, 4, 5]) == 8\nassert minPowerForList([1, 2, 4, 8, 16]) == 16\nassert minPowerForList([3, 6, 12, 24, 48]) == 48", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['integer', 'sequence', 'unique', 'LCM', 'math', 'gcd', 'construct', 'longest', 'algorithm']", "prompt_tokens": 577, "total_tokens": 1001, "completion_tokens": 424, "completion": "[Question 2]\n\nGiven a list of integers, find the longest unique sequence such that the LCM of the entire sequence is preserved for the future and it's not possible to construct a longer unique sequence.\n\n[/Question 2]\n\n[Code 2]\n\nfrom math import gcd\n\ndef findLongestUniqueLCMSequence(arr: list) -> list:\n    def LCM(a, b):\n        return abs(a*b) // gcd(a, b)\n\n    maxSeq = []\n    for i in range(len(arr)):\n        seq = []\n        for j in range(i, len(arr)):\n            if arr[j] not in seq and all(LCM(arr[j], x) == x for x in seq):\n                seq.append(arr[j])\n            else:\n                break\n        if len(seq) > len(maxSeq):\n            maxSeq = seq\n    return maxSeq\n\n[/Code 2]\n\n[Asserts 2]\n\nassert findLongestUniqueLCMSequence([2, 3, 5, 6, 10, 12]) == [2, 3, 5, 6, 10]\nassert findLongestUniqueLCMSequence([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]\nassert findLongestUniqueLCMSequence([8, 9, 12, 27, 36, 81]) == [8, 9, 12]\nassert findLongestUniqueLCMSequence([3, 7, 14, 21, 28]) == [3, 7]\nassert findLongestUniqueLCMSequence([2, 4, 8, 16, 18, 32]) == [2, 4, 8, 16]\nassert findLongestUniqueLCMSequence([1, 3, 9, 27, 81, 243, 729]) == [1, 3, 9, 27, 81]\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['range', 'odd', 'even', 'position', 'count', 'digits', 'while loop', 'conditional', 'function']", "prompt_tokens": 592, "total_tokens": 917, "completion_tokens": 325, "completion": "[Question 2]\n\nGiven a list of integers and a specific mathematical operation, write a function to count the number of elements in the list whose value after the operation matches a specific condition.\n\n[/Question 2]\n\n[Code 2]\n\ndef countMatchingElements(arr, operation, condition):\n    count = 0\n    for num in arr:\n        if operation == \"square\":\n            result = num*num\n        elif operation == \"cube\":\n            result = num*num*num\n        # Add more operations as needed\n        else:\n            raise ValueError(\"Unsupported operation\")\n\n        if condition == \"even\" and result % 2 == 0:\n            count += 1\n        elif condition == \"odd\" and result % 2 != 0:\n            count += 1\n\n    return count\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countMatchingElements([1, 2, 3, 4, 5], \"square\", \"even\") == 2\nassert countMatchingElements([1, 2, 3, 4, 5], \"square\", \"odd\") == 3\nassert countMatchingElements([1, 2, 3, 4, 5], \"cube\", \"even\") == 0\nassert countMatchingElements([1, 2, 3, 4, 5], \"cube\", \"odd\") == 5\nassert countMatchingElements([10, 20, 30, 40, 50], \"square\", \"even\") == 5\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['number', 'sum', 'natural numbers', 'alternate', 'signs']", "prompt_tokens": 463, "total_tokens": 692, "completion_tokens": 229, "completion": "[Question 2]\n\nGiven a number N, find the sum of the first N natural numbers with alternate signs, but only considering the first N double cyclic shifts of the alternating signs.\n\n[/Question 2]\n\n[Code 2]\n\ndef sumOfNWithAlternateSignsCyclicShifts(n: int) -> int:\n    total_sum = 0\n    for i in range(1, n*2+1):\n        if i % 2 == 0:\n            total_sum -= i\n        else:\n            total_sum += i\n    return total_sum\n\n[/Code 2]\n\n[Asserts 2]\n\nassert sumOfNWithAlternateSignsCyclicShifts(3) == -1\nassert sumOfNWithAlternateSignsCyclicShifts(4) == 2\nassert sumOfNWithAlternateSignsCyclicShifts(5) == -3\nassert sumOfNWithAlternateSignsCyclicShifts(6) == 3\nassert sumOfNWithAlternateSignsCyclicShifts(7) == -4\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'distinct', 'pairs', 'counting', 'Counter']", "prompt_tokens": 542, "total_tokens": 862, "completion_tokens": 320, "completion": "[Question 2]\n\nYou are given an array of points representing a keypad layout and the task is to write a function to count the number of distinct pairs of points that have a Manhattan distance equal to a given value. \n\n[/Question 2]\n\n[Code 2]\n\nfrom collections import Counter\nfrom typing import List, Tuple\n\ndef countManhattanDistancePairs(keypad: List[Tuple[int, int]], distance: int) -> int:\n\n    def manhattanDistance(p1: Tuple[int, int], p2: Tuple[int, int]) -> int:\n        return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n\n    count = Counter([manhattanDistance(p1, p2) for p1 in keypad for p2 in keypad if p1 != p2])\n    return count[distance] // 2\n\n[/Code 2]\n\n[Asserts 2]\n\nkeypad = [(0, 0), (1, 0), (2, 0), (0, 1), (1, 1), (2, 1), (0, 2), (1, 2), (2, 2)]\nassert countManhattanDistancePairs(keypad, 1) == 20\nassert countManhattanDistancePairs(keypad, 2) == 28\nassert countManhattanDistancePairs(keypad, 3) == 16\nassert countManhattanDistancePairs(keypad, 4) == 0\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['class', 'mode', 'stream', 'integer', 'insert', 'getMode', 'update', 'frequency']", "prompt_tokens": 616, "total_tokens": 980, "completion_tokens": 364, "completion": "[Question 2]\n\nYou are given a stream of integers and you need to implement a class that updates the mode as new integers are inserted. Additionally, the class should have a method to calculate the frequency of each integer and also calculate the hamming distance between two integers. Implement a class with these functionalities.\n\n[/Question 2]\n\n[Code 2]\n\nclass ModeFrequencyCalculator:\n    def __init__(self):\n        self.data = {}\n        self.mode = None\n        self.max_freq = 0\n\n    def insert(self, num: int):\n        self.data[num] = self.data.get(num, 0) + 1\n        if self.data[num] > self.max_freq:\n            self.mode = num\n            self.max_freq = self.data[num]\n\n    def getMode(self) -> int:\n        return self.mode\n\n    def calculateFrequency(self, num: int) -> int:\n        return self.data.get(num, 0)\n\n    def calculateHammingDistance(self, num1: int, num2: int) -> int:\n        xor_result = num1 ^ num2\n        distance = 0\n        while xor_result:\n            distance += xor_result & 1\n            xor_result >>= 1\n        return distance\n\n[/Code 2]\n\n[Asserts 2]\n\ncalculator = ModeFrequencyCalculator()\ncalculator.insert(5)\ncalculator.insert(7)\ncalculator.insert(5)\nassert calculator.getMode() == 5\nassert calculator.calculateFrequency(5) == 2\nassert calculator.calculateFrequency(7) == 1\nassert calculator.calculateHammingDistance(4, 14) == 2\ncalculator.insert(7)\ncalculator.insert(7)\ncalculator.insert(9)\nassert calculator.getMode() == 7\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['large number', 'distinct', 'shuffling', 'digits', 'count']", "prompt_tokens": 524, "total_tokens": 727, "completion_tokens": 203, "completion": "[Question 2]\n\nGiven a large number N, find the largest power of 12 less than or equal to N and return the count of distinct digits in the digital sum of this number.\n\n[/Question 2]\n\n[Code 2]\n\ndef largestPowerOfTwelve(N: int) -> int:\n\tpower = 0\n\twhile pow(12, power) <= N:\n\t\tpower += 1\n\treturn power - 1\n\ndef distinctDigitsDigitalSum(N: int) -> int:\n\tpower = largestPowerOfTwelve(N)\n\tnum = pow(12, power)\n\tdigital_sum = sum(int(digit) for digit in str(num))\n\treturn len(set(str(digital_sum)))\n\n[/Code 2]\n\n[Asserts 2]\n\nassert distinctDigitsDigitalSum(100)==3\nassert distinctDigitsDigitalSum(144)==2\nassert distinctDigitsDigitalSum(1728)==2\nassert distinctDigitsDigitalSum(2000)==3\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'integer', 'prime factors', 'exponents', 'divisible', 'math', 'algorithm']", "prompt_tokens": 641, "total_tokens": 919, "completion_tokens": 278, "completion": "[Question 2]\n\nYou are given an array of integers. Write a function to determine the least common multiple of the array elements which are square numbers and the result should be divisible by a given integer x. \n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef lcmOfSquares(arr: List[int], x: int) -> int:\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm(a, b):\n        return a * b // gcd(a, b)\n\n    result = 1\n    for num in arr:\n        sqrt = int(num ** 0.5)\n        if sqrt * sqrt == num:\n            result = lcm(result, num)\n    return result if result % x == 0 else -1\n\n[/Code 2]\n\n[Asserts 2]\n\nassert lcmOfSquares([4, 9, 16, 25], 5) == 100\nassert lcmOfSquares([4, 9, 16, 25], 6) == -1\nassert lcmOfSquares([4, 9, 16, 25], 10) == 100\nassert lcmOfSquares([4, 9, 16, 25], 25) == 100", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['bitwise', 'multiples', 'integer', 'left shift', 'right shift', 'bitwise AND', 'operations']", "prompt_tokens": 540, "total_tokens": 861, "completion_tokens": 321, "completion": "[Question 2]\n\nGiven a binary search tree, write a function to perform an in-order traversal and print only the integers that are even after applying bitwise operations. The function should perform the bitwise AND operation with 1 to check if the number is even and then print the non-increasing sequence of these even integers.\n\n[/Question 2]\n\n[Code 2]\n\nclass TreeNode:\n    def __init__(self, value=0, left=None, right=None):\n        self.value = value\n        self.left = left\n        self.right = right\n\ndef inOrderTraversalEven(root: TreeNode) -> None:\n    stack = []\n    result = []\n    \n    current = root\n    while True:\n        if current is not None:\n            stack.append(current)\n            current = current.left\n        elif stack:\n            current = stack.pop()\n            if current.value & 1 == 0:\n                result.append(current.value)\n            current = current.right\n        else:\n            break\n    \n    result.sort(reverse=True)\n    for val in result:\n        print(val, end=\" \")\n\n[/Code 2]\n\n[Asserts 2]\n\n# Create a binary search tree\nroot = TreeNode(5)\nroot.left = TreeNode(3)\nroot.right = TreeNode(8)\nroot.left.left = TreeNode(2)\nroot.left.right = TreeNode(4)\nroot.right.left = TreeNode(6)\nroot.right.right = TreeNode(9)\n\n# Perform in-order traversal and print only the even integers\ninOrderTraversalEven(root)  # Prints \"4 2\" \n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['number', 'count', 'occurrence', 'digit']", "prompt_tokens": 560, "total_tokens": 752, "completion_tokens": 192, "completion": "[Question 2]\n\nYou are given a list of numbers. Write a function to count the occurrence of a specific digit within the numbers and return the count.\n\n[/Question 2]\n\n[Code 2]\n\ndef count_occurrence_of_digit(numbers: list, digit: int) -> int:\n    count = 0\n    for num in numbers:\n        count += str(num).count(str(digit))\n    return count\n\n[/Code 2]\n\n[Asserts 2]\n\nassert count_occurrence_of_digit([123, 456, 789], 5) == 0\nassert count_occurrence_of_digit([123, 456, 789], 3) == 2\nassert count_occurrence_of_digit([12, 345, 6789], 9) == 2\nassert count_occurrence_of_digit([101, 202, 303], 0) == 1\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['average', 'temperature', 'sum', 'calculation', 'prediction']", "prompt_tokens": 421, "total_tokens": 553, "completion_tokens": 132, "completion": "[Question 2]\n\nGiven a sheet with words of varying lengths, calculate and predict the average word length of the sheet.\n\n[/Question 2]\n\n[Code 2]\n\ndef averageWordLength(sheet: str) -> float:\n    words = sheet.split()\n    total_length = sum(len(word) for word in words)\n    return total_length / len(words)\n\n[/Code 2]\n\n[Asserts 2]\n\nassert averageWordLength(\"I love programming\") == 8\nassert averageWordLength(\"This is a test\") == 3.75\nassert averageWordLength(\"Python is awesome\") == 6\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['integer', 'sum', 'digit', 'pair', 'search', 'conditional', 'iteration']", "prompt_tokens": 546, "total_tokens": 817, "completion_tokens": 271, "completion": "[Question 2]\n\nYou are given an array of integers and an integer K. The task is to find a pair of elements in the array whose sum is less than K and return the count of such pairs.\n\nWrite a function to solve this problem by iterating through the array and using conditional checks.\n\n[/Question 2]\n\n[Code 2]\n\ndef countPairsWithSumLessThanK(arr: list, K: int) -> int:\n\tcount = 0\n\tfor i in range(len(arr)):\n\t\tfor j in range(i+1, len(arr)):\n\t\t\tif arr[i] + arr[j] < K:\n\t\t\t\tcount += 1\n\treturn count\n\n[/Code 2]\n\n[Asserts 2]\n\nassert(countPairsWithSumLessThanK([1, 2, 3, 4, 5], 6)) == 3\nassert(countPairsWithSumLessThanK([5, 7, 9, 11, 13], 20)) == 6\nassert(countPairsWithSumLessThanK([2, 4, 6, 8, 10], 13)) == 6\nassert(countPairsWithSumLessThanK([3, 6, 9, 12, 15], 10)) == 4\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['math', 'modular arithmetic', 'inverse', 'modulo', 'integer', 'pow', 'pair', 'tuple']", "prompt_tokens": 499, "total_tokens": 811, "completion_tokens": 312, "completion": "[Question 2]\n\nYou are given an array of integers. Write a function to find a pair of integers (a, b) from the array such that the squared difference of a and b is maximum modulo a given prime number P.\n\n[/Question 2]\n\n[Code 2]\n\ndef maxSquaredDifferenceModuloPrime(arr: list, P: int) -> tuple:\n\n    arr.sort()\n    N = len(arr)\n    max_diff = 0\n\n    for i in range(N-1, -1, -1):\n        for j in range(i-1, -1, -1):\n            diff = (arr[i] - arr[j]) ** 2 % P\n            if diff > max_diff:\n                max_diff = diff\n                result = (arr[i], arr[j])\n\n    return result\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maxSquaredDifferenceModuloPrime([3, 7, 9, 15, 18], 13) == (18, 3)\nassert maxSquaredDifferenceModuloPrime([1, 5, 9, 11, 15], 17) == (15, 1)\nassert maxSquaredDifferenceModuloPrime([4, 6, 8, 10, 12], 19) == (12, 4)\nassert maxSquaredDifferenceModuloPrime([2, 4, 6, 8, 10], 23) == (10, 2)\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'sum', 'maximize', 'LCM', 'pair', 'integers', 'math']", "prompt_tokens": 649, "total_tokens": 976, "completion_tokens": 327, "completion": "[Question 2]\n\nGiven an array of N integers, the task is to find the pair of integers that maximizes the sum of their LCM (Lowest Common Multiple).\n\n[/Question 2]\n\n[Code 2]\n\ndef gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef lcm(a, b):\n    return (a * b) // gcd(a, b)\n\ndef findMaxLCMSum(arr: list, N: int) -> list:\n    max_sum = 0\n    max_pair = []\n    for i in range(N):\n        for j in range(i+1, N):\n            current_sum = lcm(arr[i], arr[j])\n            if current_sum > max_sum:\n                max_sum = current_sum\n                max_pair = [arr[i], arr[j]]\n    return max_pair\n\n[/Code 2]\n\n[Asserts 2]\n\nassert findMaxLCMSum([1, 2, 3, 4, 5], 5) == [4, 5]\nassert findMaxLCMSum([4, 5, 7, 12, 8, 3, 1], 7) == [4, 5]\nassert findMaxLCMSum([8, 10, 5, 3, 12], 5) == [8, 12]\nassert findMaxLCMSum([10, 15, 20, 25, 30], 5) == [20, 30]\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'integer', 'subarray', 'sum', 'divisible', 'length', 'prefix', 'modulo']", "prompt_tokens": 630, "total_tokens": 997, "completion_tokens": 367, "completion": "[Question 2]\n\nGiven an array of integers, we need to find the length of the longest subarray with a non-increasing prefix sum where the total sum is divisible by a given integer K.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\ndef longestSubarrayWithNonIncreasingSumDivisibleByK(arr: List[int], K: int) -> int:\n    prefixSum = 0\n    maxLen = 0\n    prefixSums = {0: -1}\n    \n    for i in range(len(arr)):\n        prefixSum += arr[i]\n        prefixSum %= K\n        \n        if prefixSum in prefixSums:\n            maxLen = max(maxLen, i - prefixSums[prefixSum])\n        else:\n            prefixSums[prefixSum] = i\n        \n    return maxLen\n\n[/Code 2]\n\n[Asserts 2]\n\nassert(longestSubarrayWithNonIncreasingSumDivisibleByK([3, 1, 2, 7, 5], 4)) == 4\nassert(longestSubarrayWithNonIncreasingSumDivisibleByK([3, 1, 2, 7, 5], 4)) == 4\nassert(longestSubarrayWithNonIncreasingSumDivisibleByK([5, 2, 7, 1, 6], 3)) == 2\nassert(longestSubarrayWithNonIncreasingSumDivisibleByK([4, 5, 0, -2, -3, 1], 5)) == 5\nassert(longestSubarrayWithNonIncreasingSumDivisibleByK([1, 2, 3, 4, 5], 5)) == 0\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['positive', 'numbers', 'operations', 'convert', 'minimum', 'steps', 'multiply', 'subtract', 'iterate', 'even', 'odd', 'approach']", "prompt_tokens": 616, "total_tokens": 910, "completion_tokens": 294, "completion": "[Question 2]\n\nYou are given a probability distribution of waiting times for customers at a bank counter. The waiting times are given in odd integers representing minutes. You need to write a program to calculate the minimum waiting time encountered for customers whose waiting times are even minutes.\n\nWrite a function to find the minimum waiting time encountered for customers with even waiting times.\n\n[/Question 2]\n\n[Code 2]\n\ndef minWaitingTime(waitingTimes: list) -> int:\n    minEvenTime = float('inf')\n    for time in waitingTimes:\n        if time % 2 == 0 and time < minEvenTime:\n            minEvenTime = time\n    if minEvenTime == float('inf'):\n        return -1  # No even waiting time encountered\n    else:\n        return minEvenTime\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minWaitingTime([3, 5, 8, 2, 4, 7, 10]) == 2\nassert minWaitingTime([1, 3, 5, 7, 9, 11, 13]) == -1\nassert minWaitingTime([6, 8, 10, 12, 14, 16, 18]) == 6\nassert minWaitingTime([5, 10, 15, 20, 25, 30]) == 10\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['integer', 'counting', 'quadruplets', 'math', 'loop', 'range', 'condition', 'equality']", "prompt_tokens": 564, "total_tokens": 877, "completion_tokens": 313, "completion": "[Question 2]\n\nGiven a range of integers from 1 to N, the task is to find the count of quadruplets (A, B, C, D) such that A + B = C + D and their decimal equivalent is opened at the beginning of the centre.\n\nWrite a function countDecimalQuadruplets(N: int) that returns the count of such quadruplets.\n\n[/Question 2]\n\n[Code 2]\n\ndef countDecimalQuadruplets(N: int) -> int:\n    count = 0\n    for A in range(1, N+1):\n        for B in range(1, N+1):\n            for C in range(1, N+1):\n                for D in range(1, N+1):\n                    if A + B == C + D:\n                        decimal_equiv_A = float(A) / 10\n                        decimal_equiv_B = float(B) / 10\n                        decimal_equiv_C = float(C) / 10\n                        decimal_equiv_D = float(D) / 10\n                        if str(decimal_equiv_A + decimal_equiv_B).startswith(str(decimal_equiv_C + decimal_equiv_D)):\n                            count += 1\n    return count\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countDecimalQuadruplets(5)==10\nassert countDecimalQuadruplets(10)==35\nassert countDecimalQuadruplets(3)==2\nassert countDecimalQuadruplets(2)==1\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'pairs', 'indices', 'sum', 'distinct', 'count', 'sort', 'task']", "prompt_tokens": 601, "total_tokens": 854, "completion_tokens": 253, "completion": "[Question 2]\n\nYou are given an array of integers and a target value. Write a function to find the number of distinct pairs of indices (i, j) in the array, such that the sum of the elements at those indices is equal to the target value. The pairs must consist of distinct indices and the pairs should be sorted based on the first index.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\ndef countDistinctPairsWithSum(arr: List[int], target: int) -> int:\n    arr.sort()\n    pairs = set()\n    n = len(arr)\n    for i in range(n):\n        for j in range(i+1, n):\n            if arr[i] + arr[j] == target:\n                pairs.add((arr[i], arr[j]))\n    return len(pairs)\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countDistinctPairsWithSum([1, 3, 2, 2], 4)==2\nassert countDistinctPairsWithSum([3, 1, 4, 1, 5], 5)==1\nassert countDistinctPairsWithSum([1, 2, 3, 4, 5], 7)==2", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'prefix', 'sum', 'integer', 'value', 'prefixes', 'greater', 'than', 'equal']", "prompt_tokens": 697, "total_tokens": 955, "completion_tokens": 258, "completion": "[Question 2]\n\nWrite a method to check if the sum of the integers in the array is greater than the given integer value for the plaintext string. If the sum of the integers is greater than the given value, then calculate the HSV value and check if the two prefixes are equal.\n\n[/Question 2]\n\n[Code 2]\n\ndef checkPrefixSumGreaterThanValue(array: List[int], value: int, plaintext: str) -> bool:\n    integerSum = sum(array)\n    if integerSum > value:\n        # Calculate HSV value\n        hsvValue = calculateHSVValue(plaintext)\n        # Check if the two prefixes are equal\n        return array[:len(array)//2] == array[len(array)//2:]\n    return False\n\ndef calculateHSVValue(plaintext: str) -> int:\n    # Calculate and return the HSV value\n    pass\n\n[/Code 2]\n\n[Asserts 2]\n\nassert checkPrefixSumGreaterThanValue([6, 7, 8, 9, 5, 4], 20, \"exampleplaintext\") == True\nassert checkPrefixSumGreaterThanValue([1, 2, 3, 4, 5, 6], 15, \"programming\") == False\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['positive integer', 'series', 'sum', 'difference', 'product', 'natural numbers', 'math']", "prompt_tokens": 473, "total_tokens": 637, "completion_tokens": 164, "completion": "[Question 2]\n\nYou are given a positive integer N. Write a function to determine the sum of a series formed by the product of equiangular natural numbers ending at N.\n\n[/Question 2]\n\n[Code 2]\n\ndef equiangularSeriesSum(n: int) -> int:\n    result = 0\n    product = 1\n    for i in range(1, n + 1):\n        product *= i\n        result += product\n    return result\n\n[/Code 2]\n\n[Asserts 2]\n\nassert equiangularSeriesSum(3)==9\nassert equiangularSeriesSum(5)==153\nassert equiangularSeriesSum(1)==1\nassert equiangularSeriesSum(2)==3\nassert equiangularSeriesSum(4)==33", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'divisibility', 'count', 'element', 'integer', 'nested loop']", "prompt_tokens": 582, "total_tokens": 974, "completion_tokens": 392, "completion": "[Question 2]\n\nYou are given an array of integers. Write a function to find and return the count of emirpimes in the array. An emirpime is a prime number that results in a different prime when its digits are reversed.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\ndef is_prime(num: int) -> bool:\n\tif num < 2:\n\t\treturn False\n\tfor i in range(2, int(num ** 0.5) + 1):\n\t\tif num % i == 0:\n\t\t\treturn False\n\treturn True\n\ndef reverse_num(num: int) -> int:\n\treversed_num = 0\n\twhile num > 0:\n\t\treversed_num = (reversed_num * 10) + (num % 10)\n\t\tnum = num // 10\n\treturn reversed_num\n\ndef is_emirpime(num: int) -> bool:\n\tif is_prime(num):\n\t\treversed_num = reverse_num(num)\n\t\treturn is_prime(reversed_num) and reversed_num != num\n\treturn False\n\ndef count_emirpimes(arr: List[int]) -> int:\n\tcount = 0\n\tfor num in arr:\n\t\tif is_emirpime(num):\n\t\t\tcount += 1\n\treturn count\n\n[/Code 2]\n\n[Asserts 2]\n\nassert count_emirpimes([13, 17, 31, 37, 79, 113, 199, 919, 1097])==6\nassert count_emirpimes([2, 3, 5, 7, 11, 101, 131, 151, 191, 313])==10\nassert count_emirpimes([23, 29, 47, 53, 97, 109, 149, 151, 353, 757])==8\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'pairs', 'even', 'count', 'integers', 'odd', 'elements']", "prompt_tokens": 563, "total_tokens": 829, "completion_tokens": 266, "completion": "[Question 2]\n\nGiven an array arr of N integers, the task is to count the number of pairs in the array such that the sum of the pair is even.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef countPairsWithEvenSum(arr: List[int]) -> int:\n    even_count = 0\n    odd_count = 0\n    for num in arr:\n        if num % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n    result = even_count * odd_count + (even_count * (even_count - 1)) // 2\n    return result\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countPairsWithEvenSum([1, 2, 3, 4, 5, 6])==8\nassert countPairsWithEvenSum([2, 4, 6, 8, 10])==10\nassert countPairsWithEvenSum([1, 3, 5, 7, 9])==0\nassert countPairsWithEvenSum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])==20\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['integer', 'divisor', 'coprime', 'sum', 'count', 'gcd', 'loops']", "prompt_tokens": 520, "total_tokens": 868, "completion_tokens": 348, "completion": "[Question 2]\n\nYou are given a list of integers representing the weights of items and a weight capacity. Each item belongs to a certain category. Write a function to transform the list into a series of sublists, where each sublist contains the integers of a particular category whose sum is coprime with the weight capacity.\n\n[/Question 2]\n\n[Code 2]\n\ndef gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef transformCategories(weights, capacity, categories):\n    result = []\n    category_sets = {category: [] for category in categories}\n    for weight, category in zip(weights, categories):\n        category_sets[category].append(weight)\n    \n    for category, category_items in category_sets.items():\n        coprime_sublist = []\n        for item in category_items:\n            if gcd(sum(coprime_sublist) + item, capacity) == 1:\n                coprime_sublist.append(item)\n        if coprime_sublist:\n            result.append(coprime_sublist)\n            \n    return result\n\n[/Code 2]\n\n[Asserts 2]\n\nassert transformCategories([3, 7, 5, 10, 8, 6], 11, [1, 2, 1, 2, 1, 2]) == [[7, 5], [10, 8, 6]]\nassert transformCategories([4, 9, 6, 12, 8, 5], 14, [1, 2, 1, 2, 1, 2]) == [[9, 5], [12, 8]]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['prime number', 'conversion', 'positive integers', 'reducing', 'math', 'boolean']", "prompt_tokens": 614, "total_tokens": 986, "completion_tokens": 372, "completion": "[Question 2]\n\nYou are given a list of positive integers representing the attendance time of students in seconds. Your task is to calculate the total time a student has attended the class by reducing the prime numbers from the given attendance time list. Return the total time the student has attended the class in timedelta format.\n\n[/Question 2]\n\n[Code 2]\n\nfrom datetime import timedelta\n\ndef isPrime(n: int) -> bool: \n\tif n <= 1: \n\t\treturn False\n\tif n <= 3: \n\t\treturn True\n\tif n % 2 == 0 or n % 3 == 0: \n\t\treturn False\n\t\n\tfor i in range(5, int(n**0.5) + 1, 6): \n\t\tif n % i == 0 or n %(i + 2) == 0: \n\t\t\treturn False\n\treturn True\n\ndef calculateAttendanceTime(attendance_list: List[int]) -> timedelta:\n    total_time_attended = 0\n    for time in attendance_list:\n        if isPrime(time):\n            total_time_attended += time\n    return timedelta(seconds=total_time_attended)\n\n[/Code 2]\n\n[Asserts 2]\n\nassert calculateAttendanceTime([10, 20, 30, 40, 50])==timedelta(seconds=0)\nassert calculateAttendanceTime([11, 19, 5, 7, 13])==timedelta(seconds=55)\nassert calculateAttendanceTime([2, 3, 5, 7, 11])==timedelta(seconds=28)\nassert calculateAttendanceTime([15, 25, 35, 45, 55])==timedelta(seconds=0)\nassert calculateAttendanceTime([17, 23, 29, 31, 37])==timedelta(seconds=137)", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['tree', 'undirected', 'sum', 'divisors', 'maximum', 'minimum', 'integer', 'modulus']", "prompt_tokens": 634, "total_tokens": 1259, "completion_tokens": 625, "completion": "[Question 2]\n\nGiven an undirected tree with N nodes, each containing an integer value, the task is to find the maximum size of a square subgraph in the given tree. A square subgraph is defined as a subgraph with 4 distinct vertices where all 4 vertices have integer values such that the sum of any two vertices is a perfect square. Return -1 if no such subgraph exists.\n\n[/Question 2]\n\n[Code 2]\n\nfrom collections import defaultdict\nfrom math import sqrt\n \ndef checkSquare(n:int)->bool:\n    cnt = 0\n    \n    for i in range(1, int(sqrt(n)) + 1):\n        if (n % i == 0):\n            if (n // i == i):\n                cnt += 1\n            else:\n                cnt += 2\n    if (sqrt(n) == int(sqrt(n))):\n        cnt -= 1\n    return (cnt == 4)\n\ndef maxSquareSubgraph(N:int, value:List[int], edges:List[Tuple[int,int]])->int:\n    mod = 1000000007\n    res, i, j, k = 0, 0, 0, 0\n    adjList = defaultdict(list)\n\n    for e in edges:\n        adjList[e[0]].append(e[1])\n        adjList[e[1]].append(e[0])\n\n    for i in range(1, N+1):\n        for j in range(i+1, N+1):\n            if value[i-1] > value[j-1] and checkSquare(value[i-1] + value[j-1]):\n                for k in range(len(adjList[i])):\n                    if checkSquare(value[i-1]+value[adjList[i][k]-1]) and value[adjList[i][k]-1] < value[j-1]:\n                        for l in range(len(adjList[j])):\n                            if checkSquare(value[j-1]+value[adjList[j][l]-1]) and value[adjList[j][l]-1] < value[i-1] and checkSquare(value[i-1]+value[adjList[j][l]-1]) and checkSquare(value[j-1]+value[adjList[i][k]-1]):\n                                res = max(res,4)\n    if (res == 0):\n        return -1\n    return res\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maxSquareSubgraph(4, [1, 3, 8, 10], [(1,2), (2,3), (2,4)])==-1\nassert maxSquareSubgraph(4, [1, 4, 3, 2], [(1,2), (2,3), (2,4)])==4\nassert maxSquareSubgraph(5, [2, 3, 5, 1, 7],[(1,4),(4,5),(2,3),(1,2)])==-1\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['python', 'program', 'number', 'centered cubic', 'figurate', 'arrangement', 'formula', 'boolean']", "prompt_tokens": 532, "total_tokens": 755, "completion_tokens": 223, "completion": "[Question 2]\n\nWrite a Python program to determine if a given number is a Heptagonal Number. A heptagonal number is a figurate number that represents a heptagon in a centered arrangement of points, determined by the formula 5n^2 - 3n. The program should return True if the given number is a heptagonal number, else it should return False.\n\n[/Question 2]\n\n[Code 2]\n\ndef is_heptagonal_number(num: int) -> bool:\n    n = int(((40*num + 9)**0.5 + 3) / 10)\n    return n * (5*n - 3) == num\n\n[/Code 2]\n\n[Asserts 2]\n\nassert is_heptagonal_number(7)==False\nassert is_heptagonal_number(50)==False\nassert is_heptagonal_number(76)==True\nassert is_heptagonal_number(105)==True\nassert is_heptagonal_number(133)==False\nassert is_heptagonal_number(162)==True\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['geometric series', 'product', 'term', 'common ratio', 'Python program', 'iteration']", "prompt_tokens": 499, "total_tokens": 833, "completion_tokens": 334, "completion": "[Question 2]\n\nWrite a Python program to determine if a given array of numbers forms a geometric series. If so, determine the common ratio and the product of the terms. Return \"None\" if the array does not form a geometric series.\n\n[/Question 2]\n\n[Code 2]\n\ndef isGeometricSeries(arr: list) -> (bool, int, int):\n    if len(arr) < 2:\n        return (False, None, None)\n\n    ratio = arr[1] / arr[0]\n    for i in range(1, len(arr) - 1):\n        if arr[i + 1] / arr[i] != ratio:\n            return (False, None, None)\n\n    return (True, ratio, arr[0] * (ratio ** (len(arr) - 1)))\n\n[/Code 2]\n\n[Asserts 2]\n\nassert isGeometricSeries([2, 4, 8, 16, 32]) == (True, 2, 64)\nassert isGeometricSeries([3, 6, 12, 24, 48]) == (True, 2, 96)\nassert isGeometricSeries([1, 3, 9, 27, 81]) == (True, 3, 243)\nassert isGeometricSeries([5, 10, 20, 40, 80]) == (True, 2, 160)\nassert isGeometricSeries([2, 4, 7, 14, 28]) == (False, None, None)\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['math', 'number theory', 'array', 'lcm', 'least common multiple', 'gcd', 'algorithm', 'iteration']", "prompt_tokens": 622, "total_tokens": 918, "completion_tokens": 296, "completion": "[Question 2]\n\nYou are given an array representing hundreds of employees' grades. Each employee has a unique grade such that the grades range from 1 to 100. Write a function to find the lowest grade such that a row of employees can be completely divided by it.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef findLowestGradeForLCM(grades: List[int]) -> int:\n    n = len(grades)\n    lowest_grade = 1\n    for grade in grades:\n        lowest_grade = lcm(lowest_grade, grade)\n    return lowest_grade\n\ndef lcm(a, b):\n    return (a * b) // gcd(a, b)\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\n[/Code 2]\n\n[Asserts 2]\n\nassert findLowestGradeForLCM([25, 50, 75, 100]) == 100\nassert findLowestGradeForLCM([10, 20, 30, 40, 50]) == 10\nassert findLowestGradeForLCM([3, 5, 7, 11, 13, 17]) == 3\nassert findLowestGradeForLCM([4, 8, 12, 16, 20, 24]) == 4\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['integer', 'fourth power', 'difference', 'list', 'loop', 'iteration']", "prompt_tokens": 519, "total_tokens": 967, "completion_tokens": 448, "completion": "[Question 2]\n\nWrite a Python function to find all pairs of integers in a given list whose difference of fourth power is less than a given threshold. Implement the solution using loops to iterate through the list and return the list of pairs that satisfy the condition.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List, Tuple\ndef findPairs(numbers: List[int], threshold: int) -> List[Tuple[int, int]]:\n    result = []\n    for i in range(len(numbers)):\n        for j in range(i+1, len(numbers)):\n            if abs(numbers[i]**4 - numbers[j]**4) < threshold:\n                result.append((numbers[i], numbers[j]))\n    return result\n\n[/Code 2]\n\n[Asserts 2]\n\nassert findPairs([1, 2, 3, 4, 5], 50)==[(1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4)]\nassert findPairs([2, 5, 8, 11, 14], 300)==[(2, 5), (2, 8), (2, 11), (2, 14), (5, 8), (5, 11), (5, 14), (8, 11), (8, 14), (11, 14)]\nassert findPairs([3, 6, 9, 12, 15], 100)==[(3, 6), (3, 9), (6, 9), (6, 12), (6, 15), (9, 12), (9, 15), (12, 15)]\nassert findPairs([4, 7, 10, 13, 16], 500)==[(4, 7), (4, 10), (4, 13), (4, 16), (7, 10), (7, 13), (7, 16), (10, 13), (10, 16), (13, 16)]\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['integer', 'divisors', 'even', 'odd', 'count', 'equality', 'boolean', 'iteration']", "prompt_tokens": 503, "total_tokens": 893, "completion_tokens": 390, "completion": "[Question 2]\n\nGiven a binary tree, the task is to find the count of nodes at a given level in the tree. If the count of nodes at even level is equal to the count of nodes at odd level, return True, otherwise return False.\n\n[/Question 2]\n\n[Code 2]\n\nclass TreeNode:\n    def __init__(self, value=0, left=None, right=None):\n        self.value = value\n        self.left = left\n        self.right = right\n\ndef countNodesAtLevel(root: TreeNode, level: int) -> int:\n    if root is None:\n        return 0\n    if level == 0:\n        return 1\n    return countNodesAtLevel(root.left, level - 1) + countNodesAtLevel(root.right, level - 1)\n\ndef countEvenOddLevelNodes(root: TreeNode) -> bool:\n    evenLevelCount = countNodesAtLevel(root, 2)\n    oddLevelCount = countNodesAtLevel(root, 3)\n    return evenLevelCount == oddLevelCount\n\n[/Code 2]\n\n[Asserts 2]\n\n# Create a tree for testing\n#       1\n#      / \\\n#     2   3\n#    / \\ / \\\n#   4  5 6  7\ntree = TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(5)), TreeNode(3, TreeNode(6), TreeNode(7))\nassert countEvenOddLevelNodes(tree) == True\n\n# Modify the tree for testing\n#       1\n#      / \\\n#     2   3\n#    /   / \\\n#   4   6   7\ntree = TreeNode(1, TreeNode(2, TreeNode(4)), TreeNode(3, TreeNode(6), TreeNode(7))\nassert countEvenOddLevelNodes(tree) == False", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['number', 'balanced', 'prime', 'digit', 'reverse', 'boolean', 'function', 'math']", "prompt_tokens": 680, "total_tokens": 1070, "completion_tokens": 390, "completion": "[Question 2]\n\nWrite a Python function to check if a given number is a balanced prime or not. A number N is termed a balanced prime number if the number of digits of prime number is also prime and if the number obtained by reversing the digits is also a prime number. Consider using a separate function to calculate the reverse of a number and another function to check if a number is prime.\n\n[/Question 2]\n\n[Code 2]\n\nimport math\n\ndef isPrime(n: int) -> bool: \n\tif n <= 1: \n\t\treturn False\n\tif n <= 3: \n\t\treturn True\n\tif n % 2 == 0 or n % 3 == 0: \n\t\treturn False\t\n\tfor i in range(5, int(math.sqrt(n)+1), 6): \n\t\tif n % i == 0 or n %(i + 2) == 0: \n\t\t\treturn False\n\treturn True\n\ndef reverseNumber(n: int) -> int:\n\treversed_num = 0\n\twhile n != 0:\n\t\tdigit = n % 10\n\t\treversed_num = reversed_num * 10 + digit\n\t\tn //= 10\n\treturn reversed_num\n\ndef isBalancedPrime(N: int) -> bool:\n\tcount = 0\n\ttemp = N\n\twhile(temp > 0):\n\t\tcount += 1\n\t\ttemp = temp//10\n\t\n\tif isPrime(count) and isPrime(N) and isPrime(reverseNumber(N)):\n\t\treturn True\n\telse:\n\t\treturn False\n\n[/Code 2]\n\n[Asserts 2]\n\nassert isBalancedPrime(53) == True\nassert isBalancedPrime(181) == False\nassert isBalancedPrime(191) == True\nassert isBalancedPrime(3797) == True\nassert isBalancedPrime(492113) == False\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['tree', 'nodes', 'subtree', 'divisors', 'queries', 'count', 'odd', 'number']", "prompt_tokens": 643, "total_tokens": 1041, "completion_tokens": 398, "completion": "[Question 2]\n\nYou are given a tree with N nodes numbered from 1 to N and Q queries. Each query consists of a node U. The task is to find the number of deadend nodes (nodes with only one adjacent node) in the subtree of node U.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\ndef countDeadendNodes(n: int, edges: List[List[int]], queries: List[int]) -> List[int]:\n    \n    adjacent_count = [0]*(n+1)\n    deadend_count = [0]*(n+1)\n    visited = [False]*(n+1)\n    \n    for edge in edges:\n        u, v = edge\n        adjacent_count[u] += 1\n        adjacent_count[v] += 1\n    \n    def dfs(node: int, parent: int):\n        visited[node] = True\n        for neighbor in edges[node]:\n            if not visited[neighbor]:\n                dfs(neighbor, node)\n                adjacent_count[node] += adjacent_count[neighbor]\n                deadend_count[node] += deadend_count[neighbor]\n        if adjacent_count[node] == 1:\n            deadend_count[node] += 1\n    \n    dfs(1, 0)\n    \n    results = []\n    \n    for query in queries:\n        results.append(deadend_count[query])\n        \n    return results\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countDeadendNodes(7, [[1, 2], [1, 3], [2, 4], [2, 5], [3, 6], [3, 7]], [1, 2, 3]) == [4, 2, 2]\nassert countDeadendNodes(4, [[1, 2], [2, 3], [2, 4]], [3, 2]) == [1, 1]\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'increment', 'decrement', 'minimum cost', 'equality', 'operations', 'comparison']", "prompt_tokens": 677, "total_tokens": 1042, "completion_tokens": 365, "completion": "[Question 2]\n\nYou are given an array of integers A[] and an integer K. Find the minimum cost to make all elements of the array equal, where the cost of an operation is equal to the absolute difference between the decrement and increment operation, ensuring that the maximum distance between any two elements is at most K.\n\n[/Question 2]\n\n[Code 2]\n\ndef minCostToMakeEqualWithMaxDistance(arr, n, K):\n    \n    arr.sort()\n    \n    l = 0\n    r = n - 1\n    \n    while (r - l > K):\n        if (arr[l] * (r - l) > arr[r] * (r - l)):\n            arr[l] -= K\n            l += 1\n        else:\n            arr[r] += K\n            r -= 1\n    \n    return arr[r] - arr[l]\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minCostToMakeEqualWithMaxDistance([1, 6, 10, 12, 15], 5, 3)==2\nassert minCostToMakeEqualWithMaxDistance([2, 8, 10, 12, 14, 20], 6, 5)==4\nassert minCostToMakeEqualWithMaxDistance([3, 7, 12, 14, 16, 18], 6, 4)==6\nassert minCostToMakeEqualWithMaxDistance([10, 12, 15, 20, 25], 5, 2)==5\nassert minCostToMakeEqualWithMaxDistance([1, 5, 7, 9, 11, 16], 6, 3)==4\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['integer', 'binary', 'count', 'form', 'representation', 'loop']", "prompt_tokens": 495, "total_tokens": 806, "completion_tokens": 311, "completion": "[Question 2]\n\nGiven a binary tree, the task is to write a function to connect each node at the same level to form a linked list of nodes using the concept of binary representation.\n\n[/Question 2]\n\n[Code 2]\n\nclass TreeNode:\n    def __init__(self, value=0, left=None, right=None, next=None):\n        self.value = value\n        self.left = left\n        self.right = right\n        self.next = next\n\ndef connectNodes(root: TreeNode) -> TreeNode:\n        if not root:\n            return root\n        queue = [root]\n        while queue:\n            size = len(queue)\n            for i in range(size):\n                node = queue.pop(0)\n                if i < size - 1:\n                    node.next = queue[0]\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n        return root\n\n[/Code 2]\n\n[Asserts 2]\n\n# Create a tree\n#           1\n#          / \\\n#         2   3\n#        / \\   \\\n#       4   5   7\ntree = TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(5)), TreeNode(3, None, TreeNode(7)))\nconnectNodes(tree)\nassert tree.next == None\nassert tree.left.next == tree.right\nassert tree.right.next == None\nassert tree.left.left.next == tree.left.right\nassert tree.left.right.next == tree.right.right", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['centered', 'hexadecagonal', 'number', 'figurate', 'formula', 'sum', 'math', 'iteration']", "prompt_tokens": 624, "total_tokens": 871, "completion_tokens": 247, "completion": "[Question 2]\n\nCreate a program to find the sum of the first N centered octahedral numbers using the specified formula. A centered octahedral number can be obtained using the formula: 2n^3 - n. The program should iterate through the first N numbers and calculate their sum.\n\n[/Question 2]\n\n[Code 2]\n\ndef centeredOctahedralNumber(n: int) -> int:\n    return (2 * n**3 - n)\n    \n\ndef sumOfCenteredOctahedralNumber(n: int) -> int:\n    totalSum=0\n    for i in range(1,n+1):\n        totalSum+=centeredOctahedralNumber(i)\n    return totalSum\n\n[/Code 2]\n\n[Asserts 2]\n\nassert sumOfCenteredOctahedralNumber(1)==0\nassert sumOfCenteredOctahedralNumber(2)==14\nassert sumOfCenteredOctahedralNumber(3)==54\nassert sumOfCenteredOctahedralNumber(4)==130\nassert sumOfCenteredOctahedralNumber(5)==252\nassert sumOfCenteredOctahedralNumber(6)==430\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['geometry', 'math', 'sum', 'pattern']", "prompt_tokens": 496, "total_tokens": 988, "completion_tokens": 492, "completion": "[Question 2]\n\nYou are given a grid representing a 2D matrix with values indicating the heights of the cells. The task is to calculate the maximum perimeter of an island in the grid. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. The perimeter of the island is the sum of the lengths of all the sides of the island. Write a function to solve this problem using breadth first search.\n\n[/Question 2]\n\n[Code 2]\n\nfrom collections import deque\n\ndef max_island_perimeter(grid: [[int]]) -> int:\n    max_perimeter = 0\n    rows, cols = len(grid), len(grid[0])\n    dirs = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    \n    def bfs(r, c):\n        perimeter = 0\n        queue = deque([(r, c)])\n        while queue:\n            x, y = queue.popleft()\n            for dx, dy in dirs:\n                nx, ny = x+dx, y+dy\n                if 0 <= nx < rows and 0 <= ny < cols and grid[nx][ny] == 1:\n                    grid[nx][ny] = -1\n                    queue.append((nx, ny))\n                else:\n                    perimeter += 1\n        return perimeter\n    \n    for r in range(rows):\n        for c in range(cols):\n            if grid[r][c] == 1:\n                grid[r][c] = -1\n                max_perimeter = max(max_perimeter, bfs(r, c))\n    \n    return max_perimeter\n\n[/Code 2]\n\n[Asserts 2]\n\nassert max_island_perimeter([[0,1,0,0],[1,1,1,0],[0,1,0,0],[1,1,0,0]]) == 16\nassert max_island_perimeter([[0,1,1,0],[1,1,1,0],[0,1,0,0],[1,1,0,0]]) == 18\nassert max_island_perimeter([[1,1],[1,1]]) == 8\nassert max_island_perimeter([[1,0],[0,1]]) == 6\nassert max_island_perimeter([[1,1,1,1,1]]) == 8", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['math', 'centered', 'dodecagonal', 'number', 'sum', 'figurate', 'layer']", "prompt_tokens": 610, "total_tokens": 881, "completion_tokens": 271, "completion": "[Question 2]\n\nWrite a function to find the sum of all centered dodecagonal numbers less than a given number N, which have repeated digits in their content.\n\n[/Question 2]\n\n[Code 2]\n\ndef hasRepeatedDigits(num: int) -> bool:\n\tdigits = str(num)\n\treturn len(set(digits)) != len(digits)\n\ndef sumOfCenteredDodecagonalWithRepeatedDigits(N: int) -> int:\n\tsum = 0\n\ti = 1\n\twhile True:\n\t\tterm = (3*i*i - 2*i)\n\t\tif term >= N:\n\t\t\tbreak\n\t\tif hasRepeatedDigits(term):\n\t\t\tsum += term\n\t\ti += 1\n\treturn sum\n\n[/Code 2]\n\n[Asserts 2]\n\nassert sumOfCenteredDodecagonalWithRepeatedDigits(10)==1\nassert sumOfCenteredDodecagonalWithRepeatedDigits(100)==14\nassert sumOfCenteredDodecagonalWithRepeatedDigits(500)==285\nassert sumOfCenteredDodecagonalWithRepeatedDigits(1000)==1240\nassert sumOfCenteredDodecagonalWithRepeatedDigits(10000)==3579\nassert sumOfCenteredDodecagonalWithRepeatedDigits(100000)==10780\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['sum', 'centered', 'octagonal', 'number', 'figurate', 'integer', 'mathematics']", "prompt_tokens": 543, "total_tokens": 796, "completion_tokens": 253, "completion": "[Question 2]\n\nIn a mathematical sequence, a figurate number is a number that can be represented as a regular, geometric arrangement of equally spaced points. A centered octagonal number is a figurate number that represents an octagon with a dot in the center and all other dots surrounding the center dot in successive octagonal layers.\n\nGiven a positive integer N, the task is to find the Nth centered octagonal number. Write a function to calculate the Nth centered octagonal number using the formula:\n\nnth_centered_octagonal_number = 3 * N * N - 2 * N\n\nWhere N is the term number.\n\n[/Question 2]\n\n[Code 2]\n\ndef centeredOctagonalNumber(N: int) -> int:\n    return 3 * N * N - 2 * N\n\n[/Code 2]\n\n[Asserts 2]\n\nassert centeredOctagonalNumber(1) == 1\nassert centeredOctagonalNumber(2) == 8\nassert centeredOctagonalNumber(3) == 21\nassert centeredOctagonalNumber(4) == 40\nassert centeredOctagonalNumber(5) == 65\nassert centeredOctagonalNumber(6) == 96\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['geometry', 'math', 'sum', 'centered', 'figurate', 'decagon']", "prompt_tokens": 506, "total_tokens": 756, "completion_tokens": 250, "completion": "[Question 2]\n\nGiven an array of integers, write a function to find the sum of all non-decreasing contiguous subarrays within the array.\n\n[/Question 2]\n\n[Code 2]\n\ndef sumOfNonDecreasingSubarrays(arr):\n    total_sum = 0\n    for i in range(len(arr)):\n        subarray_sum = arr[i]\n        j = i + 1\n        while j < len(arr) and arr[j] >= arr[j-1]:\n            subarray_sum += arr[j]\n            total_sum += subarray_sum\n            j += 1\n    return total_sum\n\n[/Code 2]\n\n[Asserts 2]\n\nassert sumOfNonDecreasingSubarrays([1, 2, 3, 4, 5]) == 35\nassert sumOfNonDecreasingSubarrays([5, 4, 3, 2, 1]) == 0\nassert sumOfNonDecreasingSubarrays([1, 3, 1, 2, 3]) == 21\nassert sumOfNonDecreasingSubarrays([2, 2, 2, 2, 2]) == 25\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['number', 'sum', 'centered', 'pentadecagonal', 'figurate', 'layers', 'calculating']", "prompt_tokens": 586, "total_tokens": 789, "completion_tokens": 203, "completion": "[Question 2]\n\nIn number theory, a figurate number is a number that can be represented by a regular geometrical arrangement of equally spaced points. A pentadecagonal number is a figurate number that represents a pentadecagon in a geometric space.\n\nWrite a function to calculate the nth pentadecagonal number. The nth pentadecagonal number can be calculated using the formula: n(7n - 5)/2.\n\n[/Question 2]\n\n[Code 2]\n\ndef calculatePentadecagonalNumber(n):\n    return n * (7*n - 5) // 2\n\n[/Code 2]\n\n[Asserts 2]\n\nassert calculatePentadecagonalNumber(1) == 1\nassert calculatePentadecagonalNumber(2) == 8\nassert calculatePentadecagonalNumber(5) == 45\nassert calculatePentadecagonalNumber(10) == 160\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['number', 'octagonal', 'figurate', 'formula', 'math', 'integer', 'calculation', 'validation']", "prompt_tokens": 527, "total_tokens": 827, "completion_tokens": 300, "completion": "[Question 2]\n\nWrite a Python function to find all octagonal numbers that are greater than a given number N and store them in a list. The nth octagonal number is given by the formula: N = n(3n-2), for n = 1, 2, 3, 4, ...\n\n[/Question 2]\n\n[Code 2]\n\ndef findOctagonalNumbersGreaterThanN(N: int, size_K: int) -> list:\n    result = []\n    n = 1\n    while True:\n        octagonal_num = n * (3 * n - 2)\n        if octagonal_num > N:\n            result.append(octagonal_num)\n            if len(result) == size_K:\n                break\n        n += 1\n    return result\n\n[/Code 2]\n\n[Asserts 2]\n\nassert findOctagonalNumbersGreaterThanN(10, 3) == [15, 22, 33]\nassert findOctagonalNumbersGreaterThanN(40, 5) == [45, 52, 63, 78, 95]\nassert findOctagonalNumbersGreaterThanN(100, 2) == [105, 120]\nassert findOctagonalNumbersGreaterThanN(200, 4) == [210, 231, 256, 285]\nassert findOctagonalNumbersGreaterThanN(500, 3) == [510, 533, 558]\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['Tetradecagonal', 'number', 'polygon', 'integer', 'sqrt', 'boolean']", "prompt_tokens": 654, "total_tokens": 1087, "completion_tokens": 433, "completion": "[Question 2]\n\nWrite a function to find the overlapping elements between two lists using the Selection Sort algorithm. Given two lists A and B, return a new list containing elements that exist in both A and B.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\ndef selection_sort(arr: List[int]) -> List[int]:\n\tfor i in range(len(arr)):\n\t\tmin_idx = i\n\t\tfor j in range(i+1, len(arr)):\n\t\t\tif arr[j] < arr[min_idx]:\n\t\t\t\tmin_idx = j\n\t\tarr[i], arr[min_idx] = arr[min_idx], arr[i]\n\treturn arr\n\ndef find_overlapping_elements(A: List[int], B: List[int]) -> List[int]:\n\tselection_sort(A)\n\tselection_sort(B)\n\t\n\toverlapping = []\n\ti = 0\n\tj = 0\n\twhile i < len(A) and j < len(B):\n\t\tif A[i] == B[j]:\n\t\t\toverlapping.append(A[i])\n\t\t\ti += 1\n\t\t\tj += 1\n\t\telif A[i] < B[j]:\n\t\t\ti += 1\n\t\telse:\n\t\t\tj += 1\n\t\n\treturn overlapping\n\n[/Code 2]\n\n[Asserts 2]\n\nassert find_overlapping_elements([1, 3, 5, 7, 9], [2, 3, 5, 7, 8]) == [3, 5, 7]\nassert find_overlapping_elements([5, 8, 2, 11, 9], [2, 7, 5, 9, 8]) == [5, 8, 9]\nassert find_overlapping_elements([1, 2, 3, 4, 5], [6, 7, 8, 9, 10]) == []\nassert find_overlapping_elements([3, 6, 9, 12, 15], [3, 9, 15, 21, 27]) == [3, 9, 15] \n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['sum', 'polygon', '20-sided', 'math', 'series']", "prompt_tokens": 458, "total_tokens": 660, "completion_tokens": 202, "completion": "[Question 2]\n\nYou have N glasses arranged in a polygonal shape, with each glass numbered from 1 to N. The glasses are filled with different amounts of water, forming a series. You can choose any two adjacent glasses and pour the water from the first glass into the second one. This process continues until only one glass contains water. What is the maximum possible sum of water that can be retained in a glass after the series of pours, for the worst-case scenario?\n\n[/Question 2]\n\n[Code 2]\n\ndef max_retained_water_sum(n: int) -> int:\n    return (n * (n+1)) // 2 - 1\n\n[/Code 2]\n\n[Asserts 2]\n\nassert max_retained_water_sum(1)==0\nassert max_retained_water_sum(2)==1\nassert max_retained_water_sum(5)==10\nassert max_retained_water_sum(10)==45\nassert max_retained_water_sum(20)==190", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['number', 'sum', 'centered', 'pentagonal', 'figurate', 'formula', 'function']", "prompt_tokens": 570, "total_tokens": 802, "completion_tokens": 232, "completion": "[Question 2]\n\nYou are given a quartic equation in the form of ax^4 + bx^3 + cx^2 + dx + e = 0. Write a function to find the sum of its real solutions. The quartic formula for finding its roots involves complex numbers and is quite complex. Utilize this formula inside the function for computation and then add only the real roots to find their sum. \n\n[/Question 2]\n\n[Code 2]\n\nimport cmath\n\ndef sum_of_real_solutions(a: float, b: float, c: float, d: float, e: float) -> float:\n\tcoefficients = [a, b, c, d, e]\n\troots = [x.real for x in  cmath.roots(coefficients) if x.imag == 0]\n\treturn sum(roots)\n\n[/Code 2]\n\n[Asserts 2]\n\nassert sum_of_real_solutions(1, -2, 1, 4, -8) == 0\nassert sum_of_real_solutions(1, -6, 11, -6, 1) == 3", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['math', 'sum', 'centered tridecagonal number', 'iteration', 'product']", "prompt_tokens": 512, "total_tokens": 817, "completion_tokens": 305, "completion": "[Question 2]\n\nYou are given a list of strings containing English words. Each word has a score based on its position in the English alphabet. For example, 'a' has a score of 1, 'b' has a score of 2, and so on. The score of a word is the product of the position of its letters in the English alphabet. Your task is to iterate through a series of queries, where each query asks for the sum of the scores of the characters in a specific word.\n\nWrite a function to process the queries and return the sum of the scores for each query.\n\n[/Question 2]\n\n[Code 2]\n\ndef getScore(word: str) -> int:\n    score = 0\n    for char in word:\n        score += ord(char) - ord('a') + 1\n    return score\n\ndef processQueries(words: List[str], queries: List[str]) -> List[int]:\n    result = []\n    for query in queries:\n        score = 0\n        for word in words:\n            if query in word:\n                score += getScore(word)\n        result.append(score)\n    return result\n\n[/Code 2]\n\n[Asserts 2]\n\nassert processQueries(['apple', 'banana', 'cat', 'dog'], ['apple', 'cat']) == [50, 24]\nassert processQueries(['programming', 'is', 'awesome'], ['programming', 'is', 'code']) == [144, 28, 31]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['math', 'number theory', 'concentric', 'hexagonal', 'boolean']", "prompt_tokens": 531, "total_tokens": 782, "completion_tokens": 251, "completion": "[Question 2]\n\nWrite a function to determine if a given natural number N is a concentric hexagonal number or not. A concentric hexagonal number is a centered hexagonal number, which can be represented by the formula: n(2n-1), where n is a natural number. Implement a function that takes a natural number as input and returns True if it is a concentric hexagonal number, and False if it is not.\n\n[/Question 2]\n\n[Code 2]\n\ndef isConcentricHexagonal(N: int) -> bool:\n    n = (1 + (1 + 8 * N)**0.5) / 4\n    return n == int(n) and n > 0\n\n[/Code 2]\n\n[Asserts 2]\n\nassert isConcentricHexagonal(1)==True\nassert isConcentricHexagonal(7)==True\nassert isConcentricHexagonal(19)==True\nassert isConcentricHexagonal(20)==False\nassert isConcentricHexagonal(21)==False\nassert isConcentricHexagonal(38)==False\nassert isConcentricHexagonal(58)==True\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'prime', 'pairs', 'difference', 'counting']", "prompt_tokens": 569, "total_tokens": 850, "completion_tokens": 281, "completion": "[Question 2]\n\nGiven an array of strictly positive integers, determine the count of pairs such that the difference between the pair of numbers is a prime number.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef is_prime(n: int) -> bool:\n    if n < 2:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef count_prime_difference_pairs(arr: List[int]) -> int:\n    count = 0\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            if is_prime(abs(arr[i]-arr[j])):\n                count += 1\n    return count\n\n[/Code 2]\n\n[Asserts 2]\n\nassert count_prime_difference_pairs([1, 3, 5, 7, 11]) == 4\nassert count_prime_difference_pairs([2, 4, 6, 8, 10]) == 0\nassert count_prime_difference_pairs([10, 11, 30, 4, 5]) == 4\nassert count_prime_difference_pairs([17, 19, 23, 29, 31, 37]) == 10\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['integer', 'count', 'sum', 'ways']", "prompt_tokens": 397, "total_tokens": 547, "completion_tokens": 150, "completion": "[Question 2]\n\nGiven a year, write a function to determine if it's a leap year or not.\n\n[/Question 2]\n\n[Code 2]\n\ndef isLeapYear(year: int) -> bool:\n    if year % 4 != 0:\n        return False\n    elif year % 100 != 0:\n        return True\n    elif year % 400 != 0:\n        return False\n    else:\n        return True\n\n[/Code 2]\n\n[Asserts 2]\n\nassert isLeapYear(2020)==True\nassert isLeapYear(2021)==False\nassert isLeapYear(2000)==True\nassert isLeapYear(1900)==False\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['logarithm', 'precision', 'decimal', 'math', 'rounding', 'calculation', 'base', 'exponentiation']", "prompt_tokens": 470, "total_tokens": 665, "completion_tokens": 195, "completion": "[Question 2]\n\nYou are implementing a function to calculate the exponentiation of a given base to a given power with the precision of 4 decimal places. If the result is a decimal, round it to the nearest integer.\n\n[/Question 2]\n\n[Code 2]\n\ndef calculateExponentiation(base: int, power: int) -> int:\n    result = base ** power\n    if result % 1 == 0:  # Check if result is a decimal\n        return int(result)\n    else:\n        return round(result, 4)\n\n[/Code 2]\n\n[Asserts 2]\n\nassert calculateExponentiation(2, 3) == 8\nassert calculateExponentiation(3, 2) == 9\nassert calculateExponentiation(2, 0.5) == 1\nassert calculateExponentiation(5, 2.5) == 25\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'integer', 'bitwise', 'OR', 'pair', 'element', 'count', 'size', 'X', 'bit']", "prompt_tokens": 575, "total_tokens": 852, "completion_tokens": 277, "completion": "[Question 2]\n\nGiven an array of integers and an integer X, the task is to find the count of pairs of elements in the array such that the bitwise XOR of the pair is equal to X and the size of each element in the pair is a bit size specified by Euler's criterion.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef countXORPairs(arr: List[int], X: int) -> int:\n    count = 0\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            if (arr[i] ^ arr[j]) == X and (arr[i].bit_length() == arr[j].bit_length()):\n                count += 1\n    return count\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countXORPairs([1, 2, 3, 4, 5], 3) == 2\nassert countXORPairs([5, 7, 9, 9, 10], 3) == 0\nassert countXORPairs([8, 10, 15, 17, 20], 5) == 2\nassert countXORPairs([3, 3, 3, 3], 2) == 6\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['division', 'math', 'iteration', 'number', 'counting', 'algorithm']", "prompt_tokens": 497, "total_tokens": 838, "completion_tokens": 341, "completion": "[Question 2]\n\nYou are given a list of integers. Write a function to count the occurrence of each digit (0-9) in the list and return the counts in a dictionary.\n\n[/Question 2]\n\n[Code 2]\n\ndef countDigitOccurrences(arr):\n    digit_count = {str(i): 0 for i in range(10)}\n    for num in arr:\n        for digit in str(num):\n            digit_count[digit] += 1\n    return digit_count\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countDigitOccurrences([123, 456, 789]) == {'0': 0, '1': 1, '2': 1, '3': 1, '4': 1, '5': 1, '6': 1, '7': 1, '8': 1, '9': 1}\nassert countDigitOccurrences([111, 222, 333, 444]) == {'0': 0, '1': 3, '2': 3, '3': 3, '4': 3, '5': 0, '6': 0, '7': 0, '8': 0, '9': 0}\nassert countDigitOccurrences([97531, 24680]) == {'0': 1, '1': 1, '2': 1, '3': 1, '4': 1, '5': 2, '6': 1, '7': 1, '8': 1, '9': 1}\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['pair', 'integers', 'GCD', 'LCM', 'sum', 'division', 'loop', 'sqrt']", "prompt_tokens": 598, "total_tokens": 951, "completion_tokens": 353, "completion": "[Question 2]\n\nYou are given a matrix representing a chessboard where each cell contains the count of bishops that can attack that cell. You need to find the sum of counts of bishops that can attack any pair of cells such that the sum of row and column indices of the two cells is a perfect square.\n\n[/Question 2]\n\n[Code 2]\n\ndef findBishopPairs(matrix: List[List[int]]) -> int:\n    n = len(matrix)\n    count = 0\n    squares = set([i*i for i in range(2*n)]) # pre-compute perfect squares up to 2n\n\n    for i in range(n):\n        for j in range(n):\n            if i+j in squares:\n                count += matrix[i][j]\n\n    return count\n\n[/Code 2]\n\n[Asserts 2]\n\nassert findBishopPairs([[1, 0, 1], [0, 2, 0], [1, 0, 1]]) == 6\nassert findBishopPairs([[1, 3], [3, 2]]) == 9\nassert findBishopPairs([[0, 3, 0, 2, 0], [3, 0, 0, 0, 3], [0, 0, 5, 0, 0], [2, 0, 0, 0, 2], [0, 3, 0, 2, 0]]) == 15\nassert findBishopPairs([[1, 2, 0], [2, 0, 2], [0, 2, 1]]) == 9\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['autobiographical number', 'subarray', 'length', 'array', 'integer', 'string', 'counting', 'iteration', 'nested loop']", "prompt_tokens": 697, "total_tokens": 1192, "completion_tokens": 495, "completion": "[Question 2]\n\nGiven an array of integers, write a function to determine the count of composite numbers in the array. A composite number is a positive integer that has at least one divisor other than 1 and itself. Additionally, a point is called external point in the array if it is the last element of a subarray with a sum equal to an autobiographical number (explained in question 1). Write a function to find and return the count of external points in the given array.\n\n[/Question 2]\n\n[Code 2]\n\ndef isAutobiographical(n: int) -> bool:\n    numStr = str(n)\n    for i in range(len(numStr)):\n        count = 0\n        for j in range(len(numStr)):\n            if int(numStr[j]) == i:\n                count += 1\n        if count != int(numStr[i]):\n            return False\n    return True\n\ndef isComposite(n: int) -> bool:\n    if n < 2:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return True\n    return False\n\ndef countCompositeAndExternalPoints(arr):\n    compositeCount = 0\n    externalPointsCount = 0\n    n = len(arr)\n    \n    for i in range(n):\n        for j in range(i, n):\n            subarraySum = sum(arr[i:j+1])\n            if isAutobiographical(subarraySum) and j == n-1:\n                externalPointsCount += 1\n            if isComposite(arr[j]):\n                compositeCount += 1\n                \n    return (compositeCount, externalPointsCount)\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countCompositeAndExternalPoints([4, 6, 8, 10, 12, 15, 18, 20, 22, 24]) == (8, 1)\nassert countCompositeAndExternalPoints([2, 3, 5, 7, 11, 13, 17, 19, 23, 29]) == (0, 0)\nassert countCompositeAndExternalPoints([4, 6, 8, 10, 12, 15, 18, 21, 24, 28]) == (8, 0)\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['prime', 'integer', 'reverse', 'square', 'adam', 'number', 'range', 'task', 'find', 'return', 'reversed']", "prompt_tokens": 1103, "total_tokens": 1390, "completion_tokens": 287, "completion": "[Question 2]\n\nGiven a rod of length 'n' and a list of integers representing the prices of rods of length 1 to n, the task is to find the optimal way to cut the rod into smaller rods to maximize the total price obtained. Return the maximum price that can be obtained for the given rod length.\n\n[/Question 2]\n\n[Code 2]\n\ndef cutRod(price, n):\n\tif n <= 0:\n\t\treturn 0\n\tmax_val = float('-inf')\n\tfor i in range(n):\n\t\tmax_val = max(max_val, price[i] + cutRod(price, n - i - 1))\n\treturn max_val\n\n[/Code 2]\n\n[Asserts 2]\n\nassert cutRod([1, 5, 8, 9, 10, 17, 17, 20], 8) == 22\nassert cutRod([1, 5, 8, 9, 10, 17, 17, 20], 4) == 10\nassert cutRod([3, 5, 8, 9, 10, 17, 17, 20], 8) == 24\nassert cutRod([3, 5, 8, 9, 10, 17, 17, 20], 3) == 8\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['integer', 'palindromic', 'sum', 'even', 'boolean']", "prompt_tokens": 502, "total_tokens": 718, "completion_tokens": 216, "completion": "[Question 2]\n\nYou are tasked with implementing a function that determines whether a given integer is a Cylindrical number or not. A Cylindrical number is defined as an even integer whose sum of digits is allowed to be both odd and even. Return True if the provided integer is a cylindrical number, and False otherwise.\n\n[/Question 2]\n\n[Code 2]\n\ndef isCylindricalNumber(num: int) -> bool:\n    if num % 2 != 0:\n        return False\n    if sum(int(digit) for digit in str(num)) % 2 == 0 or sum(int(digit) for digit in str(num)) % 2 != 0:\n        return True\n    return False\n\n[/Code 2]\n\n[Asserts 2]\n\nassert isCylindricalNumber(246) == True\nassert isCylindricalNumber(22) == True\nassert isCylindricalNumber(333) == False\nassert isCylindricalNumber(987654321) == False\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['divisible', 'reverse', 'digits']", "prompt_tokens": 489, "total_tokens": 734, "completion_tokens": 245, "completion": "[Question 2]\n\nWrite a function that takes a 2D list of integers as input and checks if the sum of digits of each number is divisible by the number located outside the 2D list in the corresponding column-wise location. If the sum of digits is divisible, return True, otherwise return False.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\ndef isDivisibleByOutside(matrix: List[List[int]]) -> bool:\n    for col in range(len(matrix[0])):\n        total = 0\n        for row in range(len(matrix)):\n            total += sum(int(digit) for digit in str(matrix[row][col]))\n        if total % matrix[-1][col] != 0:\n            return False\n    return True\n\n[/Code 2]\n\n[Asserts 2]\n\nassert isDivisibleByOutside([[12, 34, 56], [78, 90, 12], [3, 5, 7]])==True\nassert isDivisibleByOutside([[11, 22, 33], [44, 55, 66], [7, 8, 9]])==False\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['positive', 'integer', 'split', 'natural numbers', 'GCD', 'sums']", "prompt_tokens": 558, "total_tokens": 906, "completion_tokens": 348, "completion": "[Question 2]\n\nGiven a list of RGB values, write a function to calculate the GCD of the Hamming differences between the RGB and HSV representations of each color. Additionally, implement an O(1) time complexity solution for splitting the first N natural numbers into two sets such that their sums are equal.\n\n[/Question 2]\n\n[Code 2]\n\ndef gcd(x: int, y: int) -> int:\n    if y == 0:\n        return x\n    return gcd(y, x % y)\n\ndef rgb_to_hsv(rgb: list) -> list:\n    # Implementation of rgb_to_hsv function\n    pass\n\ndef hamming_difference(x: list, y: list) -> int:\n    # Implementation of hamming_difference function\n    pass\n\ndef splitEqualSum(N: int) -> list:\n    res = [0, 0]\n    res[0] = (N * (N + 1)) // 4\n    res[1] = (N * (N + 1)) // 4 + (N % 2) * (N // 2 + 1)\n    return res\n\n[/Code 2]\n\n[Asserts 2]\n\nassert gcd(8, 12) == 4\nassert gcd(7, 5) == 1\n\n# RGB to HSV conversion and hamming distance testing can be added here\n\nassert splitEqualSum(6) == [9, 9]\nassert splitEqualSum(5) == [5, 6]\nassert splitEqualSum(7) == [14, 15]\nassert splitEqualSum(12) == [39, 42]\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['tree', 'nodes', 'weight', 'powerful number', 'non-negative integer', 'power', 'count']", "prompt_tokens": 624, "total_tokens": 1145, "completion_tokens": 521, "completion": "[Question 2]\n\nYou are given a tree where each node contains a non-negative integer weight. The task is to transform the weights of the tree nodes based on the last occurrence of a powerful number in the subtree rooted at the node. Specifically, for each node, you need to switch the weight of the node with the weight of the most recently encountered powerful number in the subtree rooted at the node. If no powerful number exists in the subtree, the weight remains unchanged.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\ndef isPowerful(num: int) -> bool:\n    if num < 1:\n        return False\n    for i in range(2, int(num**0.5)+1):\n        p = i\n        while p <= num:\n            p *= i\n            if p == num:\n                return True\n    return num == 1\n\nclass TreeNode:\n    def __init__(self, x: int):\n        self.val = x\n        self.children = []\n\ndef transformWeights(root: TreeNode) -> None:\n    powerful_numbers = []\n\n    def dfs(node):\n        if isPowerful(node.val):\n            powerful_numbers.append(node.val)\n        \n        if node.children:\n            for child in node.children:\n                dfs(child)\n        \n        if powerful_numbers:\n            node.val = powerful_numbers[-1]\n    \n    dfs(root)\n\n[/Code 2]\n\n[Asserts 2]\n\n# Test cases\nroot = TreeNode(10)\nroot.children = [TreeNode(4), TreeNode(6), TreeNode(16)]\ntransformWeights(root)\nassert root.val == 16\nassert root.children[0].val == 4\nassert root.children[1].val == 16\nassert root.children[2].val == 16\n\nroot = TreeNode(5)\nroot.children = [TreeNode(81), TreeNode(27), TreeNode(16)]\nroot.children[0].children = [TreeNode(9), TreeNode(25)]\nroot.children[1].children = [TreeNode(3)]\nroot.children[2].children = [TreeNode(4), TreeNode(7)]\ntransformWeights(root)\nassert root.val == 81\nassert root.children[0].val == 9\nassert root.children[0].children[0].val == 9\nassert root.children[0].children[1].val == 25\nassert root.children[1].val == 3\nassert root.children[2].val == 4\nassert root.children[2].children[1].val == 7\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['grid', 'color', 'boundary', 'separate', 'ways', 'table']", "prompt_tokens": 566, "total_tokens": 993, "completion_tokens": 427, "completion": "[Question 2]\n\nYou are given a table of URLs and their corresponding colors. The URL column contains URLs and the Color column contains colors in hexadecimal format. Your task is to separate the URLs based on their domain and shift the colors based on a given shifting value. Write a function to perform this color shifting and return a new table with the updated colors.\n\n[/Question 2]\n\n[Code 2]\n\nfrom urllib.parse import urlparse\n\ndef shift_colors(url_color_table: List[Tuple[str, str]], shifting_value: int) -> List[Tuple[str, str]]:\n    result_table = []\n    for url, color in url_color_table:\n        parsed_url = urlparse(url)\n        domain = parsed_url.netloc\n        shifted_color = shift_color_hex(color, shifting_value)\n        result_table.append((domain, shifted_color))\n    return result_table\n\ndef shift_color_hex(color: str, shift: int) -> str:\n    # Assume color is in the format '#RRGGBB'\n    r, g, b = int(color[1:3], 16), int(color[3:5], 16), int(color[5:], 16)\n    r = (r + shift) % 256\n    g = (g + shift) % 256\n    b = (b + shift) % 256\n    return f'#{r:02X}{g:02X}{b:02X}'\n\n[/Code 2]\n\n[Asserts 2]\n\nurl_color_table = [\n    ('https://example.com/page1', '#FF0000'),\n    ('https://example.com/page2', '#00FF00'),\n    ('https://example.org/page3', '#0000FF')\n]\n\nassert shift_colors(url_color_table, 1) == [('example.com', '#FF0101'), ('example.com', '#01FF01'), ('example.org', '#010101')]\nassert shift_colors(url_color_table, 5) == [('example.com', '#FF0505'), ('example.com', '#05FF05'), ('example.org', '#050505')]\n\n", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['positive', 'integer', 'absolute difference', 'adjacent digits', 'sequence', 'iteration', 'math']", "prompt_tokens": 571, "total_tokens": 791, "completion_tokens": 220, "completion": "[Question 2]\n\nYou are given a string representing a sequence of chords in a song. Each chord is represented by a letter from A to G, optionally followed by '#' indicating a sharp note. The chords are separated by spaces. Your task is to determine if the sequence ends with a support chord. A support chord is defined as a chord that ends with 'm' or '7'.\n\n[/Question 2]\n\n[Code 2]\n\ndef endsWithSupportChord(chord_sequence: str) -> bool:\n    chords = chord_sequence.split()\n    last_chord = chords[-1]\n    if last_chord.endswith('m') or last_chord.endswith('7'):\n        return True\n    return False\n\n[/Code 2]\n\n[Asserts 2]\n\nassert endsWithSupportChord(\"C G Am F7\") == True\nassert endsWithSupportChord(\"Dm G7 C\") == True\nassert endsWithSupportChord(\"Dm Gm C\") == False\nassert endsWithSupportChord(\"G# Dm7 Am\") == True", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'unique', 'counter', 'collection', 'element', 'appears', 'times']", "prompt_tokens": 578, "total_tokens": 938, "completion_tokens": 360, "completion": "[Question 2]\n\nGiven an array arr, find the nearest unique element to a given index in the array using a greedy algorithm. If there is no unique element, return -1.\n\n[/Question 2]\n\n[Code 2]\n\nfrom collections import Counter\nfrom typing import List\ndef nearestUniqueElement(arr: List[int], index: int) -> int:\n    count = Counter(arr)\n    left = index - 1\n    right = index + 1\n    while left >= 0 or right < len(arr):\n        if left >= 0 and count[arr[left]] == 1:\n            return arr[left]\n        if right < len(arr) and count[arr[right]] == 1:\n            return arr[right]\n        left -= 1\n        right += 1\n    return -1\n\n[/Code 2]\n\n[Asserts 2]\n\nassert nearestUniqueElement([4, 3, 3, 3, 4, 4, 4], 1)==4\nassert nearestUniqueElement([1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4, 5, 5, 5], 7) == 5\nassert nearestUniqueElement([2, 2, 1, 1, 3, 3, 1, 1, 4, 4], 5) == 3\nassert nearestUniqueElement([5, 5, 5, 4, 4, 4, 3, 3, 3, 2, 2, 2, 1], 8) == -1\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['cubic equation', 'roots', 'expand', 'coefficients', 'math']", "prompt_tokens": 684, "total_tokens": 1062, "completion_tokens": 378, "completion": "[Question 2]\n\nYou are given a cubic equation in the form of ax^3 + bx^2 + cx + d = 0, where a, b, c, and d are coefficients. The task is to expand the given cubic equation and find the inflection points.\n\n[/Question 2]\n\n[Code 2]\n\ndef expandCubicEquation(a: int, b: int, c: int, d: int) -> str:\n\t# Expand the cubic equation to get the expanded form\n\treturn f\"{a}x^3 + {b}x^2 + {c}x + {d} = 0\"\n\ndef findInflectionPoints(a: int, b: int, c: int) -> tuple:\n\t# The inflection points of a cubic equation occur where the second derivative is zero\n\t# The second derivative of the cubic equation is 6ax + 2b, set it to zero and solve for x to get the inflection points\n\tx = -b/(3*a)\n\ty = a*x**3 + b*x**2 + c*x\n\treturn (x, y)\n\n[/Code 2]\n\n[Asserts 2]\n\nassert expandCubicEquation(1, -6, 11, -6)==\"1x^3 + -6x^2 + 11x + -6 = 0\"\nassert expandCubicEquation(1, -12, 40, -48)==\"1x^3 + -12x^2 + 40x + -48 = 0\"\nassert findInflectionPoints(1, -6, 11)==(1.0, 0.0)\nassert findInflectionPoints(1, -12, 40)==(2.0, -8.0)\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['differential equations', \"Gill's method\", 'numerical methods', 'approximation', 'first order', 'iterative', 'convergence', 'math', 'function']", "prompt_tokens": 677, "total_tokens": 1145, "completion_tokens": 468, "completion": "[Question 2]\n\nYou are given a maze represented as a 2D grid and a starting point. Write a function to find the nearest exit from the starting point using an iterative approximation method.\n\n[/Question 2]\n\n[Code 2]\n\ndef find_nearest_exit(maze: List[List[int]], start: Tuple[int, int]) -> Tuple[int, int]:\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    n = len(maze)\n    m = len(maze[0])\n    queue = [start]\n    while queue:\n        x, y = queue.pop(0)\n        if maze[x][y] == 1:\n            return (x, y)\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < n and 0 <= ny < m and maze[nx][ny] != -1:\n                queue.append((nx, ny))\n                maze[nx][ny] = -1  # Mark as visited\n    return (-1, -1)  # No exit found\n\n[/Code 2]\n\n[Asserts 2]\n\nmaze = [\n    [0, 0, 0, 0, 0],\n    [0, 1, 1, 1, 0],\n    [0, 1, 0, 1, 0],\n    [0, 1, 1, 1, 0],\n    [0, 0, 0, 0, 0]\n]\nassert find_nearest_exit(maze, (1, 1)) == (4, 3)\n\nmaze = [\n    [0, 0, 0, 0, 0],\n    [0, 1, 1, 1, 0],\n    [0, 1, 0, 1, 0],\n    [0, 1, 1, 1, 0],\n    [0, 0, 0, 0, 0]\n]\nassert find_nearest_exit(maze, (0, 0)) == (-1, -1)\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['digit sum', 'counting', 'dynamic programming', 'range', 'nested loops', 'recursion']", "prompt_tokens": 528, "total_tokens": 867, "completion_tokens": 339, "completion": "[Question 2]\n\nYou are given a list of n integers. Your task is to find the count of pairs (i, j) where 1 \u2264 i < j \u2264 n and the digit sum of the product of the numbers at index i and j is a prime number.\n\n[/Question 2]\n\n[Code 2]\n\ndef isPrime(n):\n    if n < 2:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef digitSum(x):\n    result = 0\n    while x:\n        result += x % 10\n        x //= 10\n    return result\n\ndef countPairsWithPrimeDigitSum(arr):\n    count = 0\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            product = arr[i] * arr[j]\n            if isPrime(digitSum(product)):\n                count += 1\n    return count\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countPairsWithPrimeDigitSum([12, 34, 56, 78, 90]) == 2\nassert countPairsWithPrimeDigitSum([11, 22, 33, 44, 55]) == 0\nassert countPairsWithPrimeDigitSum([1, 29, 11, 77, 5]) == 4\nassert countPairsWithPrimeDigitSum([8, 10, 12, 14, 16]) == 5\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'arithmetic mean', 'harmonic mean', 'distinct indices', 'unordered map', 'double', 'find', 'return', 'true', 'false']", "prompt_tokens": 702, "total_tokens": 1086, "completion_tokens": 384, "completion": "[Question 2]\n\nGiven an array of integers, the task is to find whether there exist two distinct indices i and j such that the harmonic mean of arr[i] and arr[j] is a multiple of the arithmetic mean of arr[i] and arr[j].\n\n[/Question 2]\n\n[Code 2]\n\n#include <unordered_map>\n#include <vector>\n#include <cmath>\n#include <iostream>\nusing namespace std;\n\nbool findHarmonicArithmeticMultiple(vector<int>& arr) {\n    int n = arr.size();\n    unordered_map<double, pair<int, int>> valToIndex;\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            double AM = (arr[i] + arr[j]) / 2.0;\n            double HM = 2.0 * arr[i] * arr[j] / (arr[i] + arr[j]);\n            if (valToIndex.find(AM) != valToIndex.end() && valToIndex[AM].first != i && valToIndex[AM].second != i && valToIndex[AM].first != j && valToIndex[AM].second != j) {\n                if (fmod(HM, AM) == 0 || fmod(AM, HM) == 0) {\n                    return true;\n                }\n            }\n            valToIndex[AM] = {i, j};\n        }\n    }\n    return false;\n}\n\n[/Code 2]\n\n[Asserts 2]\n\narr = [2, 4, 6, 8, 10]\nassert(findHarmonicArithmeticMultiple(arr)) == true\narr = [1, 3, 5, 7, 9]\nassert(findHarmonicArithmeticMultiple(arr)) == false\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['integer', 'Pythagorean triplet', 'sum', 'loop', 'positive integers', 'list', 'exist']", "prompt_tokens": 594, "total_tokens": 1000, "completion_tokens": 406, "completion": "[Question 2]\n\nGiven a list of positive integers representing the petrol available at different stations on a circular road, the task is to find the minimum starting petrol station index such that the complete tour is possible. Each station has a petrol value and a distance to the next station. Calculate if a petrol station exists from where the complete tour is possible once in a loop.\n\nWrite a function that takes in two lists - petrol and distance, each of size n, and returns the starting petrol station index if a tour is possible, else return -1.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\ndef find_starting_station_petrol(petrol: List[int], distance: List[int]) -> int:\n    total_petrol = 0\n    total_distance = 0\n    start_index = 0\n    current_petrol = 0\n    for i in range(len(petrol)):\n        total_petrol += petrol[i]\n        total_distance += distance[i]\n        current_petrol += petrol[i] - distance[i]\n        if current_petrol < 0:\n            start_index = i + 1\n            current_petrol = 0\n    return start_index if total_petrol >= total_distance else -1\n\n[/Code 2]\n\n[Asserts 2]\n\nassert find_starting_station_petrol([4, 6, 7, 4], [6, 5, 3, 5]) == 2\nassert find_starting_station_petrol([6, 3, 3], [5, 7, 2]) == -1\nassert find_starting_station_petrol([5, 7, 2, 9], [4, 3, 5, 2]) == 1\nassert find_starting_station_petrol([3, 5, 2, 7], [6, 4, 3, 5]) == -1\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['factors', 'prime', 'number', 'divisibility', 'boolean', 'iteration', 'math']", "prompt_tokens": 675, "total_tokens": 1229, "completion_tokens": 554, "completion": "[Question 2]\n\nGiven a graph represented as an adjacency matrix and two indices i and j, the task is to check if there exists a path from index i to index j and if the sum of values along the path is divisible by a given number K. If such a path exists, return True, otherwise return False.\n\n[/Question 2]\n\n[Code 2]\n\ndef isPathSumDivisible(matrix: List[List[int]], i: int, j: int, K: int) -> bool:\n    n = len(matrix)\n    visited = [False] * n\n\n    def dfs(curr, path_sum):\n        if curr == j:\n            return path_sum % K == 0\n        visited[curr] = True\n        for next_node in range(n):\n            if matrix[curr][next_node] != 0 and not visited[next_node]:\n                if dfs(next_node, path_sum + matrix[curr][next_node]):\n                    return True\n        visited[curr] = False\n        return False\n\n    return dfs(i, 0)\n\n[/Code 2]\n\n[Asserts 2]\n\nassert isPathSumDivisible([[0, 1, 1, 0], [1, 0, 0, 1], [1, 0, 0, 1], [0, 1, 1, 0]], 0, 3, 3)==True\nassert isPathSumDivisible([[0, 1, 1, 0], [1, 0, 0, 1], [1, 0, 0, 1], [0, 1, 1, 0]], 0, 2, 2)==False\nassert isPathSumDivisible([[0, 1, 1, 0], [1, 0, 0, 1], [1, 0, 0, 1], [0, 1, 1, 0]], 1, 3, 4)==True\nassert isPathSumDivisible([[0, 1, 1, 0], [1, 0, 0, 1], [1, 0, 0, 1], [0, 1, 1, 0]], 1, 2, 5)==True\nassert isPathSumDivisible([[0, 1, 1, 0], [1, 0, 0, 1], [1, 0, 0, 1], [0, 1, 1, 0]], 2, 3, 6)==False\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'subset', 'operations', 'OR', 'AND', 'XOR', 'combinations', 'bitwise', 'math', 'count']", "prompt_tokens": 693, "total_tokens": 966, "completion_tokens": 273, "completion": "[Question 2]\n\nGiven an array arr[] of n non-negative integers. Write a function to find the count of all possible subsets of the array where the last digit of the bitwise AND of all elements in the subset is 0.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef countSubsetsWithLastDigitZero(arr: List[int]) -> int:\n    n = len(arr)\n    count = 0\n    for i in range(1, (1 << n)):\n        currentAND = 1\n        for j in range(n):\n            if (i & (1 << j)) > 0:\n                currentAND &= arr[j]\n\n        if currentAND % 10 == 0:\n            count += 1\n    return count\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countSubsetsWithLastDigitZero([2, 3, 5]) == 4\nassert countSubsetsWithLastDigitZero([4, 2, 6, 8]) == 15\nassert countSubsetsWithLastDigitZero([1, 7, 3, 9]) == 8\nassert countSubsetsWithLastDigitZero([0, 2, 4, 6, 8]) == 31\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'integer', 'subset', 'counting', 'bitwise']", "prompt_tokens": 484, "total_tokens": 735, "completion_tokens": 251, "completion": "[Question 2]\n\nGiven an array arr[] of integers, the task is to find the count of all subsets whose elements can be rearranged in a decreasing sequence and the fourth power of the maximum element in the subset is higher than the bitwise AND of all elements in the subset.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\nfrom itertools import combinations\ndef countDecreasingSubsets(arr: List[int]) -> int:\n\tcnt = 0\n\tfor r in range(1, len(arr)+1):\n\t\tfor subset in combinations(arr, r):\n\t\t\tif all(subset[i] >= subset[i+1] for i in range(len(subset)-1)):\n\t\t\t\tmax_element = max(subset)\n\t\t\t\tand_result = subset[0]\n\t\t\t\tfor i in subset[1:]:\n\t\t\t\t\tand_result = and_result & i\n\t\t\t\tif (max_element ** 4 > and_result):\n\t\t\t\t\tcnt += 1\n\treturn cnt\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countDecreasingSubsets([1, 2, 3, 4])==7\nassert countDecreasingSubsets([4, 3, 2, 1])==15\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['integer', 'remainder', 'division', 'largest number', 'comparison']", "prompt_tokens": 453, "total_tokens": 819, "completion_tokens": 366, "completion": "[Question 2]\n\nGiven a binary tree, design a function to find the sub-tree with the largest number of bridges. A bridge is defined as an edge whose removal increases the number of connected components in the sub-tree.\n\n[/Question 2]\n\n[Code 2]\n\nclass TreeNode:\n    def __init__(self, value):\n        self.val = value\n        self.left = None\n        self.right = None\n\ndef maxBridgesSubTree(root: TreeNode) -> TreeNode:\n    maxBridges = [0]\n    maxBridgesNode = [None]\n    \n    def dfs(node):\n        if not node:\n            return 0\n        leftBridges = dfs(node.left)\n        rightBridges = dfs(node.right)\n        \n        currBridges = leftBridges + rightBridges\n        \n        if currBridges > maxBridges[0]:\n            maxBridges[0] = currBridges\n            maxBridgesNode[0] = node\n            \n        return max(leftBridges, rightBridges) + 1\n    \n    dfs(root)\n    return maxBridgesNode[0]\n\n[/Code 2]\n\n[Asserts 2]\n\n# Create a sample binary tree\nroot = TreeNode(1)\nroot.left = TreeNode(2)\nroot.right = TreeNode(3)\nroot.left.left = TreeNode(4)\nroot.left.right = TreeNode(5)\n\nassert maxBridgesSubTree(root).val == 1\n\n# Create another sample binary tree\nroot = TreeNode(1)\nroot.left = TreeNode(2)\nroot.right = TreeNode(3)\nroot.right.left = TreeNode(4)\nroot.right.right = TreeNode(5)\n\nassert maxBridgesSubTree(root).val == 3", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'count', 'elements', 'greater', 'right-side']", "prompt_tokens": 543, "total_tokens": 877, "completion_tokens": 334, "completion": "[Question 2]\n\nGiven an array representing the terrain, write a function to find the count of elements to the right side of each terrain element that are greater than it. If a single terrain element is greater than all the elements to its right, overwrite it with the count of greater elements.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef countGreaterElementsOverwrite(arr: List[int]) -> List[int]:\n    n = len(arr)\n    result = [0] * n\n    for i in range(n-1):\n        count = 0\n        for j in range(i+1,n):\n            if arr[j] > arr[i]:\n                count += 1\n        if count > 0:\n            result[i] = count\n        else:\n            result[i] = arr[i]\n    result[-1] = 0  # Last element always has 0 elements to its right\n    return result\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countGreaterElementsOverwrite([3, 1, 6, 4, 5, 2]) == [3, 1, 3, 2, 1, 0]\nassert countGreaterElementsOverwrite([5, 8, 6, 1, 2, 3, 9]) == [4, 4, 4, 3, 2, 1, 0]\nassert countGreaterElementsOverwrite([1, 2, 3, 4, 5]) == [4, 3, 2, 1, 0]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['integer', 'operations', 'increment', 'decrement', 'doubling', 'recursion']", "prompt_tokens": 528, "total_tokens": 944, "completion_tokens": 416, "completion": "[Question 2]\n\nWrite a recursive function to perform the Quickselect algorithm to find the kth smallest element in an array of integers. The Quickselect algorithm is an extension of the quicksort algorithm and uses the operations of increment, decrement, and doubling to efficiently select the kth smallest element. Ensure that the resulting array is in ascending order after each recursive call.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\ndef quickselect(arr: List[int], k: int):\n    if not arr:\n        return float('inf')\n    pivot = arr[len(arr) // 2]\n    left = [x for x in arr if x < pivot]\n    right = [x for x in arr if x > pivot]\n    count = len([x for x in arr if x == pivot])\n    if k < len(left):\n        return quickselect(left, k)\n    elif k < len(left) + count:\n        return pivot\n    else:\n        return quickselect(right, k - len(left) - count)\n\ndef ascendingQuickselect(arr: List[int], k: int):\n    selected = quickselect(arr, k)\n    arr.remove(selected)\n    arr.insert(0, selected)\n    if arr != sorted(arr):\n        return ascendingQuickselect(arr, k)\n    return arr\n\n[/Code 2]\n\n[Asserts 2]\n\nassert ascendingQuickselect([3, 2, 1, 5, 4], 2) == [1, 2, 3, 4, 5]\nassert ascendingQuickselect([7, 10, 4, 3, 21, 15, 8], 3) == [3, 4, 7, 8, 10, 15, 21]\nassert ascendingQuickselect([18, 12, 14, 17, 21, 9, 11], 5) == [9, 11, 12, 14, 17, 18, 21]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['complex number', 'quadrant', 'real numbers', 'imaginary unit', 'positive', 'negative', 'function', 'conditions']", "prompt_tokens": 652, "total_tokens": 988, "completion_tokens": 336, "completion": "[Question 2]\n\nYou are given a table representing 2D points in a Cartesian coordinate system, where each row contains the x and y coordinates of a point. You are also given a list of trucks, where each truck is represented by a positive or negative integer indicating its direction on the x-axis.\n\nWrite a function that takes the table of points and the list of trucks, and returns a list of points that lie in the same quadrant as the positive trucks.\n\n[/Question 2]\n\n[Code 2]\n\ndef sameQuadrantPoints(points: List[Tuple[int, int]], trucks: List[int]) -> List[Tuple[int, int]]:\n    result = []\n    for point in points:\n        if (point[0] > 0 and all(truck > 0 for truck in trucks)) or (point[0] < 0 and all(truck < 0 for truck in trucks)):\n            result.append(point)\n    return result\n\n[/Code 2]\n\n[Asserts 2]\n\nassert sameQuadrantPoints([(3, 4), (-3, 4), (-3, -4), (3, -4)], [5, 6]) == [(3, 4)]\nassert sameQuadrantPoints([(3, 4), (-3, 4), (-3, -4), (3, -4)], [5, -6]) == [(-3, -4), (3, -4)]\nassert sameQuadrantPoints([(3, 4), (-3, 4), (-3, -4), (3, -4)], [-5, -6]) == []", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['linked list', 'singly linked list', 'Fibonacci', 'sum', 'product', 'positive integers']", "prompt_tokens": 746, "total_tokens": 1313, "completion_tokens": 567, "completion": "[Question 2]\n\nYou are given a singly linked list containing positive integers representing the miles traveled by a vehicle each day. Write a function to calculate the sum and product of the miles for the days that correspond to Fibonacci sequence indices in the linked list. Also, handle the case of float division for calculating the average miles for these days.\n\n[/Question 2]\n\n[Code 2]\n\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\ndef sumProductAvgFibMiles(head):\n    fib_indices = [0, 1]  # Pre-calculated Fibonacci numbers to avoid recalculating for every node\n    \n    def isFibonacci(index):\n        while fib_indices[-1] < index:\n            fib_indices.append(fib_indices[-1] + fib_indices[-2])\n        return index in fib_indices\n\n    sum_miles = 0\n    product_miles = 1\n    fib_count = 0\n    while head is not None:\n        if isFibonacci(fib_count):\n            sum_miles += head.data\n            product_miles *= head.data\n        fib_count += 1\n        head = head.next\n        \n    avg_miles = sum_miles / fib_count  # Handle float division\n    \n    return sum_miles, product_miles, avg_miles\n\n[/Code 2]\n\n[Asserts 2]\n\n# Create a sample linked list for testing\n# 2 -> 3 -> 5 -> 7 -> 11 -> 13 -> 15 -> 19 -> 40\n# Days representing miles: [2, 3, 5, 7, 11, 13, 15, 19, 40]\n# Sum of miles at Fibonacci indices: 2+3+13+40 = 58\n# Product of miles at Fibonacci indices: 2*3*13*40 = 3120\n# Average miles at these Fibonacci indices: 58/4 = 14.5\nn1 = Node(2)\nn2 = Node(3)\nn3 = Node(5)\nn4 = Node(7)\nn5 = Node(11)\nn6 = Node(13)\nn7 = Node(15)\nn8 = Node(19)\nn9 = Node(40)\nn1.next = n2\nn2.next = n3\nn3.next = n4\nn4.next = n5\nn5.next = n6\nn6.next = n7\nn7.next = n8\nn8.next = n9\nassert sumProductAvgFibMiles(n1) == (58, 3120, 14.5)\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['integer', 'positive', 'distinct', 'odd', 'sum', 'list', 'conditional', 'loop']", "prompt_tokens": 600, "total_tokens": 762, "completion_tokens": 162, "completion": "[Question 2]\n\nGiven a positive integer N, find the sum of the first N positive odd integers in the harmonic sequence. If the sum is not an integer, return the floor value of the sum.\n\n[/Question 2]\n\n[Code 2]\n\ndef harmonicSumOfFirstNOddIntegers(N: int) -> int:\n\tsum = 0\n\todd = 1\n\tfor i in range(N):\n\t\tsum += 1 / odd\n\t\todd += 2\n\treturn int(sum)\n\n[/Code 2]\n\n[Asserts 2]\n\nassert harmonicSumOfFirstNOddIntegers(4) == 2\nassert harmonicSumOfFirstNOddIntegers(5) == 2\nassert harmonicSumOfFirstNOddIntegers(7) == 3", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'operations', 'subarray', 'conversion', 'integer', 'minimum', 'difference']", "prompt_tokens": 597, "total_tokens": 906, "completion_tokens": 309, "completion": "[Question 2]\n\nYou are given an array of integers and an integer K. Your task is to find the minimum number of operations needed to convert the given array into a balanced ternary array where each element is represented in balanced ternary notation.\n\nIn balanced ternary notation, the only digits allowed are -1, 0, and 1, and the array is considered balanced ternary if each element is represented using these digits.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef minOpsForBalancedTernary(arr: List[int], K: int) -> int:\n    ans = 0\n    for i in range(len(arr)):\n        diff = arr[i]\n        while diff != 0:\n            if diff % K != 0:\n                ans += 1\n            diff = diff // K\n    return ans\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minOpsForBalancedTernary([1, 2, 3, 4, 5], 3) == 6\nassert minOpsForBalancedTernary([8, 5, 12, 16], 2) == 7\nassert minOpsForBalancedTernary([20, 30, 40], 5) == 15\nassert minOpsForBalancedTernary([15, 27, 39, 41, 7], 4) == 14\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['staircase', 'steps', 'ways', 'unique', 'combinations']", "prompt_tokens": 482, "total_tokens": 914, "completion_tokens": 432, "completion": "[Question 2]\n\nYou are given a 2D grid representing a map of rooms, where 1 represents a wall and 0 represents an empty space. You need to recursively find the number of unique ways to reach the finish from the starting position at the top-left corner of the grid. You can only move down or right at each step. Write a function to calculate the number of unique ways to reach the finish from the start.\n\n[/Question 2]\n\n[Code 2]\n\ndef uniqueWays(grid: List[List[int]]) -> int:\n    rows, cols = len(grid), len(grid[0])\n    dp = [[0] * cols for _ in range(rows)]\n    \n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 1:\n                dp[i][j] = 0\n            elif i == 0 and j == 0:\n                dp[i][j] = 1\n            elif i == 0:\n                dp[i][j] = dp[i][j-1]\n            elif j == 0:\n                dp[i][j] = dp[i-1][j]\n            else:\n                dp[i][j] = dp[i-1][j] + dp[i][j-1]\n    \n    return dp[rows-1][cols-1]\n\n[/Code 2]\n\n[Asserts 2]\n\ngrid1 = [\n  [0, 0, 0],\n  [0, 1, 0],\n  [0, 0, 0]\n]\n\ngrid2 = [\n  [0, 1, 0],\n  [0, 0, 0],\n  [0, 0, 0]\n]\n\ngrid3 = [\n  [0, 0, 0],\n  [0, 0, 0],\n  [0, 0, 0]\n]\n\nassert uniqueWays(grid1) == 2\nassert uniqueWays(grid2) == 3\nassert uniqueWays(grid3) == 6\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['year', 'leap year', 'range', 'counting', 'division', 'modulo', 'inclusive']", "prompt_tokens": 640, "total_tokens": 1011, "completion_tokens": 371, "completion": "[Question 2]\n\nThe task is to implement a function that takes in a document content and a maxDist value and returns the most significant digit of the product of all the Fibonacci numbers within the maxDist of each other in the specified document content.\n\n[/Question 2]\n\n[Code 2]\n\ndef mostSignificantFibonomialDigit(document: str, maxDist: int) -> int:\n    def isFibonacci(num):\n        return ((5 * num * num + 4) ** 0.5).is_integer() or ((5 * num * num - 4) ** 0.5).is_integer()\n    \n    def findFibonomialProduct(nums):\n        product = 1\n        for num in nums:\n            product *= num\n        return product\n    \n    fib_indices = [i for i in range(len(document)) if isFibonacci(i)]\n    results = []\n    for i in range(len(fib_indices)):\n        for j in range(i+1, len(fib_indices)):\n            if abs(fib_indices[i] - fib_indices[j]) <= maxDist:\n                fib_nums = [int(digit) for digit in document[fib_indices[i]:fib_indices[i]+maxDist+1]]\n                results.append(findFibonomialProduct(fib_nums))\n    \n    if len(results) == 0:\n        return -1\n    \n    return int(str(max(results))[0])\n\n[/Code 2]\n\n[Asserts 2]\n\nassert mostSignificantFibonomialDigit(\"112358130514\", 1) == 1\nassert mostSignificantFibonomialDigit(\"11235813213455\", 2) == 1\nassert mostSignificantFibonomialDigit(\"1123581321345589144\", 3) == 2", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'sum', 'function', 'maximum', 'minimum', 'subset']", "prompt_tokens": 485, "total_tokens": 697, "completion_tokens": 212, "completion": "[Question 2]\n\nGiven an array representing the marks of N students, write a function to reconstruct the original marks array from the given array, where each mark is represented as the sum of n-digit numbers.\n\nThe function reconstructMarks(arr) takes the given array as input and returns the reconstructed marks array.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef reconstructMarks(arr: List[int]) -> List[int]:\n    reconstructed = []\n    for num in arr:\n        reconstructed.append(int(str(num)[0]))\n    return reconstructed\n\n[/Code 2]\n\n[Asserts 2]\n\nassert reconstructMarks([11, 22, 33, 44]) == [1, 2, 3, 4]\nassert reconstructMarks([456, 789, 123, 555]) == [4, 7, 1, 5]\nassert reconstructMarks([100, 200, 300, 400]) == [1, 2, 3, 4]\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'subarray', 'positive integers', 'sum', 'minimum', 'length', 'search', 'iteration']", "prompt_tokens": 629, "total_tokens": 971, "completion_tokens": 342, "completion": "[Question 2]\n\nYou are given an unordered list of positive integers. Write a function to find the length of the minimum subarray that, when its elements are added together, the sum is greater than or equal to a given value K.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\nimport sys\n\ndef minimumSubarrayLength(nums: List[int], k: int) -> int:\n    n = len(nums)\n    min_length = sys.maxsize\n    for start in range(n):\n        curr_sum = nums[start]\n        if (curr_sum >= k):\n            return 1\n          \n        for end in range(start + 1, n):\n            curr_sum += nums[end]\n            if (curr_sum >= k and (end - start + 1) < min_length):\n                min_length = (end - start + 1)\n    \n    return min_length if min_length != sys.maxsize else 0\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minimumSubarrayLength([1, 4, 45, 6, 0, 19], 51) == 3\nassert minimumSubarrayLength([1, 10, 5, 2, 7], 9) == 1\nassert minimumSubarrayLength([1, 11, 100, 1, 0, 200, 3, 2, 1], 280) == 4\nassert minimumSubarrayLength([3, 2, 7, 10, 1, 1, 9, 6], 34) == 3\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['matrix', 'queries', 'even', 'count', 'update', 'cell']", "prompt_tokens": 646, "total_tokens": 1185, "completion_tokens": 539, "completion": "[Question 2]\n\nYou are given a matrix of size m x n representing the layout of servers in a data center. Write a function to find the number of smaller, even distance cells from each cell to the nearest right-angled cell in the matrix for a given list of Q queries.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\ndef findSmallerEvenDistance(m: int, n: int, Q: int, servers: List[List[int]], queries: List[List[int]]) -> List[int]:\n    def findDistance(x1, y1, x2, y2):\n        return abs(x1 - x2) + abs(y1 - y2)\n\n    def nearestRightAngledCell(x, y, m, n):\n        minDist = float('inf')\n        for i in range(m):\n            for j in range(n):\n                if (i != x or j != y) and (i != x and j != y):\n                    dist = findDistance(i, j, x, y)\n                    if dist < minDist:\n                        minDist = dist\n        return minDist\n\n    result = []\n    for q in queries:\n        x, y = q\n        smallerEvenCount = 0\n        nearestDist = nearestRightAngledCell(x, y, m, n)\n        for i in range(m):\n            for j in range(n):\n                if findDistance(i, j, x, y) < nearestDist and (i != x or j != y) and (i != x and j != y) and servers[i][j] % 2 == 0:\n                    smallerEvenCount += 1\n        result.append(smallerEvenCount)\n    return result\n\n[/Code 2]\n\n[Asserts 2]\n\nassert findSmallerEvenDistance(3, 3, 3, [[1, 2, 3], [4, 5, 6], [7, 8, 9]], [[0, 0], [1, 1], [2, 2]]) == [1, 4, 5]\nassert findSmallerEvenDistance(2, 2, 2, [[2, 3], [5, 6]], [[0, 0], [1, 0]]) == [0, 1]\nassert findSmallerEvenDistance(2, 3, 2, [[1, 2, 3], [4, 5, 6]], [[0, 0], [1, 2]]) == [2, 1]\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['ladder', 'height', 'unreachable', 'reach', 'maximum', 'step', 'integer', 'task', 'array', 'condition']", "prompt_tokens": 742, "total_tokens": 1115, "completion_tokens": 373, "completion": "[Question 2]\n\nGiven an infinite string composed of integers and characters from an array S[], write a function to determine the maximum height of a Binary Search Tree (BST) that can be formed using the integers from the string. The task is to then perform queries to check if a given integer 'k' can be present as a node in the BST under the condition that the node cannot be unreachable from the root.\n\n[/Question 2]\n\n[Code 2]\n\nclass Node:\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n\ndef constructBSTUtil(arr, l, r):\n    if l > r:\n        return None\n    mid = (l + r) // 2\n    root = Node(arr[mid])\n    root.left = constructBSTUtil(arr, l, mid - 1)\n    root.right = constructBSTUtil(arr, mid + 1, r)\n    return root\n\ndef constructBST(arr):\n    return constructBSTUtil(arr, 0, len(arr) - 1)\n\ndef isPresent(root, k):\n    if root is None:\n        return False\n    if root.key == k:\n        return True\n    if root.key < k:\n        return isPresent(root.right, k)\n    return isPresent(root.left, k)\n\n[/Code 2]\n\n[Asserts 2]\n\narr = [2, 3, 4, 6, 8, 10, 15, 20, 22, 25]\nroot = constructBST(arr)\nassert isPresent(root, 8) == True\nassert isPresent(root, 11) == False\nassert isPresent(root, 1) == False\nassert isPresent(root, 26) == False\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'integer', 'append', 'condition', 'pair', 'indices', 'maximum']", "prompt_tokens": 628, "total_tokens": 1011, "completion_tokens": 383, "completion": "[Question 2]\n\nYou are given an integer array representing the load balance across different servers. Your task is to find the shortest path to balance the load among servers by calculating the maximum consecutive differences between the loads and appending load values in the array with a specific condition.\n\nImplement a function to find the maximum consecutive difference and append load values to satisfy the condition of load balancing.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\ndef balanceLoad(arr: List[int]) -> List[int]:\n    n = len(arr)\n    max_diff = float('-inf')\n    idx = -1\n    for i in range(n-1):\n        diff = abs(arr[i] - arr[i+1])\n        if diff > max_diff:\n            max_diff = diff\n            idx = i\n    balanced_load = arr[:idx+1] + [max(arr[idx], arr[idx+1])] + arr[idx+1:]\n    return balanced_load\n\n[/Code 2]\n\n[Asserts 2]\n\nassert balanceLoad([10, 2, 12, 14, 5, 11, 8, 15]) == [10, 2, 14, 14, 5, 11, 8, 15]\nassert balanceLoad([3, 7, 5, 9, 12, 15, 18]) == [3, 7, 12, 12, 15, 18, 18]\nassert balanceLoad([20, 10, 15, 5, 25]) == [20, 10, 20, 15, 5, 25]\nassert balanceLoad([12, 15, 25, 10, 5]) == [12, 15, 25, 25, 10, 5]\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['parabola', 'equation', 'point', 'satisfy', 'boolean', 'quadratic', 'curve', 'geometry']", "prompt_tokens": 585, "total_tokens": 954, "completion_tokens": 369, "completion": "[Question 2]\n\nGiven a list of points in the form (x, y), write a function to determine if these points lie on or above the curve of a parabola represented by the equation y = Ax^2 + Bx + C. The function should return a boolean array indicating for each point if it satisfies the equation of the parabola or lies above it.\n\n[/Question 2]\n\n[Code 2]\n\ndef satisfyParabolaCurve(A: int, B: int, C: int, points: List[Tuple[int, int]]) -> List[bool]:\n    result = []\n    for point in points:\n        x, y = point\n        result.append(y >= (A*x*x + B*x + C))\n    return result\n\n[/Code 2]\n\n[Asserts 2]\n\nassert satisfyParabolaCurve(1, 2, 1, [(1, 4), (2, 5), (-1, 2), (3, 10)]) == [True, True, True, True]\nassert satisfyParabolaCurve(2, -1, 4, [(1, 5), (2, 10), (-1, 1), (3, 20)]) == [True, True, True, True]\nassert satisfyParabolaCurve(3, 0, -2, [(1, 7), (2, 16), (-1, 1), (3, 31)]) == [True, True, True, True]\nassert satisfyParabolaCurve(-1, 2, 3, [(1, 0), (2, 2), (-1, 6), (3, 10)]) == [False, False, True, True]\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'integer', 'divide', 'count', 'multiple', 'largest', 'frequency']", "prompt_tokens": 583, "total_tokens": 881, "completion_tokens": 298, "completion": "[Question 2]\n\nGiven an array of integers, write a function to find the largest integer that can be formed by swapping the digits at multiple pairs of indices. If there is a mismatch in the count of 1s and the destination node's frequency is greater than the starting node's frequency, divide the count of 1s by the largest letter's frequency in the array.\n\n[/Question 2]\n\n[Code 2]\n\ndef largestSwapWithMismatch(arr):\n    s = [int(x) for x in str(max(arr))]\n    t = [int(x) for x in str(max(arr))]\n    s.sort(reverse = True)\n    if s!=t:\n        ones_count = arr.count(1)\n        max_freq = max(arr.count(chr(i+65)) for i in range(26))\n        dest_freq = arr.count(chr(max(arr)+65))\n        if ones_count!=dest_freq and dest_freq>max_freq:\n            return ones_count//max_freq\n    return int(''.join(map(str, s)))\n\n[/Code 2]\n\n[Asserts 2]\n\nassert largestSwapWithMismatch([123, 781, 923, 501])==321\nassert largestSwapWithMismatch([432, 945, 192, 675])==954\nassert largestSwapWithMismatch([11, 22, 33, 44, 55])==11\nassert largestSwapWithMismatch([123, 456, 789, 101112])==321", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['number', 'sum', 'digits', 'palindrome', 'reversed']", "prompt_tokens": 495, "total_tokens": 804, "completion_tokens": 309, "completion": "[Question 2]\n\nYou are given a list of numbers. Write a function to find the sum of the digits of each number and return the count of numbers for which the sum of the digits is a palindrome and the count of numbers for which the sum of the digits is not a palindrome.\n\n[/Question 2]\n\n[Code 2]\n\ndef isPalindrome(n: int) -> bool:\n    return str(n) == str(n)[::-1]\n\ndef sumOfDigits(number: int) -> int:\n    return sum([int(digit) for digit in str(number)])\n\ndef countPalindromeSumNumbers(numbers: List[int]) -> Tuple[int, int]:\n    palindrome_count = 0\n    non_palindrome_count = 0\n    for num in numbers:\n        digit_sum = sumOfDigits(num)\n        if isPalindrome(digit_sum):\n            palindrome_count += 1\n        else:\n            non_palindrome_count += 1\n    return (palindrome_count, non_palindrome_count)\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countPalindromeSumNumbers([123, 456, 789, 121, 131, 555])== (2, 4)\nassert countPalindromeSumNumbers([111, 121, 131, 141, 151])== (5, 0)\nassert countPalindromeSumNumbers([12, 22, 32, 42, 52, 62, 72, 82, 92, 102])== (3, 7)", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['XOR', 'bitwise', 'math', 'modulo', 'operation', 'binary']", "prompt_tokens": 497, "total_tokens": 805, "completion_tokens": 308, "completion": "[Question 2]\n\nGiven an array of integers, find the number of pairs (i, j) such that j > i and the XOR of the elements from index i to j is a negative number.\n\n[/Question 2]\n\n[Code 2]\n\ndef countNegativeXorPairs(arr: List[int]) -> int:\n    prefixXor = [0]\n    for num in arr:\n        prefixXor.append(prefixXor[-1] ^ num)\n    \n    count = 0\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if j > i and (prefixXor[j + 1] ^ prefixXor[i]) < 0:\n                count += 1\n    return count\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countNegativeXorPairs([3, 7, 8, 2, 10]) == 3\nassert countNegativeXorPairs([5, 15, 7, 2, 8, 10]) == 4\nassert countNegativeXorPairs([8, 3, 12, 7, 6, 4]) == 2\nassert countNegativeXorPairs([4, 5, 8, 3, 6]) == 1\nassert countNegativeXorPairs([10, 12, 15, 17, 21, 25]) == 0\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['integer', 'grid', 'cost', 'arrangements', 'sum', 'factorial']", "prompt_tokens": 510, "total_tokens": 865, "completion_tokens": 355, "completion": "[Question 2]\n\nYou are given an irregular grid of integers representing the cost associated with each cell. The task is to find the sum of the costs for all congruent arrangements that do not exceed a given cost limit, while considering the relative order of the cells.\n\n[/Question 2]\n\n[Code 2]\n\ndef sumOfCongruentArrangementsCost(grid: List[List[int]], cost_limit: int) -> int:\n    nrows = len(grid)\n    ncols = len(grid[0])\n    \n    total_cost = 0\n    for r in range(nrows):\n        for c in range(ncols):\n            for i in range(r, nrows):\n                for j in range(c, ncols):\n                    congruent_sum = 0\n                    for x in range(r, i+1):\n                        for y in range(c, j+1):\n                            congruent_sum += grid[x][y]\n                    if congruent_sum <= cost_limit:\n                        total_cost += congruent_sum\n    return total_cost\n  \n[/Code 2]\n\n[Asserts 2]\n\nassert sumOfCongruentArrangementsCost([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 12) == 45\nassert sumOfCongruentArrangementsCost([[3, 1, 2], [4, 2, 1], [5, 6, 3]], 5) == 19\nassert sumOfCongruentArrangementsCost([[5, 4, 3], [2, 1, 3], [6, 7, 8]], 6) == 21\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['fraction', 'proper fraction', 'digit', 'numerator', 'denominator', 'set', 'loop', 'division', 'remainder', 'string']", "prompt_tokens": 643, "total_tokens": 903, "completion_tokens": 260, "completion": "[Question 2]\n\nGiven a string and a size k, write a program to find the switch indices in the string such that when the string is divided into proper fractions with a denominator less than or equal to k, each fraction satisfies a specific condition.\n\nThe condition is that the sum of the digits in the numerator of each proper fraction should be greater than the remainder when divided by the denominator.\n\nReturn the list of column-wise switch indices that satisfy the condition.\n\n[/Question 2]\n\n[Code 2]\n\ndef findSwitchIndices(s: str, k: int) -> list:\n    switch_indices = []\n    n = len(s)\n\n    for i in range(0, n, k):\n        numerator_sum = 0\n        for j in range(i, min(i + k, n)):\n            numerator_sum += int(s[j])\n        \n        remainder = numerator_sum % k\n        if remainder < numerator_sum:\n            switch_indices.append(i + k - 1)\n    \n    return switch_indices\n\n[/Code 2]\n\n[Asserts 2]\n\nassert findSwitchIndices(\"123456789\", 3) == [2, 5, 8]\nassert findSwitchIndices(\"987654321\", 2) == [1, 3, 5, 7]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'query', 'update', 'sum', 'operation']", "prompt_tokens": 509, "total_tokens": 763, "completion_tokens": 254, "completion": "[Question 2]\n\nYou are given a calendar represented as an array of integers where each element represents the number of events on a particular day. You need to perform an update operation on the calendar array and then provide the sum of events within a specific depth.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef updateAndSumEvents(calendar: List[int], startIndex: int, endIndex: int, updateValue: int, depth: int) -> int:\n    for i in range(startIndex, endIndex+1):\n        calendar[i] += updateValue\n    sorted_calendar = sorted(calendar, reverse=True)\n    return sum(sorted_calendar[:depth])\n\n[/Code 2]\n\n[Asserts 2]\n\nassert updateAndSumEvents([1, 2, 3, 4, 5], 1, 3, 2, 2)==12\nassert updateAndSumEvents([0, 0, 0, 0, 0], 0, 4, 3, 3)==9\nassert updateAndSumEvents([5, 4, 3, 2, 1], 3, 4, 5, 2)==15\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['positive integer', 'binary representation', 'Hamming weight', 'closest integer', 'bit manipulation', 'bitwise operations']", "prompt_tokens": 528, "total_tokens": 751, "completion_tokens": 223, "completion": "[Question 2]\n\nWrite a function to determine if a given positive integer can be expressed as the square of the Hamming weight of a non-negative integer.\n\nGiven a positive integer, write a method to check if it can be expressed as the square of the Hamming weight of a non-negative integer using bit manipulation and bitwise operations.\n\n[/Question 2]\n\n[Code 2]\n\ndef isSquareOfHammingWeight(num: int) -> bool:\n    def hammingWeight(x: int) -> int:\n        count = 0\n        while x:\n            count += 1\n            x &= x - 1\n        return count\n    \n    for i in range(num+1):\n        if i*i == hammingWeight(num):\n            return True\n    return False\n\n[/Code 2]\n\n[Asserts 2]\n\nassert isSquareOfHammingWeight(16)==True\nassert isSquareOfHammingWeight(25)==False\nassert isSquareOfHammingWeight(36)==True\nassert isSquareOfHammingWeight(49)==False\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['grid', 'count', 'squares', 'side length', '1', '0', 'dynamic programming', 'minimum', 'size']", "prompt_tokens": 596, "total_tokens": 927, "completion_tokens": 331, "completion": "[Question 2]\n\nGiven a binary tree, you are asked to find the minimum side length of the squares which have at least n nodes where n is the count of nodes in the binary tree.\n\n[/Question 2]\n\n[Code 2]\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef postorderTraversal(root):\n    if root is None:\n        return []\n    return postorderTraversal(root.left) + postorderTraversal(root.right) + [root.val]\n\ndef countSquaresWithNNodes(root, n):\n    postorder = postorderTraversal(root)\n    if len(postorder) < n:\n        return -1\n    start, end = 1, sum(postorder)\n    while start < end:\n        mid = (start + end) // 2\n        cnt = sum(x >= mid*mid for x in postorder)\n        if cnt < n:\n            end = mid\n        else:\n            start = mid + 1\n    return start\n\n[/Code 2]\n\n[Asserts 2]\n\n# Example 1\nroot1 = TreeNode(3, TreeNode(1), TreeNode(4, TreeNode(2)))\nassert countSquaresWithNNodes(root1, 3) == 2\n\n# Example 2\nroot2 = TreeNode(5, TreeNode(3, TreeNode(1), TreeNode(4)), TreeNode(6))\nassert countSquaresWithNNodes(root2, 4) == 9\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['integer', 'palindrome', 'list', 'digits', 'range', 'iteration']", "prompt_tokens": 739, "total_tokens": 978, "completion_tokens": 239, "completion": "[Question 2]\n\nGiven a list of integers, find the longest lexicographically smallest palindrome that can be formed as a concatenation of elements from the list. If no such palindrome can be formed, return -1.\n\n[/Question 2]\n\n[Code 2]\n\ndef longestLexicographicallySmallestPalindrome(arr: list) -> int:\n    palindrome = ''\n    arr.sort()\n    for num in arr:\n        if str(num) == str(num)[::-1] and (not palindrome or num <= int(palindrome[0])):\n            palindrome += str(num)\n    return int(palindrome) if palindrome else -1\n\n[/Code 2]\n\n[Asserts 2]\n\nassert longestLexicographicallySmallestPalindrome([121, 131, 141, 151, 161, 171, 181, 191]) == 121131141151161171181191\nassert longestLexicographicallySmallestPalindrome([123, 456, 789, 1001]) == 1001\nassert longestLexicographicallySmallestPalindrome([12, 36, 78, 90]) == -1\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['positive integer', 'moves', 'reach', 'point', 'rules', 'iteration', 'division', 'addition']", "prompt_tokens": 499, "total_tokens": 705, "completion_tokens": 206, "completion": "[Question 2]\n\nYou are given a positive integer N, and you can repeatedly perform the following operation:\n\n- If N is even, divide N by 2\n- If N is odd, modify N to 3N + 1\n- Continue this iteration until N reaches the maximum height under given rules\n- Write a function to calculate the infinite sum of the values of N reached in this process.\n\n[/Question 2]\n\n[Code 2]\n\ndef infiniteSum(N: int) -> int:\n    total_sum = N\n    while N != 1:\n        if N % 2 == 0:\n            N //= 2\n        else:\n            N = 3 * N + 1\n        total_sum += N\n    return total_sum\n\n[/Code 2]\n\n[Asserts 2]\n\nassert infiniteSum(5)==46\nassert infiniteSum(7)==83\nassert infiniteSum(10)==73\nassert infiniteSum(13)==160\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['positive integer', 'minimum value', 'modulus', 'nested loop']", "prompt_tokens": 434, "total_tokens": 640, "completion_tokens": 206, "completion": "[Question 2]\n\nGiven a positive integer N, write a function to find the minimum value of x^3 % N for all odd values of x between 1 and N. Return the minimum value along with the corresponding value of x as a tuple.\n\n[/Question 2]\n\n[Code 2]\n\ndef minOddPowerModulus(N: int) -> (int, int):\n    minVal = float('inf')\n    minX = -1\n    for x in range(1, N+1, 2):\n        res = (x**3) % N\n        if res < minVal:\n            minVal = res\n            minX = x\n    return (minVal, minX)\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minOddPowerModulus(10)==(1, 1)\nassert minOddPowerModulus(15)==(6, 3)\nassert minOddPowerModulus(20)==(1, 1)\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['positive integer', 'sum', 'distinct', 'list', 'division', 'return', 'empty', 'possible']", "prompt_tokens": 593, "total_tokens": 933, "completion_tokens": 340, "completion": "[Question 2]\n\nWrite a function to check if it is possible to represent a given byte array as the sum of distinct positive integers such that each integer when multiplied by its position (1-indexed from the right side) results in the byte at that position. If possible, then return the list of such distinct positive integers. If not possible, return an empty list.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List, Union\n\ndef findDistinctIntegers(arr: List[int]) -> Union[List[int], None]:\n    n = len(arr)\n    arr.reverse()\n    sums = [0] * n\n    for i in range(n-1, -1, -1):\n        sums[i] = arr[i] - sums[i] * (n - i)\n        if sums[i] <= 0:\n            return None\n        if i > 0:\n            sums[i-1] = sums[i-1] + sums[i]\n    return sums\n\n[/Code 2]\n\n[Asserts 2]\n\nassert findDistinctIntegers([3, 7, 5, 13, 11])==[1, 2, 3]\nassert findDistinctIntegers([3, 4, 5, 6, 7])==[1, 2]\nassert findDistinctIntegers([10, 3, 21, 4])==[1, 4]\nassert findDistinctIntegers([6, 2, 1, 6, 7])==None\nassert findDistinctIntegers([8, 4, 2, 4, 8])==None\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'pairs', 'difference', 'indices', 'count']", "prompt_tokens": 512, "total_tokens": 832, "completion_tokens": 320, "completion": "[Question 2]\n\nGiven an array representing a gray code sequence, find the count of pairs of indices in the array such that the difference between the values at those indices is equal to the circumference of the gray code sequence within a given time frame.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef countPairsWithCircumference(arr: List[int], circumference: int, time_frame: int) -> int:\n    count = 0\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if abs(arr[i] - arr[j]) == circumference and (j - i) <= time_frame:\n                count += 1\n    return count\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countPairsWithCircumference([0, 1, 3, 2, 6, 7, 5, 4], 2, 3)==3\nassert countPairsWithCircumference([0, 1, 3, 2, 6, 7, 5, 4], 4, 3)==0\nassert countPairsWithCircumference([0, 1, 3, 2, 6, 7, 5, 4], 2, 4)==6\nassert countPairsWithCircumference([1, 3, 6, 4, 7, 9], 3, 2)==1\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['math', 'division', 'iteration', 'minimization', 'condition', 'arithmetic', 'optimization']", "prompt_tokens": 463, "total_tokens": 704, "completion_tokens": 241, "completion": "[Question 2]\n\nYou are given an array of integers. Find the minimum number of operations required to make all elements of the array equal. The only operation allowed is to increment or decrement an element by 1. \n\n[/Question 2]\n\n[Code 2]\n\ndef minOperationsToEqualize(arr: List[int]) -> int:\n    target = sum(arr) // len(arr)\n    operations = 0\n    for num in arr:\n        operations += abs(num - target)\n    return operations\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minOperationsToEqualize([1, 2, 3, 4, 5])==6\nassert minOperationsToEqualize([10, 10, 10, 10])==0\nassert minOperationsToEqualize([1, 1, 3, 3, 5, 5])==6\nassert minOperationsToEqualize([1, 2, 3, 4, 5, 6])==9\nassert minOperationsToEqualize([1, 1, 2, 2, 3, 3])==3\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['recursion', 'dynamic programming', 'greedy', 'math', 'minimum', 'division']", "prompt_tokens": 538, "total_tokens": 814, "completion_tokens": 276, "completion": "[Question 2]\n\nWrite a function to find the nth Ugly Number. Ugly numbers are positive numbers whose prime factors only include 2, 3, or 5. \n\nFor example, the first 10 ugly numbers are 1, 2, 3, 4, 5, 6, 8, 9, 10, 12.\n\n[/Question 2]\n\n[Code 2]\n\ndef nthUglyNumber(n: int) -> int:\n    ugly = [1]\n    i2 = i3 = i5 = 0\n    while len(ugly) < n:\n        next_ugly = min(ugly[i2]*2, ugly[i3]*3, ugly[i5]*5)\n        if next_ugly == ugly[i2]*2:\n            i2 += 1\n        if next_ugly == ugly[i3]*3:\n            i3 += 1\n        if next_ugly == ugly[i5]*5:\n            i5 += 1\n        ugly.append(next_ugly)\n    return ugly[-1]\n\n[/Code 2]\n\n[Asserts 2]\n\nassert nthUglyNumber(10) == 12\nassert nthUglyNumber(15) == 24\nassert nthUglyNumber(20) == 36", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['number', 'change', 'digit', 'largest', 'integer', 'modification']", "prompt_tokens": 549, "total_tokens": 1031, "completion_tokens": 482, "completion": "[Question 2]\n\nYou are given a list of integers representing the heights of a fence. The width of each fence panel is 1. You are allowed to change the height of at most K consecutive panels to any integer. The task is to find the maximum height of the fence that can be achieved after making the at most K changes.\n\n[/Question 2]\n\n[Code 2]\n\ndef maximumFenceHeight(heights: List[int], k: int) -> int:\n    n = len(heights)\n    prefix_max, suffix_max = [0] * (n + 1), [0] * (n + 1)\n    for i in range(1, n + 1):\n        prefix_max[i] = max(prefix_max[i - 1], heights[i - 1])\n    for i in range(n - 1, -1, -1):\n        suffix_max[i] = max(suffix_max[i + 1], heights[i])\n    max_height = 0\n    for i in range(n):\n        max_height = max(max_height, heights[i])\n        window_size = i + 1 if i < n - i else n - i\n        max_window_height = max(prefix_max[i + 1], suffix_max[i - window_size + 1])\n        additional_changes = min(k, window_size - 1)\n        max_height = max(max_height, min(max_window_height + additional_changes, max(heights[i] + k - additional_changes, max_height)))\n    return max_height\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maximumFenceHeight([1, 2, 1, 2, 1], 3) == 4\nassert maximumFenceHeight([1, 2, 1, 2, 1], 3) == 4\nassert maximumFenceHeight([1, 3, 2, 1, 2, 3, 2, 3], 4) == 6\nassert maximumFenceHeight([3, 1, 6, 4, 5, 2], 2) == 6\nassert maximumFenceHeight([7, 1, 2, 5, 4, 6, 1], 3) == 7\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['integer', 'anagram', 'permutation', 'rearrangement', 'identical', 'boolean']", "prompt_tokens": 504, "total_tokens": 808, "completion_tokens": 304, "completion": "[Question 2]\n\nYou are given an unsorted array of integer coordinates representing points on a 2D plane. Write a function to check if there exists a \"king\" in the coordinate points. A \"king\" is a point on the plane, such that it has a set bit in its binary representation at the same position as the prefix-sum of the x and y coordinates of the other points.\n\n[/Question 2]\n\n[Code 2]\n\ndef hasKing(arr: List[Tuple[int, int]]) -> bool:\n    prefix_sum_x = 0\n    prefix_sum_y = 0\n    for x, y in arr:\n        prefix_sum_x += x\n        prefix_sum_y += y\n    return any((point[0] & prefix_sum_x) and (point[1] & prefix_sum_y) for point in arr)\n\n[/Code 2]\n\n[Asserts 2]\n\nassert hasKing([(1, 1), (2, 3), (3, 2)])==True\nassert hasKing([(0, 0), (1, 1), (2, 2)])==False\nassert hasKing([(3, 3), (4, 4), (5, 5)])==True\nassert hasKing([(7, 2), (6, 4), (5, 3)])==False\nassert hasKing([(8, 8), (4, 4), (2, 2)])==False", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['geometry', 'regular polygon', 'angle', 'occurrences', 'combinations', 'vertices']", "prompt_tokens": 503, "total_tokens": 869, "completion_tokens": 366, "completion": "[Question 2]\n\nYou are given a list of vertices representing the coordinates of a regular polygon in 2D space. Write a function to find the minimum value of the angles formed by any three vertices simultaneously. The polygon may not be balanced, and the angles should be calculated beginning from one vertex and moving sequentially to the next. Return the minimum angle value as a float.\n\n[/Question 2]\n\n[Code 2]\n\nfrom math import atan2, degrees\n\ndef minAngleValue(vertices: list) -> float:\n    angles = []\n    n = len(vertices)\n    for i in range(n):\n        x1, y1 = vertices[i]\n        x2, y2 = vertices[(i + 1) % n]\n        x3, y3 = vertices[(i + 2) % n]\n        angle = abs(degrees(atan2(y2 - y1, x2 - x1) - atan2(y3 - y2, x3 - x2)))\n        angles.append(min(angle, 360 - angle))\n    return min(angles)\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minAngleValue([(0, 0), (1, 0), (0, 1)]) == 45.0\nassert minAngleValue([(0, 0), (1, 1), (2, 0), (1, -1)]) == 45.0\nassert minAngleValue([(0, 0), (1, 1), (1, 0), (1, 2)]) == 45.0\nassert minAngleValue([(0, 0), (2, 0), (1, 1), (1, -1)]) == 45.0\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['integer', 'prime number', 'sum', 'conditional', 'loop', 'math', 'range']", "prompt_tokens": 715, "total_tokens": 1066, "completion_tokens": 351, "completion": "[Question 2]\n\nYou are given a positive integer n. Your task is to find the sum of all integers between 1 and n (inclusive) whose greatest divisor is an even number.\n\nWrite a function that takes in a positive integer n and returns the sum of all integers between 1 and n (inclusive) whose greatest divisor is an even number.\n\nFor example,\n- For n=10, the integers between 1 and 10 with greatest divisor as an even number are 2, 4, 6, 8, 9, and the sum is 29.\n- For n=15, the integers between 1 and 15 with greatest divisor as an even number are 2, 4, 6, 8, 10, 12, and the sum is 42.\n\n[/Question 2]\n\n[Code 2]\n\ndef greatestDivisor(n: int) -> int:\n    for i in range(n//2, 0, -1):\n        if n % i == 0:\n            return i\n\ndef sumOfEvenGreatestDivisors(n: int) -> int:\n    total_sum = 0\n    for num in range(1, n+1):\n        if greatestDivisor(num) % 2 == 0:\n            total_sum += num\n    return total_sum\n\n[/Code 2]\n\n[Asserts 2]\n\nassert sumOfEvenGreatestDivisors(10) == 29\nassert sumOfEvenGreatestDivisors(15) == 42\nassert sumOfEvenGreatestDivisors(20) == 62\nassert sumOfEvenGreatestDivisors(25) == 67\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['combinatorics', 'selection', 'men', 'group', 'ways']", "prompt_tokens": 481, "total_tokens": 735, "completion_tokens": 254, "completion": "[Question 2]\n\nYou have to calculate the maximum distance between two men selected from a group of N men. Each man has an associated price, and you need to approximate the total price of an odd power of the max distance.\n\n[/Question 2]\n\n[Code 2]\n\ndef maxDistOddPowerPrice(N: int, prices: List[int]) -> int:\n\tmax_distance = 0\n\tfor i in range(N):\n\t\tfor j in range(i + 1, N):\n\t\t\tdistance = abs(prices[i] - prices[j])\n\t\t\tmax_distance = max(max_distance, distance)\n\treturn int(max_distance ** 3)\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maxDistOddPowerPrice(5, [10, 20, 15, 30, 25]) == 3375\nassert maxDistOddPowerPrice(3, [5, 8, 12]) == 64\nassert maxDistOddPowerPrice(4, [3, 7, 9, 11]) == 512\nassert maxDistOddPowerPrice(6, [5, 10, 15, 20, 25, 30]) == 3375\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['integer', 'factorial', 'maximum', 'power', 'division', 'loop']", "prompt_tokens": 473, "total_tokens": 684, "completion_tokens": 211, "completion": "[Question 2]\n\nYou are given an array of integers. Write a function to determine if the array is superincreasing, which means each element in the array is greater than the sum of all the previous elements. Return True if the array is superincreasing, and False otherwise.\n\n[/Question 2]\n\n[Code 2]\n\ndef isSuperincreasing(arr):\n    current_sum = 0\n    for num in arr:\n        if num <= current_sum:\n            return False\n        current_sum += num\n    return True\n\n[/Code 2]\n\n[Asserts 2]\n\nassert isSuperincreasing([1, 2, 4, 8, 16]) == True\nassert isSuperincreasing([1, 2, 3, 7, 10]) == False\nassert isSuperincreasing([3, 6, 11, 21, 40]) == True\nassert isSuperincreasing([1, 3, 6, 10, 15]) == False", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['digits', 'maximum', 'number', 'form', 'value', 'list', 'numeric', 'function', 'possible']", "prompt_tokens": 772, "total_tokens": 1160, "completion_tokens": 388, "completion": "[Question 2]\n\nYou are given a list of integers where each integer represents the probability of getting heads when a coin is flipped. The task is to find the maximum probability of getting heads when a coin is flipped multiple times.\n\nWrite a function `max_heads_probability(probabilities: List[int]) -> float` that takes in a list `probabilities` where each element `probabilities[i]` represents the probability of getting heads for the ith coin and returns the maximum probability of getting heads when flipping all the coins.\n\nFor example:\n- If `probabilities = [30, 50, 70]`, then the maximum probability of getting heads when flipping all the coins is 0.7, so the function should return 0.7.\n- If `probabilities = [10, 20, 30, 40, 50]`, then the maximum probability of getting heads when flipping all the coins is 0.5, so the function should return 0.5.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\ndef max_heads_probability(probabilities: List[int]) -> float:\n    max_prob = max(probabilities) / 100\n    return max_prob\n\n[/Code 2]\n\n[Asserts 2]\n\nassert max_heads_probability([30, 50, 70]) == 0.7\nassert max_heads_probability([10, 20, 30, 40, 50]) == 0.5\nassert max_heads_probability([70, 60, 50, 40]) == 0.7\nassert max_heads_probability([10, 20, 30, 40, 10, 20, 30, 40]) == 0.4\nassert max_heads_probability([0, 0, 0, 0, 0]) == 0.0\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'cost', 'minimize', 'element', 'sorting', 'optimization', 'math']", "prompt_tokens": 576, "total_tokens": 1028, "completion_tokens": 452, "completion": "[Question 2]\n\nGiven an array arr[] of N non-negative integers, the task is to minimize the cost of splitting the array into K non-empty, non-decreasing groups. The cost of splitting an array a[l..r] into two non-empty groups (a[l..m], a[m+1..r]) is defined as the sum of the elements in the two groups.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef minimizeSplitCost(arr: List[int], K: int) -> int:\n    n = len(arr)\n    memo = [[0] * (K + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        memo[i][1] = memo[i - 1][1] + arr[i - 1]\n    for j in range(1, K + 1):\n        memo[1][j] = arr[0]\n    for i in range(2, n + 1):\n        for j in range(2, K + 1):\n            memo[i][j] = float('inf')\n            for m in range(1, i):\n                memo[i][j] = min(memo[i][j], max(memo[m][j - 1], sum(arr[m:i])))\n    return memo[n][K]\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minimizeSplitCost([10, 7, 8, 10, 12, 16, 18, 19, 23, 21], 3) == 42\nassert minimizeSplitCost([1, 2, 3, 4, 5, 6, 7, 8, 9], 2) == 45\nassert minimizeSplitCost([5, 2, 4, 6, 2, 7, 1, 9, 4, 3, 5], 4) == 27\nassert minimizeSplitCost([1, 2, 3, 1, 2, 3, 1, 2, 3], 3) == 7", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'subarray', 'positive', 'product', 'counting', 'iteration', 'nested loop', 'logic']", "prompt_tokens": 590, "total_tokens": 862, "completion_tokens": 272, "completion": "[Question 2]\n\nYou are given an array of integers. Write a function to determine if there exists a subarray whose product converges to a positive value when all negative numbers are exchanged with their absolute values.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef convergesToPositiveProduct(nums: List[int]) -> bool:\n        n = len(nums)\n\t    for i in range(n):\n\t\t    product = 1\n\t\t    for j in range(i, n):\n\t\t\t    if nums[j] < 0:\n\t\t\t\t    product *= abs(nums[j])\n\t\t\t    else:\n\t\t\t\t    product *= nums[j]\n\t\t\t    if product > 0:\n\t\t\t\t    return True\n\t    return False\n\n[/Code 2]\n\n[Asserts 2]\n\nassert convergesToPositiveProduct([1, -2, 3, -4, 5])==True\nassert convergesToPositiveProduct([-1, -2, -3, -4, -5])==False\nassert convergesToPositiveProduct([1, 2, 3, 4, 5])==True\nassert convergesToPositiveProduct([1, -2, 3, 0, 5])==True\nassert convergesToPositiveProduct([0, 0, 0, 0, 0])==False\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['sum', 'natural numbers', 'large numbers', 'math', 'series', 'arithmetic']", "prompt_tokens": 488, "total_tokens": 656, "completion_tokens": 168, "completion": "[Question 2]\n\nWrite a function to calculate the sum of all divisors of a given natural number for large input values.\n\n[/Question 2]\n\n[Code 2]\n\ndef sumDivisors(n: int) -> int:\n    result = 0\n    i = 1\n    while i <= n**0.5:\n        if n % i == 0:\n            if n / i == i:\n                result += i\n            else:\n                result += (i + n//i)\n        i += 1\n    return result\n\n[/Code 2]\n\n[Asserts 2]\n\nassert sumDivisors(6)==12\nassert sumDivisors(28)==56\nassert sumDivisors(10000000)==27000048\nassert sumDivisors(123456789)==249652692", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'integer', 'subsequence', 'maximum', 'distance', 'sum', 'dynamic programming']", "prompt_tokens": 639, "total_tokens": 976, "completion_tokens": 337, "completion": "[Question 2]\n\nYou are given an array of integers. You need to find the maximum sum of a subsequence with the constraint that no two elements in the subsequence should be at a distance greater than K.\n\n[/Question 2]\n\n[Code 2]\n\ndef maxSumWithDistanceConstraint(arr: list, n: int, k: int) -> int:\n    incl = arr[0]\n    excl = 0\n    for i in range(1, n):\n        new_excl = max(incl, excl)\n        incl = excl + arr[i]\n        excl = new_excl\n    return max(incl, excl)\n\n[/Code 2]\n\n[Asserts 2]\n\nassert(maxSumWithDistanceConstraint([3, 2, 5, 10, 7], 5, 2)) == 15\nassert(maxSumWithDistanceConstraint([8, 2, 14, 6, 3, 15, 10, 5], 8, 3)) == 35\nassert(maxSumWithDistanceConstraint([1, 3, 4, 5, 6, 8, 2, 10], 8, 4)) == 27\nassert(maxSumWithDistanceConstraint([12, 7, 6, 8, 6, 9, 11], 7, 2)) == 30\nassert(maxSumWithDistanceConstraint([5, 6, 10, 15, 12, 5, 4, 6], 8, 3)) == 33\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['integer', 'divisibility', 'list', 'range']", "prompt_tokens": 519, "total_tokens": 842, "completion_tokens": 323, "completion": "[Question 2]\n\nImplement a function in Python that takes a list of integers and a target integer as input and returns the total number of ways the target integer can be obtained by adding up the integers from the list, without any partition and using \"Gill's method\". \n\"Gill's method\" specifies that each integer in the list can only be used once in each way and the order of the integers does not matter.\n\n[/Question 2]\n\n[Code 2]\n\ndef total_ways_to_sum(nums: List[int], target: int) -> int:\n    if target == 0:\n        return 1\n    if not nums:\n        return 0\n    ways = [0] * (target + 1)\n    ways[0] = 1\n    for num in nums:\n        for i in range(target, num - 1, -1):\n            ways[i] += ways[i - num]\n    return ways[target]\n\n[/Code 2]\n\n[Asserts 2]\n\nassert total_ways_to_sum([1, 2, 3, 4, 5], 5) == 3\nassert total_ways_to_sum([2, 2, 2, 2, 2], 4) == 2\nassert total_ways_to_sum([3, 4, 5, 6, 7], 12) == 2\nassert total_ways_to_sum([4, 5, 6, 7, 8], 16) == 1\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['probability', 'random', 'integer', 'palindrome', 'count', 'digits']", "prompt_tokens": 519, "total_tokens": 844, "completion_tokens": 325, "completion": "[Question 2]\n\nYou are given a list of integers representing the cultural values of various neighbors. You can perform a range add operation which involves adding a specific value to the cultural values of the neighbors within a given range. After performing a series of random range add operations, what is the probability that the final cultural values of the neighbors form a palindrome?\n\n[/Question 2]\n\n[Code 2]\n\ndef isPalindrome(n) -> bool:\n    return str(n) == str(n)[::-1]\n\ndef rangeAdd(neighbors: List[int], start: int, end: int, value: int) -> List[int]:\n    for i in range(start, end+1):\n        neighbors[i] += value\n    return neighbors\n\ndef finalCulturalValuesPalindromeProbability(neighbors: List[int], operations: List[tuple]) -> float:\n    for operation in operations:\n        start, end, value = operation\n        neighbors = rangeAdd(neighbors, start, end, value)\n    final_value = int(''.join(str(x) for x in neighbors))\n    return isPalindrome(final_value)\n\n[/Code 2]\n\n[Asserts 2]\n\nassert finalCulturalValuesPalindromeProbability([1, 2, 3, 4, 5], [(0, 2, 2), (1, 3, 1)]) == True\nassert finalCulturalValuesPalindromeProbability([1, 2, 3, 4, 5], [(0, 2, 2), (3, 4, 2)]) == False\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['box', 'balls', 'colors', 'choose', 'number', 'ways']", "prompt_tokens": 411, "total_tokens": 562, "completion_tokens": 151, "completion": "[Question 2]\n\nYou have a box with balls of different colors, and you want to factor in the number of ways to choose a certain number of balls from the box. Write a function to calculate the number of ways to choose a specific number of balls from the box containing different colors of balls.\n\n[/Question 2]\n\n[Code 2]\n\ndef chooseWays(colors: int, number: int) -> int:\n    return colors**number\n\n[/Code 2]\n\n[Asserts 2]\n\nassert chooseWays(2, 3)==8\nassert chooseWays(3, 2)==9\nassert chooseWays(4, 5)==1024\nassert chooseWays(5, 3)==125", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['minimize', 'sum', 'array', 'replace', 'max', 'min', 'product', 'operation']", "prompt_tokens": 587, "total_tokens": 857, "completion_tokens": 270, "completion": "[Question 2]\n\nYou have a list of hits made by a player in a game represented as an array of integers. The player's task is to minimize the number of hits by replacing the maximum element in the list with the minimum element. The operation is repeated until the list is reduced to a single element. Find the resulting list after applying these operations and return the sum of all elements in the resulting list.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef minimizeHitsSum(hits: List[int]) -> int:\n    while len(hits) > 1:\n        min_idx = hits.index(min(hits))\n        max_idx = hits.index(max(hits))\n        hits[min_idx] = min(hits)\n        del hits[max_idx]\n    return sum(hits)\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minimizeHitsSum([3, 5, 2, 8, 10])==18\nassert minimizeHitsSum([10, 20, 7])==27\nassert minimizeHitsSum([5, 4, 7, 2, 8, 1])==12\nassert minimizeHitsSum([5])==5\nassert minimizeHitsSum([10, 10, 10, 10, 10])==50\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'permutations', 'recursion', 'combinatorics', 'backtracking']", "prompt_tokens": 873, "total_tokens": 1282, "completion_tokens": 409, "completion": "[Question 2]\n\nYou are given an array arr[] of containers where each container represents a level of health. Your task is to implement a function to choose the containers to represent levels of health in a doubly circular manner and return all possible combinations.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\ndef chooseContainers(arr: List[int]) -> List[List[int]]:\n    def chooseContainersRec(arr, chosen, n, level, res, comb):\n        if len(chosen) == n:\n            res.append(chosen[:])\n            return\n        for i in range(level):\n            if i not in chosen:\n                if comb == 'levelwise' and len(chosen) > 0 and (chosen[-1] + 1) % level != i:\n                    continue\n                chosen.append(i)\n                chooseContainersRec(arr, chosen, n, level, res, comb)\n                chosen.pop()\n    res = []\n    level = len(arr)\n    for i in range(1, level + 1):\n        chooseContainersRec(arr, [], i, level, res, 'levelwise')\n    return res\n\n[/Code 2]\n\n[Asserts 2]\n\nassert chooseContainers([2, 3, 4]) == [[0], [1], [2], [0, 1], [0, 2], [1, 2], [0, 1, 2]]\nassert chooseContainers([1, 2, 3, 4]) == [[0], [1], [2], [3], [0, 1], [0, 2], [0, 3], [1, 2], [1, 3], [2, 3], [0, 1, 2], [0, 1, 3], [0, 2, 3], [1, 2, 3], [0, 1, 2, 3]]\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['math', 'series expansion', 'logarithm', 'ln', 'log10', 'Taylor series', 'change of base', 'iteration']", "prompt_tokens": 578, "total_tokens": 1006, "completion_tokens": 428, "completion": "[Question 2]\n\nGiven a binary tree, write a function to perform vertical retrieval of the non-leaf nodes using the natural logarithm (ln) and base-10 logarithm (log10) of a parameter associated with each node. Perform ordering of the retrieved nodes based on the result of the logarithmic operations using their corresponding series expansions.\n\n[/Question 2]\n\n[Code 2]\n\nclass TreeNode:\n    def __init__(self, value, left=None, right=None):\n        self.value = value\n        self.left = left\n        self.right = right\n\ndef vertical_retrieval(root: TreeNode, parameter: list) -> list:\n    logs = {}\n    ln_values = []\n    log10_values = []\n\n    def dfs(node, level):\n        if node:\n            if node.left or node.right:\n                logs[level] = logs.get(level, []) + [node.value]\n                ln_values.append((node.value, level, math.log(node.value)))\n                log10_values.append((node.value, level, math.log10(node.value))\n            dfs(node.left, level-1)\n            dfs(node.right, level+1)\n\n    dfs(root, 0)\n\n    result = []\n    for idx, val in enumerate(sorted(ln_values, key = lambda x: x[2])):\n        result.append(logs[val[1]])\n    return result\n\n[/Code 2]\n\n[Asserts 2]\n\nnode8 = TreeNode(8)\nnode4 = TreeNode(4)\nnode2 = TreeNode(2)\nnode6 = TreeNode(6)\nnode12 = TreeNode(12)\nnode10 = TreeNode(10)\nnode14 = TreeNode(14)\n\nnode8.left = node4\nnode8.right = node12\nnode4.left = node2\nnode4.right = node6\nnode12.left = node10\nnode12.right = node14\n\nassert vertical_retrieval(node8, [8, 4, 2, 6, 12, 10, 14]) == [[2], [4, 6], [8, 10, 12, 14]]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['positive', 'integer', 'sum', 'matrix', 'row', 'element', 'sequence', 'iteration']", "prompt_tokens": 512, "total_tokens": 766, "completion_tokens": 254, "completion": "[Question 2]\n\nGiven a positive integer n, find the sum of all autobiographical numbers less than or equal to n. An autobiographical number is a number such that the first digit represents the frequency of 0 in the number, the second digit represents the frequency of 1, and so on.\n\n[/Question 2]\n\n[Code 2]\n\ndef isAutobiographical(n: int) -> bool:\n    s = str(n)\n    for i in range(len(s)):\n        if s.count(str(i)) != int(s[i]):\n            return False\n    return True\n\ndef sumOfAutobiographicalNumbers(n: int) -> int:\n    totalSum = 0\n    for i in range(1, n + 1):\n        if isAutobiographical(i):\n            totalSum += i\n    return totalSum\n\n[/Code 2]\n\n[Asserts 2]\n\nassert sumOfAutobiographicalNumbers(100) == 202\nassert sumOfAutobiographicalNumbers(500) == 202\nassert sumOfAutobiographicalNumbers(1000) == 443\nassert sumOfAutobiographicalNumbers(2000) == 443\nassert sumOfAutobiographicalNumbers(5000) == 443", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['binary', 'count', 'set bits', 'bit manipulation', 'loop', 'math', 'iteration']", "prompt_tokens": 499, "total_tokens": 718, "completion_tokens": 219, "completion": "[Question 2]\n\nYou are given an array of integers, and your task is to find the total number of inversions in the array. An inversion occurs if in an array, there are two indices i and j such that i < j and array[i] > array[j].\n\n[/Question 2]\n\n[Code 2]\n\ndef countInversions(arr):\n    count = 0\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            if arr[i] > arr[j]:\n                count += 1\n    return count\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countInversions([2, 4, 1, 3, 5])==3\nassert countInversions([5, 4, 3, 2, 1])==10\nassert countInversions([1, 2, 3, 4, 5])==0\nassert countInversions([1, 5, 3, 2, 4])==4\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['number', 'divisors', 'sum', 'inverse', 'property', 'integer']", "prompt_tokens": 528, "total_tokens": 675, "completion_tokens": 147, "completion": "[Question 2]\n\nGiven an integer number, determine if it satisfies the \"power of two\" property, which means it can be expressed as 2 raised to some non-negative integer power. Return True if it satisfies the property, otherwise return False.\n\n[/Question 2]\n\n[Code 2]\n\ndef isPowerOfTwo(num: int) -> bool:\n    return num > 0 and (num & (num - 1)) == 0\n\n[/Code 2]\n\n[Asserts 2]\n\nassert isPowerOfTwo(16) == True\nassert isPowerOfTwo(3) == False\nassert isPowerOfTwo(1) == True\nassert isPowerOfTwo(0) == False", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['triplets', 'unique', 'multiple', 'sum', 'modulus', 'iteration', 'range', 'if statement']", "prompt_tokens": 539, "total_tokens": 818, "completion_tokens": 279, "completion": "[Question 2]\n\nWrite a function that takes a range of numbers and returns the count of unique triplets (i, j, k), such that i, j, and k are within the given range and the sum of each pair is a multiple of a given number K.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef countUniqueTripletsInRange(start: int, end: int, K: int) -> int:\n    count = 0\n    for i in range(start, end + 1):\n        for j in range(i + 1, end + 1):\n            for k in range(j + 1, end + 1):\n                if (i + j) % K == 0 and (j + k) % K == 0 and (i + k) % K == 0:\n                    count += 1\n    return count\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countUniqueTripletsInRange(1, 5, 2) == 2\nassert countUniqueTripletsInRange(1, 6, 3) == 4\nassert countUniqueTripletsInRange(1, 4, 2) == 1\nassert countUniqueTripletsInRange(2, 7, 5) == 5\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['integer', 'range', 'XOR', 'calculate', 'function', 'bitwise', 'operation', 'math']", "prompt_tokens": 533, "total_tokens": 824, "completion_tokens": 291, "completion": "[Question 2]\n\nGiven a finite sequence of n integers, we want to calculate the bitwise XOR of each integer with its neighboring integer in the sequence, and return the resulting sequence of XOR values.\n\nWrite a function that takes in a list of integers and returns a new list containing the bitwise XOR of each integer with its neighboring integer.\n\nFor example, for the input sequence [1, 2, 3, 4], the output should be [3, 1, 7] since (1 ^ 2) = 3, (2 ^ 3) = 1, and (3 ^ 4) = 7.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\ndef calculateXorWithNeighbors(nums: List[int]) -> List[int]:\n    result = []\n    for i in range(len(nums) - 1):\n        result.append(nums[i] ^ nums[i+1])\n    return result\n\n[/Code 2]\n\n[Asserts 2]\n\nassert calculateXorWithNeighbors([1, 2, 3, 4])==[3, 1, 7]\nassert calculateXorWithNeighbors([5, 5, 5, 5])==[0, 0, 0]\nassert calculateXorWithNeighbors([10, 20, 30, 40])==[30, 14, 10]\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'elements', 'transformation', 'reachable', 'operations', 'set', 'count', 'non-negative', 'numbers']", "prompt_tokens": 593, "total_tokens": 851, "completion_tokens": 258, "completion": "[Question 2]\n\nGiven an array arr[], and a starting index, you need to perform a transformation operation on the array. The transformation involves converting the array into a gray code sequence. You are required to count the number of elements that are reachable from the array after the transformation.\n\n[/Question 2]\n\n[Code 2]\n\ndef grayCode(arr, n, start):\n    output = set()\n    for i in range(n):\n        output.add(arr[i]^arr[start])\n    return len(output)\n\n[/Code 2]\n\n[Asserts 2]\n\nassert grayCode([1, 2, 3, 4, 5], 5, 0) == 5\nassert grayCode([3, 6, 2, 8, 2, 7, 9, 5], 8, 2) == 4\nassert grayCode([4, 10, 4, 10, 5, 4, 10, 8, 5, 10], 10, 3) == 10\nassert grayCode([4, 4, 4, 4, 4, 4], 6, 2) == 1\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['tree', 'vertices', 'degrees', 'possible', 'sum', 'calculate', 'number']", "prompt_tokens": 429, "total_tokens": 605, "completion_tokens": 176, "completion": "[Question 2]\n\nGiven a chessboard with a specific number of rows and columns, calculate the number of possible trees that can be formed on the intersections of the chessboard, such that each vertex has a degree equal to the given number.\n\n[/Question 2]\n\n[Code 2]\n\ndef countPossibleTrees(rows: int, columns: int, degree: int) -> int:\n    if rows < 1 or columns < 1 or degree < 1:\n        return 0\n    return (rows-1)*(columns-1) * 2**(rows*columns-2)\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countPossibleTrees(3, 3, 2)==144\nassert countPossibleTrees(2, 4, 1)==8\nassert countPossibleTrees(4, 4, 3)==768", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'integers', 'arithmetic progression', 'set', 'sorting', 'difference']", "prompt_tokens": 681, "total_tokens": 996, "completion_tokens": 315, "completion": "[Question 2]\n\nYou are given an array of integers where each element represents the height of a bar. Your task is to find the maximum amount of water that can be trapped in between the bars.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\ndef maxWaterTrapped(height: List[int]) -> int:\n    n = len(height)\n    left, right = 0, n-1\n    left_max, right_max = 0, 0\n    result = 0\n    while left < right:\n        if height[left] < height[right]:\n            if height[left] >= left_max:\n                left_max = height[left]\n            else:\n                result += (left_max - height[left])\n            left += 1\n        else:\n            if height[right] >= right_max:\n                right_max = height[right]\n            else:\n                result += (right_max - height[right])\n            right -= 1\n    return result\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maxWaterTrapped([0,1,0,2,1,0,1,3,2,1,2,1])==6\nassert maxWaterTrapped([4,2,0,3,2,5])==9\nassert maxWaterTrapped([1,1,1,1,1])==0\nassert maxWaterTrapped([3,1,2,4,0,1,3,2,1,2,1])==10\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['math', 'prime number', 'binomial coefficient', 'divisible', 'factorial']", "prompt_tokens": 588, "total_tokens": 1030, "completion_tokens": 442, "completion": "[Question 2]\n\nGiven a list of integers, write a function to calculate the minimum number of transpositions required to sort the list in ascending order. A transposition is the swapping of two adjacent elements in the list. Return the minimum number of transpositions required.\n\n[/Question 2]\n\n[Code 2]\n\ndef minTranspositionsToSort(nums: list) -> int:\n    def mergeSort(arr):\n        if len(arr) > 1:\n            mid = len(arr) // 2\n            left_half = arr[:mid]\n            right_half = arr[mid:]\n\n            inversions = 0\n            inversions += mergeSort(left_half)\n            inversions += mergeSort(right_half)\n\n            i = j = k = 0\n            while i < len(left_half) and j < len(right_half):\n                if left_half[i] <= right_half[j]:\n                    arr[k] = left_half[i]\n                    i += 1\n                else:\n                    arr[k] = right_half[j]\n                    j += 1\n                    inversions += (mid - i)  # Counting inversions\n                k += 1\n\n            while i < len(left_half):\n                arr[k] = left_half[i]\n                i += 1\n                k += 1\n\n            while j < len(right_half):\n                arr[k] = right_half[j]\n                j += 1\n                k += 1\n\n            return inversions\n\n    sorted_nums = nums.copy()\n    mergeSort(sorted_nums)\n    return mergeSort(nums)\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minTranspositionsToSort([3, 1, 2]) == 2\nassert minTranspositionsToSort([1, 7, 3, 4, 5]) == 1\nassert minTranspositionsToSort([5, 4, 3, 2, 1]) == 10\nassert minTranspositionsToSort([1, 2, 3, 4, 5]) == 0\nassert minTranspositionsToSort([2, 1]) == 1\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['decimal', 'base', 'radix', 'even', 'odd', 'boolean', 'conversion', 'modulo', 'number']", "prompt_tokens": 494, "total_tokens": 927, "completion_tokens": 433, "completion": "[Question 2]\n\nGiven a 2D grid representing a map of \"1\" (land) and \"0\" (water), where each cell is a binary digit. A group of connected land cells forms an \"island\". Write a function to return True if the number of cells in each island is odd, else return False. Each island is considered separate if it does not touch another island by sharing a side.\n\n[/Question 2]\n\n[Code 2]\n\ndef isOddIsland(grid: List[List[str]]) -> bool:\n    def dfs(i, j):\n        if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] == '0':\n            return 0\n        grid[i][j] = '0'  # mark as visited\n        count = 1\n        count += dfs(i + 1, j) + dfs(i - 1, j) + dfs(i, j + 1) + dfs(i, j - 1)\n        return count\n    island_counts = [dfs(i, j) for i in range(len(grid)) for j in range(len(grid[0])) if grid[i][j] == '1']\n    return all(count % 2 == 1 for count in island_counts)\n\n[/Code 2]\n\n[Asserts 2]\n\nassert isOddIsland([\n    [\"1\", \"0\", \"1\", \"0\", \"1\"],\n    [\"1\", \"1\", \"0\", \"0\", \"0\"],\n    [\"0\", \"1\", \"0\", \"1\", \"0\"],\n    [\"0\", \"0\", \"1\", \"0\", \"1\"]\n    ]) == True\n\nassert isOddIsland([\n    [\"1\", \"1\", \"0\", \"0\", \"0\"],\n    [\"1\", \"1\", \"0\", \"0\", \"0\"],\n    [\"0\", \"0\", \"1\", \"0\", \"1\"],\n    [\"0\", \"0\", \"0\", \"1\", \"1\"]\n    ]) == False", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['integer', 'quadruplets', 'GCD', 'count', 'divisors', 'math']", "prompt_tokens": 560, "total_tokens": 985, "completion_tokens": 425, "completion": "[Question 2]\n\nYou are given an array of integers. Your task is to write a function to reject all the elements in the array that are not integers and then count the number of quadruplets of the remaining elements whose GCD is a perfect square.\n\n[/Question 2]\n\n[Code 2]\n\ndef rejectNonIntegersAndCountQuadruplets(arr):\n    integers = [x for x in arr if isinstance(x, int)]\n    \n    def countDivisors(K: int) -> int:\n        cnt = 0\n        for i in range(1, int(K**0.5) + 1):\n            if K % i == 0:\n                if K // i == i:\n                    cnt += 1\n                else:\n                    cnt += 2\n        return cnt\n    \n    def isPerfectSquare(n: int) -> bool:\n        return int(n**0.5)**2 == n\n    \n    count = 0\n    for a in range(len(integers)):\n        for b in range(a, len(integers)):\n            for c in range(b, len(integers)):\n                for d in range(c, len(integers)):\n                    if isPerfectSquare(math.gcd(integers[a], math.gcd(integers[b], math.gcd(integers[c], integers[d])))):\n                        count += 1\n    return count\n\n[/Code 2]\n\n[Asserts 2]\n\nassert rejectNonIntegersAndCountQuadruplets([1, 2, 3, 4, 5, 6])==4\nassert rejectNonIntegersAndCountQuadruplets([3, 6, 9, 12, 15, 18, 21, 24])==28\nassert rejectNonIntegersAndCountQuadruplets([2, 4, 6, 8, 10])==10\nassert rejectNonIntegersAndCountQuadruplets([9, 16, 25, 36, 49, 64, 81])==7\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'integers', 'rearrange', 'prefix sum', 'prime numbers', 'sorting', 'math', 'conditional', 'division', 'sorting']", "prompt_tokens": 708, "total_tokens": 998, "completion_tokens": 290, "completion": "[Question 2]\n\nYou are given an array of integers representing the number of candies each kid has. The sun is setting and kids are located from west to east. Rearrange the array such that each kid has a number of candies which is greater than the sum of the candies of all the kids to their west.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\ndef rearrangeCandies(candies: List[int]) -> List[int]:\n    n = len(candies)\n    result = [0] * n\n    prefix_sum = 0\n    for i in range(n):\n        result[i] = max(candies[i], prefix_sum + 1)\n        prefix_sum = max(prefix_sum, result[i])\n    return result\n\n[/Code 2]\n\n[Asserts 2]\n\nassert rearrangeCandies([2, 3, 5, 1, 3])==[2, 3, 5, 6, 7]\nassert rearrangeCandies([4, 2, 5, 1, 3])==[4, 5, 6, 7, 8]\nassert rearrangeCandies([3, 6, 7, 2, 1, 5])==[3, 7, 8, 9, 10, 11]\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['positive integer', 'array', 'subarrays', 'even sum', 'odd sum', 'count']", "prompt_tokens": 561, "total_tokens": 925, "completion_tokens": 364, "completion": "[Question 2]\n\nYou are given an array of positive integers representing the processing time required by each friend to wrap a gift. Your task is to find the longest subarray such that the sum of the processing times of the friends in the subarray is an even number. If multiple such subarrays exist, return the one which is earliest in the array. If no subarray with even sum exists, return an empty array.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\ndef longestEvenSumSubarray(arr: List[int]) -> List[int]:\n    cum_sum = 0\n    arr_indices = {-1: -1}\n    result = []\n    \n    for i, num in enumerate(arr):\n        cum_sum += num\n        arr_indices.setdefault(cum_sum%2, i)\n        result = max(result, i - arr_indices[cum_sum%2], key=lambda x: x%2)\n    \n    return arr[arr_indices[result]+1:arr_indices[result]+result+1]\n\n[/Code 2]\n\n[Asserts 2]\n\nassert longestEvenSumSubarray([1, 2, 3, 4, 5]) == [2, 3, 4, 5]\nassert longestEvenSumSubarray([8, 4, 5, 2, 10, 6, 7]) == [4, 5, 2, 10, 6]\nassert longestEvenSumSubarray([1, 3, 5, 7, 9]) == []\nassert longestEvenSumSubarray([11, 22, 33, 44, 55, 66, 77, 88]) == [22, 33, 44, 55, 66]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'distinct', 'positive integers', 'minimum', 'operations', 'change', 'increasing order']", "prompt_tokens": 541, "total_tokens": 915, "completion_tokens": 374, "completion": "[Question 2]\n\nGiven an array of positive integers representing the heights of mountains, the task is to find the minimum number of jumps needed to reach the next valley. A valley is defined as a sequence of distinct integers in increasing order, followed by a sequence of distinct integers in decreasing order.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\ndef minJumpsToNextValley(arr: List[int]) -> int:\n    jumps = 0\n    i = 0\n    while i < len(arr):\n        while i < len(arr) - 1 and arr[i] == arr[i + 1]:\n            i += 1\n        if i == len(arr) - 1:\n            break\n        isIncreasing = arr[i] < arr[i + 1]\n        while i < len(arr) - 1 and ((isIncreasing and arr[i] < arr[i + 1]) or (not isIncreasing and arr[i] > arr[i + 1])):\n            i += 1\n        jumps += 1\n    return jumps\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minJumpsToNextValley([1, 2, 3, 2, 1, 3, 4, 5, 4, 3])==2\nassert minJumpsToNextValley([5, 4, 3, 2, 1])==0\nassert minJumpsToNextValley([1, 2, 3, 4, 3, 2, 3, 4, 5])==1\nassert minJumpsToNextValley([1, 2, 1, 2, 1, 2, 1, 2])==3\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'integer', 'moves', 'addition', 'count', 'sum']", "prompt_tokens": 500, "total_tokens": 908, "completion_tokens": 408, "completion": "[Question 2]\n\nGiven a Binary Tree and an integer k, the task is to count the number of distinct arrays that can be formed by performing k moves on the Binary Tree. Each move consists of adding the values in the nodes traversed so far and counting the total number of distinct arrays that can be formed.\n\n[/Question 2]\n\n[Code 2]\n\nclass TreeNode:\n    def __init__(self, value=0, left=None, right=None):\n        self.value = value\n        self.left = left\n        self.right = right\n\ndef countArrays(root: TreeNode, k: int) -> int:\n    def dfs(node, pathSum, k, seen):\n        if not node:\n            return 0\n        pathSum += node.value\n        res = 0\n        if pathSum not in seen:\n            seen.add(pathSum)\n            res += 1\n        res += dfs(node.left, pathSum, k, seen) + dfs(node.right, pathSum, k, seen)\n        if k == 0:\n            return res\n        seen.remove(pathSum)\n        return res\n    return dfs(root, 0, k, set())\n\n[/Code 2]\n\n[Asserts 2]\n\n# Creating a sample binary tree\nroot = TreeNode(1, TreeNode(2, TreeNode(3), TreeNode(4)), TreeNode(2, TreeNode(4), TreeNode(3)))\nassert countArrays(root, 2) == 4\n\n# Creating a sample binary tree\nroot2 = TreeNode(1, TreeNode(2, TreeNode(3), TreeNode(4)), TreeNode(2, TreeNode(3), TreeNode(4)))\nassert countArrays(root2, 1) == 3\n\n# Creating a sample binary tree\nroot3 = TreeNode(1, TreeNode(2, TreeNode(3), TreeNode(4)), TreeNode(2, TreeNode(3), TreeNode(4)))\nassert countArrays(root3, 3) == 6\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['boxes', 'balls', 'falling', 'position', 'rotation', 'axis', 'time']", "prompt_tokens": 855, "total_tokens": 1232, "completion_tokens": 377, "completion": "[Question 2]\n\nYou are given a 3D space divided into octants. At time t=0, m balls are released from a given position in the 3D space. Each ball is subject to free fall under the influence of gravity. The position of each ball at time t seconds can be determined based on its initial position and the time t. Considering the influence of gravity, at what position in the octant will each ball be after time t seconds?\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List, Tuple\ndef findBallPositions(initialPositions: List[Tuple[int, int, int]], time: float) -> List[Tuple[float, float, float]]:\n    positions = []\n    for initialPosition in initialPositions:\n        x, y, z = initialPosition\n        finalX = x\n        finalY = y\n        finalZ = z - 0.5 * 9.81 * (time ** 2)  # accounting for gravity\n        positions.append((finalX, finalY, finalZ))\n    return positions\n\n[/Code 2]\n\n[Asserts 2]\n\nassert findBallPositions([(0, 0, 10), (5, 5, 20), (10, 10, 30)], 2.0)==[(0, 0, 0.38), (5, 5, 4.68), (10, 10, 14.58)]\nassert findBallPositions([(0, 0, 15), (3, 3, 25), (8, 8, 35)], 3.0)==[(0, 0, 0.735), (3, 3, 5.925), (8, 8, 20.925)]\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['integer', 'power', 'division', 'factorial', 'program', 'compute', 'highest']", "prompt_tokens": 458, "total_tokens": 723, "completion_tokens": 265, "completion": "[Question 2]\n\nWrite a program to compute the factorial of an integer and then calculate the highest power of an independent integer that can divide the factorial value.\n\n[/Question 2]\n\n[Code 2]\n\ndef factorial(n: int) -> int:\n    if n < 0:\n        return None\n    if n == 0:\n        return 1\n    result = 1\n    for i in range(1, n+1):\n        result *= i\n    return result\n\ndef highestPowerOfIndependentInteger(n: int, k: int) -> int:\n    fact_n = factorial(n)\n    result = 0\n    while (fact_n >= k):\n        fact_n //= k\n        result += 1\n    return result\n\n[/Code 2]\n\n[Asserts 2]\n\nassert factorial(5) == 120\nassert factorial(0) == 1\nassert factorial(10) == 3628800\n\nassert highestPowerOfIndependentInteger(5, 2) == 3\nassert highestPowerOfIndependentInteger(10, 3) == 4\nassert highestPowerOfIndependentInteger(7, 5) == 1\nassert highestPowerOfIndependentInteger(8, 2) == 7\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['math', 'count', 'divisors', 'range', 'list']", "prompt_tokens": 553, "total_tokens": 823, "completion_tokens": 270, "completion": "[Question 2]\n\nGiven an Excel sheet with cells represented by their (row, column) coordinates, write a function to calculate the orthocenter of a given list of triangle vertices, ensuring that the coordinates satisfy the given constraints. Return the coordinates of the orthocenter as a tuple (x, y).\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List, Tuple\ndef calculateOrthocenter(vertices: List[Tuple[int, int]]) -> Tuple[int, int]:\n    if len(vertices) != 3:\n        raise ValueError(\"Exactly 3 vertices are needed to form a triangle\")\n    \n    x_coords = [vertex[0] for vertex in vertices]\n    y_coords = [vertex[1] for vertex in vertices]\n    \n    orthocenter_x = sum(x_coords) // 3\n    orthocenter_y = sum(y_coords) // 3\n    \n    return (orthocenter_x, orthocenter_y)\n\n[/Code 2]\n\n[Asserts 2]\n\nassert calculateOrthocenter([(0, 0), (3, 0), (0, 4)])==(1, 1)\nassert calculateOrthocenter([(1, 1), (1, 4), (4, 1)])==(2, 2)\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'sum', 'optimization', 'game', 'winner', 'selection']", "prompt_tokens": 640, "total_tokens": 852, "completion_tokens": 212, "completion": "[Question 2]\n\nYou are given an array of n boolean values. One by one, players select a number from the array based on a certain selection strategy. The game ends when the array is empty. The player with the most 'True' values wins the game. You need to optimize the selection strategy to determine the winner. \n\nWrite a function to determine the winner of the game based on the selected values.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\ndef determineWinner(arr: List[bool]) -> bool:\n    return sum(arr) % 2 == 1\n\n[/Code 2]\n\n[Asserts 2]\n\nassert determineWinner([True, False, True, False, True]) == True\nassert determineWinner([True, True, False, False, True, False]) == False\nassert determineWinner([False, False, False, False]) == False\nassert determineWinner([True, True, True, True, True, True, True]) == True\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['binary', 'array', 'prefix', 'divisible', 'sum', 'count']", "prompt_tokens": 610, "total_tokens": 943, "completion_tokens": 333, "completion": "[Question 2]\n\nYou are given an array of numbers. Write a function to count the number of elements whose Euler Totient value is divisible by a given number x. The Euler Totient function (phi(n)) counts the positive integers up to n that are relatively prime to n.\n\n[/Question 2]\n\n[Code 2]\n\ndef gcd(a, b):\n    if b == 0:\n        return a\n    else:\n        return gcd(b, a % b)\n\ndef eulerTotient(n):\n    result = 1\n    for i in range(2, n):\n        if gcd(i, n) == 1:\n            result += 1\n    return result\n\ndef countDivisibleEulerTotient(arr, x):\n    count = 0\n    for num in arr:\n        if eulerTotient(num) % x == 0:\n            count += 1\n    return count\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countDivisibleEulerTotient([1, 2, 3, 4, 5], 2) == 3\nassert countDivisibleEulerTotient([5, 6, 7, 8, 9, 10, 11], 3) == 4\nassert countDivisibleEulerTotient([12, 13, 14, 15, 16], 5) == 2\nassert countDivisibleEulerTotient([17, 18, 19, 20, 21, 22], 7) == 5\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['integer', 'divisible', 'smallest number', 'ones', 'form', 'length']", "prompt_tokens": 447, "total_tokens": 687, "completion_tokens": 240, "completion": "[Question 2]\n\nYou are working on a ticket selling system where each ticket ID is an integer. Given a list of ticket IDs, write a function to find the length of the smallest ticket ID that is divisible by all the ticket IDs in the list and is formed by using only 1's.\n\n[/Question 2]\n\n[Code 2]\n\nfrom math import gcd\ndef smallestDivisibleTicketID(ids: list) -> int:\n    lcm = 1\n    for id in ids:\n        lcm = (lcm*id)//gcd(lcm, id)\n        \n    n = 1\n    while n % lcm != 0:\n        n = (n*10 + 1) % lcm\n    return len(str(n))\n\n[/Code 2]\n\n[Asserts 2]\n\nassert smallestDivisibleTicketID([15, 25, 35])==4\nassert smallestDivisibleTicketID([3, 9, 12])==3\nassert smallestDivisibleTicketID([7, 11, 13])==6\nassert smallestDivisibleTicketID([5, 6, 8, 10])==3\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['math', 'integer', 'divisors', 'multiplication', 'triplets', 'positive']", "prompt_tokens": 468, "total_tokens": 715, "completion_tokens": 247, "completion": "[Question 2]\n\nGiven a positive integer N, the task is to find all ordered pairs of positive integers (a, b) such that a*b is equal to N. Additionally, you need to provide a way to toggle between finding all pairs and finding the cycle size of toggling.\n\n[/Question 2]\n\n[Code 2]\n\ndef findOrderedPairs(n: int, toggle: bool = False):\n    pairs = []\n    for i in range(1, n+1):\n        if n % i == 0:\n            pairs.append((i, n//i))\n\n    if toggle:\n        return len(pairs)\n    else:\n        return pairs\n\n[/Code 2]\n\n[Asserts 2]\n\nassert findOrderedPairs(6) == [(1, 6), (2, 3), (3, 2), (6, 1)]\nassert findOrderedPairs(12) == [(1, 12), (2, 6), (3, 4), (4, 3), (6, 2), (12, 1)]\nassert findOrderedPairs(15, True) == 8\nassert findOrderedPairs(20, True) == 6", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['string', 'brackets', 'balanced', 'backtracking', 'recursion', 'combinations']", "prompt_tokens": 513, "total_tokens": 711, "completion_tokens": 198, "completion": "[Question 2]\n\nWrite a function to determine if a given string has valid bracket combinations using a stack and backtracking.\n\n[/Question 2]\n\n[Code 2]\n\ndef isValid(s: str) -> bool:\n    stack = []\n    mapping = {\")\": \"(\", \"}\": \"{\", \"]\": \"[\"}\n    def backtrack(index: int) -> bool:\n        if (index == len(s)):\n            return len(stack) == 0\n        if s[index] in mapping:\n            top_element = stack.pop() if stack else '#'\n            if mapping[s[index]] != top_element:\n                return False\n        else:\n            stack.append(s[index])\n            \n        return backtrack(index + 1)\n    \n    return backtrack(0)\n\n[/Code 2]\n\n[Asserts 2]\n\nassert isValid(\"()\")==True\nassert isValid(\"()[]{}\")==True\nassert isValid(\"(]\")==False\nassert isValid(\"([)]\")==False\nassert isValid(\"{[]}\")==True", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['integer', 'counting', 'binary', 'recursion']", "prompt_tokens": 425, "total_tokens": 549, "completion_tokens": 124, "completion": "[Question 2]\n\nWrite a Python function to count the number of prime factors of an integer using an iterative method.\n\n[/Question 2]\n\n[Code 2]\n\ndef count_prime_factors(n):\n\tcount = 0\n\tfor i in range(2, n+1):\n\t\twhile n % i == 0:\n\t\t\tcount += 1\n\t\t\tn = n / i\n\treturn count\n\n[/Code 2]\n\n[Asserts 2]\n\nassert count_prime_factors(10) == 2\nassert count_prime_factors(12) == 2\nassert count_prime_factors(30) == 3", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['reproduction', 'rates', 'integer', 'tick', 'values', 'count', 'seconds']", "prompt_tokens": 555, "total_tokens": 1108, "completion_tokens": 553, "completion": "[Question 2]\n\nYou are given a maze represented by a 2D grid where 0 represents an empty cell and 1 represents an obstacle. The reproduction rates of values in the maze are based on the following rules: for every tick, if a cell has a value V, it will collect V more values N times from its neighboring cells (up, down, left, and right). The task is to find the count of values at each cell of the maze after N seconds.\n\nUse the Floyd Warshall algorithm for graph traversal to collect values N times from neighboring cells.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\ndef collectValuesUsingFloydWarshall(maze: List[List[int]], N: int) -> List[List[int]]:\n    rows, cols = len(maze), len(maze[0])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    for _ in range(N):\n        for i in range(rows):\n            for j in range(cols):\n                for dx, dy in directions:\n                    x, y = i + dx, j + dy\n                    if 0 <= x < rows and 0 <= y < cols:\n                        maze[i][j] += maze[x][y]\n    return maze\n\n[/Code 2]\n\n[Asserts 2]\n\nassert collectValuesUsingFloydWarshall([[0, 1, 0], [1, 0, 1], [0, 1, 0]], 1) == [[1, 3, 1], [3, 4, 3], [1, 3, 1]]\nassert collectValuesUsingFloydWarshall([[0, 1, 0], [1, 0, 1], [0, 1, 0]], 2) == [[4, 10, 4], [10, 16, 10], [4, 10, 4]]\nassert collectValuesUsingFloydWarshall([[1, 0, 0], [0, 1, 0], [0, 0, 1]], 3) == [[13, 22, 13], [22, 37, 22], [13, 22, 13]]\nassert collectValuesUsingFloydWarshall([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 2) == [[21, 32, 21], [32, 49, 32], [21, 32, 21]]\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'integer', 'factorial', 'GCD', 'math', 'max']", "prompt_tokens": 578, "total_tokens": 1116, "completion_tokens": 538, "completion": "[Question 2]\n\nYou are given an array of n integers. You need to perform updates on the array where each update consists of adding an integer value to a range of the array. After all updates, find the maximum GCD of factorials of subarrays with an odd sum.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\nfrom math import gcd, factorial\n\ndef getFactorialGCDWithOddSum(arr: List[int], updates: List[List[int]]) -> int :\n\tn = len(arr)\n\tprefixSum = [0]*(n+1)\n\tfor update in updates:\n\t\tl, r, val = update\n\t\tprefixSum[l] += val\n\t\tprefixSum[r+1] -= val\n\tfor i in range(1, n+1):\n\t\tprefixSum[i] += prefixSum[i-1]\n\tfactorialGCD = 0\n\tfor i in range(n):\n\t\tfor j in range(i, n):\n\t\t\tif (j-i+1) % 2 == 1:\n\t\t\t\tsubarraySum = prefixSum[j+1] - prefixSum[i]\n\t\t\t\tif subarraySum % 2 == 1:\n\t\t\t\t\tfact = factorial(arr[i])\n\t\t\t\t\tfor k in range(i+1, j+1):\n\t\t\t\t\t\tfact = gcd(fact, factorial(arr[k]))\n\t\t\t\t\tfactorialGCD = max(factorialGCD, fact)\n\treturn factorialGCD\n\n[/Code 2]\n\n[Asserts 2]\n\nassert getFactorialGCDWithOddSum([1, 2, 3, 4, 5], [[0, 2, 1], [1, 3, 2]])==2\nassert getFactorialGCDWithOddSum([4, 5, 6, 7, 8], [[1, 3, 2], [2, 4, 3]])==24\nassert getFactorialGCDWithOddSum([10, 20, 30, 40], [[0, 3, 10], [1, 2, 5], [2, 3, 15]])==3628800\nassert getFactorialGCDWithOddSum([3, 15, 12, 8, 2], [[1, 4, 5], [0, 3, 3]])==2\nassert getFactorialGCDWithOddSum([2, 4, 6, 8, 10], [[2, 4, 5]])==2\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['positive', 'integer', 'sum', 'series', 'recursion', 'power', 'math']", "prompt_tokens": 435, "total_tokens": 668, "completion_tokens": 233, "completion": "[Question 2]\n\nYou are given a list of integer prices representing the prices of a stock on different days. Find the minimum number of steps required to reach the fusion of the rude and positive series of the prices, where the fusion is the sum of the squares of all positive numbers in the series and the sum of the cubes of all rude (non-positive) numbers in the series.\n\n[/Question 2]\n\n[Code 2]\n\ndef minStepsToFusion(prices: List[int]) -> int:\n    positive_sum = sum(x**2 for x in prices if x > 0)\n    rude_sum = sum(x**3 for x in prices if x <= 0)\n    return abs(positive_sum - rude_sum)\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minStepsToFusion([1, 2, 3, -1, -2, -3])==50\nassert minStepsToFusion([1, -1, 2, -2, 3, -3])==28\nassert minStepsToFusion([10, -5, 3, -2, -6, 8])==318", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['integer', 'permutation', 'decreasing', 'increasing', 'dynamic programming']", "prompt_tokens": 507, "total_tokens": 758, "completion_tokens": 251, "completion": "[Question 2]\n\nGiven a list of integers, find the closest pair of integers whose 2's complement representations differ only in one bit position.\n\n[/Question 2]\n\n[Code 2]\n\ndef closestPairWithOneBitDifference(arr):\n    closest = float('inf')\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            complement_i = arr[i] * -1 - 1\n            complement_j = arr[j] * -1 - 1\n            if bin(complement_i ^ arr[i]).count('1') == 1 and bin(complement_j ^ arr[j]).count('1') == 1:\n                closest = min(closest, abs(arr[i]-arr[j]))\n    return closest\n\n[/Code 2]\n\n[Asserts 2]\n\nassert closestPairWithOneBitDifference([2, 5, 8, 10, 15]) == 2\nassert closestPairWithOneBitDifference([3, 7, 10, 15, 20]) == 5\nassert closestPairWithOneBitDifference([-4, -2, 1, 7, 9]) == 3\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['count', 'numbers', 'digits', 'length', 'binary', 'bitwise', 'combinations']", "prompt_tokens": 434, "total_tokens": 678, "completion_tokens": 244, "completion": "[Question 2]\n\nGiven an array of binary numbers represented as strings, the task is to calculate the total weight-to-value ratio considering each number as a 2's complement representation and return the count of numbers having a weight-to-value ratio greater than a given threshold.\n\n[/Question 2]\n\n[Code 2]\n\ndef countWeightValueRatioGreaterThanThreshold(arr: List[str], threshold: int) -> int:\n    count = 0\n    for binary_num in arr:\n        decimal_val = int(binary_num, 2)\n        if decimal_val < 0:\n            weight = -1 * decimal_val.bit_length()\n        else:\n            weight = binary_num.count('1')\n        value = abs(decimal_val)\n        ratio = weight / value\n        if ratio > threshold:\n            count += 1\n    return count\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countWeightValueRatioGreaterThanThreshold(['101', '111', '1101', '100', '1000'], 0.5) == 2\nassert countWeightValueRatioGreaterThanThreshold(['101', '111', '1101', '100', '1000'], 0.8) == 1", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['grid', 'placement', 'combinations', 'permutations', 'counting', 'constraints', 'math']", "prompt_tokens": 520, "total_tokens": 786, "completion_tokens": 266, "completion": "[Question 2]\n\nGiven an iterable of n numbers and an integer k, find the number of combinations of k elements from the iterable where each combination's sum is greater than or equal to a given threshold t.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List, Tuple\nfrom itertools import combinations\n\ndef countCombinationsGreaterThanEqualToThreshold(nums: List[int], k: int, t: int) -> int:\n    count = 0\n    for comb in combinations(nums, k):\n        if sum(comb) >= t:\n            count += 1\n    return count\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countCombinationsGreaterThanEqualToThreshold([1, 2, 3, 4], 2, 5) == 3\nassert countCombinationsGreaterThanEqualToThreshold([2, 8, 6, 1, 7], 3, 15) == 4\nassert countCombinationsGreaterThanEqualToThreshold([5, 6, 7, 8, 9, 10], 4, 30) == 20\nassert countCombinationsGreaterThanEqualToThreshold([3, 5, 7, 9, 11], 2, 10) == 10\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['sequence', 'math', 'pattern', 'formula', 'series', 'nth term', 'calculation']", "prompt_tokens": 428, "total_tokens": 603, "completion_tokens": 175, "completion": "[Question 2]\n\nGiven a sequence of integers, find the most significant digit of the Nth term in the sequence generated based on a given pattern.\n\n[/Question 2]\n\n[Code 2]\n\ndef findMostSignificantDigit(n: int) -> int:\n    sequence = [1, 4, 16, 64, 256]  # Example sequence based on a pattern\n    nth_term = sequence[n-1]\n    while nth_term > 9:\n        nth_term //= 10\n    return nth_term\n\n[/Code 2]\n\n[Asserts 2]\n\nassert findMostSignificantDigit(1)==1\nassert findMostSignificantDigit(2)==4\nassert findMostSignificantDigit(3)==1\nassert findMostSignificantDigit(4)==6\nassert findMostSignificantDigit(5)==2", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['integer', 'sum', 'perfect square', 'odd', 'even', 'print']", "prompt_tokens": 519, "total_tokens": 684, "completion_tokens": 165, "completion": "[Question 2]\n\nWrite a program that takes an integer n and prints the sum of the first n odd perfect square numbers.\n\n[/Question 2]\n\n[Code 2]\n\ndef sumOddPerfectSquares(n: int):\n\tsum = 0\n\tcount = 0\n\tnum = 1\n\t\n\twhile (count < n):\n\t\tif (num % 2 != 0):\n\t\t\tsum += num * num\n\t\t\tcount += 1\n\t\t\n\t\tnum += 1\n\t\n\treturn sum\n\n[/Code 2]\n\n[Asserts 2]\n\nassert sumOddPerfectSquares(3)== 35\nassert sumOddPerfectSquares(5)== 165\nassert sumOddPerfectSquares(2)== 10\nassert sumOddPerfectSquares(4)== 84\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'distinct', 'missing elements', 'XOR operation', 'bit manipulation', 'even', 'odd']", "prompt_tokens": 793, "total_tokens": 986, "completion_tokens": 193, "completion": "[Question 2]\n\nYou are given an array of integers where every number occurs twice except for one. Find the unique number using XOR operation in O(n) time and O(1) space complexity.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef findUniqueNumber(arr: List[int]) -> int:\n    result = 0\n    for num in arr:\n        result ^= num\n    return result\n\n[/Code 2]\n\n[Asserts 2]\n\nassert findUniqueNumber([4, 3, 2, 4, 3]) == 2\nassert findUniqueNumber([10, 7, 3, 7, 10, 8, 8]) == 3\nassert findUniqueNumber([1, 2, 3, 4, 5, 4, 3, 2, 1]) == 5\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['tournament', 'qualify', 'matches', 'win', 'minimum', 'remaining', 'fixed number']", "prompt_tokens": 554, "total_tokens": 815, "completion_tokens": 261, "completion": "[Question 2]\n\nYou are given the number of segments to be joined in a construction project and the minimum number of buildings required to qualify for a tournament. Write a function to determine the minimum number of segments that need to be joined in order to qualify for the tournament. The construction project has a fixed number of segments to be joined, and the team must have a minimum number of buildings to qualify.\n\n[/Question 2]\n\n[Code 2]\n\ndef minSegmentsToQualify(segmentsToJoin: int, buildingsRequired: int) -> int:\n    if segmentsToJoin % 2 == 0:\n        minBuildings = segmentsToJoin // 2\n    else:\n        minBuildings = segmentsToJoin // 2 + 1\n    \n    if minBuildings >= buildingsRequired:\n        return 0\n    else:\n        return buildingsRequired - minBuildings\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minSegmentsToQualify(10, 6) == 1\nassert minSegmentsToQualify(8, 5) == 0\nassert minSegmentsToQualify(15, 8) == 1\nassert minSegmentsToQualify(20, 10) == 0\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['number', 'product', 'digits', 'even', 'odd', 'equality']", "prompt_tokens": 498, "total_tokens": 704, "completion_tokens": 206, "completion": "[Question 2]\n\nWrite a function to determine whether a given number n has an equal product of its odd and even digits. If the product of the odd digits is equal to the product of the even digits, then return True; otherwise, return False.\n\n[/Question 2]\n\n[Code 2]\n\ndef checkEqualProduct(n: int) -> bool:\n    n_str = str(n)\n    even_product = 1\n    odd_product = 1\n\n    for digit in n_str:\n        if int(digit) % 2 == 0:\n            even_product *= int(digit)\n        else:\n            odd_product *= int(digit)\n\n    return even_product == odd_product\n\n[/Code 2]\n\n[Asserts 2]\n\nassert checkEqualProduct(1234) == True\nassert checkEqualProduct(2345) == False\nassert checkEqualProduct(1111) == True\nassert checkEqualProduct(13579) == False\nassert checkEqualProduct(246810) == True", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['integer', 'range', 'even', 'sum', 'divisible', 'digits']", "prompt_tokens": 483, "total_tokens": 727, "completion_tokens": 244, "completion": "[Question 2]\n\nGiven a list of integers, write a function to determine the count of integers whose sum of digits is even and index in the list is divisible by 5.\n\n[/Question 2]\n\n[Code 2]\n\ndef countEvenSumAtDivisibleIndexes(numbers: list) -> int:\n    count = 0\n    for index, num in enumerate(numbers):\n        if index % 5 == 0:\n            sum_of_digits = sum(int(digit) for digit in str(num))\n            if sum_of_digits % 2 == 0:\n                count += 1\n    return count\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countEvenSumAtDivisibleIndexes([123, 456, 789, 246, 135]) == 2\nassert countEvenSumAtDivisibleIndexes([111, 222, 333, 444, 555, 666, 777]) == 3\nassert countEvenSumAtDivisibleIndexes([12, 34, 56, 78, 90, 21, 43, 65, 87, 9]) == 2\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'integers', 'subarray', 'sum', 'minimum', 'sorted', 'non-decreasing']", "prompt_tokens": 545, "total_tokens": 871, "completion_tokens": 326, "completion": "[Question 2]\n\nYou are given a 2D list of integers representing a grid. Each cell in the grid contains an integer. Your task is to find the minimum sum of visitation of the subarrays of the grid that are non-decreasing. The visitation of a subarray is the sum of all elements in the subarray. Since the grid is sorted in non-decreasing order, you will need to find the minimum sum of visitation for all non-decreasing subarrays in the given grid.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef minSumVisitation(grid: List[List[int]]) -> int:\n    m, n = len(grid), len(grid[0])\n    ans = 0\n    for i in range(m):\n        for j in range(n):\n            ans += grid[i][j]\n    return ans\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minSumVisitation([[1, 2, 3], [4, 5, 6], [7, 8, 9]])==45\nassert minSumVisitation([[5, 4, 3], [2, 1, 0]])==15\nassert minSumVisitation([[3, 1, 4], [1, 5, 9], [2, 6, 5]])==36\nassert minSumVisitation([[2, 2, 2], [2, 2, 2], [2, 2, 2]])==18\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'integers', 'sum', 'operation', 'divisible', 'sort']", "prompt_tokens": 575, "total_tokens": 855, "completion_tokens": 280, "completion": "[Question 2]\n\nYou are given an array A[] of N integers representing nodes of a binary tree. Each node contains an integer value. Write a function to find the sum of all integer values in the array A[] in linear time. \n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef sumOfIntegersInArray(arr: List[int]) -> int:\n    # Sort the array\n    arr.sort()\n\n    # Initialize sum\n    total_sum = 0\n    \n    # Linear time sum calculation\n    for num in arr:\n        total_sum += num\n\n    return total_sum\n\n[/Code 2]\n\n[Asserts 2]\n\nassert sumOfIntegersInArray([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]) == 44\nassert sumOfIntegersInArray([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == 55\nassert sumOfIntegersInArray([10, 20, 30, 40, 50]) == 150\nassert sumOfIntegersInArray([5, 15, 10, 25, 20]) == 75\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['bitwise', 'AND', 'range', 'integers', 'pair', 'maximized']", "prompt_tokens": 502, "total_tokens": 894, "completion_tokens": 392, "completion": "[Question 2]\n\nYou are given a parallelogram with integer coordinates on a coordinate plane. Each turn consists of picking two distinct vertices of the parallelogram and donating some of the integer coordinates of one vertex to the other vertex. After each donation, the rank of the parallelogram (computed as the bitwise AND of the absolute differences of x-coordinates and y-coordinates) must be maximized. Write a function to determine the maximum rank achievable after a certain number of turns.\n\n[/Question 2]\n\n[Code 2]\n\nfrom itertools import combinations\n\ndef maxRankParallelogram(coordinates: list, numTurns: int) -> int:\n    max_rank = 0\n    for _ in range(numTurns):\n        for pair in combinations(coordinates, 2):\n            x1, y1 = pair[0]\n            x2, y2 = pair[1]\n            new_x1 = min(x1, x2)\n            new_x2 = max(x1, x2)\n            new_y1 = min(y1, y2)\n            new_y2 = max(y1, y2)\n            rank = (abs(new_x2 - new_x1) & abs(new_y2 - new_y1))\n            max_rank = max(max_rank, rank)\n    return max_rank\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maxRankParallelogram([[0, 0], [3, 4], [5, 7], [8, 11]], 1) == 7\nassert maxRankParallelogram([[1, 2], [3, 4], [5, 6], [7, 8]], 2) == 6\nassert maxRankParallelogram([[0, 0], [4, 4], [8, 8], [12, 12]], 3) == 8", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['integer', 'prime number', 'special prime', 'digits', 'sum', 'function', 'calculation']", "prompt_tokens": 562, "total_tokens": 888, "completion_tokens": 326, "completion": "[Question 2]\n\nGiven a positive integer n, write a function to find the cycle size of the special prime number that is obtained by calculating the sum of the digits of n, then taking the sum as the new n and repeating this process until a prime number is reached. The cycle size is the number of iterations it takes for the calculation to reach a prime number.\n\nWrite a function to calculate the cycle size of the special prime number for the given input.\n\n[/Question 2]\n\n[Code 2]\n\ndef isPrimeNumber(n: int) -> bool:\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef sumOfDigits(n: int) -> int:\n    return sum([int(i) for i in str(n)])\n\ndef cycleSizeOfSpecialPrime(n: int) -> int:\n    cycle_set = set()\n    while True:\n        if n in cycle_set:\n            return len(cycle_set)\n        cycle_set.add(n)\n        n = sumOfDigits(n)\n        if isPrimeNumber(n):\n            return len(cycle_set) + 1\n\n[/Code 2]\n\n[Asserts 2]\n\nassert cycleSizeOfSpecialPrime(13)==1\nassert cycleSizeOfSpecialPrime(31)==15\nassert cycleSizeOfSpecialPrime(7)==1\nassert cycleSizeOfSpecialPrime(113)==2\nassert cycleSizeOfSpecialPrime(29)==9\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['division', 'math', 'greedy', 'minimum', 'iteration']", "prompt_tokens": 444, "total_tokens": 646, "completion_tokens": 202, "completion": "[Question 2]\n\nWrite a function to find the minimum number of iterations required to approximate the square root of a given number within a certain threshold using the Babylonian method. The Babylonian method is an iterative algorithm to compute the square root of a number.\n\n[/Question 2]\n\n[Code 2]\n\ndef minIterationsToApproximateSquareRoot(num: float, threshold: float) -> int:\n    \n    guess = num / 2\n    iterations = 0\n    \n    while abs(guess * guess - num) > threshold:\n        guess = (guess + num / guess) / 2\n        iterations += 1\n        \n    return iterations\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minIterationsToApproximateSquareRoot(25, 0.01) == 2\nassert minIterationsToApproximateSquareRoot(81, 0.01) == 3\nassert minIterationsToApproximateSquareRoot(2, 0.01) == 4", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['integer', 'divisible', 'range', 'maximum', 'positive', 'function', 'input']", "prompt_tokens": 615, "total_tokens": 959, "completion_tokens": 344, "completion": "[Question 2]\n\nWrite a function to calculate the earliest positive integer greater than 0 in the range [A, B] which is divisible by the maximum number of integers within the range. Implement the function using the Euler Totient function to efficiently calculate the number of positive integers less than or equal to a given integer that are coprime to it.\n\n[/Question 2]\n\n[Code 2]\n\ndef earliestMaxDivisibleInRange(A: int, B: int) -> int:\n    def eulerTotient(n):\n        result = n\n        p = 2\n        while p*p <= n:\n            if n % p == 0:\n                while n % p == 0:\n                    n //= p\n                result -= result // p\n            p += 1\n        if n > 1:\n            result -= result // n\n        return result\n    \n    max_divisible_count = 0\n    result = -1\n    for i in range(A, B+1):\n        count = eulerTotient(i)\n        if count > max_divisible_count:\n            max_divisible_count = count\n            result = i\n    return result\n\n[/Code 2]\n\n[Asserts 2]\n\nassert earliestMaxDivisibleInRange(1, 10) == 6\nassert earliestMaxDivisibleInRange(10, 20) == 12\nassert earliestMaxDivisibleInRange(50, 100) == 60\nassert earliestMaxDivisibleInRange(100, 200) == 120\nassert earliestMaxDivisibleInRange(500, 600) == 504\nassert earliestMaxDivisibleInRange(700, 800) == 720", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'integer', 'sorting', 'pair', 'count', 'comparison']", "prompt_tokens": 521, "total_tokens": 860, "completion_tokens": 339, "completion": "[Question 2]\n\nGiven an array of transactions representing the amount of each transaction, write a function to find the ratio of the sum of positive transactions to the sum of negative transactions, skipping the first `k` transactions.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef calculateTransactionRatio(transactions: List[int], k: int) -> float:\n    positive_sum = 0\n    negative_sum = 0\n    for i in range(k, len(transactions)):\n        if transactions[i] > 0:\n            positive_sum += transactions[i]\n        elif transactions[i] < 0:\n            negative_sum += abs(transactions[i])\n    \n    return positive_sum / negative_sum if negative_sum != 0 else float('inf')\n\n[/Code 2]\n\n[Asserts 2]\n\nassert math.isclose(calculateTransactionRatio([10, -5, 8, -3, 12, -8], 2), 1.6, rel_tol=1e-9)\nassert math.isclose(calculateTransactionRatio([20, -10, 5, -15, 25, -20], 1), 1.25, rel_tol=1e-9)\nassert math.isclose(calculateTransactionRatio([-5, -2, -10, -8, -7, -3], 3), 0.4, rel_tol=1e-9)\nassert math.isclose(calculateTransactionRatio([10, 5, 8, 3, 12, 8], 0), float('inf'), rel_tol=1e-9)\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['grid', 'size', 'bishop', 'moves', 'count', 'visit', 'chess']", "prompt_tokens": 483, "total_tokens": 693, "completion_tokens": 210, "completion": "[Question 2]\n\nGiven a chess grid of size N x N, write a function to count the total number of squares that can be visited by a Bishop in one move along the major axis.\n\n[/Question 2]\n\n[Code 2]\n\ndef countBishopMovesMajorAxis(N: int, x: int, y: int) -> int:\n    return min(x-1, y-1) + min(N-x, N-y) + min(x-1, N-y) + min(N-x, y-1) - 1\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countBishopMovesMajorAxis(5, 3, 3) == 11\nassert countBishopMovesMajorAxis(8, 4, 5) == 14\nassert countBishopMovesMajorAxis(4, 2, 2) == 5\nassert countBishopMovesMajorAxis(6, 4, 2) == 10\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['chess', 'bishop', 'pawn', 'capture', 'diagonal', 'coordinates', 'boolean']", "prompt_tokens": 594, "total_tokens": 814, "completion_tokens": 220, "completion": "[Question 2]\n\nIn a chess game, given the coordinates of a Pawn and a Bishop, determine whether the Bishop can capture the Pawn by moving diagonally, considering the rules of movement for both the Pawn and the Bishop.\n\nWrite a function that uses Newton's divided difference interpolation formula to determine whether the Bishop can capture the Pawn given their coordinates. Return True if the Bishop can capture the Pawn, else return False.\n\n[/Question 2]\n\n[Code 2]\n\ndef canCapture(pawn: str, bishop: str) -> bool:\n    # Write code using Newton's divided difference interpolation formula\n    return False\n\n[/Code 2]\n\n[Asserts 2]\n\nassert canCapture(\"c2\", \"f5\")==True\nassert canCapture(\"a7\", \"c5\")==True\nassert canCapture(\"b2\", \"g7\")==False\nassert canCapture(\"h4\", \"e7\")==True\nassert canCapture(\"g2\", \"h1\")==True\nassert canCapture(\"a7\", \"h1\")==False\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['integer', 'sum of digits', 'multiple', 'smallest', 'positive']", "prompt_tokens": 635, "total_tokens": 852, "completion_tokens": 217, "completion": "[Question 2]\n\nGiven a positive integer n, the task is to find the smallest positive integer y such that the sum of the digits of y * n is equal to the sum of the digits of y.\n\n[/Question 2]\n\n[Code 2]\n\ndef findSmallestY(n: int) -> int:\n    if (n < 0):\n        return -1\n\n    if (n == 0):\n        return 0\n\n    for y in range(1, 10000):\n        if sum(int(digit) for digit in str(y)) == sum(int(digit) for digit in str(y * n)):\n            return y\n\n    return -1\n\n[/Code 2]\n\n[Asserts 2]\n\nassert findSmallestY(1)==1\nassert findSmallestY(9)==1\nassert findSmallestY(25)==4\nassert findSmallestY(11)==2\nassert findSmallestY(0)==0\nassert findSmallestY(1234)==32\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['number', 'divisor', 'maximum', 'division', 'sum']", "prompt_tokens": 475, "total_tokens": 746, "completion_tokens": 271, "completion": "[Question 2]\n\nGiven a list of phone numbers, find the maximum sum of once-reachable numbers. A number is once-reachable if the sum of its digits is a divisor of the number.\n\n[/Question 2]\n\n[Code 2]\n\ndef sumOfDigits(num: int)->int:\n    return sum(int(digit) for digit in str(num))\n\ndef maxSumOfOnceReachable(numbers: List[int])->int:\n    max_sum = 0\n    for number in numbers:\n        digit_sum = sumOfDigits(number)\n        if number % digit_sum == 0:\n            max_sum = max(max_sum, number)\n    return max_sum\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maxSumOfOnceReachable([123, 456, 789]) == 789\nassert maxSumOfOnceReachable([111, 222, 333, 444]) == 444\nassert maxSumOfOnceReachable([12, 34, 56, 78, 90]) == 90\nassert maxSumOfOnceReachable([135, 246, 579, 891]) == 579\nassert maxSumOfOnceReachable([11111, 22222, 33333, 44444]) == 0\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'elements', 'operations', 'sum', 'average', 'count', 'equality', 'minimum', 'replace']", "prompt_tokens": 569, "total_tokens": 868, "completion_tokens": 299, "completion": "[Question 2]\n\nYou are given a 2D array representing a tree. Each row represents a node and its child nodes. Write a program to find the average sum of each level in the tree.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef averageSumOfLevels(tree: List[List[int]]) -> List[float]:\n    result = []\n    queue = [(0, 0)]  # (node, level)\n    level_sum = 0\n    level_count = 0\n    current_level = 0\n\n    for node, level in queue:\n        if level > current_level:\n            result.append(level_sum / level_count)\n            current_level = level\n            level_sum = 0\n            level_count = 0\n        level_sum += node\n        level_count += 1\n        for child in tree[node]:\n            queue.append((child, level + 1))\n\n    result.append(level_sum / level_count) # Last level\n\n    return result\n\n[/Code 2]\n\n[Asserts 2]\n\nassert averageSumOfLevels([[3], [9, 20], [15, 7]]) == [3.0, 14.5, 11.0]\nassert averageSumOfLevels([[1], [2, 3], [4, 5, 6, 7]]) == [1.0, 2.5, 5.5, 6.5]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['integers', 'maximize', 'equation', 'non-negative', 'value']", "prompt_tokens": 549, "total_tokens": 771, "completion_tokens": 222, "completion": "[Question 2]\n\nGiven a positive integer n, the task is to find the largest value of k such that the sum of the first k odd divisors of n is a perfect cube.\n\n[/Question 2]\n\n[Code 2]\n\ndef maxOddDivisorsSum(n: int) -> int:\n    odd_divisors_sum = 0\n    count = 0\n    for i in range(1, n+1, 2):\n        if n % i == 0:\n            count += 1\n            odd_divisors_sum += i\n            if odd_divisors_sum > 0 and (odd_divisors_sum ** (1/3)).is_integer():\n                max_val = count\n    return max_val\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maxOddDivisorsSum(27)==3\nassert maxOddDivisorsSum(100)==5\nassert maxOddDivisorsSum(30)==2\nassert maxOddDivisorsSum(15)==2\nassert maxOddDivisorsSum(16)==2\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['positive', 'number', 'GCD', 'product', 'maximize', 'sum', 'factor', 'divisor']", "prompt_tokens": 504, "total_tokens": 731, "completion_tokens": 227, "completion": "[Question 2]\n\nGiven an array of positive numbers, your task is to find the maximum product of two numbers in the array such that their GCD is greater than 1. If no such pair exists, return -1.\n\n[/Question 2]\n\n[Code 2]\n\nfrom math import gcd\n\ndef maxGCDProduct(arr):\n    max_product = -1\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            if gcd(arr[i], arr[j]) > 1:\n                max_product = max(max_product, arr[i]*arr[j])\n    return max_product\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maxGCDProduct([2, 3, 5, 7, 11])==-1\nassert maxGCDProduct([2, 4, 6, 8, 10])==80\nassert maxGCDProduct([3, 7, 12, 15, 21])==63\nassert maxGCDProduct([10, 15, 25, 35, 55])==825", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['divisible', 'range', 'integer', 'positive', 'inclusive', 'algorithm', 'iteration']", "prompt_tokens": 523, "total_tokens": 737, "completion_tokens": 214, "completion": "[Question 2]\n\nYou are given a list of positive integers. Write a Python function to find the first positive integer that is divisible by all the integers in the list.\n\n[/Question 2]\n\n[Code 2]\n\ndef find_divisible_integer(arr):\n    start = max(arr)\n    while True:\n        divisible = True\n        for num in arr:\n            if start % num != 0:\n                divisible = False\n                break\n        if divisible:\n            return start\n        start += 1\n\n[/Code 2]\n\n[Asserts 2]\n\nassert find_divisible_integer([3, 5, 7])==105\nassert find_divisible_integer([2, 4, 6, 8])==24\nassert find_divisible_integer([5, 7, 11, 13])==5005\nassert find_divisible_integer([2, 3, 5, 7, 11, 13])==30030\nassert find_divisible_integer([3, 9, 15, 21])==945", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['math', 'integer', 'count', 'pairs', 'modulus']", "prompt_tokens": 508, "total_tokens": 738, "completion_tokens": 230, "completion": "[Question 2]\n\nGiven an array of RGB values represented as integers, implement a function to count the number of pairs of RGB values that satisfy a specific condition.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\ndef countPairsWithCondition(arr: List[int]) -> int:\n    n = len(arr)\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] % 2 == 0 and arr[j] % 2 != 0:\n                count += 1\n    return count\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countPairsWithCondition([2, 3, 5, 6, 8]) == 5\nassert countPairsWithCondition([1, 1, 3, 5, 7]) == 0\nassert countPairsWithCondition([2, 4, 6, 8, 10]) == 10\nassert countPairsWithCondition([1, 2, 3, 4, 5]) == 4", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['numeric', 'string', 'divisible', 'smallest', 'multiple', 'character', 'iteration', 'condition']", "prompt_tokens": 724, "total_tokens": 1084, "completion_tokens": 360, "completion": "[Question 2]\n\nGiven an array of numeric strings, find the smallest common prefix string that is divisible by a given numeric string. If there are multiple common prefix strings that satisfy the condition, return the one with the smallest lexicographical order.\n\n[/Question 2]\n\n[Code 2]\n\ndef smallestDivisibleCommonPrefix(arr: List[str], numericString: str) -> str:\n    def GCD(x, y):\n        while y != 0:\n            x, y = y, x % y\n        return x\n    \n    def isDivisibleByNumericString(s: str, numericString: str) -> bool:\n        numS = int(numericString)\n        return int(s) % numS == 0\n    \n    prefix = arr[0]\n    for s in arr[1:]:\n        while s.find(prefix) != 0:\n            prefix = prefix[:-1]\n    gcd = GCD(int(prefix), int(numericString))\n    if gcd != 1:\n        prefix = str(gcd)\n    if isDivisibleByNumericString(prefix, numericString):\n        return prefix\n    return \"-1\"\n\n[/Code 2]\n\n[Asserts 2]\n\nassert smallestDivisibleCommonPrefix(['123', '124', '125', '126', '127'], '3') == '12'\nassert smallestDivisibleCommonPrefix(['123', '124', '125', '126', '127'], '7') == '-1'\nassert smallestDivisibleCommonPrefix(['123', '124', '125', '126', '127'], '2') == '12'\nassert smallestDivisibleCommonPrefix(['123', '124', '125', '126', '127'], '10') == '-1'\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['integer', 'division', 'divisibility', 'digits', 'modulo', 'set']", "prompt_tokens": 520, "total_tokens": 889, "completion_tokens": 369, "completion": "[Question 2]\n\nYou are given an integer N. You have to repeatedly divide N by its digits and check if the result of each division is divisible by the digit used. You are allowed to perform this task a certain number of times. Return True if all the divided results are divisible by the digit used, else return False.\n\nFor example, if N is 128 and you are allowed a maximum of 2 moves, you can perform the following operations:\n1. 128 / 1 = 128 (divisible by 1)\n2. 128 / 2 = 64 (divisible by 2)\nSince all the divided results are divisible by the digits used, the output will be True.\n\n[/Question 2]\n\n[Code 2]\n\ndef isDivisibilityPatternPossible(N: int, max_moves: int) -> bool:\n    digits = [int(x) for x in str(N) if x != '0']\n    for digit in digits:\n        for _ in range(max_moves):\n            if digit != 0 and N % digit == 0:\n                N = N // digit\n            else:\n                break\n        else:\n            continue\n        break\n    else:\n        return True\n    return False\n\n[/Code 2]\n\n[Asserts 2]\n\nassert isDivisibilityPatternPossible(128, 2)==True\nassert isDivisibilityPatternPossible(30, 2)==False\nassert isDivisibilityPatternPossible(75, 1)==True\nassert isDivisibilityPatternPossible(101, 2)==False\nassert isDivisibilityPatternPossible(235, 2)==False\nassert isDivisibilityPatternPossible(777, 3)==True\nassert isDivisibilityPatternPossible(90, 2)==True", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['arithmetic progression', 'sum', 'terms', 'sequence', 'math', 'formula', 'series', 'iteration']", "prompt_tokens": 539, "total_tokens": 938, "completion_tokens": 399, "completion": "[Question 2]\n\nYou are given the starting point (x1, y1) and the ending point (x2, y2) of a sequence of points. Each point is separated by a distance of N units along the x-axis and the y-axis. Your task is to calculate the sum of the Euclidean distances between consecutive points in the sequence.\n\n[/Question 2]\n\n[Code 2]\n\nimport math\n\ndef euclidean_distance(x1, y1, x2, y2):\n    return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)\n\ndef sum_euclidean_distances(x1, y1, x2, y2, n, terms):\n    total_distance = 0\n    current_x = x1\n    current_y = y1\n    for _ in range(terms):\n        next_x = current_x + n\n        next_y = current_y + n\n        total_distance += euclidean_distance(current_x, current_y, next_x, next_y)\n        current_x = next_x\n        current_y = next_y\n    return total_distance\n\n[/Code 2]\n\n[Asserts 2]\n\nassert sum_euclidean_distances(0, 0, 3, 4, 5, 4) == 20.0\nassert sum_euclidean_distances(1, 1, 4, 5, 3, 4) == 15.0\nassert sum_euclidean_distances(2, 3, 6, 9, 5, 3) == 18.0\nassert sum_euclidean_distances(5, 7, 8, 11, 2, 6) == 24.0\nassert sum_euclidean_distances(3, 2, 8, 4, 4, 6) == 23.769728648009426", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['positive integers', 'powers', 'ascending order', 'set', 'sorted', 'while loop']", "prompt_tokens": 690, "total_tokens": 997, "completion_tokens": 307, "completion": "[Question 2]\n\nYou are given a set of positive integers. Write a program to sort the set in ascending order by considering the decrements of powers of each positive integer.\n\n[/Question 2]\n\n[Code 2]\n\ndef sortSetByDecrementPowers(input_set: set) -> list:\n    result = []\n    \n    for num in input_set:\n        power = 0\n        current_power = 1\n        \n        while current_power <= num:\n            power += 1\n            current_power *= 2\n        \n        result.append((num - power, num))\n    \n    result.sort()\n    return [x[1] for x in result]\n\n[/Code 2]\n\n[Asserts 2]\n\nassert sortSetByDecrementPowers({5, 8, 3, 12, 7}) == [3, 5, 7, 8, 12]\nassert sortSetByDecrementPowers({15, 30, 10, 20, 25}) == [10, 15, 20, 25, 30]\nassert sortSetByDecrementPowers({1, 3, 5, 7, 9}) == [1, 3, 5, 7, 9]\nassert sortSetByDecrementPowers({17, 33, 18, 25, 31}) == [17, 18, 25, 31, 33]\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['integer', 'concatenation', 'order', 'division', 'condition', 'sorting', 'looping', 'manipulation']", "prompt_tokens": 773, "total_tokens": 997, "completion_tokens": 224, "completion": "[Question 2]\n\nYou are given a list of integers. Write a function `transformerSort` to sort the integers based on the following condition:\nFor a positive integer N, let the sum of its digits be S(N). Given two integers A and B, if S(A) > S(B), then A should appear before B in the sorted list. If S(A) = S(B), then the integer that comes first in the original list should appear first in the sorted list.\n\n[/Question 2]\n\n[Code 2]\n\ndef transformerSort(nums):\n    return sorted(nums, key=lambda x: (sum(int(digit) for digit in str(x)), nums.index(x)))\n\n[/Code 2]\n\n[Asserts 2]\n\nassert transformerSort([12, 21, 31, 45, 102, 111]) == [21, 12, 31, 45, 102, 111]\nassert transformerSort([332, 102, 45, 21, 11]) == [21, 11, 332, 102, 45]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['matrix', 'increment', 'operation', 'tuple', 'coordinate']", "prompt_tokens": 760, "total_tokens": 1080, "completion_tokens": 320, "completion": "[Question 2]\n\nYou are given a matrix of size N x N where each cell represents a distance between two points in a directed graph. Design a function to check whether the given matrix is a Pythagorean matrix or not. A Pythagorean matrix is a square matrix in which the sum of the squares of elements in each row and each column is equal.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef isPythagoreanMatrix(matrix: List[List[int]]) -> bool:\n    size = len(matrix)\n    row_sums = [sum(x ** 2 for x in row) for row in matrix]\n    col_sums = [sum(matrix[i][j] ** 2 for i in range(size)) for j in range(size)]\n    return all(row_sums[i] == col_sums[i] for i in range(size))\n\n[/Code 2]\n\n[Asserts 2]\n\nmatrix1 = [\n    [3, 4, 5],\n    [4, 5, 3],\n    [5, 3, 4]\n]\nassert isPythagoreanMatrix(matrix1) == True\n\nmatrix2 = [\n    [6, 8, 10],\n    [8, 10, 6],\n    [10, 6, 8]\n]\nassert isPythagoreanMatrix(matrix2) == False\n\nmatrix3 = [\n    [1, 2],\n    [2, 1]\n]\nassert isPythagoreanMatrix(matrix3) == False\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'maximum', 'replace', 'coefficient', 'update']", "prompt_tokens": 479, "total_tokens": 844, "completion_tokens": 365, "completion": "[Question 2]\n\nGiven an array of integers and a sliding window size, write a function to update the array such that every element is replaced by the maximum element within its sliding window.\n\nFor example, if the array is [1, 3, -1, -3, 5, 3, 6, 7] and the sliding window size is 3, then the updated array will be [3, 3, 5, 5, 5, 6, 7, 7].\n\nWrite a function to accept the array and the sliding window size and return the updated array.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\nfrom collections import deque\n\ndef maxSlidingWindow(nums: List[int], k: int) -> List[int]:\n    result = []\n    window = deque()\n    \n    for i, num in enumerate(nums):\n        while window and nums[window[-1]] < num:\n            window.pop()\n        window.append(i)\n        \n        if window[0] == i - k:\n            window.popleft()\n        \n        if i >= k - 1:\n            result.append(nums[window[0]])\n            \n    return result\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maxSlidingWindow([1, 3, -1, -3, 5, 3, 6, 7], 3) == [3, 3, 5, 5, 5, 6, 7, 7]\nassert maxSlidingWindow([8, 5, 10, 7, 9, 4, 15, 12], 4) == [10, 10, 10, 10, 15, 15]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['common', 'divisor', 'division', 'positive', 'integers', 'return', 'original', 'values', 'numbers']", "prompt_tokens": 607, "total_tokens": 886, "completion_tokens": 279, "completion": "[Question 2]\n\nWrite a function to calculate the difference between the manhattan distance of consecutive terms in a sorted list of positive integers. Return the maximum difference between consecutive manhattan distances.\n\n[/Question 2]\n\n[Code 2]\n\ndef max_manhattan_distance_difference(numbers: List[int]) -> int:\n    numbers.sort()\n    max_diff = 0\n    for i in range(len(numbers)-1):\n        manhattan_dist1 = abs(numbers[i] - numbers[i+1])\n        manhattan_dist2 = abs(numbers[i] + 1 - numbers[i+1])\n        diff = abs(manhattan_dist1 - manhattan_dist2)\n        max_diff = max(max_diff, diff)\n    return max_diff\n\n[/Code 2]\n\n[Asserts 2]\n\nassert max_manhattan_distance_difference([1, 3, 6, 10, 15])==3\nassert max_manhattan_distance_difference([5, 8, 12, 16, 21])==4\nassert max_manhattan_distance_difference([10, 15, 28, 39, 45])==16\nassert max_manhattan_distance_difference([3, 7, 11, 17, 23])==6\nassert max_manhattan_distance_difference([2, 5, 8, 13, 21])==3\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['power of 2', 'absolute difference', 'minimize', 'iteration', 'math']", "prompt_tokens": 459, "total_tokens": 803, "completion_tokens": 344, "completion": "[Question 2]\n\nYou have a list of positive integers representing prices of items for sale. You want to find the minimum absolute difference between the price of an item and any power of 2. Can you write a function to compute this minimum absolute difference for each price in the list?\n\n[/Question 2]\n\n[Code 2]\n\ndef minAbsDiffPowerOf2(prices: List[int]) -> List[int]:\n    min_diffs = []\n    for price in prices:\n        power = 0\n        while (1 << power) <= price:\n            power += 1\n        min_diff = float('inf')\n        for i in range(power+1):\n            diff = abs(price - (1 << i))\n            min_diff = min(min_diff, diff)\n        min_diffs.append(min_diff)\n    return min_diffs\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minAbsDiffPowerOf2([5, 16, 127, 1024, 20])==[1, 0, 1, 0, 4]\nassert minAbsDiffPowerOf2([10, 25, 30])==[2, 7, 2]\nassert minAbsDiffPowerOf2([3, 4, 8, 10])==[1, 0, 0, 2]\nassert minAbsDiffPowerOf2([15, 18, 21])==[1, 2, 3]\nassert minAbsDiffPowerOf2([1, 2, 4, 8, 16])==[0, 0, 0, 0, 0]\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['probability', 'player', 'win', 'target', 'attempts', 'probability calculation']", "prompt_tokens": 529, "total_tokens": 740, "completion_tokens": 211, "completion": "[Question 2]\n\nYou have an arcade game where the player has to hit a target zero at a starting position. The player has 3 attempts to hit the target, and the game is considered won if the player hits the target at least once. Calculate the probability of the player winning the game.\n\n[/Question 2]\n\n[Code 2]\n\ndef probabilityOfWinningGame(attempts: int, probability: float) -> float:\n    probability_of_losing = (1 - probability) ** attempts\n    return 1 - probability_of_losing\n\n[/Code 2]\n\n[Asserts 2]\n\nassert probabilityOfWinningGame(3, 0.2) == 0.488\nassert probabilityOfWinningGame(2, 0.5) == 0.75\nassert probabilityOfWinningGame(4, 0.3) == 0.973\nassert probabilityOfWinningGame(5, 0.1) == 0.9999\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['integer', 'sum', 'powers of two', 'list', 'binary', 'bit manipulation']", "prompt_tokens": 533, "total_tokens": 754, "completion_tokens": 221, "completion": "[Question 2]\n\nYou are given a list of integers representing the side lengths of triangles. Your task is to return the count of equilateral triangles that can be formed using the side lengths in the list.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef countEquilateralTriangles(side_lengths: List[int]) -> int:\n\tcount = 0\n\tfor side in side_lengths:\n\t\tif side % 3 == 0:\n\t\t\tcount += 1\n\treturn count // 3\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countEquilateralTriangles([3, 3, 3, 3, 3, 3, 3])==2\nassert countEquilateralTriangles([4, 4, 4, 4, 4, 4])==0\nassert countEquilateralTriangles([6, 6, 6, 6, 6, 6])==2\nassert countEquilateralTriangles([3, 6, 9, 12, 15])==0\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['non-negative', 'integers', 'remove', 'zeroes', 'characters', 'equation', 'check', 'True', 'False']", "prompt_tokens": 564, "total_tokens": 837, "completion_tokens": 273, "completion": "[Question 2]\n\nYou are given an array of non-negative integers where each integer is represented as a string. Write a function to remove all the zeroes from the decimal representation of the integers and check if the resulting integers form a valid equation. If the equation is valid, return True; otherwise, return False.\n\n[/Question 2]\n\n[Code 2]\n\ndef removeZeroesAndCheckEquation(arr: List[str]) -> bool:\n    def removeZero(num: str) -> int:\n        return int(num.replace('0', ''))\n\n    numbers = [removeZero(num) for num in arr]\n    \n    return (numbers[0] + numbers[1] == numbers[2])\n\n[/Code 2]\n\n[Asserts 2]\n\nassert removeZeroesAndCheckEquation(['1023', '4000', '5023'])==True\nassert removeZeroesAndCheckEquation(['1203', '7000', '8203'])==False\nassert removeZeroesAndCheckEquation(['2304', '5000', '7304'])==True\nassert removeZeroesAndCheckEquation(['5034', '10000', '15034'])==True\nassert removeZeroesAndCheckEquation(['6000', '8000', '14000'])==False\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['integer', 'division', 'modulus', 'minimum', 'value', 'search', 'loop', 'range', 'exist']", "prompt_tokens": 517, "total_tokens": 761, "completion_tokens": 244, "completion": "[Question 2]\n\nYou're given a list of integers representing the occupancy of rooms in a hotel. Write a function to find the room number with the minimum occupancy. If there are multiple rooms with the same minimum occupancy, return the room number of the last occurrence.\n\n[/Question 2]\n\n[Code 2]\n\ndef minOccupancyRoom(occupancy: list) -> int:\n    min_occupancy = float('inf')\n    room_number = -1\n    for i in range(len(occupancy)):\n        if occupancy[i] <= min_occupancy:\n            min_occupancy = occupancy[i]\n            room_number = i + 1\n    return room_number\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minOccupancyRoom([10, 20, 5, 10, 5])==5\nassert minOccupancyRoom([5, 10, 5, 20, 10])==3\nassert minOccupancyRoom([5, 5, 5, 5, 5])==5\nassert minOccupancyRoom([10, 20, 30, 40, 50])==1\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['positive integer', 'proper divisors', 'minimized', 'multiple solutions', 'sum']", "prompt_tokens": 592, "total_tokens": 1025, "completion_tokens": 433, "completion": "[Question 2]\n\nYou are given an array of positive integers representing the number of candies of each type. Find the pair of candy types that have the minimum pairwise difference in the number of proper divisors and return the sum of their candy numbers. If there are multiple solutions, return the solution where the sum of candy numbers is minimized.\n\n[/Question 2]\n\n[Code 2]\n\nimport math\nfrom itertools import combinations\n\ndef numProperDivisors(num: int) -> int:\n    count = 0\n    for i in range(1, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            if num / i == i:\n                count += 1\n            else:\n                count += 2\n    return count\n\ndef minPairwiseDifferenceSum(candies: List[int]) -> int:\n    min_diff = float('inf')\n    min_sum = float('inf')\n    \n    for pair in combinations(range(len(candies)), 2):\n        diff = abs(numProperDivisors(candies[pair[0]]) - numProperDivisors(candies[pair[1]]))\n        if diff < min_diff:\n            min_diff = diff\n            min_sum = sum(candies[pair[0]:pair[1]+1])\n        elif diff == min_diff:\n            min_sum = min(min_sum, sum(candies[pair[0]:pair[1]+1]))\n    \n    return min_sum if min_sum != float('inf') else -1\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minPairwiseDifferenceSum([6, 7, 8, 9, 10]) == 15\nassert minPairwiseDifferenceSum([12, 15, 20, 21, 25]) == 33\nassert minPairwiseDifferenceSum([10, 15, 21, 28, 33]) == -1\nassert minPairwiseDifferenceSum([6, 8, 10, 14, 15]) == 26\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['integer', 'divisor', 'perfect square', 'math', 'maximum', 'division']", "prompt_tokens": 523, "total_tokens": 741, "completion_tokens": 218, "completion": "[Question 2]\n\nGiven an integer N, find the maximum integer M such that M is not a perfect square and the absolute difference between N and M is within a given tolerance T.\n\n[/Question 2]\n\n[Code 2]\n\ndef findMaxIntegerWithinTolerance(N: int, T: int) -> int:\n    M = int(N**0.5) - 1\n    while M * M < N:\n        M += 1\n    if abs(N - M * M) <= T:\n        M -= 1\n    return M\n\n[/Code 2]\n\n[Asserts 2]\n\nassert findMaxIntegerWithinTolerance(10, 1) == 3\nassert findMaxIntegerWithinTolerance(16, 2) == 3\nassert findMaxIntegerWithinTolerance(36, 5) == 5\nassert findMaxIntegerWithinTolerance(100, 3) == 9\nassert findMaxIntegerWithinTolerance(97, 4) == 9\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['integer', 'sum', 'natural numbers', 'divisible', 'loop', 'iteration']", "prompt_tokens": 468, "total_tokens": 717, "completion_tokens": 249, "completion": "[Question 2]\n\nYou are given a list of integers representing the percentage change in the value of a pawn for each iteration. Write a function to accept the list and return the final value of the pawn after all iterations. Each percentage change is applied to the current value of the pawn.\n\n[/Question 2]\n\n[Code 2]\n\ndef finalPawnValue(percentageChanges: List[int], initialValue: int) -> int:\n    currentValue = initialValue\n    for percentage in percentageChanges:\n        currentValue += (percentage * currentValue) / 100\n    return currentValue\n\n[/Code 2]\n\n[Asserts 2]\n\nassert finalPawnValue([10, -5, 8, -3], 1000) == 1017\nassert finalPawnValue([-20, 30, -10, 5], 500) == 420\nassert finalPawnValue([5, 2, 10, -3, 8], 1200) == 1455\nassert finalPawnValue([-10, -5, -20, 25], 1500) == 1080\nassert finalPawnValue([15, 10, -5, 20], 800) == 1000", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['range', 'inclusive', 'prime factors', 'count', 'loop', 'function', 'division', 'if statement']", "prompt_tokens": 560, "total_tokens": 833, "completion_tokens": 273, "completion": "[Question 2]\n\nWrite a function to determine whether a given number is a pandigital number after a transformation using cosine function and base changing. The transformation involves taking the cosine of the given number, changing its base, and checking if it becomes a pandigital number.\n\n[/Question 2]\n\n[Code 2]\n\ndef to_base(n, base):\n    result = ''\n    while n > 0:\n        result = str(n % base) + result\n        n = n // base\n    return result\n\ndef is_pandigital_number(number: int) -> bool:\n    digits = [str(i) for i in range(1, 10)]\n    number_str = str(number)\n    return all(digit in number_str for digit in digits) and len(number_str) == 9\n\ndef pandigital_after_transformation(number: int) -> bool:\n    transformed_number = int(abs(math.cos(number)))\n    base_changed_number = int(to_base(transformed_number, 5))\n    return is_pandigital_number(base_changed_number)\n\n[/Code 2]\n\n[Asserts 2]\n\nassert pandigital_after_transformation(30)==False\nassert pandigital_after_transformation(60)==True\nassert pandigital_after_transformation(45)==False\nassert pandigital_after_transformation(120)==True\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['factorial', 'integer', 'digits', 'max', 'math', 'iteration']", "prompt_tokens": 574, "total_tokens": 924, "completion_tokens": 350, "completion": "[Question 2]\n\nGiven a list of integers representing transaction fees of N days, find the maximum transaction fee possible if you can alter the transaction fee of any day by adding the factorial of the digits of the last card transaction fee.\n\n[/Question 2]\n\n[Code 2]\n\nfrom math import factorial\n\ndef maxTransactionFee(transactions: List[int]) -> int:\n    BIT = [0] * (len(transactions) + 1)\n\n    def update(index, val):\n        while index < len(BIT):\n            BIT[index] = max(BIT[index], val)\n            index += index & (-index)\n\n    def query(index):\n        result = 0\n        while index > 0:\n            result = max(result, BIT[index])\n            index -= index & (-index)\n        return result\n\n    max_fee = 0\n    for i in range(len(transactions)):\n        new_fee = transactions[i] + sum(factorial(int(digit)) for digit in str(transactions[i - 1])) if i > 0 else transactions[i]\n        max_fee = max(max_fee, new_fee)\n        update(i + 1, new_fee)\n    return max_fee\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maxTransactionFee([12, 25, 15, 10, 21]) == 42\nassert maxTransactionFee([5, 3, 8, 6, 12, 14]) == 28\nassert maxTransactionFee([1, 2, 3, 4, 5]) == 10\nassert maxTransactionFee([10, 20, 30, 40, 50, 60]) == 120", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['fibonacci', 'sum', 'sequence', 'math', 'numbers']", "prompt_tokens": 639, "total_tokens": 969, "completion_tokens": 330, "completion": "[Question 2]\nYou are given a sequence of numbers. Implement a function that takes the sequence and returns a new sequence with the negated position-wise sum of Fibonacci numbers up to the position in the original sequence.\n\nFor example, for the sequence [1, 2, 3, 4, 5], the function should return [-1, -1, -2, -3, -5], because at position 1, the sum of the first 1 Fibonacci numbers is -1, at position 2, the sum of the first 2 Fibonacci numbers is -1, and so on.\n\nImplement the function to solve this problem.\n\n[/Question 2]\n\n[Code 2]\n\ndef negated_fibonacci_sum(sequence):\n    def fibonacci(n):\n        a, b = 0, 1\n        for _ in range(n):\n            a, b = b, a + b\n        return a\n\n    result = []\n    for i in range(len(sequence)):\n        fib_sum = sum(fibonacci(j) for j in range(1, sequence[i] + 1))\n        result.append(-fib_sum)\n    return result\n\n[/Code 2]\n\n[Asserts 2]\n\nassert negated_fibonacci_sum([1, 2, 3, 4, 5]) == [-1, -1, -2, -3, -5]\nassert negated_fibonacci_sum([3, 2, 4, 1, 5]) == [-2, -1, -3, -1, -5]\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['integer', 'divisible', 'smallest', 'determine']", "prompt_tokens": 425, "total_tokens": 614, "completion_tokens": 189, "completion": "[Question 2]\n\nYou are given a list of integers. Write a function to determine the smallest integer in the list that is divisible by a given divisor.\n\n[/Question 2]\n\n[Code 2]\n\ndef smallestDivisibleInteger(nums: List[int], divisor: int) -> Optional[int]:\n    smallest = None\n    for num in nums:\n        if num % divisor == 0:\n            if smallest is None or num < smallest:\n                smallest = num\n    return smallest\n\n[/Code 2]\n\n[Asserts 2]\n\nassert smallestDivisibleInteger([10, 15, 20, 25, 30], 6) == 30\nassert smallestDivisibleInteger([3, 6, 9, 12, 15], 7) == None\nassert smallestDivisibleInteger([8, 16, 32, 64, 128], 4) == 8", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['integer', 'triplets', 'math', 'count', 'pythagorean theorem', 'inequality']", "prompt_tokens": 512, "total_tokens": 856, "completion_tokens": 344, "completion": "[Question 2]\n\nGiven an array of integers, write a function to count the number of triplets (a, b, c) such that a^2 + b^2 = c^2.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef countPythagoreanTriplets(arr: List[int]) -> int:\n    arr.sort()\n    n = len(arr)\n    count = 0\n    for i in range(n-1, 1, -1):\n        l, r = 0, i-1\n        while l < r:\n            if arr[l]*arr[l] + arr[r]*arr[r] == arr[i]*arr[i]:\n                count += 1\n                l += 1\n                r -= 1\n            elif arr[l]*arr[l] + arr[r]*arr[r] < arr[i]*arr[i]:\n                l += 1\n            else:\n                r -= 1\n    return count\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countPythagoreanTriplets([3, 4, 5, 6, 7, 8, 9, 10]) == 1\nassert countPythagoreanTriplets([6, 8, 10, 12, 5, 15, 13]) == 2\nassert countPythagoreanTriplets([7, 24, 25, 8, 15, 17]) == 1\nassert countPythagoreanTriplets([9, 40, 41, 5, 12, 13]) == 1\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['number', 'sum', 'digits', 'base', 'iteration']", "prompt_tokens": 489, "total_tokens": 744, "completion_tokens": 255, "completion": "[Question 2]\n\nWrite a function to detect if a given number is a happy number. A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1, or it loops endlessly in a cycle which does not include 1.\n\n[/Question 2]\n\n[Code 2]\n\ndef isHappyNumber(n: int) -> bool:\n\tdef digitSquareSum(n: int) -> int:\n\t\tsum = 0\n\t\twhile n > 0:\n\t\t\tdigit = n % 10\n\t\t\tsum += digit * digit\n\t\t\tn //= 10\n\t\treturn sum\n\t\n\tslow = n\n\tfast = n\n\twhile True:\n\t\tslow = digitSquareSum(slow)\n\t\tfast = digitSquareSum(digitSquareSum(fast))\n\t\tif slow == fast:\n\t\t\tbreak\n\treturn slow == 1\n\n[/Code 2]\n\n[Asserts 2]\n\nassert isHappyNumber(19) == True\nassert isHappyNumber(7) == True\nassert isHappyNumber(20) == False\nassert isHappyNumber(2) == False\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'integers', 'largest number', 'perfect cube', 'function', 'condition']", "prompt_tokens": 550, "total_tokens": 945, "completion_tokens": 395, "completion": "[Question 2]\n\nYou are given an array of integers and a function to check if a number is a perfect cube. Write a function `largestNonPerfectCubeIndex` to find the index of the largest number in the array that is not a perfect cube. If no such number exists, return -1.\n\nAdditionally, you need to represent the finding of the non-perfect cube using a Boolean array of the same length as the input array, where each index indicates whether the number at that index is a non-perfect cube. Implement this using memoization.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\ndef isPerfectCube(x: int) -> bool:\n    root = int(x ** (1 / 3))\n    return root ** 3 == x\n\ndef largestNonPerfectCubeIndex(arr: List[int]) -> int:\n    bool_arr = [not isPerfectCube(num) for num in arr]\n    max_non_perfect_cube = -1\n    max_non_perfect_cube_index = -1\n    for i, is_non_perfect_cube in enumerate(bool_arr):\n        if is_non_perfect_cube and arr[i] > max_non_perfect_cube:\n            max_non_perfect_cube = arr[i]\n            max_non_perfect_cube_index = i\n    return max_non_perfect_cube_index\n\n[/Code 2]\n\n[Asserts 2]\n\nassert largestNonPerfectCubeIndex([1, 8, 27, 64, 125, 216]) == -1\nassert largestNonPerfectCubeIndex([10, 20, 30, 40, 50]) == 4\nassert largestNonPerfectCubeIndex([3, 12, 5, 7, 2]) == 1\nassert largestNonPerfectCubeIndex([343, 512, 729, 1000, 1331]) == 3\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['positive', 'number', 'sum', 'integers', 'representation', 'division', 'modulo', 'multiple']", "prompt_tokens": 541, "total_tokens": 896, "completion_tokens": 355, "completion": "[Question 2]\n\nGiven a connected graph and a positive integer N, the task is to find if there exists a path in the graph whose sum of values of edges is divisible by N. Return True if such a path exists, otherwise return False.\n\n[/Question 2]\n\n[Code 2]\n\ndef isSumDivisibleByN(graph, N):\n    def dfs(node, current_sum, visited):\n        if current_sum % N == 0:\n            return True\n        visited.add(node)\n        for neighbor, edge_value in graph[node]:\n            if neighbor not in visited:\n                if dfs(neighbor, current_sum + edge_value, visited):\n                    return True\n        return False\n    \n    for node in graph:\n        if dfs(node, 0, set()):\n            return True\n    return False\n\n[/Code 2]\n\n[Asserts 2]\n\nassert isSumDivisibleByN({1: [(2, 3), (3, 5)], 2: [(3, 2)], 3: []}, 3)==True\nassert isSumDivisibleByN({1: [(2, 3), (3, 5)], 2: [(3, 2)], 3: []}, 4)==False\nassert isSumDivisibleByN({1: [(2, 3), (3, 5)], 2: [(3, 2)], 3: [(1, 4)]}, 5)==True\nassert isSumDivisibleByN({1: [(2, 3), (3, 5)], 2: [(3, 2)], 3: [(1, 4)]}, 6)==False\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['integer', 'range', 'sum', 'odd', 'natural numbers']", "prompt_tokens": 479, "total_tokens": 739, "completion_tokens": 260, "completion": "[Question 2]\n\nWrite a function to find the sum of the odd natural numbers more than a given value N within a specific range [L, R]. For example, find the sum of all odd natural numbers more than 5 and less than 15 within the range [10, 20].\n\n[/Question 2]\n\n[Code 2]\n\ndef sumOfOddMoreThanNInRange(N: int, L: int, R: int) -> int:\n    totalSum = 0\n    for i in range(L, R + 1):\n        if i > N and i % 2 != 0:\n            totalSum += i\n    return totalSum\n\n[/Code 2]\n\n[Asserts 2]\n\nassert sumOfOddMoreThanNInRange(5, 10, 20) == 75\nassert sumOfOddMoreThanNInRange(10, 15, 25) == 63\nassert sumOfOddMoreThanNInRange(3, 1, 10) == 24\nassert sumOfOddMoreThanNInRange(7, 5, 15) == 45\nassert sumOfOddMoreThanNInRange(4, 10, 20) == 75\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['divisors', 'common', 'sum', 'math', 'function', 'program']", "prompt_tokens": 565, "total_tokens": 738, "completion_tokens": 173, "completion": "[Question 2]\n\nGiven a sentence, write a program to find the sum of the distinct elements in the sentence. Treat each word in the sentence as an element.\n\nWrite a program to find the sum of distinct elements in the given sentence.\n\n[/Question 2]\n\n[Code 2]\n\ndef sumOfDistinctElements(sentence: str) -> int:\n    words = sentence.split()\n    distinct_elements = set(words)\n    return len(distinct_elements)\n\n[/Code 2]\n\n[Asserts 2]\n\nassert sumOfDistinctElements(\"The sky is blue\") == 4\nassert sumOfDistinctElements(\"This is an example example\") == 4\nassert sumOfDistinctElements(\"Python is a wonderful language\") == 5\nassert sumOfDistinctElements(\"Mississippi river flows through multiple states\") == 5\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['concatenation', 'integer', 'pattern', 'validation']", "prompt_tokens": 528, "total_tokens": 713, "completion_tokens": 185, "completion": "[Question 2]\n\nWrite a program to find the sum of the first n terms of a sequence where each term is formed by the concatenation of n with itself n times (e.g., 111 if n = 3, 4444 if n = 4, etc.). Use a while-loop for better performance.\n\n[/Question 2]\n\n[Code 2]\n\ndef sumConcatenation(n: int) -> int:\n    result = 0\n    term = 0\n    i = 1\n    while i <= n:\n        term = term * 10 + n\n        result += term\n        i += 1\n    return result\n\n[/Code 2]\n\n[Asserts 2]\n\nassert sumConcatenation(3) == 369\nassert sumConcatenation(4) == 4936\nassert sumConcatenation(5) == 61725", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['modulus', 'fibonacci', 'matrix', 'power', 'math']", "prompt_tokens": 691, "total_tokens": 943, "completion_tokens": 252, "completion": "[Question 2]\n\nGiven a binary string s of length n, find the count of pairs (i, j) such that s[i] = '1', s[j] = '1' and the value of (i*j) modulo 10^9+7 is a Fibonacci number.\n\n[/Question 2]\n\n[Code 2]\n\nN = 1000000007\ndef countFibPairs(s: str) -> int:\n    count = 0\n    n = len(s)\n    fibSet = set([0, 1, 2, 3, 5, 8, 13, 21, 34, 55])\n    for i in range(n):\n        if s[i] == '1':\n            for j in range(i+1, n):\n                if s[j] == '1':\n                    if (i*j) % N in fibSet:\n                        count += 1\n    return count\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countFibPairs(\"11011\") == 3\nassert countFibPairs(\"1010101\") == 6\nassert countFibPairs(\"1111\") == 6\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['number', 'factor', 'product', 'sum', 'math']", "prompt_tokens": 451, "total_tokens": 672, "completion_tokens": 221, "completion": "[Question 2]\n\nWrite a function to find the common prefix of a list of strings. The common prefix is the longest string that is a prefix of all strings in the list. If there is no common prefix, return an empty string.\n\n[/Question 2]\n\n[Code 2]\n\ndef commonPrefix(strings):\n    if not strings:\n        return \"\"\n    \n    min_length = min(len(s) for s in strings)\n    prefix = \"\"\n    for i in range(min_length):\n        if all(s[i] == strings[0][i] for s in strings):\n            prefix += strings[0][i]\n        else:\n            break\n    return prefix\n\n[/Code 2]\n\n[Asserts 2]\n\nassert commonPrefix([\"flower\", \"flow\", \"flight\"]) == \"fl\"\nassert commonPrefix([\"dog\", \"racecar\", \"car\"]) == \"\"\nassert commonPrefix([\"interspecies\", \"interstellar\", \"interstate\"]) == \"inter\"\nassert commonPrefix([]) == \"\"\nassert commonPrefix([\"prefix\", \"prey\", \"pregnant\"]) == \"pre\"", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'operation', 'subarray', 'increase', 'decrease', 'beautiful', 'absolute difference', 'adjacent elements', 'minimum', 'dynamic programming']", "prompt_tokens": 596, "total_tokens": 876, "completion_tokens": 280, "completion": "[Question 2]\n\nYou are given an array of integers representing the number of teddies in a line. The task is to find the minimum number of operations required to make the array beautiful. A beautiful array is defined as an array where the absolute difference between the number of teddies in any two adjacent positions is at most 1. In one operation, you can either increase or decrease the number of teddies by one in any subarray. Write a function to find the minimum number of operations required.\n\n[/Question 2]\n\n[Code 2]\n\ndef minOperationsToMakeBeautiful(teddies: List[int]) -> int:\n    n = len(teddies)\n    operations = 0\n    \n    for i in range(1, n):\n        diff = abs(teddies[i] - teddies[i-1])\n        operations += diff\n    \n    return operations\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minOperationsToMakeBeautiful([3, 2, 2, 2, 3])==2\nassert minOperationsToMakeBeautiful([3, 2, 1, 2, 3])==2\nassert minOperationsToMakeBeautiful([10, 10, 10, 10])==0\nassert minOperationsToMakeBeautiful([1, 3, 2, 4, 3])==4", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['integer', 'subtraction', 'most significant digit', 'steps', 'reduce', 'loop', 'string', 'length', 'math']", "prompt_tokens": 488, "total_tokens": 759, "completion_tokens": 271, "completion": "[Question 2]\n\nGiven a string representing a sequence of movements in the form of \"U\" (up) and \"R\" (right), where each step corresponds to a unit displacement in a 2D plane, write a function to calculate the final displacement from the starting point, where \"U\" denotes a movement towards the positive y-axis and \"R\" denotes a movement towards the positive x-axis. Consider the thousands place as the most significant digit in case negative numbers are involved.\n\n[/Question 2]\n\n[Code 2]\n\ndef calculateFinalDisplacement(movements: str) -> int:\n    x_displacement = 0\n    y_displacement = 0\n    for move in movements:\n        if move == \"U\":\n            y_displacement += 1\n        elif move == \"R\":\n            x_displacement += 1\n    return x_displacement * 1000 + y_displacement\n\n[/Code 2]\n\n[Asserts 2]\n\nassert calculateFinalDisplacement(\"UUUURR\") == 4003\nassert calculateFinalDisplacement(\"RRUURUUU\") == 7003\nassert calculateFinalDisplacement(\"RURURU\") == 3003\nassert calculateFinalDisplacement(\"UURRRU\") == 5002\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['math', 'GCD', 'power', 'function', 'integer']", "prompt_tokens": 454, "total_tokens": 626, "completion_tokens": 172, "completion": "[Question 2]\n\nWrite a Python function to calculate the GCD of the area of two right-angled triangles given the lengths of their legs as inputs. Make use of the math library for calculating the power and the GCD of the areas.\n\n[/Question 2]\n\n[Code 2]\n\nimport math\n\ndef gcd_of_triangle_areas(a: int, b: int) -> int:\n    area1 = 0.5 * a * b\n    area2 = 0.5 * a * b\n    return math.gcd(area1, area2)\n\n[/Code 2]\n\n[Asserts 2]\n\nassert gcd_of_triangle_areas(3, 4)==6\nassert gcd_of_triangle_areas(5, 12)==6\nassert gcd_of_triangle_areas(8, 15)==8\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['integer', 'odd', 'digits', 'largest', 'string', 'substring']", "prompt_tokens": 437, "total_tokens": 668, "completion_tokens": 231, "completion": "[Question 2]\n\nGiven a string representing a phone number, write a function to find the largest substring of the phone number that consists of odd digits and can be obtained by expanding from a single character removal.\n\n[/Question 2]\n\n[Code 2]\n\ndef largestOddDigitExpandingSubstring(phone: str) -> str:\n    max_len = 0\n    result = \"\"\n    for i in range(len(phone)):\n        for j in range(i + 1, len(phone) + 1):\n            sub = phone[i:j]\n            if all(int(d) % 2 != 0 for d in sub):\n                if len(sub) > max_len:\n                    max_len = len(sub)\n                    result = sub\n    return result\n\n[/Code 2]\n\n[Asserts 2]\n\nassert largestOddDigitExpandingSubstring(\"8675309\") == \"75309\"\nassert largestOddDigitExpandingSubstring(\"1234567890\") == \"789\"\nassert largestOddDigitExpandingSubstring(\"246810\") == \"\"\nassert largestOddDigitExpandingSubstring(\"975319\") == \"975319\"\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['integer', 'counting', 'perfect squares', 'product', 'nested loop']", "prompt_tokens": 469, "total_tokens": 854, "completion_tokens": 385, "completion": "[Question 2]\n\nGiven a matrix represented as a 2D list, where each row and column are sorted in ascending order, design a function to find the universal sink, if it exists. A universal sink is a number such that every other number in the matrix is either less than or equal to it.\n\n[/Question 2]\n\n[Code 2]\n\ndef findUniversalSink(matrix: List[List[int]]) -> int:\n    rows, cols = len(matrix), len(matrix[0])\n    row, col = 0, cols - 1\n    while row < rows and col >= 0:\n        if matrix[row][col] == 1:\n            col -= 1\n        else:\n            row += 1\n    # Check if the potential sink is actually a universal sink\n    potential_sink = matrix[row][col]\n    for r in range(rows):\n        if r != row and matrix[r][col] >= potential_sink:\n            return -1\n    for c in range(cols):\n        if c != col and matrix[row][c] <= potential_sink:\n            return -1\n    return potential_sink\n\n[/Code 2]\n\n[Asserts 2]\n\nmatrix1 = [\n    [0, 0, 0],\n    [0, 1, 0],\n    [1, 1, 1]\n]\nmatrix2 = [\n    [0, 0, 1],\n    [0, 0, 1],\n    [0, 0, 0]\n]\nmatrix3 = [\n    [0, 0, 0],\n    [1, 1, 1],\n    [0, 1, 0]\n]\nassert findUniversalSink(matrix1) == 1\nassert findUniversalSink(matrix2) == 2\nassert findUniversalSink(matrix3) == -1\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['integer', 'array', 'product', 'count', 'pairs', 'less than', 'multiplication', 'iteration']", "prompt_tokens": 562, "total_tokens": 958, "completion_tokens": 396, "completion": "[Question 2]\n\nYou are given a tree with N nodes represented as an array and its Prufer sequence. The task is to count the number of pairs of nodes (a, b) such that the product of the value at node a and the value at node b is less than a given integer P.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\ndef countPairsWithProductLessThanP(tree: List[int], pruferSeq: List[int], P: int) -> int :\n    n = len(tree) + 1\n    arr = [0] * n\n    for i in range(n - 2) :\n        arr[pruferSeq[i]] = arr[pruferSeq[i]] + 1\n    x = 0\n    while (arr[x] != 0) :\n        x = x + 1\n    arr[x] = 1\n    answer = 0\n    for i in range(n - 1) :\n        answer = answer + (tree[i] * arr[i])\n    return answer\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countPairsWithProductLessThanP([1, 2, 3, 4], [0, 0, 0], 10)==10\nassert countPairsWithProductLessThanP([3, 2, 5, 7, 4], [0, 0, 1, 1], 20)==61\nassert countPairsWithProductLessThanP([2, 3, 4, 5, 6, 7], [2, 3, 4, 5], 30)==149\nassert countPairsWithProductLessThanP([1, 1, 1, 1, 1], [0, 0, 0], 5)==5\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'consecutive', 'pairwise', 'absolute', 'difference', 'integers', 'math', 'list']", "prompt_tokens": 523, "total_tokens": 738, "completion_tokens": 215, "completion": "[Question 2]\n\nYou are given a list of integers representing the weights of edges in a graph. Write a function to find the greatest absolute difference between consecutive elements in the list using Dijkstra's algorithm.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\nimport heapq\n\ndef greatestAbsoluteDifference(weights: List[int]) -> int:\n    differences = [abs(weights[i] - weights[i+1]) for i in range(len(weights)-1)]\n    return max(differences)\n\n# Example usage\nweights = [4, 9, 5, 12, 8]\nprint(greatestAbsoluteDifference(weights))\n\n[/Code 2]\n\n[Asserts 2]\n\nassert greatestAbsoluteDifference([3, 7, 11, 5, 9]) == 6\nassert greatestAbsoluteDifference([2, 5, 10, 8, 15]) == 7\nassert greatestAbsoluteDifference([6, 11, 8, 14, 9]) == 5\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['sum', 'multiples', 'less than', 'iteration', 'arithmetic']", "prompt_tokens": 473, "total_tokens": 724, "completion_tokens": 251, "completion": "[Question 2]\n\nYou are given an undirected graph represented as an adjacency list. Your task is to find the sum of the largest powers of 2 for each node, where the power is less than a given threshold T. \n\n[/Question 2]\n\n[Code 2]\n\nfrom collections import defaultdict\n\ndef sumOfLargestPowers(adjacency_list: dict, threshold: int) -> int:\n    sum = 0\n    for node in adjacency_list:\n        max_power = 0\n        for power in range(threshold):\n            if 2 ** power < threshold:\n                max_power = power\n        sum += max_power\n    return sum\n\n[/Code 2]\n\n[Asserts 2]\n\ngraph = {\n    1: [2, 3],\n    2: [1, 3],\n    3: [1, 2]\n}\nassert sumOfLargestPowers(graph, 5) == 6\nassert sumOfLargestPowers(graph, 10) == 12\nassert sumOfLargestPowers(graph, 20) == 18\nassert sumOfLargestPowers(graph, 7) == 9\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['list', 'student', 'exam', 'score', 'marking scheme', 'dictionary', 'calculation', 'comparison', 'loop', 'iteration']", "prompt_tokens": 659, "total_tokens": 939, "completion_tokens": 280, "completion": "[Question 2]\n\nYou are given a list of students and their scores in an exam according to a marking scheme. Write a function to calculate the average score of all the students and return the result. \n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List, Dict\ndef calculateAverageScore(students: List[str], markingScheme: Dict[str, int], scores: Dict[str, int]) -> float:\n    total_score = 0\n    for student in students:\n        total_score += scores[student]\n    average_score = total_score / len(students)\n    return average_score\n\n[/Code 2]\n\n[Asserts 2]\n\nassert calculateAverageScore(['Alice', 'Bob', 'Carol'], {'A': 5, 'B': 3, 'C': 2}, {'Alice': 5, 'Bob': 3, 'Carol': 2}) == 3.3333\nassert calculateAverageScore(['Alice'], {'A': 5, 'B': 3, 'C': 2}, {'Alice': 5}) == 5.0\nassert calculateAverageScore(['Alice', 'Bob'], {'A': 5, 'B': 3, 'C': 2}, {'Alice': 5, 'Bob': 4}) == 4.5\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['positive', 'integer', 'product', 'prime numbers', 'math', 'loop', 'function', 'boolean', 'conditional']", "prompt_tokens": 608, "total_tokens": 980, "completion_tokens": 372, "completion": "[Question 2]\n\nGiven a 2D array of integers, find the product of all the special elements at odd levels in the array. A special element is an integer which is a quartan prime and greater than 10.\n\n[/Question 2]\n\n[Code 2]\n\ndef isPrime(n):\n\tif n <= 1:\n\t\treturn False\n\tfor i in range(2, int(n**0.5)+1):\n\t\tif n % i == 0:\n\t\t\treturn False\n\treturn True\n\ndef isQuartanPrime(n):\n\treturn isPrime(n) and isPrime((n+1)/4)\n\ndef productOfSpecialElements(arr):\n\tproduct = 1\n\tfor i in range(1, len(arr), 2):\n\t\tfor j in arr[i]:\n\t\t\tif j > 10 and isQuartanPrime(j):\n\t\t\t\tproduct *= j\n\treturn product\n\n[/Code 2]\n\n[Asserts 2]\n\nassert productOfSpecialElements([[2, 6, 17], [3, 13, 11], [5, 19, 8]]) == 143\nassert productOfSpecialElements([[19, 8, 10], [13, 11, 16], [2, 6, 17]]) == 323\nassert productOfSpecialElements([[2, 6, 17, 19], [3, 13, 11, 23], [5, 29, 8, 31], [37, 41, 43, 47]]) == 567\nassert productOfSpecialElements([[2, 4, 6], [3, 7, 11], [5, 13, 17], [19, 23, 29]]) == 1\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['range', 'count', 'numbers', 'odd', 'divisors', 'perfect square']", "prompt_tokens": 656, "total_tokens": 1093, "completion_tokens": 437, "completion": "[Question 2]\n\nYou are given a list of temperatures representing the warmer temperature of a particular location collected at different time intervals. Your task is to find the maximum number of consecutive temperatures that are perfect squares and have an odd number of divisors.\n\nWrite a function `maxOddDivisorConsecutive(temperatures: List[int]) -> int` where\n- temperatures: a list of temperatures represented as integers\n\nThe function should return an integer representing the maximum number of consecutive temperatures that are perfect squares and have an odd number of divisors.\n\nFor example, given temperatures [8, 16, 9, 25, 5, 10, 49, 81, 12, 36], the maximum number of consecutive temperatures with odd divisors is 3 (9, 25, 49).\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\ndef maxOddDivisorConsecutive(temperatures: List[int]) -> int:\n    max_count = 0\n    count = 0\n    for temp in temperatures:\n        if (int(temp**0.5))**2 == temp:\n            count += 1\n        else:\n            max_count = max(max_count, count)\n            count = 0\n    return max(max_count, count)\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maxOddDivisorConsecutive([8, 16, 9, 25, 5, 10, 49, 81, 12, 36])==3\nassert maxOddDivisorConsecutive([4, 9, 16, 25, 36])==5\nassert maxOddDivisorConsecutive([1, 3, 5, 7, 9, 11, 13, 15])==1\nassert maxOddDivisorConsecutive([64, 81, 100, 121, 144, 169, 196])==7\nassert maxOddDivisorConsecutive([10, 13, 16, 19, 25, 36])==1\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['integer', 'range', 'GCD', 'divisible', 'pair', 'existence']", "prompt_tokens": 543, "total_tokens": 818, "completion_tokens": 275, "completion": "[Question 2]\n\nGiven a list of integers, the task is to check if there exists a non-decreasing order pair of integers in the list such that the GCD of the pair is divisible by a given integer k. Return True if such a pair exists, otherwise return False. If the list is empty, return False.\n\n[/Question 2]\n\n[Code 2]\n\ndef gcd(a, b): \n\tif (b == 0): \n\t\treturn a \n\treturn gcd(b, a % b) \n\ndef pairExistInList(arr: List[int], k: int) -> bool:\n\tif not arr:\n\t\treturn False\n\t\n\tarr.sort()\n\tfor i in range(len(arr)-1): \n\t\tif (arr[i+1] % arr[i] == 0) and (gcd(arr[i], arr[i+1]) % k == 0): \n\t\t\treturn True\n\treturn False\n\n[/Code 2]\n\n[Asserts 2]\n\nassert pairExistInList([3, 6, 9, 12], 3)==True\nassert pairExistInList([2, 4, 8, 16], 5)==False\nassert pairExistInList([5, 10, 15], 5)==True\nassert pairExistInList([], 2)==False\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['molecule', 'valence', 'atoms', 'sum', 'zero', 'chemistry', 'math', 'boolean']", "prompt_tokens": 533, "total_tokens": 872, "completion_tokens": 339, "completion": "[Question 2]\n\nYou are given an array of integers representing valence numbers of atoms. Write a function to determine if it is possible to construct a molecule such that the sum of valence numbers is equal to zero. You can assume that the array is sorted in non-decreasing order.\n\nYour task is to write a function that takes in a sorted array of valence numbers and returns True if it is possible to construct a molecule with a sum of valence numbers equal to zero, otherwise return False.\n\n[/Question 2]\n\n[Code 2]\n\ndef canConstructMolecule(valence_numbers: List[int]) -> bool:\n    left, right = 0, len(valence_numbers) - 1\n    while left < right:\n        if valence_numbers[left] + valence_numbers[right] == 0:\n            return True\n        elif valence_numbers[left] + valence_numbers[right] < 0:\n            left += 1\n        else:\n            right -= 1\n    return False\n\n[/Code 2]\n\n[Asserts 2]\n\nassert canConstructMolecule([-3, -2, -1, 0, 1, 2, 3]) == True\nassert canConstructMolecule([-2, 0, 1, 3]) == False\nassert canConstructMolecule([-1, 0, 1, 2]) == True\nassert canConstructMolecule([1, 2, 3, 4, 5]) == False\nassert canConstructMolecule([-1, 0, 2, 3, 5]) == True\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['series', 'sum', 'factorial', 'iteration', 'math', 'float']", "prompt_tokens": 547, "total_tokens": 791, "completion_tokens": 244, "completion": "[Question 2]\n\nWrite a program to find the largest sum of a sub-array within a given array of 32-bit integers. The input to the program is the array of integers.\n\n[/Question 2]\n\n[Code 2]\n\ndef max_subarray_sum(nums: List[int]) -> int:\n    max_sum = float('-inf')\n    curr_sum = 0\n    for num in nums:\n        curr_sum = max(num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n    return max_sum\n\n[/Code 2]\n\n[Asserts 2]\n\nassert max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) == 6\nassert max_subarray_sum([1, 2, 3, -2, 5]) == 9\nassert max_subarray_sum([-2, -3, 4, -1, -2, 1, 5, -3]) == 7\nassert max_subarray_sum([-1, -2, -3, -4, -5]) == -1\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['number', 'count', 'divisors', 'prime', 'integer']", "prompt_tokens": 563, "total_tokens": 750, "completion_tokens": 187, "completion": "[Question 2]\n\nWrite a function to efficiently count the number of prime numbers less than a given integer N.\n\n[/Question 2]\n\n[Code 2]\n\ndef countPrimes(N: int) -> int:\n    if N < 2:\n        return 0\n    is_prime = [True] * N\n    is_prime[0], is_prime[1] = False, False\n    for i in range(2, int(N**0.5) + 1):\n        if is_prime[i]:\n            for j in range(i * i, N, i):\n                is_prime[j] = False\n    return sum(is_prime)\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countPrimes(10)==4\nassert countPrimes(20)==8\nassert countPrimes(30)==10\nassert countPrimes(50)==15\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['integer', 'operation', 'distinct', 'lcm', 'gcd']", "prompt_tokens": 463, "total_tokens": 775, "completion_tokens": 312, "completion": "[Question 2]\n\nGiven a binary tree, you are required to calculate the sum of distinct integers obtained by performing the operation lcm of all the integers from root-to-leaf paths.\n\n[/Question 2]\n\n[Code 2]\n\nclass TreeNode:\n    def __init__(self, value=0, left=None, right=None):\n        self.value = value\n        self.left = left\n        self.right = right\n\ndef gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef lcm(a, b):\n    return abs(a*b) // gcd(a, b)\n\ndef rootToLeafLcmSum(root: TreeNode) -> int:\n    if not root:\n        return 0\n    \n    def dfs(node, current):\n        if not node:\n            return 0\n        current_lcm = lcm(current, node.value)\n        if not node.left and not node.right:\n            return current_lcm\n        return dfs(node.left, current_lcm) + dfs(node.right, current_lcm)\n\n    return dfs(root, 1)\n\n[/Code 2]\n\n[Asserts 2]\n\n# Create a sample tree\nroot = TreeNode(2, TreeNode(7, TreeNode(10), TreeNode(6)), TreeNode(5, TreeNode(9), TreeNode(11)))\nassert rootToLeafLcmSum(root) == 682\n\n# Test with a single node tree\nroot2 = TreeNode(5)\nassert rootToLeafLcmSum(root2) == 5", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['integer', 'dimensions', 'rectangle', 'placement', 'size', 'count', 'division']", "prompt_tokens": 462, "total_tokens": 612, "completion_tokens": 150, "completion": "[Question 2]\n\nYou are given an integer n. Your task is to write a function to reverse the digits of the given integer.\n\n[/Question 2]\n\n[Code 2]\n\ndef reverseInteger(n: int) -> int:\n    rev = 0\n    while n > 0:\n        rev = rev * 10 + n % 10\n        n = n // 10\n    return rev\n\n[/Code 2]\n\n[Asserts 2]\n\nassert reverseInteger(123)==321\nassert reverseInteger(4567)==7654\nassert reverseInteger(78900)==987\nassert reverseInteger(10001)==10001\nassert reverseInteger(54321)==12345\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['integer', 'positive', 'smallest', 'number', 'occurrences', 'digits']", "prompt_tokens": 600, "total_tokens": 814, "completion_tokens": 214, "completion": "[Question 2]\n\nYou are given a positive integer N. Find the smallest positive integer M, such that M has the same number of digits as N and the binary representation of M contains N consecutive set bits.\n\nFor example, if N = 3, the smallest positive integer M with 3 consecutive set bits in its binary representation is 7 (111 in binary).\n\nWrite a function to find the smallest positive integer M as described above.\n\n[/Question 2]\n\n[Code 2]\n\ndef smallestIntegerWithConsecutiveSetBits(N: int) -> int:\n    m = 1\n    while True:\n        binary = bin(m)[2:]\n        if '1' * N in binary:\n            return m\n        m += 1\n\n[/Code 2]\n\n[Asserts 2]\n\nassert smallestIntegerWithConsecutiveSetBits(2) == 3\nassert smallestIntegerWithConsecutiveSetBits(4) == 15\nassert smallestIntegerWithConsecutiveSetBits(3) == 7\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['distribution', 'chocolates', 'students', 'minimum', 'maximum', 'division', 'math']", "prompt_tokens": 590, "total_tokens": 805, "completion_tokens": 215, "completion": "[Question 2]\n\nYou have a chocolate bar consisting of N squares. You are allowed to make a minimum or a maximum of K flips to divide the chocolate bar into equal parts for a group of students. Write a program to determine the minimum and maximum number of flips required for the distribution.\n\n[/Question 2]\n\n[Code 2]\n\ndef minMaxFlips(n: int, k: int) -> (int, int):\n    min_flips = 0 if k == 1 else 1\n    max_flips = n-1 if k == 1 else n-k\n    return (min_flips, max_flips)\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minMaxFlips(10, 5) == (1, 5)\nassert minMaxFlips(8, 4) == (1, 4)\nassert minMaxFlips(20, 3) == (1, 17)\nassert minMaxFlips(15, 1) == (0, 14)", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['fare', 'travel', 'cab', 'cost', 'time', 'money', 'trip', 'calculate']", "prompt_tokens": 528, "total_tokens": 855, "completion_tokens": 327, "completion": "[Question 2]\n\nYou are planning to travel for a trip and you have decided to take a cab. The fare for the cab is calculated based on the time and distance traveled. Given the time in minutes and the distance in kilometers, write a function to calculate the total fare for the trip.\n\nThe fare is calculated using the following rules:\n- The initial cost of the trip is $5.\n- For every kilometer traveled, an additional $2 is added to the fare.\n- For every 10 minutes of travel time, an additional $1 is added to the fare.\n- A 10% discount is applied to the total fare if the number of letters in the word \"juice\" is equal to the area of a rectangular area calculated using the distance and time as length and width. \n\nWrite a function to calculate the total fare for the trip and apply the discount if the condition is met.\n\n[/Question 2]\n\n[Code 2]\n\ndef calculateFare(distance: float, time: int) -> float:\n    initial_cost = 5\n    fare = initial_cost + 2 * distance + (time / 10)\n    discount_condition = len(\"juice\") == distance * time\n    if discount_condition:\n        fare = fare * 0.9\n    return fare\n\n[/Code 2]\n\n[Asserts 2]\n\nassert calculateFare(10.5, 30) == 31.5\nassert calculateFare(5.5, 45) == 21.5\nassert calculateFare(8, 20) == 28.8", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['quartic', 'equation', 'roots', 'sum', 'product', 'absolute difference', 'math', 'algebra', 'polynomial']", "prompt_tokens": 647, "total_tokens": 1065, "completion_tokens": 418, "completion": "[Question 2]\n\nGiven a quartic equation of the form ax^4 + bx^3 + cx^2 + dx + e = 0, write a function to find the absolute difference between the product of the sum of the roots taken two at a time and the sum of the products of the roots taken three at a time.\n\n[/Question 2]\n\n[Code 2]\n\ndef findRootsQuartic(a, b, c, d, e):\n    # implementing the logic for finding roots of quartic equation\n    roots = []\n    # ...\n    return roots\n\ndef calculateDifferenceQuartic(a, b, c, d, e):\n    roots = findRootsQuartic(a, b, c, d, e)\n    sum_pairs_product = 0\n    product_triplets_sum = 0\n    for i in range(len(roots)):\n        for j in range(i + 1, len(roots)):\n            # calculating sum of pairs of roots and their product\n            sum_pairs_product += roots[i] + roots[j]\n        \n        for j in range(i + 1, len(roots)):\n            for k in range(j + 1, len(roots)):\n                # calculating sum of triplets of roots and their product\n                product_triplets_sum += roots[i] * roots[j] * roots[k]\n    \n    return abs(sum_pairs_product - product_triplets_sum)\n\n[/Code 2]\n\n[Asserts 2]\n\nassert calculateDifferenceQuartic(1, -10, 35, -50, 24) == 810\nassert calculateDifferenceQuartic(1, 7, 14, 8, -42) == 560\nassert calculateDifferenceQuartic(1, -5, 5, -5, 1) == 54\nassert calculateDifferenceQuartic(1, -4, 6, -4, 1) == 80\nassert calculateDifferenceQuartic(1, -6, 11, -6, 1) == 126", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'percentages', 'attendance', 'minimum', 'additional', 'maintain', 'subject']", "prompt_tokens": 626, "total_tokens": 1016, "completion_tokens": 390, "completion": "[Question 2]\n\nYou are given an array of attendance percentages for different subjects, and a boolean array indicating whether the attendance for each subject is inside or outside the minimum required percentage. \n\nWrite a function, named `segregateAttendance`, that takes in the arrays of percentages and booleans and a target year, and returns a list of subjects that need to maintain or improve their attendance to meet the target year's requirement. \n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef segregateAttendance(attendance: List[int], inside: List[bool], target_year: int) -> List[str]:\n    subjects_to_improve = []\n    for i in range(len(attendance)):\n        if inside[i] and attendance[i] < target_year:\n            subjects_to_improve.append(\"Subject \" + str(i+1))\n        elif not inside[i] and attendance[i] >= target_year:\n            subjects_to_improve.append(\"Subject \" + str(i+1))\n    \n    return subjects_to_improve\n\n[/Code 2]\n\n[Asserts 2]\n\nassert segregateAttendance([80, 85, 70, 60, 90], [True, True, False, True, True], 75) == ['Subject 3']\nassert segregateAttendance([60, 55, 70, 80, 65], [False, True, False, True, True], 60) == ['Subject 1', 'Subject 3']\nassert segregateAttendance([90, 85, 75, 80, 70], [True, True, True, True, True], 80) == []\nassert segregateAttendance([50, 60, 70, 40, 45, 65], [True, False, True, False, False, True], 60) == ['Subject 2', 'Subject 4', 'Subject 5']", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['integer', 'counting', 'odd', 'zeros', 'digits']", "prompt_tokens": 475, "total_tokens": 712, "completion_tokens": 237, "completion": "[Question 2]\n\nWrite a Python function to count the total number of even count integers in a given list of numbers. An even count integer is defined as an integer in which each digit appears an even number of times.\n\n[/Question 2]\n\n[Code 2]\n\ndef countEvenCountIntegers(numbers: List[int]) -> int:\n    def hasEvenCount(number: int) -> bool:\n        count = [0]*10\n        for digit in str(number):\n            count[int(digit)] += 1\n        return all(c % 2 == 0 for c in count if c != 0)\n\n    return sum(1 for num in numbers if hasEvenCount(num))\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countEvenCountIntegers([22, 333, 4444, 55555, 6666]) == 3\nassert countEvenCountIntegers([123, 4556, 7890, 1010, 222]) == 2\nassert countEvenCountIntegers([1357, 2468, 7890, 1010, 5555]) == 4", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['prime numbers', 'Sieve of Eratosthenes', 'algorithm', 'sum', 'range', 'math']", "prompt_tokens": 612, "total_tokens": 980, "completion_tokens": 368, "completion": "[Question 2]\n\nWrite a recursive function to find the sum of prime numbers in a given range. If the sum is a prime number, return the capitalized version of the destination node; otherwise, reject the result. Use the Sieve of Eratosthenes algorithm to efficiently find prime numbers.\n\n[/Question 2]\n\n[Code 2]\n\ndef sieveOfEratosthenes(n: int) -> list:\n\tprime = [True for i in range(n+1)]\n\tp = 2\n\twhile (p * p <= n):\n\t\tif (prime[p] == True):\n\t\t\tfor i in range(p * p, n+1, p):\n\t\t\t\tprime[i] = False\n\t\tp += 1\n\t\t\n\tprime[0]= False\n\tprime[1]= False\n\t\n\treturn prime\n\ndef isPrime(n: int) -> bool:\n\tif n <= 1:\n\t\treturn False\n\tfor i in range(2, int(n**0.5) + 1):\n\t\tif n % i == 0:\n\t\t\treturn False\n\treturn True\n\ndef recursiveSumPrimeAndCapitalized(primeRange: range) -> str:\n\tsumOfPrimes = sum(num for num in primeRange if isPrime(num))\n\tif isPrime(sumOfPrimes):\n\t\treturn 'DESTINATION NODE'.capitalize()\n\telse:\n\t\treturn 'REJECT'\n\n[/Code 2]\n\n[Asserts 2]\n\nassert recursiveSumPrimeAndCapitalized(range(10, 20))=='Reject'\nassert recursiveSumPrimeAndCapitalized(range(3, 10))=='DESTINATION NODE'\nassert recursiveSumPrimeAndCapitalized(range(1, 5))=='DESTINATION NODE'\nassert recursiveSumPrimeAndCapitalized(range(5, 20))=='Reject'\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['sum', 'series', 'terms', 'sequence', 'arithmetic progression', 'mathematical formula']", "prompt_tokens": 461, "total_tokens": 651, "completion_tokens": 190, "completion": "[Question 2]\n\nWrite a function to find the maximum count of palindromic numbers in a given series of numbers in an arithmetic progression. The palindromic numbers are the ones that read the same backward as forward.\n\n[/Question 2]\n\n[Code 2]\n\ndef countPalindromicNumbersInAP(series):\n    count = 0\n    for num in series:\n        if str(num) == str(num)[::-1]:\n            count += 1\n    return count\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countPalindromicNumbersInAP([101, 202, 303, 404, 505])==5\nassert countPalindromicNumbersInAP([123, 234, 345, 456, 567])==0\nassert countPalindromicNumbersInAP([121, 232, 343, 454, 565])==5", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['quadratic', 'equation', 'discriminant', 'solutions', 'coefficients', 'real', 'function']", "prompt_tokens": 610, "total_tokens": 1073, "completion_tokens": 463, "completion": "[Question 2]\n\nGiven a quadratic equation in the form of ax^2 + bx + c = 0, write a function to calculate the discriminant and return the value of the discriminant for the given coefficients of the quadratic equation. Additionally, write a function to find the inorder predecessor of a given cell value in a shuffling sequence, and maintain the same type of cell value based on a specified function.\n\nWrite a program that includes these two independent functions to perform the aforementioned tasks.\n\n[/Question 2]\n\n[Code 2]\n\n# Function to calculate the discriminant of a quadratic equation\ndef calculate_discriminant(a: float, b: float, c: float) -> float:\n    discriminant = (b ** 2) - (4 * a * c)\n    return discriminant\n\n# Function to find the inorder predecessor in a shuffling sequence and maintain the same type of cell value based on a specified function\ndef inorder_predecessor_and_maintain_type(cell_value: int, shuffle_sequence: list, maintain_type_func: callable) -> int:\n    index = shuffle_sequence.index(cell_value)\n    predecessor_index = (index - 1) % len(shuffle_sequence)\n    predecessor_value = shuffle_sequence[predecessor_index]\n    return maintain_type_func(predecessor_value)\n\n[/Code 2]\n\n[Asserts 2]\n\nassert calculate_discriminant(1, 5, 6) == 1\nassert calculate_discriminant(1, 4, 4) == 0\nassert calculate_discriminant(1, 2, 3) == -8\n\nassert inorder_predecessor_and_maintain_type(7, [5, 7, 3, 2, 8, 6], lambda x: x*2) == 14\nassert inorder_predecessor_and_maintain_type(3, [5, 7, 3, 2, 8, 6], lambda x: x+1) == 8\nassert inorder_predecessor_and_maintain_type(2, [5, 7, 3, 2, 8, 6], lambda x: x**2) == 9\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['conversion', 'kilobytes', 'bytes', 'bits', 'multiplication', 'data', 'measurement']", "prompt_tokens": 597, "total_tokens": 1028, "completion_tokens": 431, "completion": "[Question 2]\n\nWrite a Python program to find the final number after performing a series of multiplication operations on an initial number. Each operation involves multiplying the current number by a given factor. The factor for each operation is given in kilobytes as a form of self-referential data. An autobiographical sequence is a series in which the nth term is the number of times the digit n appears in the sequence. Implement a function that takes the initial number, a list of factors in kilobytes, and performs the multiplication operations to find the final number. Then, validate whether the final number is an autobiographical number or not.\n\n[/Question 2]\n\n[Code 2]\n\ndef calculateFinalNumber(initial_number: int, factors_in_kb: list) -> int:\n    result = initial_number\n    for factor in factors_in_kb:\n        result *= int(str(factor).replace('KB', ''))\n    return result\n\ndef isAutobiographicalNumber(number: int) -> bool:\n    freq = [0] * 10\n    temp = number\n    while temp > 0:\n        digit = temp % 10\n        freq[digit] += 1\n        temp //= 10\n    for i in range(len(freq)):\n        if str(freq[i]) not in str(number):\n            return False\n    return True\n\n[/Code 2]\n\n[Asserts 2]\n\nassert calculateFinalNumber(6, ['2KB', '3KB', '5KB']) == 180\nassert isAutobiographicalNumber(180) == True\n\nassert calculateFinalNumber(9, ['1KB', '9KB', '3KB']) == 243\nassert isAutobiographicalNumber(243) == True\n\nassert calculateFinalNumber(2, ['4KB', '0KB', '6KB']) == 0\nassert isAutobiographicalNumber(0) == False\n\nassert calculateFinalNumber(7, ['7KB', '3KB', '9KB']) == 1323\nassert isAutobiographicalNumber(1323) == False\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['integer', 'series', 'sum', 'exponentiation']", "prompt_tokens": 512, "total_tokens": 747, "completion_tokens": 235, "completion": "[Question 2]\n\nWrite a function to calculate the sum of a frustum series up to 'n' terms, where each term in the series is of the form (a^2 + ab + b^2) and 'a' and 'b' are consecutive integers starting from the given principle 'p'.\n\n[/Question 2]\n\n[Code 2]\n\ndef frustumSum(principle: int, n: int) -> int:\n    total_sum = 0\n    a = principle\n    for i in range(1, n + 1):\n        total_sum += a**2 + a*(a+1) + (a+1)**2\n        a += 1\n    return total_sum\n\n[/Code 2]\n\n[Asserts 2]\n\nassert frustumSum(2, 3) == 62\nassert frustumSum(1, 3) == 33\nassert frustumSum(3, 4) == 127\nassert frustumSum(5, 2) == 83\nassert frustumSum(4, 3) == 82\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['sum', 'series', 'difference', 'consecutive', 'terms', 'increase']", "prompt_tokens": 455, "total_tokens": 720, "completion_tokens": 265, "completion": "[Question 2]\n\nWrite a Python function to find the difference in the cyclic labels of two given IP addresses. The cyclic label of an IP address is the sum of the digits in the address, and the difference between two cyclic labels is the absolute difference between their respective sums.\n\n[/Question 2]\n\n[Code 2]\n\ndef cyclic_label(ip):\n    sum = 0\n    ip_parts = ip.split('.')\n    for part in ip_parts:\n        sum += int(part)\n    return sum\n\ndef cyclic_label_difference(ip1, ip2):\n    label1 = cyclic_label(ip1)\n    label2 = cyclic_label(ip2)\n    return abs(label1 - label2)\n\n[/Code 2]\n\n[Asserts 2]\n\nassert cyclic_label('192.168.1.1') == 22\nassert cyclic_label('10.0.0.1') == 11\nassert cyclic_label_difference('192.168.1.1', '10.0.0.1') == 11\nassert cyclic_label_difference('10.0.0.1', '10.0.0.1') == 0\nassert cyclic_label_difference('255.255.255.255', '0.0.0.0') == 24\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['integer', 'sum', 'product', 'digits', 'maximum', 'reduce', 'single digit', 'mathematical operations']", "prompt_tokens": 554, "total_tokens": 868, "completion_tokens": 314, "completion": "[Question 2]\n\nYou have a list of integers representing the number of friends who appeared on each day. Your task is to find the maximum product of the counts for any sequence of consecutive days. If no such product is found, return 0.\n\nFor example, given the list [1, 2, 3, 4], the maximum product would be 6, which is the product of 2 and 3.\n\n[/Question 2]\n\n[Code 2]\n\ndef maxProduct(nums: List[int]) -> int:\n    if not nums:\n        return 0\n    max_product = 0\n    current_product = 1\n    for num in nums:\n        current_product *= num\n        max_product = max(max_product, current_product)\n        if num == 0:\n            current_product = 1\n    return max_product\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maxProduct([1, 2, 3, 4]) == 6\nassert maxProduct([2, 1, 0, 3, 4, 5]) == 60\nassert maxProduct([3, 0, 2, 5, 4, 6]) == 60\nassert maxProduct([1, 2, 3, 0, 4, 5, 0, 6]) == 12\nassert maxProduct([0, 0, 0, 0, 0]) == 0\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['combinatorics', 'subsets', 'count', 'dynamic programming', 'sequence']", "prompt_tokens": 521, "total_tokens": 811, "completion_tokens": 290, "completion": "[Question 2]\n\nGiven a positive real number x, find the count of all possible subsets of the cube roots of first N natural numbers, such that the sum of cube roots in each subset is less than or equal to x.\n\n[/Question 2]\n\n[Code 2]\n\ndef countSubsetsCubeRootsLessThanX(x: float, N: int) -> int:\n    cubes = [i**(1/3) for i in range(1, N+1)]\n    count = 0\n    for mask in range(1 << N):\n        subset_sum = 0\n        for j in range(N):\n            if (mask & (1 << j)):\n                subset_sum += cubes[j]\n        if subset_sum <= x:\n            count += 1\n    return count\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countSubsetsCubeRootsLessThanX(1.5, 3) == 6\nassert countSubsetsCubeRootsLessThanX(2.0, 4) == 15\nassert countSubsetsCubeRootsLessThanX(2.5, 5) == 31\nassert countSubsetsCubeRootsLessThanX(3.0, 6) == 56\nassert countSubsetsCubeRootsLessThanX(3.5, 7) == 98\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['count', 'sets', 'integers', 'consecutive', 'pairs', 'sequence', 'math', 'iteration']", "prompt_tokens": 493, "total_tokens": 711, "completion_tokens": 218, "completion": "[Question 2]\n\nGiven a sequence of integers and a target integer, write a program to count the number of pairs of consecutive integers in the sequence that add up to the target integer.\n\n[/Question 2]\n\n[Code 2]\n\ndef countConsecutivePairs(sequence, target):\n    count = 0\n    for i in range(len(sequence) - 1):\n        if sequence[i] + sequence[i + 1] == target:\n            count += 1\n    return count\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countConsecutivePairs([1, 2, 3, 4, 5], 5) == 0\nassert countConsecutivePairs([1, 2, 3, 4, 5], 3) == 2\nassert countConsecutivePairs([3, 1, 2, 4, 5], 6) == 1\nassert countConsecutivePairs([5, 7, 2, 4, 9], 11) == 2", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'arithmetic', 'sub-arrays', 'counting', 'loop', 'math']", "prompt_tokens": 638, "total_tokens": 947, "completion_tokens": 309, "completion": "[Question 2]\n\nGiven an array of integers, write a function to count the number of sub-arrays where the bitwise XOR of all elements in the sub-array is an arithmetic progression.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef countXorArithmeticSlices(A: List[int]) -> int:\n    count = 0\n    n = len(A)\n    for i in range(n):\n        xor_val = 0\n        for j in range(i, n):\n            xor_val ^= A[j]\n            diff = A[j] - A[i]\n            k = j + 1\n            while k < n and (A[k] - A[j]) == diff:\n                if xor_val == diff:\n                    count += 1\n                k += 1\n    return count\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countXorArithmeticSlices([3, 5, 4, 1, 7, 2, 5, 3, 4]) == 4\nassert countXorArithmeticSlices([1, 2, 3, 4, 5, 6]) == 9\nassert countXorArithmeticSlices([2, 4, 6, 8, 10]) == 8\nassert countXorArithmeticSlices([1, 3, 5, 7, 9]) == 5\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'triplets', 'XOR', 'elements', 'comparison', 'count']", "prompt_tokens": 599, "total_tokens": 915, "completion_tokens": 316, "completion": "[Question 2]\n\nYou are given an array of n distinct integers. A triplet (a[i], a[j], a[k]) is called an inversion triplet if there exist indices i < j < k such that a[i] > a[j] > a[k]. The task is to find the count of inversion triplets in the given array.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef countInversionTriplets(arr: List[int]) -> int:\n        n = len(arr)\n        inv_count = 0\n        for i in range(n - 2):\n            for j in range(i + 1, n - 1):\n                for k in range(j + 1, n):\n                    if arr[i] > arr[j] > arr[k]:\n                        inv_count += 1\n        return inv_count\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countInversionTriplets([5, 3, 2, 4, 1]) == 5\nassert countInversionTriplets([1, 2, 3, 4, 5]) == 0\nassert countInversionTriplets([5, 4, 3, 2, 1]) == 0\nassert countInversionTriplets([2, 4, 1, 3, 5]) == 2\nassert countInversionTriplets([3, 1, 4, 2, 5]) == 3\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'subarray', 'unique', 'count', 'integers', 'iteration']", "prompt_tokens": 539, "total_tokens": 968, "completion_tokens": 429, "completion": "[Question 2]\n\nYou are given a chessboard represented as an 8x8 array. Each cell of the chessboard contains a unique integer. Your task is to write a function to count the total number of unique integers in any given subarray of the chessboard.\n\n[/Question 2]\n\n[Code 2]\n\ndef countUniqueIntegersInSubarray(chessboard: List[List[int]], x1: int, y1: int, x2: int, y2: int) -> int:\n    unique_integers = set()\n    for i in range(x1, x2+1):\n        for j in range(y1, y2+1):\n            unique_integers.add(chessboard[i][j])\n    return len(unique_integers)\n\n[/Code 2]\n\n[Asserts 2]\n\nchessboard = [\n    [1, 2, 3, 4, 5, 6, 7, 8],\n    [9, 10, 11, 12, 13, 14, 15, 16],\n    [17, 18, 19, 20, 21, 22, 23, 24],\n    [25, 26, 27, 28, 29, 30, 31, 32],\n    [33, 34, 35, 36, 37, 38, 39, 40],\n    [41, 42, 43, 44, 45, 46, 47, 48],\n    [49, 50, 51, 52, 53, 54, 55, 56],\n    [57, 58, 59, 60, 61, 62, 63, 64]\n]\n\nassert countUniqueIntegersInSubarray(chessboard, 0, 0, 3, 3) == 16\nassert countUniqueIntegersInSubarray(chessboard, 2, 2, 5, 5) == 16", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['binary tree', 'root-to-leaf', 'Fibonacci numbers', 'connected', 'path']", "prompt_tokens": 641, "total_tokens": 981, "completion_tokens": 340, "completion": "[Question 2]\n\nYou are given a binary tree where each node contains a unique number. Determine if there exists a root-to-leaf path in the tree where the sum of the node values is a Fibonacci number and the path has equal elements.\n\n[/Question 2]\n\n[Code 2]\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\ndef isFibPathWithEqualElements(root: TreeNode) -> bool:\n    def fib(n):\n        a, b = 0, 1\n        while a < n:\n            yield a\n            a, b = b, a + b\n    \n    def dfs(node, path, fibs):\n        if not node:\n            return False\n        new_path = path + [node.val]\n        if sum(new_path) in fibs and len(set(new_path)) == 1:\n            return True\n        return dfs(node.left, new_path, fibs) or dfs(node.right, new_path, fibs)\n\n    return dfs(root, [], set(fib(max(1, root.val)+1)))\n\n[/Code 2]\n\n[Asserts 2]\n\ntree = TreeNode(1)\ntree.left = TreeNode(1)\ntree.right = TreeNode(2)\nassert isFibPathWithEqualElements(tree) == True\ntree2 = TreeNode(3)\ntree2.left = TreeNode(4)\ntree2.right = TreeNode(7)\ntree2.left.left = TreeNode(6)\ntree2.left.right = TreeNode(6)\nassert isFibPathWithEqualElements(tree2) == False\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['math', 'range', 'count', 'Fibonacci', 'absolute difference', 'sum of digits', 'even position', 'odd position']", "prompt_tokens": 657, "total_tokens": 962, "completion_tokens": 305, "completion": "[Question 2]\n\nWrite a program to calculate the sum of the digits at even positions in a given range of numeric values and determine if the count of such numbers is a Fibonacci number.\n\n[/Question 2]\n\n[Code 2]\n\ndef isFibonacci(n):\n    a, b = 0, 1\n    if n == 0:\n        return True\n    while b < n:\n        a, b = b, a + b\n    return b == n\n\ndef sumEvenPositionDigits(n):\n    evenSum = 0\n    digits = list(str(n))\n    for i in range(len(digits)):\n        if i % 2 != 0:\n            evenSum += int(digits[i])\n    return evenSum\n\ndef countSumEvenPositionFibonacciInRange(start, end):\n    count = 0\n    for i in range(start, end+1):\n        evenSum = sumEvenPositionDigits(i)\n        if isFibonacci(evenSum):\n            count += 1\n    return count\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countSumEvenPositionFibonacciInRange(10, 20) == 2\nassert countSumEvenPositionFibonacciInRange(50, 100) == 3\nassert countSumEvenPositionFibonacciInRange(1, 100) == 6\nassert countSumEvenPositionFibonacciInRange(100, 200) == 4\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['string', 'subsequence', 'arithmetic progression', 'indices', 'count']", "prompt_tokens": 661, "total_tokens": 943, "completion_tokens": 282, "completion": "[Question 2]\n\nWrite a Python function that takes a string as input and counts the number of subsequences in the string such that the cumulative sum of the direction cosines of the characters forms an arithmetic progression with a common difference of the fifth power of the separation of their indices.\n\nFor example, if the input string is \"abcd90efg\", the function should count how many subsequences of the string satisfy the given condition.\n\n[/Question 2]\n\n[Code 2]\n\ndef countArithmeticSubsequences(s: str) -> int:\n    n = len(s)\n    count = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            for k in range(j+1, n):\n                if ord(s[j]) - ord(s[i]) + ord(s[k]) - ord(s[j]) == (k - j)**5:\n                    count += 1\n    return count\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countArithmeticSubsequences(\"abcd90efg\") == 1\nassert countArithmeticSubsequences(\"abcdef\") == 0\nassert countArithmeticSubsequences(\"abcde\") == 0\nassert countArithmeticSubsequences(\"aabbbcccdddeee\") == 27\nassert countArithmeticSubsequences(\"abcdefghijk\") == 0\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['integer', 'divisible', 'counting', 'digits', 'range']", "prompt_tokens": 559, "total_tokens": 865, "completion_tokens": 306, "completion": "[Question 2]\n\nGiven a range of integers from L to R (both inclusive), the task is to find the count of integers within the range which are divisible by a given integer K. Additionally, introduce a minimal cost shuffle to the list of these integers in such a way that the digits of each integer are in non-decreasing order. Return the count of such shuffled integers.\n\n[/Question 2]\n\n[Code 2]\n\ndef countDivisibleIntegersWithNonDecreasingDigits(L: int, R: int, K: int) -> int:\n    count = 0\n    for num in range(L, R+1):\n        if num % K == 0:\n            num_str = str(num)\n            if ''.join(sorted(num_str)) == num_str:\n                count += 1\n    return count\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countDivisibleIntegersWithNonDecreasingDigits(10, 50, 5) == 4\nassert countDivisibleIntegersWithNonDecreasingDigits(100, 200, 7) == 6\nassert countDivisibleIntegersWithNonDecreasingDigits(500, 1000, 3) == 48\nassert countDivisibleIntegersWithNonDecreasingDigits(1, 100, 11) == 0\nassert countDivisibleIntegersWithNonDecreasingDigits(200, 300, 2) == 20\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['graph', 'directed', 'weighted', 'shortest path', 'vertices', 'edges', 'source', 'destination', 'algorithm', 'Dijkstra', 'Floyd-Warshall']", "prompt_tokens": 780, "total_tokens": 1139, "completion_tokens": 359, "completion": "[Question 2]\n\nWrite a program to find the shortest path in a directed and weighted graph from a source vertex to a destination vertex using Dijkstra's algorithm.\n\n[/Question 2]\n\n[Code 2]\n\nimport heapq\nimport sys\n\nclass Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = [[] for _ in range(self.V)]\n\n    def addEdge(self, u, v, w):\n        self.graph[u].append((v, w))\n\n    def dijkstra(self, src, dest):\n        pq = [(0, src)]\n        distance = [sys.maxsize] * self.V\n        distance[src] = 0\n\n        while pq:\n            dist, u = heapq.heappop(pq)\n            if u == dest:\n                return distance[dest]\n            if dist > distance[u]:\n                continue\n            for v, w in self.graph[u]:\n                if distance[u] + w < distance[v]:\n                    distance[v] = distance[u] + w\n                    heapq.heappush(pq, (distance[v], v))\n        return distance[dest]\n\n[/Code 2]\n\n[Asserts 2]\n\ng = Graph(6)\ng.addEdge(0, 1, 5)\ng.addEdge(0, 2, 1)\ng.addEdge(1, 3, 3)\ng.addEdge(1, 4, 8)\ng.addEdge(2, 3, 2)\ng.addEdge(3, 5, 7)\ng.addEdge(4, 5, 2)\nassert g.dijkstra(0, 5) == 8\nassert g.dijkstra(2, 3) == 2\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['graph', 'positive', 'edge', 'weight', 'path', 'smallest', 'product', 'product of edges']", "prompt_tokens": 600, "total_tokens": 963, "completion_tokens": 363, "completion": "[Question 2]\n\nGiven a weighted graph G and a set of range queries, where each query specifies a range of weights, we are to find the smallest positive variance of weights for all the possible right-angled triangles formed by row swaps of the edges' weights within the specified range.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List, Tuple\n\ndef smallestVariance(edges: List[Tuple[int, int, int]], queries: List[Tuple[int, int]]) -> float:\n    # Your code to calculate the smallest positive variance\n\n[/Code 2]\n\n[Asserts 2]\n\nassert smallestVariance([(1, 2, 3), (2, 3, 4), (3, 4, 5)], [(1, 5)]) == 0.6666666666666666\nassert smallestVariance([(1, 2, 10), (2, 3, 20), (3, 4, 30)], [(5, 30)]) == 66.66666666666667\nassert smallestVariance([(1, 2, 1), (2, 3, 1), (3, 4, 1)], [(1, 10)]) == 0.0\nassert smallestVariance([(1, 2, 2), (2, 3, 3), (3, 4, 4)], [(1, 5)]) == 0.6666666666666666\nassert smallestVariance([(1, 2, 10), (2, 3, 5), (3, 4, 2)], [(2, 20)]) == 4.333333333333333\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['2D array', 'integer', 'sub-matrix', 'maximum', 'size', 'sum', 'binary search']", "prompt_tokens": 853, "total_tokens": 1399, "completion_tokens": 546, "completion": "[Question 2]\n\nGiven a two-dimensional array of integers representing the drinking capacities of different bottles, the task is to find the size of the maximum square sub-matrix such that the sum of elements in the sub-matrix is divisible by a given integer and return the second smallest such sum. If no such sub-matrix exists, return -1.\n\n[/Question 2]\n\n[Code 2]\n\ndef maxDivisibleSumSubmatrix(matrix: List[List[int]], n: int, k: int) -> int:\n    def check(matrix, mid, n, k, x, y):\n        sumMatrix = [[0 for i in range(n+1)] for j in range(n+1)]\n        for i in range(1,n+1):\n            for j in range(1,n+1):\n                sumMatrix[i][j] = matrix[i-1][j-1]+sumMatrix[i-1][j]+sumMatrix[i][j-1]-sumMatrix[i-1][j-1]\n        for i in range(n-x+1):\n            for j in range(n-y+1):\n                subMatrixSum = sumMatrix[i+x][j+y]-sumMatrix[i][j+y]-sumMatrix[i+x][j]+sumMatrix[i][j]\n                if subMatrixSum%k == mid:\n                    return True\n        return False\n    l = 0\n    r = int(1e9)\n    ans = -1\n    while l <= r:\n        mid = (l+r)//2\n        found = False\n        for i in range(n):\n            for j in range(n):\n                if i+1 >= x and j+1 >= y:\n                    if check(matrix, mid, n, k, x, y):\n                        found = True\n        if found:\n            ans = mid\n            l = mid+1\n        else:\n            r = mid-1\n    return ans\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maxDivisibleSumSubmatrix([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 3, 3) == -1\nassert maxDivisibleSumSubmatrix([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 3, 5) == 3\nassert maxDivisibleSumSubmatrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3, 6) == 16\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['math', 'sum', 'iteration', 'combinations', 'digits', 'integers']", "prompt_tokens": 608, "total_tokens": 877, "completion_tokens": 269, "completion": "[Question 2]\n\nFor a given positive integer n, we define a nude number as a positive integer with the property that the sum of its digits, when written in binary, is equal to its sum when written in decimal. For example, the number 25 is a nude number since the sum of its digits in binary is 2 (11001) and the sum of its digits in decimal is also 7 (2+5).\n\nWrite a function to find the minimal nude number greater than or equal to a given integer n.\n\n[/Question 2]\n\n[Code 2]\n\ndef isNudeNumber(num: int) -> bool:\n    decimal_sum = sum(map(int, str(num)))\n    binary_sum = sum(map(int, bin(num)[2:]))\n    return decimal_sum == binary_sum\n\ndef nextNudeNumber(n: int) -> int:\n    while True:\n        if isNudeNumber(n):\n            return n\n        n += 1\n\n[/Code 2]\n\n[Asserts 2]\n\nassert nextNudeNumber(10) == 13\nassert nextNudeNumber(25) == 25\nassert nextNudeNumber(32) == 35\nassert nextNudeNumber(100) == 104\nassert nextNudeNumber(1234) == 1345", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'max value', 'operation', 'negative', 'multiply', 'index', 'sum']", "prompt_tokens": 590, "total_tokens": 943, "completion_tokens": 353, "completion": "[Question 2]\n\nYou are given an array A of size N. Write a function to find the maximum sum of a subarray after performing a single operation. The operation is to multiply any element of the array by -1.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef maxSumAfterOperation(arr: List[int]) -> int:\n    n = len(arr)\n    max_sum = float('-inf')\n    for i in range(n):\n        curr_sum = arr[i]\n        max_so_far = arr[i]\n        for j in range(i+1, n):\n            curr_sum = max(arr[j], curr_sum + arr[j])\n            max_so_far = max(max_so_far, curr_sum)\n        max_sum = max(max_sum, max_so_far)\n        \n        for j in range(i+1, n):\n            max_sum = max(max_sum, max_so_far - arr[j] + (-1 * arr[j]))\n    return max_sum\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maxSumAfterOperation([1, -2, 3, 4, -5, -6, 7, -8, 9])==50\nassert maxSumAfterOperation([-1, -2, -3, -4, -5, -6, -7, -8, -9])==45\nassert maxSumAfterOperation([1, 2, 3, 4, 5, 6, 7, 8, 9])==45\nassert maxSumAfterOperation([-1, 2, -3, 4, -5, 6, -7, 8, -9])==48\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['game', 'coins', 'maximum', 'dynamic programming', 'array', 'strategy', 'pick', 'values']", "prompt_tokens": 733, "total_tokens": 1040, "completion_tokens": 307, "completion": "[Question 2]\n\nYou are given an array representing the values of subjects in a game. The goal is to pick the largest value from the array by following a specific strategy. You can only reduce the value of a subject by picking a coin from it. You need to find the maximum value that can be obtained by picking coins from the subjects and following the reduction strategy. Write a function to calculate the largest value that can be achieved by picking coins and reducing the subjects' values using dynamic programming.\n\n[/Question 2]\n\n[Code 2]\n\ndef maxLargestValue(arr):\n    n = len(arr)\n    dp = [0] * (n+1)\n\n    for i in range(1, n+1):\n        ans = 0\n        for j in range(1, i+1):\n            ans = max(ans, arr[j-1] + dp[i-j])\n        dp[i] = ans\n\n    return dp[n]\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maxLargestValue([3, 1, 5, 8])==10\nassert maxLargestValue([2, 8, 6, 3, 7])==14\nassert maxLargestValue([5, 3, 9, 2, 7, 8])==15\nassert maxLargestValue([7, 2, 2, 9, 4, 8, 1, 5])==22\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'positive integers', 'subsequence', 'absolute difference', 'length', 'dict', 'max', 'min']", "prompt_tokens": 652, "total_tokens": 999, "completion_tokens": 347, "completion": "[Question 2]\n\nYou are given an array of positive integers and a target sum. Your task is to find the maximum length of a subsequence in the given array such that the absolute difference between the maximum and minimum elements of the subsequence is less than or equal to the target sum.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef maxLengthSubsequence(arr: List[int], target_sum: int) -> int:\n    n = len(arr)\n    dict = {}\n    max_length = 0\n    for ele in arr:\n        if ele in dict:\n            dict[ele] += 1\n        else:\n            dict[ele] = 1\n    for ele in arr:\n        if ele+target_sum in dict or ele-target_sum in dict:\n            max_length = max(max_length, dict[ele] + dict.get(ele+target_sum,0) + dict.get(ele-target_sum,0))\n    return max_length\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maxLengthSubsequence([1, 5, 3, 15, 10, 8], 2)==5\nassert maxLengthSubsequence([8, 9, 4, 11, 7, 13], 3)==6\nassert maxLengthSubsequence([3, 7, 2, 9, 1], 4)==5\nassert maxLengthSubsequence([2, 5, 1, 3, 7, 9], 3)==4\nassert maxLengthSubsequence([1, 8, 1, 13, 20, 6], 7)==6\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'maximum', 'sum', 'operation', 'distinct', 'indices', 'increment']", "prompt_tokens": 570, "total_tokens": 819, "completion_tokens": 249, "completion": "[Question 2]\n\nGiven an array of distinct integers, the task is to find the maximum sum of elements such that no two elements are consecutive in the array. Perform an operation to increment the values and then compute the maximum sum. \n\n[/Question 2]\n\n[Code 2]\n\ndef maxSumNoConsecutive(arr):\n    incl = 0\n    excl = 0\n    for i in arr:\n        new_excl = max(incl, excl)\n        incl = excl + i\n        excl = new_excl\n    return max(incl, excl)\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maxSumNoConsecutive([5, 3, 9, 7, 2]) == 16\nassert maxSumNoConsecutive([1, 2, 3, 4, 5, 6, 7, 8, 9]) == 25\nassert maxSumNoConsecutive([5, 5, 10, 40, 50, 35]) == 80\nassert maxSumNoConsecutive([3, 2, 5, 10, 7]) == 15\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['stairs', 'climbing', 'steps', 'distinct', 'ways', 'reach']", "prompt_tokens": 497, "total_tokens": 858, "completion_tokens": 361, "completion": "[Question 2]\n\nYou are given a binary tree where each node contains an integer value (0 or 1). You need to write a function to count the number of distinct ways to reach a leaf node after removing some nodes. You can remove any node in the tree that satisfies the condition that after removal, the remaining tree is a fair coin tree. A fair coin tree is defined as a tree where for each node, the number of 1's in the left subtree is equal to the number of 0's in the right subtree, and the number of 0's in the left subtree is equal to the number of 1's in the right subtree. The function should return the count of distinct ways to reach a leaf node under this condition.\n\n[/Question 2]\n\n[Code 2]\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef countWaysToLeaf(root: TreeNode) -> int:\n    # TODO: Implement the function to count the number of distinct ways to reach a leaf node\n    pass\n\n[/Code 2]\n\n[Asserts 2]\n\n# Example tree\n#        1\n#       / \\\n#      0   1\n#     / \\\n#    1   0\n\nroot = TreeNode(1, TreeNode(0, TreeNode(1), TreeNode(0)), TreeNode(1))\nassert countWaysToLeaf(root) == 2  # There are 2 distinct ways to reach the leaf nodes (1->0->1 and 1->0->0)\n\n# Add more test cases based on the tree structure and expected results\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['integer', 'array', 'coins', 'range', 'minimum']", "prompt_tokens": 514, "total_tokens": 755, "completion_tokens": 241, "completion": "[Question 2]\n\nYou are given an array representing the prices of items in a restaurant. The task is to find the minimum number of coins required to pay any bill within a given range of prices.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef minCoinsForRange(prices: List[int], start: int, end: int) -> int:\n    max_price = max(prices[start:end+1])\n    return max_price\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minCoinsForRange([5, 2, 3, 7, 8, 2, 5], 2, 5) == 8\nassert minCoinsForRange([10, 20, 30, 40, 50], 0, 2) == 30\nassert minCoinsForRange([1, 1, 1, 1, 1], 1, 4) == 1\nassert minCoinsForRange([5, 10, 15, 20, 25, 30], 2, 4) == 20\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['number', 'set bits', 'count', 'inclusive', 'binary', 'bit manipulation']", "prompt_tokens": 527, "total_tokens": 801, "completion_tokens": 274, "completion": "[Question 2]\n\nYou are given a list of end times for various activities in a day, represented in binary. The task is to count the number of activities ending at each time, and then return these counts as a list of value-added counts for each time slot.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\ndef countActivities(endTimes: List[str]) -> List[int]:\n    maxTime = max(int(time, 2) for time in endTimes)\n    counts = [0]*(maxTime+1)\n    for time in endTimes:\n        counts[int(time,2)] += 1\n    valueAddedCounts = [0]*(maxTime+1)\n    for i in range(len(counts)-1):\n        valueAddedCounts[i+1] = valueAddedCounts[i] + counts[i]\n    return valueAddedCounts\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countActivities([\"101\", \"110\", \"011\", \"101\"]) == [0, 1, 2, 4, 4, 5, 5, 5]\nassert countActivities([\"111\", \"110\", \"011\", \"101\", \"001\"]) == [0, 1, 2, 3, 4, 5, 5, 5, 5]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['permutation', 'arrangement', 'combinatorics', 'factorial', 'math']", "prompt_tokens": 438, "total_tokens": 702, "completion_tokens": 264, "completion": "[Question 2]\n\nYou are given an array of N elements and a range [L, R]. Your task is to find the number of permutations of elements within this range such that for each element at position i, arr[i] > arr[i-1].\n\n[/Question 2]\n\n[Code 2]\n\ndef countPermutationsWithRange(arr, L, R):\n    def factorial(n):\n        if n==0 or n==1:\n            return 1\n        else:\n            return n * factorial(n-1)\n    \n    def countArrangements(N):\n        if N == 1:\n            return 1\n        else:\n            return N * countArrangements(N-1)\n    \n    count = 0\n    for i in range(L, R+1):\n        if arr[i] > arr[i-1]:\n            count += 1\n    \n    return factorial(count)\n\n[/Code 2]\n\n[Asserts 2]\n\narr1 = [1, 2, 3, 4, 5]\nassert countPermutationsWithRange(arr1, 1, 3) == 6\n\narr2 = [3, 2, 1, 4]\nassert countPermutationsWithRange(arr2, 0, 2) == 2", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['grid', '2D', 'paths', 'probability', 'options', 'reach', 'start', 'finish', 'cell', 'update', 'table']", "prompt_tokens": 663, "total_tokens": 1119, "completion_tokens": 456, "completion": "[Question 2]\n\nYou are given a grid of size m x n and placed at the top-left cell (start at cell (0, 0)). You have the option to move either right or down at each step with equal probability. You want to find the probability that after t moves, you will still be within the visibility of the bottom-right cell (finish at cell(m-1, n-1)). In this context, \"visibility\" refers to the ability to reach the finish cell with orders of \"consecutive heads\" without leaving the grid. You need to update the probabilities at each cell in the 2D grid after t moves.\n\nWrite a function to calculate the probability of staying within the visibility of the finish cell after t moves.\n\n[/Question 2]\n\n[Code 2]\n\ndef probabilityOfVisibility(m: int, n: int, t: int) -> float:\n\t# create a 2D list of size m x n and initialize with all 0's\n\tprobs = [[0.0 for _ in range(n)] for _ in range(m)]\n\tprobs[0][0] = 1.0\n\n\t# update the probabilities after t moves\n\tfor _ in range(t):\n\t\tnewProbs = [[0.0 for _ in range(n)] for _ in range(m)]\n\t\tfor i in range(m):\n\t\t\tfor j in range(n):\n\t\t\t\tif i+1 < m:\n\t\t\t\t\tnewProbs[i+1][j] += 0.5 * probs[i][j]\n\t\t\t\tif j+1 < n:\n\t\t\t\t\tnewProbs[i][j+1] += 0.5 * probs[i][j]\n\t\tprobs = newProbs\n\n\treturn probs[m-1][n-1]\n\n[/Code 2]\n\n[Asserts 2]\n\nassert probabilityOfVisibility(2, 2, 2) == 0.5\nassert probabilityOfVisibility(3, 3, 3) == 0.5\nassert probabilityOfVisibility(2, 3, 1) == 0.5\nassert probabilityOfVisibility(3, 2, 1) == 0.5\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'integer', 'segment', 'bitwise', 'partition', 'maximize', 'sum', 'maximum', 'value']", "prompt_tokens": 623, "total_tokens": 940, "completion_tokens": 317, "completion": "[Question 2]\n\nYou are given an array containing both empty spaces and integer items. To maximize the sum of the resultant list of integers obtained by multiplying each empty space by the imaginary unit and then using an iterative method to fill the empty spaces such that the maximum value is obtained. Write a function to achieve this.\n\n[/Question 2]\n\n[Code 2]\n\ndef maximizeSumWithImaginaryUnit(arr):\n    maxSum = 0\n    for i in range(len(arr)):\n        if arr[i] == ' ':\n            arr[i] = 1j  # Place imaginary unit at empty space\n    while ' ' in arr:\n        for i in range(0, len(arr) - 1):\n            if arr[i] == ' ':\n                arr[i] = arr[i - 1] + arr[i + 1]  # Iterative method to fill empty space\n        arr.pop(arr.index(' '))  # Remove empty space from array\n    maxSum = sum(arr)  # calculate the sum\n    return maxSum.real  # Return the real part\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maximizeSumWithImaginaryUnit([1, ' ', 3, 4, ' ', 6])==14\nassert maximizeSumWithImaginaryUnit([' ', 2, ' ', 4, 6, ' '])==12\nassert maximizeSumWithImaginaryUnit([2, ' ', 3, ' ', 5])==10\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'subset', 'sum', 'integer', 'dynamic programming', 'bit manipulation', 'iteration', 'maximization']", "prompt_tokens": 663, "total_tokens": 1055, "completion_tokens": 392, "completion": "[Question 2]\n\nGiven a square matrix representing an upper triangular matrix, where all the elements below the main diagonal are 0, the task is to find the maximum sum of a subset of the matrix elements. The subset can only include elements from the main diagonal and the elements above it.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\ndef maxSumUpperTriangular(matrix: List[List[int]]) -> int:\n    n = len(matrix)\n    dp = [-1] * (1 << n)\n    dp[0] = 0\n    for mask in range(1 << n):\n        for i in range(n):\n            if (mask >> i) & 1:\n                continue\n            best = -1\n            for j in range(n):\n                if (mask >> j) & 1 and matrix[i][j] != 0:\n                    best = max(best, matrix[i][j])\n            if best != -1:\n                if dp[mask | (1 << i)] < dp[mask] + best:\n                    dp[mask | (1 << i)] = dp[mask] + best\n    return dp[(1 << n) - 1]\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maxSumUpperTriangular([[1, 2, 3], [0, 4, 5], [0, 0, 6]]) == 12\nassert maxSumUpperTriangular([[1, 2, 3, 4], [0, 5, 6, 7], [0, 0, 8, 9], [0, 0, 0, 10]]) == 34\nassert maxSumUpperTriangular([[1, 0, 0], [0, 2, 0], [0, 0, 3]]) == 6\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'minimize', 'absolute difference', 'elements', 'choose', 'sort', 'bisect', 'left']", "prompt_tokens": 825, "total_tokens": 1174, "completion_tokens": 349, "completion": "[Question 2]\n\nGiven an array of numbers, the task is to minimize the absolute difference between two elements of the array and choose those two elements. Additionally, find a pair of numbers from the array that are closest to being parallel lines when plotted on a graph.\n\n[/Question 2]\n\n[Code 2]\n\ndef minimizeAbsoluteDifference(arr):\n    arr.sort()\n    min_diff = float('inf')\n    result = []\n\n    for i in range(len(arr) - 1):\n        diff = abs(arr[i] - arr[i+1])\n        if diff < min_diff:\n            min_diff = diff\n            result = [arr[i], arr[i+1]]\n\n    return result\n\ndef findParallelLines(arr):\n    arr.sort()\n    min_slope = float('inf')\n    result = []\n\n    for i in range(len(arr) - 1):\n        slope = abs((arr[i+1] - arr[i]) / 1)  # Calculate slope between points\n        if slope < min_slope:\n            min_slope = slope\n            result = [arr[i], arr[i+1]]\n\n    return result\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minimizeAbsoluteDifference([1, 4, 7, 9, 12]) == [4, 7]\nassert minimizeAbsoluteDifference([5, 3, 9, 15, 18]) == [3, 5]\nassert findParallelLines([1, 2, 4, 8, 16]) == [1, 2]\nassert findParallelLines([3, 6, 10, 15, 22]) == [15, 22]\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['matrix', 'path', 'maximum', 'sum', 'series', 'row indices', 'sorting']", "prompt_tokens": 679, "total_tokens": 1158, "completion_tokens": 479, "completion": "[Question 2]\n\nGiven a matrix of size n * m, find the row index that corresponds to the least frequent element in the series formed by traversing the matrix in a given path. Then, find the maximum sum of elements in that least frequent row.\n\n[/Question 2]\n\n[Code 2]\n\ndef leastFrequentMaxSum(matrix, path):\n    n = len(matrix)\n    m = len(matrix[0])\n    \n    elements = [matrix[path[i]][j] for i in range(n) for j in range(m)]\n    element_freq = {}\n    for ele in elements:\n        if ele in element_freq:\n            element_freq[ele] += 1\n        else:\n            element_freq[ele] = 1\n    \n    least_frequent = min(element_freq, key=element_freq.get)\n    \n    least_frequent_row_indices = [i for i in range(n) if matrix[i].count(least_frequent) > 0]\n    \n    least_frequent_row_sums = [sum(matrix[i]) for i in least_frequent_row_indices]\n    \n    return max(least_frequent_row_sums)\n\n[/Code 2]\n\n[Asserts 2]\n\nassert leastFrequentMaxSum([[1, 2, 3], [4, 5, 6], [7, 8, 9]], [0, 1, 2])==24\nassert leastFrequentMaxSum([[1, 2, 2], [3, 4, 3], [5, 6, 8]], [0, 2, 1])==21\nassert leastFrequentMaxSum([[1, 1, 1, 1], [2, 2, 2, 2], [3, 3, 3, 3]], [0, 1, 2])==6\nassert leastFrequentMaxSum([[-1, -2, -3], [-4, -5, -6], [-7, -8, -9]], [0, 1, 2])==0\nassert leastFrequentMaxSum([[-1, 0, -1], [4, -5, 6], [-7, 8, -9]], [0, 2, 1])==7\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['collaboration', 'students', 'topics', 'maximum', 'prepare']", "prompt_tokens": 987, "total_tokens": 1358, "completion_tokens": 371, "completion": "[Question 2]\n\nYou are teaching a group of students to form blocks using 2x1 domino tiles. Each domino tile can cover 2 squares of a grid. The students need to prepare a maximum volume of blocks by forming them in collaboration.\n\nWrite a function `maxVolumeOfBlocks` to solve the problem. The function should take the following inputs:\n```\nmaxVolumeOfBlocks(M: int, N: int) -> int\n```\nWhere:\n- M : The length of the grid (rows)\n- N : The width of the grid (columns)\n\nThe function should return an integer representing the maximum volume of blocks that can be formed.\n\nNote:\n- The grid can have a combination of 2x1 blocks and empty squares.\n- Each 2x1 block occupies 1 volume unit.\n\nFor example, if the input is given as:\n```\nmaxVolumeOfBlocks(3, 3)\n```\nthen the output will be `4`, as the maximum number of blocks that can be formed is 4 in a 3x3 grid.\n\n[/Question 2]\n\n[Code 2]\n\ndef maxVolumeOfBlocks(M: int, N: int) -> int:\n    return (M * N) // 2\n\n# Example Usage \nprint(maxVolumeOfBlocks(3, 3))  # Output: 4\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maxVolumeOfBlocks(3, 3) == 4\nassert maxVolumeOfBlocks(2, 5) == 5\nassert maxVolumeOfBlocks(4, 4) == 8\nassert maxVolumeOfBlocks(5, 2) == 5\nassert maxVolumeOfBlocks(6, 6) == 18\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'non-negative', 'integers', 'jump', 'minimum', 'last index', 'reach', 'max distance', 'jumps']", "prompt_tokens": 649, "total_tokens": 1023, "completion_tokens": 374, "completion": "[Question 2]\n\nYou are given an array of non-negative integers and a special operation \"turn\". The \"turn\" operation modifies the array by reversing the order of the elements between the given indices. You need to perform a minimum number of turns such that you can reach the last index of the array. Return the minimum number of turns or -1 if it's not possible to reach the last index.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef minTurnsToReachLastIndex(nums: List[int]) -> int:\n    n = len(nums)\n    if n <= 1:\n        return 0\n    target = n - 1\n    turns = 0\n    while target > 0:\n        found = False\n        for i in range(target):\n            if i + nums[i] >= target:\n                target = i\n                turns += 1\n                found = True\n                break\n        if not found:\n            return -1\n    return turns\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minTurnsToReachLastIndex([2, 3, 1, 1, 4])==2\nassert minTurnsToReachLastIndex([2, 3, 0, 1, 4])==1\nassert minTurnsToReachLastIndex([2, 3, 0, 1, 4, 1])==1\nassert minTurnsToReachLastIndex([3, 1, 1, 1, 1])==4\nassert minTurnsToReachLastIndex([3, 1, 1, 1, 1, 0])==3\nassert minTurnsToReachLastIndex([1, 2, 3])==2\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['math', 'recursion', 'dynamic-programming', 'minimum', 'sum']", "prompt_tokens": 447, "total_tokens": 707, "completion_tokens": 260, "completion": "[Question 2]\n\nWrite a program to find the minimum number of coins required to make the given sum using a given set of coin denominations.\n\n[/Question 2]\n\n[Code 2]\n\ndef minCoins(coins, m, V):\n\tif (V == 0):\n\t\treturn 0\n\tres = float('inf')\n\tfor i in range(0, m):\n\t\tif (coins[i] <= V):\n\t\t\tsub_res = minCoins(coins, m, V-coins[i])\n\t\t\tif (sub_res != float('inf') and sub_res + 1 < res):\n\t\t\t\tres = sub_res + 1\n\treturn res\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minCoins([1, 2, 5], 3, 11) == 3\nassert minCoins([1, 2, 5], 3, 7) == 2\nassert minCoins([1, 2, 5], 3, 8) == 2\nassert minCoins([1, 2, 5], 3, 27) == 5\nassert minCoins([1, 2, 5], 3, 13) == 3\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['subarray', 'max', 'sum', 'invert', 'elements', 'integer', 'array', 'negative', 'positive']", "prompt_tokens": 725, "total_tokens": 988, "completion_tokens": 263, "completion": "[Question 2]\n\nGiven an array of integers, write a function to find the maximum sum of a subarray after at most K inverse moves.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\ndef maxSumAfterKInvertMoves(A: List[int], K: int) -> int:\n    n = len(A)\n    j = 0\n    for i in range(n):\n        if A[i] < 0:\n            j += 1\n    for i in range(K):\n        if j == n:\n            break\n        A[j] = -A[j]\n        j += 1\n    return sum(A)\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maxSumAfterKInvertMoves([4, 2, 3], 1) == 9\nassert maxSumAfterKInvertMoves([3, -1, 0, 2], 3) == 6\nassert maxSumAfterKInvertMoves([2, -3, -1, 5, -4], 2) == 12\nassert maxSumAfterKInvertMoves([-2, -3, -1, 5, -4], 2) == 14\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['binary', 'cost', 'powers of 2', 'math', 'computation']", "prompt_tokens": 478, "total_tokens": 805, "completion_tokens": 327, "completion": "[Question 2]\n\nYou are given a list of N cuboids. Each cuboid is represented by its length, width, and height. The task is to find the sum of the interior angles of all the cuboids and then determine whether the sum of the interior angles obtained is a power of 2 or not.\n\n[/Question 2]\n\n[Code 2]\n\ndef sumInteriorAnglesOfCuboids(cuboids):\n    total_angle = 0\n    for cuboid in cuboids:\n        l, w, h = cuboid\n        interior_angle = 2 * (l * w + w * h + h * l)\n        total_angle += interior_angle\n    return total_angle\n\ndef isPowerOf2(num):\n    return (num & (num - 1)) == 0 and num != 0\n\n[/Code 2]\n\n[Asserts 2]\n\ncuboids1 = [(1, 1, 1), (2, 2, 2), (3, 3, 3)]\nassert sumInteriorAnglesOfCuboids(cuboids1) == 216\nassert isPowerOf2(sumInteriorAnglesOfCuboids(cuboids1)) == True\n\ncuboids2 = [(2, 3, 4), (5, 6, 7), (8, 9, 10)]\nassert sumInteriorAnglesOfCuboids(cuboids2) == 1800\nassert isPowerOf2(sumInteriorAnglesOfCuboids(cuboids2)) == False\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['integer', 'divisible', 'sum', 'array', 'count']", "prompt_tokens": 517, "total_tokens": 960, "completion_tokens": 443, "completion": "[Question 2]\n\nYou are given an array of integers. The task is to find the count of pairs in the array such that the sum of the pair is divisible by a given integer k.\n\nWrite a function that takes an array of integers and an integer k as input and returns the count of such pairs.\n\n[/Question 2]\n\n[Code 2]\n\nfrom collections import defaultdict\n\ndef countPairsWithSumDivisibleByK(arr: List[int], k: int) -> int:\n    remainderMap = defaultdict(int)\n    for num in arr:\n        remainderMap[num % k] += 1\n    \n    count = remainderMap[0] * (remainderMap[0] - 1) // 2  # Count pairs with remainder 0\n    for i in range(1, k//2 + 1):\n        if i != k - i:\n            count += remainderMap[i] * remainderMap[k - i]\n    if k % 2 == 0:\n        count += remainderMap[k // 2] * (remainderMap[k // 2] - 1) // 2  # Count pairs with remainder k/2\n    return count\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countPairsWithSumDivisibleByK([1, 2, 3, 4, 5], 3) == 4\nassert countPairsWithSumDivisibleByK([4, 5, 15, 8, 9, 2, 12, 66], 7) == 2\nassert countPairsWithSumDivisibleByK([4, 5, 0, 8, 9, 2, 12, 6], 6) == 9\nassert countPairsWithSumDivisibleByK([5, 9, 36, 74, 52, 31, 79, 26, 11], 7) == 9\nassert countPairsWithSumDivisibleByK([3, 7, 2, 9, 4], 5) == 4\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['dynamic programming', 'combinatorics', 'modular arithmetic', 'counting', 'coloring', 'ways']", "prompt_tokens": 699, "total_tokens": 992, "completion_tokens": 293, "completion": "[Question 2]\n\nYou are given a set of N Fibonacci nodes, where each node can be colored with either red or blue. The condition is that no two adjacent nodes should have the same color. Your task is to find the number of ways to color the Fibonacci nodes satisfying the given condition.\n\nFor Example, for N = 3, the output should be 5. \n  - Color the nodes as R B R -> 1 way\n  - Color the nodes as R B B -> 1 way\n  - Color the nodes as B R B -> 1 way\n  - Color the nodes as B R B -> 1 way\n  - Color the nodes as B R B -> 1 way\n\n[/Question 2]\n\n[Code 2]\n\ndef colorFibonacciNodes(N: int) -> int:\n    if N <= 0:\n        return 0\n    if N == 1:\n        return 2\n    a, b = 1, 1\n    for _ in range(2, N):\n        a, b = b, a+b\n    return 2 * b\n\n[/Code 2]\n\n[Asserts 2]\n\nassert colorFibonacciNodes(3)==5\nassert colorFibonacciNodes(5)==21\nassert colorFibonacciNodes(1)==2\nassert colorFibonacciNodes(10)==144\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'integer', 'XOR', 'subset', 'ordered', 'value', 'counting']", "prompt_tokens": 548, "total_tokens": 844, "completion_tokens": 296, "completion": "[Question 2]\n\nGiven an array of integers, we want to find all the quadruples (a, b, c, d) such that they form a subset of the array and the XOR of the quadruples is zero. Return the count of such quadruples.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef countXorQuadruples(arr: List[int]) -> int:\n    count = 0\n    n = len(arr)\n    for i in range(n-3):\n        for j in range(i+1, n-2):\n            for k in range(j+1, n-1):\n                for l in range(k+1, n):\n                    if arr[i]^arr[j]^arr[k]^arr[l] == 0:\n                        count += 1\n    return count\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countXorQuadruples([3, 4, 2, 7, 3, 3])==3\nassert countXorQuadruples([1, 2, 3, 4, 5])==0\nassert countXorQuadruples([1, 2, 3, 1, 2, 3, 1, 2, 3])==21\nassert countXorQuadruples([5, 5, 7, 7])==16\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['integer', 'division', 'parts', 'divisible', 'maximum', 'counting']", "prompt_tokens": 482, "total_tokens": 886, "completion_tokens": 404, "completion": "[Question 2]\n\nGiven a non-empty integer matrix representing a grid of 0's and 1's, where a 1 represents land and 0 represents water, the task is to find the maximum number of parts that can be formed when all the islands (connected 1's) are divided.\n\n[/Question 2]\n\n[Code 2]\n\ndef maxParts(grid: List[List[int]]) -> int:\n    def dfs(row, col, grid):\n        if row < 0 or row >= len(grid) or col < 0 or col >= len(grid[0]) or grid[row][col] != 1:\n            return\n        grid[row][col] = -1\n        dfs(row+1, col, grid)\n        dfs(row-1, col, grid)\n        dfs(row, col+1, grid)\n        dfs(row, col-1, grid)\n\n    parts = 0\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                dfs(i, j, grid)\n                parts += 1\n    return parts\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maxParts([[1, 1, 0, 0, 0],\n                 [1, 1, 0, 0, 0],\n                 [0, 0, 1, 0, 0],\n                 [0, 0, 0, 1, 1]]) == 3\n\nassert maxParts([[1, 1, 0, 0, 0],\n                 [0, 0, 1, 1, 1],\n                 [0, 0, 0, 1, 1]]) == 2\n\nassert maxParts([[1, 1, 1],\n                 [0, 0, 0],\n                 [1, 1, 1]]) == 2", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['range', 'integer', 'counting', 'digit', 'occurs', 'inclusive', 'while loop']", "prompt_tokens": 581, "total_tokens": 879, "completion_tokens": 298, "completion": "[Question 2]\n\nGiven a list of integers, find the initial position of the first occurrence of an odd digit. If no odd digit occurs, return -1.\n\n[/Question 2]\n\n[Code 2]\n\ndef initialPositionOfOddDigit(arr):\n\tfor i in range(len(arr)):\n\t\tnum = arr[i]\n\t\twhile(num != 0):\n\t\t\tif num % 2 != 0:\n\t\t\t\treturn i\n\t\t\tnum //= 10\n\treturn -1\n\n[/Code 2]\n\n[Asserts 2]\n\nassert initialPositionOfOddDigit([12, 24, 36, 48, 57, 69, 82, 91, 103]) == 4\nassert initialPositionOfOddDigit([22, 44, 66, 88, 200, 402]) == -1\nassert initialPositionOfOddDigit([111, 222, 333, 444, 555, 666, 777, 888, 999]) == 0\nassert initialPositionOfOddDigit([0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20]) == -1\nassert initialPositionOfOddDigit([123, 246, 357, 468, 579, 680, 791, 812, 933, 104]) == 0\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['range', 'count', 'numbers', 'first digit', 'last digit']", "prompt_tokens": 487, "total_tokens": 787, "completion_tokens": 300, "completion": "[Question 2]\n\nGiven a list of numbers, the task is to filter out the numbers at odd indices and then count the total numbers in the filtered list such that the first digit is equal to the last digit of the number.\n\n[/Question 2]\n\n[Code 2]\n\ndef countNumbersWithFirstAndLastDigitAtOddIndices(numbers: List[int]) -> int:\n    filtered_numbers = [numbers[i] for i in range(1, len(numbers), 2)]\n    cnt = 0\n    for num in filtered_numbers:\n        if str(num)[0] == str(num)[-1]:\n            cnt += 1\n    return cnt\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countNumbersWithFirstAndLastDigitAtOddIndices([123, 456, 151, 252, 303, 505, 707]) == 3\nassert countNumbersWithFirstAndLastDigitAtOddIndices([111, 222, 333, 444, 555, 666, 777, 888, 999]) == 9\nassert countNumbersWithFirstAndLastDigitAtOddIndices([12, 34, 56, 78, 90]) == 0\nassert countNumbersWithFirstAndLastDigitAtOddIndices([121, 232, 343, 454, 565, 676, 787, 898, 909]) == 9\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['matrix', 'boundary', 'steps', 'movement', 'deque', 'adjacency', 'graph', 'BFS', 'queue']", "prompt_tokens": 1253, "total_tokens": 1797, "completion_tokens": 544, "completion": "[Question 2]\n\nGiven a matrix of integers, where some cells may contain negative numbers, the task is to implement a BFS based approach to find all the reachable cells from a given cell containing a negative number. It is also required to count the number of steps needed to reach each cell and filter out the cells that can be reached in a circular manner (i.e., moving in a circular array). Implement a function to achieve this.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List, Tuple\nfrom collections import deque\n\ndef isSafe(x: int, y: int, n: int, m: int) -> bool:\n    return (x>=0 and x<n and y>=0 and y<m)\n\ndef isCircular(x1: int, y1: int, x2: int, y2: int) -> bool:\n    return (abs(x1 - x2) + abs(y1 - y2) == 1)\n\ndef bfsNegatives(matrix: List[List[int]], start: Tuple[int,int]) -> List[Tuple[Tuple[int,int], int]]:\n    n = len(matrix)\n    m = len(matrix[0])\n\n    q = deque()\n    q.append((start, 0))\n\n    visited = set()\n    visited.add(start)\n\n    res = []\n\n    while q:\n        (x, y), steps = q.popleft()\n        res.append(((x, y), steps))\n        for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            new_x, new_y = x+dx, y+dy\n            if isSafe(new_x, new_y, n, m) and (new_x, new_y) not in visited and matrix[new_x][new_y] >= 0:\n                q.append(((new_x, new_y), steps+1))\n                visited.add((new_x, new_y))\n\n    res = [(coord, steps) for (coord, steps) in res if not any(isCircular(coord[0], coord[1], c[0], c[1]) for c, _ in res if c != coord)]\n    \n    return res\n\n[/Code 2]\n\n[Asserts 2]\n\nassert bfsNegatives([[0, -2, -3, 0], [-1, 5, 0, 7], [9, -8, -7, 0]], (1, 2)) == [((1, 2), 0), ((1, 1), 1), ((0, 2), 2)]\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['path', 'movement', 'grid', 'character', 'occurrences', 'max', 'horizontal', 'vertical']", "prompt_tokens": 486, "total_tokens": 838, "completion_tokens": 352, "completion": "[Question 2]\n\nYou are given a grid with elements representing coefficients of a quadratic equation. Write a function that determines the number of elements in the grid that satisfy the given quadratic equation when the grid is transversed vertically or horizontally. \n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\ndef satisfyingQuadratic(grid: List[List[int]]) -> int:\n    count = 0\n    for row in grid:\n        for coeff in row:\n            if isinstance(coeff, int):\n                if coeff > 0:\n                    # Let's assume the quadratic equation is ax^2 + bx + c = 0\n                    # For simplicity, we are considering only the ones where the roots are real\n                    # Discriminant (D) = b^2 - 4ac\n                    D = (coeff**2) - (4*coeff*coeff)\n                    if D >= 0:\n                        count += 1\n    return count\n\n[/Code 2]\n\n[Asserts 2]\n\nassert satisfyingQuadratic([[1, 2, 1], [4, 4, 1], [1, 6, 9]]) == 9\nassert satisfyingQuadratic([[1, 0, 1], [0, 4, 0], [1, 0, 1]]) == 5\nassert satisfyingQuadratic([[4, 3, 2], [1, 1, 1], [0, 0, 0]]) == 6\nassert satisfyingQuadratic([[-1, -2, -1], [-4, -4, -1], [-1, -6, -9]]) == 9\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['chessboard', 'bishops', 'placement', 'attack', 'count', 'ways', 'util', 'function', 'boolean', 'nested loops']", "prompt_tokens": 761, "total_tokens": 1065, "completion_tokens": 304, "completion": "[Question 2]\n\nWrite a function that takes a chessboard of size N x N and the coordinates of a start point, and returns the count of squares on the chessboard that can be reached by a bishop in exactly M moves.\n\n[/Question 2]\n\n[Code 2]\n\ndef canMove(x, y, n) :\n\tif (x < 0 or y < 0 or x >= n or y >= n) :\n\t\treturn False\n\treturn True\n\ndef countSquares(n, x, y, m) :\n\tcnt = 0\n\tdx = [2, 1, -1, -2, -2, -1, 1, 2]\n\tdy = [1, 2, 2, 1, -1, -2, -2, -1]\n\tfor i in range(0, n) :\n\t\tfor j in range(0, n) :\n\t\t\tcnt += 1\n\treturn cnt\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countSquares(3, 0, 0, 1)==2\nassert countSquares(3, 0, 0, 2)==7\nassert countSquares(4, 1, 2, 2)==11\nassert countSquares(2, 0, 0, 1)==3\nassert countSquares(5, 2, 2, 3)==24\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['string', 'partition', 'subsequences', 'balanced', 'count']", "prompt_tokens": 507, "total_tokens": 746, "completion_tokens": 239, "completion": "[Question 2]\n\nGiven a list of numbers, write a function to count the total number of subsequences that can be formed by taking a partition of the list and then applying nested loops to generate all possible subsequences.\n\n[/Question 2]\n\n[Code 2]\n\ndef countSubsequences(arr: List[int]) -> int:\n    n = len(arr)\n    cnt = 0\n    for i in range(n):\n        for j in range(i, n):\n            # Subsequence from index i to j\n            cnt += 1\n    return cnt\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countSubsequences([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]) == 66\nassert countSubsequences([1, 2, 3, 4, 5]) == 15\nassert countSubsequences([5, 4, 3, 2, 1]) == 15\nassert countSubsequences([3, 3, 3, 3]) == 10\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['2D', 'grid', 'max', 'sum', 'pattern', 'plus shape', 'boundary', 'visited']", "prompt_tokens": 845, "total_tokens": 1541, "completion_tokens": 696, "completion": "[Question 2]\n\nGiven a 2D grid of size N, consisting of non-negative integers, the task is to find the maximum sum of the Plus shape pattern that can be formed with the orthocenter as the center of the plus shape. The orthocenter is a point of concurrency of the three altitudes of a triangle. In a 2D grid, the orthocenter is defined as the element which has the maximum sum of distances from the boundary in both the row and column directions.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\n\ndef maxPlusSumWithOrthocenter(grid: List[List[int]], N: int) -> int:\n\n    def findOrthocenter(grid: List[List[int]], N: int) -> Tuple[int, int]:\n        max_sum = -1\n        ortho_x, ortho_y = -1, -1\n        for i in range(N):\n            row_sum, col_sum = 0, 0\n            for j in range(N):\n                row_sum += grid[i][j]\n                col_sum += grid[j][i]\n            if row_sum + col_sum > max_sum:\n                max_sum = row_sum + col_sum\n                ortho_x, ortho_y = i, i\n        return (ortho_x, ortho_y)\n\n    ortho_x, ortho_y = findOrthocenter(grid, N)\n\n    def findMaxPlus(i: int, j: int, grid: List[List[int]]) -> int: \n        sum = grid[i][j]\n        x, y = i - 1, j\n        while x >= 0 and grid[x][y] != -1:\n            sum += grid[x][y]\n            x -= 1\n        x, y = i + 1, j\n        while x < N and grid[x][y] != -1:\n            sum += grid[x][y]\n            x += 1\n        x, y = i, j - 1\n        while y >= 0 and grid[x][y] != -1:\n            sum += grid[x][y]\n            y -= 1\n        x, y = i, j + 1\n        while y < N and grid[x][y] != -1:\n            sum += grid[x][y]\n            y += 1\n        return sum\n\n    max_sum = 0\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] != -1:\n                cur_max_sum = findMaxPlus(i, j, grid)\n                max_sum = max(max_sum, cur_max_sum)\n    return max_sum\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maxPlusSumWithOrthocenter([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == 35\nassert maxPlusSumWithOrthocenter([[1, 2, 3], [4, 8, 6], [7, 8, 9]], 3) == 39\nassert maxPlusSumWithOrthocenter([[1, 2, 1], [2, 1, 2], [1, 2, 1]], 3) == 10\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['integer', 'staircase', 'boxes', 'count', 'different', 'combinations', 'dynamic programming', 'recursive']", "prompt_tokens": 557, "total_tokens": 833, "completion_tokens": 276, "completion": "[Question 2]\n\nGiven a staircase with N steps and an integer value of x, write a function to calculate the maximum number of ways to climb the staircase when taking steps of value x or less at a time. This can be solved using dynamic programming to efficiently compute the number of combinations.\n\n[/Question 2]\n\n[Code 2]\n\ndef countWaysToClimbStaircase(n, x):\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    for i in range(1, n+1):\n        for j in range(1, x+1):\n            if i - j >= 0:\n                dp[i] += dp[i - j]\n    return dp[n]\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countWaysToClimbStaircase(3, 2) == 3\nassert countWaysToClimbStaircase(4, 2) == 5\nassert countWaysToClimbStaircase(5, 3) == 13\nassert countWaysToClimbStaircase(6, 3) == 24\nassert countWaysToClimbStaircase(7, 2) == 21\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'integers', 'deletion', 'points', 'maximum', 'adjacent', 'condition']", "prompt_tokens": 671, "total_tokens": 939, "completion_tokens": 268, "completion": "[Question 2]\n\nGiven an array of integers, the task is to find the maximum number which can be obtained after deleting some elements from the array. The condition for deletion is that the element at the unit place must be in lowercase. Write a function that takes in the array and returns the maximum number which can be obtained after such deletions.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef maxNumberAfterDeletion(arr: List[int]) -> int:\n        max_num=-1\n        for num in arr:\n            if str(num)[-1].islower():\n                continue\n            num_str = str(num)\n            if int(num_str[-1]) > max_num:\n                max_num = int(num_str[-1])\n                \n        return max_num\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maxNumberAfterDeletion([123, 456, 789, 555, 666])==9\nassert maxNumberAfterDeletion([245, 886, 973, 555, 662])==5\nassert maxNumberAfterDeletion([123, 456, 785, 555, 686])==8\nassert maxNumberAfterDeletion([111, 222, 333, 444, 555])==4\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['matrix', 'count', 'ways', 'reach', 'bottom-right', 'cell', 'top-left', 'allowed moves']", "prompt_tokens": 489, "total_tokens": 772, "completion_tokens": 283, "completion": "[Question 2]\n\nYou are given a matrix representing a grid of classrooms, each having an odd number of students. You are allowed to perform flipping operations on the cells in the matrix. Each flipping operation will convert the number of students in a given cell from an odd number to an even number, or vice versa. Implement a method to count the total number of ways to perform flipping operations so that each cell in the matrix ends up with an even number of students.\n\n[/Question 2]\n\n[Code 2]\n\ndef countWaysToEven(matrix: List[List[int]]) -> int:\n    result = 1\n    for row in matrix:\n        for cell in row:\n            if cell % 2 != 0:\n                result *= 2\n    return max(1, result)\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countWaysToEven([[1, 3, 5], [7, 9, 11]]) == 8\nassert countWaysToEven([[1, 2, 3], [4, 5, 6]]) == 16\nassert countWaysToEven([[7, 11, 15], [3, 9, 21]]) == 16\nassert countWaysToEven([[2, 4, 6], [8, 10, 12]]) == 1", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['positive', 'integer', 'minimum', 'palindromic', 'sum', 'dp', 'loop', 'range']", "prompt_tokens": 550, "total_tokens": 956, "completion_tokens": 406, "completion": "[Question 2]\n\nGiven a non-empty 2D matrix of integers, find the minimum sum of a sub-matrix where the elements are arranged in non-decreasing order.\n\n[/Question 2]\n\n[Code 2]\n\ndef minSumSubMatrix(matrix: List[List[int]]) -> int:\n    rows, cols = len(matrix), len(matrix[0])\n    for i in range(rows):\n        for j in range(cols - 1):\n            matrix[i][j + 1] += matrix[i][j]\n    for j in range(cols):\n        for i in range(rows - 1):\n            matrix[i + 1][j] += matrix[i][j]\n    result = float('inf')\n    for i in range(rows):\n        for j in range(cols):\n            for k in range(i, rows):\n                for l in range(j, cols):\n                    sub_matrix_sum = matrix[k][l]\n                    if i > 0:\n                        sub_matrix_sum -= matrix[i - 1][l]\n                    if j > 0:\n                        sub_matrix_sum -= matrix[k][j - 1]\n                    result = min(result, sub_matrix_sum)\n    return result\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minSumSubMatrix([[1,4,7],[2,5,8],[3,6,9]])==1\nassert minSumSubMatrix([[1,2,3],[4,5,6],[7,8,9]])==1\nassert minSumSubMatrix([[10,20,30,40],[15,25,35,45],[28,29,37,49],[33,34,38,50]])==33\nassert minSumSubMatrix([[5,4,8],[10,1,2],[7,9,3]])==1\nassert minSumSubMatrix([[5,1,7],[3,9,6],[2,8,4]])==1\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['convex polygon', 'triangles', 'split', 'vertices', 'combinations', 'counting']", "prompt_tokens": 426, "total_tokens": 538, "completion_tokens": 112, "completion": "[Question 2]\n\nYou are given a convex polygon with `n` sides, and you want to determine the number of unique triangles that can be formed by selecting three distinct vertices from the polygon.\n\n[/Question 2]\n\n[Code 2]\n\nimport math\n\ndef uniqueTriangleCount(n):\n    return math.comb(n, 3)\n\n[/Code 2]\n\n[Asserts 2]\n\nassert uniqueTriangleCount(4) == 4\nassert uniqueTriangleCount(5) == 10\nassert uniqueTriangleCount(6) == 20", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'distinct', 'adjacent', 'ways', 'count', 'integer']", "prompt_tokens": 505, "total_tokens": 765, "completion_tokens": 260, "completion": "[Question 2]\n\nGiven a binary tree represented as an array of integers, write a function to count the number of distinct ways to form an array with distinct adjacent elements at each level of the tree.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef countDistinctWays(arr: List[int]) -> int:\n    def countWays(level: int, parent: int) -> int:\n        if level == len(arr):\n            return 1\n        ans = 0\n        for child in range(len(arr)):\n            if parent != child:\n                if level == 0 or arr[child] != arr[level - 1]:\n                    ans += countWays(level + 1, child)\n        return ans\n    \n    return countWays(0, -1)\n\n[/Code 2]\n\n[Asserts 2]\n\nassert countDistinctWays([1, 2, 3, 3, 2, 4, 4]) == 2\nassert countDistinctWays([2, 3, 2, 3, 3, 4]) == 3\nassert countDistinctWays([1, 2, 3, 4, 5]) == 24\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['integer', 'digits', 'smallest', 'number', 'sum', 'squares', 'function', 'exists']", "prompt_tokens": 612, "total_tokens": 879, "completion_tokens": 267, "completion": "[Question 2]\n\nWrite a function to generate a pseudo-random integer using a proper pseudo-random number generator algorithm with a given number of digits. The function should ensure that the sum of squares of the digits of the generated number exists and is smallest possible.\n\n[/Question 2]\n\n[Code 2]\n\nimport random\n\ndef generateRandomNumber(num_digits: int, sum_squares: int) -> int:\n    while True:\n        num = random.randint(10**(num_digits-1), 10**num_digits - 1)\n        digit_sum = sum(int(digit) for digit in str(num))\n        square_sum = sum(int(digit)**2 for digit in str(num))\n        if digit_sum == num_digits and square_sum == sum_squares:\n            return num\n\n[/Code 2]\n\n[Asserts 2]\n\nassert generateRandomNumber(3, 10) in range(100, 1000)\nassert generateRandomNumber(4, 30) in range(1000, 10000)\nassert generateRandomNumber(2, 5) in range(10, 100)\nassert generateRandomNumber(5, 55) in range(10000, 100000)\nassert generateRandomNumber(6, 25) in range(100000, 1000000)", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['positive', 'integer', 'sum', 'product', 'consecutive', 'binomial coefficient', 'dynamic programming']", "prompt_tokens": 522, "total_tokens": 748, "completion_tokens": 226, "completion": "[Question 2]\n\nGiven a list of positive integers, write a function to find the maximum sum of the products of consecutive selected elements in the list.\n\n[/Question 2]\n\n[Code 2]\n\ndef max_sum_of_consecutive_products(nums):\n    max_sum = float('-inf')\n    for i in range(len(nums)-1):\n        max_sum = max(max_sum, nums[i]*nums[i+1])\n    return max_sum\n\n[/Code 2]\n\n[Asserts 2]\n\nassert max_sum_of_consecutive_products([1, 2, 3, 4, 5])==20\nassert max_sum_of_consecutive_products([3, 7, 2, 5, 8])==56\nassert max_sum_of_consecutive_products([9, 10, 11, 12, 13])==156\nassert max_sum_of_consecutive_products([5, 3, 8, 2, 10])==80\nassert max_sum_of_consecutive_products([1, 1, 1, 1, 1])==1\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'integer', 'sum', 'bitwise', 'operation', 'element', 'add', 'subtract', 'NOT']", "prompt_tokens": 619, "total_tokens": 908, "completion_tokens": 289, "completion": "[Question 2]\n\nYou are given an array of strings representing different types of pizzas. Each pizza type has a numerical value associated with it. You need to perform a series of operations to determine the total numerical value of the pizzas in a spiral order, where each pizza type adds to the total sum and each pizza type can be represented as an integer.\n\nYour task is to write a function that takes in the array of strings, performs the spiral operation, and returns the total sum of the numerical values of the pizza types.\n\n[/Question 2]\n\n[Code 2]\n\ndef spiralPizzaSum(pizzas: list) -> int:\n    rows = len(pizzas)\n    cols = len(pizzas[0])\n    totalSum = 0\n    for i in range(rows):\n        totalSum += int(pizzas[i][i%cols])  # Traverse in spiral order\n    return totalSum\n\n[/Code 2]\n\n[Asserts 2]\n\nassert spiralPizzaSum([\"123\", \"456\", \"789\"]) == 15\nassert spiralPizzaSum([\"111\", \"222\", \"333\"]) == 6\nassert spiralPizzaSum([\"98\", \"76\", \"54\", \"32\"]) == 20\nassert spiralPizzaSum([\"9999\", \"8888\", \"7777\", \"6666\"]) == 30\nassert spiralPizzaSum([\"12345\"]) == 5\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['Fibonacci', 'sequence', 'print', 'two variables', 'iteration', 'loop', 'number', 'math']", "prompt_tokens": 520, "total_tokens": 785, "completion_tokens": 265, "completion": "[Question 2]\n\nYou are designing a system to identify unique identifiers for each rectangular park. You decide to use a modified Fibonacci sequence to create these identifiers, by printing the first n numbers of the modified Fibonacci sequence. Write a Python program that utilizes two variables and a loop to print the modified Fibonacci sequence for the given number of parks.\n\n[/Question 2]\n\n[Code 2]\n\ndef modified_fibonacci(n: int) -> None :\n  a = 0\n  b = 1\n  print(a, end=\", \")\n  for i in range(2, n) :\n    c = a + b + 2   # Modify the Fibonacci sequence\n    print(b, end=\", \")\n    a, b = b, c\n  \n[/Code 2]\n\n[Asserts 2]\n\nassert modified_fibonacci(5) == \"0, 1, 3, 6, 11, \"\nassert modified_fibonacci(7) == \"0, 1, 3, 6, 11, 19, 32, \"\nassert modified_fibonacci(10) == \"0, 1, 3, 6, 11, 19, 32, 53, 87, 142, \"\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['array', 'subsequence', 'sum', 'maximum', 'increasing', 'integer', 'length']", "prompt_tokens": 619, "total_tokens": 1009, "completion_tokens": 390, "completion": "[Question 2]\n\nGiven a binary array A of length N, the task is to find the maximum sum of increasing subsequence of elements with a capacity constraint W, where the sum of the indices of the selected elements does not exceed the capacity. Also, the selected elements should form a valid expression when interpreted as a binary tree, where every element's child nodes should have lower indices than the parent element.\n\n[/Question 2]\n\n[Code 2]\n\nfrom typing import List\ndef maxSumIncreasingSubsequenceWithCapacityConstraint(A: List[int], W: int) -> int:\n    n = len(A)\n    maxSum = 0\n    dp = [0] * n\n    for i in range(n):\n        dp[i] = A[i]\n        for j in range(i):\n            if A[i] > A[j] and i - j <= W:\n                dp[i] = max(dp[i], dp[j] + A[i])\n        if dp[i] > maxSum:\n            maxSum = dp[i]\n    return maxSum\n\n[/Code 2]\n\n[Asserts 2]\n\nassert maxSumIncreasingSubsequenceWithCapacityConstraint([1, 101, 2, 3, 100, 4, 5], 2) == 104\nassert maxSumIncreasingSubsequenceWithCapacityConstraint([3, 4, 5, 10], 1) == 15\nassert maxSumIncreasingSubsequenceWithCapacityConstraint([10, 5, 4, 3], 3) == 19\nassert maxSumIncreasingSubsequenceWithCapacityConstraint([1, 2, 3, 2, 1], 2) == 6\nassert maxSumIncreasingSubsequenceWithCapacityConstraint([3, 2, 6, 4, 5, 1], 3) == 12\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['strings', 'longest', 'common', 'substring', 'dynamic programming', '2D array', 'comparison', 'iteration', 'max']", "prompt_tokens": 637, "total_tokens": 1097, "completion_tokens": 460, "completion": "[Question 2]\n\nGiven a list of strings representing PAN Card numbers, find the length of the longest common substring between any two PAN Card numbers.\n\n[/Question 2]\n\n[Code 2]\n\ndef longestCommonPANSubstring(pan_numbers: List[str]) -> int:\n    def longestCommonSubstring(str1: str, str2: str) -> int:\n        m = len(str1)\n        n = len(str2)\n        dp = [[0]*(n + 1) for i in range(2)]\n        result = 0\n        flag = 0\n        for i in range(m + 1):\n            for j in range(n + 1):\n                if (i == 0 or j == 0):\n                    dp[flag][j] = 0\n                elif (str1[i - 1] == str2[j - 1]):\n                    dp[flag][j] = dp[1 - flag][j - 1] + 1\n                    result = max(result, dp[flag][j])\n                else :\n                    dp[flag][j] = 0\n            flag = 1 - flag\n        return result\n    \n    max_length = 0\n    for i in range(len(pan_numbers)):\n        for j in range(i+1, len(pan_numbers)):\n            max_length = max(max_length, longestCommonSubstring(pan_numbers[i], pan_numbers[j]))\n    return max_length\n\n[/Code 2]\n\n[Asserts 2]\n\npan_numbers = [\"ABCDE1234F\", \"ABCD1234F\", \"ABCDE1245G\", \"ABCD1245G\"]\nassert longestCommonPANSubstring(pan_numbers) == 4\n\npan_numbers = [\"ABCD1234F\", \"1234FABCD\", \"ABCD5678G\", \"5678GABCD\"]\nassert longestCommonPANSubstring(pan_numbers) == 4\n\npan_numbers = [\"ABCD1234F\", \"1234FABCD\", \"ABCD5678G\", \"5678GABCD\", \"ABCDPQRS1\", \"WXYZPQRS1\"]\nassert longestCommonPANSubstring(pan_numbers) == 4\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}, {"keywords": "['string', 'minimum', 'moves', 'append', 'character', 'equality']", "prompt_tokens": 521, "total_tokens": 834, "completion_tokens": 313, "completion": "[Question 2]\n\nYou are given a string s consisting of lowercase English alphabet characters. The string represents a sequence of booked and unbooked seats on a unit-length seat on a train. The booked seats are represented by 'x' and unbooked seats by '.'\nYour task is to find the minimum number of moves required to make all the unbooked seats 'booked' with the condition that no two booked seats are adjacent.\n\nWrite a Python program to find the minimal moves required to book all the unbooked seats according to the above condition.\n\n[/Question 2]\n\n[Code 2]\n\ndef minMovesToBookSeats(s: str) -> int:\n    count = 0\n    if s[0] == '.':\n        count += 1\n        s = 'x' + s[1:]\n    if s[-1] == '.':\n        count += 1\n        s = s[:-1] + 'x'\n    s = s.replace('xxx', 'xx')\n    return count + (s.count('.') + 1) // 2\n\n[/Code 2]\n\n[Asserts 2]\n\nassert minMovesToBookSeats(\"x.x.xxx.x.\")==2\nassert minMovesToBookSeats(\"x.x.x.x.x.x.x.\")==4\nassert minMovesToBookSeats(\"...\")==1\nassert minMovesToBookSeats(\"x.xx.x.xx.x\")==0\nassert minMovesToBookSeats(\"x.x...x.x\")==2\n\n[/Asserts 2]", "model_name": "gpt-3.5-turbo-1106", "source": "xlcost-diverse-instruct"}]