Question,Question Example/Explanation,Link,Difficulty,Categories,Method 1,Driver Code 1,Method 2
Write a program to generate 0 and 1 with 25% and 75% probability,"Given a function rand50() that returns 0 or 1 with equal probability, write a function that returns 1 with 75% probability and 0 with 25% probability using rand50() only. Minimize the number of calls to the rand50() method. Also, the use of any other library function and floating-point arithmetic are not allowed.",https://www.geeksforgeeks.org/generate-0-1-25-75-probability/,Easy,[Randomized Algorithms],"from random import randrange

def rand50():
  return ((int)(randrange(0, 2)) & 1)
   
def rand75():
  return (rand50() & rand50())^1
  
for i in range(0, 50):
    print(rand75(), end="""")",,"from random import randrange
 
# Random Function to that returns 0 or 1 with
# equal probability
def rand50():
        # rand range function generates a integer between
    # the provided ranges which is half closed interval
    # It will generate integer 0 or 1 if passed 0,2 as parameter
    return (int)(randrange(0, 2)) & 1
 
# Random Function to that returns 1 with 75%
# probability and 0 with 25% probability using
# left shift and Bitwise XOR
 
 
def rand75():
 
    # x is one of {0, 1}
    x = rand50()
    x = x << 1
 
    # x is now one of {00, 10}
    x = x ^ rand50()
 
    # x is now one of {00, 01, 10, 11}
    return 1 if (x > 0) else 0
 
# Driver code to test above functions
for i in range(0, 50):
    print(rand75(), end="""")"
"Given a deck of cards as an array, write a program to shuffle the cards","Input: [0, 1, 2, 3, 4, 5, 6, 7, 8,
       9, 10, 11, 12, 13, 14, 15,
       16, 17, 18, 19, 20, 21, 22, 
       23, 24, 25, 26, 27, 28, 29,
       30, 31, 32, 33, 34, 35, 36,
       37, 38, 39, 40, 41, 42, 43, 
       44, 45, 46, 47, 48, 49, 50,
       51]
One possible output: 
29 27 20 23 26 21 35 51 15 18 46 32 33 19 
24 30 3 45 40 34 16 11 36 50 17 10 7 5 4 
39 6 47 38 28 13 44 49 1 8 42 43 48 0 12 
37 41 25 2 31 14 22",https://www.geeksforgeeks.org/shuffle-a-deck-of-cards-3/,Easy,[Randomized Algorithms],"import random
def shuffle(card,n) :
    for i in range(n):
        r = i + (random.randint(0,55) % (52 -i))
        tmp=card[i]
        card[i]=card[r]
        card[r]=tmp","#Driver code
if __name__=='__main__':
    a=[0, 1, 2, 3, 4, 5, 6, 7, 8,
       9, 10, 11, 12, 13, 14, 15,
       16, 17, 18, 19, 20, 21, 22, 
       23, 24, 25, 26, 27, 28, 29,
       30, 31, 32, 33, 34, 35, 36,
       37, 38, 39, 40, 41, 42, 43, 
       44, 45, 46, 47, 48, 49, 50,
       51]
    shuffle(a,52)
    print(a)",
"There are N elements in an array. In the very beginning, random element is chosen. After some element are over, the next one is chosen randomly and independently of what have been selected before. Find the minimum selections to be made until every element is selected at least once.","Input: 1 
Output: 1.0
Explanation: There is only one element and it needs to be selected to make all elements as selected.

Input: 2
Output: 3.0
Explanation: After selecting the first element, there is 1/2 chance to finish the array each time new element is selected. So the expected number of elements selected is 2/2 + 3/4 + 4/8… = 3.

Input: 3
Output: 5.5
Explanation: Elements selected are 3/1+3/2+3/3=5.5",https://www.geeksforgeeks.org/expected-number-of-trials-before-success/,Medium,[Randomized Algorithms],"def minSelections(n):
    ans = 0
    for i in range(1, n + 1):
        ans = ans + (n/i)
    return ans","# Driver's code
N = 3
print('%.8f' % minSelections(N))",
"A password is considered strong if it has the following criteria: At least 8 characters, At least one special char, At least one number, At least one upper and one lower case char. Given a password entered by the user, check its strength and suggest some password if it is not strong.","Input : keshav123
Output : Suggested Password
        k(eshav12G3
        keshav1@A23
        kesh!Aav123
        ke(shav12V3
        keGshav1$23
        kesXhav@123
        keAshav12$3
        kesKhav@123
        kes$hav12N3
        $kesRhav123

Input :rakesh@1995kumar
Output : Your Password is Strong",https://www.geeksforgeeks.org/strong-password-suggester-program/,Medium,[Randomized Algorithms],"import random
def insert(s, pos, ch):
        return(s[:pos] + ch + s[pos:])

def add_more_char(s, need):
        pos = 0
        low_case = ""abcdefghijklmnopqrstuvwxyz""
 
        for i in range(need):
                pos = random.randint(0, len(s)-1)
                s = insert(s, pos, low_case[random.randint(0,25)])
 
        return(s)
def suggester(l, u, d, s, st):
        num = '0123456789'
        low_case = ""abcdefghijklmnopqrstuvwxyz""
        up_case = low_case.upper()
        spl_char = '@#$_()!'
        pos = 0
        if(l == 0):
           
                pos = random.randint(0,len(st)-1)
                st = insert(st, pos, low_case[random.randint(0,25)])
        if( u == 0 ):
                pos = random.randint(0,len(st)-1)
                st = insert(st, pos, up_case[random.randint(0,25)])
 
        # If there is no digit in input string, add it
        if( d == 0 ):
                pos = random.randint(0,len(st)-1)
                st = insert(st, pos, num[random.randint(0,9)])
        if( s == 0 ):
                pos = random.randint(0,len(st)-1)
                st = insert(st, pos, low_case[random.randint(0,6)])
 
        return st

def generate_password(n, p):
        l = 0; u = 0; d = 0; s = 0; need = 0
 
        suggest = ''
 
        for i in range(n):
           
                # Password suggestion
                if( p[i].islower() ):
                        l = 1
                elif( p[i].isupper() ):
                        u = 1
                elif( p[i].isdigit() ):
                        d = 1
                else:
                        s = 1
        if( (l + u + d + s) == 4):
                print(""Your Password is Strong"")
                return
        else:
                print(""Suggested Passwords"")
 
        for i in range(10):
                suggest = suggester(l, u, d, s, p)
                need = 8 - len(suggest)
 
                if(need > 0):
                        suggest = add_more_char(suggest, need)
                print(suggest)
 
"," 
# Driver Code
input_string = 'geek@2018'
 
generate_password( len(input_string), input_string)",
"Given n numbers, each with some frequency of occurrence. Return a random number with probability proportional to its frequency of occurrence.","Let following be the given numbers.
  arr[] = {10, 30, 20, 40}  

Let following be the frequencies of given numbers.
  freq[] = {1, 6, 2, 1}  

The output should be
  10 with probability 1/10
  30 with probability 6/10
  20 with probability 2/10
  40 with probability 1/10",https://www.geeksforgeeks.org/random-number-generator-in-arbitrary-probability-distribution-fashion/,Hard,[Randomized Algorithms],"
import random 
def findCeil(arr, r, l, h) : 

        while (l < h) :         
                mid = l + ((h - l) >> 1)
                if r > arr[mid] : 
                        l = mid + 1
                else : 
                        h = mid 
        
        if arr[l] >= r : 
                return l 
        else : 
                return -1

def myRand(arr, freq, n) : 

        prefix = [0] * n 
        prefix[0] = freq[0] 
        for i in range(n) : 
                prefix[i] = prefix[i - 1] + freq[i] 

        r = random.randint(0, prefix[n - 1]) + 1

        indexc = findCeil(prefix, r, 0, n - 1) 
        return arr[indexc] 
","# Driver code 
arr = [1, 2, 3, 4] 
freq = [10, 5, 20, 100] 
n = len(arr) 

# Let us generate 10 random numbers according to 
# given distribution 
for i in range(5) : 
        print(myRand(arr, freq, n)) 

        # This code is contributed by divyesh072019",
"Given a singly linked list, select a random node from the linked list (the probability of picking a node should be 1/N if there are N nodes in the list). You are given a random number generator.","If the linked list is:

5 --> 20 --> 4 --> 3 --> 30

Then one correct answer for the randomly samples node can be:

Randomly selected key is
4",https://www.geeksforgeeks.org/select-a-random-node-from-a-singly-linked-list/,Hard,[Randomized Algorithms],"
import random

class Node:
        def __init__(self, data):
                self.data= data
                self.next = None

class LinkedList:
        def __init__(self):
                self.head = None
        def printRandom(self):
                if self.head is None:
                        return
                if self.head and not self.head.next:
                print(""Randomly selected key is %d"" %(self.head.data))
                random.seed()
                result = self.head.data
                current = self.head.next
                n = 2
                while(current is not None):
                        
                        # change result with probability 1/n
                        if (random.randrange(n) == 0 ):
                                result = current.data 

                        # Move to next node
                        current = current.next
                        n += 1

                print(""Randomly selected key is %d"" %(result))
                
        def push(self, new_data):
                new_node = Node(new_data)
                new_node.next = self.head
                self.head = new_node

        def printList(self):
                temp = self.head
                while(temp):
                        print(temp.data,end="" "")
                        temp = temp.next


","# Driver program to test above function
llist = LinkedList()
llist.push(5)
llist.push(20)
llist.push(4)
llist.push(3)
llist.push(30)
llist.printRandom()

# This code is contributed by Nikhil Kumar Singh(nickzuck_007)",
Given a square matrix mat[][] and a number k. The task is to shift the first k elements of each row to the right of the matrix.,"Input : mat[N][N] = {{1, 2, 3},
                     {4, 5, 6},
                     {7, 8, 9}}
        k = 2
Output :mat[N][N] = {{3, 1, 2}
                     {6, 4, 5}
                     {9, 7, 8}}

Input : mat[N][N] = {{1, 2, 3, 4}
                     {5, 6, 7, 8}
                     {9, 10, 11, 12}
                     {13, 14, 15, 16}}
        k = 2
Output :mat[N][N] = {{3, 4, 1, 2}
                     {7, 8, 5, 6}
                     {11, 12, 9, 10}
                     {15, 16, 13, 14}}",https://www.geeksforgeeks.org/shift-matrix-elements-k/,Easy,[Matrix/Grid],"N = 4
def shiftMatrixByK(mat, k): 
        if (k > N) : 
                print (""shifting is""
                        "" not possible"") 
                return
        
        j = 0
        while (j < N) :
                for i in range(k, N): 
                        print (""{} "" . 
                        format(mat[j][i]), end="""") 
                        
                for i in range(0, k): 
                        print (""{} "" . 
                        format(mat[j][i]), end="""") 
                        
                print ("""") 
                j = j + 1","
# Driver code 
mat = [[1, 2, 3, 4], 
        [5, 6, 7, 8], 
        [9, 10, 11, 12], 
        [13, 14, 15, 16]] 
k = 2

# Function call 
shiftMatrixByK(mat, k) ",
"Given an integer matrix of odd dimensions (like 3 * 3 or 5 * 5), find the sum of the middle row & column elements. ","Input :  2 5 7
         3 7 2
         5 6 9
Output : Sum of middle row = 12
         Sum of middle column = 18

Input :  1 3 5 6 7
         3 5 3 2 1
         1 2 3 4 5
         7 9 2 1 6
         9 1 5 3 2
Output : Sum of middle row = 15
         Sum of middle column = 18",https://www.geeksforgeeks.org/sum-middle-row-column-matrix/,Easy,[Matrix/Grid],"def middlesum(mat,n):

        row_sum = 0
        col_sum = 0
        for i in range(n):
                row_sum += mat[n // 2][i]
        
        print(""Sum of middle row = "",
                                        row_sum)
        
        for i in range(n):
                col_sum += mat[i][n // 2]
        
        print(""Sum of middle column = "",
                                                        col_sum)","
# Driver code
mat= [[2, 5, 7],
        [3, 7, 2], 
        [5, 6, 9]]
        
middlesum(mat, 3)",
"Given a matrix of n*n size, the task is to find whether all rows are circular rotations of each other or not. ","Input: mat[][] = 1, 2, 3
                 3, 1, 2
                 2, 3, 1
Output:  Yes
All rows are rotated permutation
of each other.

Input: mat[3][3] = 1, 2, 3
                   3, 2, 1
                   1, 3, 2
Output:  No
Explanation : As 3, 2, 1 is not a rotated or 
circular permutation of 1, 2, 3",https://geeksforgeeks.org/check-rows-matrix-circular-rotations/,Medium,[Matrix/Grid],"
MAX = 1000

def isPermutedMatrix(mat, n) :
        
        str_cat = """"
        for i in range(n) :
                str_cat = str_cat + ""-"" + str(mat[0][i])

        str_cat = str_cat + str_cat

        for i in range(1, n) :
                curr_str = """"
                
                for j in range(n) :
                        curr_str = curr_str + ""-"" + str(mat[i][j])

                if (str_cat.find(curr_str)) : 
                        return True
                        
        return False
","
# Driver code 
if __name__ == ""__main__"" :
        n = 4
        mat = [[1, 2, 3, 4], 
                [4, 1, 2, 3], 
                [3, 4, 1, 2], 
                [2, 3, 4, 1]] 
        
        if (isPermutedMatrix(mat, n)):
                print(""Yes"")
        else :
                print(""No"")",
"Given a N x N binary matrix (elements in matrix can be either 1 or 0) where each row and column of the matrix is sorted in ascending order, count number of 0s present in it.","Input: 
[0, 0, 0, 0, 1]
[0, 0, 0, 1, 1]
[0, 1, 1, 1, 1]
[1, 1, 1, 1, 1]
[1, 1, 1, 1, 1]

Output: 8


Input: 
[0, 0]
[0, 0]

Output: 4


Input: 
[1, 1, 1, 1]
[1, 1, 1, 1]
[1, 1, 1, 1]
[1, 1, 1, 1]

Output: 0",https://www.geeksforgeeks.org/count-zeros-in-a-row-wise-and-column-wise-sorted-matrix/,Medium,[Matrix/Grid],"
def countZeroes(mat):
        
        N = 5;
        row = N - 1;
        col = 0;
        count = 0;

        while (col < N):
                while (mat[row][col]):
                        if (row < 0):
                                return count;
                        row = row - 1;
                count = count + (row + 1);
                col = col + 1;

        return count","# Driver Code
mat = [[0, 0, 0, 0, 1],
        [0, 0, 0, 1, 1],
        [0, 1, 1, 1, 1],
        [1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1]];

print( countZeroes(mat));

# This code is contributed
# by chandan_jnu ",
"Given the dimension of a sequence of matrices in an array arr[], where the dimension of the ith matrix is (arr[i-1] * arr[i]), the task is to find the most efficient way to multiply these matrices together such that the total number of element multiplications is minimum.","Input: arr[] = {40, 20, 30, 10, 30}
Output: 26000
Explanation:There are 4 matrices of dimensions 40×20, 20×30, 30×10, 10×30.
Let the input 4 matrices be A, B, C and D.
The minimum number of  multiplications are obtained by 
putting parenthesis in following way (A(BC))D.
The minimum is 20*30*10 + 40*20*10 + 40*10*30

Input: arr[] = {1, 2, 3, 4, 3}
Output: 30
Explanation: There are 4 matrices of dimensions 1×2, 2×3, 3×4, 4×3. 
Let the input 4 matrices be A, B, C and D.  
The minimum number of multiplications are obtained by 
putting parenthesis in following way ((AB)C)D.
The minimum number is 1*2*3 + 1*3*4 + 1*4*3 = 30

Input: arr[] = {10, 20, 30}
Output: 6000  
Explanation: There are only two matrices of dimensions 10×20 and 20×30. 
So there  is only one way to multiply the matrices, cost of which is 10*20*30",https://www.geeksforgeeks.org/matrix-chain-multiplication-dp-8/,Hard,[Matrix/Grid],"import sys
def MatrixChainOrder(p, i, j):
        if i == j:
                return 0

        _min = sys.maxsize

        for k in range(i, j):

                count = (MatrixChainOrder(p, i, k)
                                + MatrixChainOrder(p, k + 1, j)
                                + p[i-1] * p[k] * p[j])

                if count < _min:
                        _min = count

        return _min","
# Driver code
if __name__ == '__main__':
        arr = [1, 2, 3, 4, 3]
        N = len(arr)
        
        # Function call
        print(""Minimum number of multiplications is "",
        MatrixChainOrder(arr, 1, N-1))",
Given an MxN matrix where each element can either be 0 or 1. We need to find the shortest path between a given source cell to a destination cell. The path can only be created out of a cell if its value is 1.,"Input:
mat[ROW][COL]  = {{1, 0, 1, 1, 1, 1, 0, 1, 1, 1 },
                  {1, 0, 1, 0, 1, 1, 1, 0, 1, 1 },
                  {1, 1, 1, 0, 1, 1, 0, 1, 0, 1 },
                  {0, 0, 0, 0, 1, 0, 0, 0, 0, 1 },
                  {1, 1, 1, 0, 1, 1, 1, 0, 1, 0 },
                  {1, 0, 1, 1, 1, 1, 0, 1, 0, 0 },
                  {1, 0, 0, 0, 0, 0, 0, 0, 0, 1 },
                  {1, 0, 1, 1, 1, 1, 0, 1, 1, 1 },
                  {1, 1, 0, 0, 0, 0, 1, 0, 0, 1 }};
Source = {0, 0};
Destination = {3, 4};

Output:
Shortest Path is 11",https://www.geeksforgeeks.org/shortest-path-in-a-binary-maze/,Hard,[Matrix/Grid],"import sys
class Pair:
        def __init__(self, x, y):
                self.first = x
                self.second = y
def isSafe(mat, visited, x, y):
        return (x >= 0 and x < len(mat) and y >= 0 and y < len(mat[0]) and mat[x][y] == 1 and (not visited[x][y]))

def findShortestPath(mat, visited, i, j, x, y, min_dist, dist):
        if (i == x and j == y):
                min_dist = min(dist, min_dist)
                return min_dist

        visited[i][j] = True
        
        if (isSafe(mat, visited, i + 1, j)):
                min_dist = findShortestPath(
                        mat, visited, i + 1, j, x, y, min_dist, dist + 1)

        if (isSafe(mat, visited, i, j + 1)):
                min_dist = findShortestPath(
                        mat, visited, i, j + 1, x, y, min_dist, dist + 1)

        if (isSafe(mat, visited, i - 1, j)):
                min_dist = findShortestPath(
                        mat, visited, i - 1, j, x, y, min_dist, dist + 1)

        if (isSafe(mat, visited, i, j - 1)):
                min_dist = findShortestPath(
                        mat, visited, i, j - 1, x, y, min_dist, dist + 1)

        visited[i][j] = False
        return min_dist

def findShortestPathLength(mat, src, dest):
        if (len(mat) == 0 or mat[src.first][src.second] == 0
                        or mat[dest.first][dest.second] == 0):
                return -1

        row = len(mat)
        col = len(mat[0])

        visited = []
        for i in range(row):
                visited.append([None for _ in range(col)])

        dist = sys.maxsize
        dist = findShortestPath(mat, visited, src.first,
                                                        src.second, dest.first, dest.second, dist, 0)

        if (dist != sys.maxsize):
                return dist
        return -1
","# Driver code
mat = [[1, 0, 1, 1, 1, 1, 0, 1, 1, 1],
        [1, 0, 1, 0, 1, 1, 1, 0, 1, 1],
        [1, 1, 1, 0, 1, 1, 0, 1, 0, 1],
        [0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
        [1, 1, 1, 0, 1, 1, 1, 0, 1, 0],
        [1, 0, 1, 1, 1, 1, 0, 1, 0, 0],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 1, 1, 1, 1, 0, 1, 1, 1],
        [1, 1, 0, 0, 0, 0, 1, 0, 0, 1]
        ]

src = Pair(0, 0)
dest = Pair(3, 4)
dist = findShortestPathLength(mat, src, dest)
if (dist != -1):
        print(""Shortest Path is"", dist)

else:
        print(""Shortest Path doesn't exist"")",
"Given an array arr[] of size N, the task is to printing K largest elements in an array. The Elements in output array can be in any order","Input:  [1, 23, 12, 9, 30, 2, 50], K = 3
Output: 50, 30, 23

Input:  [11, 5, 12, 9, 44, 17, 2], K = 2
Output: 44, 17",https://www.geeksforgeeks.org/k-largestor-smallest-elements-in-an-array/,Easy,[Heap],"def kLargest(arr, k):
        arr.sort(reverse=True)
        for i in range(k):
                print(arr[i], end="" "")","
# Driver code
arr = [1, 23, 12, 9, 30, 2, 50]
# n = len(arr)
k = 3
kLargest(arr, k)",
"Given an array of elements, sort the array in decreasing order using min heap. ","Input : arr[] = {5, 3, 10, 1}
Output : arr[] = {10, 5, 3, 1}

Input : arr[] = {1, 50, 100, 25}
Output : arr[] = {100, 50, 25, 1}",https://www.geeksforgeeks.org/heap-sort-for-decreasing-order-using-min-heap/,Easy,[Heap],"def heapify(arr, n, i):
        smallest = i 
        l = 2 * i + 1 
        r = 2 * i + 2

        if l < n and arr[l] < arr[smallest]: 
                smallest = l 

        if r < n and arr[r] < arr[smallest]: 
                smallest = r 

        if smallest != i: 
                (arr[i], 
                arr[smallest]) = (arr[smallest],
                                                arr[i])

                heapify(arr, n, smallest)

def heapSort(arr, n):
         
        for i in range(int(n / 2) - 1, -1, -1):
                heapify(arr, n, i) 

        for i in range(n-1, -1, -1):
                
                arr[0], arr[i] = arr[i], arr[0]

                heapify(arr, i, 0)

","# A utility function to print 
# array of size n 
def printArray(arr, n):
        
        for i in range(n):
                print(arr[i], end = "" "") 
        print()

# Driver Code 
if __name__ == '__main__':
        arr = [4, 6, 3, 2, 9] 
        n = len(arr) 

        heapSort(arr, n) 

        print(""Sorted array is "") 
        printArray(arr, n)

# This code is contributed by PranchalK",
Given an array arr[] containing n elements. The problem is to find the maximum number of distinct elements (non-repeating) after removing k elements from the array. Where 1<= k <= n,"Input : arr[] = {5, 7, 5, 5, 1, 2, 2}, k = 3
Output : 4
Remove 2 occurrences of element 5 and
1 occurrence of element 2.

Input : arr[] = {1, 2, 3, 4, 5, 6, 7}, k = 5
Output : 2

Input : arr[] = {1, 2, 2, 2}, k = 1
Output : 1",https://www.geeksforgeeks.org/maximum-distinct-elements-removing-k-elements/,Medium,[Heap],"
def maxDistinctNum(a, n, k):
        s = {}
        for i in range(n):
                if a[i] not in s or k == 0:
                        s[a[i]] = s.get(a[i], 0)+1
                else:
                        s[a[i]] = 1
                        k -= 1
        if k != 0:
                return len(s)-k
        else:

                st = set()
                for i in s:
                        st.add(i)
                return len(st)","# Driver Code
if __name__ == ""__main__"":

# Array
        arr = [5, 7, 5, 5, 1, 2, 2]
        K = 3

        # Size of array
        N = len(arr)
        
        # Function Call
        print(""Maximum distinct elements = "", maxDistinctNum(arr, N, K))

# This code is contributed by vivekmaddheshiya205",
"Given a stream of integers represented as arr[]. For each index i from 0 to n-1, print the multiplication of largest, second largest, third largest element of the subarray arr[0…i]. If i < 2 print -1. ","Input : arr[] = {1, 2, 3, 4, 5}
Output :-1
        -1
         6
         24
         60
Explanation : for i = 2 only three elements 
are there {1, 2, 3} so answer is 6. For i = 3
largest three elements are {2, 3, 4} their
product is 2*3*4 = 24 ....so on  ",https://www.geeksforgeeks.org/largest-triplet-product-stream/,Medium,[Heap],"def LargestTripletMultiplication(arr, n):
        
        q = PriorityQueue()

        for i in range(n): 
                
                q.put(-arr[i])

                if (q.qsize() < 3):
                        print(-1)
                else:
                        
                        x = q.get()
                        y = q.get()
                        z = q.get()
                        ans = x * y * z
                        
                        print(-ans)
                        
                        q.put(x);
                        q.put(y);
                        q.put(z);","# Driver Code
if __name__ == '__main__':

        arr = [ 1, 2, 3, 4, 5 ]
        n = len(arr)
        
        LargestTripletMultiplication(arr, n)
        
# This code is contributed by math_lover",
"Given a binary search tree which is also a complete binary tree. The problem is to convert the given BST into a Min Heap with the condition that all the values in the left subtree of a node should be less than all the values in the right subtree of the node. This condition is applied to all the nodes, in the resultant converted Min Heap.","Input:       4
                /   \
              2     6
            /  \   /  \
          1   3  5    7  
Output:  1
               /   \
             2     5
           /  \   /  \
         3   4  6    7 
Explanation: The given BST has been transformed into a Min Heap. All the nodes in the Min Heap satisfies the given condition, that is, values in the left subtree of a node should be less than the values in the right subtree of the node. ",https://www.geeksforgeeks.org/convert-bst-min-heap/,Hard,[Heap],"class Node:

        def __init__(self, data):
                self.data = data
                self.left = None
                self.right = None

def inorderTraversal(root, arr):
        if root == None:
                return

        inorderTraversal(root.left, arr)
        arr.append(root.data)
        inorderTraversal(root.right, arr)

def BSTToMinHeap(root, arr, i):
        if root == None:
                return
        i[0] += 1
        root.data = arr[i[0]]
        BSTToMinHeap(root.left, arr, i)
        BSTToMinHeap(root.right, arr, i)

def convertToMinHeapUtil(root):
        arr = []
        i = [-1]
        inorderTraversal(root, arr)
        BSTToMinHeap(root, arr, i)

def preorderTraversal(root):
        if root == None:
                return
        print(root.data, end="" "")
        preorderTraversal(root.left)
        preorderTraversal(root.right)","# Driver's Code
if __name__ == '__main__':

        # BST formation
        root = Node(4)
        root.left = Node(2)
        root.right = Node(6)
        root.left.left = Node(1)
        root.left.right = Node(3)
        root.right.left = Node(5)
        root.right.right = Node(7)

        # Function call
        convertToMinHeapUtil(root)
        print(""Preorder Traversal:"")
        preorderTraversal(root)

# This code is contributed
# by PranchalK",
Given an array of integers. Write a program to find the K-th largest sum of contiguous subarray within the array of numbers that has both negative and positive numbers.,"Input: a[] = {20, -5, -1}, K = 3
Output: 14
Explanation: All sum of contiguous subarrays are (20, 15, 14, -5, -6, -1) 
so the 3rd largest sum is 14.

Input: a[] = {10, -10, 20, -40}, k = 6
Output: -10
Explanation: The 6th largest sum among
sum of all contiguous subarrays is -10.",https://www.geeksforgeeks.org/k-th-largest-sum-contiguous-subarray/,Hard,[Heap],"def kthLargestSum(arr, N, K):
    result = []
    for i in range(N):
        sum = 0
        for j in range(i, N):
                sum += arr[j]
                result.append(sum)

    result.sort(reverse=True)

    return result[K - 1]","
a = [ 20, -5, -1]
N = len(a)
K = 3
# Function call
print(kthLargestSum(a, N, K))

# This code is contributed by hardikkushwaha.",
"Linear Search is defined as a sequential search algorithm that starts at one end and goes through each element of a list until the desired element is found, otherwise the search continues till the end of the data set. Implement the Liknear searching algorithm in python","Input: arr[] = {10, 50, 30, 70, 80, 20, 90, 40} and key = 30
Output: Element is present at index 2",https://www.geeksforgeeks.org/linear-search/,Easy,[Searching Algorithm],"def search(arr, N, x): 
        for i in range(0, N): 
                if (arr[i] == x): 
                        return i 
        return -1","# Driver Code 
if __name__ == ""__main__"": 
        arr = [2, 3, 4, 10, 40] 
        x = 10
        N = len(arr) 

        # Function call 
        result = search(arr, N, x) 
        if(result == -1): 
                print(""Element is not present in array"") 
        else: 
                print(""Element is present at index"", result) ",
Binary Search is defined as a searching algorithm used in a sorted array by repeatedly dividing the search interval in half. The idea of binary search is to use the information that the array is sorted and reduce the time complexity to O(log N). Write the algorithm for binary search in python,"Input: arr[] = {10, 50, 30, 70, 80, 20, 90, 40} and key = 30
Output: Element is present at index 2",https://www.geeksforgeeks.org/binary-search/,Easy,[Searching Algorithm],"def binarySearch(arr, l, r, x):
        while l <= r:
                mid = l + (r - l) // 2
                if arr[mid] == x:
                        return mid

                elif arr[mid] < x:
                        l = mid + 1

                else:
                        r = mid - 1

        return -1","# Driver Code
if __name__ == '__main__':
        arr = [2, 3, 4, 10, 40]
        x = 10

        # Function call
        result = binarySearch(arr, 0, len(arr)-1, x)
        if result != -1:
                print(""Element is present at index"", result)
        else:
                print(""Element is not present in array"")",
Jump Search is a searching algorithm for sorted arrays. The basic idea is to check fewer elements (than linear search) by jumping ahead by fixed steps or skipping some elements in place of searching all elements. Write the algorithm to perform Jump Search in Python,"For example, suppose we have an array arr[] of size n and a block (to be jumped) of size m. Then we search in the indexes arr[0], arr[m], arr[2m]…..arr[km] and so on. Once we find the interval (arr[km] < x < arr[(k+1)m]), we perform a linear search operation from the index km to find the element x.
Let’s consider the following array: (0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610). The length of the array is 16. The Jump search will find the value of 55 with the following steps assuming that the block size to be jumped is 4. 
STEP 1: Jump from index 0 to index 4; 
STEP 2: Jump from index 4 to index 8; 
STEP 3: Jump from index 8 to index 12; 
STEP 4: Since the element at index 12 is greater than 55, we will jump back a step to come to index 8. 
STEP 5: Perform a linear search from index 8 to get the element 55.",https://www.geeksforgeeks.org/jump-search/,Medium,[Searching Algorithm],"
import math

def jumpSearch( arr , x , n ):
        step = math.sqrt(n)
        prev = 0
        while arr[int(min(step, n)-1)] < x:
                prev = step
                step += math.sqrt(n)
                if prev >= n:
                        return -1
        while arr[int(prev)] < x:
                prev += 1
                if prev == min(step, n):
                        return -1
        if arr[int(prev)] == x:
                return prev
        
        return -1","# Driver code to test function
arr = [ 0, 1, 1, 2, 3, 5, 8, 13, 21,
        34, 55, 89, 144, 233, 377, 610 ]
x = 55
n = len(arr)

# Find the index of 'x' using Jump Search
index = jumpSearch(arr, x, n)

# Print the index where 'x' is located
print(""Number"" , x, ""is at index"" ,""%.0f""%index)

# This code is contributed by ""Sharad_Bhardwaj"".",
"Given a sorted array of n uniformly distributed values arr[], write a function to search for a particular element x in the array. ","Input: arr[] = {10, 50, 30, 70, 80, 20, 90, 40} and key = 30
Output: Element is present at index 2",https://www.geeksforgeeks.org/interpolation-search/,Medium,[Searching Algorithm],"def interpolationSearch(arr, lo, hi, x):
        if (lo <= hi and x >= arr[lo] and x <= arr[hi]):
                pos = lo + ((hi - lo) // (arr[hi] - arr[lo]) *
                                        (x - arr[lo]))
                if arr[pos] == x:
                        return pos

                if arr[pos] < x:
                        return interpolationSearch(arr, pos + 1,
                                                                        hi, x)

                if arr[pos] > x:
                        return interpolationSearch(arr, lo,
                                                                        pos - 1, x)
        return -1","# Driver code


# Array of items in which
# search will be conducted
arr = [10, 12, 13, 16, 18, 19, 20,
        21, 22, 23, 24, 33, 35, 42, 47]
n = len(arr)

# Element to be searched
x = 18
index = interpolationSearch(arr, 0, n - 1, x)

if index != -1:
        print(""Element found at index"", index)
else:
        print(""Element not found"")

# This code is contributed by Hardik Jain",
"Ternary search is a decrease(by constant) and conquer algorithm that can be used to find an element in an array. It is similar to binary search where we divide the array into two parts but in this algorithm, we divide the given array into three parts and determine which has the key (searched element). We can divide the array into three parts by taking mid1 and mid2 which can be calculated as shown below. Initially, l and r will be equal to 0 and n-1 respectively, where n is the length of the array.  Write a program in python to implement Ternary Search","Input: arr[] = {10, 50, 30, 70, 80, 20, 90, 40} and key = 30
Output: Element is present at index 2",https://www.geeksforgeeks.org/ternary-search/,Easy,[Searching Algorithm],"
import math as mt
def ternarySearch(l, r, key, ar):
        if (r >= l):
                mid1 = l + (r - l) //3
                mid2 = r - (r - l) //3
                if (ar[mid1] == key): 
                        return mid1
                
                if (ar[mid2] == key): 
                        return mid2
                
                if (key < ar[mid1]): 
                        return ternarySearch(l, mid1 - 1, key, ar)
                
                elif (key > ar[mid2]): 
                        return ternarySearch(mid2 + 1, r, key, ar)
                
                else: 
                        return ternarySearch(mid1 + 1, 
                                                                mid2 - 1, key, ar)
        return -1","# Driver code
l, r, p = 0, 9, 5

# Get the array
# Sort the array if not sorted
ar = [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ]

# Starting index
l = 0

# end element index
r = 9

# Checking for 5

# Key to be searched in the array
key = 5

# Search the key using ternarySearch
p = ternarySearch(l, r, key, ar)

# Print the result
print(""Index of"", key, ""is"", p)

# Checking for 50

# Key to be searched in the array
key = 50

# Search the key using ternarySearch
p = ternarySearch(l, r, key, ar)

# Print the result
print(""Index of"", key, ""is"", p)

# This code is contributed by 
# Mohit kumar 29",
"Given an array with repeated elements, the task is to find the maximum distance between two occurrences of an element.","Input : arr[] = {3, 2, 1, 2, 1, 4, 5, 8, 6, 7, 4, 2}
Output: 10
// maximum distance for 2 is 11-1 = 10 
// maximum distance for 1 is 4-2 = 2 
// maximum distance for 4 is 10-5 = 5 ",https://www.geeksforgeeks.org/maximum-distance-two-occurrences-element-array/,Easy,[Hash],"def max_distance(arr): 
        n = len(arr) 
        max_d = -1
        for i in range(n - 1): 
                for j in range(i + 1, n): 
                        if arr[i] == arr[j]: 
                                temp = abs(j - i) 
                                max_d = max(max_d, temp) 
        return max_d ","# Driver code 
arr = [1, 2, 4, 1, 3, 4, 2, 5, 6, 5] 
print(""Maximum distance between two occurrences of same element in array:"", max_distance(arr)) ",
You are given an array of n-element. You have to make subsets from the array such that no subset contain duplicate elements. Find out minimum number of subset possible.,"Input : arr[] = {1, 2, 3, 4}
Output :1
Explanation : A single subset can contains all 
values and all values are distinct
Input : arr[] = {1, 2, 3, 3}
Output : 2
Explanation : We need to create two subsets
{1, 2, 3} and {3} [or {1, 3} and {2, 3}] such
that both subsets have distinct elements.",https://www.geeksforgeeks.org/minimum-number-subsets-distinct-elements/,Easy,[Hash],"def subset(ar, n):
 
    res = 0
 
    ar.sort()
    for i in range(0, n) :
        count = 1
 
        for i in range(n - 1):
            if ar[i] == ar[i + 1]:
                count+=1
            else:
                break
             
        res = max(res, count)
     
    return res"," 
# Driver code
ar = [ 5, 6, 9, 3, 4, 3, 4 ]
n = len(ar)
print(subset(ar, n))",
Given an arr[] containing n integers and a positive integer k. The problem is to find the longest subarray’s length with the sum of the elements divisible by the given value k.,"Input: arr[] = {2, 7, 6, 1, 4, 5}, k = 3
Output: 4
Explanation: The subarray is {7, 6, 1, 4} with sum 18, which is divisible by 3.

Input: arr[] = {-2, 2, -5, 12, -11, -1, 7}, k = 3
Output: 5",https://www.geeksforgeeks.org/longest-subarray-sum-divisible-k/,Medium,[Hash],"def longestSubarrWthSumDivByK(arr, N, k):
        maxl = 0
        for i in range(N):
                sum1 = 0
                for j in range(i, N):
                        sum1 += arr[j]
                        if sum1 % k == 0:
                                maxl = max(maxl, j - i + 1)
        return maxl","
# Driver code
arr = [2, 7, 6, 1, 4, 5]
n = len(arr)
k = 3

print(""Length ="", longestSubarrWthSumDivByK(arr, n, k))","# Python3 implementation to find the
# longest subarray with sum divisible by k

# Function to find the longest
# subarray with sum divisible by k


def longestSubarrWthSumDivByK(arr, n, k):

	# unordered map 'um' implemented
	# as hash table
	um = {}

	# 'mod_arr[i]' stores (sum[0..i] % k)
	mod_arr = [0 for i in range(n)]
	max_len = 0
	curr_sum = 0

	# Traverse arr[] and build up
	# the array 'mod_arr[]'
	for i in range(n):
		curr_sum += arr[i]

		# As the sum can be negative,
		# taking modulo twice
		mod_arr[i] = ((curr_sum % k) + k) % k

		# If true then sum(0..i) is
		# divisible by k
		if (mod_arr[i] == 0):

			# Update 'max_len'
			max_len = i + 1

		# If value 'mod_arr[i]' not present in
		# 'um' then store it in 'um' with index
		# of its first occurrence
		elif (mod_arr[i] not in um):
			um[mod_arr[i]] = i

		else:
			# If true, then update 'max_len'
			if (max_len < (i - um[mod_arr[i]])):
				max_len = i - um[mod_arr[i]]

	# Return the required length of longest subarray
	# with sum divisible by 'k'
	return max_len


# Driver Code
if __name__ == '__main__':

	arr = [2, 7, 6, 1, 4, 5]
	n = len(arr)
	k = 3

	print(""Length ="",
		longestSubarrWthSumDivByK(arr, n, k))

# This code is contributed by Surendra_Gangwar, updated by Kshitij Dwivedi"
"Given an array of size N and an integer K, return the count of distinct numbers in all windows of size K. ","Input: arr[] = {1, 2, 1, 3, 4, 2, 3}, K = 4
Output: 3 4 4 3
Explanation: First window is {1, 2, 1, 3}, count of distinct numbers is 3
                      Second window is {2, 1, 3, 4} count of distinct numbers is 4
                      Third window is {1, 3, 4, 2} count of distinct numbers is 4
                      Fourth window is {3, 4, 2, 3} count of distinct numbers is 3

Input: arr[] = {1, 2, 4, 4}, K = 2
Output: 2 2 1
Explanation: First window is {1, 2}, count of distinct numbers is 2
                      First window is {2, 4}, count of distinct numbers is 2
                      First window is {4, 4}, count of distinct numbers is 1",https://www.geeksforgeeks.org/count-distinct-elements-in-every-window-of-size-k/,Medium,[Hash],"import math as mt
def countWindowDistinct(win, K):
        dist_count = 0
        for i in range(K):
                j = 0
                while j < i:
                        if (win[i] == win[j]):
                                break
                        else:
                                j += 1
                if (j == i):
                        dist_count += 1

        return dist_count

def countDistinct(arr, N, K):
        for i in range(N - K + 1):
                print(countWindowDistinct(arr[i:K + i], K))","# Driver's Code
if __name__=='__main__':
arr = [1, 2, 1, 3, 4, 2, 3]
K = 4
N = len(arr)

# Function call
countDistinct(arr, N, K)

# This code is contributed by
# Mohit kumar 29",
"Given an array containing only 0s and 1s, find the largest subarray which contains equal no of 0s and 1s. The expected time complexity is O(n). ","Input: arr[] = {1, 0, 1, 1, 1, 0, 0}
Output: 1 to 6 
(Starting and Ending indexes of output subarray)

Input: arr[] = {1, 1, 1, 1}
Output: No such subarray

Input: arr[] = {0, 0, 1, 1, 0}
Output: 0 to 3 Or 1 to 4",https://www.geeksforgeeks.org/largest-subarray-with-equal-number-of-0s-and-1s/,Hard,[Hash],"def findSubArray(arr, n):
        sum = 0
        maxsize = -1
        for i in range(0, n-1):
        
                sum = -1 if(arr[i] == 0) else 1
                for j in range(i + 1, n):
                        sum = sum + (-1) if (arr[j] == 0) else sum + 1

                        if (sum == 0 and maxsize < j-i + 1):
                                
                                maxsize = j - i + 1
                                startindex = i
                        
                
        
        if (maxsize == -1):
                print(""No such subarray"");
        else:
                print(startindex, ""to"", startindex + maxsize-1);

        return maxsize","
# Driver program to test above functions
arr = [1, 0, 0, 1, 0, 1, 1]
size = len(arr)
findSubArray(arr, size)

# This code is contributed by Smitha Dinesh Semwal","# Python 3 program to find largest 
# subarray with equal number of 
# 0's and 1's. 

# Returns largest subarray with 
# equal number of 0s and 1s 
def maxLen(arr, n): 

	# NOTE: Dictionary in python in 
	# implemented as Hash Maps. 
	# Create an empty hash map (dictionary) 
	hash_map = {} 
	curr_sum = 0
	max_len = 0
	ending_index = -1

	for i in range (0, n): 
		if(arr[i] == 0): 
			arr[i] = -1
		else: 
			arr[i] = 1

	# Traverse through the given array 
	for i in range (0, n): 
	
		# Add current element to sum 
		curr_sum = curr_sum + arr[i] 

		# To handle sum = 0 at last index 
		if (curr_sum == 0): 
			max_len = i + 1
			ending_index = i 

		# If this sum is seen before, 
		if curr_sum in hash_map:
			
			# If max_len is smaller than new subarray
			# Update max_len and ending_index
			if max_len < i - hash_map[curr_sum]:
				max_len = i - hash_map[curr_sum]
				ending_index = i
		else: 

			# else put this sum in dictionary 
			hash_map[curr_sum] = i 
		
	for i in range (0, n): 
		if(arr[i] == -1): 
			arr[i] = 0
		else: 
			arr[i] = 1
			
	print (ending_index - max_len + 1, end ="" "")
	print (""to"", end = "" "")
	print (ending_index)

	return max_len

# Driver Code 
arr = [1, 0, 0, 1, 0, 1, 1] 
n = len(arr) 

maxLen(arr, n) 
	
# This code is contributed 
# by Tarun Garg"
"Given an array of n integers. Count the total number of sub-arrays having total distinct elements, the same as that of the total distinct elements of the original array. ","Input  : arr[] = {2, 1, 3, 2, 3}
Output : 5
Total distinct elements in array is 3
Total sub-arrays that satisfy the condition 
are:  Subarray from index 0 to 2
      Subarray from index 0 to 3
      Subarray from index 0 to 4
      Subarray from index 1 to 3
      Subarray from index 1 to 4

Input  : arr[] = {2, 4, 5, 2, 1}
Output : 2

Input  : arr[] = {2, 4, 4, 2, 4}
Output : 9",https://www.geeksforgeeks.org/count-subarrays-total-distinct-elements-original-array/,Hard,[Hash],"
def countDistictSubarray(arr, n):
        unst1 = set(arr)
        totalDist = len(unst1)
        count = 0

        for i in range(n):
                unst = set()
                for j in range(i, n):
                        unst.add(arr[j])
                        if len(unst) == totalDist:
                                count += 1

        return count","
# Driver code
arr = [2, 1, 3, 2, 3]
n = len(arr)

print(countDistictSubarray(arr, n))
# This code is contributed by Prajwal Kandekar","# Python3 program Count total number of 
# sub-arrays having total distinct elements 
# same as that original array.

# Function to calculate distinct sub-array
def countDistictSubarray(arr, n):

	# Count distinct elements in whole array
	vis = dict()
	for i in range(n):
		vis[arr[i]] = 1
	k = len(vis)

	# Reset the container by removing
	# all elements
	vid = dict()

	# Use sliding window concept to find
	# count of subarrays having k distinct
	# elements.
	ans = 0
	right = 0
	window = 0
	for left in range(n):
	
		while (right < n and window < k):

			if arr[right] in vid.keys():
				vid[ arr[right] ] += 1
			else:
				vid[ arr[right] ] = 1

			if (vid[ arr[right] ] == 1):
				window += 1

			right += 1
		
		# If window size equals to array distinct 
		# element size, then update answer
		if (window == k):
			ans += (n - right + 1)

		# Decrease the frequency of previous 
		# element for next sliding window
		vid[ arr[left] ] -= 1

		# If frequency is zero then decrease 
		# the window size
		if (vid[ arr[left] ] == 0):
			window -= 1
	
	return ans

# Driver code
arr = [2, 1, 3, 2, 3]
n = len(arr)

print(countDistictSubarray(arr, n))

# This code is contributed by
# mohit kumar 29"
"A rotation (or circular shift) is an operation similar to shift except that the bits that fall off at one end are put back to the other end. In left rotation, the bits that fall off at left end are put back at right end. In right rotation, the bits that fall off at right end are put back at left end. Write a program to rotate the bits of a number","Let n is stored using 8 bits. Left rotation of n = 11100101 by 3 makes n = 00101111 (Left shifted by 3 and first 3 bits are put back in last ). If n is stored using 16 bits or 32 bits then left rotation of n (000…11100101) becomes 00..0011100101000. 
Right rotation of n = 11100101 by 3 makes n = 10111100 (Right shifted by 3 and last 3 bits are put back in first ) if n is stored using 8 bits. If n is stored using 16 bits or 32 bits then right rotation of n (000…11100101) by 3 becomes 101000..0011100. ",https://www.geeksforgeeks.org/rotate-bits-of-an-integer/,Easy,[Bitwise Algorithms],"

INT_BITS = 32
def leftRotate(n, d):
        return (n << d)|(n >> (INT_BITS - d))

def rightRotate(n, d):
        return (n >> d)|(n << (INT_BITS - d)) & 0xFFFFFFFF","# Driver program to
# test above functions 
n = 16
d = 2

print(""Left Rotation of"",n,""by""
        ,d,""is"",end="" "")
print(leftRotate(n, d))

print(""Right Rotation of"",n,""by""
        ,d,""is"",end="" "")
print(rightRotate(n, d))

# This code is contributed by
# Smitha Dinesh Semwal","SHORT_SIZE = 16

# function to rotate the given unsigned short
# in the left direction
def leftRotate(x, d):

	return (x << d) | (x >> (SHORT_SIZE - d))

# function to rotate the given unsigned short
# in the right direction
def rightRotate(x, d):

	return (x >> d) | (x << (SHORT_SIZE - d)) & 0xDDDDDF

# Driver program to test above functions
# Test case
n = 28
d = 2

print(""Left Rotation of"",n,""by""
	,d,""is"",end="" "")
print(leftRotate(n, d))

print(""Right Rotation of"",n,""by""
	,d,""is"",end="" "")
print(rightRotate(n, d))

# This code is contributed by shivanisinghss2110"
"Given a positive integer n, write a function to find if it is a power of 2 or not","Input : n = 4
Output : Yes
Explanation: 22 = 4

Input : n = 32
Output : Yes
Explanation: 25 = 32",https://www.geeksforgeeks.org/program-to-find-whether-a-given-number-is-power-of-2/,Easy,[Bitwise Algorithms],"import math

def Log2(x):
        if x == 0:
                return false

        return (math.log10(x) /
                        math.log10(2))

def isPowerOfTwo(n):
        return (math.ceil(Log2(n)) ==
                        math.floor(Log2(n)))","# Driver Code
if __name__ == ""__main__"":

        # Function call
        if(isPowerOfTwo(31)):
                print(""Yes"")
        else:
                print(""No"")

        if(isPowerOfTwo(64)):
                print(""Yes"")
        else:
                print(""No"")

# This code is contributed
# by mits","# Python program to check if given
# number is power of 2 or not

# Function to check if x is power of 2


def isPowerOfTwo(n):
	if (n == 0):
		return False
	while (n != 1):
		if (n % 2 != 0):
			return False
		n = n // 2

	return True


# Driver code
if __name__ == ""__main__"":

	# Function call
	if(isPowerOfTwo(31)):
		print('Yes')
	else:
		print('No')
	if(isPowerOfTwo(64)):
		print('Yes')
	else:
		print('No')

# This code is contributed by Danish Raza"
"Given a number x and two positions (from the right side) in the binary representation of x, write a function that swaps n bits at the given two positions and returns the result. It is also given that the two sets of bits do not overlap.","Input:
x = 47 (00101111)
p1 = 1 (Start from the second bit from the right side)
p2 = 5 (Start from the 6th bit from the right side)
n = 3 (No of bits to be swapped)
Output:
227 (11100011)
The 3 bits starting from the second bit (from the right side) are 
swapped with 3 bits starting from 6th position (from the right side)",https://www.geeksforgeeks.org/swap-bits-in-a-given-number/,Medium,[Bitwise Algorithms],"def swapBits(x, p1, p2, n):
        set1 = (x >> p1) & ((1<< n) - 1)
        set2 = (x >> p2) & ((1 << n) - 1)

        xor = (set1 ^ set2)
        xor = (xor << p1) | (xor << p2)
        result = x ^ xor

        return result","# Driver code

res = swapBits(28, 0, 3, 2)
print(""Result ="", res)

# This code is contributed
# by Anant Agarwal.","# Python code to implement the approach
def swapBits(x, p1, p2, n) :
	
	# xor contains xor of two sets 
	xor = (((x >> p1) ^ (x >> p2)) & ((1 << n) - 1))

	# To swap two sets, we need to again XOR the xor with original sets 
	return x ^ ( (xor << p1) | (xor << p2))

# This code is contributed by sanjoy_62."
"Given an integer ‘x’, write a python function that returns true if binary representation of x is palindrome else return false.",For example a numbers with binary representation as 10..01 is palindrome and number with binary representation as 10..00 is not palindrome.,https://www.geeksforgeeks.org/check-binary-representation-number-palindrome/,Medium,[Bitwise Algorithms],"
import sys
def isKthBitSet(x, k):
        if ((x & (1 << (k - 1))) !=0):
                return True
        else:
                return False
def isPalindrome(x):
        l = 1 
        r = 2 * 8 
        while (l < r):
                if (isKthBitSet(x, l) != isKthBitSet(x, r)):
                        return False
                l += 1
                r -= 1
        
        return True","# Driver Code
if __name__ =='__main__':
        x = 1 << 15 + 1 << 16
        print(int(isPalindrome(x)))
        x = 1 << 31 + 1
        print(int(isPalindrome(x)))

# This code is contributed by
# Surendra_Gangwar","def bin(n):
	ans=""""; 
	while n > 0:
		ans = (str(n&1)) + ans;
		n >>= 1; 
	return ans; 

def checkPalindrome(x):
	s1 = bin(x)
	s2 = s1[::-1]
	return 1 if s1 == s2 else 0

# Some test cases....
x = 9; 
print(checkPalindrome(x)) # output 1 

x = 10
print(checkPalindrome(x)) # output 0"
Given an array of integers. The task is to find the maximum subarray XOR value in the given array.,"Input: arr[] = {1, 2, 3, 4}
Output: 7
Explanation: The subarray {3, 4} has maximum XOR value

Input: arr[] = {8, 1, 2, 12, 7, 6}
Output: 15
Explanation: The subarray {1, 2, 12} has maximum XOR value",https://www.geeksforgeeks.org/find-the-maximum-subarray-xor-in-a-given-array/,Hard,[Bitwise Algorithms],"def maxSubarrayXOR(arr,n):

        ans = -2147483648

        for i in range(n):
                curr_xor = 0
                for j in range(i,n):
                
                        curr_xor = curr_xor ^ arr[j]
                        ans = max(ans, curr_xor)
        return ans","# Driver code

arr = [8, 1, 2, 12]
n = len(arr)

print(""Max subarray XOR is "",
        maxSubarrayXOR(arr, n))

# This code is contributed
# by Anant Agarwal.","""""""Python implementation for a Trie based solution
to find max subArray XOR""""""

# Structure of Trie Node
class Node:

	def __init__(self, data):

		self.data = data
		
		# left node for 0
		self.left = None
		
		# right node for 1
		self.right = None

# Class for implementing Trie
class Trie:

	def __init__(self):

		self.root = Node(0)

	# Insert pre_xor to trie with given root
	def insert(self, pre_xor):

		self.temp = self.root

		# Start from msb, insert all bits of pre_xor
		# into the Trie
		for i in range(31, -1, -1):

			# Find current bit in prefix sum
			val = pre_xor & (1<<i)

			if val :
				
				# Create new node if needed
				if not self.temp.right:
					self.temp.right = Node(0)
				self.temp = self.temp.right

			if not val:
				
				# Create new node if needed
				if not self.temp.left:
					self.temp.left = Node(0)
				self.temp = self.temp.left

		# Store value at leaf node
		self.temp.data = pre_xor

	# Find the maximum xor ending with last number
	# in prefix XOR and return the XOR of this
	def query(self, xor):

		self.temp = self.root

		for i in range(31, -1, -1):

			# Find the current bit in prefix xor
			val = xor & (1<<i)

			# Traverse the trie, first look for opposite bit
			# and then look for same bit
			if val:
				if self.temp.left:
					self.temp = self.temp.left
				elif self.temp.right:
					self.temp = self.temp.right
			else:
				if self.temp.right:
					self.temp = self.temp.right
				elif self.temp.left:
					self.temp = self.temp.left

		return xor ^ self.temp.data

	# Returns maximum XOR value of subarray
	def maxSubArrayXOR(self, n, Arr):

		# Insert 0 in the trie
		self.insert(0)

		# Initialize result and pre_xor
		result = -float('inf')
		pre_xor = 0

		# Traverse all input array element
		for i in range(n):

			# Update current prefix xor and 
			# insert it into Trie
			pre_xor = pre_xor ^ Arr[i]
			self.insert(pre_xor)

			# Query for current prefix xor
			# in Trie and update result
			result = max(result, self.query(pre_xor))

		return result

# Driver code
if __name__ == ""__main__"":

	Arr = [8, 1, 2, 12]
	n = len(Arr)
	trie = Trie()
	print(""Max subarray XOR is"", end = ' ')
	print(trie.maxSubArrayXOR(n, Arr))

# This code is contributed by chaudhary_19"
Write a function to to convert a floating point number to binary,"Enter your floating point value : 
11.234
Enter the number of decimal places of the result : 
4

1011.0011

Enter your floating point value : 
1.234
Enter the number of decimal places of the result :
4

1.0011",https://www.geeksforgeeks.org/python-program-to-convert-floating-to-binary/,Hard,[Bitwise Algorithms],"def float_bin(number, places = 3):
        whole, dec = str(number).split(""."")
        whole = int(whole)
        dec = int (dec)
        res = bin(whole).lstrip(""0b"") + "".""
        for x in range(places):
                whole, dec = str((decimal_converter(dec)) * 2).split(""."")
                dec = int(dec)
                res += whole
        return res

def decimal_converter(num): 
        while num > 1:
                num /= 10
        return num","# Driver Code

# Take the user input for 
# the floating point number
n = input(""Enter your floating point value : \n"")

# Take user input for the number of
# decimal places user want result as
p = int(input(""Enter the number of decimal places of the result : \n""))

print(float_bin(n, places = p))",
"An interval is represented as a combination of start time and end time. Given a set of intervals, check if any two intervals intersect. ","Input:  arr[] = {{1, 3}, {5, 7}, {2, 4}, {6, 8}}
Output: true
The intervals {1, 3} and {2, 4} overlap


Input:  arr[] = {{1, 3}, {7, 9}, {4, 6}, {10, 13}}
Output: false
No pair of intervals overlap. ",https://www.geeksforgeeks.org/check-if-any-two-intervals-overlap-among-a-given-set-of-intervals/,Easy,[Sorting Algorithms],"class Interval:
        def __init__(self, start, end):
                self.start = start
                self.end = end

def isIntersect(arr, n):
        arr.sort(key=lambda x: x.start)
        for i in range(1, n):
                if (arr[i - 1].end > arr[i].start):
                        return True
        return False","# Driver code
arr1 = [Interval(1, 3), Interval(7, 9), Interval(4, 6), Interval(10, 13)]
n1 = len(arr1)
if (isIntersect(arr1, n1)):
        print(""Yes"")
else:
        print(""No"")

arr2 = [Interval(6, 8), Interval(1, 3), Interval(2, 4), Interval(4, 7)]
n2 = len(arr2)

if (isIntersect(arr2, n2)):
        print(""Yes"")
else:
        print(""No"")

# This code is contributed by Saurabh Jaiswal","# A Python program to check if any two intervals overlap

# An interval has start time and end time
class Interval:
	def __init__(self, start, end):
		self.start = start
		self.end = end

# Function to check if any two intervals overlap
def is_intersect(arr, n):
	max_ele = 0

	# Find the overall maximum element
	for i in range(n):
		if max_ele < arr[i].end:
			max_ele = arr[i].end

	# Initialize an array of size max_ele
	aux = [0] * (max_ele + 1)
	for i in range(max_ele + 1):
		aux[i] = 0
	for i in range(n):
	
		# starting point of the interval
		x = arr[i].start
		
		# end point of the interval
		y = arr[i].end
		aux[x] += 1
		aux[y] -= 1
	for i in range(1, max_ele + 1):
	
		# Calculating the prefix Sum
		aux[i] += aux[i - 1]
		
		# Overlap
		if aux[i] > 1:
			return True
		
	# If we reach here, then no Overlap
	return False

# Driver program
arr1 = [Interval(1, 3), Interval(7, 9), Interval(4, 6), Interval(10, 13)]
n1 = len(arr1)
if is_intersect(arr1, n1):
	print(""Yes"")
else:
	print(""No"")

arr2 = [Interval(6, 8), Interval(1, 3), Interval(2, 4), Interval(4, 7)]
n2 = len(arr2)
if is_intersect(arr2, n2):
	print(""Yes"")
else:
	print(""No"")

	
# this code is contributed by phasing17"
"We are given an array of n distinct numbers. The task is to sort all even-placed numbers in increasing and odd-placed numbers in decreasing order. The modified array should contain all sorted even-placed numbers followed by reverse sorted odd-placed numbers.

Note that the first element is considered as even placed because of its index 0. ","Input:  arr[] = {0, 1, 2, 3, 4, 5, 6, 7}
Output: arr[] = {0, 2, 4, 6, 7, 5, 3, 1}
Even-place elements : 0, 2, 4, 6
Odd-place elements : 1, 3, 5, 7
Even-place elements in increasing order : 
0, 2, 4, 6
Odd-Place elements in decreasing order : 
7, 5, 3, 1

Input: arr[] = {3, 1, 2, 4, 5, 9, 13, 14, 12}
Output: {2, 3, 5, 12, 13, 14, 9, 4, 1}
Even-place elements : 3, 2, 5, 13, 12
Odd-place elements : 1, 4, 9, 14
Even-place elements in increasing order : 
2, 3, 5, 12, 13
Odd-Place elements in decreasing order : 
14, 9, 4, 1 ",https://www.geeksforgeeks.org/sort-even-placed-elements-increasing-odd-placed-decreasing-order/,Easy,[Sorting Algorithms],"
def bitonicGenerator(arr, n): 
        evenArr = [] 
        oddArr = [] 
        for i in range(n): 
                if ((i % 2) == 0): 
                        evenArr.append(arr[i]) 
                else: 
                        oddArr.append(arr[i]) 
        evenArr = sorted(evenArr) 
        oddArr = sorted(oddArr) 
        oddArr = oddArr[::-1] 

        i = 0
        for j in range(len(evenArr)): 
                arr[i] = evenArr[j] 
                i += 1
        for j in range(len(oddArr)): 
                arr[i] = oddArr[j] 
                i += 1","# Driver Code 
arr = [1, 5, 8, 9, 6, 7, 3, 4, 2, 0] 
n = len(arr) 
bitonicGenerator(arr, n) 
for i in arr: 
        print(i, end = "" "") 

# This code is contributed by Mohit Kumar ","# Python3 Program to sort even-placed elements in increasing and 
# odd-placed in decreasing order with constant space complexity 
def bitonicGenerator(arr, n): 

	# first odd index 
	i = 1

	# last index 
	j = n - 1
	
	# if last index is odd 
	if (j % 2 != 0): 
		
		# decrement j to even index 
		j = j - 1
		
	# swapping till half of array 
	while (i < j) : 
		arr[j], arr[i] = arr[i], arr[j] 
		i = i + 2
		j = j - 2
		
	arr_f = [] 
	arr_s = [] 
	
	for i in range(int((n + 1) / 2)) : 
		arr_f.append(arr[i]) 
	
	i = int((n + 1) / 2) 
	while( i < n ) : 
		arr_s.append(arr[i]) 
		i = i + 1
	
	# Sort first half in increasing 
	arr_f.sort() 

	# Sort second half in decreasing 
	arr_s.sort(reverse = True) 
	
	for i in arr_s: 
		arr_f.append(i) 
	
	return arr_f 

# Driver Program 
arr = [ 1, 5, 8, 9, 6, 7, 3, 4, 2, 0] 
n = len(arr) 
arr = bitonicGenerator(arr, n) 
print(arr) 

# This code is contributed by Arnab Kundu "
"Given an array of N elements, where each element is at most K away from its target position, devise an algorithm that sorts it","Input: arr[] = {6, 5, 3, 2, 8, 10, 9}, K = 3 
Output: arr[] = {2, 3, 5, 6, 8, 9, 10}

Input: arr[] = {10, 9, 8, 7, 4, 70, 60, 50}, k = 4
Output: arr[] = {4, 7, 8, 9, 10, 50, 60, 70}",https://www.geeksforgeeks.org/nearly-sorted-algorithm/,Medium,[Sorting Algorithms],"def insertionSort(A, size):
        i, key, j = 0, 0, 0
        for i in range(size):
                key = A[i]
                j = i-1
                while j >= 0 and A[j] > key:
                        A[j + 1] = A[j]
                        j = j - 1
                A[j + 1] = key",,"def sortNearlySortedArray(A, size, k):
	for i in range(1, size):
		key = A[i]
		j = i - 1

		# Check if the previous element is greater than the current
		# element, and shift elements to the right until the correct
		# position is found, but only if the current element is more
		# than k positions away from its correct position
		while j >= max(0, i - k) and A[j] > key:
			A[j + 1] = A[j]
			j -= 1
		A[j + 1] = key

	for i in range(size):
		print(A[i], end=' ')

	print()

# Driver Code
A = [2, 6, 3, 12, 56, 8]
size = 6
k = 3
sortNearlySortedArray(A, size, k)"
"Given two arrays that have the same values but in a different order and having no duplicate elements in it, we need to make a second array the same as a first array using the minimum number of swaps. ","Input  : arrA[] = {3, 6, 4, 8}, 
         arrB[] = {4, 6, 8, 3}
Output : 2
Explanation: we can make arrB to same as arrA in 2 swaps which are shown below, swap 4 with 8,
arrB = {8, 6, 4, 3} swap 8 with 3,   arrB = {3, 6, 4, 8}",https://www.geeksforgeeks.org/minimum-swaps-to-make-two-array-identical/,Medium,[Sorting Algorithms],"def minSwapsToSort(arr, n): 
        arrPos = [[0 for x in range(2)] 
                                for y in range(n)] 
        
        for i in range(n):         
                arrPos[i][0] = arr[i] 
                arrPos[i][1] = i 
        arrPos.sort() 
        vis = [False] * (n) 
        ans = 0

        for i in range(n): 
                if (vis[i] or arrPos[i][1] == i): 
                        continue
                cycle_size = 0
                j = i 
                
                while (not vis[j]):                 
                        vis[j] = 1
                        j = arrPos[j][1] 
                        cycle_size+= 1
                ans += (cycle_size - 1) 

        return ans 

def minSwapToMakeArraySame(a, b, n): 
        mp = {} 
        for i in range(n): 
                mp[b[i]] = i 
        for i in range(n): 
                b[i] = mp[a[i]] 
        return minSwapsToSort(b, n) ","# Driver code 
if __name__ == ""__main__"": 

        a = [3, 6, 4, 8] 
        b = [4, 6, 8, 3] 
        n = len(a) 
        print(minSwapToMakeArraySame(a, b, n)) 

# This code is contributed by Chitranayal",
"Given a two strings S and T, find the count of distinct occurrences of T in S as a subsequence.","Input: S = banana, T = ban
Output: 3
Explanation: T appears in S as below three subsequences.
[ban], [ba  n], [b   an]

Input: S = geeksforgeeks, T = ge
Output: 6
Explanation: T appears in S as below six subsequences.
[ge], [     ge], [g e], [g    e] [g     e]
and [     g e] ",https://www.geeksforgeeks.org/count-distinct-occurrences-as-a-subsequence/,Hard,[Sorting Algorithms],"def f(i, j, s, t):
        if(j >= len(t)):
                return 1
        
        if(i >= len(s)):
                return 0
        
        if(s[i] == t[j]):
                return f(i + 1, j + 1, s, t) + f(i + 1, j, s, t)
        
        return f(i + 1, j, s, t)

def findSubsequenceCount(s, t):
        return f(0, 0, s, t)","# Driver code to check above method
T = ""ge""
S = ""geeksforgeeks""
print(findSubsequenceCount(S,T))

# This code is contributed by Aman Kumar.","# Python3 program to count number of times 
# S appears as a subsequence in T
def findSubsequenceCount(S, T):

	m = len(T)
	n = len(S)

	# T can't appear as a subsequence in S
	if m > n:
		return 0

	# mat[i][j] stores the count of 
	# occurrences of T(1..i) in S(1..j).
	mat = [[0 for _ in range(n + 1)]
			for __ in range(m + 1)]

	# Initializing first column with all 0s. x
	# An empty string can't have another
	# string as subsequence
	for i in range(1, m + 1):
		mat[i][0] = 0

	# Initializing first row with all 1s. 
	# An empty string is subsequence of all.
	for j in range(n + 1):
		mat[0][j] = 1

	# Fill mat[][] in bottom up manner
	for i in range(1, m + 1):
		for j in range(1, n + 1):

			# If last characters don't match, 
			# then value is same as the value 
			# without last character in S.
			if T[i - 1] != S[j - 1]:
				mat[i][j] = mat[i][j - 1]
				
			# Else value is obtained considering two cases.
			# a) All substrings without last character in S
			# b) All substrings without last characters in
			# both.
			else:
				mat[i][j] = (mat[i][j - 1] +
							mat[i - 1][j - 1])

	return mat[m][n]

# Driver Code
if __name__ == ""__main__"":
	T = ""ge""
	S = ""geeksforgeeks""
	print(findSubsequenceCount(S, T))

# This code is contributed 
# by vibhu4agarwal"
"Given an array arr[] of size ‘n’ and a positive integer k. Consider series of natural numbers and remove arr[0], arr[1], arr[2], …, arr[p] from it. Now the task is to find k-th smallest number in the remaining set of natural numbers. If no such number exists print “-1”.","Input : arr[] = { 1 } and k = 1.
Output: 2
Natural numbers are {1, 2, 3, 4, .... }
After removing {1}, we get {2, 3, 4, ...}.
Now, K-th smallest element = 2.
Input : arr[] = {1, 3}, k = 4.
Output : 6
First 5 Natural number {1, 2, 3, 4, 5, 6,  .. }
After removing {1, 3}, we get {2, 4, 5, 6, ... }.",https://www.geeksforgeeks.org/k-th-smallest-element-removing-integers-natural-numbers/,Hard,[Sorting Algorithms],"MAX = 1000000
def ksmallest(arr, n, k):
        b = [0]*MAX;
        for i in range(n):
                b[arr[i]] = 1;

        for j in range(1, MAX):
                if (b[j] != 1):
                        k-= 1;
                if (k is not 1):
                        return j;","k = 1;
arr = [ 1 ];
n = len(arr);
print(ksmallest(arr, n, k));

# This code contributed by Rajput-Ji","# Python3 program to find the Kth 
# smallest element after 
# removing some integer from 
# first n natural number.

# Return the K-th 
# smallest element.
def ksmallest(arr, n, k):

	arr.sort();

	# Checking if k lies
	# before 1st element
	if (k < arr[0]):
		return k;

	# If k is the first 
	# element of array arr[].
	if (k == arr[0]):
		return arr[0] + 1;

	# If k is more 
	# than last element
	if (k > arr[n - 1]):
		return k + n;

	# If first element 
	# of array is 1.
	if (arr[0] == 1):
		k-= 1;

	# Reducing k by numbers
	# before arr[0].
	else:
		k -= (arr[0] - 1);

	# Finding k'th smallest element 
	# after removing array elements.
	for i in range(1, n):
		# Finding count of element between 
		# i-th and (i-1)-th element.
		c = arr[i] - arr[i - 1] - 1;
		if (k <= c):
			return arr[i - 1] + k;
		else:
			k -= c;

	return arr[n - 1] + k;

# Driver Code
k = 1;
arr =[ 1 ];
n = len(arr);
print(ksmallest(arr, n, k));

# This code is contributed by mits"