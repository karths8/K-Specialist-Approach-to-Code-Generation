Question,Examples,Code,Categories,Link for ref (if any),Assert Statement 1
Given an array reorder it so that even numbers appear first,"Input: [1,2,3,4,5,6,7,8,9]
Output: [8,2,6,4,5,7,3,9,1]","def even_odd_reorder(arr: list):
  nextEven = 0
  nextOdd = len(arr) - 1
  while nextEven < nextOdd:
    if arr[nextEven] % 2 == 0:
      nextEven += 1
    else:
      temp = arr[nextEven]
      arr[nextEven] = arr[nextOdd]
      arr[nextOdd] = temp
      nextOdd -= 1
  return arr","['array', 'sorting']",,"assert even_odd_reorder([1,2,3,4,5,6,7,8,9]) == [8, 2, 6, 4, 5, 7, 3, 9, 1]"
Given an array with 3 different values sort the array,DITCH,"def dutch_flag_partition(arr: list):
  def swap(i,j):
    tmp = arr[i]
    arr[i] = arr[j]
    arr[j] = tmp
  min_val = min(arr)
  max_val = max(arr)
  mid = None
  for i in range(len(arr)):
    if arr[i] > min_val and arr[i] < max_val:
      mid = arr[i]
      break
  smaller = 0
  for i in range(len(arr)):
    if arr[i] < mid:
      swap(smaller,i)
      smaller += 1
  larger = len(arr) - 1
  for j in range(len(arr) - 1, 0, -1):
    if arr[j] < mid:
      break
    elif arr[j] > mid:
      swap(larger,j)
      larger -= 1
  return arr","['array', 'sorting']",,"assert dutch_flag_partition([1, 1, 1, 1, 0, 2, 1, 1, 1, 2])[:-1] <= dutch_flag_partition([1, 1, 1, 1, 0, 2, 1, 1, 1, 2])[1:]"
Given two arrays return an array with the set intersection of their common elements,"Input: arr1 = [1, 2, 3, 4], arr2 = [2, 3]
Output: [2, 3]","def array_intersection(arr1: list, arr2: list):
  set1 = set(arr1)
  ret = set([x for x in arr2 if x in set1])
  return list(ret)",['array'],,"assert set(array_intersection([1,0,2,0,2,0,2,1,1,1], [2,1,0,2,0,2,2,2,1,0])) == {0,1,2}"
"Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the result must appear as many times as it shows in both arrays and you may return the result in any order.",,"def array_intersection_with_freq(arr1: list, arr2: list):
  freq = dict()
  ret = []
  for num in arr1:
      if num in freq.keys():
          freq[num] = freq[num]+1
      else:
          freq[num] = 1
  for num in arr2:
      if num in freq.keys() and freq[num] > 0:
          ret.append(num)
          freq[num] = freq[num] - 1
  return ret",['array'],,"assert array_intersection_with_freq([1,0,2,0,2,0,2,1,1,1], [2,1,0,2,0,2,2,2,1,0]) == [2, 1, 0, 2, 0, 2, 1, 0]"
"You are given two 0-indexed integer permutations A and B of length n.

A prefix common array of A and B is an array C such that C[i] is equal to the count of numbers that are present at or before the index i in both A and B.

Return the prefix common array of A and B.

A sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once.","Input: A = [1,3,2,4], B = [3,1,2,4]
Output: [0,2,3,4]","def findThePrefixCommonArray(arr1: list, arr2: list):
  max = len(arr1) if len(arr1) > len(arr2) else len(arr2)
  seen = set()
  curCount = 0
  ret = []
  for i in range(max):
    cur1 = arr1[i]
    cur2 = arr2[i]
    if cur1 in seen:
      curCount += 1
    else:
      seen.add(cur1)
    if cur2 in seen:
      curCount += 1
    else:
      seen.add(cur2)
    ret.append(curCount)
  return ret",['array'],https://leetcode.com/problems/find-the-prefix-common-array-of-two-arrays/,"assert findThePrefixCommonArray([1,3,2,4], [3,1,2,4]) == [0,2,3,4]"
Given a N*N board with the Knight placed on the first block of an empty board. Moving according to the rules of chess knight must visit each square exactly once. Return the order of each cell in which they are visited as a matrix or none if one does not exist.,"Input : 
N = 8
Output:
0  59  38  33  30  17   8  63
37  34  31  60   9  62  29  16
58   1  36  39  32  27  18   7
35  48  41  26  61  10  15  28
42  57   2  49  40  23   6  19
47  50  45  54  25  20  11  14
56  43  52   3  22  13  24   5
51  46  55  44  53   4  21  12","def isSafe(x, y, board, n): 
  if(x >= 0 and y >= 0 and x < n and y < n and board[x][y] == -1): 
    return True
  return False

def solveKT(n): 
  board = [[-1 for i in range(n)]for i in range(n)]
  move_x = [2, 1, -1, -2, -2, -1, 1, 2] 
  move_y = [1, 2, 2, 1, -1, -2, -2, -1] 
  board[0][0] = 0 
  pos = 1
  if(not solveKTUtil(n, board, 0, 0, move_x, move_y, pos)): 
      return None
  else: 
      return board 
  
  
def solveKTUtil(n, board, curr_x, curr_y, move_x, move_y, pos): 
  if(pos == n**2): 
    return True
  for i in range(8): 
    new_x = curr_x + move_x[i] 
    new_y = curr_y + move_y[i] 
    if(isSafe(new_x, new_y, board, n)): 
      board[new_x][new_y] = pos 
      if(solveKTUtil(n, board, new_x, new_y, move_x, move_y, pos+1)): 
        return True
      board[new_x][new_y] = -1
  return False","['backtracking', 'matrix/grid']",https://www.geeksforgeeks.org/the-knights-tour-problem/,"assert solveKT(8) == [[0,59,38,33,30,17, 8,63 ],
[37,34,31,60, 9,62,29,16],
[58, 1,36,39,32,27,18, 7],
[35,48,41,26,61,10,15,28],
[42,57, 2,49,40,23, 6,19],
[47,50,45,54,25,20,11,14],
[56,43,52, 3,22,13,24, 5],
[51,46,55,44,53, 4,21,12]]"
"A Maze is given as N*N binary matrix of blocks where source block is maze[0][0] and destination block is maze[N-1][N-1]. 
A rat starts from source and has to reach the destination. The rat can move only in two directions: forward and down. 

In the maze matrix, 0 means the block is a dead end and 1 means the block can be used in the path from source to destination. 
Given an N*N input maze Output a N*N matrix where all entries in the solution path are marked as 1 or output None if no solution exists.",DITCH,"def isValid(n, maze, x, y, res):
  if x >= 0 and y >= 0 and x < n and y < n and maze[x][y] == 1 and res[x][y] == 0:
    return True
  return False

def RatMaze(n, maze, move_x, move_y, x, y, res):
  if x == n-1 and y == n-1:
    return True
  for i in range(4):
    x_new = x + move_x[i]
    y_new = y + move_y[i]
    if isValid(n, maze, x_new, y_new, res):
      res[x_new][y_new] = 1
      if RatMaze(n, maze, move_x, move_y, x_new, y_new, res):
          return True
      res[x_new][y_new] = 0
  return False
 
def solveMaze(maze):
  n = len(maze)
  res = [[0 for i in range(n)] for i in range(n)]
  res[0][0] = 1
  move_x = [-1, 1, 0, 0]
  move_y = [0, 0, -1, 1]
  if RatMaze(n, maze, move_x, move_y, 0, 0, res):
    return res
  else:
    return None","['backtracking', 'matrix/grid']",https://www.geeksforgeeks.org/rat-in-a-maze/?ref=lbp,"assert solveMaze([[1, 0, 0, 0],[1, 1, 0, 1],[0, 1, 0, 0],[1, 1, 1, 1]]) == [[1, 0, 0, 0], [1, 1, 0, 0], [0, 1, 0, 0], [0, 1, 1, 1]]"
"Given an input N for a NxN chessboard place N queens such that no two queens attack each other. Return the NxN board with the Queens marked as Q. If the problem is not solvable return Solution does not exist
",DITCH,"def isSafe(board, row, col):
  for i in range(col):
    if board[row][i] == ""Q"":
      return False
  for i, j in zip(range(row, -1, -1), range(col, -1, -1)):
    if board[i][j] == ""Q"":
      return False
  for i, j in zip(range(row, len(board), 1), range(col, -1, -1)):
    if board[i][j] == ""Q"":
      return False

  return True
 
def solveNQUtil(board, col):
  if col >= len(board):
    return True
  for i in range(len(board)):
    if isSafe(board, i, col):
      board[i][col] = ""Q""
      if solveNQUtil(board, col + 1) == True:
        return True
      board[i][col] = '.'
  return False

def solveNQ(N):
  board = []
  for row in range(N):
    board.append(['.']*N)
  if solveNQUtil(board, 0) == False:
    return None
  return board","['backtracking', 'matrix/grid']",https://www.geeksforgeeks.org/n-queen-problem-backtracking-3/,"assert solveNQ(4) == [['.', '.', 'Q', '.'], ['Q', '.', '.', '.'], ['.', '.', '.', 'Q'], ['.', 'Q', '.', '.']]"
"Given a set[] of non-negative integers and a value sum, return the subset of the given set whose sum is equal to the given sum or None if one doesn't exist
","Input: set = [1, 2, 3, 4, 5], sum = 10
Output: [1, 2, 3, 4]","def subsetSum_helper(cur_idx: int, fullset: list, target_sum: int, subset: list):
  if target_sum == 0:
    return subset

  if (cur_idx == len(fullset)):
    return None
  
  excluding = subsetSum_helper(cur_idx + 1, fullset, target_sum, subset)
  if excluding is not None:
    return excluding
  elif fullset[cur_idx] <= target_sum:
    subset.append(fullset[cur_idx])
    including = subsetSum_helper(cur_idx + 1, fullset, target_sum - fullset[cur_idx], subset)
    if including is not None:
      return including
    else:
      subset.pop()
  return None

def subsetsum(fullset: list, target_sum: int):
  return subsetSum_helper(0, fullset, target_sum, [])","['backtracking', 'recursion']",https://www.geeksforgeeks.org/subset-sum-problem-dp-25/,"assert set(subsetsum([3, 34, 4, 12, 5, 2], 9)) == set([4,5])"
"Given an undirected graph in the form of an adjacency matrix and a number m, color the graph with m colors such that no two adjacent vertices share the same color. Return a list of colors for each vertex or None if no solution exists.",Assert not matching the Code,"def isSafe(graph, v, colour, c):
  for i in range(len(graph)):
    if graph[v][i] == 1 and colour[i] == c:
      return False
  return True

def graphColourUtil(graph, m, colour, v):
  if v == len(graph):
    return True

  for c in range(1, m + 1):
    if isSafe(graph, v, colour, c) == True:
      colour[v] = c
      if graphColourUtil(graph, m, colour, v + 1) == True:
        return True
      colour[v] = 0

def graphColouring(graph:[[int]], m):
  colour = [0] * len(graph)
  if graphColourUtil(graph, m, colour, 0):
    return colour
  else:
    return None","['backtracking', 'graph']",https://www.geeksforgeeks.org/m-coloring-problem/,"assert graphColouring( [[0, 1, 1, 1],[1, 0, 1, 0],[1, 1, 0, 1],[1, 0, 1, 0]], 3) == [1, 2, 3, 2]"
"Given a 3Ã—3 board with 8 tiles (every tile has one number from 1 to 8) and one empty space. The objective is to place the numbers on tiles to match the final configuration using the empty space. We can slide four adjacent (left, right, above, and below) tiles into the empty space. 

For example, 
initial: [[1,2,3],[5,6,None],[7,8,4]]
final: [[1,2,3],[5,8,6],[None,7,4]]
",,"import copy
from heapq import heappush, heappop
 
# bottom, left, top, right
row = [ 1, 0, -1, 0 ]
col = [ 0, -1, 0, 1 ]
 
# A class for Priority Queue
class priorityQueue:
		 
		# Constructor to initialize a
		# Priority Queue
		def __init__(self):
				self.heap = []
 
		# Inserts a new key 'k'
		def push(self, k):
				heappush(self.heap, k)
 
		# Method to remove minimum element 
		# from Priority Queue
		def pop(self):
				return heappop(self.heap)
 
		# Method to know if the Queue is empty
		def empty(self):
				if not self.heap:
						return True
				else:
						return False
 
# Node structure
class node:
		 
		def __init__(self, parent, mat, empty_tile_pos,
								 cost, level):
											
				# Stores the parent node of the 
				# current node helps in tracing 
				# path when the answer is found
				self.parent = parent
 
				# Stores the matrix
				self.mat = mat
 
				# Stores the position at which the
				# empty space tile exists in the matrix
				self.empty_tile_pos = empty_tile_pos
 
				# Stores the number of misplaced tiles
				self.cost = cost
 
				# Stores the number of moves so far
				self.level = level
 
		# This method is defined so that the 
		# priority queue is formed based on 
		# the cost variable of the objects
		def __lt__(self, nxt):
				return self.cost < nxt.cost
 
# Function to calculate the number of 
# misplaced tiles ie. number of non-blank
# tiles not in their goal position
def calculateCost(mat, final, n) -> int:
		 
		count = 0
		for i in range(n):
				for j in range(n):
						if ((mat[i][j]) and
								(mat[i][j] != final[i][j])):
								count += 1
								 
		return count
 
def newNode(mat, empty_tile_pos, new_empty_tile_pos,
						level, parent, final, n) -> node:
								 
		# Copy data from parent matrix to current matrix
		new_mat = copy.deepcopy(mat)
 
		# Move tile by 1 position
		x1 = empty_tile_pos[0]
		y1 = empty_tile_pos[1]
		x2 = new_empty_tile_pos[0]
		y2 = new_empty_tile_pos[1]
		new_mat[x1][y1], new_mat[x2][y2] = new_mat[x2][y2], new_mat[x1][y1]
 
		# Set number of misplaced tiles
		cost = calculateCost(new_mat, final, n)
 
		new_node = node(parent, new_mat, new_empty_tile_pos,
										cost, level)
		return new_node
 
# Function to check if (x, y) is a valid
# matrix coordinate
def isSafe(x, y, n):
		 
		return x >= 0 and x < n and y >= 0 and y < n
 
# Print path from root node to destination node
def printPath(root):
		ret = []
		while root != None:
			ret.append(root.mat)
			root = root.parent
		ret.reverse()
		return ret
 
# Function to solve N*N - 1 puzzle algorithm
# using Branch and Bound. empty_tile_pos is
# the blank tile position in the initial state.
def solve(initial, final):
		
		n = len(initial)
		empty_tile_pos = None
		for i in range(n):
			for j in range(n):
				if initial[i][j] == 0:
					empty_tile_pos = [i,j]
		# Create a priority queue to store live
		# nodes of search tree
		pq = priorityQueue()
 
		# Create the root node
		cost = calculateCost(initial, final, n)
		root = node(None, initial, 
								empty_tile_pos, cost, 0)
 
		# Add root to list of live nodes
		pq.push(root)
 
		# Finds a live node with least cost,
		# add its children to list of live 
		# nodes and finally deletes it from 
		# the list.
		while not pq.empty():
 
				# Find a live node with least estimated
				# cost and delete it from the list of 
				# live nodes
				minimum = pq.pop()
 
				# If minimum is the answer node
				if minimum.cost == 0:
						return printPath(minimum)
 
				# Generate all possible children
				for i in range(4):
						new_tile_pos = [
								minimum.empty_tile_pos[0] + row[i],
								minimum.empty_tile_pos[1] + col[i], ]
								 
						if isSafe(new_tile_pos[0], new_tile_pos[1], n):
								 
								# Create a child node
								child = newNode(minimum.mat,
																minimum.empty_tile_pos,
																new_tile_pos,
																minimum.level + 1,
																minimum, final, n)
 
								# Add child to list of live nodes
								pq.push(child)","['branch and bound', 'matrix/grid']",https://www.geeksforgeeks.org/8-puzzle-problem-using-branch-and-bound/,"assert solve([ [ 1, 2, 3 ], [ 5, 6, 0 ], [ 7, 8, 4 ] ], [ [ 1, 2, 3 ], [ 5, 8, 6 ], [ 0, 7, 4 ] ]) == [[[1, 2, 3], [5, 6, 0], [7, 8, 4]],[[1, 2, 3], [5, 0, 6], [7, 8, 4]],[[1, 2, 3], [5, 8, 6], [7, 0, 4]],[[1, 2, 3], [5, 8, 6], [0, 7, 4]]]"
"Given an input N for a NxN chessboard place N queens such that no two queens attack each other. Return the NxN board with the Queens marked as Q. If the problem is not solvable return Solution does not exist
",,"
N = 8

def printSolution(board):
    for i in range(N):
        for j in range(N):
            print(board[i][j], end = "" "")
        print()

def isSafe(row, col, slashCode, backslashCode, 
           rowLookup, slashCodeLookup, 
                       backslashCodeLookup):
    if (slashCodeLookup[slashCode[row][col]] or
        backslashCodeLookup[backslashCode[row][col]] or
        rowLookup[row]):
        return False
    return True

def solveNQueensUtil(board, col, slashCode, backslashCode, 
                     rowLookup, slashCodeLookup,
                     backslashCodeLookup):
    if(col >= N):
        return True
    for i in range(N):
        if(isSafe(i, col, slashCode, backslashCode, 
                  rowLookup, slashCodeLookup,
                  backslashCodeLookup)):
            board[i][col] = 1
            rowLookup[i] = True
            slashCodeLookup[slashCode[i][col]] = True
            backslashCodeLookup[backslashCode[i][col]] = True
            if(solveNQueensUtil(board, col + 1, 
                                slashCode, backslashCode, 
                                rowLookup, slashCodeLookup, 
                                backslashCodeLookup)):
                return True
            board[i][col] = 0
            rowLookup[i] = False
            slashCodeLookup[slashCode[i][col]] = False
            backslashCodeLookup[backslashCode[i][col]] = False
             
    return False
def solveNQueens():
    board = [[0 for i in range(N)] 
                for j in range(N)]
     
    # helper matrices 
    slashCode = [[0 for i in range(N)] 
                    for j in range(N)]
    backslashCode = [[0 for i in range(N)] 
                        for j in range(N)]
     
    # arrays to tell us which rows are occupied 
    rowLookup = [False] * N
     
    # keep two arrays to tell us 
    # which diagonals are occupied 
    x = 2 * N - 1
    slashCodeLookup = [False] * x
    backslashCodeLookup = [False] * x
     
    # initialize helper matrices 
    for rr in range(N):
        for cc in range(N):
            slashCode[rr][cc] = rr + cc
            backslashCode[rr][cc] = rr - cc + 7
     
    if(solveNQueensUtil(board, 0, slashCode, backslashCode, 
                        rowLookup, slashCodeLookup, 
                        backslashCodeLookup) == False):
        print(""Solution does not exist"")
        return False
         
    # solution found 
    printSolution(board)
    return True
","['branch and bound', 'matrix/grid']",,
"Let there be N workers and N jobs. Any worker can be assigned to perform any job, incurring some cost that may vary depending on the work-job assignment. It is required to perform all jobs by assigning exactly one worker to each job and exactly one job to each agent in such a way that the total cost of the assignment is minimized.
Your input will be an NxN matrix of cost for each work to do each job. Return an assignment matrix with the least cost.
",,"
import math
from heapq import heappush, heappop

class priorityQueue:
     
    # Constructor to initialize a
    # Priority Queue
    def __init__(self):
        self.heap = []
 
    # Inserts a new key 'k'
    def push(self, k):
        heappush(self.heap, k)
 
    # Method to remove minimum element 
    # from Priority Queue
    def pop(self):
        return heappop(self.heap)
 
    # Method to know if the Queue is empty
    def empty(self):
        if not self.heap:
            return True
        else:
            return False

class Node():
    def __init__(self, parent, pathCost, cost, workerID, jobID, assigned):
        self.parent = parent
        self.pathCost = pathCost
        self.cost = cost
        self.workerID = workerID
        self.jobId = jobID
        self.assigned = assigned

    def __lt__(self, other):
        return self.cost < other.cost

def newNode(x, y, assigned, parent):
    a = copy(assigned)
    a[y] = True
    return Node(parent, None, None, x, y, a)

def calcCost(cost_matrix, x, y, assigned):
    cost = 0
    available = [True] * len(cost_matrix)
    for i in range(x+1, len(cost_matrix)):
        min = math.inf
        minIndex = -1
        for j in range(len(cost_matrix)):
            if not assigned[j] and available[j] and cost_matrix[i][j] < min:
                minIndex = j
                min = cost_matrix[i][j]
        cost += min
        available[minIndex] = False

    return cost

def retAssignment(min: Node, n):
    ret = []
    for i in range(n):
        ret.append([False]*n)
    cur = min
    while cur is not None:
        ret[cur.workerID][cur.jobId] = True
        cur = cur.parent

def find_min_cost(cost_matrix):
    pq = priorityQueue()
    assigned = [False] * len(cost_matrix)
    root = newNode(-1,-1, assigned, None)
    root.pathCost = 0
    root.cost = 0
    root.workerID = -1
    pq.push(root)
    while not pq.empty():
        min = pq.pop()
        i = min.workerID + 1
        if i == len(cost_matrix):
            return retAssignment(min, len(cost_matrix))
        for j in range(len(cost_matrix)):
            child = newNode(i,j,min.assigned, min)
            child.pathCost = min.pathCost + cost_matrix[i][j]
            child.cost = child.pathCost + calcCost(cost_matrix, i, j, child.assigned)
            pq.push(child)
","['branch and bound', 'matrix/grid']",,
"Given a set of cities and distance between every pair of cities, the problem is to find the shortest possible tour that visits every city exactly once and returns to the starting point.
",HARD Question + too many functions + includes prints as output,"
import math
maxsize = float('inf')
def copyToFinal(curr_path):
        final_path[:N + 1] = curr_path[:]
        final_path[N] = curr_path[0]
def firstMin(adj, i):
        min = maxsize
        for k in range(N):
                if adj[i][k] < min and i != k:
                        min = adj[i][k]

        return min

def secondMin(adj, i):
        first, second = maxsize, maxsize
        for j in range(N):
                if i == j:
                        continue
                if adj[i][j] <= first:
                        second = first
                        first = adj[i][j]

                elif(adj[i][j] <= second and
                        adj[i][j] != first):
                        second = adj[i][j]

        return second

def TSPRec(adj, curr_bound, curr_weight, 
                        level, curr_path, visited):
        global final_res

        if level == N:

                if adj[curr_path[level - 1]][curr_path[0]] != 0:
                        curr_res = curr_weight + adj[curr_path[level - 1]]                                                                                [curr_path[0]]
                        if curr_res < final_res:
                                copyToFinal(curr_path)
                                final_res = curr_res
                return

        for i in range(N):
                if (adj[curr_path[level-1]][i] != 0 and
                                                        visited[i] == False):
                        temp = curr_bound
                        curr_weight += adj[curr_path[level - 1]][i]
                        if level == 1:
                                curr_bound -= ((firstMin(adj, curr_path[level - 1]) +
                                                                firstMin(adj, i)) / 2)
                        else:
                                curr_bound -= ((secondMin(adj, curr_path[level - 1]) +
                                                                firstMin(adj, i)) / 2)
                        if curr_bound + curr_weight < final_res:
                                curr_path[level] = i
                                visited[i] = True
                                TSPRec(adj, curr_bound, curr_weight, 
                                        level + 1, curr_path, visited)
                        curr_weight -= adj[curr_path[level - 1]][i]
                        curr_bound = temp
                        visited = [False] * len(visited)
                        for j in range(level):
                                if curr_path[j] != -1:
                                        visited[curr_path[j]] = True
def TSP(adj):
        curr_bound = 0
        curr_path = [-1] * (N + 1)
        visited = [False] * N
        for i in range(N):
                curr_bound += (firstMin(adj, i) +
                                        secondMin(adj, i))
        curr_bound = math.ceil(curr_bound / 2)
        visited[0] = True
        curr_path[0] = 0
        TSPRec(adj, curr_bound, 0, 1, curr_path, visited)

# Driver code

# Adjacency matrix for the given graph
adj = [[0, 10, 15, 20],
        [10, 0, 35, 25],
        [15, 35, 0, 30],
        [20, 25, 30, 0]]
N = 4

# final_path[] stores the final solution 
# i.e. the // path of the salesman.
final_path = [None] * (N + 1)

# visited[] keeps track of the already
# visited nodes in a particular path
visited = [False] * N

# Stores the final minimum weight
# of shortest tour.
final_res = maxsize

TSP(adj)

print(""Minimum cost :"", final_res)
print(""Path Taken : "", end = ' ')
for i in range(N + 1):
        print(final_path[i], end = ' ')
","['branch and bound', 'graph']",,
"You are given an array of people, people, which are the attributes of some people in a queue (not necessarily in order). Each people[i] = [hi, ki] represents the ith person of height hi with exactly ki other people in front who have a height greater than or equal to hi.

Reconstruct and return the queue that is represented by the input array people. The returned queue should be formatted as an array queue, where queue[j] = [hj, kj] is the attributes of the jth person in the queue (queue[0] is the person at the front of the queue).
","Input:  [[7, 0], [4, 4], [7, 1], [5, 0], [6, 1], [5, 2]]
Output: [[5, 0], [4, 1], [7, 0], [5, 2], [6, 1], [7, 1]]

Input:  [[6, 0], [5, 0], [4, 0], [3, 2], [2, 2], [1, 4]]
Output: [[4, 0], [5, 0], [2, 2], [3, 2], [1, 4], [6, 0]]","
def reconstructQueue(people):
    output=[] 
    people.sort(key=lambda x: (-x[0], x[1]))                
    for a in people:
        output.insert(a[1], a)
    
    return output
","['greedy', 'array']",,"assert reconstructQueue([[8,1],[5,0],[6,1],[5,2],[4,4],[7,1]]) == [[5, 0], [8, 1], [5, 2], [6, 1], [4, 4], [7, 1]]
assert reconstructQueue([[7,0],[4,1],[7,1],[5,0],[6,1],[5,2]]) == [[5, 0], [4, 1], [7, 0], [5, 2], [6, 1], [7, 1]]"
"There are N Mice and N holes are placed in a straight line. Each hole can accommodate only 1 mouse. A mouse can stay at his position, move one step right from x to x + 1, or move one step left from x to x -1. Any of these moves consumes 1 minute. Assign mice to holes so that the time when the last mouse gets inside a hole is minimized.
You are given a list of mice and hole positions as integer scalers.
","Input: Mices = [0, 10, 2, 3], Holes = [3, 2, 23, 0]
Output: 13","def assignHole(mices, holes):
    for i,j in zip(mices,holes):
        if i<0 or j<0:
            return -1
    if (len(mices) != len(holes)):
        return -1
    mices.sort()
    holes.sort()
    Max = 0
     
    for i in range(len(holes)):
        if (Max < abs(mices[i] - holes[i])):
            Max = abs(mices[i] - holes[i])
     
    return Max","['greedy', 'array', 'sorting']",,"assert assignHole([1, 2, 3, 4], [4, 3, 2, 1]) == 0
assert assignHole([1,10,4,6], [4,5,2,4]) == 5"
"Every positive fraction can be represented as sum of unique unit fractions. A fraction is unit fraction if numerator is 1 and denominator is a positive integer, for example 1/3 is a unit fraction. Such a representation is called Egyptian Fraction.
Given a numerator and denominator print the  Egyptian Fraction.
",BAD QUESTION,"
import math
def egyptianFraction(nr, dr):
 
    print(""The Egyptian Fraction "" +
          ""Representation of {0}/{1} is"".
                format(nr, dr), end=""
"")
    ef = []
    while nr != 0:
        x = math.ceil(dr / nr)
        ef.append(x)
        nr = x * nr - dr
        dr = dr * x
    for i in range(len(ef)):
        if i != len(ef) - 1:
            print("" 1/{0} +"" . 
                    format(ef[i]), end = "" "")
        else:
            print("" 1/{0}"" .
                    format(ef[i]), end = "" "")
","['greedy', 'mathematical']",,
"Every house in the colony has at most one pipe going into it and at most one pipe going out of it. Tanks and taps are to be installed in a manner such that every house with one outgoing pipe but no incoming pipe gets a tank installed on its roof and every house with only an incoming pipe and no outgoing pipe gets a tap.

Given two integers n and p denoting the number of houses and the number of pipes. The connections of pipe among the houses contain three input values: a_i, b_i, d_i denoting the pipe of diameter d_i from house a_i to house b_i, find out the efficient solution for the network. 

The output will contain the number of pairs of tanks and taps t installed in first line and the next t lines contain three integers: house number of tank, house number of tap and the minimum diameter of pipe between them.


",BAD QUESTION,"
def dfs(w, ans, cd, wt):
        if (cd[w] == 0):
                return w, ans
        if (wt[w] < ans):
                ans = wt[w]
        return dfs(cd[w], ans, cd, wt)

# Function performing calculations.
def solve(n, p, arr):
    # Array rd stores the 
    # ending vertex of pipe
    rd = [0]*1100

    # Array wd stores the value 
    # of diameters between two pipes
    wt = [0]*1100

    # Array cd stores the 
    # starting end of pipe
    cd = [0]*1100
    ans = 0
    i = 0
    while (i < p):
        q = arr[i][0]
        h = arr[i][1]
        t = arr[i][2]
        
        cd[q] = h
        wt[q] = t
        rd[h] = q
        i += 1
    a = []
    b = []
    c = []
        
    for j in range(1, n + 1):
        if (rd[j] == 0 and cd[j]):
            
            ans = 1000000000
            w, ans = dfs(j, ans, cd, wt)
            
            # We put the details of component
            # in final output array
            a.append(j)
            b.append(w) 
            c.append(ans)
    print(len(a))
    for j in range(len(a)):
        print(a[j], b[j], c[j])
","['greedy', 'graph']",,
"You are given n activities with their start and finish times. Select the maximum number of activities that can be performed by a single person and return their indexes. Assume that a person can only work on a single activity at a time. 
","Input: start  =  {10, 12, 20}, finish =  {20, 25, 30}
Output: [0, 2]","import numpy as np
def MaxActivities(s, f):
    indices = np.argsort(f)
    [s[i] for i in indices]
    [f[i] for i in indices]
    result = []
    n = len(f)
    i = 0
    result.append(i)
    for j in range(1, n):
        if s[j] >= f[i]:
            result.append(j)
            i = j
    return result
",['greedy'],,"assert MaxActivities([2, 4, 5, 6, 7, 8], [3, 5, 6, 7, 9, 10]) == [0, 1, 2, 3, 4]

assert MaxActivities([0, 1, 3, 5, 5, 8], [6, 2, 4, 7, 9, 9]) == [0, 5]"
"Given the head of a singly linked list, reverse the list, and return the reversed list.
Definition for singly-linked list.
class ListNode(object):
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next
",,"
def reverseList(head):
    if head == None:
        return None
    cur = head
    next = cur.next
    while next:
        tmp = next.next
        next.next = cur
        cur = next
        next = tmp

    head.next = None
    return cur
",['linked list'],,
"Given the head of a singly linked list, return true if it is a palindrome or false otherwise.
Definition for singly-linked list.
class ListNode(object):
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next
",,"
def isPalindrome(head):
    slow = fast = head 
    while fast and fast.next:
        fast = fast.next.next
        slow = slow.next 
        
    stack1=[]
    stack2 = []
    
    fast = slow 
    slow = head
    while fast:
        stack2.append(slow.val)
        stack1.append(fast.val)
        fast = fast.next
        slow = slow.next 
        
    stack2.reverse()
    return stack1 == stack2
",['linked list'],,
"Given the head of a singly linked list and an integer k, split the linked list into k consecutive linked list parts.

The length of each part should be as equal as possible: no two parts should have a size differing by more than one. This may lead to some parts being null.

The parts should be in the order of occurrence in the input list, and parts occurring earlier should always have a size greater than or equal to parts occurring later.

Return an array of the k parts.
Definition for singly-linked list.
class ListNode(object):
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next
",,"
def splitListToParts(head, k):
    cur = head
    N = 0
    while cur:
        N += 1
        cur = cur.next
    width, remainder = divmod(N, k)

    ans = []
    cur = head
    for i in range(k):
        head = cur
        for j in range(width + (i < remainder) - 1):
            if cur: cur = cur.next
        if cur:
            cur.next, cur = None, cur.next
        ans.append(head)
    return ans
",['linked list'],,
"Given the head of a singly linked list, return the middle node of the linked list.

If there are two middle nodes, return the second middle node.
Definition for singly-linked list.
class ListNode(object):
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next
",,"
def middleNode(head):
    slow = fast = head
    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next
    return slow
",['linked list'],,
"You are given the head of a linked list, and an integer k.

Return the head of the linked list after swapping the values of the kth node from the beginning and the kth node from the end (the list is 1-indexed).
Definition for singly-linked list.
class ListNode(object):
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next
",,"
def swapNodes(self, head, k):
    node1 = node2 = fast = head
    #Finding kth node from the start 
    k-=1
    while (k):
        node1 = node1.next
        fast = fast.next
        k-=1

    #Finding kth node from the end
    while (fast and fast.next):
        node2 = node2.next
        fast = fast.next

    #Swapping the values only
    temp = node1.val
    node1.val = node2.val
    node2.val = temp

    return head
",['linked list'],,
" Given a queue reverse it
",,"
from collections import deque
def reverse(queue: deque):
    if not len(queue) == 0:
        temp = queue.pop()
        reverse(queue)
        queue.appendleft(temp)
",['queue'],,
"Given a root treenode convert the entire tree into a list of values such that the nth entry has children 2*n+1 and 2*n+2.
class TreeNode(object):
    def __init__(self, val=0, left=None, ight=None):
        self.val = val
        self.left = left
        self.right = right
",,"
class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def tree_to_list(root: TreeNode):
    ret = []
    if root is None:
        return ret
    cur_queue = [root]
    still_nodes = True
    while still_nodes:
        still_nodes = False
        next_queue = []
        for node in cur_queue:
            left = None
            right = None
            if node is not None:
                left = node.left
                right = node.right
                ret.append(node.val)
            else:
                ret.append(None)
            next_queue.append(left)
            next_queue.append(right)
            if left is not None or right is not None:
                still_nodes = True
        cur_queue = next_queue
    return ret
","['queue', 'tree']",,
"Design your implementation of the circular queue. The circular queue is a linear data structure in which the operations are performed based on FIFO (First In First Out) principle, and the last position is connected back to the first position to make a circle. It is also called ""Ring Buffer"".

Implement the MyCircularQueue class:

MyCircularQueue(k) Initializes the object with the size of the queue to be k.
int Front() Gets the front item from the queue. If the queue is empty, return -1.
int Rear() Gets the last item from the queue. If the queue is empty, return -1.
boolean enQueue(int value) Inserts an element into the circular queue. Return true if the operation is successful.
boolean deQueue() Deletes an element from the circular queue. Return true if the operation is successful.
boolean isEmpty() Checks whether the circular queue is empty or not.
boolean isFull() Checks whether the circular queue is full or not.
",,"
class MyCircularQueue:
    def __init__(self, k):
        self.size=k
        self.q=[0]*k
        self.front=-1
        self.rear=-1

    def enQueue(self, value):
        if self.isFull():
            return False
        if self.isEmpty():
            self.front=self.rear=0
        else:
            self.rear=(self.rear+1)%self.size
        self.q[self.rear]=value
        return True

    def deQueue(self):
        if self.isEmpty():
            return False
        item=self.q[self.front]
        if self.front==self.rear:
            self.front=self.rear=-1
        else:
            self.front=(self.front+1)%self.size
        return True

    def Front(self):
        if self.front==-1:
            return -1
        return self.q[self.front]

    def Rear(self):
        if self.rear==-1:
            return -1
        return self.q[self.rear]

    def isEmpty(self):
        return self.front==-1

    def isFull(self):
        if self.front==0 and self.rear==self.size-1:
            return True
        if self.rear==(self.front-1)%(self.size):
            return True
        return False
",['queue'],,
"
Design a queue that supports push and pop operations in the front, middle, and back.

Implement the FrontMiddleBack class:

FrontMiddleBack() Initializes the queue.
void pushFront(int val) Adds val to the front of the queue.
void pushMiddle(int val) Adds val to the middle of the queue.
void pushBack(int val) Adds val to the back of the queue.
int popFront() Removes the front element of the queue and returns it. If the queue is empty, return -1.
int popMiddle() Removes the middle element of the queue and returns it. If the queue is empty, return -1.
int popBack() Removes the back element of the queue and returns it. If the queue is empty, return -1.
Notice that when there are two middle position choices, the operation is performed on the frontmost middle position choice
",,"
class FrontMiddleBackQueue(object):
    def __init__(self):
        self.queue=[]

    def pushFront(self, val):
        self.queue.insert(0,val)

    def pushMiddle(self, val):
        mid=(len(self.queue))//2
        self.queue.insert(mid,val)
    
    def pushBack(self, val):
        self.queue.append(val)

    def popFront(self):
        if len(self.queue)==0:
            return -1
        else:
            res=self.queue.pop(0)
            return res
    
    def popMiddle(self):
        if len(self.queue)==0:
            return -1
        else:
            mid=(len(self.queue)-1)//2
            res=self.queue.pop(mid)
            return res
    
    def popBack(self):
        if len(self.queue)==0:
            return -1
        else:
            res=self.queue.pop()
            return res
",['queue'],,
"You are given a string s and an integer k. You can choose one of the first k letters of s and append it at the end of the string.

Return the lexicographically smallest string you could have after applying the mentioned step any number of moves.
","Input: s = ""cba"", k = 1
Output: ""acb""

Input: s = ""baaca"", k = 3
Output: ""aaabc""","
def orderlyQueue(s: str, k: int) -> str:
    if k == 1:
        n = len(s)
        ss = s + s
        lex_min_str = s
        for i in range(n):
            lex_min_str = min(lex_min_str, ss[i:i + n])
        return lex_min_str
    
    return """".join(sorted(s))
","['queue', 'string']",,"assert orderlyQueue(""abcd"", 1) == ""abcd""
assert orderlyQueue(""hgfedcba"", 2) == ""abcdefgh""
assert orderlyQueue(""zyxwvutsrqponmlkjihgfedcba"", 2) == ""abcdefghijklmnopqrstuvwxyz""
assert orderlyQueue(""racecar"", 3) == ""aaccerr""
assert orderlyQueue(""racecar"", 1) == ""acecarr""
assert orderlyQueue(""zzzzzzzzzzzzzzzzzzzzzzzzzzzzy"", 2) == ""yzzzzzzzzzzzzzzzzzzzzzzzzzzzz"""
Return nth number in the fibonacci sequence,"Input: 9
Output: 34

Input: 7
Output: 13","
def fibonacci(n):
    a = 0
    b = 1
    if n < 0:
        print(""Incorrect input"")
    elif n == 0:
        return a
    elif n == 1:
        return b
    else:
        for i in range(2, n+1):
            c = a + b
            a = b
            b = c
        return b
  b = c
  return fib(n-1, a, b)
","['recursion', 'mathematical']",,"assert fibonacci(9) == 34
assert fibonacci(7) == 13"
Return the factorial of a given number n,"Input: 5
Output: 120

Input: 6
Output: 720","
def fact(n):
  if n <= 1:
    return 1
  return n*fact(n-1)
","['recursion', 'mathematical']",,assert fact(5) == 120
"Given a numerator and a denominator, return the fraction in string format. If the fractional part is repeating, enclose the repeating part in parentheses","Input: Numerator = 1, Denominator = 2
Output: ""0.5""

Input: Numerator = 2, Denominator = 3
Output: ""0.(6)""

Input: Numerator = 1, Denominator = 4
Output: ""0.25""

Input: Numerator = 4, Denominator = 333
Output: ""0.(012)""","
def helper(cur, numerator, denominator, numerators_seen):
  if numerator == 0:
    return cur
  elif numerator in numerators_seen.keys():
    idx = numerators_seen[numerator]
    return cur[:idx] + '(' + cur [idx:] + ')'
  numerators_seen[numerator] = len(cur)
  if numerator >= denominator:
    cur += str(numerator // denominator)
    numerator = numerator % denominator
    return helper(cur, numerator*10, denominator, numerators_seen)
  else:
    cur += ""0""
    return helper(cur, numerator*10, denominator, numerators_seen)

def fractionToDecimal(numerator, denominator):
  cur = """"
  if numerator == 0:
    return ""0""
  elif (numerator < 0 and denominator > 0) or (numerator > 0 and denominator < 0):
    cur = ""-""
  numerator = abs(numerator)
  denominator = abs(denominator)
  if numerator >= denominator:
    cur += str(numerator // denominator)
    numerator = numerator % denominator
    if numerator != 0:
      cur += "".""
      return helper(cur, numerator*10, denominator, dict())
    else:
      return cur
  else:
    cur += ""0.""
    return helper(cur, numerator*10, denominator, dict())
","['recursion', 'mathematical', 'string']",,"assert fractionToDecimal(1, 2) == ""0.5""
assert fractionToDecimal(2, 3) == ""0.(6)"""
"You are given the root of a binary search tree (BST), where the values of exactly two nodes of the tree were swapped by mistake. Recover the tree without changing its structure.
Definition for a binary tree node.
class TreeNode(object):
    def __init__(self, val=0, left=None, ight=None):
        self.val = val
        self.left = left
        self.right = right
",,"
def forward(root, n):
    if root is None:
        return
    ret = forward(root.left, n)
    if ret:
        return ret
    
    if not n:
        n.append(root)
    elif root.val < n[0].val:
        return n[0]
    else:
        n[0] = root
    
    ret = forward(root.right, n)
    if ret:
        return ret
    
def backward(root, n):
    if root is None:
        return
    
    ret = backward(root.right, n)
    if ret:
        return ret
    
    if not n:
        n.append(root)
    elif root.val > n[0].val:
        return n[0]
    else:
        n[0] = root
    
    ret = backward(root.left, n)
    if ret:
        return ret
    
def recoverTree(root):
    x, y = forward(root, []), backward(root, [])
    x.val, y.val = y.val, x.val
    return root
","['recursion', 'tree']",,
"Given a list of values output a root binary tree node with appropiate children. None should not have a Tree Node created for them.
Definition for a binary tree node.
class TreeNode(object):
    def __init__(self, val=0, left=None, ight=None):
        self.val = val
        self.left = left
        self.right = right
",DITCH,"
class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def createTree(nums):
   if len(nums) == 0:
      return None
   def helper(cur):
      if cur >= len(nums):
         return None
      left = helper(cur*2+1)
      right = helper(cur*2+2)
      if nums[cur] is not None:
        return TreeNode(nums[cur], left, right)
      else:
         return None
   return helper(0)
","['recursion', 'tree']",,
"Write a function that reverses a string. The input string is given as an array of characters s.

You must do this by modifying the input array in-place with O(1) extra memory.","Input: [""h"",""e"",""l"",""l"",""o""]
Output: [""o"",""l"",""l"",""e"",""h""]

Input: [""H"",""a"",""n"",""n"",""a"",""h""]
Output: [""h"",""a"",""n"",""n"",""a"",""H""]","
def reverse_string(s: str):
  l = 0
  r = len(s) - 1
  while l < r:
    tmp = s[l]
    s[l] = s[r]
    s[r] = tmp
    l += 1
    r -= 1
",['string'],,"assert reverse_string(list(""abcd"")) == list(""dcba"")
assert reverse_string(list(""Programming"")) == list(""gnimmargorP"")
assert reverse_string(list(""Racecar"")) == list(""racecaR"")"
"Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.

In other words, return true if one of s1's permutations is the substring of s2.","Input: s1 = ""ab"", s2 = ""eidbaooo""
Output: True

Input: s1 = ""ab"", s2 = ""eidboaoo""
Output: False","
def permutation_in_string(s1: str, s2: str):
  window = len(s1)
  if window > len(s2):
    return False
  freq1 = [0]*26
  freq2 = [0]*26
  for i in range(window):
    freq1[ord(s1[i])-ord('a')] += 1
    freq2[ord(s2[i])-ord('a')] += 1

  matches = 0
  for i in range(26):
    if freq1[i] == freq2[i]:
      matches += 1
  
  for l in range(len(s2) - window):
    if matches == 26:
      return True

    added = ord(s2[l + window]) - ord('a')
    freq2[added] += 1
    if freq1[added] == freq2[added]:
      matches += 1
    elif freq1[added] + 1 == freq2[added]:
      matches -= 1

    removed = ord(s2[l]) - ord('a')
    freq2[removed] -= 1
    if freq1[removed] == freq2[removed]:
      matches += 1
    elif freq1[removed] == freq2[removed] + 1:
      matches -= 1
    
  return matches == 26
","['string', 'pattern searching']",,"
assert permutation_in_string(""hello"", ""ooollehhhhh"") == True
assert permutation_in_string(""abcd"", ""dcba"") == True
assert permutation_in_string(""abcd"", ""dcbb"") == False
assert permutation_in_string(""abcde"", ""dcba"") == False
assert permutation_in_string(""abcde"", ""edcba"") == True
assert permutation_in_string(""abc"", ""jjj"") == False
assert permutation_in_string(""abc"", ""cba"") == True
assert permutation_in_string(""abc"", ""bca"") == True
assert permutation_in_string(""abcd"", ""dcbae"") == True
assert permutation_in_string(""abcd"", ""ecbda"") == True
assert permutation_in_string(""abcd"", ""dcbaef"") == True
assert permutation_in_string(""abcd"", ""edcba"") == True
assert permutation_in_string(""abcd"", ""abcde"") == True
assert permutation_in_string(""abc"", ""cbaa"") == True
assert permutation_in_string(""abc"", ""cbaab"") == True
assert permutation_in_string(""abc"", ""cbabc"") == True
assert permutation_in_string(""abc"", ""cbaabc"") == True
assert permutation_in_string(""abc"", ""cbaabcd"") == True
assert permutation_in_string(""abc"", ""cbaabcde"") == True
assert permutation_in_string(""abcd"", ""cbaabcde"") == True
assert permutation_in_string(""abcd"", ""cbaabcdex"") == True
assert permutation_in_string(""abcde"", ""cbaabcdex"") == True
assert permutation_in_string(""abc"", ""cbaabcdexf"") == True
assert permutation_in_string(""abc"", ""cbaabcdefx"") == True
assert permutation_in_string(""abc"", ""cbaabcdef"") == True
assert permutation_in_string(""abcdef"", ""cbaabcdef"") == True
assert permutation_in_string(""abcdef"", ""cbaabcdefg"") == True
assert permutation_in_string(""abcdef"", ""cbaabcdefgx"") == True
assert permutation_in_string(""abcdef"", ""cbaabcdefgxh"") == True
assert permutation_in_string(""abcdef"", ""cbaabcdefgxhi"") == True
assert permutation_in_string(""abcdef"", ""cbaabcdefgxhij"") == True
assert permutation_in_string(""abcdef"", ""cbaabcdefgxhijk"") == True
assert permutation_in_string(""abcdef"", ""cbaabcdefgxhijkl"") == True
assert permutation_in_string(""abcdef"", ""cbaabcdefgxhijklm"") == True
assert permutation_in_string(""abcdef"", ""cbaabcdefgxhijklmn"") == True
assert permutation_in_string(""abcdef"", ""cbaabcdefgxhijklmno"") == True
assert permutation_in_string(""abcdef"", ""cbaabcdefgxhijklmnop"") == True
assert permutation_in_string(""abcdef"", ""cbaabcdefgxhijklmnopq"") == True
assert permutation_in_string(""abcdef"", ""cbaabcdefgxhijklmnopqr"") == True
assert permutation_in_string(""abcdef"", ""cbaabcdefgxhijklmnopqrs"") == True
assert permutation_in_string(""abcdef"", ""cbaabcdefgxhijklmnopqrst"") == True
assert permutation_in_string(""abcdef"", ""cbaabcdefgxhijklmnopqrstu"") == True
assert permutation_in_string(""abcdef"", ""cbaabcdefgxhijklmnopqrstuv"") == True
assert permutation_in_string(""abcdef"", ""cbaabcdefgxhijklmnopqrstuvw"") == True
assert permutation_in_string(""abcdef"", ""cbaabcdefgxhijklmnopqrstuvwx"") == True
assert permutation_in_string(""abcdef"", ""cbaabcdefgxhijklmnopqrstuvwxz"") == True
assert permutation_in_string(""abcdef"", ""cbaabcdefgxhijklmnopqrstuvwxzy"") == True
assert permutation_in_string(""abcdef"", ""cbaabcdefgxhijklmnopqrstuvwxzyx"") == True
assert permutation_in_string(""abcdef"", ""cbaabcdefgxhijklmnopqrstuvwxzyxw"") == True
assert permutation_in_string(""abcdef"", ""cbaabcdefgxhijklmnopqrstuvwxzyxwv"") == True
assert permutation_in_string(""abcdef"", ""cbaabcdefgxhijklmnopqrstuvwxzyxwvu"") == True
assert permutation_in_string(""abcdef"", ""cbaabcdefgxhijklmnopqrstuvwxzyxwvut"") == True
assert permutation_in_string(""abcdef"", ""cbaabcdefgxhijklmnopqrstuvwxzyxwvuts"") == True
assert permutation_in_string(""abcdef"", ""cbaabcdefgxhijklmnopqrstuvwxzyxwvutsr"") == True
assert permutation_in_string(""abcdef"", ""cbaabcdefgxhijklmnopqrstuvwxzyxwvutsrq"") == True
assert permutation_in_string(""abcdef"", ""cbaabcdefgxhijklmnopqrstuvwxzyxwvutsrqp"") == True
assert permutation_in_string(""abcdef"", ""cbaabcdefgxhijklmnopqrstuvwxzyxwvutsrqpo"") == True
assert permutation_in_string(""abcdef"", ""cbaabcdefgxhijklmnopqrstuvwxzyxwvutsrqpon"") == True
assert permutation_in_string(""abcdef"", ""cbaabcdefgxhijklmnopqrstuvwxzyxwvutsrqponm"") == True
assert permutation_in_string(""abcdef"", ""cbaabcdefgxhijklmnopqrstuvwxzyxwvutsrqponml"") == True
assert permutation_in_string(""abcdef"", ""cbaabcdefgxhijklmnopqrstuvwxzyxwvutsrqponmlk"") == True
assert permutation_in_string(""abcdef"", ""cbaabcdefgxhijklmnopqrstuvwxzyxwvutsrqponmlkj"") == True
assert permutation_in_string(""abcdef"", ""cbaabcdefgxhijklmnopqrstuvwxzyxwvutsrqponmlkji"") == True
assert permutation_in_string(""abcdef"", ""cbaabcdefgxhijklmnopqrstuvwxzyxwvutsrqponmlkjih"") == True
assert permutation_in_string(""abcdef"", ""cbaabcdefgxhijklmnopqrstuvwxzyxwvutsrqponmlkjihg"") == True
assert permutation_in_string(""abcdef"", ""cbaabcdefgxhijklmnopqrstuvwxzyxwvutsrqponmlkjihgf"") == True
assert permutation_in_string(""abcdef"", ""cbaabcdefgxhijklmnopqrstuvwxzyxwvutsrqponmlkjihgfe"") == True
assert permutation_in_string(""abcdef"", ""cbaabcdefgxhijklmnopqrstuvwxzyxwvutsrqponmlkjihgfed"") == True
assert permutation_in_string(""abcdef"", ""cbaabcdefgxhijklmnopqrstuvwxzyxwvutsrqponmlkjihgfedc"") == True
assert permutation_in_string(""abcdef"", ""cbaabcdefgxhijklmnopqrstuvwxzyxwvutsrqponmlkjihgfedcb"") == True
assert permutation_in_string(""abcdef"", ""cbaabcdefgxhijklmnopqrstuvwxzyxwvutsrqponmlkjihgfedcba"") == True"
"You are given a string s and an integer array indices of the same length. The string s will be shuffled such that the character at the ith position moves to indices[i] in the shuffled string.

Return the shuffled string.","Input: s = ""codeleet"", indices = [4,5,6,7,0,2,1,3]
Output: ""leetcode""

Input: s = ""abc"", indices = [0,1,2]
Output: ""abc""","
def shuffle_string(s: str, indices: list[int]):
  ret = ['_']*len(s)
  for idx, i in enumerate(indices):
    ret[i] = s[idx]
  return """".join(ret)

#https://leetcode.com/problems/optimal-partition-of-string/description/
def partitionString(s):
  substrings = 1
  cur_str = set()
  for i in range(len(s)):
    if s[i] in cur_str:
      substrings += 1
      cur_str = {s[i]}
    else:
      cur_str.add(s[i])
  return substrings
",['string'],,"assert shuffle_string(""reoc"", [2, 0, 1, 3]) == ""core""
assert shuffle_string(""word"", [3, 0, 2, 1]) == ""drow"""
"Given an integer n, return the number of strings of length n that consist only of vowels (a, e, i, o, u) and are lexicographically sorted.

A string s is lexicographically sorted if for all valid i, s[i] is the same as or comes before s[i+1] in the alphabet.","Input: 1
Output: 5

Input: 2
Output: 15","def helper(n, letter_idx):
  letters = [""a"",""e"",""i"",""o"",""u""]
  dynamic = {
      'a1' : 5,
      'e1' : 4,
      'i1' : 3,
      'o1' : 2,
      'u1' : 1
  }
  ret = 0
  key = letters[letter_idx] + str(n)
  if key in dynamic.keys():
    return dynamic[key]
  else:
    for i in range(letter_idx, len(letters)):
      ret += helper(n-1, i)
    dynamic[key] = ret
  return ret
  

def countVowelStrings(n):
  return helper(n, 0)

print(countVowelStrings(33))
",['string'],,"assert countVowelStrings(3) == 35
assert countVowelStrings(4) == 70"