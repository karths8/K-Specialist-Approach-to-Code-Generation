author,UUID,question,examples,link,difficulty,categories,code,asserts,Error,Status
Karthik,83190ce9-1db2-4b27-9211-d06ca290b1f0,"Given the dimension of a sequence of matrices in an array arr[], where the dimension of the ith matrix is (arr[i-1] * arr[i]), the task is to find the most efficient way to multiply these matrices together such that the total number of element multiplications is minimum.","Input: arr[] = {40, 20, 30, 10, 30}
Output: 26000
Explanation:There are 4 matrices of dimensions 40×20, 20×30, 30×10, 10×30.
Let the input 4 matrices be A, B, C and D.
The minimum number of  multiplications are obtained by 
putting parenthesis in following way (A(BC))D.
The minimum is 20*30*10 + 40*20*10 + 40*10*30

Input: arr[] = {1, 2, 3, 4, 3}
Output: 30
Explanation: There are 4 matrices of dimensions 1×2, 2×3, 3×4, 4×3. 
Let the input 4 matrices be A, B, C and D.  
The minimum number of multiplications are obtained by 
putting parenthesis in following way ((AB)C)D.
The minimum number is 1*2*3 + 1*3*4 + 1*4*3 = 30

Input: arr[] = {10, 20, 30}
Output: 6000  
Explanation: There are only two matrices of dimensions 10×20 and 20×30. 
So there  is only one way to multiply the matrices, cost of which is 10*20*30",https://www.geeksforgeeks.org/matrix-chain-multiplication-dp-8/,Hard,['Matrix/Grid'],"import sys
def MatrixChainOrder(p, i, j):
        if i == j:
                return 0

        _min = sys.maxsize

        for k in range(i, j):

                count = (MatrixChainOrder(p, i, k)
                                + MatrixChainOrder(p, k + 1, j)
                                + p[i-1] * p[k] * p[j])

                if count < _min:
                        _min = count

        return _min","['assert MatrixChainOrder([40, 20, 30, 10, 30], 0, 4) ==  26000']",Assert Failed,Remove
Karthik,89396d48-febb-46d4-a7e9-fc6db885a2cb,"Given an array of elements, sort the array in decreasing order using min heap. ","Input : arr[] = {5, 3, 10, 1}
Output : arr[] = {10, 5, 3, 1}

Input : arr[] = {1, 50, 100, 25}
Output : arr[] = {100, 50, 25, 1}",https://www.geeksforgeeks.org/heap-sort-for-decreasing-order-using-min-heap/,Easy,['Heap'],"def heapSort(arr):
        def heapify(arr, n, i):
                smallest = i 
                l = 2 * i + 1 
                r = 2 * i + 2

                if l < n and arr[l] < arr[smallest]: 
                        smallest = l 

                if r < n and arr[r] < arr[smallest]: 
                        smallest = r 

                if smallest != i: 
                        (arr[i], 
                        arr[smallest]) = (arr[smallest],
                                                        arr[i])

                        heapify(arr, n, smallest)
         
        n = len(arr)
        for i in range(int(n / 2) - 1, -1, -1):
                heapify(arr, n, i) 

        for i in range(n-1, -1, -1):
                
                arr[0], arr[i] = arr[i], arr[0]

                heapify(arr, i, 0)

        return arr","['assert heapSort([4,6,3,2,9]) == [9,6,4,3,2]']",Assert Failed,Resolved. Code Changed + assert changed
Karthik,b2d10472-1c51-495a-a76c-b37a3c5986fb,Given an array arr[] containing n elements. The problem is to find the maximum number of distinct elements (non-repeating) after removing k elements from the array. Where 1<= k <= n,"Input : arr[] = {5, 7, 5, 5, 1, 2, 2}, k = 3
Output : 4
Remove 2 occurrences of element 5 and
1 occurrence of element 2.

Input : arr[] = {1, 2, 3, 4, 5, 6, 7}, k = 5
Output : 2

Input : arr[] = {1, 2, 2, 2}, k = 1
Output : 1",https://www.geeksforgeeks.org/maximum-distinct-elements-removing-k-elements/,Medium,['Heap'],"
def maxDistinctNum(a, k):
        s = {}
        n = len(a)
        for i in range(n):
                if a[i] not in s or k == 0:
                        s[a[i]] = s.get(a[i], 0)+1
                else:
                        s[a[i]] = 1
                        k -= 1
        if k != 0:
                return len(s)-k
        else:

                st = set()
                for i in s:
                        st.add(i)
                return len(st)","['assert maxDistinctNum([5, 7, 5, 5, 1, 2, 2], 3) == 4']",Assert Failed,Resolved. Changed a wrong assert
Karthik,47709123-a6fd-44dc-b1b3-6360282a7b0e,"Given a stream of integers represented as arr[]. For each index i from 0 to n-1, print the multiplication of largest, second largest, third largest element of the subarray arr[0…i]. If i < 2 print -1. ","Input : arr[] = {1, 2, 3, 4, 5}
Output :-1
        -1
         6
         24
         60
Explanation : for i = 2 only three elements 
are there {1, 2, 3} so answer is 6. For i = 3
largest three elements are {2, 3, 4} their
product is 2*3*4 = 24 ....so on  ",https://www.geeksforgeeks.org/largest-triplet-product-stream/,Medium,['Heap'],"def LargestTripletMultiplication(arr):
        n = len(arr)
        
        q = PriorityQueue()

        res = []

        for i in range(n): 
                
                q.put(-arr[i])
                
                if (q.qsize() < 3):
                        res.append(-1)
                else:
                        
                        x = q.get()
                        y = q.get()
                        z = q.get()
                        ans = x * y * z
                        
                        res.append(ans)
                        
                        q.put(x);
                        q.put(y);
                        q.put(z);
        return ans","['assert LargestTripletMultiplication([1,2,3,4,5]) == [-1,-1,6,24,60]']",name 'PriorityQueue' is not defined,Remove. Using Class object
Karthik,4d754c72-3726-4f91-b435-b01a6dd531b9,Jump Search is a searching algorithm for sorted arrays. The basic idea is to check fewer elements (than linear search) by jumping ahead by fixed steps or skipping some elements in place of searching all elements. Write the algorithm to perform Jump Search in Python,"For example, suppose we have an array arr[] of size n and a block (to be jumped) of size m. Then we search in the indexes arr[0], arr[m], arr[2m]…..arr[km] and so on. Once we find the interval (arr[km] < x < arr[(k+1)m]), we perform a linear search operation from the index km to find the element x.
Let’s consider the following array: (0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610). The length of the array is 16. The Jump search will find the value of 55 with the following steps assuming that the block size to be jumped is 4. 
STEP 1: Jump from index 0 to index 4; 
STEP 2: Jump from index 4 to index 8; 
STEP 3: Jump from index 8 to index 12; 
STEP 4: Since the element at index 12 is greater than 55, we will jump back a step to come to index 8. 
STEP 5: Perform a linear search from index 8 to get the element 55.",https://www.geeksforgeeks.org/jump-search/,Medium,['Searching Algorithm'],"
import math

def jumpSearch( arr , x):
        n = len(arr)
        step = math.sqrt(n)
        prev = 0
        while arr[int(min(step, n)-1)] < x:
                prev = step
                step += math.sqrt(n)
                if prev >= n:
                        return -1
        while arr[int(prev)] < x:
                prev += 1
                if prev == min(step, n):
                        return -1
        if arr[int(prev)] == x:
                return prev
        
        return -1","['assert jumpSearch([0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610], 55) == 10']",name 'math' is not defined,Solved using globals()
Karthik,89460848-49b1-4efa-9612-9d0bfcdaa170,"Given a sorted array of n uniformly distributed values arr[], write a function to search for a particular element x in the array. ","Input: arr[] = {10, 20, 30, 70, 80, 85, 90, 100} and key = 30
Output: Element is present at index 2",https://www.geeksforgeeks.org/interpolation-search/,Medium,['Searching Algorithm'],"def interpolationSearch(arr, x):
        lo = 0
        hi = len(arr) - 1
        if (lo <= hi and x >= arr[lo] and x <= arr[hi]):
                pos = lo + ((hi - lo) // (arr[hi] - arr[lo]) *
                                        (x - arr[lo]))
                if arr[pos] == x:
                        return pos

                if arr[pos] < x:
                        return interpolationSearch(arr, pos + 1,
                                                                        hi, x)

                if arr[pos] > x:
                        return interpolationSearch(arr, lo,
                                                                        pos - 1, x)
        return -1","['assert interpolationSearch([10, 12, 13, 16, 18, 19, 20, 21, 22, 23, 24, 33, 35, 42, 47], 18) == 4']",interpolationSearch() takes 2 positional arguments but 4 were given,Remove
Karthik,a304b379-a885-412d-9170-0e1570ef4984,"Ternary search is a decrease(by constant) and conquer algorithm that can be used to find an element in an array. It is similar to binary search where we divide the array into two parts but in this algorithm, we divide the given array into three parts and determine which has the key (searched element). We can divide the array into three parts by taking mid1 and mid2 which can be calculated as shown below. Initially, l and r will be equal to 0 and n-1 respectively, where n is the length of the array.  Write a program in python to implement Ternary Search","Input: arr[] = {10, 50, 30, 70, 80, 20, 90, 40} and key = 30
Output: Element is present at index 2",https://www.geeksforgeeks.org/ternary-search/,Easy,['Searching Algorithm'],"
import math as mt
def ternarySearch(key, ar):
        l = 0
        r = len(ar)
        if (r >= l):
                mid1 = l + (r - l) //3
                mid2 = r - (r - l) //3
                if (ar[mid1] == key): 
                        return mid1
                
                if (ar[mid2] == key): 
                        return mid2
                
                if (key < ar[mid1]): 
                        return ternarySearch(l, mid1 - 1, key, ar)
                
                elif (key > ar[mid2]): 
                        return ternarySearch(mid2 + 1, r, key, ar)
                
                else: 
                        return ternarySearch(mid1 + 1, 
                                                                mid2 - 1, key, ar)
        return -1","['assert ternarySearch(5, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == 4']",name 'ternarySearch' is not defined,Remove
Karthik,b9f3e5e1-657a-413f-a266-970047b2222c,"Given an array of size N and an integer K, return the count of distinct numbers in all windows of size K. ","Input: arr[] = {1, 2, 1, 3, 4, 2, 3}, K = 4
Output: 3 4 4 3
Explanation: First window is {1, 2, 1, 3}, count of distinct numbers is 3
                      Second window is {2, 1, 3, 4} count of distinct numbers is 4
                      Third window is {1, 3, 4, 2} count of distinct numbers is 4
                      Fourth window is {3, 4, 2, 3} count of distinct numbers is 3

Input: arr[] = {1, 2, 4, 4}, K = 2
Output: 2 2 1
Explanation: First window is {1, 2}, count of distinct numbers is 2
                      First window is {2, 4}, count of distinct numbers is 2
                      First window is {4, 4}, count of distinct numbers is 1",https://www.geeksforgeeks.org/count-distinct-elements-in-every-window-of-size-k/,Medium,['Hash'],"def countDistinct(arr, K):
        def countWindowDistinct(win, K):
                dist_count = 0
                for i in range(K):
                        j = 0
                        while j < i:
                                if (win[i] == win[j]):
                                        break
                                else:
                                        j += 1
                        if (j == i):
                                dist_count += 1

                return dist_count
        N = len(arr)
        result = []
        for i in range(N - K + 1):
                result.append(countWindowDistinct(arr[i:K + i], K))
        return result","['assert countDistinct([1, 2, 1, 3, 4, 2, 3], 4) == [3,4,4,3]']",Assert Failed,Resolved. Changed the function thats being tested + changed code
Karthik,3418f7cc-2703-4dbb-8705-e51df4295087,"Given an array of n integers. Count the total number of sub-arrays having total distinct elements, the same as that of the total distinct elements of the original array. ","Input  : arr[] = {2, 1, 3, 2, 3}
Output : 5
Total distinct elements in array is 3
Total sub-arrays that satisfy the condition 
are:  Subarray from index 0 to 2
      Subarray from index 0 to 3
      Subarray from index 0 to 4
      Subarray from index 1 to 3
      Subarray from index 1 to 4

Input  : arr[] = {2, 4, 5, 2, 1}
Output : 2

Input  : arr[] = {2, 4, 4, 2, 4}
Output : 9",https://www.geeksforgeeks.org/count-subarrays-total-distinct-elements-original-array/,Hard,['Hash'],"
def countDistinctSubarray(arr):
        n = len(arr)
        unst1 = set(arr)
        totalDist = len(unst1)
        count = 0

        for i in range(n):
                unst = set()
                for j in range(i, n):
                        unst.add(arr[j])
                        if len(unst) == totalDist:
                                count += 1

        return count","['assert countDistinctSubarray([2, 1, 3, 2, 3]) == 5']",name 'countDistinctSubarray' is not defined,Resolved. Spelling mistake in the function
Karthik,06becabf-b745-4905-bc52-d291d0c15e0d,"A rotation (or circular shift) is an operation similar to shift except that the bits that fall off at one end are put back to the other end. In left rotation, the bits that fall off at left end are put back at right end. Write a program to left rotate the bits of a number by d places",Let n is stored using 8 bits. Left rotation of n = 11100101 by 3 makes n = 00101111 (Left shifted by 3 and first 3 bits are put back in last ). If n is stored using 16 bits or 32 bits then left rotation of n (000…11100101) becomes 00..0011100101000,https://www.geeksforgeeks.org/rotate-bits-of-an-integer/,Easy,['Bitwise Algorithms'],"INT_BITS = 32
def leftRotate(n, d):
        return (n << d)|(n >> (INT_BITS - d))","['assert leftRotate(16, 2) == 64']",name 'INT_BITS' is not defined,Resolved. Test case was wrong
Karthik,4fba2bf1-fda1-48e9-9c2a-bc3ed4718da0,"Given a positive integer n, write a function to find if it is a power of 2 or not","Input : n = 4
Output : Yes
Explanation: 22 = 4

Input : n = 32
Output : Yes
Explanation: 25 = 32",https://www.geeksforgeeks.org/program-to-find-whether-a-given-number-is-power-of-2/,Easy,['Bitwise Algorithms'],"import math

def Log2(x):
        if x == 0:
                return False

        return (math.log10(x) /
                        math.log10(2))

def isPowerOfTwo(n):
        return (math.ceil(Log2(n)) ==
                        math.floor(Log2(n)))",['assert isPowerOfTwo(31) == False'],name 'math' is not defined,Resolved. math imports taken care of now
Karthik,d8c99575-b9bd-4988-b2ed-23c3b889c9c8,"Given an integer ‘x’, write a python function that returns true if binary representation of x is palindrome else return false.",For example a numbers with binary representation as 10..01 is palindrome and number with binary representation as 10..00 is not palindrome.,https://www.geeksforgeeks.org/check-binary-representation-number-palindrome/,Medium,['Bitwise Algorithms'],"
import sys
def isKthBitSet(x, k):
        if ((x & (1 << (k - 1))) !=0):
                return True
        else:
                return False
def isPalindrome(x):
        l = 1 
        r = 2 * 8 
        while (l < r):
                if (isKthBitSet(x, l) != isKthBitSet(x, r)):
                        return False
                l += 1
                r -= 1
        
        return True",['assert isPalindrome(9) == True'],name 'isKthBitSet' is not defined,Remove. Input is weird
Karthik,8714ed57-3a2b-4115-b4d8-100182b1f6bb,Write a function to to convert a floating point number to binary,"Enter your floating point value : 
11.234
Enter the number of decimal places of the result : 
4

1011.0011

Enter your floating point value : 
1.234
Enter the number of decimal places of the result :
4

1.0011",https://www.geeksforgeeks.org/python-program-to-convert-floating-to-binary/,Hard,['Bitwise Algorithms'],"def float_bin(number, places = 3):
    def decimal_converter(num): 
        while num > 1:
                num /= 10
        return num
    whole, dec = str(number).split(""."")
    whole = int(whole)
    dec = int (dec)
    res = bin(whole).lstrip(""0b"") + "".""
    for x in range(places):
            whole, dec = str((decimal_converter(dec)) * 2).split(""."")
            dec = int(dec)
            res += whole
    return res","[""assert float_bin(11.234, 4) == '1011.0011'""]",name 'decimal_converter' is not defined,Resolved. Changed code and test case
Karthik,a1eec3ae-a390-4b99-90ae-8520d462bd27,"We are given an array of n distinct numbers. The task is to sort all even-placed numbers in increasing and odd-placed numbers in decreasing order. The modified array should contain all sorted even-placed numbers followed by reverse sorted odd-placed numbers. 
Note that the first element is considered as even placed because of its index 0. ","Input:  arr[] = {0, 1, 2, 3, 4, 5, 6, 7}
Output: arr[] = {0, 2, 4, 6, 7, 5, 3, 1}
Even-place elements : 0, 2, 4, 6
Odd-place elements : 1, 3, 5, 7
Even-place elements in increasing order : 
0, 2, 4, 6
Odd-Place elements in decreasing order : 
7, 5, 3, 1

Input: arr[] = {3, 1, 2, 4, 5, 9, 13, 14, 12}
Output: {2, 3, 5, 12, 13, 14, 9, 4, 1}
Even-place elements : 3, 2, 5, 13, 12
Odd-place elements : 1, 4, 9, 14
Even-place elements in increasing order : 
2, 3, 5, 12, 13
Odd-Place elements in decreasing order : 
14, 9, 4, 1 ",https://www.geeksforgeeks.org/sort-even-placed-elements-increasing-odd-placed-decreasing-order/,Easy,['Sorting Algorithms'],"def bitonicGenerator(arr):
        n = len(arr) 
        evenArr = [] 
        oddArr = [] 
        for i in range(n): 
                if ((i % 2) == 0): 
                        evenArr.append(arr[i]) 
                else: 
                        oddArr.append(arr[i]) 
        evenArr = sorted(evenArr) 
        oddArr = sorted(oddArr) 
        oddArr = oddArr[::-1] 

        i = 0
        for j in range(len(evenArr)): 
                arr[i] = evenArr[j] 
                i += 1
        for j in range(len(oddArr)): 
                arr[i] = oddArr[j] 
                i += 1
        return arr","['assert bitonicGenerator([0, 1, 2, 3, 4, 5, 6, 7]) == [0, 2, 4, 6, 7, 5, 3, 1]']",Assert Failed,Resolved. Changed test case and code
Karthik,99fa7e96-23ff-4c94-951a-98176d1045cb,"Given two arrays that have the same values but in a different order and having no duplicate elements in it, we need to make a second array the same as a first array using the minimum number of swaps. ","Input  : arrA[] = {3, 6, 4, 8}, 
         arrB[] = {4, 6, 8, 3}
Output : 2
Explanation: we can make arrB to same as arrA in 2 swaps which are shown below, swap 4 with 8,
arrB = {8, 6, 4, 3} swap 8 with 3,   arrB = {3, 6, 4, 8}",https://www.geeksforgeeks.org/minimum-swaps-to-make-two-array-identical/,Medium,['Sorting Algorithms'],"def minSwapsToSort(arr):
        n = len(arr)
        arrPos = [[0 for x in range(2)] 
                                for y in range(n)] 
        
        for i in range(n):         
                arrPos[i][0] = arr[i] 
                arrPos[i][1] = i 
        arrPos.sort() 
        vis = [False] * (n) 
        ans = 0

        for i in range(n): 
                if (vis[i] or arrPos[i][1] == i): 
                        continue
                cycle_size = 0
                j = i 
                
                while (not vis[j]):                 
                        vis[j] = 1
                        j = arrPos[j][1] 
                        cycle_size+= 1
                ans += (cycle_size - 1) 

        return ans 

def minSwapToMakeArraySame(a, b):
        n = len(a) 
        mp = {} 
        for i in range(n): 
                mp[b[i]] = i 
        for i in range(n): 
                b[i] = mp[a[i]] 
        return minSwapsToSort(b) ","['assert minSwapToMakeArraySame([3, 6, 4, 8], [4, 6, 8, 3]) == 2']",minSwapsToSort() takes 1 positional argument but 2 were given,Resolved. Changed code
Karthik,039c3ece-6170-412d-ae03-6d0825e0e340,"Given a two strings S and T, find the count of distinct occurrences of T in S as a subsequence.","Input: S = banana, T = ban
Output: 3
Explanation: T appears in S as below three subsequences.
[ban], [ba  n], [b   an]

Input: S = geeksforgeeks, T = ge
Output: 6
Explanation: T appears in S as below six subsequences.
[ge], [     ge], [g e], [g    e] [g     e]
and [     g e] ",https://www.geeksforgeeks.org/count-distinct-occurrences-as-a-subsequence/,Hard,['Sorting Algorithms'],"def findSubsequenceCount(s, t):
    def f(i, j, s, t):
        if(j >= len(t)):
                return 1
        
        if(i >= len(s)):
                return 0
        
        if(s[i] == t[j]):
                return f(i + 1, j + 1, s, t) + f(i + 1, j, s, t)
        
        return f(i + 1, j, s, t)
    return f(0, 0, s, t)","['assert findSubsequenceCount(""banana"", ""ban"") == 3']",name 'f' is not defined,Resolved. Changed code
Karthik,178ae598-7393-45be-a548-9ec811c72789,"Given an array arr[] of size ‘n’ and a positive integer k. Consider series of natural numbers and remove arr[0], arr[1], arr[2], …, arr[p] from it. Now the task is to find k-th smallest number in the remaining set of natural numbers. If no such number exists print “-1”.","Input : arr[] = { 1 } and k = 1.
Output: 2
Natural numbers are {1, 2, 3, 4, .... }
After removing {1}, we get {2, 3, 4, ...}.
Now, K-th smallest element = 2.
Input : arr[] = {1, 3}, k = 4.
Output : 6
First 5 Natural number {1, 2, 3, 4, 5, 6,  .. }
After removing {1, 3}, we get {2, 4, 5, 6, ... }.",https://www.geeksforgeeks.org/k-th-smallest-element-removing-integers-natural-numbers/,Hard,['Sorting Algorithms'],"MAX = 1000000
def ksmallest(arr, k):
        n = len(arr)
        b = [0]*MAX;
        for i in range(n):
                b[arr[i]] = 1;

        for j in range(1, MAX):
                if (b[j] != 1):
                        k-= 1;
                if (k is not 1):
                        return j;","['assert ksmallest([1, 3], 4) == 6']",name 'MAX' is not defined,Remove
Hafeez,38dca76c-ee6c-4c71-83a9-89240828a3b7,"Best Time to Buy and Sell Stock II: You are given an integer array prices where prices[i] is the price of a given stock on the ith day.

On each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day.

Find and return the maximum profit you can achieve.","Input: prices = [7,1,5,3,6,4]
Output: 7
Explanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.
Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.
Total profit is 4 + 3 = 7.
Input: prices = [7,6,4,3,1]
Output: 0
Explanation: There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0.",https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/,Medium,['Dynamic Programming'],"from typing import List
def maxProfit(prices: List[int]) -> int:
    cur_hold, cur_not_hold = -float('inf'), 0
    
    for stock_price in prices:
        
        prev_hold, prev_not_hold = cur_hold, cur_not_hold
        cur_hold = max( prev_hold, prev_not_hold - stock_price )
        cur_not_hold = max( prev_not_hold, prev_hold + stock_price )
    return cur_not_hold","['assert maxProfit([1,2,3,4,5])==4']",name 'List' is not defined,Resolved
Hafeez,296ab89e-7208-4f6f-bed1-d623f30e32c9,"Coin Change II: You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.

Return the number of combinations that make up that amount. If that amount of money cannot be made up by any combination of the coins, return 0.

You may assume that you have an infinite number of each kind of coin.

The answer is guaranteed to fit into a signed 32-bit integer.","Input: amount = 5, coins = [1,2,5]
Output: 4
Explanation: there are four ways to make up the amount:
5=5
5=2+2+1
5=2+1+1+1
5=1+1+1+1+1
Input: amount = 3, coins = [2]
Output: 0
Explanation: the amount of 3 cannot be made up just with coins of 2.",https://leetcode.com/problems/coin-change-ii/description/,Medium,['Dynamic Programming'],"from typing import List
def change(amount: int, coins: List[int]) -> int:
    def numberOfWays(i: int, amount: int) -> int:
        if amount == 0:
            return 1
        if i == len(coins):
            return 0
        if memo[i][amount] != -1:
            return memo[i][amount]

        if coins[i] > amount:
            memo[i][amount] = numberOfWays(i + 1, amount)
        else:
            memo[i][amount] = numberOfWays(i, amount - coins[i]) + numberOfWays(i + 1, amount)
        
        return memo[i][amount]

    memo = [[-1] * (amount + 1) for _ in range(len(coins))]
    return numberOfWays(0, amount)","['assert change(10,[10])==1']",name 'List' is not defined,Resolved
Hafeez,b6f47e1f-52e7-4dca-837f-88bc0d3b7a5a,"Backspace String Compare: Given two strings s and t, return true if they are equal when both are typed into empty text editors. '#' means a backspace character.

Note that after backspacing an empty text, the text will continue empty.","Input: s = ""ab#c"", t = ""ad#c""
Output: True
Explanation: Both s and t become ""ac"".
Input: s = ""a#c"", t = ""b""
Output: False
Explanation: s becomes ""c"" while t becomes ""b"".",https://leetcode.com/problems/backspace-string-compare/description/,Easy,['Stack'],"def backspaceCompare(S, T):
    def build(S):
        ans = []
        for c in S:
            if c != '#':
                ans.append(c)
            elif ans:
                ans.pop()
        return """".join(ans)
    return build(S) == build(T)","['assert backspaceCompare(""ab##"", ""c#d#"")==True']","invalid syntax (<string>, line 11)",Resolved. Changed code and test case
Hafeez,6ceae436-ff42-4122-a163-cc19372ef773,"Squirrel Simulation: You are given two integers height and width representing a garden of size height x width. You are also given:

an array tree where tree = [treer, treec] is the position of the tree in the garden,
an array squirrel where squirrel = [squirrelr, squirrelc] is the position of the squirrel in the garden,
and an array nuts where nuts[i] = [nutir, nutic] is the position of the ith nut in the garden.
The squirrel can only take at most one nut at one time and can move in four directions: up, down, left, and right, to the adjacent cell.

Return the minimal distance for the squirrel to collect all the nuts and put them under the tree one by one.

The distance is the number of moves.","Input: height = 5, width = 7, tree = [2,2], squirrel = [4,4], nuts = [[3,0], [2,5]]
Output: 12
Explanation: The squirrel should go to the nut at [2, 5] first to achieve a minimal distance.",https://leetcode.com/problems/squirrel-simulation/description/,Medium,['Math'],"from typing import List
def minDistance(height: int, width: int, tree: List[int], squirrel: List[int], nuts: List[List[int]]) -> int:
        firstPath = float('-inf')
        total_dist = 0
        for nut in nuts:
            dist_to_Sq = abs(squirrel[0]-nut[0])+abs(squirrel[1]-nut[1])
            dist_to_Tr = abs(tree[0]-nut[0])+abs(tree[1]-nut[1])
            if (dist_to_Tr-dist_to_Sq)>firstPath:
                firstPath = dist_to_Tr-dist_to_Sq
            total_dist+=2*dist_to_Tr
        total_dist = total_dist - firstPath
        return total_dist","['assert minDistance(1,3, [0,1], [0,0], [[0,2]])==3']",name 'List' is not defined,Resolved
Hafeez,22847d55-ac87-410b-956b-009096af4c77,"Consecutive Numbers Sum: Given an integer n, return the number of ways you can write n as the sum of consecutive positive integers.","Input: n = 5
Output: 2
Explanation: 5 = 2 + 3
Input: n = 15
Output: 4
Explanation: 15 = 8 + 7 = 4 + 5 + 6 = 1 + 2 + 3 + 4 + 5",https://leetcode.com/problems/consecutive-numbers-sum/description/,Hard,['Math'],"import math
def consecutiveNumbersSum(N: int) -> int:
    count = 0
    upper_limit = math.ceil((2 * N + 0.25)**0.5 - 0.5) + 1
    for k in range(1, upper_limit):
        if (N - k * (k + 1) // 2) % k == 0:
            count += 1
    return count",['assert consecutiveNumbersSum(9)==3'],name 'ceil' is not defined,Resolved
Hafeez,fc3fbbf7-4bca-4fca-9308-23d9f5735034,"Minimum Time Visiting All Points: On a 2D plane, there are n points with integer coordinates points[i] = [xi, yi]. Return the minimum time in seconds to visit all the points in the order given by points.

You can move according to these rules:

In 1 second, you can either:
move vertically by one unit,
move horizontally by one unit, or
move diagonally sqrt(2) units (in other words, move one unit vertically then one unit horizontally in 1 second).
You have to visit the points in the same order as they appear in the array.
You are allowed to pass through points that appear later in the order, but these do not count as visits.","Input: points = [[1,1],[3,4],[-1,0]]
Output: 7
Explanation: One optimal path is [1,1] -> [2,2] -> [3,3] -> [3,4] -> [2,3] -> [1,2] -> [0,1] -> [-1,0]   
Time from [1,1] to [3,4] = 3 seconds 
Time from [3,4] to [-1,0] = 4 seconds
Total time = 7 seconds",https://leetcode.com/problems/minimum-time-visiting-all-points/description/,Easy,['Geometry'],"from typing import List
def minTimeToVisitAllPoints(points: List[List[int]]) -> int:
    def rule(A, B):
        return max(abs(A[0] - B[0]), abs(A[1] - B[1]))
    s = 0
    for tup1, tup2 in zip(points[:-1], points[1:]):
        s += rule(tup1, tup2)
    return s","['assert minTimeToVisitAllPoints([[3,2],[-2,2]])==5']",name 'List' is not defined,Resolved
Hafeez,e2c47631-84af-497c-8e1d-3ce51c4b3eff,"Projection Area of 3D Shapes: You are given an n x n grid where we place some 1 x 1 x 1 cubes that are axis-aligned with the x, y, and z axes.

Each value v = grid[i][j] represents a tower of v cubes placed on top of the cell (i, j).

We view the projection of these cubes onto the xy, yz, and zx planes.

A projection is like a shadow, that maps our 3-dimensional figure to a 2-dimensional plane. We are viewing the ""shadow"" when looking at the cubes from the top, the front, and the side.

Return the total area of all three projections.","Input: grid = [[1,2],[3,4]]
Output: 17
Explanation: Here are the three projections (""shadows"") of the shape made with each axis-aligned plane.
Input: grid = [[1,0],[0,2]]
Output: 8",https://leetcode.com/problems/projection-area-of-3d-shapes/description/,Easy,['Geometry'],"def projectionArea(grid):
    N = len(grid)
    ans = 0
    for i in range(N):
        best_row = 0
        best_col = 0 
        for j in range(N):
            if grid[i][j]: ans += 1
            best_row = max(best_row, grid[i][j])
            best_col = max(best_col, grid[j][i])

        ans += best_row + best_col

    return ans",['assert projectionArea([[2]])==5'],name 'xrange' is not defined,Resolved
Hafeez,e1724953-bc74-4dbf-86e7-5713be00a339,"K Closest Points to Origin: Given an array of points where points[i] = [xi, yi] represents a point on the X-Y plane and an integer k, return the k closest points to the origin (0, 0).

The distance between two points on the X-Y plane is the Euclidean distance (i.e., √(x1 - x2)2 + (y1 - y2)2).

You may return the answer in any order. The answer is guaranteed to be unique (except for the order that it is in).","Input: points = [[1,3],[-2,2]], k = 1
Output: [[-2,2]]
Explanation:
The distance between (1, 3) and the origin is sqrt(10).
The distance between (-2, 2) and the origin is sqrt(8).
Since sqrt(8) < sqrt(10), (-2, 2) is closer to the origin.
We only want the closest k = 1 points from the origin, so the answer is just [[-2,2]].",https://leetcode.com/problems/k-closest-points-to-origin/description/,Medium,['Geometry'],"def kClosest(points, K):
    dist = lambda i: points[i][0]**2 + points[i][1]**2

    def sort(i, j, K):
        if i >= j: return
        k = random.randint(i, j)
        points[i], points[k] = points[k], points[i]

        mid = partition(i, j)
        if K < mid - i + 1:
            sort(i, mid - 1, K)
        elif K > mid - i + 1:
            sort(mid + 1, j, K - (mid - i + 1))

    def partition(i, j):
        oi = i
        pivot = dist(i)
        i += 1

        while True:
            while i < j and dist(i) < pivot:
                i += 1
            while i <= j and dist(j) >= pivot:
                j -= 1
            if i >= j: break
            points[i], points[j] = points[j], points[i]

        points[oi], points[j] = points[j], points[oi]
        return j

    sort(0, len(points) - 1, K)
    return points[:K]","['assert kClosest([[3,3],[5,-1],[-2,4]], 2)==[[3,3],[-2,4]]']",name 'random' is not defined,Remove. Randomnes question
Hafeez,e811f9cc-fa5e-4ea0-8adb-8cf3ab7c72db,"Detect Pattern of Length M Repeated K or More Times: Given an array of positive integers arr, find a pattern of length m that is repeated k or more times.

A pattern is a subarray (consecutive sub-sequence) that consists of one or more values, repeated multiple times consecutively without overlapping. A pattern is defined by its length and the number of repetitions.

Return true if there exists a pattern of length m that is repeated k or more times, otherwise return false.","Input: arr = [1,2,1,2,1,1,1,3], m = 2, k = 2
Output: true
Explanation: The pattern (1,2) of length 2 is repeated 2 consecutive times. Another valid pattern (2,1) is also repeated 2 times.
Input: arr = [1,2,1,2,1,3], m = 2, k = 3
Output: false
Explanation: The pattern (1,2) is of length 2 but is repeated only 2 times. There is no pattern of length 2 that is repeated 3 or more times.
",https://leetcode.com/problems/detect-pattern-of-length-m-repeated-k-or-more-times/description/,Easy,['Pattern'],"from typing import List
def containsPattern(arr: List[int], m: int, k: int) -> bool:
    i = 0
    while i <= len(arr)-1:
            p = arr[i:i+m]
            if p * k == arr[i:i+m*k]:
                    return True
            i += 1
    return False","['assert containsPattern([1,2,4,4,4,4],1,3)==True']",name 'List' is not defined,Resolved
Hafeez,8c9548d2-7b9c-46a4-9b8e-8afd488f7e87,"Find and Replace Pattern: Given a list of strings words and a string pattern, return a list of words[i] that match pattern. You may return the answer in any order.

A word matches the pattern if there exists a permutation of letters p so that after replacing every letter x in the pattern with p(x), we get the desired word.

Recall that a permutation of letters is a bijection from letters to letters: every letter maps to another letter, and no two letters map to the same letter.","Input: words = [""abc"",""deq"",""mee"",""aqq"",""dkd"",""ccc""], pattern = ""abb""
Output: [""mee"",""aqq""]
Explanation: ""mee"" matches the pattern because there is a permutation {a -> m, b -> e, ...}. 
""ccc"" does not match the pattern because {a -> c, b -> c, ...} is not a permutation, since a and b map to the same letter.",https://leetcode.com/problems/find-and-replace-pattern/description/,Medium,['Pattern'],"def findAndReplacePattern(words, pattern):
        def match(word):
            m1, m2 = {}, {}
            for w, p in zip(word, pattern):
                if w not in m1: m1[w] = p
                if p not in m2: m2[p] = w
                if (m1[w], m2[p]) != (p, w):
                    return False
            return True

        return list(filter(match, words))","['assert findAndReplacePattern([""a"",""b"",""c""], ""a"")==[""a"",""b"",""c""]']",Assert Failed,Resolved. Changed code
Calvin,f452df1d-cc8f-408f-a79d-1452e32ef567,Given a N*N board with the Knight placed on the first block of an empty board. Moving according to the rules of chess knight must visit each square exactly once. Return the order of each cell in which they are visited as a matrix or none if one does not exist.,"Input : 
N = 8
Output:
0  59  38  33  30  17   8  63
37  34  31  60   9  62  29  16
58   1  36  39  32  27  18   7
35  48  41  26  61  10  15  28
42  57   2  49  40  23   6  19
47  50  45  54  25  20  11  14
56  43  52   3  22  13  24   5
51  46  55  44  53   4  21  12",https://www.geeksforgeeks.org/the-knights-tour-problem/,,"[""'backtracking', 'matrix/grid'""]","def isSafe(x, y, board, n): 
  if(x >= 0 and y >= 0 and x < n and y < n and board[x][y] == -1): 
    return True
  return False

def solveKT(n): 
  board = [[-1 for i in range(n)]for i in range(n)]
  move_x = [2, 1, -1, -2, -2, -1, 1, 2] 
  move_y = [1, 2, 2, 1, -1, -2, -2, -1] 
  board[0][0] = 0 
  pos = 1
  if(not solveKTUtil(n, board, 0, 0, move_x, move_y, pos)): 
      return None
  else: 
      return board 
  
  
def solveKTUtil(n, board, curr_x, curr_y, move_x, move_y, pos): 
  if(pos == n**2): 
    return True
  for i in range(8): 
    new_x = curr_x + move_x[i] 
    new_y = curr_y + move_y[i] 
    if(isSafe(new_x, new_y, board, n)): 
      board[new_x][new_y] = pos 
      if(solveKTUtil(n, board, new_x, new_y, move_x, move_y, pos+1)): 
        return True
      board[new_x][new_y] = -1
  return False","['assert solveKT(8) == [[0,59,38,33,30,17, 8,63 ]]']","unexpected EOF while parsing (<string>, line 30)",Remove
Calvin,51a5caf9-241f-4de3-9ee2-9420490b73d7,"Given a set[] of non-negative integers and a value sum, return the subset of the given set whose sum is equal to the given sum or None if one doesn't exist
","Input: set = [1, 2, 3, 4, 5], sum = 10
Output: [1, 2, 3, 4]",https://www.geeksforgeeks.org/subset-sum-problem-dp-25/,,"[""'backtracking', 'recursion'""]","def subsetsum(fullset: list, target_sum: int):
    def subsetSum_helper(cur_idx: int, fullset: list, target_sum: int, subset: list):
        if target_sum == 0:
            return subset
        if (cur_idx == len(fullset)):
            return None
        excluding = subsetSum_helper(cur_idx + 1, fullset, target_sum, subset)
          
        if excluding is not None:
            return excluding
        elif fullset[cur_idx] <= target_sum:
            subset.append(fullset[cur_idx])
            including = subsetSum_helper(cur_idx + 1, fullset, target_sum - fullset[cur_idx], subset)
            if including!=None:
                return including
            else:
                subset.pop()
            return None
    return subsetSum_helper(0, fullset, target_sum, [])","['assert set(subsetsum([3, 34, 4, 12, 5, 2], 9)) == set([4,5])']",name 'subsetSum_helper' is not defined,Resolved Changed code
Calvin,1aeb3246-4c22-4d34-a48c-db7be8ba1b94,"You are given n activities with their start and finish times. Select the maximum number of activities that can be performed by a single person and return their indexes. Assume that a person can only work on a single activity at a time. 
","Input: start  =  {10, 12, 20}, finish =  {20, 25, 30}
Output: [0, 2]",,,"[""'greedy'""]","import numpy as np
def MaxActivities(s, f):
    indices = np.argsort(f)
    [s[i] for i in indices]
    [f[i] for i in indices]
    result = []
    n = len(f)
    i = 0
    result.append(i)
    for j in range(1, n):
        if s[j] >= f[i]:
            result.append(j)
            i = j
    return result
","['assert MaxActivities([2, 4, 5, 6, 7, 8], [3, 5, 6, 7, 9, 10]) == [0, 1, 2, 3, 4]']",name 'np' is not defined,Resolved
Calvin,5e7011e5-fee4-4c1a-a98f-3b81e50508cc,Return nth number in the fibonacci sequence,"Input: 9
Output: 34

Input: 7
Output: 13",,,"[""'recursion', 'mathematical'""]","def fibonacci(n):
    a = 0
    b = 1
    if n < 0:
        print(""Incorrect input"")
    elif n == 0:
        return a
    elif n == 1:
        return b
    else:
        for i in range(2, n+1):
            c = a + b
            a = b
            b = c
        return b
    b = c
    return fib(n-1, a, b)",['assert fibonacci(9) == 34'],"unindent does not match any outer indentation level (<string>, line 17)",Resolved
Calvin,e35d1110-85e8-4f50-80aa-91eb976b310b,Return the factorial of a given number n,"Input: 5
Output: 120

Input: 6
Output: 720",,,"[""'recursion', 'mathematical'""]","
def fact(n):
  if n <= 1:
    return 1
  return n*fact(n-1)
",['assert fact(5) == 120'],name 'fact' is not defined,Resolved
Calvin,9a970ea6-ed80-4fd3-a257-f01e0a8d5eaa,"Given a numerator and a denominator, return the fraction in string format. If the fractional part is repeating, enclose the repeating part in parentheses","Input: Numerator = 1, Denominator = 2
Output: ""0.5""

Input: Numerator = 2, Denominator = 3
Output: ""0.(6)""

Input: Numerator = 1, Denominator = 4
Output: ""0.25""

Input: Numerator = 4, Denominator = 333
Output: ""0.(012)""",,,"[""'recursion', 'mathematical', 'string'""]","
def helper(cur, numerator, denominator, numerators_seen):
  if numerator == 0:
    return cur
  elif numerator in numerators_seen.keys():
    idx = numerators_seen[numerator]
    return cur[:idx] + '(' + cur [idx:] + ')'
  numerators_seen[numerator] = len(cur)
  if numerator >= denominator:
    cur += str(numerator // denominator)
    numerator = numerator % denominator
    return helper(cur, numerator*10, denominator, numerators_seen)
  else:
    cur += ""0""
    return helper(cur, numerator*10, denominator, numerators_seen)

def fractionToDecimal(numerator, denominator):
  cur = """"
  if numerator == 0:
    return ""0""
  elif (numerator < 0 and denominator > 0) or (numerator > 0 and denominator < 0):
    cur = ""-""
  numerator = abs(numerator)
  denominator = abs(denominator)
  if numerator >= denominator:
    cur += str(numerator // denominator)
    numerator = numerator % denominator
    if numerator != 0:
      cur += "".""
      return helper(cur, numerator*10, denominator, dict())
    else:
      return cur
  else:
    cur += ""0.""
    return helper(cur, numerator*10, denominator, dict())
","['assert fractionToDecimal(1, 2) == ""0.5""']",helper() takes 2 positional arguments but 4 were given,Remove
Calvin,80e34b28-16a8-46ac-8b6a-ee28beb1e8d4,"Write a function that reverses a string. The input string is given as an array of characters s.

You must do this by modifying the input array in-place with O(1) extra memory.","Input: [""h"",""e"",""l"",""l"",""o""]
Output: [""o"",""l"",""l"",""e"",""h""]

Input: [""H"",""a"",""n"",""n"",""a"",""h""]
Output: [""h"",""a"",""n"",""n"",""a"",""H""]",,,"[""'string'""]","def reverse_string(s: list):
  l = 0
  r = len(s) - 1
  while l < r:
    tmp = s[l]
    s[l] = s[r]
    s[r] = tmp
    l += 1
    r -= 1
  return s","['assert reverse_string([""a"",""b"",""c"",""d""]) == [""d"", ""c"", ""b"", ""a""]']",Assert Failed,Resolved
Calvin,87372a22-f5ef-4100-845b-28700ca3fde3,"You are given a string s and an integer array indices of the same length. The string s will be shuffled such that the character at the ith position moves to indices[i] in the shuffled string.

Return the shuffled string.","Input: s = ""codeleet"", indices = [4,5,6,7,0,2,1,3]
Output: ""leetcode""

Input: s = ""abc"", indices = [0,1,2]
Output: ""abc""",,,"[""'string'""]","from typing import List
def shuffle_string(s: str, indices: List[int]):
    def partitionString(s):
      substrings = 1
      cur_str = set()
      for i in range(len(s)):
        if s[i] in cur_str:
          substrings += 1
          cur_str = {s[i]}
        else:
          cur_str.add(s[i])
      return substrings
    ret = ['_']*len(s)
    for idx, i in enumerate(indices):
        ret[i] = s[idx]
    return """".join(ret)","['assert shuffle_string(""reoc"", [2, 0, 1, 3]) == ""eorc""']",type' object is not subscriptable,Reoslved changed code and test case