[{"question": "Given a N*N board with the Knight placed on the first block of an empty board. Moving according to the rules of chess knight must visit each square exactly once. Print the order of each cell in which they are visited.\n", "code": "\ndef isSafe(x, y, board, n): \n  if(x >= 0 and y >= 0 and x < n and y < n and board[x][y] == -1): \n    return True\n  return False\n\ndef printSolution(n, board):\n  for i in range(n): \n    for j in range(n): \n      print(board[i][j], end=' ') \n    print() \n  \n  \ndef solveKT(n): \n  board = [[-1 for i in range(n)]for i in range(n)]\n  move_x = [2, 1, -1, -2, -2, -1, 1, 2] \n  move_y = [1, 2, 2, 1, -1, -2, -2, -1] \n  board[0][0] = 0 \n  pos = 1\n  if(not solveKTUtil(n, board, 0, 0, move_x, move_y, pos)): \n      print(\"Solution does not exist\") \n  else: \n      printSolution(n, board) \n  \n  \ndef solveKTUtil(n, board, curr_x, curr_y, move_x, move_y, pos): \n  if(pos == n**2): \n    return True\n  for i in range(8): \n    new_x = curr_x + move_x[i] \n    new_y = curr_y + move_y[i] \n    if(isSafe(new_x, new_y, board, n)): \n      board[new_x][new_y] = pos \n      if(solveKTUtil(n, board, new_x, new_y, move_x, move_y, pos+1)): \n        return True\n      board[new_x][new_y] = -1\n  return False\n", "categories": ["backtracking", "matrix/grid"]}, {"question": "A Maze is given as N*N binary matrix of blocks where source block is maze[0][0] and destination block is maze[N-1][N-1]. \nA rat starts from source and has to reach the destination. The rat can move only in two directions: forward and down. \n\nIn the maze matrix, 0 means the block is a dead end and 1 means the block can be used in the path from source to destination. \nGiven an N*N input maze Output a N*N matrix where all entries in the solution path are marked as 1 or output Solution does not exist if no solution exists.\n", "code": "\ndef isValid(n, maze, x, y, res):\n  if x >= 0 and y >= 0 and x < n and y < n and maze[x][y] == 1 and res[x][y] == 0:\n    return True\n  return False\n\ndef RatMaze(n, maze, move_x, move_y, x, y, res):\n  if x == n-1 and y == n-1:\n    return True\n  for i in range(4):\n    x_new = x + move_x[i]\n    y_new = y + move_y[i]\n    if isValid(n, maze, x_new, y_new, res):\n      res[x_new][y_new] = 1\n      if RatMaze(n, maze, move_x, move_y, x_new, y_new, res):\n          return True\n      res[x_new][y_new] = 0\n  return False\n \ndef solveMaze(maze):\n    n = len(maze)\n    res = [[0 for i in range(n)] for i in range(n)]\n    res[0][0] = 1\n    move_x = [-1, 1, 0, 0]\n    move_y = [0, 0, -1, 1]\n    if RatMaze(n, maze, move_x, move_y, 0, 0, res):\n        for i in range(n):\n            for j in range(n):\n                print(res[i][j], end=' ')\n            print()\n    else:\n        print('Solution does not exist')\n", "categories": ["backtracking", "matrix/grid"]}, {"question": "Given an input N for a NxN chessboard place N queens such that no two queens attack each other. Return the NxN board with the Queens marked as Q. If the problem is not solvable return Solution does not exist\n", "code": "\ndef printSolution(board):\n  for i in range(len(board)):\n    for j in range(len(board)):\n      if board[i][j] == 1:\n        print(\"Q\",end=\" \")\n      else:\n        print(\".\",end=\" \")\n    print()\n\ndef isSafe(board, row, col):\n  for i in range(col):\n    if board[row][i] == 1:\n      return False\n  for i, j in zip(range(row, -1, -1), range(col, -1, -1)):\n    if board[i][j] == 1:\n      return False\n  for i, j in zip(range(row, len(board), 1), range(col, -1, -1)):\n    if board[i][j] == 1:\n      return False\n\n  return True\n \ndef solveNQUtil(board, col):\n  if col >= len(board):\n    return True\n  for i in range(len(board)):\n    if isSafe(board, i, col):\n      board[i][col] = 1\n      if solveNQUtil(board, col + 1) == True:\n        return True\n      board[i][col] = 0\n  return False\n\ndef solveNQ(N):\n  board = []\n  for row in range(N):\n    board.append([0]*N)\n  if solveNQUtil(board, 0) == False:\n    print(\"Solution does not exist\")\n  printSolution(board)\n", "categories": ["backtracking", "matrix/grid"]}, {"question": "Given a set[] of non-negative integers and a value sum, return the subset of the given set whose sum is equal to the given sum or None if one doesn't exist\n", "code": "\ndef subsetSum_helper(cur_idx: int, fullset: list, target_sum: int, subset: list):\n  if target_sum == 0:\n    return subset\n\n  if (cur_idx == len(fullset)):\n    return None\n  \n  excluding = subsetSum_helper(cur_idx + 1, fullset, target_sum, subset)\n  if excluding is not None:\n    return excluding\n  elif fullset[cur_idx] <= target_sum:\n    subset.append(fullset[cur_idx])\n    including = subsetSum_helper(cur_idx + 1, fullset, target_sum - fullset[cur_idx], subset)\n    if including is not None:\n      return including\n    else:\n      subset.pop()\n  return None\n\ndef subsetsum(fullset: list, target_sum: int):\n  return subsetSum_helper(0, fullset, target_sum, [])\n", "categories": ["backtracking", "recursion"]}, {"question": "Given an undirected graph in the form of an adjacency matrix and a number m color the graph with m colors such that no two adjacent vertices share the same color. Return a list of colors for each vertex or None if no solution exists.", "code": "\ndef isSafe(graph, v, colour, c):\n  for i in range(len(graph)):\n    if graph[v][i] == 1 and colour[i] == c:\n      return False\n  return True\n\ndef graphColourUtil(graph, m, colour, v):\n  if v == len(graph):\n    return True\n\n  for c in range(1, m + 1):\n    if isSafe(graph, v, colour, c) == True:\n      colour[v] = c\n      if graphColourUtil(graph, m, colour, v + 1) == True:\n        return True\n      colour[v] = 0\n\ndef graphColouring(graph:[[int]], m):\n  colour = [0] * len(graph)\n  if graphColourUtil(graph, m, colour, 0):\n    return colour\n  else:\n    return None\n", "categories": ["backtracking", "graph"]}]