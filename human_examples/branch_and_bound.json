[{"question": "Given two integer arrays val[0..n-1] and wt[0..n-1] that represent values and weights associated with n items respectively. \n\nFind out the maximum value subset of val[] such that sum of the weights of this subset is smaller than or equal to Knapsack capacity W.\n", "code": "\nfrom queue import Queue\nclass Item:\n    def __init__(self, weight, value):\n        self.weight = weight\n        self.value = value\nclass Node:\n    def __init__(self, level, profit, bound, weight):\n        self.level = level\n        self.profit = profit\n        self.bound = bound\n        self.weight = weight\ndef compare(a, b):\n    r1 = float(a.value) / a.weight\n    r2 = float(b.value) / b.weight\n    return r1 > r2\n \ndef bound(u, n, W, arr):\n    if u.weight >= W:\n        return 0\n    profitBound = u.profit\n    j = u.level + 1\n    totWeight = int(u.weight)\n \n    while j < n and totWeight + int(arr[j].weight) <= W:\n        totWeight += int(arr[j].weight)\n        profitBound += arr[j].value\n        j += 1\n\n    if j < n:\n        profitBound += int((W - totWeight) * arr[j].value / arr[j].weight)\n \n    return profitBound\n \ndef knapsack_solution(W, arr, n):\n    arr.sort(cmp=compare, reverse=True)\n\n    q = Queue()\n    u = Node(-1, 0, 0, 0)\n    q.put(u)\n\n    maxProfit = 0\n \n    while not q.empty():\n        u = q.get()\n \n        if u.level == -1:\n            v = Node(0, 0, 0, 0)\n\n        if u.level == n - 1:\n            continue\n\n        v = Node(u.level + 1, u.profit +\n                 arr[u.level + 1].value, 0, u.weight + arr[u.level + 1].weight)\n\n        if v.weight <= W and v.profit > maxProfit:\n            maxProfit = v.profit\n \n        v.bound = bound(v, n, W, arr)\n \n        if v.bound > maxProfit:\n            q.put(v)\n \n        v = Node(u.level + 1, u.profit, 0, u.weight)\n \n        v.bound = bound(v, n, W, arr)\n \n        if v.bound > maxProfit:\n            q.put(v)\n \n    return maxProfit\n", "categories": ["branch and bound"]}, {"question": "Given a 3\u00d73 board with 8 tiles (every tile has one number from 1 to 8) and one empty space. The objective is to place the numbers on tiles to match the final configuration using the empty space. We can slide four adjacent (left, right, above, and below) tiles into the empty space. \n\nFor example, \ninitial: [[1,2,3],[5,6,None],[7,8,4]]\nfinal: [[1,2,3],[5,8,6],[None,7,4]]\n", "code": "\nimport copy\nfrom heapq import heappush, heappop\n \n# This variable can be changed to change\n# the program from 8 puzzle(n=3) to 15 \n# puzzle(n=4) to 24 puzzle(n=5)...\nn = 3\n \n# bottom, left, top, right\nrow = [ 1, 0, -1, 0 ]\ncol = [ 0, -1, 0, 1 ]\n \n# A class for Priority Queue\nclass priorityQueue:\n     \n    # Constructor to initialize a\n    # Priority Queue\n    def __init__(self):\n        self.heap = []\n \n    # Inserts a new key 'k'\n    def push(self, k):\n        heappush(self.heap, k)\n \n    # Method to remove minimum element \n    # from Priority Queue\n    def pop(self):\n        return heappop(self.heap)\n \n    # Method to know if the Queue is empty\n    def empty(self):\n        if not self.heap:\n            return True\n        else:\n            return False\n \n# Node structure\nclass node:\n     \n    def __init__(self, parent, mat, empty_tile_pos,\n                 cost, level):\n                      \n        # Stores the parent node of the \n        # current node helps in tracing \n        # path when the answer is found\n        self.parent = parent\n \n        # Stores the matrix\n        self.mat = mat\n \n        # Stores the position at which the\n        # empty space tile exists in the matrix\n        self.empty_tile_pos = empty_tile_pos\n \n        # Stores the number of misplaced tiles\n        self.cost = cost\n \n        # Stores the number of moves so far\n        self.level = level\n \n    # This method is defined so that the \n    # priority queue is formed based on \n    # the cost variable of the objects\n    def __lt__(self, nxt):\n        return self.cost < nxt.cost\n \n# Function to calculate the number of \n# misplaced tiles ie. number of non-blank\n# tiles not in their goal position\ndef calculateCost(mat, final) -> int:\n     \n    count = 0\n    for i in range(n):\n        for j in range(n):\n            if ((mat[i][j]) and\n                (mat[i][j] != final[i][j])):\n                count += 1\n                 \n    return count\n \ndef newNode(mat, empty_tile_pos, new_empty_tile_pos,\n            level, parent, final) -> node:\n                 \n    # Copy data from parent matrix to current matrix\n    new_mat = copy.deepcopy(mat)\n \n    # Move tile by 1 position\n    x1 = empty_tile_pos[0]\n    y1 = empty_tile_pos[1]\n    x2 = new_empty_tile_pos[0]\n    y2 = new_empty_tile_pos[1]\n    new_mat[x1][y1], new_mat[x2][y2] = new_mat[x2][y2], new_mat[x1][y1]\n \n    # Set number of misplaced tiles\n    cost = calculateCost(new_mat, final)\n \n    new_node = node(parent, new_mat, new_empty_tile_pos,\n                    cost, level)\n    return new_node\n \n# Function to print the N x N matrix\ndef printMatrix(mat):\n     \n    for i in range(n):\n        for j in range(n):\n            print(\"%d \" % (mat[i][j]), end = \" \")\n             \n        print()\n \n# Function to check if (x, y) is a valid\n# matrix coordinate\ndef isSafe(x, y):\n     \n    return x >= 0 and x < n and y >= 0 and y < n\n \n# Print path from root node to destination node\ndef printPath(root):\n     \n    if root == None:\n        return\n     \n    printPath(root.parent)\n    printMatrix(root.mat)\n    print()\n \n# Function to solve N*N - 1 puzzle algorithm\n# using Branch and Bound. empty_tile_pos is\n# the blank tile position in the initial state.\ndef solve(initial, empty_tile_pos, final):\n     \n    # Create a priority queue to store live\n    # nodes of search tree\n    pq = priorityQueue()\n \n    # Create the root node\n    cost = calculateCost(initial, final)\n    root = node(None, initial, \n                empty_tile_pos, cost, 0)\n \n    # Add root to list of live nodes\n    pq.push(root)\n \n    # Finds a live node with least cost,\n    # add its children to list of live \n    # nodes and finally deletes it from \n    # the list.\n    while not pq.empty():\n \n        # Find a live node with least estimated\n        # cost and delete it from the list of \n        # live nodes\n        minimum = pq.pop()\n \n        # If minimum is the answer node\n        if minimum.cost == 0:\n             \n            # Print the path from root to\n            # destination;\n            printPath(minimum)\n            return\n \n        # Generate all possible children\n        for i in range(4):\n            new_tile_pos = [\n                minimum.empty_tile_pos[0] + row[i],\n                minimum.empty_tile_pos[1] + col[i], ]\n                 \n            if isSafe(new_tile_pos[0], new_tile_pos[1]):\n                 \n                # Create a child node\n                child = newNode(minimum.mat,\n                                minimum.empty_tile_pos,\n                                new_tile_pos,\n                                minimum.level + 1,\n                                minimum, final,)\n \n                # Add child to list of live nodes\n                pq.push(child)\n", "categories": ["branch and bound", "matrix/grid"]}, {"question": "Given an input N for a NxN chessboard place N queens such that no two queens attack each other. Return the NxN board with the Queens marked as Q. If the problem is not solvable return Solution does not exist\n", "code": "\nN = 8\n\ndef printSolution(board):\n    for i in range(N):\n        for j in range(N):\n            print(board[i][j], end = \" \")\n        print()\n\ndef isSafe(row, col, slashCode, backslashCode, \n           rowLookup, slashCodeLookup, \n                       backslashCodeLookup):\n    if (slashCodeLookup[slashCode[row][col]] or\n        backslashCodeLookup[backslashCode[row][col]] or\n        rowLookup[row]):\n        return False\n    return True\n\ndef solveNQueensUtil(board, col, slashCode, backslashCode, \n                     rowLookup, slashCodeLookup,\n                     backslashCodeLookup):\n    if(col >= N):\n        return True\n    for i in range(N):\n        if(isSafe(i, col, slashCode, backslashCode, \n                  rowLookup, slashCodeLookup,\n                  backslashCodeLookup)):\n            board[i][col] = 1\n            rowLookup[i] = True\n            slashCodeLookup[slashCode[i][col]] = True\n            backslashCodeLookup[backslashCode[i][col]] = True\n            if(solveNQueensUtil(board, col + 1, \n                                slashCode, backslashCode, \n                                rowLookup, slashCodeLookup, \n                                backslashCodeLookup)):\n                return True\n            board[i][col] = 0\n            rowLookup[i] = False\n            slashCodeLookup[slashCode[i][col]] = False\n            backslashCodeLookup[backslashCode[i][col]] = False\n             \n    return False\ndef solveNQueens():\n    board = [[0 for i in range(N)] \n                for j in range(N)]\n     \n    # helper matrices \n    slashCode = [[0 for i in range(N)] \n                    for j in range(N)]\n    backslashCode = [[0 for i in range(N)] \n                        for j in range(N)]\n     \n    # arrays to tell us which rows are occupied \n    rowLookup = [False] * N\n     \n    # keep two arrays to tell us \n    # which diagonals are occupied \n    x = 2 * N - 1\n    slashCodeLookup = [False] * x\n    backslashCodeLookup = [False] * x\n     \n    # initialize helper matrices \n    for rr in range(N):\n        for cc in range(N):\n            slashCode[rr][cc] = rr + cc\n            backslashCode[rr][cc] = rr - cc + 7\n     \n    if(solveNQueensUtil(board, 0, slashCode, backslashCode, \n                        rowLookup, slashCodeLookup, \n                        backslashCodeLookup) == False):\n        print(\"Solution does not exist\")\n        return False\n         \n    # solution found \n    printSolution(board)\n    return True\n", "categories": ["branch and bound", "matrix/grid"]}, {"question": "Let there be N workers and N jobs. Any worker can be assigned to perform any job, incurring some cost that may vary depending on the work-job assignment. It is required to perform all jobs by assigning exactly one worker to each job and exactly one job to each agent in such a way that the total cost of the assignment is minimized.\nYour input will be an NxN matrix of cost for each work to do each job. Return an assignment matrix with the least cost.\n", "code": "\nimport math\nfrom heapq import heappush, heappop\n\nclass priorityQueue:\n     \n    # Constructor to initialize a\n    # Priority Queue\n    def __init__(self):\n        self.heap = []\n \n    # Inserts a new key 'k'\n    def push(self, k):\n        heappush(self.heap, k)\n \n    # Method to remove minimum element \n    # from Priority Queue\n    def pop(self):\n        return heappop(self.heap)\n \n    # Method to know if the Queue is empty\n    def empty(self):\n        if not self.heap:\n            return True\n        else:\n            return False\n\nclass Node():\n    def __init__(self, parent, pathCost, cost, workerID, jobID, assigned):\n        self.parent = parent\n        self.pathCost = pathCost\n        self.cost = cost\n        self.workerID = workerID\n        self.jobId = jobID\n        self.assigned = assigned\n\n    def __lt__(self, other):\n        return self.cost < other.cost\n\ndef newNode(x, y, assigned, parent):\n    a = copy(assigned)\n    a[y] = True\n    return Node(parent, None, None, x, y, a)\n\ndef calcCost(cost_matrix, x, y, assigned):\n    cost = 0\n    available = [True] * len(cost_matrix)\n    for i in range(x+1, len(cost_matrix)):\n        min = math.inf\n        minIndex = -1\n        for j in range(len(cost_matrix)):\n            if not assigned[j] and available[j] and cost_matrix[i][j] < min:\n                minIndex = j\n                min = cost_matrix[i][j]\n        cost += min\n        available[minIndex] = False\n\n    return cost\n\ndef retAssignment(min: Node, n):\n    ret = []\n    for i in range(n):\n        ret.append([False]*n)\n    cur = min\n    while cur is not None:\n        ret[cur.workerID][cur.jobId] = True\n        cur = cur.parent\n\ndef find_min_cost(cost_matrix):\n    pq = priorityQueue()\n    assigned = [False] * len(cost_matrix)\n    root = newNode(-1,-1, assigned, None)\n    root.pathCost = 0\n    root.cost = 0\n    root.workerID = -1\n    pq.push(root)\n    while not pq.empty():\n        min = pq.pop()\n        i = min.workerID + 1\n        if i == len(cost_matrix):\n            return retAssignment(min, len(cost_matrix))\n        for j in range(len(cost_matrix)):\n            child = newNode(i,j,min.assigned, min)\n            child.pathCost = min.pathCost + cost_matrix[i][j]\n            child.cost = child.pathCost + calcCost(cost_matrix, i, j, child.assigned)\n            pq.push(child)\n", "categories": ["branch and bound", "matrix/grid"]}, {"question": "Given a set of cities and distance between every pair of cities, the problem is to find the shortest possible tour that visits every city exactly once and returns to the starting point.\n", "code": "\nimport math\nmaxsize = float('inf')\ndef copyToFinal(curr_path):\n\tfinal_path[:N + 1] = curr_path[:]\n\tfinal_path[N] = curr_path[0]\ndef firstMin(adj, i):\n\tmin = maxsize\n\tfor k in range(N):\n\t\tif adj[i][k] < min and i != k:\n\t\t\tmin = adj[i][k]\n\n\treturn min\n\ndef secondMin(adj, i):\n\tfirst, second = maxsize, maxsize\n\tfor j in range(N):\n\t\tif i == j:\n\t\t\tcontinue\n\t\tif adj[i][j] <= first:\n\t\t\tsecond = first\n\t\t\tfirst = adj[i][j]\n\n\t\telif(adj[i][j] <= second and\n\t\t\tadj[i][j] != first):\n\t\t\tsecond = adj[i][j]\n\n\treturn second\n\ndef TSPRec(adj, curr_bound, curr_weight, \n\t\t\tlevel, curr_path, visited):\n\tglobal final_res\n\n\tif level == N:\n\n\t\tif adj[curr_path[level - 1]][curr_path[0]] != 0:\n\t\t\tcurr_res = curr_weight + adj[curr_path[level - 1]]\t\t\t\t\t\t\t\t\t\t[curr_path[0]]\n\t\t\tif curr_res < final_res:\n\t\t\t\tcopyToFinal(curr_path)\n\t\t\t\tfinal_res = curr_res\n\t\treturn\n\n\tfor i in range(N):\n\t\tif (adj[curr_path[level-1]][i] != 0 and\n\t\t\t\t\t\t\tvisited[i] == False):\n\t\t\ttemp = curr_bound\n\t\t\tcurr_weight += adj[curr_path[level - 1]][i]\n\t\t\tif level == 1:\n\t\t\t\tcurr_bound -= ((firstMin(adj, curr_path[level - 1]) +\n\t\t\t\t\t\t\t\tfirstMin(adj, i)) / 2)\n\t\t\telse:\n\t\t\t\tcurr_bound -= ((secondMin(adj, curr_path[level - 1]) +\n\t\t\t\t\t\t\t\tfirstMin(adj, i)) / 2)\n\t\t\tif curr_bound + curr_weight < final_res:\n\t\t\t\tcurr_path[level] = i\n\t\t\t\tvisited[i] = True\n\t\t\t\tTSPRec(adj, curr_bound, curr_weight, \n\t\t\t\t\tlevel + 1, curr_path, visited)\n\t\t\tcurr_weight -= adj[curr_path[level - 1]][i]\n\t\t\tcurr_bound = temp\n\t\t\tvisited = [False] * len(visited)\n\t\t\tfor j in range(level):\n\t\t\t\tif curr_path[j] != -1:\n\t\t\t\t\tvisited[curr_path[j]] = True\ndef TSP(adj):\n\tcurr_bound = 0\n\tcurr_path = [-1] * (N + 1)\n\tvisited = [False] * N\n\tfor i in range(N):\n\t\tcurr_bound += (firstMin(adj, i) +\n\t\t\t\t\tsecondMin(adj, i))\n\tcurr_bound = math.ceil(curr_bound / 2)\n\tvisited[0] = True\n\tcurr_path[0] = 0\n\tTSPRec(adj, curr_bound, 0, 1, curr_path, visited)\n\n# Driver code\n\n# Adjacency matrix for the given graph\nadj = [[0, 10, 15, 20],\n\t[10, 0, 35, 25],\n\t[15, 35, 0, 30],\n\t[20, 25, 30, 0]]\nN = 4\n\n# final_path[] stores the final solution \n# i.e. the // path of the salesman.\nfinal_path = [None] * (N + 1)\n\n# visited[] keeps track of the already\n# visited nodes in a particular path\nvisited = [False] * N\n\n# Stores the final minimum weight\n# of shortest tour.\nfinal_res = maxsize\n\nTSP(adj)\n\nprint(\"Minimum cost :\", final_res)\nprint(\"Path Taken : \", end = ' ')\nfor i in range(N + 1):\n\tprint(final_path[i], end = ' ')\n", "categories": ["branch and bound", "graph"]}]