[{"question": "You are given an array of people, people, which are the attributes of some people in a queue (not necessarily in order). Each people[i] = [hi, ki] represents the ith person of height hi with exactly ki other people in front who have a height greater than or equal to hi.\n\nReconstruct and return the queue that is represented by the input array people. The returned queue should be formatted as an array queue, where queue[j] = [hj, kj] is the attributes of the jth person in the queue (queue[0] is the person at the front of the queue).\n", "code": "\ndef reconstructQueue(people):\n    output=[] \n    people.sort(key=lambda x: (-x[0], x[1]))                \n    for a in people:\n        output.insert(a[1], a)\n    \n    return output\n", "categories": ["greedy", "array"]}, {"question": "There are N Mice and N holes are placed in a straight line. Each hole can accommodate only 1 mouse. A mouse can stay at his position, move one step right from x to x + 1, or move one step left from x to x -1. Any of these moves consumes 1 minute. Assign mice to holes so that the time when the last mouse gets inside a hole is minimized.\nYou are given a list of mice and hole positions as integer scalers.\n", "code": "\ndef assignHole(mices, holes):\n    if (len(mices) != len(holes)):\n        return -1\n    mices.sort()\n    holes.sort()\n    Max = 0\n     \n    for i in range(len(holes)):\n        if (Max < abs(mices[i] - holes[i])):\n            Max = abs(mices[i] - holes[i])\n     \n    return Max\n", "categories": ["greedy", "array", "sorting"]}, {"question": "Every positive fraction can be represented as sum of unique unit fractions. A fraction is unit fraction if numerator is 1 and denominator is a positive integer, for example 1/3 is a unit fraction. Such a representation is called Egyptian Fraction.\nGiven a numerator and denominator print the  Egyptian Fraction.\n", "code": "\nimport math\ndef egyptianFraction(nr, dr):\n \n    print(\"The Egyptian Fraction \" +\n          \"Representation of {0}/{1} is\".\n                format(nr, dr), end=\"\n\")\n    ef = []\n    while nr != 0:\n        x = math.ceil(dr / nr)\n        ef.append(x)\n        nr = x * nr - dr\n        dr = dr * x\n    for i in range(len(ef)):\n        if i != len(ef) - 1:\n            print(\" 1/{0} +\" . \n                    format(ef[i]), end = \" \")\n        else:\n            print(\" 1/{0}\" .\n                    format(ef[i]), end = \" \")\n", "categories": ["greedy", "mathematical"]}, {"question": "Every house in the colony has at most one pipe going into it and at most one pipe going out of it. Tanks and taps are to be installed in a manner such that every house with one outgoing pipe but no incoming pipe gets a tank installed on its roof and every house with only an incoming pipe and no outgoing pipe gets a tap.\n\nGiven two integers n and p denoting the number of houses and the number of pipes. The connections of pipe among the houses contain three input values: a_i, b_i, d_i denoting the pipe of diameter d_i from house a_i to house b_i, find out the efficient solution for the network. \n\nThe output will contain the number of pairs of tanks and taps t installed in first line and the next t lines contain three integers: house number of tank, house number of tap and the minimum diameter of pipe between them.\n\nExample:\nInput:  4 2\n        1 2 60\n        3 4 50\nOutput: 2\n        1 2 60\n        3 4 50\n", "code": "\ndef dfs(w, ans, cd, wt):\n\tif (cd[w] == 0):\n\t\treturn w, ans\n\tif (wt[w] < ans):\n\t\tans = wt[w]\n\treturn dfs(cd[w], ans, cd, wt)\n\n# Function performing calculations.\ndef solve(n, p, arr):\n    # Array rd stores the \n    # ending vertex of pipe\n    rd = [0]*1100\n\n    # Array wd stores the value \n    # of diameters between two pipes\n    wt = [0]*1100\n\n    # Array cd stores the \n    # starting end of pipe\n    cd = [0]*1100\n    ans = 0\n    i = 0\n    while (i < p):\n        q = arr[i][0]\n        h = arr[i][1]\n        t = arr[i][2]\n        \n        cd[q] = h\n        wt[q] = t\n        rd[h] = q\n        i += 1\n    a = []\n    b = []\n    c = []\n\t\n    for j in range(1, n + 1):\n        if (rd[j] == 0 and cd[j]):\n            \n            ans = 1000000000\n            w, ans = dfs(j, ans, cd, wt)\n            \n            # We put the details of component\n            # in final output array\n            a.append(j)\n            b.append(w) \n            c.append(ans)\n    print(len(a))\n    for j in range(len(a)):\n        print(a[j], b[j], c[j])\n", "categories": ["greedy", "graph"]}, {"question": "You are given n activities with their start and finish times. Select the maximum number of activities that can be performed by a single person and return their indexes. Assume that a person can only work on a single activity at a time. \nExample:\nInput: start[]  =  {10, 12, 20}, finish[] =  {20, 25, 30}\nOutput: 0 2\n", "code": "\nimport numpy as np\ndef printMaxActivities(s, f):\n    indices = np.argsort(f)\n    [s[i] for i in indices]\n    [f[i] for i in indices]\n    n = len(f)\n    print(\"Following activities are selected\")\n    i = 0\n    print(i, end=' ')\n\n    # Consider rest of the activities\n    for j in range(1, n):\n\n        # If this activity has start time greater than\n        # or equal to the finish time of previously\n        # selected activity, then select it\n        if s[j] >= f[i]:\n            print(j, end=' ')\n            i = j\n", "categories": ["greedy"]}]