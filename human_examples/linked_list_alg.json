[{"question": "Given the head of a singly linked list, reverse the list, and return the reversed list.\nDefinition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n", "code": "\ndef reverseList(head):\n    if head == None:\n        return None\n    cur = head\n    next = cur.next\n    while next:\n        tmp = next.next\n        next.next = cur\n        cur = next\n        next = tmp\n\n    head.next = None\n    return cur\n"}, {"question": "Given the head of a singly linked list, return true if it is a palindrome or false otherwise.\nDefinition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n", "code": "\ndef isPalindrome(head):\n    slow = fast = head \n    while fast and fast.next:\n        fast = fast.next.next\n        slow = slow.next \n        \n    stack1=[]\n    stack2 = []\n    \n    fast = slow \n    slow = head\n    while fast:\n        stack2.append(slow.val)\n        stack1.append(fast.val)\n        fast = fast.next\n        slow = slow.next \n        \n    stack2.reverse()\n    return stack1 == stack2\n"}, {"question": "Given the head of a singly linked list and an integer k, split the linked list into k consecutive linked list parts.\n\nThe length of each part should be as equal as possible: no two parts should have a size differing by more than one. This may lead to some parts being null.\n\nThe parts should be in the order of occurrence in the input list, and parts occurring earlier should always have a size greater than or equal to parts occurring later.\n\nReturn an array of the k parts.\nDefinition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n", "code": "\ndef splitListToParts(head, k):\n    cur = head\n    N = 0\n    while cur:\n        N += 1\n        cur = cur.next\n    width, remainder = divmod(N, k)\n\n    ans = []\n    cur = head\n    for i in range(k):\n        head = cur\n        for j in range(width + (i < remainder) - 1):\n            if cur: cur = cur.next\n        if cur:\n            cur.next, cur = None, cur.next\n        ans.append(head)\n    return ans\n"}, {"question": "Given the head of a singly linked list, return the middle node of the linked list.\n\nIf there are two middle nodes, return the second middle node.\nDefinition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n", "code": "\ndef middleNode(head):\n    slow = fast = head\n    while fast and fast.next:\n        slow = slow.next\n        fast = fast.next.next\n    return slow\n"}, {"question": "You are given the head of a linked list, and an integer k.\n\nReturn the head of the linked list after swapping the values of the kth node from the beginning and the kth node from the end (the list is 1-indexed).\nDefinition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n", "code": "\ndef swapNodes(self, head, k):\n    node1 = node2 = fast = head\n    #Finding kth node from the start \n    k-=1\n    while (k):\n        node1 = node1.next\n        fast = fast.next\n        k-=1\n\n    #Finding kth node from the end\n    while (fast and fast.next):\n        node2 = node2.next\n        fast = fast.next\n\n    #Swapping the values only\n    temp = node1.val\n    node1.val = node2.val\n    node2.val = temp\n\n    return head\n"}]