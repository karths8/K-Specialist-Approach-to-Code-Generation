[{"question": " Given a queue reverse it\n", "code": "\nfrom collections import deque\ndef reverse(queue: deque):\n    if not len(queue) == 0:\n        temp = queue.pop()\n        reverse(queue)\n        queue.appendleft(temp)\n"}, {"question": "Given a root treenode convert the entire tree into a list of values such that the nth entry has children 2*n+1 and 2*n+2.\nclass TreeNode(object):\n    def __init__(self, val=0, left=None, ight=None):\n        self.val = val\n        self.left = left\n        self.right = right\n", "code": "\nclass TreeNode(object):\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef tree_to_list(root: TreeNode):\n    ret = []\n    if root is None:\n        return ret\n    cur_queue = [root]\n    still_nodes = True\n    while still_nodes:\n        still_nodes = False\n        next_queue = []\n        for node in cur_queue:\n            left = None\n            right = None\n            if node is not None:\n                left = node.left\n                right = node.right\n                ret.append(node.val)\n            else:\n                ret.append(None)\n            next_queue.append(left)\n            next_queue.append(right)\n            if left is not None or right is not None:\n                still_nodes = True\n        cur_queue = next_queue\n    return ret\n"}, {"question": "Design your implementation of the circular queue. The circular queue is a linear data structure in which the operations are performed based on FIFO (First In First Out) principle, and the last position is connected back to the first position to make a circle. It is also called \"Ring Buffer\".\n\nImplement the MyCircularQueue class:\n\nMyCircularQueue(k) Initializes the object with the size of the queue to be k.\nint Front() Gets the front item from the queue. If the queue is empty, return -1.\nint Rear() Gets the last item from the queue. If the queue is empty, return -1.\nboolean enQueue(int value) Inserts an element into the circular queue. Return true if the operation is successful.\nboolean deQueue() Deletes an element from the circular queue. Return true if the operation is successful.\nboolean isEmpty() Checks whether the circular queue is empty or not.\nboolean isFull() Checks whether the circular queue is full or not.\n", "code": "\nclass MyCircularQueue:\n    def __init__(self, k):\n        self.size=k\n        self.q=[0]*k\n        self.front=-1\n        self.rear=-1\n\n    def enQueue(self, value):\n        if self.isFull():\n            return False\n        if self.isEmpty():\n            self.front=self.rear=0\n        else:\n            self.rear=(self.rear+1)%self.size\n        self.q[self.rear]=value\n        return True\n\n    def deQueue(self):\n        if self.isEmpty():\n            return False\n        item=self.q[self.front]\n        if self.front==self.rear:\n            self.front=self.rear=-1\n        else:\n            self.front=(self.front+1)%self.size\n        return True\n\n    def Front(self):\n        if self.front==-1:\n            return -1\n        return self.q[self.front]\n\n    def Rear(self):\n        if self.rear==-1:\n            return -1\n        return self.q[self.rear]\n\n    def isEmpty(self):\n        return self.front==-1\n\n    def isFull(self):\n        if self.front==0 and self.rear==self.size-1:\n            return True\n        if self.rear==(self.front-1)%(self.size):\n            return True\n        return False\n"}, {"question": "\nDesign a queue that supports push and pop operations in the front, middle, and back.\n\nImplement the FrontMiddleBack class:\n\nFrontMiddleBack() Initializes the queue.\nvoid pushFront(int val) Adds val to the front of the queue.\nvoid pushMiddle(int val) Adds val to the middle of the queue.\nvoid pushBack(int val) Adds val to the back of the queue.\nint popFront() Removes the front element of the queue and returns it. If the queue is empty, return -1.\nint popMiddle() Removes the middle element of the queue and returns it. If the queue is empty, return -1.\nint popBack() Removes the back element of the queue and returns it. If the queue is empty, return -1.\nNotice that when there are two middle position choices, the operation is performed on the frontmost middle position choice\n", "code": "\nclass FrontMiddleBackQueue(object):\n    def __init__(self):\n        self.queue=[]\n\n    def pushFront(self, val):\n        self.queue.insert(0,val)\n\n    def pushMiddle(self, val):\n        mid=(len(self.queue))//2\n        self.queue.insert(mid,val)\n    \n    def pushBack(self, val):\n        self.queue.append(val)\n\n    def popFront(self):\n        if len(self.queue)==0:\n            return -1\n        else:\n            res=self.queue.pop(0)\n            return res\n    \n    def popMiddle(self):\n        if len(self.queue)==0:\n            return -1\n        else:\n            mid=(len(self.queue)-1)//2\n            res=self.queue.pop(mid)\n            return res\n    \n    def popBack(self):\n        if len(self.queue)==0:\n            return -1\n        else:\n            res=self.queue.pop()\n            return res\n"}, {"question": "You are given a string s and an integer k. You can choose one of the first k letters of s and append it at the end of the string.\n\nReturn the lexicographically smallest string you could have after applying the mentioned step any number of moves.\n", "code": "\ndef orderlyQueue(s: str, k: int) -> str:\n    if k == 1:\n        n = len(s)\n        ss = s + s\n        lex_min_str = s\n        for i in range(n):\n            lex_min_str = min(lex_min_str, ss[i:i + n])\n        return lex_min_str\n    \n    return \"\".join(sorted(s))\n"}]