[{"question": "Return nth number in the fibonacci sequence", "code": "\ndef fib(n, a=0, b=1):\n  if n <= 0:\n    return b\n  c = a + b\n  a = b\n  b = c\n  return fib(n-1, a, b)\n"}, {"question": "Return the factorial of a given number n", "code": "\ndef fact(n):\n  if n <= 1:\n    return 1\n  return n*fact(n)\n"}, {"question": "Given a numerator and a denominator return the fraction in string format. If the fractional part is repeating enclose the repeating part in parentheses", "code": "\ndef helper(cur, numerator, denominator, numerators_seen):\n  if numerator == 0:\n    return cur\n  elif numerator in numerators_seen.keys():\n    idx = numerators_seen[numerator]\n    return cur[:idx] + '(' + cur [idx:] + ')'\n  numerators_seen[numerator] = len(cur)\n  if numerator >= denominator:\n    cur += str(numerator // denominator)\n    numerator = numerator % denominator\n    return helper(cur, numerator*10, denominator, numerators_seen)\n  else:\n    cur += \"0\"\n    return helper(cur, numerator*10, denominator, numerators_seen)\n\ndef fractionToDecimal(numerator, denominator):\n  cur = \"\"\n  if numerator == 0:\n    return \"0\"\n  elif (numerator < 0 and denominator > 0) or (numerator > 0 and denominator < 0):\n    cur = \"-\"\n  numerator = abs(numerator)\n  denominator = abs(denominator)\n  if numerator >= denominator:\n    cur += str(numerator // denominator)\n    numerator = numerator % denominator\n    if numerator != 0:\n      cur += \".\"\n      return helper(cur, numerator*10, denominator, dict())\n    else:\n      return cur\n  else:\n    cur += \"0.\"\n    return helper(cur, numerator*10, denominator, dict())\n"}, {"question": "You are given the root of a binary search tree (BST), where the values of exactly two nodes of the tree were swapped by mistake. Recover the tree without changing its structure.\nDefinition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, val=0, left=None, ight=None):\n        self.val = val\n        self.left = left\n        self.right = right\n", "code": "\ndef forward(root, n):\n    if root is None:\n        return\n    ret = forward(root.left, n)\n    if ret:\n        return ret\n    \n    if not n:\n        n.append(root)\n    elif root.val < n[0].val:\n        return n[0]\n    else:\n        n[0] = root\n    \n    ret = forward(root.right, n)\n    if ret:\n        return ret\n    \ndef backward(root, n):\n    if root is None:\n        return\n    \n    ret = backward(root.right, n)\n    if ret:\n        return ret\n    \n    if not n:\n        n.append(root)\n    elif root.val > n[0].val:\n        return n[0]\n    else:\n        n[0] = root\n    \n    ret = backward(root.left, n)\n    if ret:\n        return ret\n    \ndef recoverTree(root):\n    x, y = forward(root, []), backward(root, [])\n    x.val, y.val = y.val, x.val\n    return root\n"}, {"question": "Given a list of values output a root binary tree node with appropiate children. None should not have a Tree Node created for them.\nDefinition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, val=0, left=None, ight=None):\n        self.val = val\n        self.left = left\n        self.right = right\n", "code": "\nclass TreeNode(object):\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef createTree(nums):\n   if len(nums) == 0:\n      return None\n   def helper(cur):\n      if cur >= len(nums):\n         return None\n      left = helper(cur*2+1)\n      right = helper(cur*2+2)\n      if nums[cur] is not None:\n        return TreeNode(nums[cur], left, right)\n      else:\n         return None\n   return helper(0)\n"}]